tiny forth

description
-----------

implémentation d'un mini forth sur PIC32MX110F016B. Le systÃ¨me forth fonctionne
sur une machine virtuelle à  piles qui utilise des tokens encodés sur 1 octet.
Le modèle d'exécution de la machine virtuelle est conçu pour que le forth s'y
adapte naturellement. 

La liste des mnémoniques de la machine virtuelle et le hash résultant est dans
le fichier 'tokens-hash.txt'.

symboles:
les mnénoniques de la VM ainsi que les mot du forth sont hashé sur un entier 32 bits
qui limite la longueur des symboles à  5 caractères ASCII compris entre ASCII 33 et 126.
Les lettres mininuscules sont converties en majuscules ce qui fait 68 symboles. 
La fonction hash converti simplement les symboles en entier comme s'il s'agissait de
nombres en base 68. La recherche des symboles ce fait sur ce hash par comparison d'entier.


limitation:
Du à  la faible quantité de mémoire disponible sur le PIC32MX110F016B le système est conçu
d'abord pour réduire l'utilisation de l'espace mémoire. 

La machine virtuelle est écrite en assembleur mais le reste est écris en 'C'.

S: pile des données
R: pile des retours

t=-1
f=0
p pointeur
n entier

 codes machine virtuelle
--------------------------------
code    mnémo       description
=================================
0       end         termine l'exécution
1       ?key        vérifie s'il a un caractère dans buffer d'entrée
2       emit        ( char -- ) émet le charactère qui se trouve au sommet de la pile vers STDOUT
3       lit n       ( -- n)  empile le nombre n
4       fcall addr  appelle la sous-routine en code IL qui se trouve dans la mémoire FLASH
5       ret         sortie de sous-routine IL
6       bra r-addr  branchement à l'adresse relative r-addr  déplacement ±127 octets
7       ?bra r-addr ( t|f -- ) branche si sommet pile=t, déplacement relativ ±127 octets
8       exec        ( addr -- )  appelle sous-routine IL addr
9       !           ( n addr -- ) enregistre n dans la mémoire addr
10      @           ( addr -- n ) empile la valeur qui se trouve à addr
11      c!          ( char addr -- ) enregistre le caractère à l'addresse
12      c@          ( addr -- n ) empile le caractère qui est à addr
13      rp@         ( -- p ) empile le pointeur de la pile retour
14      rp!         ( p -- ) initialise le pointeur de retour avec p
15      r@          ( -- n ) empile la valeur au sommet de R:
16      >r          ( n -- ) (R: -- n)  transfert n de S: à R:
17      r>          ( -- n) (R: n -- ) transfert n de R: à S:
18      sp@         ( -- p) empile le pointeur de S:
19      sp!         ( p -- ) initialise le pointeur de S: avec p
20      drop        ( n -- ) jette le sommet de S:
21      dup         ( n -- n n ) créé une copie du sommet de S:
22      swap        ( n1 n2 -- n2 n1 ) interchange les 2 valeurs au sommet de S:
23      over        ( n1 n2 -- n1 n2 n1 ) empile une copie de n1
24      +           ( n1 n2 -- n3 ) n3=n1+n2
25      -           ( n1 n2 -- n3 ) n3=n1-n2
26      *           ( n1 n2 -- n3 ) n3=n1*n2
27      /           ( n1 n2 -- n3 ) n2=n1/n2
28      mod         ( n1 n2 -- n3 ) n3=n1%n2 le reste de la division n1/n2
29      0<          ( n -- t|f ) vérifie si n<0 et le remplace par t ou f
30      and         ( n1 n2 -- n3 ) et bit à bit entre n1 et n2
31      or          ( n1 n2 -- n3 ) ou bit à bit entre n1 et n2
32      xor         ( n1 n2 -- n3 ) ou exclusif bit à bit entre n1 et n2
33      not         ( n1 -- ~n1 )  inversion des bits de n1
34      key         ( -- char ) lecture d'un caractère sur STDIN
35      sfr         ( lo -- hilo ) la valeur 0xBF88 est concaténé à lo qui est la partie basse de l'adresse du SFR
36      clear       ( bits sfr -- ) met à zéro les bits du SFR (special function register)
37      set         ( bits sfr -- ) met à 1 les bits du SFR
38      inv         ( bits sfr -- ) inverse les bits du SFR
39      clit octet  ( -- n ) empile l'octet
40      wlit word   ( -- n ) empile le mot de 16 bits
41      ."  text"   ( -- )  envoie le text vers STDOUT
42      readl       ( addr max -- count ) lectures d'une chaine sur STDIN
43      rcall       ( addr -- ) appelle de sous-routine IL en mémoire RAM
44      type        ( count buff -- ) envoie les 'count' caractères qui sont dans 'buff' vers STDOUT
45      delay       ( n -- ) suspend l'exécution pour n milli-secondes
46      ?dup        ( n -- n n | 0 ) si n<>0 empile un copie de n
47      +1          ( n1 -- n2 )  incrément n1 de 1
48      -1          ( n1 -- n2 ) décrmente n1 de 1
49      +!          ( n addr -- ) ajoute n à la valeur qui se trouve à 'addr'
50      2drop       ( n1 n2 -- ) jette les 2 élément au sommet de S:
51      rot         ( n1 n2 n3 -- n3 n1 n2 ) rotation des 3 éléments au sommet de S:
52      2dup        ( n1 n2 -- n1 n2 ) empile une copie des 2 éléments au sommet de S:
53      min         ( n1 n2 -- n ) ne garde que le plus petit des 2 nombres
54      max         ( n1 n2 -- n ) ne garde que le plus grand des 2 nombres
55      abs         ( n -- n ) valeur absolue de n
56      <<          ( n1 u -- n3 ) n3 = n1 << u
57      >>          ( n1 u -- n3 ) n3 = n1 >> u
58      /mod        ( n1 n2 -- r q ) r = reste de n1/n2  q = quotient de n1/n2
59      ?braz addr  ( n -- ) branchement vers 'addr' si n==0
60      .           ( n -- ) imprime l'entier n vers STDOUT
61      zsp         ( -- p ) retourne pointeur vers la position vide de S:
62      zrp         ( -- p ) retourne le pointeur vers la position vide de R:
63      here        ( -- addr ) retourne l'adresse de la variable 'here'
64      base        ( -- addr ) retourne l'adresse de la variable 'base'
65      =           ( n1 n2 -- t|f ) test si n1==n2
66      <>          ( n1 n2 -- t|fr ) test si n1<>n2
67      <           ( n1 n2 -- t|f ) test n1<n2
68      >           ( n1 n2 -- t|f ) test n1>n2
69      <=          ( n1 n2 -- t|f ) test si n1<=n2
70      >=          ( n1 n2 -- t|f ) test si n>=n2
71      iemit       ( n -- ) envoie l'entier en little indian vers STDOUT

