Disassembly Listing for eForth_test
Generated From:
C:/Users/Jacques/Documents/GitHub/VPC-32.X/resources/eForth-mips/eForth_test.X/dist/default/production/eForth_test.X.production.elf
2013-09-15 21:37:38

---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/uart.h  ---------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: Constants & Data Types
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  //DOM-IGNORE-BEGIN
74:                  /****
75:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
76:                         the device file.  Also the UART register set could also be placed there
77:                  *****/
78:                  typedef struct
79:                  {
80:                  	volatile UINT	reg;
81:                  	volatile UINT	clr;
82:                  	volatile UINT	set;
83:                  	volatile UINT	inv;
84:                  }REG_SET;
85:                  
86:                  typedef struct
87:                  {
88:                  	volatile REG_SET	mode;
89:                  	volatile REG_SET	sta;
90:                  	volatile REG_SET    tx;
91:                  	volatile REG_SET	rx;
92:                  	volatile REG_SET	brg;
93:                  }UART_REGS;
94:                  
95:                  extern UART_REGS * const uartReg[];
96:                  //DOM-IGNORE-END
97:                  
98:                  // *****************************************************************************
99:                  /* UART Module
100:                 
101:                   Summary:
102:                     UART modules supported.
103:                 
104:                   Description:
105:                     This enumeration identifies the available UART modules.
106:                 */
107:                 
108:                 typedef enum
109:                 {
110:                 #if defined _UART1
111:                     // UART1 Module ID.
112:                     UART1 = 0,
113:                 #endif
114:                 #if defined _UART2
115:                     // UART2 Module ID.
116:                     UART2,
117:                 #endif
118:                 #ifdef _UART3
119:                     // UART3 Module ID.
120:                     UART3,
121:                 #endif
122:                 #ifdef _UART4
123:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
124:                     UART4,
125:                 #endif
126:                 #ifdef _UART5
127:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
128:                     UART5,
129:                 #endif
130:                 #ifdef _UART6
131:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
132:                     UART6,
133:                 #endif
134:                     // Number of available UART modules.
135:                     UART_NUMBER_OF_MODULES
136:                 
137:                 } UART_MODULE;
138:                 
139:                 
140:                 // *****************************************************************************
141:                 /* UART Enable Modes
142:                 
143:                   Summary:
144:                     Operating modes of UART.
145:                 
146:                   Description:
147:                     This enumeration defines the supported modes in which the UART may be
148:                     enabled or disbled.
149:                 
150:                   Remarks:
151:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
152:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
153:                     has been pre-loaded with data.
154:                 
155:                     The caller should not rely on the specific numbers assigned to any of these
156:                     values as they may change from one processor to the next.
157:                 */
158:                 
159:                 typedef enum
160:                 {
161:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
162:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
163:                 
164:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
165:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
166:                 
167:                 
168:                     // UART Module, receiver and transmitter functionality is not.
169:                     // enabled or disabled
170:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
171:                 
172:                     // UART Module receiver.
173:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
174:                 
175:                     // UART Module transmitter.
176:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
177:                 
178:                 
179:                 } UART_ENABLE_MODE;
180:                 
181:                 // *****************************************************************************
182:                 /* UART Enable Helper Macro
183:                 
184:                   Summary:
185:                     Macro for enabling module operating modes.
186:                 
187:                   Description:
188:                     This macro creates the proper flags for enabling operating modes of the UART module.
189:                 
190:                   Example:
191:                     <code>
192:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
193:                     </code>
194:                 
195:                   Remarks:
196:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
197:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
198:                     has been pre-loaded with data.
199:                 */
200:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
201:                 
202:                 // *****************************************************************************
203:                 /* UART Disable Helper Macro
204:                 
205:                   Summary:
206:                     Macro for disabling module operating modes.
207:                 
208:                   Description:
209:                     This macro creates the proper flags for disabling operating modes of the UART module.
210:                 
211:                   Example:
212:                     <code>
213:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
214:                     </code>
215:                 
216:                 */
217:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
218:                 
219:                 // *****************************************************************************
220:                 /* UART Configuration Settings
221:                 
222:                   Summary:
223:                     Supported configuration flags for the UART module.
224:                 
225:                   Description:
226:                     This enumeration defines the various configuration options for the UART
227:                     module.  These values can be OR'd together to create a configuration mask
228:                     passed to the UARTConfigure routine.
229:                 
230:                   Remarks:
231:                     Several of the configuration options are mutually exclusive:
232:                     * Only one of the "ENABLE_PINS" modes can be used at a time
233:                     * Only one of the "RTS_WHEN" modes can be used at a time
234:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
235:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
236:                 
237:                     The caller should not rely on the specific numbers assigned to any of these
238:                     values as they may change from one processor ot the next.
239:                 */
240:                 
241:                 typedef enum
242:                 {
243:                     // Enables high-speed range of the UART (see UARTSetBitRate).
244:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
245:                 
246:                     // Inverts polarity of data interpretation the received (RX) pin.
247:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
248:                 
249:                     // Enables UART TX-to-RX Loop-back mode.
250:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
251:                 
252:                     // Enables Wake-up of the part when a start bit is received.
253:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
254:                 
255:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
256:                     // cannot be used in bit-clock/IrDA mode).
257:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
258:                 
259:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
260:                     // cannot be used in CTS/RTS mode).
261:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
262:                 
263:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
264:                     // be used in RTS-Only mode).
265:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
266:                 
267:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
268:                     // the default mode and this parameter can be left out if it is desired).
269:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
270:                 
271:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
272:                     // is not full (i.e., the UART is ready to receive data).  This is also known
273:                     // as "RTS Flow-Control Mode".
274:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
275:                 
276:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
277:                     // is not empty (i.e., when the UART has data ready to send).  This is also
278:                     // known as "RTS Simplex Mode".
279:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
280:                 
281:                     // Enable the IrDA encoder/decoder.
282:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
283:                 
284:                     // Enables stopping of the UART operation to save power when the core has
285:                     // been put in idle mode.
286:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
287:                 
288:                     // Inverts the polarity of data sent on the transmit (TX) pin.
289:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
290:                 
291:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
292:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
293:                     // Note:  The address must still be set using UARTEnableAddressDetect
294:                     // to support IEEE-485 protocol.
295:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
296:                 
297:                 } UART_CONFIGURATION;
298:                 
299:                 
300:                 // *****************************************************************************
301:                 /* UART FIFO Modes
302:                 
303:                   Summary:
304:                     Supported FIFO modes for the UART module.
305:                 
306:                   Description:
307:                     This enumeration defines supported FIFO modes that determine when the Tx
308:                     and Rx interrupts will occur.
309:                 
310:                   Remarks:
311:                     These modes consist of two sets of mutially exclusive modes:
312:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
313:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
314:                 
315:                     The caller should not rely on the specific numbers assigned to any of these
316:                     values as they may change from one processor ot the next.
317:                 
318:                 */
319:                 
320:                 typedef enum
321:                 {
322:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
323:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
324:                 
325:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
326:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
327:                 
328:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
329:                     // full (i.e. there is space available for more data)  This is the default.
330:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
331:                 
332:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
333:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
334:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
337:                     // (three-quarter) full.
338:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
339:                 
340:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
341:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
342:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
343:                 
344:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
345:                     // data.
346:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
347:                 
348:                 } UART_FIFO_MODE;
349:                 
350:                 
351:                 // *****************************************************************************
352:                 /* UART Line Control Mode
353:                 
354:                   Summary:
355:                     UART line control mode.
356:                 
357:                   Description:
358:                     This data type defines the supported line control modes for the UART.
359:                 
360:                   Remarks:
361:                     Some of the line-control options are mutually exclusive:
362:                     * Only one of the "DATA_SIZE" options can be used at a time
363:                     * Only one of the "PARITY" options can be used at a time
364:                     * Only one of the "STOP_BITS" options can be used at a time
365:                 
366:                     The caller should not rely on the specific numbers assigned to any of these
367:                     values as they may change from one processor ot the next.
368:                 */
369:                 
370:                 typedef enum
371:                 {
372:                     // Sets the data transfer size to 8-bits per frame.
373:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
374:                 
375:                     // Sets the data transfer size to 9-bits per frame.
376:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
377:                 
378:                     // Enables parity bit generation for odd parity.
379:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
380:                 
381:                     // Enables parity bit generation for even parity.
382:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
383:                 
384:                     // Disables parity bit generation.
385:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
386:                 
387:                     // Enables generation of 2 stop bits per frame.
388:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
389:                 
390:                     // Enables generation of 1 stop bit per frame (default).
391:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
392:                 
393:                 } UART_LINE_CONTROL_MODE;
394:                 
395:                 
396:                 // *****************************************************************************
397:                 /* UART Line Status Flags
398:                 
399:                   Summary:
400:                     UART line-status bitmask flags.
401:                 
402:                   Description:
403:                     This enumeration defines the UART line-status bits.  These values are
404:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
405:                 
406:                   Remarks:
407:                     The caller should not rely on the specific numbers assigned to any of these
408:                     values as they may change from one processor ot the next.
409:                 */
410:                 
411:                 typedef enum
412:                 {
413:                     // The transmitter is able to accept data to transmit.
414:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
415:                 
416:                     // The transmitter is empty (no data is available to transmit).
417:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
418:                 
419:                     // The receiver is currently idle.
420:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
421:                 
422:                     // A received data parity error was detected.
423:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
424:                 
425:                     // Data was received that violated the framing protocol (the data word did
426:                     // not start or stop at the appropriate place).  Note:  A break condition
427:                     // will always indicate a framing error.
428:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
429:                 
430:                     // The UART has received more data than it can buffer.  Data has been lost.
431:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
432:                 
433:                     // UART data has been received and is avaiable in the FIFO.
434:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
435:                 
436:                 } UART_LINE_STATUS;
437:                 
438:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
439:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
440:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
441:                 
442:                 
443:                 
444:                 // *****************************************************************************
445:                 /* UART Data
446:                 
447:                   Summary:
448:                     UART data.
449:                 
450:                   Description:
451:                     This data type defines the supported data sizes for the UART.
452:                 */
453:                 
454:                 typedef union
455:                 {
456:                     // 8-bit data
457:                     struct
458:                     {
459:                         UINT16  data8bit    : 8;
460:                     };
461:                 
462:                     // 9-bit data
463:                     struct
464:                     {
465:                         UINT16  data9bit    : 9;
466:                     };
467:                 
468:                     UINT16 __data;
469:                 } UART_DATA;
470:                 
471:                 
472:                 // *****************************************************************************
473:                 // *****************************************************************************
474:                 // Section: UART Peripheral Library Interface Routines
475:                 // *****************************************************************************
476:                 // *****************************************************************************
477:                 
478:                 
479:                 /*******************************************************************************
480:                   Function:
481:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
482:                 
483:                   Summary:
484:                     Enables or disables the given UART module in the desired mode.
485:                 
486:                   Description:
487:                     This routine enables or disables the given UART module in the desired mode.
488:                 
489:                   Precondition:
490:                     The UART module should be appropriately configured before being enabled.
491:                 
492:                   Parameters:
493:                     id    - Identifies the desired UART module.
494:                 
495:                     mode  - Identifies the desired mode of UART operation.
496:                 
497:                   Returns:
498:                     None
499:                 
500:                   Example:
501:                     <code>
502:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
503:                     </code>
504:                 
505:                   Remarks:
506:                     Enabling UART transmissions will immediately cause a TX interrupt to
507:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
508:                     was pre-loaded with data.
509:                   *****************************************************************************/
510:                 
511:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
512:                 
513:                 
514:                 /*******************************************************************************
515:                   Function:
516:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
517:                 
518:                   Summary:
519:                     UART module configuration routine.
520:                 
521:                   Description:
522:                     This routine allows the caller to configure various features of the UART
523:                     module for desired operation.
524:                 
525:                   Precondition:
526:                     None
527:                 
528:                   Parameters:
529:                     id      - Identifies the desired UART module.
530:                 
531:                     flags   - Bit-wise OR of the desired module configuration settings.
532:                 
533:                   Returns:
534:                     None
535:                 
536:                   Example:
537:                     <code>
538:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
539:                     </code>
540:                 
541:                   Remarks:
542:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
543:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
544:                     of these values will result in a value that is not explicitly defined in
545:                     the enumeration.
546:                   *****************************************************************************/
547:                 
548:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
549:                 
550:                 
551:                 /*******************************************************************************
552:                   Function:
553:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
554:                 
555:                   Summary:
556:                     Controls UART module TX and RX FIFO operation.
557:                 
558:                   Description:
559:                     This routine allows the caller to configure when interrupts occur relative
560:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
561:                     or empty the FIFOs are).
562:                 
563:                   Precondition:
564:                     None
565:                 
566:                   Parameters:
567:                     id      - Identifies the desired UART module.
568:                 
569:                     mode    - Bit-wise OR of the desired FIFO mode values.
570:                 
571:                   Returns:
572:                     None
573:                 
574:                   Example:
575:                     <code>
576:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
577:                     </code>
578:                 
579:                   Remarks:
580:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
581:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
582:                     of these values will result in a value that is not explicitly defined in
583:                     the enumeration.
584:                   *****************************************************************************/
585:                 
586:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
587:                 
588:                 
589:                 /*******************************************************************************
590:                   Function:
591:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
592:                 
593:                   Summary:
594:                     Routine to set the UART module's desired data data rate.
595:                 
596:                   Description:
597:                     This routine allows the caller to set the desired data rate for the UART.
598:                 
599:                   Precondition:
600:                     The source clock's frequency must be operating at the frequency passed in the
601:                     "sourceClock" parameter.
602:                 
603:                   Parameters:
604:                     id          - Identifies the desired UART module.
605:                 
606:                     sourceClock - Frequency (Hz) of the source clock being provided to the
607:                                   UART module.
608:                 
609:                     dataRate     - Desired data rate (bits per second).
610:                 
611:                   Returns:
612:                     Actual bit rate selected
613:                 
614:                   Example:
615:                     <code>
616:                 	#define PERIPHERAL_CLOCK    10000000
617:                 	#define DESIRED_DATA_RATE   19200
618:                 	
619:                 	UINT32    actualDataRate;
620:                 
621:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
622:                     </code>
623:                 
624:                   Remarks:
625:                     Actual data rate selected may be slightly different than the data rate
626:                     requested due to truncation error.
627:                 
628:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
629:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
630:                     the maximum data rate is sourceClock/4.
631:                   *****************************************************************************/
632:                 
633:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
634:                 
635:                 
636:                 /*******************************************************************************
637:                   Function:
638:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
639:                 
640:                   Summary:
641:                     Routine to get the UART module's current data data rate.
642:                 
643:                   Description:
644:                     This routine allows the caller to get the current data rate for the UART module.
645:                 
646:                   Precondition:
647:                     The source clock's frequency must be operating at the frequency passed in the
648:                     "sourceClock" parameter.
649:                 
650:                   Parameters:
651:                     id          - Identifies the desired UART module.
652:                 
653:                     sourceClock - Frequency (Hz) of the source clock being provided to the
654:                                   UART module.
655:                 
656:                   Returns:
657:                     The UART's current data rate (bits per second).
658:                 
659:                   Example:
660:                     <code>
661:                 	#define PERIPHERAL_CLOCK    10000000
662:                 	
663:                 	UINT32    currentDataRate;
664:                 
665:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
666:                     </code>
667:                 
668:                   Remarks:
669:                     The current (actual) data rate returned may be slightly different than bit
670:                     rate requested due to truncation error.
671:                   *****************************************************************************/
672:                 
673:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
674:                 
675:                 
676:                 /*******************************************************************************
677:                   Function:
678:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
679:                 
680:                   Summary:
681:                     Routine to set the UART module's desired line control parameters.
682:                 
683:                   Description:
684:                     This routine allows the caller to select the desired size of the UART data
685:                     frame, the generation of parity and framing parameters (collectively
686:                     referred to as the "line control" mode).
687:                 
688:                   Precondition:
689:                 
690:                   Parameters:
691:                     id      - Identifies the desired UART module.
692:                 
693:                     mode    - This is a bit-wise OR of the desired line control mode flags.
694:                 
695:                   Returns:
696:                     None
697:                 
698:                   Example:
699:                     <code>
700:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
701:                     </code>
702:                 
703:                   Remarks:
704:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
705:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
706:                     of these values will result in a value that is not explicitly defined in
707:                     the enumeration.
708:                   *****************************************************************************/
709:                 
710:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
711:                 
712:                 
713:                 /*******************************************************************************
714:                   Function:
715:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
716:                 
717:                   Summary:
718:                     Provides current UART line status.
719:                 
720:                   Description:
721:                     This routine allows the caller to get the current line status of the UART,
722:                     indicating the current state of the transmitter and receiver buffers, and
723:                     if any errors have occurred.
724:                 
725:                   Precondition:
726:                     None
727:                 
728:                   Parameters:
729:                     id      - Identifies the desired UART module.
730:                 
731:                   Returns:
732:                     A bit-wise OR of the current line status flags.
733:                 
734:                   Example:
735:                     <code>
736:                     UART_LINE_STATUS lineStatus;
737:                 	
738:                 	lineStatus = UARTGetLineStatus(UART1);
739:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
740:                     {
741:                         // Handle receiver error
742:                     }
743:                     </code>
744:                 
745:                   Remarks:
746:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
747:                     status flag.
748:                 
749:                     The receiver line status flags are only valid when data has been received
750:                     and for the data at the top of the RX FIFO.
751:                 
752:                     Note that the bitmask resulting from the bit-wise OR of these values will
753:                     result in a value that is not explicitly defined in the enumeration.
754:                   *****************************************************************************/
755:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
756:                 {
757:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
758:                 }
759:                 
760:                 
761:                 /*******************************************************************************
762:                   Function:
763:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
764:                 
765:                   Summary:
766:                     Routine to detect if the transmitter is ready to accept data to transmit.
767:                 
768:                   Description:
769:                     This routine determines if the transmitter is ready to accept more data to
770:                     be transmitted.
771:                 
772:                   Precondition:
773:                     The UART module should have been appropriately configured and enabled.
774:                 
775:                   Parameters:
776:                     id      - Identifies the desired UART module.
777:                 
778:                   Returns:
779:                     Boolean identifying whether or not the transmitter is ready:
780:                     * TRUE    - If the transmitter is ready to accept more data
781:                     * FALSE   - If the transmitter is not ready to accept more data
782:                 
783:                   Example:
784:                     <code>
785:                     unsigned char data;
786:                 	
787:                 	data = 'a';
788:                 	
789:                 	if (UARTTransmitterIsReady(UART1))
790:                     {
791:                         UARTSendDataByte(UART1, data);
792:                     }
793:                     </code>
794:                 
795:                   Remarks:
796:                   *****************************************************************************/
797:                 
798:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
799:                 {
800:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D00A5E0  3C029D01   LUI V0, -25343
9D00A5E4  8FC30000   LW V1, 0(S8)
9D00A5E8  00031880   SLL V1, V1, 2
9D00A5EC  2442CDEC   ADDIU V0, V0, -12820
9D00A5F0  00621021   ADDU V0, V1, V0
9D00A5F4  8C420000   LW V0, 0(V0)
9D00A5F8  8C420010   LW V0, 16(V0)
9D00A5FC  30420200   ANDI V0, V0, 512
9D00A600  14400004   BNE V0, ZERO, 0x9D00A614
9D00A604  00000000   NOP
9D00A608  24020001   ADDIU V0, ZERO, 1
9D00A60C  0B402986   J 0x9D00A618
9D00A610  00000000   NOP
9D00A614  00001021   ADDU V0, ZERO, ZERO
9D00A7D8  3C029D01   LUI V0, -25343
9D00A7DC  8FC30000   LW V1, 0(S8)
9D00A7E0  00031880   SLL V1, V1, 2
9D00A7E4  2442CDEC   ADDIU V0, V0, -12820
9D00A7E8  00621021   ADDU V0, V1, V0
9D00A7EC  8C420000   LW V0, 0(V0)
9D00A7F0  8C420010   LW V0, 16(V0)
9D00A7F4  30420200   ANDI V0, V0, 512
9D00A7F8  14400004   BNE V0, ZERO, 0x9D00A80C
9D00A7FC  00000000   NOP
9D00A800  24020001   ADDIU V0, ZERO, 1
9D00A804  0B402A04   J 0x9D00A810
9D00A808  00000000   NOP
9D00A80C  00001021   ADDU V0, ZERO, ZERO
801:                 }
802:                 
803:                 
804:                 /*******************************************************************************
805:                   Function:
806:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
807:                 
808:                   Summary:
809:                     Routine to send a byte of data.
810:                 
811:                   Description:
812:                     This routine allows the caller to send a byte of data.
813:                 
814:                   Precondition:
815:                     The UART should have been appropriately configured.  The configuration must
816:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
817:                     have been ready, although not necessarily enabled yet.
818:                 
819:                   Parameters:
820:                     id      - Identifies the desired UART module.
821:                 
822:                     data    - Data byte to be sent.
823:                 
824:                   Returns:
825:                     None
826:                 
827:                   Example:
828:                     <code>
829:                 	unsigned char data;
830:                 	
831:                 	data = 'a';
832:                 	
833:                     if (UARTTransmitterIsReady(UART1))
834:                     {
835:                         UARTSendDataByte(UART1, data);
836:                     }
837:                     </code>
838:                 
839:                   Remarks:
840:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
841:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
842:                     data.
843:                   *****************************************************************************/
844:                 
845:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
846:                 {
847:                     uartReg[id]->tx.reg = data;
9D00A630  3C029D01   LUI V0, -25343
9D00A634  8FC30004   LW V1, 4(S8)
9D00A638  00031880   SLL V1, V1, 2
9D00A63C  2442CDEC   ADDIU V0, V0, -12820
9D00A640  00621021   ADDU V0, V1, V0
9D00A644  8C420000   LW V0, 0(V0)
9D00A648  93C30008   LBU V1, 8(S8)
9D00A64C  AC430020   SW V1, 32(V0)
9D00A83C  3C029D01   LUI V0, -25343
9D00A840  8FC30004   LW V1, 4(S8)
9D00A844  00031880   SLL V1, V1, 2
9D00A848  2442CDEC   ADDIU V0, V0, -12820
9D00A84C  00621021   ADDU V0, V1, V0
9D00A850  8C420000   LW V0, 0(V0)
9D00A854  93C30008   LBU V1, 8(S8)
9D00A858  AC430020   SW V1, 32(V0)
848:                 }
849:                 
850:                 
851:                 /*******************************************************************************
852:                   Function:
853:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
854:                 
855:                   Summary:
856:                     Routine to send data through the UART.
857:                 
858:                   Description:
859:                     This routine allows the caller to send data of any permitted size through
860:                     the UART.
861:                 
862:                   Precondition:
863:                     The UART module should have been appropriately configured.  The configuration must
864:                     have been for desired data size.  The transmitter must have been ready,
865:                     although not necessarily enabled yet.
866:                 
867:                   Parameters:
868:                     id      - Identifies the desired UART module.
869:                 
870:                     data    - Data to be sent.
871:                 
872:                   Returns:
873:                     None
874:                 
875:                   Example:
876:                     <code>
877:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
878:                 	
879:                 	if (UARTTransmitterIsReady(UART1))
880:                     {
881:                         UARTSendData(UART1, data);
882:                     }
883:                     </code>
884:                 
885:                   Remarks:
886:                     Size of the data word size depends on the current configuration (see
887:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
888:                   *****************************************************************************/
889:                 
890:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
891:                 {
892:                     uartReg[id]->tx.reg = data.__data;
893:                 }
894:                 
895:                 /*******************************************************************************
896:                   Function:
897:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
898:                 
899:                   Summary:
900:                     Routine to detect if the UART module has finshed transmitting the most recent
901:                     data.
902:                 
903:                   Description:
904:                     This routine determines if the transmitter has finished sending all
905:                     available data.
906:                 
907:                   Preconditions:
908:                     The UART module should have been appropriately configured and enabled and data
909:                     sent to the UART TX buffer.
910:                 
911:                   Parameters:
912:                     id      - Identifies the desired UART module.
913:                 
914:                   Returns:
915:                     Boolean identifying if the transmission has completed:
916:                     * TRUE    - If the transmitter has completed sending the data
917:                     * FALSE   - If the transmitter is still busy sending the data
918:                 
919:                   Example:
920:                     <code>
921:                 	if (UARTTransmissionHasCompleted(UART1))
922:                     {
923:                         // Perform any tasks necessary when all data has been sent
924:                     }
925:                     </code>
926:                 
927:                   Remarks:
928:                   *****************************************************************************/
929:                 
930:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
931:                 {
932:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
9D00A874  3C029D01   LUI V0, -25343
9D00A878  8FC3000C   LW V1, 12(S8)
9D00A87C  00031880   SLL V1, V1, 2
9D00A880  2442CDEC   ADDIU V0, V0, -12820
9D00A884  00621021   ADDU V0, V1, V0
9D00A888  8C420000   LW V0, 0(V0)
9D00A88C  8C420010   LW V0, 16(V0)
9D00A890  30420100   ANDI V0, V0, 256
9D00A894  10400004   BEQ V0, ZERO, 0x9D00A8A8
9D00A898  00000000   NOP
9D00A89C  24020001   ADDIU V0, ZERO, 1
9D00A8A0  0B402A2B   J 0x9D00A8AC
9D00A8A4  00000000   NOP
9D00A8A8  00001021   ADDU V0, ZERO, ZERO
933:                 }
934:                 
935:                 
936:                 /*******************************************************************************
937:                   Function:
938:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
939:                 
940:                   Summary:
941:                     Routine to detect if the receiver has data available.
942:                 
943:                   Description:
944:                     This routine determines if the receiver has data available to be read.
945:                 
946:                   Precondition:
947:                     The UART module must have been configured appropriately and enabled. A complete
948:                     data frame must have been sent to the UART before it will return a TRUE.
949:                 
950:                   Parameters:
951:                     id      - Identifies the desired UART module.
952:                 
953:                   Returns:
954:                     Boolean identifying whether or not data is available:
955:                     * TRUE    - If the receiver has data available
956:                     * FALSE   - If the receiver does not have data availble
957:                 
958:                   Example:
959:                     <code>
960:                     UART_DATA data;
961:                 	
962:                 	if (UARTReceivedDataIsAvailable(UART1))
963:                     {
964:                         data = UARTGetData(UART1);
965:                     }
966:                     </code>
967:                 
968:                   Remarks:
969:                     This routine provides the same information as the UART_DATA_READY line
970:                     status flag.
971:                   *****************************************************************************/
972:                 
973:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
974:                 {
975:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
9D00A54C  3C029D01   LUI V0, -25343
9D00A550  8FC30000   LW V1, 0(S8)
9D00A554  00031880   SLL V1, V1, 2
9D00A558  2442CDEC   ADDIU V0, V0, -12820
9D00A55C  00621021   ADDU V0, V1, V0
9D00A560  8C420000   LW V0, 0(V0)
9D00A564  8C420010   LW V0, 16(V0)
9D00A568  30420001   ANDI V0, V0, 1
9D00A69C  3C029D01   LUI V0, -25343
9D00A6A0  8FC30014   LW V1, 20(S8)
9D00A6A4  00031880   SLL V1, V1, 2
9D00A6A8  2442CDEC   ADDIU V0, V0, -12820
9D00A6AC  00621021   ADDU V0, V1, V0
9D00A6B0  8C420000   LW V0, 0(V0)
9D00A6B4  8C420010   LW V0, 16(V0)
9D00A6B8  30420001   ANDI V0, V0, 1
9D00A720  3C029D01   LUI V0, -25343
9D00A724  8FC3001C   LW V1, 28(S8)
9D00A728  00031880   SLL V1, V1, 2
9D00A72C  2442CDEC   ADDIU V0, V0, -12820
9D00A730  00621021   ADDU V0, V1, V0
9D00A734  8C420000   LW V0, 0(V0)
9D00A738  8C420010   LW V0, 16(V0)
9D00A73C  30420001   ANDI V0, V0, 1
9D00A8F8  3C029D01   LUI V0, -25343
9D00A8FC  8FC30018   LW V1, 24(S8)
9D00A900  00031880   SLL V1, V1, 2
9D00A904  2442CDEC   ADDIU V0, V0, -12820
9D00A908  00621021   ADDU V0, V1, V0
9D00A90C  8C420000   LW V0, 0(V0)
9D00A910  8C420010   LW V0, 16(V0)
9D00A914  30420001   ANDI V0, V0, 1
9D00AA70  3C029D01   LUI V0, -25343
9D00AA74  8FC30004   LW V1, 4(S8)
9D00AA78  00031880   SLL V1, V1, 2
9D00AA7C  2442CDEC   ADDIU V0, V0, -12820
9D00AA80  00621021   ADDU V0, V1, V0
9D00AA84  8C420000   LW V0, 0(V0)
9D00AA88  8C420010   LW V0, 16(V0)
9D00AA8C  30420001   ANDI V0, V0, 1
976:                 }
977:                 
978:                 
979:                 /*******************************************************************************
980:                   Function:
981:                     BYTE UARTGetDataByte ( UART_MODULE id )
982:                 
983:                   Summary:
984:                     Routine to get a byte of data received by the UART.
985:                 
986:                   Description:
987:                     This routine allows the caller to read a byte of data received by the UART.
988:                 
989:                   Precondition:
990:                     The UART module must have been appropriately configured, the configuration must
991:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
992:                     been enabled.  Also, a complete data frame must have been received by the UART.
993:                 
994:                   Parameters:
995:                     id      - Identifies the desired UART module.
996:                 
997:                   Returns:
998:                     A byte of data received by the UART.
999:                 
1000:                  Example:
1001:                    <code>
1002:                    unsigned char data;
1003:                	
1004:                	if (UARTReceivedDataIsAvailable(UART1))
1005:                    {
1006:                        data = UARTGetDataByte(UART1);
1007:                    }
1008:                    </code>
1009:                
1010:                  Remarks:
1011:                    This routine is optimized for receiving 8-bit data through the UART.
1012:                  *****************************************************************************/
1013:                
1014:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1015:                {
1016:                    return (BYTE)uartReg[id]->rx.reg;
9D00A57C  3C029D01   LUI V0, -25343
9D00A580  8FC30004   LW V1, 4(S8)
9D00A584  00031880   SLL V1, V1, 2
9D00A588  2442CDEC   ADDIU V0, V0, -12820
9D00A58C  00621021   ADDU V0, V1, V0
9D00A590  8C420000   LW V0, 0(V0)
9D00A594  8C420030   LW V0, 48(V0)
9D00A598  304200FF   ANDI V0, V0, 255
9D00A6CC  3C029D01   LUI V0, -25343
9D00A6D0  8FC30018   LW V1, 24(S8)
9D00A6D4  00031880   SLL V1, V1, 2
9D00A6D8  2442CDEC   ADDIU V0, V0, -12820
9D00A6DC  00621021   ADDU V0, V1, V0
9D00A6E0  8C420000   LW V0, 0(V0)
9D00A6E4  8C420030   LW V0, 48(V0)
9D00A6E8  304200FF   ANDI V0, V0, 255
9D00A750  3C029D01   LUI V0, -25343
9D00A754  8FC30020   LW V1, 32(S8)
9D00A758  00031880   SLL V1, V1, 2
9D00A75C  2442CDEC   ADDIU V0, V0, -12820
9D00A760  00621021   ADDU V0, V1, V0
9D00A764  8C420000   LW V0, 0(V0)
9D00A768  8C420030   LW V0, 48(V0)
9D00A76C  304200FF   ANDI V0, V0, 255
9D00A928  3C029D01   LUI V0, -25343
9D00A92C  8FC3001C   LW V1, 28(S8)
9D00A930  00031880   SLL V1, V1, 2
9D00A934  2442CDEC   ADDIU V0, V0, -12820
9D00A938  00621021   ADDU V0, V1, V0
9D00A93C  8C420000   LW V0, 0(V0)
9D00A940  8C420030   LW V0, 48(V0)
9D00A944  304200FF   ANDI V0, V0, 255
9D00AAA0  3C029D01   LUI V0, -25343
9D00AAA4  8FC30008   LW V1, 8(S8)
9D00AAA8  00031880   SLL V1, V1, 2
9D00AAAC  2442CDEC   ADDIU V0, V0, -12820
9D00AAB0  00621021   ADDU V0, V1, V0
9D00AAB4  8C420000   LW V0, 0(V0)
9D00AAB8  8C420030   LW V0, 48(V0)
9D00AABC  304200FF   ANDI V0, V0, 255
1017:                }
1018:                
1019:                
1020:                /*******************************************************************************
1021:                  Function:
1022:                    UART_DATA UARTGetData ( UART_MODULE id )
1023:                
1024:                  Summary:
1025:                    Routine to get data received by the UART.
1026:                
1027:                  Description:
1028:                    This routine allows the caller to read a data word received by the UART.
1029:                
1030:                  Precondition:
1031:                    The module must have been appropriately configured, the UART module must have been
1032:                    enabled, and a complete data frame must have been received by the UART.
1033:                
1034:                  Parameters:
1035:                    id      - Identifies the desired UART module.
1036:                
1037:                  Returns:
1038:                    Data received by the UART.
1039:                
1040:                  Example:
1041:                    <code>
1042:                    UART_DATA data;
1043:                	
1044:                	if (UARTReceivedDataIsAvailable(UART1))
1045:                    {
1046:                        data = UARTGetData(UART1);
1047:                    }
1048:                    </code>
1049:                
1050:                  Remarks:
1051:                    Size of the data word depends on the current configuration (see
1052:                    UARTSetLineControl).
1053:                  *****************************************************************************/
1054:                
1055:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1056:                {
1057:                    UART_DATA data;
1058:                
1059:                    data.__data = uartReg[id]->rx.reg;
1060:                
1061:                    return data;
1062:                }
1063:                
1064:                
1065:                /*******************************************************************************
1066:                  Function:
1067:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1068:                
1069:                  Summary:
1070:                    Routine to program the address for which the UART module may watch.
1071:                
1072:                  Description:
1073:                    This routine programs the 8-bit address for which the module may watch.
1074:                
1075:                  Precondition:
1076:                    None
1077:                
1078:                  Parameters:
1079:                    id      - Identifies the desired UART module.
1080:                
1081:                    address - 8-bit address for which the module will watch.
1082:                
1083:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1084:                              * TRUE - Enable address watch mode
1085:                              * FALSE - Disable address watch mode
1086:                
1087:                  Returns:
1088:                    None.
1089:                
1090:                  Example:
1091:                    <code>
1092:                    #define SLAVE_ADDRESS  0x42
1093:                	
1094:                	UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1095:                    </code>
1096:                
1097:                  Remarks:
1098:                    The module can be placed into a mode where it will ignore all data received
1099:                    until it identifies the programmed adress.  After the programmed address
1100:                    has been identified, it will begin receiving data normally.  This mode is
1101:                    particularly useful for supporting the IEEE-485 protocol.
1102:                  *****************************************************************************/
1103:                
1104:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1105:                
1106:                
1107:                /*******************************************************************************
1108:                  Function:
1109:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1110:                
1111:                  Summary:
1112:                    Routine to enable or disable recognition of the programmed address byte.
1113:                
1114:                  Description:
1115:                    This routine can enable or disable the "address watch" mode.  In this mode,
1116:                    the UART module will ignore all data until it recognizes the programmed address.
1117:                
1118:                  Precondition:
1119:                    UART should have already been enabled and set with watch address.
1120:                
1121:                  Parameters:
1122:                    id      - Identifies the desired UART module.
1123:                
1124:                    watch   - Determines if the "address watch" mode will be enabled or
1125:                              disabled.
1126:                              * TRUE - Enable address watch mode
1127:                              * FALSE - Disable address watch mode
1128:                
1129:                  Returns:
1130:                    None.
1131:                
1132:                  Example:
1133:                    <code>
1134:                    #define SLAVE_ADDRESS 0x42
1135:                	
1136:                	// Set the address, but don't enable the watch until later,
1137:                	// UART continues to receive data normally
1138:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1139:                
1140:                    // ...
1141:                
1142:                    // Now begin to ignore all UART traffic until we are addressed
1143:                    UARTWatchForAddress(UART1, TRUE);
1144:                    </code>
1145:                
1146:                  Remarks:
1147:                    The UART module can be placed into a mode where it will ignore all data received
1148:                    until it identifies the programmed address.  After the programmed address
1149:                    has been identified, it will begin receiving data normally.  This mode is
1150:                    particularly useful for supporting the IEEE-485 protocol.
1151:                  *****************************************************************************/
1152:                
1153:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1154:                
1155:                
1156:                /*******************************************************************************
1157:                  Function:
1158:                    void UARTSendBreak ( UART_MODULE id )
1159:                
1160:                  Summary:
1161:                    Routine to send a break signal from the UART.
1162:                
1163:                  Description:
1164:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1165:                
1166:                  Precondition:
1167:                    The UART should have been appropriately configured.  The transmitter should
1168:                    be idle, although not necessarily enabled yet.
1169:                
1170:                  Parameters:
1171:                    id      - Identifies the desired UART module.
1172:                
1173:                  Returns:
1174:                    None
1175:                
1176:                  Example:
1177:                    <code>
1178:                    if (UARTTransmissionHasCompleted(UART1))
1179:                    {
1180:                        UARTSendBreak(UART1);
1181:                    }
1182:                    </code>
1183:                
1184:                  Remarks:
1185:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1186:                    data may be pre-loaded into the FIFO and it will be send immediately
1187:                    following the break signal.
1188:                  *****************************************************************************/
1189:                
1190:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1191:                {
1192:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1193:                }
1194:                
1195:                
1196:                /*******************************************************************************
1197:                  Function:
1198:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1199:                
1200:                  Summary:
1201:                    Routine to automatically determine the data rate (bits-per-second) of an
1202:                    external transmitter to the UART.
1203:                
1204:                  Description:
1205:                    This routine initiates the process of automatically determining the data
1206:                    rate (bits-per-second) of an external transmitter to the UART.
1207:                
1208:                  Precondition:
1209:                    The UART should have been appropriately configured.  The transmitter should
1210:                    be idle, although not necessarily enabled yet.
1211:                
1212:                  Parameters:
1213:                    id      - Identifies the desired UART module.
1214:                
1215:                  Returns:
1216:                    None
1217:                
1218:                  Example:
1219:                    <code>
1220:                	// See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1221:                	// methods to detect a Break.
1222:                	
1223:                    if (breakDetected && useAutoRateDetect) 
1224:                    {
1225:                        UARTStartAutoDataRateDetect (UART1);
1226:                    }
1227:                    </code>
1228:                
1229:                  Remarks:
1230:                    The UART module begins measuring the data rate beginning at the next start
1231:                    bit.  The external transmitter should send an alternating pattern (0x55)
1232:                    for the byte to be measured for an effective rate detection.  To ensure
1233:                    an effective measurement sequence, this can be done immediately following
1234:                    a break reception. It is important that this UART module is not
1235:                	transmitting data while it is trying to detect RX baud rate, see the 
1236:                	"PIC32 Family Reference Manual, Sect. 21 UART".
1237:                  *****************************************************************************/
1238:                
1239:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1240:                {
1241:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1242:                }
1243:                
1244:                
1245:                
1246:                /*******************************************************************************
1247:                  Function:
1248:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1249:                
1250:                  Summary:
1251:                    Routine to identify when automatic data rate detection has completed.
1252:                
1253:                  Description:
1254:                    This routine checks to see if automatic data rate detection has completed.
1255:                
1256:                  Precondition:
1257:                    Automatic rate detection should have been previously started.
1258:                
1259:                  Parameters:
1260:                    id      - Identifies the desired UART module.
1261:                
1262:                  Returns:
1263:                    * TRUE    - Indicates that automatic rate detection has completed.
1264:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1265:                
1266:                  Example:
1267:                    <code>
1268:                    #define PERIPHERAL_CLOCK    10000000
1269:                	
1270:                	UINT32 currentRate;
1271:                	
1272:                	if (UARTDataRateDetected(UART1))
1273:                    {
1274:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1275:                    }
1276:                    </code>
1277:                
1278:                  Remarks:
1279:                    This routine returns FALSE after automatic rate detection
1280:                    has been started but before rate is detectdd, it will return TRUE
1281:                	at any other time.
1282:                  *****************************************************************************/
1283:                
1284:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1285:                {
1286:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1287:                }
1288:                
1289:                #ifdef __cplusplus
1290:                  }
1291:                #endif
1292:                
1293:                #endif // _UART_h_
1294:                
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
9D00AB70  8FC20020   LW V0, 32(S8)
9D00AB74  AFC20024   SW V0, 36(S8)
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D00AB78  8FC30020   LW V1, 32(S8)
9D00AB7C  3C0204C4   LUI V0, 1220
9D00AB80  3442B401   ORI V0, V0, -19455
9D00AB84  0062102B   SLTU V0, V1, V0
9D00AB88  14400008   BNE V0, ZERO, 0x9D00ABAC
9D00AB8C  00000000   NOP
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
9D00AB90  3C020008   LUI V0, 8
9D00AB94  AFC20028   SW V0, 40(S8)
118:                         pb_clock >>= 1;
9D00AB98  8FC20024   LW V0, 36(S8)
9D00AB9C  00021042   SRL V0, V0, 1
9D00ABA0  AFC20024   SW V0, 36(S8)
9D00ABA4  0B402AEC   J 0x9D00ABB0
9D00ABA8  00000000   NOP
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
9D00ABAC  AFC00028   SW ZERO, 40(S8)
9D00ABB0  8FC20028   LW V0, 40(S8)
9D00ABB4  AFC2002C   SW V0, 44(S8)
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
170:                     {
171:                         wait_states++;
172:                         sys_clock -= FLASH_SPEED_HZ;
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
176:                     mCheConfigure(wait_states);
177:                     INTRestoreInterrupts(int_status);
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
227:                     {
228:                         wait_states++;
229:                         sys_clock -= FLASH_SPEED_HZ;
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
233:                     mCheConfigure(wait_states);
234:                     INTRestoreInterrupts(int_status);
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
279:                 
280:                     int_status=INTDisableInterrupts();
281:                 
282:                     mBMXDisableDRMWaitState();
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
286:                     cache_status |= CHE_CONF_PF_ALL;
287:                     mCheConfigure(cache_status);
288:                     CheKseg0CacheOn();
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
9D00AB24  0F403379   JAL INTDisableInterrupts
9D00AB28  00000000   NOP
9D00AB2C  AFC20018   SW V0, 24(S8)
342:                 
343:                     mBMXDisableDRMWaitState();
9D00AB30  3C02BF88   LUI V0, -16504
9D00AB34  24030040   ADDIU V1, ZERO, 64
9D00AB38  AC432004   SW V1, 8196(V0)
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
9D00AB3C  8FC20014   LW V0, 20(S8)
9D00AB40  30420001   ANDI V0, V0, 1
9D00AB44  304200FF   ANDI V0, V0, 255
9D00AB48  10400003   BEQ V0, ZERO, 0x9D00AB58
9D00AB4C  00000000   NOP
9D00AB50  8FC20010   LW V0, 16(S8)
9D00AB54  AFC2001C   SW V0, 28(S8)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
9D00AB58  8FC20014   LW V0, 20(S8)
9D00AB5C  30420002   ANDI V0, V0, 2
9D00AB60  10400065   BEQ V0, ZERO, 0x9D00ACF8
9D00AB64  00000000   NOP
9D00AB68  8FC20010   LW V0, 16(S8)
9D00AB6C  AFC20020   SW V0, 32(S8)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
358:                     {
359:                         cache_status = mCheGetCon();
360:                         cache_status |= CHE_CONF_PF_ALL;
361:                         mCheConfigure(cache_status);
362:                         CheKseg0CacheOn();
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
9D00ACF8  8FC20010   LW V0, 16(S8)
9D00ACFC  AFC20044   SW V0, 68(S8)
367:                     pb_clk >>= OSCCONbits.PBDIV;
9D00AD00  3C02BF81   LUI V0, -16511
9D00AD04  8C42F000   LW V0, -4096(V0)
9D00AD08  7C420CC0   EXT V0, V0, 19, 2
9D00AD0C  304200FF   ANDI V0, V0, 255
9D00AD10  8FC30044   LW V1, 68(S8)
9D00AD14  00431006   SRLV V0, V1, V0
9D00AD18  AFC20044   SW V0, 68(S8)
368:                 
369:                     INTRestoreInterrupts(int_status);
9D00AD1C  8FC40018   LW A0, 24(S8)
9D00AD20  0F40335E   JAL INTRestoreInterrupts
9D00AD24  00000000   NOP
370:                 
371:                     return pb_clk;
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/osc.h  ----------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the ?Company?) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Company?s customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  #define _OSC_
47:                  
48:                  /*********************************************************************
49:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
50:                   *
51:                   * Description:	    Sets Osc options and clock source
52:                   *
53:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
54:                   *
55:                   * Inputs:	    	Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
56:                   *
57:                   * Output:          None
58:                   *
59:                   * Example:	    	OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
60:                   *
61:                   * Note:	    	Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
62:                   * 		     		source and then switches to the new clock source
63:                   *
64:                   *		    		Unused parameters are set to zero/default values.
65:                   ********************************************************************/
66:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
67:                  
68:                  	/******************************************************************************
69:                  	 * Available options for source parameter
70:                  	 *****************************************************************************/
71:                  		// CPU Oscillator modes - values are mutually exclusive
72:                  		#define OSC_FRC_DIV 	(7 << _OSCCON_NOSC_POSITION)
73:                  		#define OSC_FRC_DIV16 	(6 << _OSCCON_NOSC_POSITION)
74:                  		#define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
75:                  		#define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
76:                  		#define OSC_POSC_PLL 	(3 << _OSCCON_NOSC_POSITION)
77:                  		#define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
78:                  		#define OSC_FRC_PLL 	(1 << _OSCCON_NOSC_POSITION)
79:                  		#define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
80:                  
81:                  	/******************************************************************************
82:                  	 * Available options for mult parameter
83:                  	 *****************************************************************************/
84:                  		// CPU PLL multiplier values - values are mutually exclusive
85:                  		#define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
86:                  		#define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
87:                  		#define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
88:                  		#define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
89:                  		#define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
90:                  		#define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
91:                  		#define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
92:                  		#define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
93:                  
94:                  	/******************************************************************************
95:                  	 * Available options for post parameter
96:                  	 *****************************************************************************/
97:                  		// CPU PLL output divisor values - values are mutuallye exclusive
98:                  		#define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
99:                  		#define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
100:                 		#define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
101:                 		#define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
102:                 		#define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
103:                 		#define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
104:                 		#define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
105:                 		#define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
106:                 
107:                 	/******************************************************************************
108:                 	 * Available options for div parameter
109:                 	 *****************************************************************************/
110:                 		// CPU FRC output divisor values - values are mutually exclusive
111:                 		#define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
112:                 		#define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
113:                 		#define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
114:                 		#define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
115:                 		#define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
116:                 		#define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
117:                 		#define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
118:                 		#define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
119:                 	/***********************************
120:                 	 * End parameter values
121:                 	 ************************************/
122:                 
123:                 #if (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || \
124:                     (__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 370) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450) || (__PIC32_FEATURE_SET__ == 470))
125:                 	
126:                 		// Reference Oscillator Source Select bits - values are mutually exclusive
127:                 	#define OSC_REFOCON_REFCLKI	 	(7 << _REFOCON_ROSEL_POSITION )
128:                 	#define OSC_REFOCON_SYSPLL 		(7 << _REFOCON_ROSEL_POSITION )
129:                 	#define OSC_REFOCON_USBPLL 		(6 << _REFOCON_ROSEL_POSITION )
130:                 	#define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
131:                 	#define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
132:                 	#define OSC_REFOCON_FRC 		(3 << _REFOCON_ROSEL_POSITION )
133:                 	#define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
134:                 	#define OSC_REFOCON_PBCLK 		(1 << _REFOCON_ROSEL_POSITION )
135:                 	#define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
136:                 		
137:                 	typedef enum
138:                 	{		
139:                 		OSC_REFOCON_RLSPEN		=(1 << _REFOCON_RSLP_POSITION )	,
140:                 		OSC_REFOCON_OE			=(1 << _REFOCON_OE_POSITION ),
141:                 		OSC_REFOCON_SIDLEN		=(1 << _REFOCON_SIDL_POSITION ),
142:                 		OSC_REFOCON_ON			=(1 << _REFOCON_ON_POSITION )
143:                 	} OSCREFConfigFlags;
144:                 	
145:                 	void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
146:                 	 
147:                 
148:                 	#define mOSCREFOTRIMSet(trim) 		(REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
149:                 
150:                 #endif
151:                 
152:                 	 
153:                 	 
154:                 	 
155:                 /*********************************************************************
156:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
157:                  *
158:                  * Description:	Configures peripheral bus divisor
159:                  *
160:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
161:                  *
162:                  * Inputs:    oscPbDiv - desired PB divider
163:                  *
164:                  * Output:      None
165:                  *
166:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
167:                  *
168:                  ********************************************************************/
169:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
170:                 {
171:                 	unsigned int dma_status;
172:                 	unsigned int int_status;
173:                 	__OSCCONbits_t oscBits;
174:                 
175:                 	mSYSTEMUnlock(int_status, dma_status);
9D00ABB8  0F403379   JAL INTDisableInterrupts
9D00ABBC  00000000   NOP
9D00ABC0  AFC20030   SW V0, 48(S8)
9D00AC08  AFC20038   SW V0, 56(S8)
9D00AC0C  3C02BF81   LUI V0, -16511
9D00AC10  AC40F230   SW ZERO, -3536(V0)
9D00AC14  3C02BF81   LUI V0, -16511
9D00AC18  3C03AA99   LUI V1, -21863
9D00AC1C  34636655   ORI V1, V1, 26197
9D00AC20  AC43F230   SW V1, -3536(V0)
9D00AC24  3C02BF81   LUI V0, -16511
9D00AC28  3C035566   LUI V1, 21862
9D00AC2C  346399AA   ORI V1, V1, -26198
9D00AC30  AC43F230   SW V1, -3536(V0)
176:                 	
177:                 	oscBits.w=OSCCON;		// read to be in sync. flush any pending write
9D00AC34  3C02BF81   LUI V0, -16511
9D00AC38  8C42F000   LW V0, -4096(V0)
9D00AC3C  AFC20048   SW V0, 72(S8)
178:                 	oscBits.PBDIV=0;
9D00AC40  8FC20048   LW V0, 72(S8)
9D00AC44  7C02A4C4   INS V0, ZERO, 19, 2
9D00AC48  AFC20048   SW V0, 72(S8)
179:                 	oscBits.w|=oscPbDiv;	
9D00AC4C  8FC30048   LW V1, 72(S8)
9D00AC50  8FC2002C   LW V0, 44(S8)
9D00AC54  00621025   OR V0, V1, V0
9D00AC58  AFC20048   SW V0, 72(S8)
180:                 	OSCCON=oscBits.w;		// write back
9D00AC5C  8FC30048   LW V1, 72(S8)
9D00AC60  3C02BF81   LUI V0, -16511
9D00AC64  AC43F000   SW V1, -4096(V0)
181:                 	oscBits.w=OSCCON;		// make sure the write occurred before returning from this function
9D00AC68  3C02BF81   LUI V0, -16511
9D00AC6C  8C42F000   LW V0, -4096(V0)
9D00AC70  AFC20048   SW V0, 72(S8)
182:                 	
183:                 	mSYSTEMLock(int_status, dma_status);
9D00AC74  3C02BF81   LUI V0, -16511
9D00AC78  3C033333   LUI V1, 13107
9D00AC7C  34633333   ORI V1, V1, 13107
9D00AC80  AC43F230   SW V1, -3536(V0)
9D00AC84  8FC20038   LW V0, 56(S8)
9D00AC88  AFC2003C   SW V0, 60(S8)
9D00ACEC  8FC40030   LW A0, 48(S8)
9D00ACF0  0F40335E   JAL INTRestoreInterrupts
9D00ACF4  00000000   NOP
184:                 }
185:                 
186:                 #define		mOSCSetPBDIV		OSCSetPBDIV		// backward compatibility
187:                 
188:                 
189:                 
190:                 	/******************************************************************************
191:                 	 * Available options for config parameter
192:                 	 *****************************************************************************/
193:                 		// CPU Peripheral Bus divisor values - values are mutually exclusive
194:                 		#define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
195:                 		#define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
196:                 		#define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
197:                 		#define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
198:                 	/***********************************
199:                 	 * End config parameter values
200:                 	 ************************************/
201:                 
202:                 
203:                 /*********************************************************************
204:                  * Function:    mOSCGetPBDIV()
205:                  *
206:                  * Description:	Reads peripheral bus divisor
207:                  *
208:                  * PreCondition:None
209:                  *
210:                  * Inputs:	  	None
211:                  *
212:                  * Output:      None
213:                  *
214:                  * Example:	  	mOSCGetPBDIV()
215:                  *
216:                  ********************************************************************/
217:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
218:                 
219:                 
220:                 /*********************************************************************
221:                  * Function:    mOSCClockFailStatus()
222:                  *
223:                  * Description:	Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
224:                  *
225:                  * PreCondition: None
226:                  *
227:                  * Inputs:	  	None
228:                  *
229:                  * Output:      None
230:                  *
231:                  * Example:	  	mOSCClockFailStatus()
232:                  *
233:                  ********************************************************************/
234:                 #define mOSCClockFailStatus (OSCCONbits.CF)
235:                 
236:                 
237:                 /*********************************************************************
238:                  * Function:      	mOSCEnableSOSC()
239:                  *
240:                  * Description:	  	Enables the LPRC
241:                  *
242:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
243:                  *
244:                  * Inputs:	  		None
245:                  *
246:                  * Output:        	None
247:                  *
248:                  * Example:	  		mOSCEnableSOSC()
249:                  *
250:                  ********************************************************************/
251:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
252:                 
253:                 
254:                 /*********************************************************************
255:                  * Function:      	mOSCDisableSOSC(config)
256:                  *
257:                  * Description:	  	Disables SOSC
258:                  *
259:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
260:                  *
261:                  * Inputs:	  		None
262:                  *
263:                  * Output:        	None
264:                  *
265:                  * Example:	  		mOSCDisableSOSC()
266:                  *
267:                  ********************************************************************/
268:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
269:                 
270:                 
271:                 
272:                 #endif
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/dma_1xx_2xx.h  --------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:    xc.h
8:                    *                  int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Compiler:        MPLAB XC32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the ?Company?) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Company?s customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_H_
43:                  #define _DMA_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  
48:                  // DMA definitions
49:                  
50:                  #ifdef _DMAC0
51:                      #define _DMA_CHANNELS       // DMA channels exist
52:                  
53:                  
54:                  // existent DMA channels
55:                      typedef enum
56:                      {
57:                          DMA_CHANNEL0,
58:                      #ifdef _DMAC1
59:                          DMA_CHANNEL1,
60:                      # ifdef _DMAC2
61:                          DMA_CHANNEL2,
62:                      #  ifdef _DMAC3
63:                          DMA_CHANNEL3,
64:                      #  endif// _DMAC3
65:                      # endif // _DMAC2
66:                      #endif  // _DMAC1
67:                          //  add/remove DMA channel as needed here
68:                  
69:                          DMA_CHANNELS    // number of current available channels
70:                      }DmaChannel;
71:                  
72:                  
73:                      // Relative Dma channels priority, between each other
74:                      typedef enum
75:                      {
76:                          DMA_CHN_PRI0,
77:                          DMA_CHN_PRI1,
78:                          DMA_CHN_PRI2,
79:                          DMA_CHN_PRI3
80:                      }DmaChannelPri;
81:                  
82:                  
83:                  
84:                      // high level definitions for the API functions
85:                  
86:                      typedef enum
87:                      {
88:                          DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
89:                          DMA_OPEN_AUTO   = _DCH0CON_CHAEN_MASK,                  // DMA channel is auto enabled
90:                          DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),   // DMA channel is chained to lower channel
91:                          DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),             // DMA channel is chained to higher channel
92:                          DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,                  // events detection enabled while channel off
93:                          DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,                   // DMA channel is enabled after open
94:                          DMA_OPEN_MATCH  = 0x80000000,                           // DMA channel stops on match
95:                      }DmaOpenFlags;  // flags for the channel open
96:                  
97:                  
98:                      typedef enum
99:                      {
100:                         DMA_EV_ERR =            0x1,        // address error event
101:                         DMA_EV_ABORT =          0x2,        // transfer abort event
102:                         DMA_EV_CELL_DONE =      0x4,        // cell transfer complete event
103:                         DMA_EV_BLOCK_DONE =     0x8,        // block transfer complete event
104:                         DMA_EV_DST_HALF =       0x10,       // destination half event
105:                         DMA_EV_DST_FULL =       0x20,       // destination full event
106:                         DMA_EV_SRC_HALF =       0x40,       // source half event
107:                         DMA_EV_SRC_FULL =       0x80,       // source full event
108:                 
109:                         DMA_EV_ALL_EVNTS=       (DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
110:                                                     DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)                // all available events
111:                     }DmaEvFlags;    // flags for controlling the DMA channel events; Bit fields from the processor header file.
112:                 
113:                 
114:                     typedef enum
115:                     {
116:                         DMA_TXFER_OK,           // the transfer was performed successfully
117:                         DMA_TXFER_ADD_ERR,      // address error while performing the transfer
118:                         DMA_TXFER_ABORT,        // the DMA transfer was aborted
119:                         DMA_TXFER_BC_ERR,       // block complete not set after the DMA transfer performed
120:                         DMA_TXFER_CC_ERR,       // cell complete not set after the DMA transfer performed
121:                         DMA_TXFER_TMO           // DMA transfer timeout
122:                     }DmaTxferRes;       // DMA transfer result
123:                 
124:                     typedef enum
125:                     {
126:                         DMA_WAIT_NOT,       // don't wait for the transfer to complete, return immediately
127:                         DMA_WAIT_CELL,      // wait for the cell transfer to complete, than return
128:                         DMA_WAIT_BLOCK      // wait for the block transfer to complete, than return
129:                     }DmaWaitMode;       // DMA transfer wait mode
130:                 
131:                     typedef enum
132:                     {
133:                         DMA_CHKSUM_CRC,     // LFSR CRC
134:                         DMA_CHKSUM_IP,      // IP Checksum
135:                     }DmaChksumType;     // DMA SFM supported checksum types
136:                 
137:                     typedef enum
138:                     {
139:                         DMA_BITO_MSb,       // MSb first (not reflected)
140:                         DMA_BITO_LSb,       // LSb first (reflected)
141:                     }DmaBitOrder;       // DMA SFM supported bit ordering
142:                 
143:                     typedef enum
144:                     {
145:                         DMA_REORDER_NOT,    // no reordering, destination matches the source
146:                         DMA_REORDER_ENDIAN, // change endianess on word (32 bit) boundaries: LE<->BE
147:                         DMA_REORDER_SWAP_HALF,  // swap half words (16 bit) within word (32 bit)
148:                         DMA_REORDER_SWAP_BYTE,  // swap bytes within half word (16 bit)
149:                     }DmaReorderMode;    // DMA SFM supported re-ordering modes
150:                 
151:                 
152:                     /*********************************************************************
153:                      * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
154:                      *
155:                      * PreCondition:    chPri  - valid channel priority, 0-3
156:                      *
157:                      * Input:           chn    - channel to be configured in the DMA controller
158:                      *                  chPri  - the priority given to the channel, 0-3
159:                      *                  oFlags - orred flags specifying the open mode:
160:                      *                           DMA_OPEN_DEFAULT: DMA default operation mode
161:                      *                           DMA_OPEN_AUTO: DMA channel is auto enabled
162:                      *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
163:                      *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
164:                      *                           DMA_OPEN_DET_EN: events detection enabled while channel off
165:                      *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
166:                      *                           DMA_OPEN_MATCH:    DMA channel stops on match
167:                      *
168:                      *
169:                      *
170:                      * Output:          None
171:                      *
172:                      * Side Effects:    None
173:                      *
174:                      * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
175:                      *
176:                      * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
177:                      *                  Use the low level functions to address special settings.
178:                      *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
179:                      *                  After that the channel is configured.
180:                      *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
181:                      *                  if DMA_OPEN_ENABLE flag was not specified.
182:                      *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
183:                      *                  This way, the transfer will occur correctly together with CRC calculation.
184:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
185:                      *                  User has to call event channel functions to enable the event flags if needed.
186:                      *
187:                      * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
188:                      ********************************************************************/
189:                      void           DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
190:                 
191:                     /*********************************************************************
192:                      * Function:        void DmaChnEnable(DmaChannel chn)
193:                      *
194:                      * PreCondition:    None
195:                      *
196:                      * Input:           chn     - channel to be enabled
197:                      *
198:                      * Output:          None
199:                      *
200:                      * Side Effects:    None
201:                      *
202:                      * Overview:        The function enables a previously configured DMA channel.
203:                      *
204:                      * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
205:                      *
206:                      * Example:         DmaChnEnable(DMA_CHANNEL3);
207:                      ********************************************************************/
208:                      void           DmaChnEnable(DmaChannel chn);
209:                 
210:                     /*********************************************************************
211:                      * Function:        void DmaChnDisable(DmaChannel chn)
212:                      *
213:                      * PreCondition:    None
214:                      *
215:                      * Input:           chn     - selected channel in the DMA controller
216:                      *
217:                      * Output:          None
218:                      *
219:                      * Side Effects:    None
220:                      *
221:                      * Overview:        The function disables a DMA channel. The channel operation stops.
222:                      *
223:                      * Note:            None.
224:                      *
225:                      * Example:         DmaChnDisable(DMA_CHANNEL3);
226:                      ********************************************************************/
227:                      void           DmaChnDisable(DmaChannel chn);
228:                 
229:                     /*********************************************************************
230:                      * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
231:                      *
232:                      * PreCondition:    chn     - valid DMA channel
233:                      *              - vSrcAdd, vDstAdd  - valid pointers
234:                      *                              - 0 < srcSize <= DmaGetMaxTxferSize()
235:                      *                              - 0 < dstSize <= DmaGetMaxTxferSize()
236:                      *                              - 0 < cellSize <= DmaGetMaxTxferSize()
237:                      *
238:                      * Input:           chn         - DMA channel number
239:                      *                              - vSrcAdd: source of the DMA transfer
240:                      *                              - vDstAdd: destination of the DMA transfer
241:                      *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
242:                      *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
243:                      *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
244:                      *
245:                      * Output:          None
246:                      *
247:                      * Side Effects:    None
248:                      *
249:                      * Overview:        The function sets the transfer characteristics for a DMA channel transfer:
250:                      *                  the source and the destination addresses.
251:                      *                  the source and destination lengths
252:                      *                  and the number of bytes transferred per event.
253:                      *
254:                      * Note:            The function clears the existing DMA channel event flags.
255:                      *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
256:                      *
257:                      * Example:         DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
258:                      ********************************************************************/
259:                      void           DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
260:                 
261:                 
262:                     /*********************************************************************
263:                      * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
264:                      *
265:                      * PreCondition:    chn     - valid DMA channel
266:                      *
267:                      * Input:           chn     - DMA channel number
268:                      *              - vSrcAdd: source (virtual) of the DMA transfer
269:                      * Output:          None
270:                      *
271:                      * Side Effects:    None
272:                      *
273:                      * Overview:        The function is a helper to set directly the transfer source address.
274:                      *
275:                      * Note:            None.
276:                      *
277:                      * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
278:                      ********************************************************************/
279:                      void           DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
280:                 
281:                     /*********************************************************************
282:                      * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
283:                      *
284:                      * PreCondition:    chn     - valid DMA channel
285:                      *
286:                      * Input:           chn         - DMA channel number
287:                      *                              - vDstAdd: destination (virtual) of the DMA transfer
288:                      * Output:          None
289:                      *
290:                      * Side Effects:    None
291:                      *
292:                      * Overview:        The function is a helper to set directly the transfer destination address.
293:                      *
294:                      * Note:            None
295:                      *
296:                      * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
297:                      ********************************************************************/
298:                      void           DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
299:                 
300:                     /*********************************************************************
301:                      * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
302:                      *
303:                      * PreCondition:    chn - valid DMA channel
304:                      *
305:                      * Input:           chn     - DMA channel number
306:                      *                  pattern -  the match pattern
307:                      *
308:                      * Output:          None
309:                      *
310:                      * Side Effects:    None
311:                      *
312:                      * Overview:        The function sets the curent match pattern for the selected DMA channel.
313:                      *
314:                      * Note:            None.
315:                      *
316:                      * Example:         DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
317:                      ********************************************************************/
318:                      void           DmaChnSetMatchPattern(DmaChannel chn, int pattern);
319:                 
320:                     /*********************************************************************
321:                      * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
322:                      *
323:                      * PreCondition:    chn - valid DMA channel
324:                      *
325:                      * Input:           chn     - DMA channel number
326:                      *
327:                      * Output:          The channel match pattern.
328:                      *
329:                      * Side Effects:    None
330:                      *
331:                      * Overview:        The function retrieves the curent match pattern for the selected DMA channel.
332:                      *
333:                      * Note:            None.
334:                      *
335:                      * Example:         int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
336:                      ********************************************************************/
337:                      int            DmaChnGetMatchPattern(DmaChannel chn);
338:                 
339:                     /*********************************************************************
340:                      * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
341:                      *
342:                      * PreCondition:    chn - valid DMA channel
343:                      *
344:                      * Input:           chn     - DMA channel number
345:                      *                  wMode   - if DMA_WAIT_NOT, return immediately
346:                      *                          - if DMA_WAIT_CELL, return after the cell transfer complete
347:                      *                          - if DMA_WAIT_BLOCK, return after the whole transfer is done
348:                      *                  retries - retry counter: if transfer not complete after so many retries, return with tmo.
349:                      *                              If 0, wait forever.
350:                      *
351:                      * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
352:                      *                  an DmaTxferRes error code  otherwise
353:                      *
354:                      * Side Effects:    None
355:                      *
356:                      * Overview:        The function initiates (forces) a DMA transfer for the selected DMA channel.
357:                      *                  The DMA channel is enabled.
358:                      *                  If waiting for the transfer completion needed (user doesn't use an ISR to catch
359:                      *                  this event) the function will periodically query the DMA controller for the
360:                      *                  transfer completion status.
361:                      *                  If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
362:                      *                  the block transfer than the function will re-force the transfer for each cell.
363:                      *
364:                      * Note:            This function can not ne used when the DMA channel is triggerred
365:                      *                  by hardware interrupt requests.
366:                      *                  This is because the transfers are software forced, theere is no
367:                      *                  wait for the occurrence of the hardware trigger.
368:                      *
369:                      * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
370:                      ********************************************************************/
371:                      DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
372:                 
373:                     /*********************************************************************
374:                      * Function:        void DmaChnForceTxfer(DmaChannel chn)
375:                      *
376:                      * PreCondition:    chn - valid DMA channel
377:                      *
378:                      * Input:           chn     - DMA channel number
379:                      *
380:                      * Output:          None
381:                      *
382:                      * Side Effects:    None
383:                      *
384:                      * Overview:        The function forces a DMA transfer to occur for the selected DMA channel.
385:                      *
386:                      * Note:            None.
387:                      *
388:                      * Example:         DmaChnForceTxfer(DMA_CHANNEL3);
389:                      ********************************************************************/
390:                      void           DmaChnForceTxfer(DmaChannel chn);
391:                 
392:                     /*********************************************************************
393:                      * Function:        void DmaChnAbortTxfer(DmaChannel chn)
394:                      *
395:                      * PreCondition:    chn - valid DMA channel
396:                      *
397:                      * Input:           chn     - DMA channel number
398:                      *
399:                      * Output:          None
400:                      *
401:                      * Side Effects:    None
402:                      *
403:                      * Overview:        The function aborts a current undergoing DMA transfer for the selected DMA channel.
404:                      *
405:                      * Note:            None.
406:                      *
407:                      * Example:         DmaChnAbortTxfer(DMA_CHANNEL3);
408:                      ********************************************************************/
409:                      void           DmaChnAbortTxfer(DmaChannel chn);
410:                 
411:                     // High level channel event and interrupt control functions
412:                 
413:                     /*********************************************************************
414:                      * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
415:                      *
416:                      * PreCondition:    chn - valid DMA channel
417:                      *
418:                      * Input:           chn     - DMA channel number
419:                      *                  eFlags  - event flags with the following significance:
420:                      *                              - DMA_EV_ERR: address error event
421:                      *                              - DMA_EV_ABORT: transfer abort event
422:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
423:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
424:                      *                              - DMA_EV_DST_HALF: destination half event
425:                      *                              - DMA_EV_DST_FULL: destination full event
426:                      *                              - DMA_EV_SRC_HALF: source half event
427:                      *                              - DMA_EV_SRC_FULL: source full event
428:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
429:                      *
430:                      * Output:          None
431:                      *
432:                      * Side Effects:    None
433:                      *
434:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
435:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
436:                      *                  enabled for the selected channel, the other channel event flags won't be touched.
437:                      *
438:                      * Note:            None.
439:                      *
440:                      * Example:         DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
441:                      ********************************************************************/
442:                      void           DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
443:                 
444:                     /*********************************************************************
445:                      * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
446:                      *
447:                      * PreCondition:    chn - valid DMA channel
448:                      *
449:                      * Input:           chn     - DMA channel number
450:                      *                  eFlags  - event flags with the following significance:
451:                      *                              - DMA_EV_ERR: address error event
452:                      *                              - DMA_EV_ABORT: transfer abort event
453:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
454:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
455:                      *                              - DMA_EV_DST_HALF: destination half event
456:                      *                              - DMA_EV_DST_FULL: destination full event
457:                      *                              - DMA_EV_SRC_HALF: source half event
458:                      *                              - DMA_EV_SRC_FULL: source full event
459:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
460:                      *
461:                      * Output:          None
462:                      *
463:                      * Side Effects:    None
464:                      *
465:                      * Overview:        The function clears the event enable flags for the selected DMA channel.
466:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
467:                      *                  disabled for the selected channel, the other channel event flags won't be touched.
468:                      *
469:                      * Note:            None.
470:                      *
471:                      * Example:         DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
472:                      ********************************************************************/
473:                      void           DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
474:                 
475:                     /*********************************************************************
476:                      * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
477:                      *
478:                      * PreCondition:    chn - valid DMA channel
479:                      *
480:                      * Input:           chn     - DMA channel number
481:                      *                  eFlags  - event flags with the following significance:
482:                      *                              - DMA_EV_ERR: address error event
483:                      *                              - DMA_EV_ABORT: transfer abort event
484:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
485:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
486:                      *                              - DMA_EV_DST_HALF: destination half event
487:                      *                              - DMA_EV_DST_FULL: destination full event
488:                      *                              - DMA_EV_SRC_HALF: source half event
489:                      *                              - DMA_EV_SRC_FULL: source full event
490:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
491:                      *
492:                      * Output:          None
493:                      *
494:                      * Side Effects:    None
495:                      *
496:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
497:                      *                  The channel event flags are forced to the eFlags value.
498:                      *
499:                      * Note:            None.
500:                      *
501:                      * Example:         DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
502:                      ********************************************************************/
503:                      void           DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
504:                 
505:                     /*********************************************************************
506:                      * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
507:                      *
508:                      * PreCondition:    chn - valid DMA channel
509:                      *
510:                      * Input:           chn     - DMA channel number
511:                      *
512:                      * Output:          - event flags with the following significance:
513:                      *                      - DMA_EV_ERR: address error event
514:                      *                      - DMA_EV_ABORT: transfer abort event
515:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
516:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
517:                      *                      - DMA_EV_DST_HALF: destination half event
518:                      *                      - DMA_EV_DST_FULL: destination full event
519:                      *                      - DMA_EV_SRC_HALF: source half event
520:                      *                      - DMA_EV_SRC_FULL: source full event
521:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
522:                      *
523:                      * Side Effects:    None
524:                      *
525:                      * Overview:        The function returns the event enabled flags for the selected DMA channel.
526:                      *
527:                      * Note:            None.
528:                      *
529:                      * Example:         DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
530:                      ********************************************************************/
531:                      DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn);
532:                 
533:                     /*********************************************************************
534:                      * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
535:                      *
536:                      * PreCondition:    chn - valid DMA channel
537:                      *
538:                      * Input:           chn     - DMA channel number
539:                      *                  eFlags  - event flags with the following significance:
540:                      *                              - DMA_EV_ERR: address error event
541:                      *                              - DMA_EV_ABORT: transfer abort event
542:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
543:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
544:                      *                              - DMA_EV_DST_HALF: destination half event
545:                      *                              - DMA_EV_DST_FULL: destination full event
546:                      *                              - DMA_EV_SRC_HALF: source half event
547:                      *                              - DMA_EV_SRC_FULL: source full event
548:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
549:                      *
550:                      * Output:          None
551:                      *
552:                      * Side Effects:    None
553:                      *
554:                      * Overview:        The function clears the event flags for the selected DMA channel.
555:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
556:                      *                  cleared for the selected channel, the other channel event flags won't be touched.
557:                      *
558:                      * Note:            None.
559:                      *
560:                      * Example:         DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
561:                      ********************************************************************/
562:                      void           DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
563:                 
564:                     /*********************************************************************
565:                      * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
566:                      *
567:                      * PreCondition:    chn - valid DMA channel
568:                      *
569:                      * Input:           chn     - DMA channel number
570:                      *
571:                      * Output:          event flags with the following significance:
572:                      *                      - DMA_EV_ERR: address error event
573:                      *                      - DMA_EV_ABORT: transfer abort event
574:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
575:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
576:                      *                      - DMA_EV_DST_HALF: destination half event
577:                      *                      - DMA_EV_DST_FULL: destination full event
578:                      *                      - DMA_EV_SRC_HALF: source half event
579:                      *                      - DMA_EV_SRC_FULL: source full event
580:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
581:                      *
582:                      * Side Effects:    None
583:                      *
584:                      * Overview:        The function returns the event flags for the selected DMA channel.
585:                      *
586:                      * Note:            None.
587:                      *
588:                      * Example:         DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
589:                      ********************************************************************/
590:                      DmaEvFlags DmaChnGetEvFlags(DmaChannel chn);
591:                 
592:                 
593:                     // high level helpers for fast strcpy/memcpy transfers
594:                 
595:                     /*********************************************************************
596:                      * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
597:                      *
598:                      * PreCondition:    chn     - a valid DMA channel
599:                      *                  s1, s2  - valid memory pointers
600:                      *                  n>0, n<=DmaGetMaxTxferSize()
601:                      *
602:                      * Input:           s1      - destination pointer
603:                      *                  s2      - source pointer
604:                      *                  n       - number of bytes to transfer
605:                      *                  chn     - the DMA channel to perform the transfer
606:                      *                  chPri   - the desired channel priority
607:                      *
608:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
609:                      *                  an DmaTxferRes error code  otherwise
610:                      *
611:                      * Side Effects:    None
612:                      *
613:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
614:                      *          Then it copies one block of memory from source to destination.
615:                      *
616:                      *
617:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
618:                      *                    This way, the transfer will occur correctly together with checksum calculation.
619:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
620:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
621:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
622:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
623:                      *
624:                      * Example:     res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
625:                      ********************************************************************/
626:                      DmaTxferRes    DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
627:                 
628:                     /*********************************************************************
629:                      * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
630:                      *
631:                      * PreCondition:    chn     - a valid DMA channel
632:                      *                  s1, s2  - valid memory pointers
633:                      *
634:                      * Input:           s1      - destination pointer
635:                      *                  s2      - source pointer
636:                      *                  chn     - the DMA channel to perform the transfer
637:                      *                  chPri   - the desired channel priority
638:                      *
639:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
640:                      *                  an DmaTxferRes error code  otherwise
641:                      *
642:                      * Side Effects:    None
643:                      *
644:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
645:                      *          Then it copies one zero terminated string from source to destination.
646:                      *
647:                      *
648:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
649:                      *                    This way, the transfer will occur correctly together with checksum calculation.
650:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
651:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
652:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
653:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
654:                      *
655:                      *
656:                      * Example:     res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
657:                      *********************************************************************/
658:                      DmaTxferRes    DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
659:                 
660:                     /*********************************************************************
661:                      * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
662:                      *
663:                      * PreCondition:    chn     - a valid DMA channel
664:                      *              - s1, s2    - valid memory pointers
665:                      *                              - 0 < n <= DmaGetMaxTxferSize()
666:                      *
667:                      * Input:           s1      - destination pointer
668:                      *                  s2      - source pointer
669:                      *                  n   - max number of bytes to transfer
670:                      *                  chn     - the DMA channel to perform the transfer
671:                      *                  chPri   - the desired channel priority
672:                      *
673:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
674:                      *                  an DmaTxferRes error code  otherwise
675:                      *
676:                      * Side Effects:    None
677:                      *
678:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
679:                      *          Then it copies one zero terminated string from source to destination.
680:                      *          It copies no more than n characters from s2.
681:                      *
682:                      *
683:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
684:                      *                    This way, the transfer will occur correctly together with checksum calculation.
685:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
686:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
687:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
688:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
689:                      *
690:                      *
691:                      * Example:     res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
692:                      ********************************************************************/
693:                      DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
694:                 
695:                     /*********************************************************************
696:                      * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
697:                      *
698:                      * PreCondition:    chn    - a valid DMA channel
699:                      *                  d, s   - valid memory pointer
700:                      *                  n>0, n<=DmaGetMaxTxferSize()
701:                      *
702:                      * Input:           d     - address where to deposit the result
703:                      *                  s     - source buffer pointer
704:                      *                  n     - number of bytes in the pointer
705:                      *                  chn   - the DMA channel to use
706:                      *                  chPri - the desired channel priority
707:                      *
708:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
709:                      *                  an DmaTxferRes error code  otherwise
710:                      *
711:                      * Side Effects:    None
712:                      *
713:                      * Overview:        The function is a helper that calculates the CRC of a memory block.
714:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
715:                      *
716:                      *
717:                      * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
718:                      *                  - No transfer is done, just the CRC is calculated.
719:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
720:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
721:                      *                  - The checksum type is switched to CRC.
722:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
723:                      *
724:                      * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
725:                      ********************************************************************/
726:                      DmaTxferRes    DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
727:                 
728:                     /*********************************************************************
729:                      * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
730:                      *
731:                      * PreCondition:    chn    - a valid DMA channel
732:                      *                  d, s   - valid memory pointer
733:                      *                  n>0, n<=DmaGetMaxTxferSize()
734:                      *
735:                      * Input:           d     - address where to deposit the result
736:                      *                  s     - source buffer pointer
737:                      *                  n     - number of bytes in the pointer
738:                      *                  chn   - the DMA channel to use
739:                      *                  chPri - the desired channel priority
740:                      *
741:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
742:                      *                  an DmaTxferRes error code  otherwise
743:                      *
744:                      * Side Effects:    None
745:                      *
746:                      * Overview:        The function is a helper that calculates the IP checksum of a memory block.
747:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
748:                      *
749:                      *
750:                      * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
751:                      *                  - No transfer is done, just the checksum is calculated.
752:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
753:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
754:                      *                  - The checksum type is switched to IP checksum.
755:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
756:                      *
757:                      * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
758:                      ********************************************************************/
759:                      DmaTxferRes    DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
760:                 
761:                     // High level Special Function Module (SFM) functions
762:                 
763:                     /*********************************************************************
764:                      * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
765:                      *
766:                      * PreCondition:    cType, bitO, rMode - valid values
767:                      *
768:                      * Input:           cType - checksum type to be calculated: CRC or IP Checksum
769:                      *                  bitO  - the bit order to be used MSb or LSb first
770:                      *                  rMode - the reordering mode of the bytes when calculating the checksum
771:                      *
772:                      * Output:          None
773:                      *
774:                      * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
775:                      *
776:                      * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
777:                      *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
778:                      *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first)
779:                      *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
780:                      *                      All these values affect the way the checksum is calculated.
781:                      *
782:                      * Note:            None
783:                      *
784:                      * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
785:                      ********************************************************************/
786:                     extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
787:                     {
788:                         DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
789:                         DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
790:                     }
791:                 
792:                     /*********************************************************************
793:                      * Function:        void DmaSfmTxferReorder(int enable)
794:                      *
795:                      * PreCondition:    None
796:                      *
797:                      * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
798:                      *
799:                      * Output:          None
800:                      *
801:                      * Side Effects:    None
802:                      *
803:                      * Overview:        The function configures the data transfer re-ordering of the SFM module.
804:                      *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
805:                      *                  Otherwise the data is written to the destination un-modified.
806:                      *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
807:                      *
808:                      *
809:                      * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
810:                      *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
811:                      *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
812:                      *                    Un-aligned transfers are not supported (undefined behavior)!
813:                      *
814:                      * Example:         DmaSfmTxferReorder();
815:                      ********************************************************************/
816:                     extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
817:                     {
818:                         DCRCCONCLR=_DCRCCON_WBO_MASK;
819:                         DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
820:                     }
821:                 
822:                 
823:                      /*********************************************************************
824:                      * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
825:                      *
826:                      * PreCondition:    pLen   - valid polynomial length within 1-32
827:                      *
828:                      * Input:           polynomial  - the layout of the CRC generator
829:                      *                  pLen        - the length of the CRC generator polynomial
830:                      *                  seed        - the initial seed of the CRC generator
831:                      *
832:                      * Output:          None
833:                      *
834:                      * Side Effects:    None
835:                      *
836:                      * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
837:                      *                  - the length of the CRC generator polynomial, pLen;
838:                      *                  - the function sets the layout of the shift stages that take place in the CRC generation.
839:                      *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
840:                      *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
841:                      *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
842:                      *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
843:                      *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
844:                      *                  - the function sets the seed of the CRC generator. This is the initial data present in the
845:                      *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
846:                      *
847:                      * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
848:                      *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
849:                      *                    Upon the transfer completion the calculated CRC is stored at the destination address.
850:                      *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
851:                      *                    the CrcResult() function.
852:                      *                  - The CRC module should be configured before enabled.
853:                      *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
854:                      *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
855:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
856:                      *
857:                      * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
858:                      ********************************************************************/
859:                     extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
860:                     {
861:                         DCRCCONCLR=_DCRCCON_PLEN_MASK;
862:                         DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
863:                         DCRCDATA=seed;
864:                         DCRCXOR=polynomial;
865:                     }
866:                 
867:                     #define DmaCrcConfigure DmaSfmCrcConfigure  // PIC32_3xx backward compatibility name
868:                 
869:                 
870:                     /*********************************************************************
871:                      * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
872:                      *
873:                      * PreCondition:    chn    - valid DMA channel
874:                      *
875:                      * Input:           chn         - the DMA channel to be attached to the checksum module.
876:                      *                  appendMode  - if TRUE the data passed to the checksum generator is not transferred to destination
877:                      *                                but it's written to the destination address when the block transfer is complete.
878:                      *                              - if FALSE the data is transferred normally while the checksum is calculated.
879:                      *                                The checksum will be available using the DmaSfmChecksum function.
880:                      *
881:                      * Output:          None
882:                      *
883:                      * Side Effects:    None
884:                      *
885:                      * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
886:                      *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
887:                      *                  is complete, the checksum result is available in the checksum data register.
888:                      *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
889:                 
890:                      *
891:                      * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
892:                      *
893:                      * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
894:                      ********************************************************************/
895:                     void            DmaSfmAttachChannel(DmaChannel chn, int appendMode);
896:                     #define         CrcAttachChannel    DmaSfmAttachChannel     // PIC32_3xx backward compatibility name
897:                 
898:                     /*********************************************************************
899:                      * Function:        unsigned int DmaSfmChecksum(void)
900:                      *
901:                      * PreCondition:    None
902:                      *
903:                      * Input:           None
904:                      *
905:                      * Output:          the current value of the checksum generator.
906:                      *
907:                      * Side Effects:    None
908:                      *
909:                      * Overview:        The function returns the calculated checksum value.
910:                      *
911:                      * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
912:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
913:                      *
914:                      * Example:         unsigned int myChk=DmaSfmChecksum();
915:                      ********************************************************************/
916:                     extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
917:                     {
918:                         return DCRCDATA;
919:                     }
920:                     #define     CrcResult   DmaSfmChecksum      // PIC32_3xx backward compatibility name
921:                     #define     DmaCrcGetValue  DmaSfmChecksum      // PIC32_3xx backward compatibility name
922:                 
923:                 
924:                     /*********************************************************************
925:                      * Function:        void DmaSfmSetSeed(unsigned int seed)
926:                      *
927:                      * PreCondition:    None
928:                      *
929:                      * Input:           seed    - the initial seed of the checksum generator
930:                      *
931:                      * Output:          None
932:                      *
933:                      * Side Effects:    None
934:                      *
935:                      * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
936:                      *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
937:                      *
938:                      * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
939:                      *
940:                      * Example:         DmaSfmSetSeed(0xffffffff);
941:                      ********************************************************************/
942:                     extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
943:                     {
944:                         DCRCDATA=seed;
945:                     }
946:                     #define     DmaCrcSetSeed   DmaSfmSetSeed       // PIC32_3xx backward compatibility name
947:                 
948:                 
949:                 /*********************  end of high level functions ****************************************/
950:                 
951:                     // low level definitions for the API functions
952:                 
953:                 
954:                     typedef struct
955:                     {
956:                         union
957:                         {
958:                             struct
959:                             {
960:                                 unsigned int chn:   3;      // last active DMA channel
961:                                 unsigned int rdOp:  1;      // last DMA operation, read if 1, write if 0
962:                             };
963:                             unsigned int    w;                      // word access
964:                         }lastAccess;
965:                         void*   lastAddress;        // most recent DMA address
966:                     }DmaStatus;         // DMA controller status
967:                 
968:                     typedef enum
969:                     {
970:                         DMA_GFLG_SUSPEND =  _DMACON_SUSPEND_MASK,   // suspend DMA controller operation
971:                         DMA_GFLG_ON =       _DMACON_ON_MASK,        // DMA module enabled/desabled
972:                         //
973:                         DMA_GFLG_ALL_FLAGS= DMA_GFLG_SUSPEND|DMA_GFLG_ON        // all flags
974:                     }DmaGlblFlags;  // flags for controlling global DMA controller behavior. From processor header file.
975:                 
976:                 
977:                 
978:                 
979:                     typedef enum
980:                     {
981:                         DMA_EV_ABORT_IRQ_EN =       _DCH0ECON_AIRQEN_MASK,
982:                         DMA_EV_START_IRQ_EN =       _DCH0ECON_SIRQEN_MASK,
983:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
984:                         // the start and abort IRQ signals
985:                         DMA_EV_MATCH_EN =           _DCH0ECON_PATEN_MASK,
986:                 
987:                 
988:                         // compiler use only field
989:                         _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
990:                     }DmaEvCtrlFlags;    // DMA channel event control fields accessibile as flags
991:                     // also part of DmaEvCtrlFlags:
992:                     #define DMA_EV_START_IRQ(irq)   (DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
993:                     #define DMA_EV_ABORT_IRQ(irq)   (DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
994:                 
995:                     // DMA channel event control as a structure:
996:                     #define DmaEvCtrl   __DCH0ECONbits_t
997:                 
998:                 
999:                 
1000:                
1001:                    typedef enum
1002:                    {
1003:                        DMA_CTL_AUTO_EN =       _DCH0CON_CHAEN_MASK,
1004:                        DMA_CTL_CHAIN_EN =      _DCH0CON_CHCHN_MASK,
1005:                        DMA_CTL_DET_EN =        _DCH0CON_CHAED_MASK,
1006:                        DMA_CTL_CHN_EN =        _DCH0CON_CHEN_MASK,
1007:                        DMA_CTL_CHAIN_DIR =     _DCH0CON_CHCHNS_MASK,
1008:                        // use the DMA_CTL_PRI() below for selecting the DMA
1009:                        // channel priority
1010:                    }DmaChnCtrlFlags;   // controlling the DMA channel with flags
1011:                    // also part of DmaChnCtrlFlags:
1012:                    #define DMA_CTL_PRI(pri)    ((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1013:                
1014:                    // DMA channel control as a structure:
1015:                    #define DmaChnCtrl      __DCH0CONbits_t
1016:                
1017:                    typedef struct
1018:                    {
1019:                        void*   vSrcAdd;        // source of the DMA transfer, virtual
1020:                        void*   vDstAdd;        // destination of the DMA transfer, virtual
1021:                        int srcSize;        // source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1022:                        int dstSize;        // destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1023:                        int cellSize;       // no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1024:                    }DmaTxferCtrl;      // transfer setting: the transfer source, destination addresses and size, cell size
1025:                
1026:                
1027:                    /********************** low level DMA channel functions *******************************/
1028:                
1029:                
1030:                
1031:                    // Global DMA controller functions
1032:                
1033:                    /*********************************************************************
1034:                     * Function:        void DmaEnable(int enable)
1035:                     *
1036:                     * PreCondition:    None
1037:                     *
1038:                     * Input:           enable - boolean to enable/disable the DMA controller
1039:                     *
1040:                     * Output:          None
1041:                     *
1042:                     * Side Effects:    None
1043:                     *
1044:                     * Overview:       The function enables/disables the DMA controller.
1045:                     *
1046:                     * Note:           None.
1047:                     *
1048:                     * Example:        DmaEnable(1);
1049:                     ********************************************************************/
1050:                    extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1051:                    {
1052:                        if(enable)
1053:                        {
1054:                            DMACONSET=_DMACON_ON_MASK;
1055:                        }
1056:                        else
1057:                        {
1058:                            DMACONCLR=_DMACON_ON_MASK;
1059:                            while(DMACONbits.ON);       // wait to take effect
1060:                        }
1061:                    }
1062:                
1063:                    /*********************************************************************
1064:                     * Function:        void DmaReset(void)
1065:                     *
1066:                     * PreCondition:    None
1067:                     *
1068:                     * Input:       None
1069:                     *
1070:                     * Output:          None
1071:                     *
1072:                     * Side Effects:    None
1073:                     *
1074:                     * Overview:        The function resets the DMA controller.
1075:                     *
1076:                     * Note:            None.
1077:                     *
1078:                     * Example:        DmaReset();
1079:                     ********************************************************************/
1080:                    #define            DmaReset()   DmaEnable(0)
1081:                
1082:                
1083:                    /*********************************************************************
1084:                     * Function:        int DmaSuspend(void)
1085:                     *
1086:                     * PreCondition:    None
1087:                     *
1088:                     * Input:       None
1089:                     *
1090:                     * Output:          true if the DMA was previously suspended, false otherwise
1091:                     *
1092:                     *
1093:                     * Side Effects:    None
1094:                     *
1095:                     * Overview:        The function suspends the DMA controller.
1096:                     *
1097:                     * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1098:                     *                  I.e. the function has to wait for the suspension to take place!
1099:                     *
1100:                     * Example:         int susp=DmaSuspend();
1101:                     ********************************************************************/
1102:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1103:                    {
1104:                        int suspSt;
1105:                        if(!(suspSt=DMACONbits.SUSPEND))
9D00ABC4  3C02BF88   LUI V0, -16504
9D00ABC8  8C423000   LW V0, 12288(V0)
9D00ABCC  7C420300   EXT V0, V0, 12, 1
9D00ABD0  304200FF   ANDI V0, V0, 255
9D00ABD4  AFC20034   SW V0, 52(S8)
9D00ABD8  8FC20034   LW V0, 52(S8)
9D00ABDC  14400009   BNE V0, ZERO, 0x9D00AC04
9D00ABE0  00000000   NOP
9D00AC98  3C02BF88   LUI V0, -16504
9D00AC9C  8C423000   LW V0, 12288(V0)
9D00ACA0  7C420300   EXT V0, V0, 12, 1
9D00ACA4  304200FF   ANDI V0, V0, 255
9D00ACA8  AFC20040   SW V0, 64(S8)
9D00ACAC  8FC20040   LW V0, 64(S8)
9D00ACB0  1440000E   BNE V0, ZERO, 0x9D00ACEC
9D00ACB4  00000000   NOP
1106:                        {
1107:                            DMACONSET=_DMACON_SUSPEND_MASK;     // suspend
9D00ABE4  3C02BF88   LUI V0, -16504
9D00ABE8  24031000   ADDIU V1, ZERO, 4096
9D00ABEC  AC433008   SW V1, 12296(V0)
9D00ACB8  3C02BF88   LUI V0, -16504
9D00ACBC  24031000   ADDIU V1, ZERO, 4096
9D00ACC0  AC433008   SW V1, 12296(V0)
1108:                            while((DMACONbits.DMABUSY));    // wait to be actually suspended
9D00ABF0  3C02BF88   LUI V0, -16504
9D00ABF4  8C423000   LW V0, 12288(V0)
9D00ABF8  30420800   ANDI V0, V0, 2048
9D00ABFC  1440FFFC   BNE V0, ZERO, 0x9D00ABF0
9D00AC00  00000000   NOP
9D00ACC4  3C02BF88   LUI V0, -16504
9D00ACC8  8C423000   LW V0, 12288(V0)
9D00ACCC  30420800   ANDI V0, V0, 2048
9D00ACD0  1440FFFC   BNE V0, ZERO, 0x9D00ACC4
9D00ACD4  00000000   NOP
9D00ACD8  0B402B3B   J 0x9D00ACEC
9D00ACDC  00000000   NOP
1109:                        }
1110:                        return suspSt;
9D00AC04  8FC20034   LW V0, 52(S8)
1111:                    }
1112:                
1113:                
1114:                
1115:                    /*********************************************************************
1116:                     * Function:        void DmaResume(int susp)
1117:                     *
1118:                     * PreCondition:    None
1119:                     *
1120:                     * Input:       the desired DMA suspended state.
1121:                     *
1122:                     * Output:          None
1123:                     *
1124:                     * Side Effects:    None
1125:                     *
1126:                     * Overview:        The function restores the DMA controller activity to the old suspended mode.
1127:                     *
1128:                     * Note:            None.
1129:                     *
1130:                     * Example:         int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1131:                     ********************************************************************/
1132:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1133:                    {
1134:                        if(susp)
9D00AC8C  8FC2003C   LW V0, 60(S8)
9D00AC90  10400013   BEQ V0, ZERO, 0x9D00ACE0
9D00AC94  00000000   NOP
1135:                        {
1136:                            DmaSuspend();
1137:                        }
1138:                        else
1139:                        {
1140:                            DMACONCLR=_DMACON_SUSPEND_MASK;     // resume DMA activity
9D00ACE0  3C02BF88   LUI V0, -16504
9D00ACE4  24031000   ADDIU V1, ZERO, 4096
9D00ACE8  AC433004   SW V1, 12292(V0)
1141:                        }
1142:                    }
1143:                
1144:                    /*********************************************************************
1145:                     * Function:        void DmaGetStatus(DmaStatus* pStat)
1146:                     *
1147:                     * PreCondition:    pStat   - valid pointer
1148:                     *
1149:                     * Input:           pStat   - pointer to a DmaStatus structure to store the current DMA controller
1150:                     *                          status, carrying the following info:
1151:                     *                              - chn:  the last active DMA channel
1152:                     *                              - rdOp: the last DMA operation, read/write
1153:                     *                              - lastAddress: the most recent DMA address
1154:                     *
1155:                     * Output:          None
1156:                     *
1157:                     * Side Effects:    None
1158:                     *
1159:                     * Overview:        The function updates the info for the current DMA controller status.
1160:                     *                  It updates the last DMA: operation, channel used and address.
1161:                     *
1162:                     * Note:            None.
1163:                     *
1164:                     * Example:         DmaStatus stat; DmaGetStatus(&stat);
1165:                     ********************************************************************/
1166:                     void           DmaGetStatus(DmaStatus* pStat);
1167:                
1168:                    /*********************************************************************
1169:                     * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1170:                     *
1171:                     * PreCondition:    None
1172:                     *
1173:                     * Input:           gFlags - flags to be set, having the following fields:
1174:                     *          - DMA_GFLG_SUSPEND: DMA controller operation suspend
1175:                     *          - DMA_GFLG_ON: DMA controller enabled/desabled
1176:                     *          - DMA_GFLG_ALL_FLAGS: all flags
1177:                     *
1178:                     * Output:          None
1179:                     *
1180:                     * Side Effects:    None
1181:                     *
1182:                     * Overview:        The function affects the global behavior of the DMA controller.
1183:                     *                  It sets the specified flags. Any flag that is set in the gFlags will be
1184:                     *                  enabled, the other flags won't be touched.
1185:                     *
1186:                     * Note:            None.
1187:                     *
1188:                     * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1189:                     ********************************************************************/
1190:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1191:                    {
1192:                        DMACONSET=gFlags;
1193:                    }
1194:                
1195:                    /*********************************************************************
1196:                     * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1197:                     *
1198:                     * PreCondition:    None
1199:                     *
1200:                     * Input:           gFlags - flags to be cleared, having the following fields:
1201:                     *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1202:                     *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1203:                     *                               - DMA_GFLG_ALL_FLAGS: all flags
1204:                     *
1205:                     * Output:          None
1206:                     *
1207:                     * Side Effects:    None
1208:                     *
1209:                     * Overview:        The function affects the global behavior of the DMA controller.
1210:                     *                  It clears the specified flags. Any flag that is set in the gFlags will be
1211:                     *                  cleared, the other flags won't be touched.
1212:                     *
1213:                     * Note:            None.
1214:                     *
1215:                     * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1216:                     ********************************************************************/
1217:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1218:                    {
1219:                        DMACONCLR=gFlags;
1220:                    }
1221:                
1222:                
1223:                    /*********************************************************************
1224:                     * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1225:                     *
1226:                     * PreCondition:    None
1227:                     *
1228:                     * Input:           gFlags - flags to be set, having the following fields:
1229:                     *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1230:                     *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1231:                     *                                 - DMA_GFLG_ALL_FLAGS: all flags
1232:                     *
1233:                     * Output:          None
1234:                     *
1235:                     * Side Effects:    None
1236:                     *
1237:                     * Overview:        The function affects the global behavior of the DMA controller.
1238:                     *                  It forces the flags to have the specified gFlags value.
1239:                     *
1240:                     * Note:            None.
1241:                     *
1242:                     * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1243:                     ********************************************************************/
1244:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1245:                    {
1246:                        DMACON=gFlags;
1247:                    }
1248:                
1249:                    /*********************************************************************
1250:                     * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1251:                     *
1252:                     * PreCondition:    None
1253:                     *
1254:                     * Input:           None
1255:                     *
1256:                     * Output:          The current DMA controller flags settings.
1257:                     *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1258:                     *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1259:                     *
1260:                     * Side Effects:    None
1261:                     *
1262:                     * Overview:        The function returns the global flags of the DMA controller.
1263:                     *
1264:                     * Note:            None.
1265:                     *
1266:                     * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1267:                     ********************************************************************/
1268:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1269:                    {
1270:                        return (DmaGlblFlags)DMACON;
1271:                    }
1272:                
1273:                
1274:                    /*********************************************************************
1275:                     * Function:        int DmaGetMaxTxferSize(void)
1276:                     *
1277:                     * PreCondition:    None
1278:                     *
1279:                     * Input:           None
1280:                     *
1281:                     * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1282:                     *
1283:                     * Side Effects:    None
1284:                     *
1285:                     * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1286:                     *
1287:                     * Note:            Revision dependant.
1288:                     *
1289:                     * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1290:                     ********************************************************************/
1291:                    extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1292:                    {
1293:                        return 65536;
1294:                    }
1295:                
1296:                    // Direct Channel control functions
1297:                
1298:                    typedef enum
1299:                    {
1300:                        DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1301:                        DMA_CONFIG_AUTO = _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1302:                        DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK), // DMA channel is chained to lower channel
1303:                        DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),       // DMA channel is chained to higher channel
1304:                        DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,            // events detection enabled while channel off
1305:                        DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,             // DMA channel is enabled after open
1306:                        DMA_CONFIG_MATCH    = 0x80000000,                   // DMA channel stops on match
1307:                    }DmaConfigFlags;    // flags for the channel configuration
1308:                
1309:                
1310:                
1311:                    /*********************************************************************
1312:                     * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1313:                     *
1314:                     * PreCondition:    chPri  - valid channel priority, 0-3
1315:                     *
1316:                     * Input:           chn    - channel to be configured in the DMA controller
1317:                     *                  chPri  - the priority given to the channel, 0-3
1318:                     *                  cFlags - orred flags specifying the configuration:
1319:                     *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1320:                     *                           DMA_CONFIG_AUTO:   DMA channel is auto enabled
1321:                     *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1322:                     *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1323:                     *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1324:                     *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1325:                     *                           DMA_CONFIG_MATCH:  DMA channel stops on match
1326:                     *
1327:                     *
1328:                     *
1329:                     * Output:          None
1330:                     *
1331:                     * Side Effects:    None
1332:                     *
1333:                     * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1334:                     *
1335:                     * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1336:                     *                  The channel is just configured.
1337:                     *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1338:                     *                  if DMA_CONFIG_ENABLE flag was not specified.
1339:                     *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1340:                     *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1341:                     *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1342:                     *                  User has to call event channel functions to clear/enable the event flags if needed.
1343:                     *
1344:                     * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1345:                     ********************************************************************/
1346:                    void            DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1347:                
1348:                
1349:                    /*********************************************************************
1350:                     * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1351:                     *
1352:                     * PreCondition:    chn - valid DMA channel
1353:                     *
1354:                     * Input:           chn     - DMA channel number
1355:                     *
1356:                     * Output:          Current channel source pointer.
1357:                     *
1358:                     * Side Effects:    None
1359:                     *
1360:                     * Overview:        The function retrieves the current source pointer for the selected DMA channel.
1361:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1362:                     *
1363:                     * Note:            None
1364:                     *
1365:                     * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1366:                     ********************************************************************/
1367:                     int            DmaChnGetSrcPnt(DmaChannel chn);
1368:                
1369:                    /*********************************************************************
1370:                     * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1371:                     *
1372:                     * PreCondition:    chn - valid DMA channel
1373:                     *
1374:                     * Input:           chn     - DMA channel number
1375:                     *
1376:                     * Output:          Current channel destination pointer.
1377:                     *
1378:                     * Side Effects:    None
1379:                     *
1380:                     * Overview:        The function retrieves the current destination pointer for the selected DMA channel.
1381:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1382:                     *
1383:                     * Note:            None
1384:                     *
1385:                     * Example:         int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1386:                     ********************************************************************/
1387:                     int            DmaChnGetDstPnt(DmaChannel chn);
1388:                
1389:                    /*********************************************************************
1390:                     * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1391:                     *
1392:                     * PreCondition:    chn - valid DMA channel
1393:                     *
1394:                     * Input:           chn     - DMA channel number
1395:                     *
1396:                     * Output:          Current channel transfer pointer.
1397:                     *
1398:                     * Side Effects:    None
1399:                     *
1400:                     * Overview:        The function retrieves the current transfer progress pointer for the selected DMA channel.
1401:                     *                  It ranges 0 to DmaGetMaxTxferSize()-1.
1402:                     *
1403:                     * Note:            None
1404:                     *
1405:                     * Example:         int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1406:                     ********************************************************************/
1407:                     int            DmaChnGetCellPnt(DmaChannel chn);
1408:                
1409:                
1410:                
1411:                    /*********************************************************************
1412:                     * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1413:                     *
1414:                     * PreCondition:    chn - valid DMA channel
1415:                     *
1416:                     * Input:           chn         - DMA channel number
1417:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1418:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1419:                     *                                      - SIRQEN: enable/disable the start IRQ action
1420:                     *                                      - PATEN: enable/disable the pattern match and abort
1421:                     *                                  or any of the DmaEvCtrlFlags:
1422:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1423:                     *
1424:                     *
1425:                     * Output:          None
1426:                     *
1427:                     * Side Effects:    None
1428:                     *
1429:                     * Overview:        The function sets the events that start and abort the transfer
1430:                     *                  for the selected DMA channel.
1431:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1432:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1433:                     *
1434:                     * Note:            None.
1435:                     *
1436:                     * Example:         either:
1437:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1438:                     *                  or:
1439:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1440:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1441:                     *
1442:                     ********************************************************************/
1443:                     void           DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1444:                
1445:                
1446:                    /*********************************************************************
1447:                     * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1448:                     *
1449:                     * PreCondition:    chn - valid DMA channel
1450:                     *
1451:                     * Input:           chn         - DMA channel number
1452:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1453:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1454:                     *                                      - SIRQEN: enable/disable the start IRQ action
1455:                     *                                      - PATEN: enable/disable the pattern match and abort
1456:                     *                                  or any of the DmaEvCtrlFlags:
1457:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1458:                     *
1459:                     *
1460:                     * Output:          None
1461:                     *
1462:                     * Side Effects:    None
1463:                     *
1464:                     * Overview:        The function clears the events that start and abort the transfer
1465:                     *                  for the selected DMA channel.
1466:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1467:                     *                  disabled for the selected channel, the other channel event flags won't be touched.
1468:                     *
1469:                     * Note:            None.
1470:                     *
1471:                     * Example:         either:
1472:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1473:                     *                  or:
1474:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1475:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1476:                     *
1477:                     ********************************************************************/
1478:                     void           DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1479:                
1480:                
1481:                
1482:                    /*********************************************************************
1483:                     * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1484:                     *
1485:                     * PreCondition:    chn - valid DMA channel
1486:                     *
1487:                     * Input:           chn         - DMA channel number
1488:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1489:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1490:                     *                                      - SIRQEN: enable/disable the start IRQ action
1491:                     *                                      - PATEN: enable/disable the pattern match and abort
1492:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1493:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1494:                     *                                  or any of the DmaEvCtrlFlags:
1495:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1496:                     *
1497:                     *
1498:                     * Output:          None
1499:                     *
1500:                     * Side Effects:    None
1501:                     *
1502:                     * Overview:        The function writes the events that start and abort the transfer
1503:                     *                  for the selected DMA channel.
1504:                     *
1505:                     * Note:            None.
1506:                     *
1507:                     * Example:         either:
1508:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1509:                     *                  or:
1510:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1511:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1512:                     *
1513:                     ********************************************************************/
1514:                     void           DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1515:                
1516:                
1517:                
1518:                    /*********************************************************************
1519:                     * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1520:                     *
1521:                     * PreCondition:    chn - valid DMA channel
1522:                     *
1523:                     * Input:           chn         - DMA channel number
1524:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1525:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1526:                     *                                      - SIRQEN: enable/disable the start IRQ action
1527:                     *                                      - PATEN: enable/disable the pattern match and abort
1528:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1529:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1530:                     *                                  or any of the DmaEvCtrlFlags:
1531:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1532:                     *
1533:                     *
1534:                     * Output:          None
1535:                     *
1536:                     * Side Effects:    None
1537:                     *
1538:                     * Overview:        The function sets the events that start and abort the transfer
1539:                     *                  for the selected DMA channel.
1540:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1541:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1542:                     *
1543:                     * Note:           A shorter name for DmaChnWriteEventControlFlags();
1544:                     *
1545:                     * Example:         either:
1546:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1547:                     *                  or:
1548:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1549:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1550:                     *
1551:                     ********************************************************************/
1552:                    #define         DmaChnSetEventControl(chn, dmaEvCtrl)   DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1553:                
1554:                
1555:                    /*********************************************************************
1556:                     * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1557:                     *
1558:                     * PreCondition:    chn - valid DMA channel
1559:                     *
1560:                     * Input:           chn     - DMA channel number
1561:                     *
1562:                     * Output:          -   either a DmaEvCtrl structure field, carrying the following info:
1563:                     *                          - AIRQEN: enable/disable the abort IRQ action
1564:                     *                          - SIRQEN: enable/disable the start IRQ action
1565:                     *                          - PATEN: enable/disable the pattern match and abort
1566:                     *                          - CHSIRQ: IRQ number to start the DMA channel transfer
1567:                     *                          - CHAIRQ: IRQ number to abort the DMA channel transfer
1568:                     *                      or any of the DmaEvCtrlFlags:
1569:                     *                          DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1570:                     *
1571:                     *
1572:                     * Side Effects:    None
1573:                     *
1574:                     * Overview:        The function retrieves the events that start and abort the transfer
1575:                     *                  for the selected DMA channel.
1576:                     *
1577:                     * Note:            None.
1578:                     *
1579:                     * Example:         either:
1580:                     *                      DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1581:                     *                  or:
1582:                     *                      DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1583:                     *
1584:                     ********************************************************************/
1585:                     DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn);
1586:                
1587:                
1588:                    /*********************************************************************
1589:                     * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1590:                     *
1591:                     * PreCondition:    chn - valid DMA channel
1592:                     *
1593:                     * Input:           chn         - DMA channel number
1594:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1595:                     *                                      - autoEn: enable/disable the automatic mode
1596:                     *                                      - chainEn: enable/disable channel chaining
1597:                     *                                      - detectEn: enable/disable events detection when channel disabled
1598:                     *                                      - chEn: enable/disable channel functionality
1599:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1600:                     *                                  or any of the DmaChnCtrlFlags flags:
1601:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1602:                     *
1603:                     * Output:          None
1604:                     *
1605:                     * Side Effects:    None
1606:                     *
1607:                     * Overview:        The function sets the selected DMA channel control flags:
1608:                     *                  the chaining or auto mode, and events detection.
1609:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1610:                     *                  set for the selected channel, the other channel control flags won't be touched.
1611:                     *
1612:                     * Note:            None.
1613:                     *
1614:                     * Example:         either:
1615:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1616:                     *                  or:
1617:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1618:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1619:                     *
1620:                     ********************************************************************/
1621:                     void           DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1622:                
1623:                    /*********************************************************************
1624:                     * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1625:                     *
1626:                     * PreCondition:    chn - valid DMA channel
1627:                     *
1628:                     * Input:           chn         - DMA channel number
1629:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1630:                     *                                      - autoEn: enable/disable the automatic mode
1631:                     *                                      - chainEn: enable/disable channel chaining
1632:                     *                                      - detectEn: enable/disable events detection when channel disabled
1633:                     *                                      - chEn: enable/disable channel functionality
1634:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1635:                     *                                  or any of the DmaChnCtrlFlags flags:
1636:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1637:                     *
1638:                     * Output:          None
1639:                     *
1640:                     * Side Effects:    None
1641:                     *
1642:                     * Overview:        The function clears the selected DMA channel control flags:
1643:                     *                  the chaining or auto mode and events detection.
1644:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1645:                     *                  cleared for the selected channel, the other channel control flags won't be touched.
1646:                     *
1647:                     * Note:            None.
1648:                     *
1649:                     * Example:         either:
1650:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1651:                     *                  or:
1652:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1653:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1654:                     *
1655:                     ********************************************************************/
1656:                     void           DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1657:                
1658:                    /*********************************************************************
1659:                     * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1660:                     *
1661:                     * PreCondition:    chn - valid DMA channel
1662:                     *
1663:                     * Input:           chn         - DMA channel number
1664:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1665:                     *                                      - chPri: channel priority 0-3
1666:                     *                                      - autoEn: enable/disable the automatic mode
1667:                     *                                      - chainEn: enable/disable channel chaining
1668:                     *                                      - detectEn: enable/disable events detection when channel disabled
1669:                     *                                      - chEn: enable/disable channel functionality
1670:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1671:                     *                                  or any of the DmaChnCtrlFlags flags:
1672:                     *                                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1673:                     *
1674:                     * Output:          None
1675:                     *
1676:                     * Side Effects:    None
1677:                     *
1678:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1679:                     *                  the channel priority, chaining mode or auto and events detection.
1680:                     *
1681:                     * Note:            None.
1682:                     *
1683:                     * Example:         either:
1684:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1685:                     *                  or:
1686:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1687:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1688:                     *
1689:                     ********************************************************************/
1690:                     void           DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1691:                
1692:                    /*********************************************************************
1693:                     * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1694:                     *
1695:                     * PreCondition:    chn - valid DMA channel
1696:                     *
1697:                     * Input:       chn     - DMA channel number
1698:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1699:                     *                      - chPri: channel priority 0-3
1700:                     *                      - autoEn: enable/disable the automatic mode
1701:                     *                      - chainEn: enable/disable channel chaining
1702:                     *                      - detectEn: enable/disable events detection when channel disabled
1703:                     *                      - chEn: enable/disable channel functionality
1704:                     *                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1705:                     *                  or any of the DmaChnCtrlFlags flags:
1706:                     *                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1707:                     *
1708:                     * Output:          None
1709:                     *
1710:                     * Side Effects:    None
1711:                     *
1712:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1713:                     *                  the channel priority, chaining mode or auto and events detection.
1714:                     *
1715:                     * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1716:                     *
1717:                     * Example:         either:
1718:                     *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1719:                     *                  or:
1720:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1721:                     *          DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1722:                     *
1723:                     ********************************************************************/
1724:                    #define     DmaChnSetControl(chn, dmaChnCtrl)   DmaChnWriteControlFlags(chn, dmaChnCtrl)
1725:                
1726:                    /*********************************************************************
1727:                     * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1728:                     *
1729:                     * PreCondition:    chn - valid DMA channel
1730:                     *
1731:                     * Input:           chn         - DMA channel number
1732:                     *
1733:                     * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1734:                     *                          - chPri: channel priority 0-3
1735:                     *                          - autoEn: enable/disable the automatic mode
1736:                     *                          - chainEn: enable/disable channel chaining
1737:                     *                          - detectEn: enable/disable events detection when channel disabled
1738:                     *                          - chEn: enable/disable channel functionality
1739:                     *                          - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1740:                     *                      or any of the DmaChnCtrlFlags flags:
1741:                     *                          DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1742:                     *
1743:                     * Side Effects:    None
1744:                     *
1745:                     * Overview:        The function retrieves the current control settings for the selected DMA channel,
1746:                     *                  including the channel enable/disable status, the channel priority,
1747:                     *                  chaining mode, auto mode and events detection.
1748:                     *
1749:                     * Note:            None.
1750:                     *
1751:                     * Example:         either:
1752:                     *                      DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1753:                     *                  or:
1754:                     *                      DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1755:                     *
1756:                     ********************************************************************/
1757:                     DmaChnCtrlFlags    DmaChnGetControlFlags(DmaChannel chn);
1758:                
1759:                
1760:                    /*********************************************************************
1761:                     * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1762:                     *
1763:                     * PreCondition:    chn - valid DMA channel
1764:                     *
1765:                     * Input:           chn     - DMA channel number
1766:                     *
1767:                     * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1768:                     *
1769:                     * Side Effects:    None
1770:                     *
1771:                     * Overview:        The function returns the current event detection for the selected DMA channel.
1772:                     *
1773:                     * Note:            None.
1774:                     *
1775:                     * Example:         int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1776:                     *
1777:                     ********************************************************************/
1778:                     int            DmaChnGetEvDetect(DmaChannel chn);
1779:                
1780:                    /*********************************************************************
1781:                     * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1782:                     *
1783:                     * PreCondition:    chn     - valid DMA channel
1784:                     *                  pTxCtrl - valid pointer
1785:                     *
1786:                     * Input:           chn         - DMA channel number
1787:                     *                  pTxCtrl     - pointer to a DmaTxferCtrl that will carry the following info:
1788:                     *                              - vSrcAdd: source of the DMA transfer
1789:                     *                              - vDstAdd: destination of the DMA transfer
1790:                     *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1791:                     *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1792:                     *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1793:                     *                  mapToK0     - if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1794:                     *
1795:                     * Output:          None
1796:                     *
1797:                     * Side Effects:    None
1798:                     *
1799:                     * Overview:        The function retrieves the transfer characteristics for a DMA channel transfer:
1800:                     *                  the source and the destination addresses.
1801:                     *                  It also retrieves the source and destination lengths
1802:                     *                  and the number of bytes transferred per event.
1803:                     *
1804:                     * Note:            None
1805:                     *
1806:                     * Example:         DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1807:                     ********************************************************************/
1808:                     void           DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1809:                
1810:                    // Low level checksum functions
1811:                
1812:                    /*********************************************************************
1813:                     * Function:        void DmaSfmEnable(int enable)
1814:                     *
1815:                     * PreCondition:    None
1816:                     *
1817:                     * Input:           enable _ boolean to enable/disable the SFM functionality
1818:                     *
1819:                     * Output:          None
1820:                     *
1821:                     * Side Effects:    None
1822:                     *
1823:                     * Overview:        The function enables/diables the checksum module functionality.
1824:                     *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1825:                     *
1826:                     * Note:            The SFM module should be properly configured before enabled.
1827:                     *
1828:                     * Example:         DmaSfmEnable(1);
1829:                     ********************************************************************/
1830:                    extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1831:                    {
1832:                        if(enable)
1833:                        {
1834:                            DCRCCONSET=_DCRCCON_CRCEN_MASK;
1835:                        }
1836:                        else
1837:                        {
1838:                            DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1839:                        }
1840:                    }
1841:                    #define DmaCrcEnable    DmaSfmEnable        // PIC32_3xx backward compatibility
1842:                
1843:                
1844:                    /*********************************************************************
1845:                     * Function:        int DmaSfmGetEnable(void)
1846:                     *
1847:                     * PreCondition:    None
1848:                     *
1849:                     * Input:           None
1850:                     *
1851:                     * Output:          TRUE, if the SFM module is enabled
1852:                     *          FALSE otherwise
1853:                     *
1854:                     * Side Effects:    None
1855:                     *
1856:                     * Overview:        The function returns the SFM module enabling status.
1857:                     *
1858:                     * Note:            None
1859:                     *
1860:                     * Example:     int isSfmEnabled=DmaSfmGetEnable();
1861:                     ********************************************************************/
1862:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1863:                    {
1864:                        return DCRCCONbits.CRCEN!=0;
1865:                    }
1866:                    #define     DmaCrcGetEnable     DmaSfmGetEnable     // PIC32_3xx backward compatibility
1867:                
1868:                
1869:                    /*********************************************************************
1870:                     * Function:        void DmaSfmAppendEnable(int enable)
1871:                     *
1872:                     * PreCondition:    None
1873:                     *
1874:                     * Input:           enable _ boolean to enable/disable the SFM append mode
1875:                     *
1876:                     * Output:          None
1877:                     *
1878:                     * Side Effects:    None
1879:                     *
1880:                     * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1881:                     *                  the source data but does not write it to the destination address. The data it's just passed
1882:                     *                  to the checksum generator for CRC/IP checksum calculation.
1883:                     *                  When the block transfer is completed, the checksum result is written to the
1884:                     *                  DMA channel destination address.
1885:                     *
1886:                     * Note:            The SFM module should be properly configured before enabled.
1887:                     *
1888:                     * Example:         DmaSfmAppendModeEnable(TRUE);
1889:                     ********************************************************************/
1890:                    extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1891:                    {
1892:                        if(enable)
1893:                        {
1894:                            DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1895:                        }
1896:                        else
1897:                        {
1898:                            DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1899:                        }
1900:                    }
1901:                    #define     DmaCrcAppendModeEnable  DmaSfmAppendEnable  // PIC32_3xx backward compatibility
1902:                
1903:                
1904:                    /*********************************************************************
1905:                     * Function:        int DmaSfmGetAppendMode(void)
1906:                     *
1907:                     * PreCondition:    None
1908:                     *
1909:                     * Input:           None
1910:                     *
1911:                     * Output:          TRUE, if the SFM append mode is enabled
1912:                     *                  FALSE otherwise
1913:                     *
1914:                     * Side Effects:    None
1915:                     *
1916:                     * Overview:        The function returns the SFM module enabling status.
1917:                     *
1918:                     * Note:            None
1919:                     *
1920:                     * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1921:                     ********************************************************************/
1922:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1923:                    {
1924:                        return DCRCCONbits.CRCAPP!=0;
1925:                    }
1926:                    #define DmaCrcGetAppendMode DmaSfmGetAppendMode     // PIC32_3xx backward compatibility
1927:                
1928:                
1929:                    /*********************************************************************
1930:                     * Function:        void DmaSfmSetAttach(DmaChannel chn)
1931:                     *
1932:                     * PreCondition:    chn     - valid DMA channel
1933:                     *
1934:                     * Input:           chn - the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1935:                     *
1936:                     * Output:          None
1937:                     *
1938:                     * Side Effects:    None
1939:                     *
1940:                     * Overview:        The function directly attaches a DMA channel to the SFM module.
1941:                     *
1942:                     * Note:            None
1943:                     *
1944:                     * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1945:                     ********************************************************************/
1946:                    extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1947:                    {
1948:                        DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1949:                        DCRCCONSET=chn;
1950:                    }
1951:                    #define     DmaCrcSetAttach     DmaSfmSetAttach     // PIC32_3xx backward compatibility
1952:                
1953:                
1954:                    /*********************************************************************
1955:                     * Function:        DmaChannel DmaSfmGetAttach(void)
1956:                     *
1957:                     * PreCondition:    None
1958:                     *
1959:                     * Input:           None
1960:                     *
1961:                     * Output:          the DMA channel that is currently attached to the CRC module
1962:                     *
1963:                     * Side Effects:    None
1964:                     *
1965:                     * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1966:                     *
1967:                     * Note:            None
1968:                     *
1969:                     * Example:         DmaChannel chn=DmaSfmGetAttach();
1970:                     ********************************************************************/
1971:                    extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1972:                    {
1973:                        return (DmaChannel)DCRCCONbits.CRCCH;
1974:                    }
1975:                    #define     DmaCrcGetAttach     DmaSfmGetAttach     // PIC32_3xx backward compatibility
1976:                
1977:                    /*********************************************************************
1978:                     * Function:        void DmaCrcSetPLen(int pLen)
1979:                     *
1980:                     * PreCondition:    pLen - valid polynomial length within 1-32
1981:                     *
1982:                     * Input:           pLen    - the length of the CRC generator polynomial
1983:                     *
1984:                     * Output:          None
1985:                     *
1986:                     * Side Effects:    None
1987:                     *
1988:                     * Overview:        The length of the CRC generator polynomial is set as being pLen;
1989:                     *
1990:                     * Note:            None
1991:                     *
1992:                     * Example:         DmaCrcSetPLen(32);
1993:                     ********************************************************************/
1994:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
1995:                    {
1996:                        DCRCCONCLR=_DCRCCON_PLEN_MASK;
1997:                        DCRCCONSET=(pLen)-1;
1998:                    }
1999:                
2000:                    /*********************************************************************
2001:                     * Function:        int DmaCrcGetPLen(void)
2002:                     *
2003:                     * PreCondition:    None
2004:                     *
2005:                     * Input:           None
2006:                     *
2007:                     * Output:          the length of the CRC generator polynomial
2008:                     *
2009:                     * Side Effects:    None
2010:                     *
2011:                     * Overview:        The function returns the current length of the CRC generator polynomial.
2012:                     *                  It's always a number between 1 and 32.
2013:                     *
2014:                     * Note:            None
2015:                     *
2016:                     * Example:         int polyLen=DmaCrcGetPLen();
2017:                     ********************************************************************/
2018:                    extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2019:                    {
2020:                        return  DCRCCONbits.PLEN+1;
2021:                    }
2022:                
2023:                    /*********************************************************************
2024:                     * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2025:                     *
2026:                     * PreCondition:    None
2027:                     *
2028:                     * Input:           feedback - the layout of the CRC generator
2029:                     *
2030:                     * Output:          None
2031:                     *
2032:                     * Side Effects:    None
2033:                     *
2034:                     * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2035:                     *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2036:                     *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2037:                     *
2038:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2039:                     *
2040:                     * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2041:                     ********************************************************************/
2042:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2043:                    {
2044:                        DCRCXOR=feedback;
2045:                    }
2046:                
2047:                
2048:                    /*********************************************************************
2049:                     * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2050:                     *
2051:                     * PreCondition:    None
2052:                     *
2053:                     * Input:           None
2054:                     *
2055:                     * Output:          the current layout of the CRC generator
2056:                     *
2057:                     * Side Effects:    None
2058:                     *
2059:                     * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2060:                     *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2061:                     *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2062:                     *
2063:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2064:                     *
2065:                     * Example:         int feedback=DmaCrcGetShiftFeedback();
2066:                     ********************************************************************/
2067:                    extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2068:                    {
2069:                        return DCRCXOR;
2070:                    }
2071:                
2072:                
2073:                
2074:                    // Channel test/debug and special functions
2075:                
2076:                    /*********************************************************************
2077:                     * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2078:                     *
2079:                     * PreCondition:    chn - valid DMA channel
2080:                     *
2081:                     * Input:           chn     - DMA channel number
2082:                     *                  eFlags  - event flags with the following significance:
2083:                     *                              - DMA_EV_ERR: address error event
2084:                     *                              - DMA_EV_ABORT: transfer abort event
2085:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2086:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2087:                     *                              - DMA_EV_DST_HALF: destination half event
2088:                     *                              - DMA_EV_DST_FULL: destination full event
2089:                     *                              - DMA_EV_SRC_HALF: source half event
2090:                     *                              - DMA_EV_SRC_FULL: source full event
2091:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2092:                     *
2093:                     * Output:          None
2094:                     *
2095:                     * Side Effects:    None
2096:                     *
2097:                     * Overview:        The function sets the event flags for the selected DMA channel.
2098:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2099:                     *                  set for the selected channel, the other channel event flags won't be touched.
2100:                     *
2101:                     * Note:            This is intended as a channel test function.
2102:                     *
2103:                     * Example:         DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2104:                     ********************************************************************/
2105:                     void           DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2106:                
2107:                    /*********************************************************************
2108:                     * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2109:                     *
2110:                     * PreCondition:    chn - valid DMA channel
2111:                     *
2112:                     * Input:           chn     - DMA channel number
2113:                     *                  eFlags  - event flags with the following significance:
2114:                     *                              - DMA_EV_ERR: address error event
2115:                     *                              - DMA_EV_ABORT: transfer abort event
2116:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2117:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2118:                     *                              - DMA_EV_DST_HALF: destination half event
2119:                     *                              - DMA_EV_DST_FULL: destination full event
2120:                     *                              - DMA_EV_SRC_HALF: source half event
2121:                     *                              - DMA_EV_SRC_FULL: source full event
2122:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2123:                     *
2124:                     * Output:          None
2125:                     *
2126:                     * Side Effects:    None
2127:                     *
2128:                     * Overview:        The function writes the event flags for the selected DMA channel.
2129:                     *                  The channel event flags are forced to the eFlags value.
2130:                     *
2131:                     * Note:            This is intended as a channel test function.
2132:                     *
2133:                     * Example:         DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2134:                     ********************************************************************/
2135:                     void           DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2136:                
2137:                
2138:                    /********************************************************************
2139:                     * Include legacy DMA functions
2140:                     * New projects should not use them!
2141:                     * Note that interrupt functions are no longer provided.
2142:                     * The functions in the int.h should be used instead.
2143:                     ********************************************************************/
2144:                    #ifndef _PLIB_DISABLE_LEGACY
2145:                        #include <peripheral/legacy/dma_legacy.h>
2146:                    #endif
2147:                
2148:                
2149:                #else
2150:                    #undef _DMA_CHANNELS        // no DMA channels
2151:                #endif  // _DMAC0
2152:                
2153:                #endif /*_DMA_H_*/
2154:                
2155:                
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/sound.c  ------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   sound.c
20:                   * Author: Jacques Deschênes
21:                   *
22:                   * Created on 13 septembre 2013, 20:42
23:                   */
24:                  
25:                  #include "hardware/HardwareProfile.h"
26:                  
27:                  volatile unsigned char tone_on=0;
28:                  volatile unsigned int duration;
29:                  
30:                  void tone(unsigned int freq, // fréquence en hertz
31:                            unsigned int msec){ // durée en  millisecondes
00000000  00000000   NOP
00000004  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
32:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
33:                      OC3CONbits.OCM = 5; //mode pwm
00000014  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
34:                      OC3CONbits.OCTSEL=1; // timer 3
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
35:                      T3CON=0;
0000003C  00000000   NOP
00000040  00000000   NOP
36:                      PR3=(SYSCLK/8/freq)-1; // rapport cyclique 50%
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000050  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
0000005C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
00000068  00000000   NOP
37:                      OC3RS=0;
0000006C  00000000   NOP
00000070  00000000   NOP
38:                      OC3R=SYSCLK/16/freq;
00000074  00000000   NOP
00000078  00000000   NOP
0000007C  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
0000008C  00000000   NOP
00000090  00000000   NOP
00000094  00000000   NOP
00000098  00000000   NOP
39:                      OC3CONbits.ON=1;
0000009C  00000000   NOP
000000A0  00000000   NOP
000000A4  00000000   NOP
000000A8  00000000   NOP
000000AC  00000000   NOP
40:                      duration=msec;
000000B0  00000000   NOP
000000B4  00000000   NOP
41:                      tone_on=1;
000000B8  00000000   NOP
000000BC  00000000   NOP
42:                      T3CONbits.TCKPS=3;
000000C0  00000000   NOP
000000C4  00000000   NOP
000000C8  00000000   NOP
000000CC  00000000   NOP
000000D0  00000000   NOP
43:                      T3CONbits.ON=1;
000000D4  00000000   NOP
000000D8  00000000   NOP
000000DC  00000000   NOP
000000E0  00000000   NOP
000000E4  00000000   NOP
44:                  } //tone();
000000E8  00000000   NOP
000000EC  00000000   NOP
000000F0  00000000   NOP
000000F4  00000000   NOP
000000F8  00000000   NOP
45:                  
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/resources/eForth-mips/eForth_test.X/eForth_test.c  ------
1:                   /* 
2:                    * File:   eForth_test.c
3:                    * Author: Jacques
4:                    *
5:                    * Created on 14 septembre 2013, 08:07
6:                    */
7:                   
8:                   #include <stdio.h>
9:                   #include <stdlib.h>
10:                  #include "../../../hardware/HardwareProfile.h"
11:                  #include "../../../hardware/serial_comm.h"
12:                  
13:                  // PIC32MX150F128B Configuration Bit Settings
14:                  #include <xc.h>
15:                  
16:                  // DEVCFG3
17:                  // USERID = No Setting
18:                  #pragma config PMDL1WAY = OFF           // permet plusieurs configurations des périphériques.
19:                  #pragma config IOL1WAY = OFF            // permet plusieurs configuration des broches.
20:                  
21:                  // DEVCFG2
22:                  #pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
23:                  #if SYSCLK==40000000L
24:                  #pragma config FPLLMUL = MUL_16         // SYSCLK=40Mhz
25:                  #else
26:                  #pragma config FPLLMUL = MUL_15          // PLL Multiplier (15x Multiplier) SYSCLK=37,5Mhz
27:                  #endif
28:                  #pragma config FPLLODIV = DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)
29:                  
30:                  // DEVCFG1
31:                  #pragma config FNOSC = PRIPLL           // Oscillator Selection Bits (Primary Osc w/PLL (XT+,HS+,EC+PLL))
32:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
33:                  #pragma config IESO = OFF               // Internal/External Switch Over (Disabled)
34:                  #pragma config POSCMOD = HS             // Primary Oscillator Configuration (XT osc mode)
35:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
36:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
37:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
38:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
39:                  
40:                  // DEVCFG0
41:                  #pragma config JTAGEN = OFF             // JTAG Enable (JTAG Disabled)
42:                  #pragma config ICESEL = ICS_PGx1        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
43:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
44:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
45:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
46:                  
47:                  extern void eForth(void);
48:                  
49:                  char *text[80];
50:                  void debug_print(char *fmt, unsigned int a, unsigned int b, unsigned int c){
9D00C844  27BDFFE0   ADDIU SP, SP, -32
9D00C848  AFBF001C   SW RA, 28(SP)
9D00C84C  AFBE0018   SW S8, 24(SP)
9D00C850  03A0F021   ADDU S8, SP, ZERO
9D00C854  AFC40020   SW A0, 32(S8)
9D00C858  AFC50024   SW A1, 36(S8)
9D00C85C  AFC60028   SW A2, 40(S8)
9D00C860  AFC7002C   SW A3, 44(S8)
51:                      sprintf((char*)text, fmt, a,b,c);
9D00C864  3C02A000   LUI V0, -24576
9D00C868  24420048   ADDIU V0, V0, 72
9D00C86C  8FC3002C   LW V1, 44(S8)
9D00C870  AFA30010   SW V1, 16(SP)
9D00C874  00402021   ADDU A0, V0, ZERO
9D00C878  8FC50020   LW A1, 32(S8)
9D00C87C  8FC60024   LW A2, 36(S8)
9D00C880  8FC70028   LW A3, 40(S8)
9D00C884  0F4032B2   JAL sprintf
9D00C888  00000000   NOP
52:                      UartPrint(STDOUT, (char*)text);
9D00C88C  3C02A000   LUI V0, -24576
9D00C890  24420048   ADDIU V0, V0, 72
9D00C894  24040001   ADDIU A0, ZERO, 1
9D00C898  00402821   ADDU A1, V0, ZERO
9D00C89C  0F4029ED   JAL UartPrint
9D00C8A0  00000000   NOP
53:                  } // debug_print
9D00C8A4  03C0E821   ADDU SP, S8, ZERO
9D00C8A8  8FBF001C   LW RA, 28(SP)
9D00C8AC  8FBE0018   LW S8, 24(SP)
9D00C8B0  27BD0020   ADDIU SP, SP, 32
9D00C8B4  03E00008   JR RA
9D00C8B8  00000000   NOP
54:                  
55:                  /*
56:                   * 
57:                   */
58:                  void main(void) {
9D00C8BC  27BDFFE8   ADDIU SP, SP, -24
9D00C8C0  AFBF0014   SW RA, 20(SP)
9D00C8C4  AFBE0010   SW S8, 16(SP)
9D00C8C8  03A0F021   ADDU S8, SP, ZERO
59:                      HardwareInit();
9D00C8CC  0F402AC0   JAL HardwareInit
9D00C8D0  00000000   NOP
60:                      UartInit(STDIO,115200,DEFAULT_LINE_CTRL);
9D00C8D4  24040001   ADDIU A0, ZERO, 1
9D00C8D8  3C020001   LUI V0, 1
9D00C8DC  3445C200   ORI A1, V0, -15872
9D00C8E0  00003021   ADDU A2, ZERO, ZERO
9D00C8E4  0F40292B   JAL UartInit
9D00C8E8  00000000   NOP
61:                      while (1){
62:                         eForth();
9D00C8EC  0F402458   JAL 0x9D009160
9D00C8F0  00000000   NOP
63:                         UartPrint(STDOUT,"VM crashed!\r restarting it.\r");
9D00C8F4  24040001   ADDIU A0, ZERO, 1
9D00C8F8  3C029D01   LUI V0, -25343
9D00C8FC  2445CD58   ADDIU A1, V0, -12968
9D00C900  0F4029ED   JAL UartPrint
9D00C904  00000000   NOP
64:                      }
9D00C908  0B40323B   J 0x9D00C8EC
9D00C90C  00000000   NOP
65:                  }
66:                  
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/resources/eForth-mips/EF.S  -----------------------------
                                                  1:     # REF: http://www.offete.com/files/zeneForth.htm
                                                  2:     # REF: https://getinfo.de/app/MIPS-eForth/id/BLCP%3ACN011970047
                                                  3:     # REF: http://www.offete.com/eforth1.html
                                                  4:     # cat ef.s
                                                  5:     # cat: cannot open ef.s
                                                  6:     # <104 weaver2 /people/ting> cd work
                                                  7:     # Depend.awk            Makefile.log          ls/
                                                  8:     # DoubleDefines         _c/                   polys
                                                  9:     # Makefile              _c.1/                 progname*
                                                  10:    # Makefile.BAK          _h/                   progname.awk*
                                                  11:    # Makefile.bak          _o/                   we.93.Jul.19*
                                                  12:    # Makefile.bak.930717   backup/               we.93.Jul.4*
                                                  13:    # <105 weaver2 /ting/work> cd ls
                                                  14:    # a.out*           eForth.s.14      ef.s.2           test*
                                                  15:    # calling.c        eForth.s.15      ef.s.3           test.c
                                                  16:    # calling.c.1      eForth.s.16      ef.s.4           test.c.BAK
                                                  17:    # calling.o        eForth.s.17      ef.s.5           test.s
                                                  18:    # calling.s        eForth.s.2       ef.s.6           test.x
                                                  19:    # circuit.c        eForth.s.3       ef.s.7           trees.f
                                                  20:    # circuit.f        eForth.s.5       ef.s.8           tty
                                                  21:    # circuit.s        eForth.s.6       ef.s.9           tty:
                                                  22:    # code.patterns    eForth.s.7       ef.s.BAK         ttyd1
                                                  23:    # copy.of.test.c   eForth.s.8       efg.s            ttyd2
                                                  24:    # core             eForth.s.9       files            ttyf1
                                                  25:    # device.f         eForth.s.BAK     flower.f         ttyf2
                                                  26:    # e.l              eForth.s.CKP     flower2.f        ttym1
                                                  27:    # eForth.backup    ef.l             gl/              ttym2
                                                  28:    # eForth.new       ef.o             gl.h@            walnut.f
                                                  29:    # eForth.nl        ef.s             hi.f             win.f
                                                  30:    # eForth.o         ef.s.1           man.f            yin.f
                                                  31:    # eForth.s         ef.s.10          mandelbrot.f     yin1.f
                                                  32:    # eForth.s.10      ef.s.11          plot.f           yin2.f
                                                  33:    # eForth.s.11      ef.s.12          red.c            yin3.f
                                                  34:    # eForth.s.12      ef.s.13          red.s            yin4.f
                                                  35:    # eForth.s.13      ef.s.14          symbols
                                                  36:    # <106 weaver2 /work/ls> ^@  cat ef.s
                                                  37:    
                                                  38:     #      Debugged through OVERT, where a segmentation fault
                                                  39:     #      occurred because o storing LAST into FORTH. 7/23/93 cht
                                                  40:     #      Change vocabulary data field to .data segment.
                                                  41:     #      Use scanf to get a line in QUERY.  scanf does not return
                                                  42:     #      character count.  sad.
                                                  43:     #      Try read() to get characters one at a time.
                                                  44:     #      7/30/93 interpreter works.  does not compile due to segmentation.
                                                  45:     #      8/3/93  Change to indirect threaded code.  separate code
                                                  46:     #              from colon definitions.  compiler works.
                                                  47:     #      8/6/93  Test read file hi.f.
                                                  48:     #      8/8/93  Test INCLUDE.  Works ine on hi.f.
                                                  49:     #      8/10/93 Full optimization
                                                  50:     #              Add dovar, docon, douse, dovov.
                                                  51:     #              Copied from eForth.s.17
                                                  52:     #              Add 0, 1, 2, 3 and replace 'DOLIT,0' and 'DOLIT,1'.
                                                  53:     #              Add GRAPHICS and APPLICATION vocabularies.
                                                  54:     #              Change all user variables, variables and vocs.
                                                  55:     #      8/12/93 Add floating point package.
                                                  56:     #      8/15/93 Add graphics package.  Initial entering word list.
                                                  57:     #      8/18/93 Add F<.  Failed to fix UM/MOD.
                                                  58:     #      8/19/93 Implement true UM/MOD and high level */MOD.
                                                  59:     #      8/20/93 Add low level Mandelbrot words.
                                                  60:     #      8/21/93 Mandelbrot debugged.  INCLUDE win.f and man.f files.
                                                  61:     #              Add input device interface.
                                                  62:     #      8/25/93 Add cpack, gconfig, polf, polfi, and RGBmode.
                                                  63:     #      8/26/93 Add lookat and perspective.
                                                  64:     #      9/08/93 Add 2*, 2/, pnt2i and pnti.
                                                  65:     #      9/09/93 Fix draw2i and move2i for fern drawing.
                                                  66:    
                                                  67:    .extern UartPutch
                                                  68:    .extern UartGetch
                                                  69:    .extern UartReadln
                                                  70:    .extern UartPrint
                                                  71:    .extern debug_print
                                                  72:    .extern UartWaitch
                                                  73:    
                                                  74:    #define stdin    1
                                                  75:    #define stdout   1
                                                  76:    
                                                  77:    #define getchar UartGetch
                                                  78:    #define putchar UartPutch
                                                  79:    #define read    UartReadln
                                                  80:    #define print   UartPrint
                                                  81:    #define printf  debug_print
                                                  82:    #define waitch  UartWaitch
                                                  83:    
                                                  84:            .verstamp       2 40
                                                  85:            .align  4, 0xFF
                                                  86:            .set    macro
                                                  87:            .set    noreorder
                                                  88:    
                                                  89:            COMPO=0X40
                                                  90:            IMEDD=0X80
                                                  91:            MASKK=0X1F7F7F7F
                                                  92:            CELLL=4
                                                  93:            BASEE=10
                                                  94:            VOCSS=8
                                                  95:            BKSPP=8
                                                  96:            LF=10
                                                  97:            CRR=13          # can''t input a CR
                                                  98:            ERR=27
                                                  99:            TIC=39
                                                  100:   
                                                  101:   #     ax=$t0
                                                  102:   #     bx=$t1
                                                  103:   #     cx=$t2
                                                  104:   #     dx=$t3
                                                  105:   
                                                  106:       DP=$s0  # vm data stack pointer
                                                  107:       RP=$s1  # vm return address stack pointer
                                                  108:       IP=$s2  # vm instruction pointer
                                                  109:       WP=$s3  # vm working pointer
                                                  110:   
                                                  111:   
                                                  112:           .text
                                                  113:           .globl  eForth
                                                  114:           .ent    eForth
                                                  115:   
9D009160  3C01A000   LUI AT, -24576               116:   eForth: sw      DP, SAVSP
9D009164  AC30065C   SW S0, 1628(AT)
9D009168  3C01A000   LUI AT, -24576               117:           sw      $ra, SAVLINK
9D00916C  AC3F0658   SW RA, 1624(AT)
9D009170  3C10A000   LUI S0, -24576               118:           la      DP, SPP-12
9D009174  2610037C   ADDIU S0, S0, 892
9D009178  AE130008   SW S3, 8(S0)                 119:           sw      WP, 8(DP)
9D00917C  AE110004   SW S1, 4(S0)                 120:           sw      RP, 4(DP)
9D009180  AE120000   SW S2, 0(S0)                 121:           sw      IP, 0(DP)
9D009184  27BDFFC0   ADDIU SP, SP, -64            122:           subu    $sp, $sp, 64
9D009188  00000000   NOP                          123:           nop
                                                  124:   
                                                  125:   
9D00918C  3C129D00   LUI S2, -25344               126:           la      IP, COLD1
9D009190  2652687C   ADDIU S2, S2, 26748
                                                  127:   
                                                  128:    # Test High Level Words
                                                  129:    #      la      IP, QUERY+8
                                                  130:    #      la      IP, IOTST+8
                                                  131:   
                                                  132:    #      addiu   DP, -8         # test 'find'
                                                  133:    #      la      $t0, FVOC
                                                  134:    #      sw      $t0, 0(DP)
                                                  135:    #      la      $t0, p6
                                                  136:    #      sw      $t0, 4(DP)
                                                  137:    #      la      IP, FIND+8
                                                  138:   
9D009194  3C11A000   LUI S1, -24576               139:           la      RP, RPP-4
9D009198  26310588   ADDIU S1, S1, 1416
9D00919C  3C01A000   LUI AT, -24576               140:           sw      IP, RPP-4
9D0091A0  AC320588   SW S2, 1416(AT)
                                                  141:   
                                                  142:    # Indirect threaded inner interpreter.
                                                  143:   
                                                  144:   $next:
9D0091A4  3C08A000   LUI T0, -24576               145:           la     $t0, TRACE
9D0091A8  25080660   ADDIU T0, T0, 1632
9D0091AC  8D090000   LW T1, 0(T0)                 146:           lw     $t1, 0($t0)
9D0091B0  11200003   BEQ T1, ZERO, 0x9D0091C0     147:           beqz   $t1, 1f
9D0091B4  00000000   NOP                          148:           nop
9D0091B8  0F402476   JAL 0x9D0091D8               149:           jal    DBG
9D0091BC  00000000   NOP                          150:           nop
                                                  151:   1:
9D0091C0  8E480000   LW T0, 0(S2)                 152:           lw      $t0, 0(IP)      # get next word in list
9D0091C4  26520004   ADDIU S2, S2, 4              153:           addiu   IP, IP, 4     # increment ip
9D0091C8  8D090000   LW T1, 0(T0)                 154:           lw      $t1, 0($t0)       # get address in code field
9D0091CC  01009821   ADDU S3, T0, ZERO            155:           move    WP, $t0
9D0091D0  01200008   JR T1                        156:           j       $t1              # indirect jump to next word
9D0091D4  26730004   ADDIU S3, S3, 4              157:           addiu   WP, WP, 4     # set up wp to pfa
                                                  158:           
                                                  159:    # Call DBG in $next or in dolst to sinlge step Forth code.
                                                  160:   
9D0091D8  3C01A000   LUI AT, -24576               161:   DBG:    sw      DP, ULAST      # display sp, ip, wp
9D0091DC  AC300624   SW S0, 1572(AT)
9D0091E0  3C01A000   LUI AT, -24576               162:           sw      RP, ULAST+4    #         s0, s1, s2
9D0091E4  AC310628   SW S1, 1576(AT)
9D0091E8  3C01A000   LUI AT, -24576               163:           sw      IP, ULAST+8    #         rp, r0, r1
9D0091EC  AC32062C   SW S2, 1580(AT)
9D0091F0  3C01A000   LUI AT, -24576               164:           sw      $ra, ULAST+12   # call from either $next or dolst
9D0091F4  AC3F0630   SW RA, 1584(AT)
9D0091F8  3C01A000   LUI AT, -24576               165:           sw      WP, ULAST+16
9D0091FC  AC330634   SW S3, 1588(AT)
9D009200  3C049D00   LUI A0, -25344               166:           la      $a0, msg9
9D009204  24847605   ADDIU A0, A0, 30213
9D009208  02002821   ADDU A1, S0, ZERO            167:           move    $a1, DP
9D00920C  02403021   ADDU A2, S2, ZERO            168:           move    $a2, IP
9D009210  8E470000   LW A3, 0(S2)                 169:           lw      $a3, 0(IP)
9D009214  0F403211   JAL 0x9D00C844               170:           jal     printf
9D009218  00000000   NOP                          171:           nop
9D00921C  3C049D00   LUI A0, -25344               172:           la      $a0, msg10
9D009220  24847619   ADDIU A0, A0, 30233
9D009224  8E050000   LW A1, 0(S0)                 173:           lw      $a1, 0(DP)
9D009228  8E060004   LW A2, 4(S0)                 174:           lw      $a2, 4(DP)
9D00922C  8E070008   LW A3, 8(S0)                 175:           lw      $a3, 8(DP)
9D009230  0F403211   JAL 0x9D00C844               176:           jal     printf
9D009234  00000000   NOP                          177:           nop
9D009238  3C049D00   LUI A0, -25344               178:           la      $a0, msg8
9D00923C  248475F1   ADDIU A0, A0, 30193
9D009240  02202821   ADDU A1, S1, ZERO            179:           move    $a1, RP
9D009244  8E260000   LW A2, 0(S1)                 180:           lw      $a2, 0(RP)
9D009248  8E270004   LW A3, 4(S1)                 181:           lw      $a3, 4(RP)
9D00924C  0F403211   JAL 0x9D00C844               182:           jal     printf
9D009250  00000000   NOP                          183:           nop
9D009254  24040001   ADDIU A0, ZERO, 1            184:           li      $a0, stdin
9D009258  24050000   ADDIU A1, ZERO, 0            185:           li      $a1, 0
9D00925C  0F402999   JAL 0x9D00A664               186:           jal     waitch
9D009260  00000000   NOP                          187:           nop
9D009264  304200FF   ANDI V0, V0, 255             188:           andi    $v0, $v0, 255
9D009268  38420071   XORI V0, V0, 113             189:           xori    $v0,$v0,'q'
9D00926C  14400004   BNE V0, ZERO, 0x9D009280     190:           bnez    $v0, 1f
9D009270  00000000   NOP                          191:           nop
9D009274  3C08A000   LUI T0, -24576               192:           la      $t0, TRACE
9D009278  25080660   ADDIU T0, T0, 1632
9D00927C  AD000000   SW ZERO, 0(T0)               193:           sw      $zero, 0($t0)
                                                  194:   1:
9D009280  3C13A000   LUI S3, -24576               195:           lw      WP, ULAST+16
9D009284  8E730634   LW S3, 1588(S3)
9D009288  3C1FA000   LUI RA, -24576               196:           lw      $ra, ULAST+12
9D00928C  8FFF0630   LW RA, 1584(RA)
9D009290  3C10A000   LUI S0, -24576               197:           lw      DP, ULAST
9D009294  8E100624   LW S0, 1572(S0)
9D009298  3C11A000   LUI S1, -24576               198:           lw      RP, ULAST+4
9D00929C  8E310628   LW S1, 1576(S1)
9D0092A0  3C12A000   LUI S2, -24576               199:           lw      IP, ULAST+8
9D0092A4  8E52062C   LW S2, 1580(S2)
9D0092A8  03E00008   JR RA                        200:           j       $ra
9D0092AC  00000000   NOP                          201:           nop
                                                  202:   
                                                  203:   BYE:    .word   BYE+4
9D0092B4  3C1FA000   LUI RA, -24576               204:           lw      $ra, SAVLINK
9D0092B8  8FFF0658   LW RA, 1624(RA)
9D0092BC  3C10A000   LUI S0, -24576               205:           la      DP, SPP-12
9D0092C0  2610037C   ADDIU S0, S0, 892
9D0092C4  8E130008   LW S3, 8(S0)                 206:           lw      WP, 8(DP)
9D0092C8  8E110004   LW S1, 4(S0)                 207:           lw      RP, 4(DP)
9D0092CC  8E120000   LW S2, 0(S0)                 208:           lw      IP, 0(DP)
9D0092D0  3C10A000   LUI S0, -24576               209:           lw      DP, SAVSP
9D0092D4  8E10065C   LW S0, 1628(S0)
9D0092D8  27BD0040   ADDIU SP, SP, 64             210:           addu    $sp, $sp, 64
9D0092DC  03E00008   JR RA                        211:           j       $ra
9D0092E0  00000000   NOP                          212:           nop
                                                  213:   
                                                  214:   
                                                  215:   DPRT: .word DPRT+4   # debug print
9D0092E8  0F402476   JAL 0x9D0091D8               216:           jal DBG
9D0092EC  00000000   NOP                          217:           nop
9D0092F0  0B402469   J 0x9D0091A4                 218:           j $next
9D0092F4  00000000   NOP                          219:           nop
                                                  220:   
                                                  221:   TRON:  .word  TRON+4  # trace on
9D0092FC  3C08A000   LUI T0, -24576               222:           la $t0, TRACE
9D009300  25080660   ADDIU T0, T0, 1632
9D009304  24090001   ADDIU T1, ZERO, 1            223:           li  $t1, 1
9D009308  0B402469   J 0x9D0091A4                 224:           j $next
9D00930C  AD090000   SW T1, 0(T0)                 225:           sw  $t1, 0($t0)
                                                  226:   
                                                  227:   TROFF: .word  TROFF+4 # trace off
9D009314  3C08A000   LUI T0, -24576               228:           la  $t0, TRACE
9D009318  25080660   ADDIU T0, T0, 1632
9D00931C  0B402469   J 0x9D0091A4                 229:           j   $next
9D009320  AD000000   SW ZERO, 0(T0)               230:           sw  $zero, 0($t0)
                                                  231:   
                                                  232:   QRX:    .word   QRX+4
9D009328  24040001   ADDIU A0, ZERO, 1            233:           li      $a0, stdin      # UART device
9D00932C  0F40294D   JAL 0x9D00A534               234:           jal     getchar
9D009330  00000000   NOP                          235:           nop
9D009334  2610FFFC   ADDIU S0, S0, -4             236:           addiu   DP, DP, -4
9D009338  1040FF9A   BEQ V0, ZERO, 0x9D0091A4     237:           beq     $v0, $zero, $next
9D00933C  AE000000   SW ZERO, 0(S0)               238:           sw      $zero, 0(DP)
9D009340  2409FFFF   ADDIU T1, ZERO, -1           239:           li      $t1, -1
9D009344  AE020000   SW V0, 0(S0)                 240:           sw      $v0, 0(DP)
9D009348  2610FFFC   ADDIU S0, S0, -4             241:           addiu   DP, DP, -4
9D00934C  0B402469   J 0x9D0091A4                 242:           j       $next
9D009350  AE090000   SW T1, 0(S0)                 243:           sw      $t1, 0(DP)
                                                  244:           
                                                  245:   TXSTO:  .word   TXSTO+4
9D009358  24040001   ADDIU A0, ZERO, 1            246:           li      $a0, stdin
9D00935C  8E050000   LW A1, 0(S0)                 247:           lw      $a1, 0(DP)
9D009360  26100004   ADDIU S0, S0, 4              248:           addiu   DP, DP, 4
9D009364  0F402970   JAL 0x9D00A5C0               249:           jal     putchar
9D009368  00000000   NOP                          250:           nop
9D00936C  0B402469   J 0x9D0091A4                 251:           j       $next
9D009370  00000000   NOP                          252:           nop
                                                  253:   
                                                  254:   # IOTST:        .word   dolst
                                                  255:   # IOTS1:        .word   QRX, QBRAN, IOTS2
                                                  256:   # IOTS2:        .word   TXSTO, BRAN, IOTS1
                                                  257:   
                                                  258:   STOIO:  .word   STOIO+4
9D009378  0B402469   J 0x9D0091A4                 259:           j       $next
9D00937C  00000000   NOP                          260:           nop
                                                  261:   
                                                  262:   DOLIT:  .word   DOLIT+4
9D009384  8E480000   LW T0, 0(S2)                 263:           lw      $t0, 0(IP)
9D009388  2610FFFC   ADDIU S0, S0, -4             264:           addiu   DP, DP, -4
9D00938C  26520004   ADDIU S2, S2, 4              265:           addiu   IP, IP, 4
9D009390  0B402469   J 0x9D0091A4                 266:           j       $next
9D009394  AE080000   SW T0, 0(S0)                 267:           sw      $t0, 0(DP)
                                                  268:   
                                                  269:    # Colon word interpreter to lead the colon words
                                                  270:   
                                                  271:   dolst:
9D009398  2631FFFC   ADDIU S1, S1, -4             272:   DOLST:  addiu   RP, RP, -4    # push ip
9D00939C  AE320000   SW S2, 0(S1)                 273:           sw      IP, 0(RP)     # onto rp
9D0093A0  02609021   ADDU S2, S3, ZERO            274:           move    IP, WP        # move wp into ip
                                                  275:   #        nop
                                                  276:   
                                                  277:    #      jal     DBG
                                                  278:    #      nop
                                                  279:    
9D0093A4  0B402469   J 0x9D0091A4                 280:           j       $next           # execute list in pf
9D0093A8  02609021   ADDU S2, S3, ZERO            281:           move IP, WP
                                                  282:   #        nop
                                                  283:   
9D0093AC  8E730000   LW S3, 0(S3)                 284:   docon:  lw      WP, 0(WP)
9D0093B0  2610FFFC   ADDIU S0, S0, -4             285:   dovar:  addiu   DP, DP, -4
9D0093B4  0B402469   J 0x9D0091A4                 286:           j       $next
9D0093B8  AE130000   SW S3, 0(S0)                 287:           sw      WP, 0(DP)
                                                  288:   
9D0093BC  2610FFFC   ADDIU S0, S0, -4             289:   douse:  addiu   DP, DP, -4
9D0093C0  8E730000   LW S3, 0(S3)                 290:           lw      WP, 0(WP)
9D0093C4  3C08A000   LUI T0, -24576               291:           la      $t0, UPP
9D0093C8  25080590   ADDIU T0, T0, 1424
9D0093CC  01134021   ADDU T0, T0, S3              292:           addu    $t0, $t0, WP
9D0093D0  0B402469   J 0x9D0091A4                 293:           j       $next
9D0093D4  AE080000   SW T0, 0(S0)                 294:           sw      $t0, 0(DP)
                                                  295:   
9D0093D8  3C08A000   LUI T0, -24576               296:   dovoc:  la      $t0, CTXT
9D0093DC  250805EC   ADDIU T0, T0, 1516
9D0093E0  0B402469   J 0x9D0091A4                 297:           j       $next
9D0093E4  AD130000   SW S3, 0(T0)                 298:           sw      WP, 0($t0)
                                                  299:   
                                                  300:   EXIT:   .word   EXIT+4
9D0093EC  8E320000   LW S2, 0(S1)                 301:           lw      IP, 0(RP)     # get ip from rp
9D0093F0  0B402469   J 0x9D0091A4                 302:           j       $next           # return to calling list
9D0093F4  26310004   ADDIU S1, S1, 4              303:           addiu   RP, RP, 4     # pop rp
                                                  304:           
                                                  305:   EXECU:  .word   EXECU+4
9D0093FC  8E080000   LW T0, 0(S0)                 306:           lw      $t0, 0(DP)      # get cfa from sp
9D009400  26100004   ADDIU S0, S0, 4              307:           addiu   DP, DP, 4     # pop sp
9D009404  8D090000   LW T1, 0(T0)                 308:           lw      $t1, 0($t0)       # get address in code field
9D009408  01009821   ADDU S3, T0, ZERO            309:           move    WP, $t0         # WP = t0
9D00940C  01200008   JR T1                        310:           j       $t1              # indirect jump to next word
9D009410  26730004   ADDIU S3, S3, 4              311:           addiu   WP, WP, 4     # set up wp to pfa
                                                  312:   
                                                  313:   DONXT:  .word   DONXT+4
9D009418  8E280000   LW T0, 0(S1)                 314:           lw      $t0, 0(RP)
9D00941C  00000000   NOP                          315:           nop
9D009420  11000006   BEQ T0, ZERO, 0x9D00943C     316:           beq     $t0, $zero, NEXT1
9D009424  00000000   NOP                          317:           nop
9D009428  2508FFFF   ADDIU T0, T0, -1             318:           addiu   $t0, $t0, -1
9D00942C  AE280000   SW T0, 0(S1)                 319:           sw      $t0, 0(RP)
9D009430  8E520000   LW S2, 0(S2)                 320:           lw      IP, 0(IP)
9D009434  0B402469   J 0x9D0091A4                 321:           j       $next
9D009438  00000000   NOP                          322:           nop
9D00943C  26520004   ADDIU S2, S2, 4              323:   NEXT1:  addiu   IP, IP, 4
9D009440  0B402469   J 0x9D0091A4                 324:           j       $next
9D009444  26310004   ADDIU S1, S1, 4              325:           addiu   RP, RP, 4
                                                  326:   
                                                  327:           
                                                  328:   QBRAN:  .word   QBRAN+4
9D00944C  8E080000   LW T0, 0(S0)                 329:           lw      $t0, 0(DP)
9D009450  26100004   ADDIU S0, S0, 4              330:           addiu   DP, DP, 4
9D009454  11000004   BEQ T0, ZERO, 0x9D009468     331:           beq     $t0, $zero, BRAN1
9D009458  00000000   NOP                          332:           nop
9D00945C  26520004   ADDIU S2, S2, 4              333:           addiu   IP, IP, 4
9D009460  0B402469   J 0x9D0091A4                 334:           j       $next
9D009464  00000000   NOP                          335:           nop
9D009468  8E520000   LW S2, 0(S2)                 336:   BRAN1:  lw      IP, 0(IP)
9D00946C  0B402469   J 0x9D0091A4                 337:           j       $next
9D009470  00000000   NOP                          338:           nop
                                                  339:   
                                                  340:   BRAN:   .word   BRAN+4
9D009478  8E520000   LW S2, 0(S2)                 341:           lw      IP, 0(IP)
9D00947C  0B402469   J 0x9D0091A4                 342:           j       $next
9D009480  00000000   NOP                          343:           nop
                                                  344:   
                                                  345:   STORE:  .word   STORE+4
9D009488  8E090000   LW T1, 0(S0)                 346:           lw      $t1, 0(DP)
9D00948C  8E080004   LW T0, 4(S0)                 347:           lw      $t0, 4(DP)
9D009490  26100008   ADDIU S0, S0, 8              348:           addiu   DP, DP, 8
9D009494  0B402469   J 0x9D0091A4                 349:           j       $next
9D009498  AD280000   SW T0, 0(T1)                 350:           sw      $t0, 0($t1)
                                                  351:   
                                                  352:   AT:     .word   AT+4
9D0094A0  8E090000   LW T1, 0(S0)                 353:           lw      $t1, 0(DP)
                                                  354:   #        nop
9D0094A4  8D280000   LW T0, 0(T1)                 355:           lw      $t0, 0($t1)
9D0094A8  0B402469   J 0x9D0091A4                 356:           j       $next
9D0094AC  AE080000   SW T0, 0(S0)                 357:           sw      $t0, 0(DP)
                                                  358:           
                                                  359:   CSTOR:  .word   CSTOR+4
9D0094B4  8E090000   LW T1, 0(S0)                 360:           lw      $t1, 0(DP)
9D0094B8  8E080004   LW T0, 4(S0)                 361:           lw      $t0, 4(DP)
9D0094BC  26100008   ADDIU S0, S0, 8              362:           addiu   DP, DP, 8
9D0094C0  0B402469   J 0x9D0091A4                 363:           j       $next
9D0094C4  A1280000   SB T0, 0(T1)                 364:           sb      $t0, 0($t1)
                                                  365:   
                                                  366:   CAT:    .word   CAT+4
9D0094CC  8E090000   LW T1, 0(S0)                 367:           lw      $t1, 0(DP)
9D0094D0  00000000   NOP                          368:           nop
9D0094D4  91280000   LBU T0, 0(T1)                369:           lbu     $t0, 0($t1)
9D0094D8  0B402469   J 0x9D0091A4                 370:           j       $next
9D0094DC  AE080000   SW T0, 0(S0)                 371:           sw      $t0, 0(DP)
                                                  372:           
                                                  373:   WSTOR:  .word   WSTOR+4
9D0094E4  8E090000   LW T1, 0(S0)                 374:           lw      $t1, 0(DP)
9D0094E8  8E080004   LW T0, 4(S0)                 375:           lw      $t0, 4(DP)
9D0094EC  26100008   ADDIU S0, S0, 8              376:           addiu   DP, DP, 8
9D0094F0  0B402469   J 0x9D0091A4                 377:           j       $next
9D0094F4  A5280000   SH T0, 0(T1)                 378:           sh      $t0, 0($t1)
                                                  379:   
                                                  380:   WAT:    .word   WAT+4
9D0094FC  8E090000   LW T1, 0(S0)                 381:           lw      $t1, 0(DP)
9D009500  00000000   NOP                          382:           nop
9D009504  95280000   LHU T0, 0(T1)                383:           lhu     $t0, 0($t1)
9D009508  0B402469   J 0x9D0091A4                 384:           j       $next
9D00950C  AE080000   SW T0, 0(S0)                 385:           sw      $t0, 0(DP)
                                                  386:           
                                                  387:   RPAT:   .word   RPAT+4
9D009514  2610FFFC   ADDIU S0, S0, -4             388:           addiu   DP, DP, -4
9D009518  0B402469   J 0x9D0091A4                 389:           j       $next
9D00951C  AE110000   SW S1, 0(S0)                 390:           sw      RP, 0(DP)
                                                  391:   
                                                  392:   RPSTO:  .word   RPSTO+4
9D009524  8E080000   LW T0, 0(S0)                 393:           lw      $t0, 0(DP)
9D009528  26100004   ADDIU S0, S0, 4              394:           addiu   DP, DP, 4
9D00952C  0B402469   J 0x9D0091A4                 395:           j       $next
9D009530  01008825   OR S1, T0, ZERO              396:           or      RP, $t0, $zero
                                                  397:           
                                                  398:   RFROM:  .word   RFROM+4
9D009538  8E280000   LW T0, 0(S1)                 399:           lw      $t0, 0(RP)
9D00953C  2610FFFC   ADDIU S0, S0, -4             400:           addiu   DP, DP, -4
9D009540  AE080000   SW T0, 0(S0)                 401:           sw      $t0, 0(DP)
9D009544  0B402469   J 0x9D0091A4                 402:           j       $next
9D009548  26310004   ADDIU S1, S1, 4              403:           addiu   RP, RP, 4
                                                  404:   
                                                  405:   RAT:    .word   RAT+4
9D009550  8E280000   LW T0, 0(S1)                 406:           lw      $t0, 0(RP)
9D009554  2610FFFC   ADDIU S0, S0, -4             407:           addiu   DP, DP, -4
9D009558  0B402469   J 0x9D0091A4                 408:           j       $next
9D00955C  AE080000   SW T0, 0(S0)                 409:           sw      $t0, 0(DP)
                                                  410:   
                                                  411:   TOR:    .word   TOR+4
9D009564  8E080000   LW T0, 0(S0)                 412:           lw      $t0, 0(DP)
9D009568  2631FFFC   ADDIU S1, S1, -4             413:           addiu   RP, RP, -4
9D00956C  AE280000   SW T0, 0(S1)                 414:           sw      $t0, 0(RP)
9D009570  0B402469   J 0x9D0091A4                 415:           j       $next
9D009574  26100004   ADDIU S0, S0, 4              416:           addiu   DP, DP, 4
                                                  417:   
                                                  418:   SPAT:   .word   SPAT+4
9D00957C  02004025   OR T0, S0, ZERO              419:           or      $t0, DP, $zero
9D009580  2610FFFC   ADDIU S0, S0, -4             420:           addiu   DP, DP, -4
9D009584  0B402469   J 0x9D0091A4                 421:           j       $next
9D009588  AE080000   SW T0, 0(S0)                 422:           sw      $t0, 0(DP)
                                                  423:   
                                                  424:   SPSTO:  .word   SPSTO+4
9D009590  0B402469   J 0x9D0091A4                 425:           j       $next
9D009594  8E100000   LW S0, 0(S0)                 426:           lw      DP, 0(DP)
                                                  427:           
                                                  428:   DROP:   .word   DROP+4
9D00959C  0B402469   J 0x9D0091A4                 429:           j       $next
9D0095A0  26100004   ADDIU S0, S0, 4              430:           addiu   DP, DP, 4
                                                  431:   
                                                  432:   DUPP:   .word   DUPP+4
9D0095A8  8E080000   LW T0, 0(S0)                 433:           lw      $t0, 0(DP)
9D0095AC  2610FFFC   ADDIU S0, S0, -4             434:           addiu   DP, DP, -4
9D0095B0  0B402469   J 0x9D0091A4                 435:           j       $next
9D0095B4  AE080000   SW T0, 0(S0)                 436:           sw      $t0, 0(DP)
                                                  437:   
                                                  438:   SWAP:   .word   SWAP+4
9D0095BC  8E080000   LW T0, 0(S0)                 439:           lw      $t0, 0(DP)
9D0095C0  8E090004   LW T1, 4(S0)                 440:           lw      $t1, 4(DP)
9D0095C4  AE080004   SW T0, 4(S0)                 441:           sw      $t0, 4(DP)
9D0095C8  0B402469   J 0x9D0091A4                 442:           j       $next
9D0095CC  AE090000   SW T1, 0(S0)                 443:           sw      $t1, 0(DP)
                                                  444:   
                                                  445:   OVER:   .word   OVER+4
9D0095D4  8E080004   LW T0, 4(S0)                 446:           lw      $t0, 4(DP)
9D0095D8  2610FFFC   ADDIU S0, S0, -4             447:           addiu   DP, DP, -4
9D0095DC  0B402469   J 0x9D0091A4                 448:           j       $next
9D0095E0  AE080000   SW T0, 0(S0)                 449:           sw      $t0, 0(DP)
                                                  450:   
                                                  451:   ZLESS:  .word   ZLESS+4
9D0095E8  8E080000   LW T0, 0(S0)                 452:           lw      $t0, 0(DP)
9D0095EC  2409FFFF   ADDIU T1, ZERO, -1           453:           li      $t1, -1
9D0095F0  0500FEEC   BLTZ T0, 0x9D0091A4          454:           blt     $t0, $zero, $next
9D0095F4  AE090000   SW T1, 0(S0)                 455:           sw      $t1, 0(DP)
9D0095F8  0B402469   J 0x9D0091A4                 456:           j       $next
9D0095FC  AE000000   SW ZERO, 0(S0)               457:           sw      $zero, 0(DP)
                                                  458:           
                                                  459:   ANDD:   .word   ANDD+4
9D009604  8E080000   LW T0, 0(S0)                 460:           lw      $t0, 0(DP)
9D009608  8E090004   LW T1, 4(S0)                 461:           lw      $t1, 4(DP)
9D00960C  26100004   ADDIU S0, S0, 4              462:           addiu   DP, DP, 4
9D009610  01094024   AND T0, T0, T1               463:           and     $t0, $t0, $t1
9D009614  0B402469   J 0x9D0091A4                 464:           j       $next
9D009618  AE080000   SW T0, 0(S0)                 465:           sw      $t0, 0(DP)
                                                  466:   
                                                  467:   ORR:    .word   ORR+4
9D009620  8E080000   LW T0, 0(S0)                 468:           lw      $t0, 0(DP)
9D009624  8E090004   LW T1, 4(S0)                 469:           lw      $t1, 4(DP)
9D009628  26100004   ADDIU S0, S0, 4              470:           addiu   DP, DP, 4
9D00962C  01094025   OR T0, T0, T1                471:           or      $t0, $t0, $t1
9D009630  0B402469   J 0x9D0091A4                 472:           j       $next
9D009634  AE080000   SW T0, 0(S0)                 473:           sw      $t0, 0(DP)
                                                  474:   
                                                  475:   XORR:   .word   XORR+4
9D00963C  8E080000   LW T0, 0(S0)                 476:           lw      $t0, 0(DP)
9D009640  8E090004   LW T1, 4(S0)                 477:           lw      $t1, 4(DP)
9D009644  26100004   ADDIU S0, S0, 4              478:           addiu   DP, DP, 4
9D009648  01094026   XOR T0, T0, T1               479:           xor     $t0, $t0, $t1
9D00964C  0B402469   J 0x9D0091A4                 480:           j       $next
9D009650  AE080000   SW T0, 0(S0)                 481:           sw      $t0, 0(DP)
                                                  482:   
                                                  483:   UPLUS:  .word   UPLUS+4
9D009658  8E080000   LW T0, 0(S0)                 484:           lw      $t0, 0(DP)
9D00965C  8E090004   LW T1, 4(S0)                 485:           lw      $t1, 4(DP)
9D009660  00000000   NOP                          486:           nop
9D009664  01094021   ADDU T0, T0, T1              487:           addu    $t0, $t0, $t1
9D009668  0109502B   SLTU T2, T0, T1              488:           sltu    $t2, $t0, $t1
9D00966C  AE080004   SW T0, 4(S0)                 489:           sw      $t0, 4(DP)
9D009670  0B402469   J 0x9D0091A4                 490:           j       $next
9D009674  AE0A0000   SW T2, 0(S0)                 491:           sw      $t2, 0(DP)
                                                  492:   
                                                  493:    ######  Following words are optimized for MIPS uP #####
                                                  494:   
                                                  495:   QDUP:   .word   QDUP+4
9D00967C  8E080000   LW T0, 0(S0)                 496:           lw      $t0, 0(DP)
                                                  497:   #        nop
9D009680  1100FEC8   BEQ T0, ZERO, 0x9D0091A4     498:           beq     $t0, $zero, $next
9D009684  00000000   NOP                          499:           nop
9D009688  2610FFFC   ADDIU S0, S0, -4             500:           addiu   DP, DP, -4
9D00968C  0B402469   J 0x9D0091A4                 501:           j       $next
9D009690  AE080000   SW T0, 0(S0)                 502:           sw      $t0, 0(DP)
                                                  503:   
                                                  504:   ROT:    .word   ROT+4
9D009698  8E080000   LW T0, 0(S0)                 505:           lw $t0, 0(DP)
9D00969C  8E090004   LW T1, 4(S0)                 506:           lw $t1, 4(DP)
9D0096A0  8E0A0008   LW T2, 8(S0)                 507:           lw $t2, 8(DP)
9D0096A4  AE080004   SW T0, 4(S0)                 508:           sw $t0, 4(DP)
9D0096A8  AE090008   SW T1, 8(S0)                 509:           sw $t1, 8(DP)
9D0096AC  0B402469   J 0x9D0091A4                 510:           j       $next
9D0096B0  AE0A0000   SW T2, 0(S0)                 511:           sw $t2, 0(DP)
                                                  512:   
                                                  513:   DDROP:  .word   DDROP+4
9D0096B8  0B402469   J 0x9D0091A4                 514:           j       $next
9D0096BC  26100008   ADDIU S0, S0, 8              515:           addiu DP, DP, 8
                                                  516:   
                                                  517:   DDUP:   .word   DDUP+4
9D0096C4  8E080000   LW T0, 0(S0)                 518:           lw $t0, 0(DP)
9D0096C8  8E090004   LW T1, 4(S0)                 519:           lw $t1, 4(DP)
9D0096CC  2610FFF8   ADDIU S0, S0, -8             520:           addiu DP, DP, -8
9D0096D0  AE080000   SW T0, 0(S0)                 521:           sw $t0, 0(DP)
9D0096D4  0B402469   J 0x9D0091A4                 522:           j $next
9D0096D8  AE090004   SW T1, 4(S0)                 523:           sw $t1, 4(DP)
                                                  524:   
                                                  525:   PLUS:   .word   PLUS+4
9D0096E0  8E080000   LW T0, 0(S0)                 526:           lw      $t0, 0(DP)
9D0096E4  8E090004   LW T1, 4(S0)                 527:           lw      $t1, 4(DP)
9D0096E8  26100004   ADDIU S0, S0, 4              528:           addiu   DP, DP, 4
9D0096EC  01094021   ADDU T0, T0, T1              529:           addu    $t0, $t0, $t1
9D0096F0  0B402469   J 0x9D0091A4                 530:           j       $next
9D0096F4  AE080000   SW T0, 0(S0)                 531:           sw      $t0, 0(DP)
                                                  532:   
                                                  533:   
                                                  534:   DPLUS:  .word   DPLUS+4
9D0096FC  8E08000C   LW T0, 12(S0)                535:           lw      $t0, 12(DP)
9D009700  8E090008   LW T1, 8(S0)                 536:           lw      $t1, 8(DP)
                                                  537:   #        nop
9D009704  01094021   ADDU T0, T0, T1              538:           addu    $t0, $t0, $t1
9D009708  0109502B   SLTU T2, T0, T1              539:           sltu    $t2, $t0, $t1
9D00970C  AE08000C   SW T0, 12(S0)                540:           sw      $t0, 12(DP)
9D009710  8E080004   LW T0, 4(S0)                 541:           lw      $t0, 4(DP)
9D009714  8E090000   LW T1, 0(S0)                 542:           lw      $t1, 0(DP)
9D009718  26100008   ADDIU S0, S0, 8              543:           addiu   DP, DP, 8
9D00971C  01094021   ADDU T0, T0, T1              544:           addu    $t0, $t0, $t1
9D009720  010A4021   ADDU T0, T0, T2              545:           addu    $t0, $t0, $10
9D009724  0B402469   J 0x9D0091A4                 546:           j       $next
9D009728  AE080000   SW T0, 0(S0)                 547:           sw      $t0, 0(DP)
                                                  548:   
                                                  549:   
                                                  550:   INVER:  .word   INVER+4
9D009730  8E080000   LW T0, 0(S0)                 551:           lw      $t0, 0(DP)
9D009734  2409FFFF   ADDIU T1, ZERO, -1           552:           li      $t1, -1
9D009738  01094026   XOR T0, T0, T1               553:           xor     $t0, $t0, $t1
9D00973C  0B402469   J 0x9D0091A4                 554:           j       $next
9D009740  AE080000   SW T0, 0(S0)                 555:           sw      $t0, 0(DP)
                                                  556:   
                                                  557:   
                                                  558:   NEGAT:  .word   NEGAT+4
9D009748  8E080000   LW T0, 0(S0)                 559:           lw      $t0, 0(DP)
9D00974C  00000000   NOP                          560:           nop
9D009750  00084023   SUBU T0, ZERO, T0            561:           subu    $t0, $zero, $t0
9D009754  0B402469   J 0x9D0091A4                 562:           j       $next
9D009758  AE080000   SW T0, 0(S0)                 563:           sw      $t0, 0(DP)
                                                  564:   
                                                  565:   SUBB:   .word   SUBB+4
9D009760  8E080000   LW T0, 0(S0)                 566:           lw      $t0, 0(DP)
9D009764  8E090004   LW T1, 4(S0)                 567:           lw      $t1, 4(DP)
9D009768  26100004   ADDIU S0, S0, 4              568:           addiu   DP, DP, 4
9D00976C  01284023   SUBU T0, T1, T0              569:           subu    $t0, $t1, $t0
9D009770  0B402469   J 0x9D0091A4                 570:           j       $next
9D009774  AE080000   SW T0, 0(S0)                 571:           sw      $t0, 0(DP)
                                                  572:   
                                                  573:   ABSS:   .word   ABSS+4
9D00977C  8E080000   LW T0, 0(S0)                 574:           lw      $t0, 0(DP)
9D009780  00000000   NOP                          575:           nop
9D009784  0501FE87   BGEZ T0, 0x9D0091A4          576:           bge     $t0, $zero, $next
9D009788  00084023   SUBU T0, ZERO, T0            577:           subu    $t0, $zero, $t0
9D00978C  0B402469   J 0x9D0091A4                 578:           j       $next
9D009790  AE080000   SW T0, 0(S0)                 579:           sw      $t0, 0(DP)
                                                  580:   
                                                  581:   
                                                  582:   EQUAL:  .word   EQUAL+4
9D009798  8E080000   LW T0, 0(S0)                 583:           lw      $t0, 0(DP)
9D00979C  8E090004   LW T1, 4(S0)                 584:           lw      $t1, 4(DP)
9D0097A0  26100004   ADDIU S0, S0, 4              585:           addiu   DP, DP, 4
9D0097A4  11090002   BEQ T0, T1, 0x9D0097B0       586:           beq     $t0, $t1, EQUA1
9D0097A8  2408FFFF   ADDIU T0, ZERO, -1           587:           li      $t0, -1
9D0097AC  24080000   ADDIU T0, ZERO, 0            588:           li      $t0, 0
9D0097B0  0B402469   J 0x9D0091A4                 589:   EQUA1:  j       $next
9D0097B4  AE080000   SW T0, 0(S0)                 590:           sw      $t0, 0(DP)
                                                  591:   
                                                  592:   
                                                  593:   ULESS:  .word   ULESS+4
9D0097BC  8E080000   LW T0, 0(S0)                 594:           lw      $t0, 0(DP)
9D0097C0  8E090004   LW T1, 4(S0)                 595:           lw      $t1, 4(DP)
9D0097C4  26100004   ADDIU S0, S0, 4              596:           addiu   DP, DP, 4
9D0097C8  0128082B   SLTU AT, T1, T0              597:           bltu    $t1, $t0, ULES1
9D0097CC  14200002   BNE AT, ZERO, 0x9D0097D8
9D0097D0  2408FFFF   ADDIU T0, ZERO, -1           598:           li      $t0, -1
9D0097D4  24080000   ADDIU T0, ZERO, 0            599:           li      $t0, 0
9D0097D8  0B402469   J 0x9D0091A4                 600:   ULES1:  j       $next
9D0097DC  AE080000   SW T0, 0(S0)                 601:           sw      $t0, 0(DP)
                                                  602:   
                                                  603:     # signed compare of top two
                                                  604:   
                                                  605:   LESS:   .word   LESS+4
9D0097E4  8E080000   LW T0, 0(S0)                 606:           lw      $t0, 0(DP)
9D0097E8  8E090004   LW T1, 4(S0)                 607:           lw      $t1, 4(DP)
9D0097EC  26100004   ADDIU S0, S0, 4              608:           addiu   DP, DP, 4
9D0097F0  0128082A   SLT AT, T1, T0               609:           blt     $t1, $t0, LESS1
9D0097F4  14200002   BNE AT, ZERO, 0x9D009800
9D0097F8  2408FFFF   ADDIU T0, ZERO, -1           610:           li      $t0, -1
9D0097FC  24080000   ADDIU T0, ZERO, 0            611:           li      $t0, 0
9D009800  0B402469   J 0x9D0091A4                 612:   LESS1:  j       $next
9D009804  AE080000   SW T0, 0(S0)                 613:           sw      $t0, 0(DP)
                                                  614:   
                                                  615:     # return greater of top two
                                                  616:   
                                                  617:   MAX:    .word   MAX+4
9D00980C  8E080000   LW T0, 0(S0)                 618:           lw      $t0, 0(DP)
9D009810  8E090004   LW T1, 4(S0)                 619:           lw      $t1, 4(DP)
9D009814  26100004   ADDIU S0, S0, 4              620:           addiu   DP, DP, 4
9D009818  0109082A   SLT AT, T0, T1               621:           bgt     $t1, $t0, $next
9D00981C  1420FE61   BNE AT, ZERO, 0x9D0091A4
9D009820  00000000   NOP                          622:           nop
9D009824  0B402469   J 0x9D0091A4                 623:           j       $next
9D009828  AE080000   SW T0, 0(S0)                 624:           sw      $t0, 0(DP)
                                                  625:   
                                                  626:     # return smaller of top two
                                                  627:   
                                                  628:   MIN:    .word   MIN+4
9D009830  8E080000   LW T0, 0(S0)                 629:           lw      $t0, 0(DP)
9D009834  8E090004   LW T1, 4(S0)                 630:           lw      $t1, 4(DP)
9D009838  26100004   ADDIU S0, S0, 4              631:           addiu   DP, DP, 4
9D00983C  0128082A   SLT AT, T1, T0               632:           blt     $t1, $t0, $next
9D009840  1420FE58   BNE AT, ZERO, 0x9D0091A4
9D009844  00000000   NOP                          633:           nop
9D009848  0B402469   J 0x9D0091A4                 634:           j       $next
9D00984C  AE080000   SW T0, 0(S0)                 635:           sw      $t0, 0(DP)
                                                  636:   
                                                  637:   
                                                  638:     # unsigned divide of a double by a single, return mod and quotient
                                                  639:   
                                                  640:   UMMOD:  .word   UMMOD+4
9D009854  8E080000   LW T0, 0(S0)                 641:           lw      $t0, 0(DP)      # divisor
9D009858  8E090004   LW T1, 4(S0)                 642:           lw      $t1, 4(DP)      # high
9D00985C  8E0A0008   LW T2, 8(S0)                 643:           lw      $t2, 8(DP)     # low
9D009860  0128082B   SLTU AT, T1, T0              644:           bgeu    $t1, $t0, UMOD4   # overflow?
9D009864  10200013   BEQ AT, ZERO, 0x9D0098B4
9D009868  26100004   ADDIU S0, S0, 4              645:           addiu   DP, DP, 4
9D00986C  240B0001   ADDIU T3, ZERO, 1            646:           li      $t3, 1          # shift 1 bit left
9D009870  240D0020   ADDIU T5, ZERO, 32           647:           li      $t5, 32         # process 32 bits
9D009874  01694804   SLLV T1, T1, T3              648:   UMOD1:  sll     $t1, $t1, $11     # shift high
9D009878  05400002   BLTZ T2, 0x9D009884          649:           bltz    $t2, UMOD2      # test low
9D00987C  240C0001   ADDIU T4, ZERO, 1            650:           li      $t4, 1          # carry
9D009880  240C0000   ADDIU T4, ZERO, 0            651:           li      $t4, 0          # no carry
9D009884  012C4821   ADDU T1, T1, T4              652:   UMOD2:  addu    $t1, $t1, $12     # add carry to high
9D009888  0128082B   SLTU AT, T1, T0              653:           bltu    $t1, $t0, UMOD3   # test high
9D00988C  14200003   BNE AT, ZERO, 0x9D00989C
9D009890  016A5004   SLLV T2, T2, T3              654:           sll     $t2, $t2, $11   # shift low
9D009894  01284823   SUBU T1, T1, T0              655:           subu    $t1, $t1, $t0      # conditional subtract
9D009898  014B5021   ADDU T2, T2, T3              656:           addu    $t2, $t2, $11   # add bit to quotient
9D00989C  25ADFFFF   ADDIU T5, T5, -1             657:   UMOD3:  subu    $t5, $t5, 1
9D0098A0  15A0FFF4   BNE T5, ZERO, 0x9D009874     658:           bnez    $t5, UMOD1      # repeat 32 times
9D0098A4  00000000   NOP                          659:           nop
9D0098A8  AE0A0000   SW T2, 0(S0)                 660:           sw      $t2, 0(DP)     # get quotient
9D0098AC  0B402469   J 0x9D0091A4                 661:           j       $next
9D0098B0  AE090004   SW T1, 4(S0)                 662:           sw      $t1, 4(DP)      # get remainder
9D0098B4  AE000004   SW ZERO, 4(S0)               663:   UMOD4:  sw      $zero, 4(DP)
9D0098B8  2408FFFF   ADDIU T0, ZERO, -1           664:           li      $t0, -1
9D0098BC  0B402469   J 0x9D0091A4                 665:           j       $next
9D0098C0  AE080000   SW T0, 0(S0)                 666:           sw      $t0, 0(DP)
                                                  667:   
                                                  668:   # signed floored divide of double by single, return mod and quotient
                                                  669:   # upper 32 bits are ignored.  In effect a 32 bits divide.
                                                  670:   
                                                  671:    # MSMOD:       .word   MSMOD+4
9D0098C4  8E080000   LW T0, 0(S0)                 672:           lw      $t0, 0(DP)
9D0098C8  8E090008   LW T1, 8(S0)                 673:           lw      $t1, 8(DP)
9D0098CC  26100004   ADDIU S0, S0, 4              674:           addiu   DP, DP, 4
9D0098D0  010001F4   TEQ T0, ZERO                 675:           div     $t1, $t0
9D0098D4  0128001A   DIV T1, T0
9D0098D8  2401FFFF   ADDIU AT, ZERO, -1
9D0098DC  15010002   BNE T0, AT, 0x9D0098E8
9D0098E0  3C018000   LUI AT, -32768
9D0098E4  012101B4   TEQ T1, AT
9D0098E8  00004812   MFLO T1, 0
9D0098EC  00004010   MFHI T0, 0                   676:           mfhi    $t0
9D0098F0  00004812   MFLO T1, 0                   677:           mflo    $t1
9D0098F4  AE080004   SW T0, 4(S0)                 678:           sw      $t0, 4(DP)
9D0098F8  0B402469   J 0x9D0091A4                 679:           j       $next
9D0098FC  AE090000   SW T1, 0(S0)                 680:           sw      $t1, 0(DP)
                                                  681:   
                                                  682:   # signed divide, return mod and quotient
                                                  683:   
                                                  684:   SLMOD:  .word   SLMOD+4
9D009904  8E080000   LW T0, 0(S0)                 685:           lw      $t0, 0(DP)
9D009908  8E090004   LW T1, 4(S0)                 686:           lw      $t1, 4(DP)
9D00990C  00000000   NOP                          687:           nop
9D009910  010001F4   TEQ T0, ZERO                 688:           div     $t1, $t0
9D009914  0128001A   DIV T1, T0
9D009918  2401FFFF   ADDIU AT, ZERO, -1
9D00991C  15010002   BNE T0, AT, 0x9D009928
9D009920  3C018000   LUI AT, -32768
9D009924  012101B4   TEQ T1, AT
9D009928  00004812   MFLO T1, 0
9D00992C  00004010   MFHI T0, 0                   689:           mfhi    $t0
9D009930  00004812   MFLO T1, 0                   690:           mflo    $t1
9D009934  AE080004   SW T0, 4(S0)                 691:           sw      $t0, 4(DP)
9D009938  0B402469   J 0x9D0091A4                 692:           j       $next
9D00993C  AE090000   SW T1, 0(S0)                 693:           sw      $t1, 0(DP)
                                                  694:   
                                                  695:   # signed divide, return mod only
                                                  696:   
                                                  697:   MODD:   .word   MODD+4
9D009944  8E080000   LW T0, 0(S0)                 698:           lw      $t0, 0(DP)
9D009948  8E090004   LW T1, 4(S0)                 699:           lw      $t1, 4(DP)
9D00994C  00000000   NOP                          700:           nop
9D009950  010001F4   TEQ T0, ZERO                 701:           div     $t1, $t0
9D009954  0128001A   DIV T1, T0
9D009958  2401FFFF   ADDIU AT, ZERO, -1
9D00995C  15010002   BNE T0, AT, 0x9D009968
9D009960  3C018000   LUI AT, -32768
9D009964  012101B4   TEQ T1, AT
9D009968  00004812   MFLO T1, 0
9D00996C  00004010   MFHI T0, 0                   702:           mfhi    $t0
9D009970  26100004   ADDIU S0, S0, 4              703:           addiu   DP, DP, 4
9D009974  0B402469   J 0x9D0091A4                 704:           j       $next
9D009978  AE080000   SW T0, 0(S0)                 705:           sw      $t0, 0(DP)
                                                  706:   
                                                  707:   # signed divide, return quotient only
                                                  708:   
                                                  709:   SLASH:  .word   SLASH+4
9D009980  8E080000   LW T0, 0(S0)                 710:           lw      $t0, 0(DP)
9D009984  8E090004   LW T1, 4(S0)                 711:           lw      $t1, 4(DP)
9D009988  00000000   NOP                          712:           nop
9D00998C  010001F4   TEQ T0, ZERO                 713:           div     $t1, $t0
9D009990  0128001A   DIV T1, T0
9D009994  2401FFFF   ADDIU AT, ZERO, -1
9D009998  15010002   BNE T0, AT, 0x9D0099A4
9D00999C  3C018000   LUI AT, -32768
9D0099A0  012101B4   TEQ T1, AT
9D0099A4  00004812   MFLO T1, 0
9D0099A8  00004812   MFLO T1, 0                   714:           mflo    $t1
9D0099AC  26100004   ADDIU S0, S0, 4              715:           addiu   DP, DP, 4
9D0099B0  0B402469   J 0x9D0091A4                 716:           j       $next
9D0099B4  AE090000   SW T1, 0(S0)                 717:           sw      $t1, 0(DP)
                                                  718:   
                                                  719:   # unsigned multiply, return double product
                                                  720:   
                                                  721:   UMSTA:  .word   UMSTA+4
9D0099BC  8E080000   LW T0, 0(S0)                 722:           lw $t0, 0(DP)
9D0099C0  8E090004   LW T1, 4(S0)                 723:           lw $t1, 4(DP)
9D0099C4  00000000   NOP                          724:           nop
9D0099C8  01090019   MULTU 0, T0, T1              725:           multu $t0, $t1
9D0099CC  00004012   MFLO T0, 0                   726:           mflo $t0
9D0099D0  00004810   MFHI T1, 0                   727:           mfhi $t1
9D0099D4  AE080004   SW T0, 4(S0)                 728:           sw      $t0, 4(DP)
9D0099D8  0B402469   J 0x9D0091A4                 729:           j $next
9D0099DC  AE090000   SW T1, 0(S0)                 730:           sw      $t1, 0(DP)
                                                  731:   
                                                  732:   # signed multiply, return single product
                                                  733:   
                                                  734:   STAR:   .word   STAR+4
9D0099E4  8E080000   LW T0, 0(S0)                 735:           lw $t0, 0(DP)
9D0099E8  8E090004   LW T1, 4(S0)                 736:           lw $t1, 4(DP)
9D0099EC  00000000   NOP                          737:           nop
9D0099F0  01090018   MULT 0, T0, T1               738:           mult $t0, $t1
9D0099F4  00004012   MFLO T0, 0                   739:           mflo $t0
9D0099F8  AE080004   SW T0, 4(S0)                 740:           sw      $t0, 4(DP)
9D0099FC  0B402469   J 0x9D0091A4                 741:           j $next
9D009A00  26100004   ADDIU S0, S0, 4              742:           addiu DP, DP, 4
                                                  743:   
                                                  744:   # signed multiply, return double product
                                                  745:   
                                                  746:   MSTAR:  .word   MSTAR+4
9D009A08  8E080000   LW T0, 0(S0)                 747:           lw $t0, 0(DP)
9D009A0C  8E090004   LW T1, 4(S0)                 748:           lw $t1, 4(DP)
9D009A10  00000000   NOP                          749:           nop
9D009A14  01090018   MULT 0, T0, T1               750:           mult $t0, $t1
9D009A18  00004012   MFLO T0, 0                   751:           mflo $t0
9D009A1C  00004810   MFHI T1, 0                   752:           mfhi $t1
9D009A20  AE080004   SW T0, 4(S0)                 753:           sw      $t0, 4(DP)
9D009A24  0B402469   J 0x9D0091A4                 754:           j $next
9D009A28  AE090000   SW T1, 0(S0)                 755:           sw      $t1, 0(DP)
                                                  756:   
                                                  757:   CELLP:  .word   CELLP+4
9D009A30  8E080000   LW T0, 0(S0)                 758:           lw      $t0, 0(DP)
                                                  759:   #        nop
9D009A34  25080004   ADDIU T0, T0, 4              760:           addiu   $t0, CELLL
9D009A38  0B402469   J 0x9D0091A4                 761:           j       $next
9D009A3C  AE080000   SW T0, 0(S0)                 762:           sw      $t0, 0(DP)
                                                  763:   
                                                  764:   CELLM:  .word   CELLM+4
9D009A44  8E080000   LW T0, 0(S0)                 765:           lw      $t0, 0(DP)
9D009A48  00000000   NOP                          766:           nop
9D009A4C  2508FFFC   ADDIU T0, T0, -4             767:           addiu   $t0, -(CELLL)
9D009A50  0B402469   J 0x9D0091A4                 768:           j       $next
9D009A54  AE080000   SW T0, 0(S0)                 769:           sw      $t0, 0(DP)
                                                  770:   
                                                  771:   
                                                  772:   CELLS:  .word   CELLS+4
9D009A5C  8E080000   LW T0, 0(S0)                 773:           lw      $t0, 0(DP)
9D009A60  24090004   ADDIU T1, ZERO, 4            774:           li      $t1, CELLL
9D009A64  01090018   MULT 0, T0, T1               775:           mult    $t0, $t1
9D009A68  00004012   MFLO T0, 0                   776:           mflo    $t0
9D009A6C  0B402469   J 0x9D0091A4                 777:           j       $next
9D009A70  AE080000   SW T0, 0(S0)                 778:           sw      $t0, 0(DP)
                                                  779:   
                                                  780:   TWOST:  .word   TWOST+4
9D009A78  8E080000   LW T0, 0(S0)                 781:           lw      $t0, 0(DP)
9D009A7C  00000000   NOP                          782:           nop
9D009A80  00084040   SLL T0, T0, 1                783:           sll     $t0, $t0, 1
9D009A84  0B402469   J 0x9D0091A4                 784:           j       $next
9D009A88  AE080000   SW T0, 0(S0)                 785:           sw      $t0, 0(DP)
                                                  786:   
                                                  787:   TWOSL:  .word   TWOSL+4
9D009A90  8E080000   LW T0, 0(S0)                 788:           lw      $t0, 0(DP)
9D009A94  00000000   NOP                          789:           nop
9D009A98  00084043   SRA T0, T0, 1                790:           sra     $t0, $t0, 1
9D009A9C  0B402469   J 0x9D0091A4                 791:           j       $next
9D009AA0  AE080000   SW T0, 0(S0)                 792:           sw      $t0, 0(DP)
                                                  793:   
                                                  794:   ALGND:  .word   ALGND+4
9D009AA8  8E080000   LW T0, 0(S0)                 795:           lw      $t0, 0(DP)
9D009AAC  24090003   ADDIU T1, ZERO, 3            796:           li      $t1, (CELLL-1)
9D009AB0  01285024   AND T2, T1, T0               797:           and     $t2, $t1, $t0
9D009AB4  1140FDBB   BEQ T2, ZERO, 0x9D0091A4     798:           beq     $t2, $zero, $next
9D009AB8  010A4026   XOR T0, T0, T2               799:           xor     $t0, $t0, $10
9D009ABC  25080004   ADDIU T0, T0, 4              800:           addiu   $t0, CELLL
9D009AC0  0B402469   J 0x9D0091A4                 801:           j       $next
9D009AC4  AE080000   SW T0, 0(S0)                 802:           sw      $t0, 0(DP)
                                                  803:   
                                                  804:   PICK:   .word   PICK+4
9D009ACC  8E080000   LW T0, 0(S0)                 805:           lw      $t0, 0(DP)
9D009AD0  24090004   ADDIU T1, ZERO, 4            806:           li      $t1, CELLL
9D009AD4  25080001   ADDIU T0, T0, 1              807:           addiu   $t0, 1
9D009AD8  01090019   MULTU 0, T0, T1              808:           multu   $t0, $t1
9D009ADC  00004812   MFLO T1, 0                   809:           mflo    $t1
9D009AE0  01304821   ADDU T1, T1, S0              810:           addu    $t1, $t1, DP
9D009AE4  8D280000   LW T0, 0(T1)                 811:           lw      $t0, 0($t1)
9D009AE8  0B402469   J 0x9D0091A4                 812:           j       $next
9D009AEC  AE080000   SW T0, 0(S0)                 813:           sw      $t0, 0(DP)
                                                  814:   
                                                  815:   CMOVE:  .word   CMOVE+4
9D009AF4  8E080000   LW T0, 0(S0)                 816:           lw      $t0, 0(DP)
9D009AF8  8E090004   LW T1, 4(S0)                 817:           lw      $t1, 4(DP)
9D009AFC  8E0A0008   LW T2, 8(S0)                 818:           lw      $t2, 8(DP)
9D009B00  2610000C   ADDIU S0, S0, 12             819:           addiu   DP, 12
9D009B04  1100FDA7   BEQ T0, ZERO, 0x9D0091A4     820:   CMOV1:  beq     $t0, $zero, $next
9D009B08  814B0000   LB T3, 0(T2)                 821:           lb      $t3, 0($10)
9D009B0C  254A0001   ADDIU T2, T2, 1              822:           addiu   $t2, 1
9D009B10  A12B0000   SB T3, 0(T1)                 823:           sb      $t3, 0($t1)
9D009B14  2508FFFF   ADDIU T0, T0, -1             824:           addiu   $t0, -1
9D009B18  0B4026C1   J 0x9D009B04                 825:           j       CMOV1
9D009B1C  25290001   ADDIU T1, T1, 1              826:           addiu   $t1, 1
                                                  827:   
                                                  828:   MOVEE:  .word   MOVEE+4
9D009B24  8E080000   LW T0, 0(S0)                 829:           lw      $t0, 0(DP)
9D009B28  8E090004   LW T1, 4(S0)                 830:           lw      $t1, 4(DP)
9D009B2C  8E0A0008   LW T2, 8(S0)                 831:           lw      $t2, 8(DP)
9D009B30  2610000C   ADDIU S0, S0, 12             832:           addiu   DP, 12
9D009B34  1100FD9B   BEQ T0, ZERO, 0x9D0091A4     833:   MOV1:   beq     $t0, $zero, $next
9D009B38  8D4B0000   LW T3, 0(T2)                 834:           lw      $t3, 0($10)
9D009B3C  254A0004   ADDIU T2, T2, 4              835:           addiu   $t2, 4
9D009B40  AD320000   SW S2, 0(T1)                 836:           sw      IP, 0($t1)
9D009B44  2508FFFF   ADDIU T0, T0, -1             837:           addiu   $t0, -1
9D009B48  0B4026C1   J 0x9D009B04                 838:           j       CMOV1
9D009B4C  25290004   ADDIU T1, T1, 4              839:           addiu   $t1, 4
9D009B50  00000000   NOP
9D009B54  00000000   NOP
9D009B58  00000000   NOP
9D009B5C  00000000   NOP
                                                  840:   
                                                  841:   
                                                  842:   ##### Mandelbrot plot #####
                                                  843:   
                                                  844:   # MANDE:  .word   MANDE+4 # ( max a b -- n )
                                                  845:   #         lw      $t6, 8(DP)
                                                  846:   #         lw      $v0, 4(DP)
                                                  847:   #         lw      $v1, 0(DP)
                                                  848:   #         move    $a0, $2          # x
                                                  849:   #         move    $a1, $3          # y
                                                  850:   # MAND1:  mult    $a0, $a0          # x*x
                                                  851:   #         mflo    $a2
                                                  852:   #         mfhi    $a3
                                                  853:   #         lui     $t4, 0x1000     # 4.0, limit
                                                  854:   #         addiu   $t6, $t6, -1    # bump n
                                                  855:   #         mult    $a1, $a1          # y*y
                                                  856:   #         mflo    $t0
                                                  857:   #         mfhi    $t1
                                                  858:   #         addu    $t2, $t0, $a2     # xx+yy
                                                  859:   #         sltu    $t3, $t2, $a2
                                                  860:   #         addu    $t3, $t3, $a3
                                                  861:   #         addu    $t3, $t3, $t1
                                                  862:   #         bge     $t3, $t4, MAND2
                                                  863:   #         sltu    $t5, $a2, $t0     # xx-yy
                                                  864:   #         subu    $t3, $a2, $t0
                                                  865:   #         subu    $t4, $a3, $t1
                                                  866:   #         subu    $t4, $t4, $13
                                                  867:   #         sll     $t4, $t4, 3     # xx-yy normalized
                                                  868:   #         srl     $t3, $t3, 29
                                                  869:   #         or      $t5, $t3, $12
                                                  870:   #         mult    $a0, $a1          # xy
                                                  871:   #         mflo    $11
                                                  872:   #         mfhi    $12
                                                  873:   #         addu    $a0, $t5, $2     # new x
                                                  874:   #         sll     $t4, $t4, 4     # normalize 2xy
                                                  875:   #         srl     $t3, $t3, 28
                                                  876:   #         or      $t5, $t3, $12
                                                  877:   #         bnez    $t6, MAND1
                                                  878:   #         addu    $a1, $t5, $3     # new y
                                                  879:   # MAND2:  addiu   DP, DP, 8
                                                  880:   #         j       $next
                                                  881:   #         sw      $t6, 0(DP)
                                                  882:   
                                                  883:   
                                                  884:   ##### floating point numbers #####
                                                  885:   
                                                  886:   
                                                  887:   # FLOA:   .word   FLOA+4
                                                  888:   #         l.s     $f0, 0(DP)
                                                  889:   #         nop
                                                  890:   #         cvt.s.w $f2, $f0
                                                  891:   #         s.s     $f2, 0(DP)
                                                  892:   #         j       $next
                                                  893:   #         nop
                                                  894:   #
                                                  895:   # INT:    .word   INT+4
                                                  896:   #         l.s     $f0, 0(DP)
                                                  897:   #         nop
                                                  898:   #         cvt.w.s $f2, $f0
                                                  899:   #         s.s     $f2, 0(DP)
                                                  900:   #         j       $next
                                                  901:   #         nop
                                                  902:   
                                                  903:   # FDOT:   .word   FDOT+4
                                                  904:   #         la      $a0, msg6
                                                  905:   #         l.s     $f0, 0(DP)
                                                  906:   #         nop
                                                  907:   #         cvt.d.s $f2, $f0
                                                  908:   #         mfc1.d  $a2, $f2
                                                  909:   #         jal     printf
                                                  910:   #         nop
                                                  911:   #         j       $next
                                                  912:   #         addiu   DP, DP, 4
                                                  913:   #
                                                  914:   # FPLUS:  .word   FPLUS+4
                                                  915:   #         l.s     $f0, 0(DP)
                                                  916:   #         l.s     $f2, 4(DP)
                                                  917:   #         nop
                                                  918:   #         add.s   $f2, $f2, $f0
                                                  919:   #         addiu   DP, DP, 4
                                                  920:   #         j       $next
                                                  921:   #         s.s     $f2, 0(DP)
                                                  922:   #
                                                  923:   # FSUB:   .word   FSUB+4
                                                  924:   #         l.s     $f0, 0(DP)
                                                  925:   #         l.s     $f2, 4(DP)
                                                  926:   #         nop
                                                  927:   #         sub.s   $f2, $f2, $f0
                                                  928:   #         addiu   DP, DP, 4
                                                  929:   #         j       $next
                                                  930:   #         s.s     $f2, 0(DP)
                                                  931:   #
                                                  932:   # FMUL:   .word   FMUL+4
                                                  933:   #         l.s     $f0, 0(DP)
                                                  934:   #         l.s     $f2, 4(DP)
                                                  935:   #         nop
                                                  936:   #         mul.s   $f2, $f2, $f0
                                                  937:   #         addiu   DP, DP, 4
                                                  938:   #         j       $next
                                                  939:   #         s.s     $f2, 0(DP)
                                                  940:   #
                                                  941:   # FDIV:   .word   FDIV+4
                                                  942:   #         l.s     $f0, 0(DP)
                                                  943:   #         l.s     $f2, 4(DP)
                                                  944:   #         nop
                                                  945:   #         div.s   $f2, $f2, $f0
                                                  946:   #         addiu   DP, DP, 4
                                                  947:   #         j       $next
                                                  948:   #         s.s     $f2, 0(DP)
                                                  949:   
                                                  950:   # PI:     .word   docon
                                                  951:   #         .float  3.14159274
                                                  952:   #
                                                  953:   # ECON:   .word   docon
                                                  954:   #         .float  2.718281813
                                                  955:   #
                                                  956:   # FZERO:  .word   docon
                                                  957:   #         .float  0.0
                                                  958:   #
                                                  959:   # FONE:   .word   docon
                                                  960:   #         .float  1.0
                                                  961:   #
                                                  962:   # FTWO:   .word   docon
                                                  963:   #         .float  2.0
                                                  964:   #
                                                  965:   # FTEN:   .word   docon
                                                  966:   #         .float  10.0
                                                  967:   #
                                                  968:   # FSIN:   .word   FSIN+4
                                                  969:   #         l.s     $f12, 0(DP)
                                                  970:   #         jal     sinf
                                                  971:   #         nop
                                                  972:   #         j       $next
                                                  973:   #         s.s     $f0, 0(DP)
                                                  974:   #
                                                  975:   # FCOS:   .word   FCOS+4
                                                  976:   #         l.s     $f12, 0(DP)
                                                  977:   #         jal     cosf
                                                  978:   #         nop
                                                  979:   #         j       $next
                                                  980:   #         s.s     $f0, 0(DP)
                                                  981:   #
                                                  982:   # FTAN:   .word   FTAN+4
                                                  983:   #         l.s     $f12, 0(DP)
                                                  984:   #         jal     tanf
                                                  985:   #         nop
                                                  986:   #         j       $next
                                                  987:   #         s.s     $f0, 0(DP)
                                                  988:   #
                                                  989:   # FATAN:  .word   FATAN+4
                                                  990:   #         l.s     $f12, 0(DP)
                                                  991:   #         jal     atanf
                                                  992:   #         nop
                                                  993:   #         j       $next
                                                  994:   #         s.s     $f0, 0(DP)
                                                  995:   #
                                                  996:   # FSQRT:  .word   FSQRT+4
                                                  997:   #         l.s     $f12, 0(DP)
                                                  998:   #         jal     sqrtf
                                                  999:   #         nop
                                                  1000:  #         j       $next
                                                  1001:  #         s.s     $f0, 0(DP)
                                                  1002:  #
                                                  1003:  # FLESS:  .word   FLESS+4
                                                  1004:  #         l.s     $f0, 0(DP)
                                                  1005:  #         l.s     $f2, 4(DP)
                                                  1006:  #         li      $t0, -1
                                                  1007:  #         c.lt.s  $f2, $f0
                                                  1008:  #         addiu   DP, DP, 4
                                                  1009:  #         bc1t    FLES1
                                                  1010:  #         nop
                                                  1011:  #         li      $t0, 0
                                                  1012:  # FLES1:  j       $next
                                                  1013:  #         sw      $t0, 0(DP)
                                                  1014:  
                                                  1015:  #         .word   FLOA, f01
                                                  1016:  # f00:    .ascii  "\005FLOAT"
                                                  1017:  #         .word   INT, f02
                                                  1018:  # f01:    .ascii  "\003INT"
                                                  1019:  #         .word   FPLUS, f03
                                                  1020:  # f02:    .ascii  "\002F+"
                                                  1021:  #         .word   FSUB, f04
                                                  1022:  # f03:    .ascii  "\002F-"
                                                  1023:  #         .word   FMUL, f05
                                                  1024:  # f04:    .ascii  "\002F*"
                                                  1025:  #         .word   FDIV, f06
                                                  1026:  # f05:    .ascii  "\002F/"
                                                  1027:  #         .word   FZERO, f07
                                                  1028:  # f06:    .ascii  "\0030.0"
                                                  1029:  #         .word   FONE, f08
                                                  1030:  # f07:    .ascii  "\0031.0"
                                                  1031:  #         .word   FTWO, f09
                                                  1032:  # f08:    .ascii  "\0032.0"
                                                  1033:  #         .word   FTEN, f10
                                                  1034:  # f09:    .ascii  "\00410.0"
                                                  1035:  #         .word   PI, f11
                                                  1036:  # f10:    .ascii  "\002PI"
                                                  1037:  #         .word   ECON, f12
                                                  1038:  # f11:    .ascii  "\001e"
                                                  1039:  #         .word   FSIN, f13
                                                  1040:  # f12:    .ascii  "\004FSIN"
                                                  1041:  #         .word   FCOS, f14
                                                  1042:  # f13:    .ascii  "\004FCOS"
                                                  1043:  #         .word   FTAN, f15
                                                  1044:  # f14:    .ascii  "\004FTAN"
                                                  1045:  #         .word   FATAN, f16
                                                  1046:  # f15:    .ascii  "\005FATAN"
                                                  1047:  #         .word   FSQRT, f17
                                                  1048:  # f16:    .ascii  "\005FSQRT"
                                                  1049:  #         .word   FDOT, f18
                                                  1050:  # f17:    .ascii  "\002F."
                                                  1051:  #         .word   FLESS, 0
                                                  1052:  # f18:    .ascii  "\002F<"
                                                  1053:          .word   0,0,0,0
                                                  1054:  
                                                  1055:  
                                                  1056:  ##### names for colors in color map loaded by greset #####
                                                  1057:  
                                                  1058:  
                                                  1059:  # BLACK:  .word   docon,0
                                                  1060:  # RED:    .word   docon,1
                                                  1061:  # GREEN:  .word   docon,2
                                                  1062:  # YELLOW: .word   docon,3
                                                  1063:  # BLUE:   .word   docon,4
                                                  1064:  # MAGENTA:        .word   docon,5
                                                  1065:  # CYAN:   .word   docon,6
                                                  1066:  # WHITE:  .word   docon,7
                                                  1067:  
                                                  1068:  # GLXconfig *      GLXgetconfig( void *, long, GLXconfig * );
                                                  1069:  # void     acbuf( long, float );
                                                  1070:  # void     acsize( long );
                                                  1071:  # void     addtopup( long, String, ... );
                                                  1072:  # void     afunction( long, long );
                                                  1073:  # void     arc( Coord, Coord, Coord, Angle, Angle );
                                                  1074:  # void     arcf( Coord, Coord, Coord, Angle, Angle );
                                                  1075:  # void     arcfi( Icoord, Icoord, Icoord, Angle, Angle );
                                                  1076:  # ARCFI:  .word   ARCFI+4
                                                  1077:  #         lw      $a0, 0(DP)
                                                  1078:  #         nop
                                                  1079:  #         sw      $a0, 16($sp)
                                                  1080:  #         lw      $a0, 16(DP)
                                                  1081:  #         lw      $a1, 12(DP)
                                                  1082:  #         lw      $a2, 8(DP)
                                                  1083:  #         lw      $a3, 4(DP)
                                                  1084:  #         jal     arcfi
                                                  1085:  #         nop
                                                  1086:  #         j       $next
                                                  1087:  #         addiu   DP, DP, 20
                                                  1088:  #
                                                  1089:  #  # void     arcfs( Scoord, Scoord, Scoord, Angle, Angle );
                                                  1090:  #  # void     arci( Icoord, Icoord, Icoord, Angle, Angle );
                                                  1091:  # ARCI:   .word   ARCI+4
                                                  1092:  #         lw      $a0, 0(DP)
                                                  1093:  #         nop
                                                  1094:  #         sw      $a0, 16($sp)
                                                  1095:  #         lw      $a0, 16(DP)
                                                  1096:  #         lw      $a1, 12(DP)
                                                  1097:  #         lw      $a2, 8(DP)
                                                  1098:  #         lw      $a3, 4(DP)
                                                  1099:  #         jal     arci
                                                  1100:  #         nop
                                                  1101:  #         j       $next
                                                  1102:  #         addiu   DP, DP, 20
                                                  1103:  #
                                                  1104:  #  # void     arcs( Scoord, Scoord, Scoord, Angle, Angle );
                                                  1105:  #  # void     attachcursor( Device, Device );
                                                  1106:  #  # void     backbuffer( Boolean );
                                                  1107:  #  # void     backface( Boolean );
                                                  1108:  #  # void     bbox2( Screencoord, Screencoord, Coord, Coord, Coord, Coord );
                                                  1109:  #  # void     bbox2i( Screencoord, Screencoord, Icoord, Icoord, Icoord, Icoord );
                                                  1110:  #  # void     bbox2s( Screencoord, Screencoord, Scoord, Scoord, Scoord, Scoord );
                                                  1111:  #  # void     bgnclosedline( void );
                                                  1112:  # BCLIN:  .word   BCLIN+4
                                                  1113:  #         jal     bgnclosedline
                                                  1114:  #         nop
                                                  1115:  #         j       $next
                                                  1116:  #         nop
                                                  1117:  #
                                                  1118:  #  # void     bgncurve( void );
                                                  1119:  #  # void     bgnline( void );
                                                  1120:  # BLINE:  .word   BLINE+4
                                                  1121:  #         jal     bgnline
                                                  1122:  #         lw      $a0, 0(DP)
                                                  1123:  #         j       $next
                                                  1124:  #         addiu   DP, DP, 4
                                                  1125:  #
                                                  1126:  #  # void     bgnpoint( void );
                                                  1127:  # BPNT:   .word   BPNT+4
                                                  1128:  #         jal     bgnpoint
                                                  1129:  #         nop
                                                  1130:  #         j       $next
                                                  1131:  #         nop
                                                  1132:  #
                                                  1133:  #  # void     bgnpolygon( void );
                                                  1134:  # BPOLY:  .word   BPOLY+4
                                                  1135:  #         jal     bgnpolygon
                                                  1136:  #         nop
                                                  1137:  #         j       $next
                                                  1138:  #         nop
                                                  1139:  #
                                                  1140:  #
                                                  1141:  #  # void     bgnqstrip( void );
                                                  1142:  #  # void     bgnsurface( void );
                                                  1143:  #  # void     bgntmesh( void );
                                                  1144:  # BMESH:  .word   BMESH+4
                                                  1145:  #         jal     bgntmesh
                                                  1146:  #         nop
                                                  1147:  #         j       $next
                                                  1148:  #         nop
                                                  1149:  #
                                                  1150:  #  # void     bgntrim( void );
                                                  1151:  #  # void     blankscreen( Boolean );
                                                  1152:  #  # void     blanktime( long );
                                                  1153:  #  # void     blendfunction( long, long );
                                                  1154:  #  # void     blink( short, Colorindex, short, short, short );
                                                  1155:  #  # long     blkqread( short[], short );
                                                  1156:  #  # void     c3f( const float[3] );
                                                  1157:  #  # void     c3i( const long[3] );
                                                  1158:  #  # void     c3s( const short[3] );
                                                  1159:  #  # void     c4f( const float[4] );
                                                  1160:  #  # void     c4i( const long[4] );
                                                  1161:  #  # void     c4s( const short[4] );
                                                  1162:  #  # void     callfunc( __PFV_, long, ... );          /* not recommended */
                                                  1163:  #  # void     callobj( Object );
                                                  1164:  #  # void     charstr( String );
                                                  1165:  # CHRST:  .word   CHRST+4
                                                  1166:  #         lw      $a0, 0(DP)
                                                  1167:  #         jal     charstr
                                                  1168:  #         nop
                                                  1169:  #         j       $next
                                                  1170:  #         addiu   DP, DP, 4
                                                  1171:  #
                                                  1172:  #  # void     chunksize( long );
                                                  1173:  #  # void     circ( Coord, Coord, Coord );
                                                  1174:  #  # void     circf( Coord, Coord, Coord );
                                                  1175:  #  # void     circfi( Icoord, Icoord, Icoord );
                                                  1176:  # CIRFI:  .word   CIRFI+4
                                                  1177:  #         lw      $a0, 8(DP)
                                                  1178:  #         lw      $a1, 4(DP)
                                                  1179:  #         jal     circfi
                                                  1180:  #         lw      $a2, 0(DP)
                                                  1181:  #         j       $next
                                                  1182:  #         addiu   DP, DP, 12
                                                  1183:  #
                                                  1184:  #
                                                  1185:  #  # void     circfs( Scoord, Scoord, Scoord );
                                                  1186:  #  # void     circi( Icoord, Icoord, Icoord );
                                                  1187:  # CIRCI:  .word   CIRCI+4
                                                  1188:  #         lw      $a0, 8(DP)
                                                  1189:  #         lw      $a1, 4(DP)
                                                  1190:  #         jal     circi
                                                  1191:  #         lw      $a2, 0(DP)
                                                  1192:  #         j       $next
                                                  1193:  #         addiu   DP, DP, 12
                                                  1194:  #
                                                  1195:  #  # void     circs( Scoord, Scoord, Scoord );
                                                  1196:  #  # void     clear( void );
                                                  1197:  # CLEAR:  .word   CLEAR+4
                                                  1198:  #         jal     clear
                                                  1199:  #         nop
                                                  1200:  #         j       $next
                                                  1201:  #         nop
                                                  1202:  #
                                                  1203:  #  # void     clearhitcode( void );                   /* not recommended */
                                                  1204:  #  # void     clipplane( long, long, const float[] );
                                                  1205:  #  # void     clkoff( void );
                                                  1206:  #  # void     clkon( void );
                                                  1207:  #  # void     closeobj( void );
                                                  1208:  #  # void     cmode( void );
                                                  1209:  #  # void     cmov( Coord, Coord, Coord );
                                                  1210:  #  # void     cmov2( Coord, Coord );
                                                  1211:  #  # void     cmov2i( Icoord, Icoord );
                                                  1212:  # CMOV2:  .word   CMOV2+4
                                                  1213:  #         lw      $a0, 12(DP)
                                                  1214:  #         jal     cmov2i
                                                  1215:  #         lw      $a1, 8(DP)
                                                  1216:  #         j       $next
                                                  1217:  #         addiu   DP, DP, 8
                                                  1218:  #
                                                  1219:  #  # void     cmov2s( Scoord, Scoord );
                                                  1220:  #  # void     cmovi( Icoord, Icoord, Icoord );
                                                  1221:  # CMOVI:  .word   CMOVI+4
                                                  1222:  #         lw      $a0, 8(DP)
                                                  1223:  #         lw      $a1, 4(DP)
                                                  1224:  #         jal     cmovi
                                                  1225:  #         lw      $a2, 0(DP)
                                                  1226:  #         j       $next
                                                  1227:  #         addiu   DP, DP, 12
                                                  1228:  #
                                                  1229:  #  # void     cmovs( Scoord, Scoord, Scoord );
                                                  1230:  #  # void     color( Colorindex );
                                                  1231:  # COLOR:  .word   COLOR+4
                                                  1232:  #         lw      $a0, 0(DP)
                                                  1233:  #         jal     color
                                                  1234:  #         nop
                                                  1235:  #         j       $next
                                                  1236:  #         addiu   DP, DP, 4
                                                  1237:  #
                                                  1238:  #  # void     colorf( float );
                                                  1239:  #  # void     compactify( Object );
                                                  1240:  #  # void     concave( Boolean );
                                                  1241:  #  # void     cpack( unsigned long );
                                                  1242:  # CPACK:  .word   CPACK+4
                                                  1243:  #         lw      $a0, 0(DP)
                                                  1244:  #         jal     cpack
                                                  1245:  #         nop
                                                  1246:  #         j       $next
                                                  1247:  #         addiu   DP, DP, 4
                                                  1248:  #
                                                  1249:  #  # void     crv( const Coord[4][3] );
                                                  1250:  #  # void     crvn( long, const Coord[][3] );
                                                  1251:  #  # void     curorigin( short, short, short );
                                                  1252:  #  # void     cursoff( void );
                                                  1253:  #  # void     curson( void );
                                                  1254:  #  # void     curstype( long );
                                                  1255:  #  # void     curvebasis( short );
                                                  1256:  #  # void     curveit( short );
                                                  1257:  #  # void     curveprecision( short );
                                                  1258:  #  # void     cyclemap( short, short, short );
                                                  1259:  #  # void     czclear( unsigned long, long );
                                                  1260:  #  # void     dbtext( char[8] );
                                                  1261:  #  # void     defbasis( short, const Matrix );
                                                  1262:  #  # void     defcursor( short, const unsigned short[128] );
                                                  1263:  #  # void     deflfont( short, short, const Lfontchar[], long, const unsigned short[] );
                                                  1264:  #  # void     deflinestyle( short, Linestyle );
                                                  1265:  #  # void     defpattern( short, short, const unsigned short[] );
                                                  1266:  #  # long     defpup( String, ... );
                                                  1267:  #  # void     defrasterfont( short, short, short, const Fontchar[], short, const unsigned short[] );
                                                  1268:  #  # void     delobj( Object );
                                                  1269:  #  # void     deltag( Tag );
                                                  1270:  #  # void     depthcue( Boolean );
                                                  1271:  #  # void     dglclose( long );
                                                  1272:  #  # long     dglopen( String, long );
                                                  1273:  #  # void     dither( long );
                                                  1274:  #  # long     dopup( long );
                                                  1275:  #  # void     doublebuffer( void );
                                                  1276:  #  # void     draw( Coord, Coord, Coord );
                                                  1277:  #  # void     draw2( Coord, Coord );
                                                  1278:  #  # void     draw2i( Icoord, Icoord );
                                                  1279:  # DRAW2:  .word   DRAW2+4
                                                  1280:  #         lw      $a0, 4(DP)
                                                  1281:  #         jal     draw2i
                                                  1282:  #         lw      $a1, 0(DP)
                                                  1283:  #         j       $next
                                                  1284:  #         addiu   DP, DP, 8
                                                  1285:  #
                                                  1286:  #  # void     draw2s( Scoord, Scoord );
                                                  1287:  #  # void     drawi( Icoord, Icoord, Icoord );
                                                  1288:  # DRAWI:  .word   DRAWI+4
                                                  1289:  #         lw      $a0, 8(DP)
                                                  1290:  #         lw      $a1, 4(DP)
                                                  1291:  #         jal     drawi
                                                  1292:  #         lw      $a2, 0(DP)
                                                  1293:  #         j       $next
                                                  1294:  #         addiu   DP, DP, 12
                                                  1295:  #
                                                  1296:  #  # void     drawmode( long );
                                                  1297:  #  # void     draws( Scoord, Scoord, Scoord );
                                                  1298:  #  # void     editobj( Object );
                                                  1299:  #  # void     endclosedline( void );
                                                  1300:  # ECLIN:  .word   ECLIN+4
                                                  1301:  #         jal     endclosedline
                                                  1302:  #         nop
                                                  1303:  #         j       $next
                                                  1304:  #         nop
                                                  1305:  #
                                                  1306:  #  # void     endcurve( void );
                                                  1307:  #  # long     endfeedback( void * );
                                                  1308:  #  # void     endfullscrn( void );
                                                  1309:  #  # void     endline( void );
                                                  1310:  # ELINE:  .word   ELINE+4
                                                  1311:  #         jal     endline
                                                  1312:  #         nop
                                                  1313:  #         j       $next
                                                  1314:  #         nop
                                                  1315:  #
                                                  1316:  #  # long     endpick( short[] );
                                                  1317:  #  # void     endpoint( void );
                                                  1318:  # EPNT:   .word   EPNT+4
                                                  1319:  #         jal     endpoint
                                                  1320:  #         nop
                                                  1321:  #         j       $next
                                                  1322:  #         nop
                                                  1323:  #
                                                  1324:  #  # void     endpolygon( void );
                                                  1325:  # EPOLY:  .word   EPOLY+4
                                                  1326:  #         jal     endpolygon
                                                  1327:  #         nop
                                                  1328:  #         j       $next
                                                  1329:  #         nop
                                                  1330:  #
                                                  1331:  #  # void     endqstrip( void );
                                                  1332:  #  # long     endselect( short[] );
                                                  1333:  #  # void     endsurface( void );
                                                  1334:  #  # void     endtmesh( void );
                                                  1335:  # EMESH:  .word   EMESH+4
                                                  1336:  #         jal     endtmesh
                                                  1337:  #         nop
                                                  1338:  #         j       $next
                                                  1339:  #         nop
                                                  1340:  #
                                                  1341:  #  # void     endtrim( void );
                                                  1342:  #  # void     feedback( void *, long );
                                                  1343:  #  # void     finish( void );
                                                  1344:  #  # void     fogvertex( long, const float[] );
                                                  1345:  #  # void     font( short );
                                                  1346:  #  # void     foreground( void );
                                                  1347:  #  # void     freepup( long );
                                                  1348:  #  # void     frontbuffer( Boolean );
                                                  1349:  #  # void     frontface( Boolean );
                                                  1350:  #  # void     fudge( long, long );
                                                  1351:  #  # void     fullscrn( void );
                                                  1352:  #  # void     gammaramp( const short[256], const short[256], const short[256] );
                                                  1353:  #  # void     gbegin( void );
                                                  1354:  # GBEGN:  .word   GBEGN+4
                                                  1355:  #         jal     gbegin
                                                  1356:  #         nop
                                                  1357:  #         j       $next
                                                  1358:  #         nop
                                                  1359:  #
                                                  1360:  #  # void     gconfig( void );
                                                  1361:  # GCONF:  .word   GCONF+4
                                                  1362:  #         jal     gconfig
                                                  1363:  #         nop
                                                  1364:  #         j       $next
                                                  1365:  #         nop
                                                  1366:  #
                                                  1367:  #  # Object   genobj( void );
                                                  1368:  #  # Tag      gentag( void );
                                                  1369:  #  # long     getbackface( void );
                                                  1370:  #  # long     getbuffer( void );
                                                  1371:  #  # Boolean  getbutton( Device );
                                                  1372:  #  # Boolean  getcmmode( void );
                                                  1373:  #  # long     getcolor( void );
                                                  1374:  #  # void     getcpos( short *, short * );
                                                  1375:  #  # void     getcursor( short *, Colorindex *, Colorindex *, Boolean * );
                                                  1376:  #  # Boolean  getdcm( void );
                                                  1377:  #  # long     getdescender( void );
                                                  1378:  #  # void     getdev( long, const Device[], short[] );
                                                  1379:  # GTDEV:  .word   GTDEV+4
                                                  1380:  #         lw      $a0, 8(DP)
                                                  1381:  #         lw      $a1, 4(DP)
                                                  1382:  #         lw      $a2, 0(DP)
                                                  1383:  #         jal     getdev
                                                  1384:  #         nop
                                                  1385:  #         j       $next
                                                  1386:  #         addiu   DP, DP, 12
                                                  1387:  #
                                                  1388:  #  # long     getdisplaymode( void );
                                                  1389:  #  # long     getdrawmode( void );
                                                  1390:  #  # long     getfont( void );
                                                  1391:  #  # long     getgdesc( long );
                                                  1392:  # GDESC:  .word   GDESC+4
                                                  1393:  #         jal     getgdesc
                                                  1394:  #         lw      $a0, 0(DP)
                                                  1395:  #         j       $next
                                                  1396:  #         sw      $v0, 0(DP)
                                                  1397:  #
                                                  1398:  #  # void     getgpos( Coord *, Coord *, Coord *, Coord * );
                                                  1399:  #  # long     getheight( void );
                                                  1400:  #  # long     getlsrepeat( void );
                                                  1401:  #  # long     getlstyle( void );
                                                  1402:  #  # long     getlwidth( void );
                                                  1403:  #  # long     getmap( void );
                                                  1404:  #  # void     getmatrix( Matrix );
                                                  1405:  #  # void     getmcolor( Colorindex, short *, short *, short * );
                                                  1406:  #  # long     getmmode( void );
                                                  1407:  #  # long     getmonitor( void );
                                                  1408:  #  # void     getnurbsproperty( long, float * );
                                                  1409:  #  # Object   getopenobj( void );
                                                  1410:  #  # void     getorigin( long *, long * );
                                                  1411:  # GORIG:  .word   GORIG+4
                                                  1412:  #         lw      $a0, 4(DP)
                                                  1413:  #         lw      $a1, 0(DP)
                                                  1414:  #         jal     getorigin
                                                  1415:  #         addiu   DP, DP, 8
                                                  1416:  #         j       $next
                                                  1417:  #         nop
                                                  1418:  #
                                                  1419:  #  # long     getpattern( void );
                                                  1420:  #  # long     getplanes( void );
                                                  1421:  #  # void     getscrbox( long *, long *, long *, long * );
                                                  1422:  #  # void     getscrmask( Screencoord *, Screencoord *, Screencoord *, Screencoord * );
                                                  1423:  #  # void     getsize( long *, long * );
                                                  1424:  # GSIZE:  .word   GSIZE+4
                                                  1425:  #         lw      $a0, 4(DP)
                                                  1426:  #         lw      $a1, 0(DP)
                                                  1427:  #         jal     getsize
                                                  1428:  #         addiu   DP, DP, 8
                                                  1429:  #         j       $next
                                                  1430:  #         nop
                                                  1431:  #
                                                  1432:  #  # long     getsm( void );
                                                  1433:  #  # long     getvaluator( Device );
                                                  1434:  #  # long     getvideo( long );
                                                  1435:  #  # void     getviewport( Screencoord *, Screencoord *, Screencoord *, Screencoord * );
                                                  1436:  #  # long     getwritemask( void );
                                                  1437:  #  # long     getwscrn( void );
                                                  1438:  #  # Boolean  getzbuffer( void );
                                                  1439:  #  # void     gexit( void );
                                                  1440:  # GEXIT:  .word   GEXIT+4
                                                  1441:  #         jal     gexit
                                                  1442:  #         nop
                                                  1443:  #         j       $next
                                                  1444:  #         addu    $sp, 64
                                                  1445:  #
                                                  1446:  # GINIT:  .word   GINIT+4
                                                  1447:  #         jal     ginit
                                                  1448:  #         nop
                                                  1449:  #         j       $next
                                                  1450:  #         nop
                                                  1451:  #
                                                  1452:  #  # void     gflush( void );
                                                  1453:  #  # void     glcompat( long, long );
                                                  1454:  #  # long     GLXlink( void *, GLXconfig * );
                                                  1455:  #  # long     GLXunlink( void *, unsigned long );
                                                  1456:  #  # long     GLXwinset( void *, unsigned long );
                                                  1457:  #  # void     gRGBcolor( short *, short *, short * );
                                                  1458:  #  # void     gRGBcursor( short *, short *, short *, short *, short *, short *, short *, Boolean * ); /* obsolete */
                                                  1459:  #  # void     gRGBmask( short *, short *, short * );
                                                  1460:  #  # void     gselect( short[], long );
                                                  1461:  #  # void     gsync( void );
                                                  1462:  #  # long     gversion( char[12] );
                                                  1463:  #  # void     iconsize( long, long );
                                                  1464:  #  # void     icontitle( String );
                                                  1465:  #  # void     imakebackground( void );
                                                  1466:  #  # void     initnames( void );
                                                  1467:  #  # Boolean  isobj( Object );
                                                  1468:  #  # Boolean  isqueued( Device );
                                                  1469:  #  # Boolean  istag( Tag );
                                                  1470:  #  # void     keepaspect( long, long );
                                                  1471:  #  # void     lcharstr( long, Lstring );
                                                  1472:  #  # void     linesmooth( unsigned long );
                                                  1473:  #  # void     linewidth( short );
                                                  1474:  #  # void     linewidthf( float );
                                                  1475:  #  # void     lmbind( short, short );
                                                  1476:  #  # void     lmcolor( long );
                                                  1477:  #  # void     lmdef( short, short, short, const float[] );
                                                  1478:  #  # void     loadmatrix( const Matrix );
                                                  1479:  #  # void     loadname( short );
                                                  1480:  #  # void     logicop( long );
                                                  1481:  #  # void     lookat( Coord, Coord, Coord, Coord, Coord, Coord, Angle );
                                                  1482:  # LOKAT:  .word   LOKAT+4
                                                  1483:  #         l.s     $f12, 24(DP)
                                                  1484:  #         l.s     $f14, 20(DP)
                                                  1485:  #         lw      $a2, 16(DP)
                                                  1486:  #         lw      $a3, 12(DP)
                                                  1487:  #         l.s     $f4, 8(DP)
                                                  1488:  #         l.s     $f6, 4(DP)
                                                  1489:  #         lw      $a0, 0(DP)
                                                  1490:  #         s.s     $f4, 16($sp)
                                                  1491:  #         s.s     $f6, 20($sp)
                                                  1492:  #         jal     lookat
                                                  1493:  #         sw      $a0, 24($sp)
                                                  1494:  #         j       $next
                                                  1495:  #         addiu   DP, DP, 28
                                                  1496:  #
                                                  1497:  #  # long     lrectread( Screencoord, Screencoord, Screencoord, Screencoord, unsigned long[] );
                                                  1498:  #  # void     lrectwrite( Screencoord, Screencoord, Screencoord, Screencoord, const unsigned long[] );
                                                  1499:  #  # void     lRGBrange( short, short, short, short, short, short, long, long );
                                                  1500:  #  # void     lsetdepth( long, long );
                                                  1501:  #  # void     lshaderange( Colorindex, Colorindex, long, long );
                                                  1502:  #  # void     lsrepeat( long );
                                                  1503:  #  # long     lstrwidth( long, Lstring );
                                                  1504:  #  # void     makeobj( Object );
                                                  1505:  #  # void     maketag( Tag );
                                                  1506:  #  # void     mapcolor( Colorindex, short, short, short );
                                                  1507:  #  # void     mapw( Object, Screencoord, Screencoord, Coord *, Coord *, Coord *, Coord *, Coord *, Coord * );
                                                  1508:  #  # void     mapw2( Object, Screencoord, Screencoord, Coord *, Coord * );
                                                  1509:  #  # void     maxsize( long, long );
                                                  1510:  #  # void     minsize( long, long );
                                                  1511:  #  # void     mmode( short );
                                                  1512:  #  # void     move( Coord, Coord, Coord );
                                                  1513:  #  # void     move2( Coord, Coord );
                                                  1514:  #  # void     move2i( Icoord, Icoord );
                                                  1515:  # MOVE2:  .word   MOVE2+4
                                                  1516:  #         lw      $a0, 4(DP)
                                                  1517:  #         jal     move2i
                                                  1518:  #         lw      $a1, 0(DP)
                                                  1519:  #         j       $next
                                                  1520:  #         addiu   DP, DP, 8
                                                  1521:  #
                                                  1522:  #  # void     move2s( Scoord, Scoord );
                                                  1523:  #  # void     movei( Icoord, Icoord, Icoord );
                                                  1524:  # MOVEI:  .word   MOVEI+4
                                                  1525:  #         lw      $a0, 8(DP)
                                                  1526:  #         lw      $a1, 4(DP)
                                                  1527:  #         jal     movei
                                                  1528:  #         lw      $a2, 0(DP)
                                                  1529:  #         j       $next
                                                  1530:  #         addiu   DP, DP, 12
                                                  1531:  #
                                                  1532:  #  # void     moves( Scoord, Scoord, Scoord );
                                                  1533:  #  # void     mswapbuffers( long );
                                                  1534:  #  # void     multimap( void );
                                                  1535:  #  # void     multmatrix( const Matrix );
                                                  1536:  #  # void     n3f( const float[3] );
                                                  1537:  #  # long     newpup( void );
                                                  1538:  #  # void     newtag( Tag, Tag, Offset );
                                                  1539:  #  # void     nmode( long );
                                                  1540:  #  # void     noborder( void );
                                                  1541:  #  # void     noise( Device, short );
                                                  1542:  #  # void     noport( void );
                                                  1543:  #  # void     nurbscurve( long, const double[], long, const double[], long, long );
                                                  1544:  #  # void     nurbssurface( long, const double[], long, const double[], long, long, const double[], long, long, long );
                                                  1545:  #  # void     objdelete( Tag, Tag );
                                                  1546:  #  # void     objinsert( Tag );
                                                  1547:  #  # void     objreplace( Tag );
                                                  1548:  #  # void     onemap( void );
                                                  1549:  #  # void     ortho( Coord, Coord, Coord, Coord, Coord, Coord );
                                                  1550:  # ORTHO:  .word   ORTHO+4
                                                  1551:  #         l.s     $f12, 20(DP)
                                                  1552:  #         l.s     $f14, 16(DP)
                                                  1553:  #         lw      $a2, 12(DP)
                                                  1554:  #         lw      $a3, 8(DP)
                                                  1555:  #         l.s     $f4, 4(DP)
                                                  1556:  #         l.s     $f6, 0(DP)
                                                  1557:  #         s.s     $f4, 16($sp)
                                                  1558:  #         jal     ortho
                                                  1559:  #         s.s     $f6, 20($sp)
                                                  1560:  #         j       $next
                                                  1561:  #         addiu   DP, DP, 24
                                                  1562:  #
                                                  1563:  #  # void     ortho2( Coord, Coord, Coord, Coord );
                                                  1564:  # ORTH2:  .word   ORTH2+4
                                                  1565:  #         l.s     $f12, 12(DP)
                                                  1566:  #         l.s     $f14, 8(DP)
                                                  1567:  #         lw      $a2, 4(DP)
                                                  1568:  #         jal     ortho2
                                                  1569:  #         lw      $a3, 0(DP)
                                                  1570:  #         j       $next
                                                  1571:  #         addiu   DP, DP, 16
                                                  1572:  #
                                                  1573:  #  # void     overlay( long );
                                                  1574:  #  # void     passthrough( short );
                                                  1575:  #  # void     patch( const Matrix, const Matrix, const Matrix );
                                                  1576:  #  # void     patchbasis( long, long );
                                                  1577:  #  # void     patchcurves( long, long );
                                                  1578:  #  # void     patchprecision( long, long );
                                                  1579:  #  # void     pclos( void );
                                                  1580:  #  # void     pdr( Coord, Coord, Coord );
                                                  1581:  #  # void     pdr2( Coord, Coord );
                                                  1582:  #  # void     pdr2i( Icoord, Icoord );
                                                  1583:  #  # void     pdr2s( Scoord, Scoord );
                                                  1584:  #  # void     pdri( Icoord, Icoord, Icoord );
                                                  1585:  #  # void     pdrs( Scoord, Scoord, Scoord );
                                                  1586:  #  # void     perspective( Angle, float, Coord, Coord );
                                                  1587:  # PERSP:  .word   PERSP+4
                                                  1588:  #         lw      $a0, 12(DP)
                                                  1589:  #         lw      $a1, 8(DP)
                                                  1590:  #         lw      $a2, 4(DP)
                                                  1591:  #         jal     perspective
                                                  1592:  #         lw      $a3, 0(DP)
                                                  1593:  #         j       $next
                                                  1594:  #         addiu   DP, DP, 16
                                                  1595:  #
                                                  1596:  #  # void     pick( short[], long );
                                                  1597:  #  # void     picksize( short, short );
                                                  1598:  #  # void     pixmode( long, long );
                                                  1599:  #  # void     pixmodef( long, float );
                                                  1600:  #  # void     pmv( Coord, Coord, Coord );
                                                  1601:  #  # void     pmv2( Coord, Coord );
                                                  1602:  #  # void     pmv2i( Icoord, Icoord );
                                                  1603:  #  # void     pmv2s( Scoord, Scoord );
                                                  1604:  #  # void     pmvi( Icoord, Icoord, Icoord );
                                                  1605:  #  # void     pmvs( Scoord, Scoord, Scoord );
                                                  1606:  #  # void     pnt( Coord, Coord, Coord );
                                                  1607:  #  # void     pnt2( Coord, Coord );
                                                  1608:  #  # void     pnt2i( Icoord, Icoord );
                                                  1609:  # PNT2I:  .word   PNT2I+4
                                                  1610:  #         lw      $a0, 12(DP)
                                                  1611:  #         jal     pnt2i
                                                  1612:  #         lw      $a1, 8(DP)
                                                  1613:  #         j       $next
                                                  1614:  #         addiu   DP, DP, 8
                                                  1615:  #
                                                  1616:  #  # void     pnt2s( Scoord, Scoord );
                                                  1617:  #  # void     pnti( Icoord, Icoord, Icoord );
                                                  1618:  # PNTI:   .word   PNTI+4
                                                  1619:  #         lw      $a0, 8(DP)
                                                  1620:  #         lw      $a1, 4(DP)
                                                  1621:  #         jal     pnti
                                                  1622:  #         lw      $a2, 0(DP)
                                                  1623:  #         j       $next
                                                  1624:  #         addiu   DP, DP, 12
                                                  1625:  #
                                                  1626:  #  # void     pnts( Scoord, Scoord, Scoord );
                                                  1627:  #  # void     pntsize( short );
                                                  1628:  #  # void     pntsizef( float );
                                                  1629:  #  # void     pntsmooth( unsigned long );
                                                  1630:  #  # void     polarview( Coord, Angle, Angle, Angle );
                                                  1631:  #  # void     polf( long, const Coord[][3] );
                                                  1632:  # POLF:   .word   POLF+4
                                                  1633:  #         lw      $a0, 4(DP)
                                                  1634:  #         lw      $a1, 0(DP)
                                                  1635:  #         jal     polf
                                                  1636:  #         addiu   DP, DP, 8
                                                  1637:  #         j       $next
                                                  1638:  #         nop
                                                  1639:  #
                                                  1640:  #   # void     polf2( long, const Coord[][2] );
                                                  1641:  #  # void     polf2i( long, const Icoord[][2] );
                                                  1642:  # PLF2I:  .word   PLF2I+4
                                                  1643:  #         lw      $a0, 4(DP)
                                                  1644:  #         lw      $a1, 0(DP)
                                                  1645:  #         jal     polf2i
                                                  1646:  #         addiu   DP, DP, 8
                                                  1647:  #         j       $next
                                                  1648:  #         nop
                                                  1649:  #
                                                  1650:  #  # void     polf2s( long, const Scoord[][2] );
                                                  1651:  #  # void     polfi( long, const Icoord[][3] );
                                                  1652:  # POLFI:  .word   POLFI+4
                                                  1653:  #         lw      $a0, 4(DP)
                                                  1654:  #         lw      $a1, 0(DP)
                                                  1655:  #         jal     polfi
                                                  1656:  #         addiu   DP, DP, 8
                                                  1657:  #         j       $next
                                                  1658:  #         nop
                                                  1659:  #
                                                  1660:  #   # void     polfs( long, const Scoord[][3] );
                                                  1661:  #  # void     poly( long, const Coord[][3] );
                                                  1662:  #  # void     poly2( long, const Coord[][2] );
                                                  1663:  #  # void     poly2i( long, const Icoord[][2] );
                                                  1664:  # POLY2:  .word   POLY2+4
                                                  1665:  #         lw      $a0, 4(DP)
                                                  1666:  #         lw      $a1, 0(DP)
                                                  1667:  #         jal     poly2i
                                                  1668:  #         addiu   DP, DP, 8
                                                  1669:  #         j       $next
                                                  1670:  #         nop
                                                  1671:  #
                                                  1672:  #  # void     poly2s( long, const Scoord[][2] );
                                                  1673:  #  # void     polyi( long, const Icoord[][3] );
                                                  1674:  #  # void     polymode( long );
                                                  1675:  #  # void     polys( long, const Scoord[][3] );
                                                  1676:  #  # void     polysmooth( long );
                                                  1677:  #  # void     popattributes( void );
                                                  1678:  #  # void     popmatrix( void );
                                                  1679:  # POPMA:  .word   POPMA+4
                                                  1680:  #         jal     popmatrix
                                                  1681:  #         nop
                                                  1682:  #         j       $next
                                                  1683:  #         nop
                                                  1684:  #
                                                  1685:  #  # void     popname( void );
                                                  1686:  #  # void     popviewport( void );
                                                  1687:  #  # void     prefposition( long, long, long, long );
                                                  1688:  # PREPO:  .word   PREPO+4
                                                  1689:  #         lw      $a0, 12(DP)
                                                  1690:  #         lw      $a1, 8(DP)
                                                  1691:  #         lw      $a2, 4(DP)
                                                  1692:  #         jal     prefposition
                                                  1693:  #         lw      $a3, 0(DP)
                                                  1694:  #         j       $next
                                                  1695:  #         addiu   DP, DP, 16
                                                  1696:  #
                                                  1697:  #  # void     prefsize( long, long );
                                                  1698:  # PRESI:  .word   PRESI+4
                                                  1699:  #         lw      $a0, 4(DP)
                                                  1700:  #         jal     prefsize
                                                  1701:  #         lw      $a1, 0(DP)
                                                  1702:  #         j       $next
                                                  1703:  #         addiu   DP, DP, 8
                                                  1704:  #
                                                  1705:  #  # void     pushattributes( void );
                                                  1706:  #  # void     pushmatrix( void );
                                                  1707:  # PSHMA:  .word   PSHMA+4
                                                  1708:  #         jal     pushmatrix
                                                  1709:  #         nop
                                                  1710:  #         j       $next
                                                  1711:  #         nop
                                                  1712:  #
                                                  1713:  #  # void     pushname( short );
                                                  1714:  #  # void     pushviewport( void );
                                                  1715:  #  # void     pwlcurve( long, const double[], long, long );
                                                  1716:  #  # long     qcontrol( long, long, const short[], long, short[] );
                                                  1717:  #  # void     qdevice( Device );
                                                  1718:  # QDEVI:  .word   QDEVI+4
                                                  1719:  #         lw      $a0, 0(DP)
                                                  1720:  #         jal     qdevice
                                                  1721:  #         nop
                                                  1722:  #         j       $next
                                                  1723:  #         addiu   DP, DP, 4
                                                  1724:  #
                                                  1725:  #  # void     qenter( Device, short );
                                                  1726:  #  # long     qgetfd( void );
                                                  1727:  #  # long     qread( short * );
                                                  1728:  # QREAD:  .word   QREAD+4
                                                  1729:  #         lw      $a0, 0(DP)
                                                  1730:  #         jal     qread
                                                  1731:  #         nop
                                                  1732:  #         j       $next
                                                  1733:  #         sw      $v0, 0(DP)
                                                  1734:  #
                                                  1735:  #  # void     qreset( void );
                                                  1736:  # QREST:  .word   QREST+4
                                                  1737:  #         jal     qreset
                                                  1738:  #         nop
                                                  1739:  #         j       $next
                                                  1740:  #         nop
                                                  1741:  #
                                                  1742:  #  # long     qtest( void );
                                                  1743:  #  # void     rcrv( const Coord[4][4] );
                                                  1744:  #  # void     rcrvn( long, const Coord[][4] );
                                                  1745:  #  # void     rdr( Coord, Coord, Coord );
                                                  1746:  #  # void     rdr2( Coord, Coord );
                                                  1747:  #  # void     rdr2i( Icoord, Icoord );
                                                  1748:  #  # void     rdr2s( Scoord, Scoord );
                                                  1749:  #  # void     rdri( Icoord, Icoord, Icoord );
                                                  1750:  #  # void     rdrs( Scoord, Scoord, Scoord );
                                                  1751:  #  # long     readdisplay( Screencoord, Screencoord, Screencoord, Screencoord, unsigned long[], unsigned long );
                                                  1752:  #  # long     readpixels( short, Colorindex[] );
                                                  1753:  #  # long     readRGB( short, RGBvalue[], RGBvalue[], RGBvalue[] );
                                                  1754:  #  # void     readsource( long );
                                                  1755:  #  # void     rect( Coord, Coord, Coord, Coord );
                                                  1756:  #  # void     rectcopy( Screencoord, Screencoord, Screencoord, Screencoord, Screencoord, Screencoord );
                                                  1757:  #  # void     rectf( Coord, Coord, Coord, Coord );
                                                  1758:  #  # void     rectfi( Icoord, Icoord, Icoord, Icoord );
                                                  1759:  # RCTFI:  .word   RCTFI+4
                                                  1760:  #         lw      $a0, 12(DP)
                                                  1761:  #         lw      $a1, 8(DP)
                                                  1762:  #         lw      $a2, 4(DP)
                                                  1763:  #         jal     rectfi
                                                  1764:  #         lw      $a3, 0(DP)
                                                  1765:  #         j       $next
                                                  1766:  #         addiu   DP, DP, 16
                                                  1767:  #
                                                  1768:  #  # void     rectfs( Scoord, Scoord, Scoord, Scoord );
                                                  1769:  #  # void     recti( Icoord, Icoord, Icoord, Icoord );
                                                  1770:  # RECTI:  .word   RECTI+4
                                                  1771:  #         lw      $a0, 12(DP)
                                                  1772:  #         lw      $a1, 8(DP)
                                                  1773:  #         lw      $a2, 4(DP)
                                                  1774:  #         jal     recti
                                                  1775:  #         lw      $a3, 0(DP)
                                                  1776:  #         j       $next
                                                  1777:  #         addiu   DP, DP, 16
                                                  1778:  #
                                                  1779:  #  # long     rectread( Screencoord, Screencoord, Screencoord, Screencoord, Colorindex[] );
                                                  1780:  #  # void     rects( Scoord, Scoord, Scoord, Scoord );
                                                  1781:  #  # void     rectwrite( Screencoord, Screencoord, Screencoord, Screencoord, const Colorindex[] );
                                                  1782:  #  # void     rectzoom( float, float );
                                                  1783:  #  # void     reshapeviewport( void );
                                                  1784:  #  # void     RGBcolor( short, short, short );
                                                  1785:  #  # void     RGBmode( void );
                                                  1786:  # RGBMD:  .word   RGBMD+4
                                                  1787:  #         jal     RGBmode
                                                  1788:  #         nop
                                                  1789:  #         j       $next
                                                  1790:  #         nop
                                                  1791:  #
                                                  1792:  #  # void     RGBwritemask( short, short, short );
                                                  1793:  #  # void     ringbell( void );
                                                  1794:  #  # void     rmv( Coord, Coord, Coord );
                                                  1795:  #  # void     rmv2( Coord, Coord );
                                                  1796:  #  # void     rmv2i( Icoord, Icoord );
                                                  1797:  #  # void     rmv2s( Scoord, Scoord );
                                                  1798:  #  # void     rmvi( Icoord, Icoord, Icoord );
                                                  1799:  #  # void     rmvs( Scoord, Scoord, Scoord );
                                                  1800:  #  # void     rot( float, char );
                                                  1801:  #  # void     rotate( Angle, char );
                                                  1802:  # ROTAT:  .word   ROTAT+4
                                                  1803:  #         lw      $a0, 4(DP)
                                                  1804:  #         jal     rotate
                                                  1805:  #         lw      $a1, 0(DP)
                                                  1806:  #         j       $next
                                                  1807:  #         addiu   DP, DP, 8
                                                  1808:  #
                                                  1809:  #  # void     rpatch( const Matrix, const Matrix, const Matrix, const Matrix );
                                                  1810:  #  # void     rpdr( Coord, Coord, Coord );
                                                  1811:  #  # void     rpdr2( Coord, Coord );
                                                  1812:  #  # void     rpdr2i( Icoord, Icoord );
                                                  1813:  #  # void     rpdr2s( Scoord, Scoord );
                                                  1814:  #  # void     rpdri( Icoord, Icoord, Icoord );
                                                  1815:  #  # void     rpdrs( Scoord, Scoord, Scoord );
                                                  1816:  #  # void     rpmv( Coord, Coord, Coord );
                                                  1817:  #  # void     rpmv2( Coord, Coord );
                                                  1818:  #  # void     rpmv2i( Icoord, Icoord );
                                                  1819:  #  # void     rpmv2s( Scoord, Scoord );
                                                  1820:  #  # void     rpmvi( Icoord, Icoord, Icoord );
                                                  1821:  #  # void     rpmvs( Scoord, Scoord, Scoord );
                                                  1822:  #  # void     sbox( Coord, Coord, Coord, Coord );
                                                  1823:  #  # void     sboxf( Coord, Coord, Coord, Coord );
                                                  1824:  #  # void     sboxfi( Icoord, Icoord, Icoord, Icoord );
                                                  1825:  # SBOXF:  .word   SBOXF+4
                                                  1826:  #         lw      $a0, 12(DP)
                                                  1827:  #         lw      $a1, 8(DP)
                                                  1828:  #         lw      $a2, 4(DP)
                                                  1829:  #         jal     sboxfi
                                                  1830:  #         lw      $a3, 0(DP)
                                                  1831:  #         j       $next
                                                  1832:  #         addiu   DP, DP, 16
                                                  1833:  #
                                                  1834:  #  # void     sboxfs( Scoord, Scoord, Scoord, Scoord );
                                                  1835:  #  # void     sboxi( Icoord, Icoord, Icoord, Icoord );
                                                  1836:  #  # void     sboxs( Scoord, Scoord, Scoord, Scoord );
                                                  1837:  #  # void     scale( float, float, float );
                                                  1838:  # SCALE:  .word   SCALE+4
                                                  1839:  #         l.s     $f12, 8(DP)
                                                  1840:  #         l.s     $f14, 4(DP)
                                                  1841:  #         jal     scale
                                                  1842:  #         lw      $a2, 0(DP)
                                                  1843:  #         j       $next
                                                  1844:  #         addiu   DP, DP, 12
                                                  1845:  #
                                                  1846:  #  # void     sclear( unsigned long );
                                                  1847:  #  # void     scrbox( long );
                                                  1848:  #  # void     screenspace( void );
                                                  1849:  #  # void     scrmask( Screencoord, Screencoord, Screencoord, Screencoord );
                                                  1850:  #  # long     scrnattach( long );
                                                  1851:  #  # long     scrnselect( long );
                                                  1852:  #  # void     scrsubdivide( long, const float[] );
                                                  1853:  #  # void     setbell( Byte );
                                                  1854:  #  # void     setcursor( short, Colorindex, Colorindex );
                                                  1855:  #  # void     setdblights( unsigned long );
                                                  1856:  #  # void     setlinestyle( short );
                                                  1857:  #  # void     setmap( short );
                                                  1858:  #  # void     setmonitor( short );
                                                  1859:  #  # void     setnurbsproperty( long, float );
                                                  1860:  #  # void     setpattern( short );
                                                  1861:  #  # void     setpup( long, long, unsigned long );
                                                  1862:  #  # void     setshade( Colorindex );
                                                  1863:  #  # void     setvaluator( Device, short, short, short );
                                                  1864:  #  # void     setvideo( long, long );
                                                  1865:  #  # void     shademodel( long );
                                                  1866:  # SHDMD:  .word   SHDMD+4
                                                  1867:  #         jal     shademodel
                                                  1868:  #         lw      $a0, 0(DP)
                                                  1869:  #         j       $next
                                                  1870:  #         addiu   DP, DP, 4
                                                  1871:  #
                                                  1872:  #  # void     singlebuffer( void );
                                                  1873:  # SLEEP:  .word   SLEEP+4
                                                  1874:  #         jal     sleep
                                                  1875:  #         lw      $a0, 0(DP)
                                                  1876:  #         j       $next
                                                  1877:  #         addiu   DP, DP, 4
                                                  1878:  #
                                                  1879:  #  # void     splf( long, const Coord[][3], const Colorindex[] );
                                                  1880:  #  # void     splf2( long, const Coord[][2], const Colorindex[] );
                                                  1881:  #  # void     splf2i( long, const Icoord[][2], const Colorindex[] );
                                                  1882:  #  # void     splf2s( long, const Scoord[][2], const Colorindex[] );
                                                  1883:  #  # void     splfi( long, const Icoord[][3], const Colorindex[] );
                                                  1884:  #  # void     splfs( long, const Scoord[][3], const Colorindex[] );
                                                  1885:  #  # void     stencil( long, unsigned long, long, unsigned long, long, long, long );
                                                  1886:  #  # void     stensize( long );
                                                  1887:  #  # void     stepunit( long, long );
                                                  1888:  #  # long     strwidth( String );
                                                  1889:  #  # void     subpixel( Boolean );
                                                  1890:  #  # void     swapbuffers( void );
                                                  1891:  #  # void     swapinterval( short );
                                                  1892:  #  # void     swaptmesh( void );
                                                  1893:  # SMESH:  .word   SMESH+4
                                                  1894:  #         jal     swaptmesh
                                                  1895:  #         nop
                                                  1896:  #         j       $next
                                                  1897:  #         nop
                                                  1898:  #
                                                  1899:  #  # long     swinopen( long );
                                                  1900:  #  # void     swritemask( unsigned long );
                                                  1901:  #  # void     t2d( const double[2] );
                                                  1902:  #  # void     t2f( const float[2] );
                                                  1903:  #  # void     t2i( const long[2] );
                                                  1904:  #  # void     t2s( const short[2] );
                                                  1905:  #  # void     tevbind( long, long );
                                                  1906:  #  # void     tevdef( long, long, const float[] );
                                                  1907:  #  # void     texbind( long, long );
                                                  1908:  #  # void     texdef2d( long, long, long, long, const unsigned long[], long, const float[] );
                                                  1909:  #  # void     texgen( long, long, const float[] );
                                                  1910:  #  # void     tie( Device, Device, Device );
                                                  1911:  # TIE:    .word   TIE+4
                                                  1912:  #         lw      $a0, 8(DP)
                                                  1913:  #         lw      $a1, 4(DP)
                                                  1914:  #         lw      $a2, 0(DP)
                                                  1915:  #         jal     tie
                                                  1916:  #         nop
                                                  1917:  #         j       $next
                                                  1918:  #         addiu   DP, DP, 12
                                                  1919:  #
                                                  1920:  #  # void     translate( Coord, Coord, Coord );
                                                  1921:  # TRANS:  .word   TRANS+4
                                                  1922:  #         l.s     $f12, 8(DP)
                                                  1923:  #         l.s     $f14, 4(DP)
                                                  1924:  #         jal     translate
                                                  1925:  #         lw      $a2, 0(DP)
                                                  1926:  #         j       $next
                                                  1927:  #         addiu   DP, DP, 12
                                                  1928:  #
                                                  1929:  #  # void     underlay( long );
                                                  1930:  #  # void     unqdevice( Device );
                                                  1931:  #  # void     v2d( const double[2] );
                                                  1932:  #  # void     v2f( const float[2] );
                                                  1933:  #  # void     v2i( const long[2] );
                                                  1934:  # V2I:    .word   V2I+4
                                                  1935:  #         jal     v2i
                                                  1936:  #         lw      $a0, 0(DP)
                                                  1937:  #         j       $next
                                                  1938:  #         addiu   DP, DP, 4
                                                  1939:  #
                                                  1940:  #  # void     v2s( const short[2] );
                                                  1941:  #  # void     v3d( const double[3] );
                                                  1942:  #  # void     v3f( const float[3] );
                                                  1943:  #  # void     v3i( const long[3] );
                                                  1944:  # V3I:    .word   V3I+4
                                                  1945:  #         jal     v3i
                                                  1946:  #         lw      $a0, 0(DP)
                                                  1947:  #         j       $next
                                                  1948:  #         addiu   DP, DP, 4
                                                  1949:  #
                                                  1950:  #  # void     v3s( const short[3] );
                                                  1951:  #  # void     v4d( const double[4] );
                                                  1952:  #  # void     v4f( const float[4] );
                                                  1953:  #  # void     v4i( const long[4] );
                                                  1954:  #  # void     v4s( const short[4] );
                                                  1955:  #  # void     videocmd( long );
                                                  1956:  #  # void     viewport( Screencoord, Screencoord, Screencoord, Screencoord );
                                                  1957:  #  # void     winclose( long );
                                                  1958:  #  # void     winconstraints( void );
                                                  1959:  #  # long     windepth( long );
                                                  1960:  #  # void     window( Coord, Coord, Coord, Coord, Coord, Coord );
                                                  1961:  #  # long     winget( void );
                                                  1962:  #  # void     winmove( long, long );
                                                  1963:  #  # long     winopen( String );
                                                  1964:  # WINOP:  .word   WINOP+4
                                                  1965:  #         la      $a0, WINDO+4
                                                  1966:  #         jal     winopen
                                                  1967:  #         nop
                                                  1968:  #         j       $next
                                                  1969:  #         sw      $v0, 0(DP)
                                                  1970:  #
                                                  1971:  #  # void     winpop( void );
                                                  1972:  #  # void     winposition( long, long, long, long );
                                                  1973:  #  # void     winpush( void );
                                                  1974:  #  # void     winset( long );
                                                  1975:  #  # void     wintitle( String );
                                                  1976:  #  # void     wmpack( unsigned long );
                                                  1977:  #  # void     writemask( Colorindex );
                                                  1978:  #  # void     writepixels( short, const Colorindex[] );
                                                  1979:  #  # void     writeRGB( short, const RGBvalue[], const RGBvalue[], const RGBvalue[] );
                                                  1980:  #  # void     zbuffer( Boolean );
                                                  1981:  # ZBUFF:  .word   ZBUFF+4
                                                  1982:  #         jal     zbuffer
                                                  1983:  #         lw      $a0, 0(DP)
                                                  1984:  #         j       $next
                                                  1985:  #         addiu   DP, DP, 4
                                                  1986:  #
                                                  1987:  #  # void     zclear( void );
                                                  1988:  # ZCLEA:  .word   ZCLEA+4
                                                  1989:  #         jal     zclear
                                                  1990:  #         nop
                                                  1991:  #         j       $next
                                                  1992:  #         nop
                                                  1993:  #
                                                  1994:  #  # void     zdraw( Boolean );
                                                  1995:  #  # void     zfunction( long );
                                                  1996:  #  # void     zwritemask( unsigned long );
                                                  1997:  #
                                                  1998:  # WINDO:  .word   dovar
                                                  1999:  #         .asciiz "window"
                                                  2000:  #
                                                  2001:  #         .word   BLACK, g01
                                                  2002:  # g00:    .ascii  "\005BLACK"
                                                  2003:  #         .word   RED, g02
                                                  2004:  # g01:    .ascii  "\003RED"
                                                  2005:  #         .word   GREEN, g03
                                                  2006:  # g02:    .ascii  "\005GREEN"
                                                  2007:  #         .word   YELLOW, g04
                                                  2008:  # g03:    .ascii  "\006YELLOW"
                                                  2009:  #         .word   BLUE, g05
                                                  2010:  # g04:    .ascii  "\004BLUE"
                                                  2011:  #         .word   MAGENTA, g06
                                                  2012:  # g05:    .ascii  "\007MAGENTA"
                                                  2013:  #         .word   CYAN, g07
                                                  2014:  # g06:    .ascii  "\004CYAN"
                                                  2015:  #         .word   WHITE, g08
                                                  2016:  # g07:    .ascii  "\005WHITE"
                                                  2017:  #         .word   BCLIN, g09
                                                  2018:  # g08:    .ascii  "\015bgnclosedline"
                                                  2019:  #         .word   BLINE, g10
                                                  2020:  # g09:    .ascii  "\007bgnline"
                                                  2021:  #         .word   BPNT, g11
                                                  2022:  # g10:    .ascii  "\010bgnpoint"
                                                  2023:  #         .word   BPOLY, g12
                                                  2024:  # g11:    .ascii  "\012bgnpolygon"
                                                  2025:  #         .word   BMESH, g13
                                                  2026:  # g12:    .ascii  "\010bgntmesh"
                                                  2027:  #         .word   CLEAR, g14
                                                  2028:  # g13:    .ascii  "\005clear"
                                                  2029:  #         .word   COLOR, g15
                                                  2030:  # g14:    .ascii  "\005color"
                                                  2031:  #         .word   CHRST, g15a
                                                  2032:  # g15:    .ascii  "\007charstr"
                                                  2033:  #         .word   CMOV2, g15b
                                                  2034:  # g15a:   .ascii  "\006cmov2i"
                                                  2035:  #         .word   CMOVI, g15c
                                                  2036:  # g15b:   .ascii  "\005cmovi"
                                                  2037:  #         .word   CPACK, g16
                                                  2038:  # g15c:   .ascii  "\005cpack"
                                                  2039:  #         .word   ECLIN, g17
                                                  2040:  # g16:    .ascii  "\015endclosedline"
                                                  2041:  #         .word   ELINE, g18
                                                  2042:  # g17:    .ascii  "\007endline"
                                                  2043:  #         .word   BCLIN, g19
                                                  2044:  # g18:    .ascii  "\015bgnclosedline"
                                                  2045:  #         .word   BLINE, g20
                                                  2046:  # g19:    .ascii  "\007bgnline"
                                                  2047:  #         .word   EPNT, g21
                                                  2048:  # g20:    .ascii  "\010endpoint"
                                                  2049:  #         .word   EPOLY, g22
                                                  2050:  # g21:    .ascii  "\012endpolygon"
                                                  2051:  #         .word   EMESH, g23
                                                  2052:  # g22:    .ascii  "\010endtmesh"
                                                  2053:  #         .word   GBEGN, g24
                                                  2054:  # g23:    .ascii  "\006gbegin"
                                                  2055:  #         .word   GDESC, g25
                                                  2056:  # g24:    .ascii  "\010getgdesc"
                                                  2057:  #         .word   GEXIT, g25a
                                                  2058:  # g25:    .ascii  "\005gexit"
                                                  2059:  #         .word   GINIT, g26
                                                  2060:  # g25a:   .ascii  "\005ginit"
                                                  2061:  #         .word   ORTHO, g27
                                                  2062:  # g26:    .ascii  "\005ortho"
                                                  2063:  #         .word   ORTH2, g28
                                                  2064:  # g27:    .ascii  "\006ortho2"
                                                  2065:  #         .word   POPMA, g28a
                                                  2066:  # g28:    .ascii  "\011popmatrix"
                                                  2067:  #         .word   PLF2I, g28b
                                                  2068:  # g28a:   .ascii  "\006polf2i"
                                                  2069:  #         .word   POLF, g28c
                                                  2070:  # g28b:   .ascii  "\004polf"
                                                  2071:  #         .word   POLFI, g28d
                                                  2072:  # g28c:   .ascii  "\005polfi"
                                                  2073:  #         .word   PNT2I, g28e
                                                  2074:  # g28d:   .ascii  "\005pnt2i"
                                                  2075:  #         .word   PNTI, g29
                                                  2076:  # g28e:   .ascii  "\004pnti"
                                                  2077:  #         .word   PREPO, g30
                                                  2078:  # g29:    .ascii  "\014prefposition"
                                                  2079:  #         .word   PRESI, g31
                                                  2080:  # g30:    .ascii  "\010prefsize"
                                                  2081:  #         .word   PSHMA, g32a
                                                  2082:  # g31:    .ascii  "\012pushmatrix"
                                                  2083:  #         .word   ROTAT, g32b
                                                  2084:  # g32a:   .ascii  "\006rotate"
                                                  2085:  #         .word   RCTFI, g32c
                                                  2086:  # g32b:   .ascii  "\006rectfi"
                                                  2087:  #         .word   RECTI, g33
                                                  2088:  # g32c:   .ascii  "\005recti"
                                                  2089:  #         .word   SCALE, g34
                                                  2090:  # g33:    .ascii  "\005scale"
                                                  2091:  #         .word   SHDMD, g35
                                                  2092:  # g34:    .ascii  "\012shademodel"
                                                  2093:  #         .word   SLEEP, g36
                                                  2094:  # g35:    .ascii  "\005sleep"
                                                  2095:  #         .word   SMESH, g37
                                                  2096:  # g36:    .ascii  "\011swaptmesh"
                                                  2097:  #         .word   TRANS, g38
                                                  2098:  # g37:    .ascii  "\011translate"
                                                  2099:  #         .word   V2I, g39
                                                  2100:  # g38:    .ascii  "\003v2i"
                                                  2101:  #         .word   V3I, g40
                                                  2102:  # g39:    .ascii  "\003v3i"
                                                  2103:  #         .word   WINOP, g41
                                                  2104:  # g40:    .ascii  "\007winopen"
                                                  2105:  #         .word   WINDO, g42
                                                  2106:  # g41:    .ascii  "\006window"
                                                  2107:  #         .word   ARCFI, g43
                                                  2108:  # g42:    .ascii  "\005arcfi"
                                                  2109:  #         .word   ARCI, g44
                                                  2110:  # g43:    .ascii  "\004arci"
                                                  2111:  #         .word   CIRFI, g45
                                                  2112:  # g44:    .ascii  "\006circfi"
                                                  2113:  #         .word   CIRCI, g46
                                                  2114:  # g45:    .ascii  "\005circi"
                                                  2115:  #         .word   DRAW2, g47
                                                  2116:  # g46:    .ascii  "\006draw2i"
                                                  2117:  #         .word   DRAWI, g48
                                                  2118:  # g47:    .ascii  "\005drawi"
                                                  2119:  #         .word   MOVE2, g49
                                                  2120:  # g48:    .ascii  "\006move2i"
                                                  2121:  #         .word   MOVEI, g50
                                                  2122:  # g49:    .ascii  "\005move1"
                                                  2123:  #         .word   POLY2, g51
                                                  2124:  # g50:    .ascii  "\006poly2i"
                                                  2125:  #         .word   MANDE, g52
                                                  2126:  # g51:    .ascii  "\006MANDEL"
                                                  2127:  #         .word   GTDEV, g53
                                                  2128:  # g52:    .ascii  "\006getdev"
                                                  2129:  #         .word   GORIG, g54
                                                  2130:  # g53:    .ascii  "\011getorigin"
                                                  2131:  #         .word   GSIZE, g55
                                                  2132:  # g54:    .ascii  "\007getsize"
                                                  2133:  #         .word   QDEVI, g56
                                                  2134:  # g55:    .ascii  "\007qdevice"
                                                  2135:  #         .word   QREAD, g56a
                                                  2136:  # g56:    .ascii  "\005qread"
                                                  2137:  #         .word   QREST, g57
                                                  2138:  # g56a:   .ascii  "\006qreset"
                                                  2139:  #         .word   TIE, g58
                                                  2140:  # g57:    .ascii  "\003tie"
                                                  2141:  #         .word   SBOXF, g59
                                                  2142:  # g58:    .ascii  "\006sboxfi"
                                                  2143:  #         .word   GCONF, g60
                                                  2144:  # g59:    .ascii  "\007gconfig"
                                                  2145:  #         .word   RGBMD, g61
                                                  2146:  # g60:    .ascii  "\007RGBmode"
                                                  2147:  #         .word   LOKAT, g62
                                                  2148:  # g61:    .ascii  "\006lookat"
                                                  2149:  #         .word   PERSP, g63
                                                  2150:  # g62:    .ascii  "\013perspective"
                                                  2151:  #         .word   ZBUFF, g64
                                                  2152:  # g63:    .ascii  "\007zbuffer"
                                                  2153:  #         .word   ZCLEA, 0
                                                  2154:  # g64:    .ascii  "\006zclear"
                                                  2155:  #         .word   0,0,0,0
                                                  2156:  
                                                  2157:  
                                                  2158:          
                                                  2159:  
                                                  2160:   ##### open and read source file #####
                                                  2161:  
                                                  2162:   # OPEN ( file-buffer file-name-ptr -- bytes-read, 0 if error )
                                                  2163:  
                                                  2164:  OPEN:   .word   OPEN+4
9D009B64  8E040000   LW A0, 0(S0)                 2165:          lw      $a0, 0(DP)
9D009B68  00002821   ADDU A1, ZERO, ZERO          2166:          move    $a1, $zero
9D009B6C  0F40336B   JAL 0x9D00CDAC               2167:          jal     open
9D009B70  00000000   NOP                          2168:          nop
9D009B74  3C049D00   LUI A0, -25344               2169:          la      $a0, msg5
9D009B78  248475D3   ADDIU A0, A0, 30163
9D009B7C  2401FFFF   ADDIU AT, ZERO, -1           2170:          bne     $v0, -1, OPEN1
9D009B80  14410006   BNE V0, AT, 0x9D009B9C
9D009B84  00000000   NOP                          2171:          nop
9D009B88  0F403211   JAL 0x9D00C844               2172:          jal     printf
9D009B8C  00000000   NOP                          2173:          nop
9D009B90  AE000004   SW ZERO, 4(S0)               2174:          sw      $zero, 4(DP)
9D009B94  0B402469   J 0x9D0091A4                 2175:          j       $next
9D009B98  26100004   ADDIU S0, S0, 4              2176:          addiu   DP, DP, 4
9D009B9C  00402021   ADDU A0, V0, ZERO            2177:  OPEN1:  move    $a0, $2
9D009BA0  8E050004   LW A1, 4(S0)                 2178:          lw      $a1, 4(DP)
9D009BA4  2406FFFF   ADDIU A2, ZERO, -1           2179:          li      $a2, -1
9D009BA8  0F402A32   JAL 0x9D00A8C8               2180:          jal     read
9D009BAC  00000000   NOP                          2181:          nop
9D009BB0  26100004   ADDIU S0, S0, 4              2182:          addiu   DP, DP, 4
9D009BB4  0B402469   J 0x9D0091A4                 2183:          j       $next
9D009BB8  AE020000   SW V0, 0(S0)                 2184:          sw      $v0, 0(DP)
                                                  2185:  
                                                  2186:          .end eForth
                                                  2187:  
                                                  2188:  ######### high level words #############
                                                  2189:  
                                                  2190:      .section  .rodata   # put all high level words in data space
                                                  2191:  
                                                  2192:  
                                                  2193:  ######### user variables ###############
                                                  2194:  
                                                  2195:  UP:     .word   docon
                                                  2196:  .word   UPP
                                                  2197:  
                                                  2198:  SZERO:  .word   douse
                                                  2199:  .word   16
                                                  2200:  
                                                  2201:  RZERO:  .word   douse
                                                  2202:  .word   20
                                                  2203:  
                                                  2204:  TQKEY:  .word   douse
                                                  2205:  .word   24
                                                  2206:  
                                                  2207:  TEMIT:  .word   douse
                                                  2208:  .word   28
                                                  2209:  
                                                  2210:  TEXPE:  .word   douse
                                                  2211:  .word   32
                                                  2212:  
                                                  2213:  TTAP:   .word   douse
                                                  2214:  .word   36
                                                  2215:  
                                                  2216:  TECHO:  .word   douse
                                                  2217:  .word   40
                                                  2218:  
                                                  2219:  TPROM:  .word   douse
                                                  2220:  .word   44
                                                  2221:  
                                                  2222:  BASE:   .word   douse
                                                  2223:  .word   48
                                                  2224:  
                                                  2225:  TEMP:   .word   douse
                                                  2226:  .word   52
                                                  2227:  
                                                  2228:  SPAN:   .word   douse
                                                  2229:  .word   56
                                                  2230:  
                                                  2231:  INN:    .word   douse
                                                  2232:  .word   60
                                                  2233:  
                                                  2234:  NTIB:   .word   douse
                                                  2235:  .word   64
                                                  2236:  
                                                  2237:  CSP:    .word   douse
                                                  2238:  .word   72
                                                  2239:  
                                                  2240:  TEVAL:  .word   douse
                                                  2241:  .word   76
                                                  2242:  
                                                  2243:  TNUMB:  .word   douse
                                                  2244:  .word   80
                                                  2245:  
                                                  2246:  HLD:    .word   douse
                                                  2247:  .word   84
                                                  2248:  
                                                  2249:  HANDL:  .word   douse
                                                  2250:  .word   88
                                                  2251:  
                                                  2252:  CNTXT:  .word   douse
                                                  2253:  .word   92
                                                  2254:  
                                                  2255:  CRRNT:  .word   douse
                                                  2256:  .word   128
                                                  2257:  
                                                  2258:  CP:     .word   douse
                                                  2259:  .word   136
                                                  2260:  
                                                  2261:  NP:     .word   douse
                                                  2262:  .word   140
                                                  2263:  
                                                  2264:  LAST:   .word   douse
                                                  2265:  .word   144
                                                  2266:  
                                                  2267:  
                                                  2268:   ##### vocabulary words #####
                                                  2269:  
                                                  2270:  
                                                  2271:  FORTH:  .word   dovoc
                                                  2272:          .word   LASTN
                                                  2273:          .word   0
                                                  2274:  
                                                  2275:  # GRAPH:  .word   dovoc
                                                  2276:  #         .word   g00
                                                  2277:  #         .word   FORTH+8
                                                  2278:  #
                                                  2279:  # FLTNG:  .word   dovoc
                                                  2280:  #         .word   f00
                                                  2281:  #         .word   GRAPH+8
                                                  2282:  
                                                  2283:  # APPLI:  .word   dovoc
                                                  2284:  #        .word   LASTN
                                                  2285:  #        .word   FLTNG+8
                                                  2286:  
                                                  2287:  ZERO:   .word   docon
                                                  2288:          .word   0
                                                  2289:  
                                                  2290:  ONE:    .word   docon
                                                  2291:          .word   1
                                                  2292:  
                                                  2293:  TWO:    .word   docon
                                                  2294:          .word   2
                                                  2295:  
                                                  2296:  THREE:  .word   docon
                                                  2297:          .word   3
                                                  2298:  
                                                  2299:  XXX:    .word   dovar
                                                  2300:          .word   0
                                                  2301:  
                                                  2302:  
                                                  2303:    ######  MISCELLANEOUS ######
                                                  2304:  
                                                  2305:  
                                                  2306:    # return true if u is within the range of ul and uh
                                                  2307:  WITHI:  .word   dolst
                                                  2308:  .word OVER,SUBB,TOR
                                                  2309:  .word SUBB,RFROM,ULESS,EXIT
                                                  2310:  
                                                  2311:  DNEGA:  .word   dolst
                                                  2312:  .word INVER,TOR,INVER
                                                  2313:  .word ONE,UPLUS
                                                  2314:  .word RFROM,PLUS,EXIT
                                                  2315:  
                                                  2316:  MSMOD:  .word   dolst
                                                  2317:          .word   DUPP,ZLESS,DUPP,TOR
                                                  2318:          .word   QBRAN,MMOD1
                                                  2319:          .word   NEGAT,TOR,DNEGA,RFROM
                                                  2320:  MMOD1:  .word   TOR,DUPP,ZLESS
                                                  2321:          .word   QBRAN,MMOD2
                                                  2322:          .word   RAT,PLUS
                                                  2323:  MMOD2:  .word   RFROM,UMMOD,RFROM
                                                  2324:          .word   QBRAN,MMOD3
                                                  2325:          .word   SWAP,NEGAT,SWAP
                                                  2326:  MMOD3:  .word   EXIT
                                                  2327:  
                                                  2328:     # return mod and quotient of n1 * n2 / n3
                                                  2329:  SSMOD:  .word   dolst
                                                  2330:  .word TOR,MSTAR,RFROM,MSMOD,EXIT
                                                  2331:  
                                                  2332:    # return quotient of n1 * n2 / n3
                                                  2333:  STASL:  .word   dolst
                                                  2334:  .word SSMOD,SWAP,DROP,EXIT
                                                  2335:  
                                                  2336:  BLANK:  .word   dolst
                                                  2337:  .word DOLIT,32,EXIT
                                                  2338:  
                                                  2339:  TCHAR:  .word   dolst
                                                  2340:  .word DOLIT,0x7F,ANDD,DUPP
                                                  2341:  .word BLANK,DOLIT,127,WITHI,INVER
                                                  2342:  .word QBRAN,TCHA1
                                                  2343:  .word DROP,DOLIT,95
                                                  2344:  TCHA1:
                                                  2345:  .word EXIT
                                                  2346:  
                                                  2347:  
                                                  2348:  DEPTH:  .word   dolst
                                                  2349:  
                                                  2350:  .word SPAT,SZERO,AT,SWAP,SUBB
                                                  2351:  .word DOLIT,CELLL,SLASH,EXIT
                                                  2352:  
                                                  2353:  PSTOR:  .word   dolst
                                                  2354:  
                                                  2355:  .word SWAP,OVER,AT,PLUS
                                                  2356:  .word SWAP,STORE,EXIT
                                                  2357:  
                                                  2358:  DSTOR:  .word   dolst
                                                  2359:  .word SWAP,OVER,STORE
                                                  2360:  .word CELLP,STORE,EXIT
                                                  2361:  
                                                  2362:  DAT:    .word   dolst
                                                  2363:  .word DUPP, CELLP, AT
                                                  2364:  .word SWAP, AT, EXIT
                                                  2365:  
                                                  2366:  COUNT:  .word   dolst
                                                  2367:  .word DUPP,ONE,PLUS
                                                  2368:  .word SWAP,CAT,EXIT
                                                  2369:  
                                                  2370:  HERE:   .word   dolst
                                                  2371:  .word CP,AT,EXIT
                                                  2372:  
                                                  2373:  PAD:    .word   dolst
                                                  2374:  .word HERE,DOLIT,80,PLUS,EXIT
                                                  2375:  
                                                  2376:  TIB:    .word   dolst
                                                  2377:  .word NTIB,CELLP,AT,EXIT
                                                  2378:  
                                                  2379:  ATEXE:  .word   dolst
                                                  2380:  .word AT,QDUP
                                                  2381:  .word QBRAN,EXE1
                                                  2382:  .word EXECU
                                                  2383:  EXE1:
                                                  2384:  .word EXIT
                                                  2385:  
                                                  2386:  
                                                  2387:   ##### string words #####
                                                  2388:  
                                                  2389:  
                                                  2390:  FILL:   .word   dolst
                                                  2391:  .word SWAP,TOR,SWAP
                                                  2392:  .word BRAN,FILL2
                                                  2393:  FILL1:
                                                  2394:  .word DDUP,CSTOR,ONE,PLUS
                                                  2395:  FILL2:
                                                  2396:  .word DONXT,FILL1
                                                  2397:  .word DDROP,EXIT
                                                  2398:  
                                                  2399:  DTRAI:  .word   dolst
                                                  2400:  .word TOR
                                                  2401:  .word BRAN,DTRA2
                                                  2402:  DTRA1:
                                                  2403:  .word BLANK,OVER,RAT,PLUS,CAT,LESS
                                                  2404:  .word QBRAN,DTRA2
                                                  2405:  .word RFROM,ONE,PLUS,EXIT
                                                  2406:  DTRA2:
                                                  2407:  .word DONXT,DTRA1
                                                  2408:  .word ZERO,EXIT
                                                  2409:  
                                                  2410:  PACKS:  .word   dolst
                                                  2411:  .word ALGND,DUPP,TOR
                                                  2412:  .word OVER,DUPP,ZERO
                                                  2413:  .word DOLIT,CELLL,UMMOD,DROP
                                                  2414:  .word SUBB,OVER,PLUS
                                                  2415:  .word ZERO,SWAP,STORE
                                                  2416:  .word DDUP,CSTOR,ONE,PLUS
                                                  2417:  .word SWAP,CMOVE,RFROM,EXIT
                                                  2418:  
                                                  2419:  
                                                  2420:   ##### number conversions #####
                                                  2421:  
                                                  2422:  
                                                  2423:  DIGIT:  .word   dolst
                                                  2424:  .word DOLIT,9,OVER,LESS
                                                  2425:  .word DOLIT,7,ANDD,PLUS
                                                  2426:  .word DOLIT,48,PLUS,EXIT
                                                  2427:  
                                                  2428:  EXTRC:  .word   dolst
                                                  2429:  .word ZERO,SWAP,UMMOD
                                                  2430:  .word SWAP,DIGIT,EXIT
                                                  2431:  
                                                  2432:  BDIGS:  .word   dolst
                                                  2433:  .word PAD,HLD,STORE,EXIT
                                                  2434:  
                                                  2435:  HOLD:   .word   dolst
                                                  2436:  .word HLD,AT,ONE,SUBB
                                                  2437:  .word DUPP,HLD,STORE,CSTOR,EXIT
                                                  2438:  
                                                  2439:  DIG:    .word   dolst
                                                  2440:  .word BASE,AT,EXTRC,HOLD,EXIT
                                                  2441:  
                                                  2442:  DIGS:   .word   dolst
                                                  2443:  DIGS1:
                                                  2444:  .word DIG,DUPP
                                                  2445:  .word QBRAN,DIGS2
                                                  2446:  .word BRAN,DIGS1
                                                  2447:  DIGS2:
                                                  2448:  .word EXIT
                                                  2449:  
                                                  2450:  SIGN:   .word   dolst
                                                  2451:  .word ZLESS
                                                  2452:  .word QBRAN,SIGN1
                                                  2453:  .word DOLIT,45,HOLD
                                                  2454:  SIGN1:
                                                  2455:  .word EXIT
                                                  2456:  
                                                  2457:  EDIGS:  .word   dolst
                                                  2458:  .word DROP,HLD,AT
                                                  2459:  .word PAD,OVER,SUBB,EXIT
                                                  2460:  
                                                  2461:  STRR:   .word   dolst
                                                  2462:  .word DUPP,TOR,ABSS
                                                  2463:  .word BDIGS,DIGS,RFROM
                                                  2464:  .word SIGN,EDIGS,EXIT
                                                  2465:  
                                                  2466:  HEX:    .word   dolst
                                                  2467:  .word DOLIT,16,BASE,STORE,EXIT
                                                  2468:  
                                                  2469:  DECIM:  .word   dolst
                                                  2470:  .word DOLIT,10,BASE,STORE,EXIT
                                                  2471:  
                                                  2472:  DIGTQ:  .word   dolst
                                                  2473:  .word TOR,DOLIT,48,SUBB
                                                  2474:  .word DOLIT,9,OVER,LESS
                                                  2475:  .word QBRAN,DGTQ1
                                                  2476:  .word DOLIT,7,SUBB
                                                  2477:  .word DUPP,DOLIT,10,LESS,ORR
                                                  2478:  DGTQ1:
                                                  2479:  .word DUPP,RFROM,ULESS,EXIT
                                                  2480:  
                                                  2481:  NUMBQ:  .word   dolst
                                                  2482:  .word BASE,AT,TOR,ZERO,OVER,COUNT
                                                  2483:  .word OVER,CAT,DOLIT,36,EQUAL
                                                  2484:  .word QBRAN,NUMQ1
                                                  2485:  .word HEX,SWAP,ONE,PLUS
                                                  2486:  .word SWAP,ONE,SUBB
                                                  2487:  NUMQ1:
                                                  2488:  .word OVER,CAT,DOLIT,45,EQUAL,TOR
                                                  2489:  .word SWAP,RAT,SUBB,SWAP,RAT,PLUS,QDUP
                                                  2490:  .word QBRAN,NUMQ6
                                                  2491:  .word ONE,SUBB,TOR
                                                  2492:  NUMQ2:
                                                  2493:  .word DUPP,TOR,CAT,BASE,AT,DIGTQ
                                                  2494:  .word QBRAN,NUMQ4
                                                  2495:  .word SWAP,BASE,AT,STAR,PLUS,RFROM
                                                  2496:  .word ONE,PLUS
                                                  2497:  .word DONXT,NUMQ2
                                                  2498:  .word RAT,SWAP,DROP
                                                  2499:  .word QBRAN,NUMQ3
                                                  2500:  .word NEGAT
                                                  2501:  NUMQ3:
                                                  2502:  .word SWAP
                                                  2503:  .word BRAN,NUMQ5
                                                  2504:  NUMQ4:
                                                  2505:  .word RFROM,RFROM,DDROP,DDROP,ZERO
                                                  2506:  NUMQ5:
                                                  2507:  .word DUPP
                                                  2508:  NUMQ6:
                                                  2509:  .word RFROM,DDROP
                                                  2510:  .word RFROM,BASE,STORE,EXIT
                                                  2511:  
                                                  2512:  
                                                  2513:   ##### input output words #####
                                                  2514:  
                                                  2515:  
                                                  2516:  QKEY:   .word   dolst
                                                  2517:  .word   TQKEY, ATEXE, EXIT
                                                  2518:  
                                                  2519:  KEY:    .word   dolst
                                                  2520:  KEY1:
                                                  2521:  .word   QKEY, QBRAN, KEY1, EXIT
                                                  2522:  
                                                  2523:  EMIT:   .word   dolst
                                                  2524:  .word   TEMIT, ATEXE, EXIT
                                                  2525:  
                                                  2526:  NUFQ:   .word   dolst
                                                  2527:  .word   QKEY, DUPP, QBRAN, NUFQ1
                                                  2528:  .word   DDROP, KEY, DOLIT, LF, EQUAL
                                                  2529:  NUFQ1:
                                                  2530:  .word   EXIT
                                                  2531:  
                                                  2532:  PACE:   .word   dolst
                                                  2533:  .word   DOLIT, 11, EMIT, EXIT
                                                  2534:  
                                                  2535:  SPACE:  .word   dolst
                                                  2536:  .word   BLANK, EMIT, EXIT
                                                  2537:  
                                                  2538:  SPACS:  .word   dolst
                                                  2539:  .word   DOLIT, 0, MAX, TOR
                                                  2540:  .word   BRAN, CHAR2
                                                  2541:  CHAR1:
                                                  2542:  .word   SPACE
                                                  2543:  CHAR2:
                                                  2544:  .word   DONXT, CHAR1, EXIT
                                                  2545:  
                                                  2546:  TYPEE:  .word   dolst
                                                  2547:  .word   TOR, BRAN, TYPE2
                                                  2548:  TYPE1:
                                                  2549:  .word   DUPP, CAT, EMIT, DOLIT, 1, PLUS
                                                  2550:  TYPE2:
                                                  2551:  .word   DONXT, TYPE1, DROP, EXIT
                                                  2552:  
                                                  2553:  CR:     .word   dolst
                                                  2554:   #      .word   DOLIT, CRR, EMIT
                                                  2555:  .word   DOLIT, LF, EMIT, EXIT
                                                  2556:  
                                                  2557:  
                                                  2558:  DOSTR:  .word   dolst
                                                  2559:  .word RFROM,RAT,RFROM,COUNT,PLUS
                                                  2560:  .word ALGND,TOR,SWAP,TOR,EXIT
                                                  2561:  
                                                  2562:  STRQP:  .word   dolst
                                                  2563:  .word DOSTR,EXIT
                                                  2564:  
                                                  2565:  DOTQP:  .word   dolst
                                                  2566:  .word DOSTR,COUNT,TYPEE,EXIT
                                                  2567:  
                                                  2568:  DOTR:   .word   dolst
                                                  2569:  .word TOR,STRR,RFROM,OVER,SUBB
                                                  2570:  .word SPACS,TYPEE,EXIT
                                                  2571:  
                                                  2572:  UDOTR:  .word   dolst
                                                  2573:  .word TOR,BDIGS,DIGS,EDIGS
                                                  2574:  .word RFROM,OVER,SUBB
                                                  2575:  .word SPACS,TYPEE,EXIT
                                                  2576:  
                                                  2577:  UDOT:   .word   dolst
                                                  2578:  .word BDIGS,DIGS,EDIGS
                                                  2579:  .word SPACE,TYPEE,EXIT
                                                  2580:  
                                                  2581:  DOT:    .word   dolst
                                                  2582:  .word BASE,AT,DOLIT,10,XORR
                                                  2583:  .word QBRAN,DOT1
                                                  2584:  .word UDOT,EXIT
                                                  2585:  DOT1:
                                                  2586:  .word STRR,SPACE,TYPEE,EXIT
                                                  2587:  
                                                  2588:  QUEST:  .word   dolst
                                                  2589:  .word AT,DOT,EXIT
                                                  2590:  
                                                  2591:  
                                                  2592:   ##### text interpreter #####
                                                  2593:  
                                                  2594:  
                                                  2595:  PARS:   .word   dolst
                                                  2596:  .word TEMP,STORE,OVER,TOR,DUPP
                                                  2597:  .word QBRAN,PARS8
                                                  2598:  .word ONE,SUBB,TEMP,AT,BLANK,EQUAL
                                                  2599:  .word QBRAN,PARS3
                                                  2600:  .word TOR
                                                  2601:  PARS1:
                                                  2602:  .word BLANK,OVER,CAT
                                                  2603:  .word SUBB,ZLESS,INVER
                                                  2604:  .word QBRAN,PARS2
                                                  2605:  .word ONE,PLUS
                                                  2606:  .word DONXT,PARS1
                                                  2607:  .word RFROM,DROP,ZERO,DUPP,EXIT
                                                  2608:  PARS2:
                                                  2609:  .word RFROM
                                                  2610:  PARS3:
                                                  2611:  .word OVER,SWAP
                                                  2612:  .word TOR
                                                  2613:  PARS4:
                                                  2614:  .word TEMP,AT,OVER,CAT,SUBB
                                                  2615:  .word TEMP,AT,BLANK,EQUAL
                                                  2616:  .word QBRAN,PARS5
                                                  2617:  .word ZLESS
                                                  2618:  PARS5:
                                                  2619:  .word QBRAN,PARS6
                                                  2620:  .word ONE,PLUS
                                                  2621:  .word DONXT,PARS4
                                                  2622:  .word DUPP,TOR
                                                  2623:  .word BRAN,PARS7
                                                  2624:  PARS6:
                                                  2625:  .word RFROM,DROP,DUPP
                                                  2626:  .word ONE,PLUS,TOR
                                                  2627:  PARS7:
                                                  2628:  .word OVER,SUBB
                                                  2629:  .word RFROM,RFROM,SUBB,EXIT
                                                  2630:  PARS8:
                                                  2631:  .word OVER,RFROM,SUBB,EXIT
                                                  2632:  
                                                  2633:  PARSE:  .word   dolst
                                                  2634:  .word TOR,TIB,INN,AT,PLUS
                                                  2635:  .word NTIB,AT,INN,AT,SUBB
                                                  2636:  .word RFROM,PARS,INN,PSTOR,EXIT
                                                  2637:  
                                                  2638:  DOTPR:  .word   dolst
                                                  2639:  .word DOLIT,41,PARSE,TYPEE,EXIT
                                                  2640:  
                                                  2641:  PAREN:  .word   dolst
                                                  2642:  .word DOLIT,41,PARSE,DDROP,EXIT
                                                  2643:  
                                                  2644:  BKSLA:  .word   dolst
                                                  2645:  .word NTIB,AT,INN,STORE,EXIT
                                                  2646:  
                                                  2647:  CHAR:   .word   dolst
                                                  2648:  .word BLANK, PARSE, DROP, CAT, EXIT
                                                  2649:  
                                                  2650:  TOKEN:  .word   dolst
                                                  2651:  .word BLANK,PARSE,DOLIT,31,MIN
                                                  2652:  .word NP,AT,OVER,SUBB,CELLM
                                                  2653:  .word PACKS,EXIT
                                                  2654:  
                                                  2655:  WORDD:  .word   dolst
                                                  2656:  .word PARSE,HERE,PACKS,EXIT
                                                  2657:  
                                                  2658:  NAMET:  .word   dolst
                                                  2659:  .word CELLM
                                                  2660:  .word CELLM,AT,EXIT
                                                  2661:  
                                                  2662:  SAMEQ:  .word   dolst
                                                  2663:  .word TOR
                                                  2664:  .word BRAN,SAME2
                                                  2665:  SAME1:
                                                  2666:  .word OVER,RAT,CELLS,PLUS,AT
                                                  2667:  .word OVER,RAT,CELLS,PLUS,AT
                                                  2668:  .word SUBB,QDUP
                                                  2669:  .word QBRAN,SAME2
                                                  2670:  .word RFROM,DROP,EXIT
                                                  2671:  SAME2:
                                                  2672:  .word DONXT,SAME1
                                                  2673:  .word ZERO,EXIT
                                                  2674:  
                                                  2675:  FIND:   .word   dolst  # (a va -- ca na | a F) \ search word in dictionary 'a' is target address, 'va' dict. head address
                                                  2676:  .word SWAP,DUPP,CAT
                                                  2677:  .word DOLIT,CELLL,SLASH,TEMP,STORE
                                                  2678:  .word DUPP,AT,TOR,CELLP,SWAP
                                                  2679:  FIND1:
                                                  2680:  .word AT,DUPP
                                                  2681:  .word QBRAN,FIND6
                                                  2682:  .word DUPP,AT,DOLIT,MASKK,ANDD,RAT,XORR
                                                  2683:  .word QBRAN,FIND2
                                                  2684:  .word CELLM
                                                  2685:  .word BRAN,FIND1
                                                  2686:  FIND2:
                                                  2687:  .word CELLP,TEMP,AT,SAMEQ
                                                  2688:  FIND3:
                                                  2689:  .word BRAN,FIND4
                                                  2690:  FIND6:
                                                  2691:  .word RFROM,DROP
                                                  2692:  .word SWAP,CELLM,SWAP,EXIT
                                                  2693:  FIND4:
                                                  2694:  .word QBRAN,FIND5
                                                  2695:  .word CELLM,CELLM
                                                  2696:  .word BRAN,FIND1
                                                  2697:  FIND5:
                                                  2698:  .word RFROM,DROP,SWAP,DROP
                                                  2699:  .word CELLM
                                                  2700:  .word DUPP,NAMET,SWAP,EXIT
                                                  2701:  
                                                  2702:  NAMEQ:  .word   dolst
                                                  2703:  .word CNTXT,DUPP,DAT,XORR
                                                  2704:  .word QBRAN,NAMQ1
                                                  2705:  .word CELLM
                                                  2706:  NAMQ1:
                                                  2707:  .word TOR
                                                  2708:  NAMQ2:
                                                  2709:  .word RFROM,CELLP,DUPP,TOR
                                                  2710:  .word AT,QDUP
                                                  2711:  .word QBRAN,NAMQ3
                                                  2712:  .word FIND,QDUP
                                                  2713:  .word QBRAN,NAMQ2
                                                  2714:  .word RFROM,DROP,EXIT
                                                  2715:  NAMQ3:
                                                  2716:  .word RFROM,DROP
                                                  2717:  .word ZERO,EXIT
                                                  2718:  
                                                  2719:  BKSP:   .word   dolst
                                                  2720:  .word TOR,OVER,RFROM,SWAP,OVER,XORR
                                                  2721:  .word QBRAN,BACK1
                                                  2722:  .word DOLIT,BKSPP,TECHO,ATEXE,ONE,SUBB
                                                  2723:  .word BLANK,TECHO,ATEXE
                                                  2724:  .word DOLIT,BKSPP,TECHO,ATEXE
                                                  2725:  BACK1:
                                                  2726:  .word EXIT
                                                  2727:  
                                                  2728:  TAP:    .word   dolst
                                                  2729:  .word DUPP,TECHO,ATEXE
                                                  2730:  .word OVER,CSTOR,ONE,PLUS,EXIT
                                                  2731:  
                                                  2732:  KTAP:   .word   dolst
                                                  2733:  .word DUPP,DOLIT,CRR,XORR
                                                  2734:  .word QBRAN,KTAP2
                                                  2735:  .word DOLIT,BKSPP,XORR
                                                  2736:  .word QBRAN,KTAP1
                                                  2737:  .word BLANK,TAP,EXIT
                                                  2738:  KTAP1:
                                                  2739:  .word BKSP,EXIT
                                                  2740:  KTAP2:
                                                  2741:  .word DROP,SWAP,DROP,DUPP,EXIT
                                                  2742:  
                                                  2743:  ACCEP:  .word   dolst
                                                  2744:  .word OVER,PLUS,OVER
                                                  2745:  ACCP1:
                                                  2746:  .word DDUP,XORR
                                                  2747:  .word QBRAN,ACCP4
                                                  2748:  .word KEY,DUPP
                                                  2749:  .word BLANK,DOLIT,127,WITHI
                                                  2750:  .word QBRAN,ACCP2
                                                  2751:  .word TAP
                                                  2752:  .word BRAN,ACCP3
                                                  2753:  ACCP2:
                                                  2754:  .word TTAP,ATEXE
                                                  2755:  ACCP3:
                                                  2756:  .word BRAN,ACCP1
                                                  2757:  ACCP4:
                                                  2758:  .word DROP,OVER,SUBB,EXIT
                                                  2759:  
                                                  2760:  EXPEC:  .word   dolst
                                                  2761:  .word TEXPE,ATEXE,SPAN,STORE,DROP,EXIT
                                                  2762:  
                                                  2763:  QUERY:  .word   dolst
                                                  2764:  .word TIB,DOLIT,80, TEXPE,ATEXE,NTIB,STORE
                                                  2765:  .word DROP,ZERO,INN,STORE, EXIT
                                                  2766:  
                                                  2767:  
                                                  2768:   ##### error checking words #####
                                                  2769:  
                                                  2770:  
                                                  2771:  CATCH:  .word   dolst
                                                  2772:  .word SPAT,TOR,HANDL,AT,TOR
                                                  2773:  .word RPAT,HANDL,STORE,EXECU
                                                  2774:  .word RFROM,HANDL,STORE
                                                  2775:  .word RFROM,DROP,ZERO,EXIT
                                                  2776:  
                                                  2777:  THROW:  .word   dolst
                                                  2778:  .word HANDL,AT,RPSTO
                                                  2779:  .word RFROM,HANDL,STORE
                                                  2780:  .word RFROM,SWAP,TOR,SPSTO
                                                  2781:  .word DROP,RFROM,EXIT
                                                  2782:  
                                                  2783:  NULLS:  .word   dovar
                                                  2784:  .word 0
                                                  2785:  .byte 99,111,121,111,116,101  
                                                  2786:    # $align
                                                  2787:  
                                                  2788:  ABORT:  .word   dolst
                                                  2789:  .word NULLS,THROW
                                                  2790:  
                                                  2791:  ABORQ:  .word   dolst
                                                  2792:  .word QBRAN,ABOR1
                                                  2793:  .word DOSTR,THROW
                                                  2794:  ABOR1:
                                                  2795:  .word DOSTR,DROP,EXIT
                                                  2796:  
                                                  2797:  
                                                  2798:     ###### text interpreter #####
                                                  2799:  
                                                  2800:  
                                                  2801:  INTER:  .word   dolst
                                                  2802:  .word NAMEQ,QDUP
                                                  2803:  .word QBRAN,INTE1
                                                  2804:  .word AT,DOLIT,0x40000000       #COMP
                                                  2805:  .word ANDD
                                                  2806:  .word ABORQ
                                                  2807:  .ascii "\X0d COMPILE ONLY"   
                                                  2808:  .word EXECU,EXIT
                                                  2809:  INTE1:
                                                  2810:  .word TNUMB,ATEXE
                                                  2811:  .word QBRAN,INTE2
                                                  2812:  .word EXIT
                                                  2813:  INTE2:
                                                  2814:  .word THROW
                                                  2815:  
                                                  2816:  LBRAC:  .word   dolst
                                                  2817:  .word DOLIT,INTER,TEVAL,STORE,EXIT
                                                  2818:  
                                                  2819:  DOTOK:  .word   dolst
                                                  2820:  .word DOLIT,INTER,TEVAL,AT,EQUAL
                                                  2821:  .word QBRAN,DOTO1
                                                  2822:  .word DOTQP
                                                  2823:  .ascii "\X03 ok"
                                                  2824:  DOTO1:
                                                  2825:  .word CR,EXIT
                                                  2826:  
                                                  2827:  QSTAC:  .word   dolst
                                                  2828:  .word DEPTH,ZLESS
                                                  2829:  .word ABORQ
                                                  2830:  .ascii "\X0a underflow"
                                                  2831:  .word EXIT
                                                  2832:  
                                                  2833:  EVAL:   .word   dolst
                                                  2834:  EVAL1:
                                                  2835:  .word TOKEN,DUPP,CAT
                                                  2836:  .word QBRAN,EVAL2
                                                  2837:  .word TEVAL,ATEXE,QSTAC
                                                  2838:  .word BRAN,EVAL1   
                                                  2839:  EVAL2:
                                                  2840:  .word DROP,TPROM,ATEXE,EXIT
                                                  2841:  
                                                  2842:  PRESE:  .word   dolst
                                                  2843:  .word SZERO,AT,SPSTO
                                                  2844:  .word DOLIT,TIBB,NTIB,CELLP,STORE,EXIT
                                                  2845:  
                                                  2846:  XIO:    .word   dolst
                                                  2847:  .word DOLIT,ACCEP,TEXPE,DSTOR
                                                  2848:  .word TECHO,DSTOR,EXIT
                                                  2849:  
                                                  2850:  FILE:   .word   dolst
                                                  2851:  .word DOLIT,PACE,DOLIT,DROP
                                                  2852:  .word DOLIT,KTAP,XIO,EXIT
                                                  2853:  
                                                  2854:  HAND:   .word   dolst
                                                  2855:  .word DOLIT,DOTOK,DOLIT,EMIT
                                                  2856:  .word DOLIT,KTAP,XIO,EXIT
                                                  2857:  
                                                  2858:  ISLO:   .word   dovar
                                                  2859:  .word QRX,TXSTO
                                                  2860:  
                                                  2861:  CONSO:  .word   dolst
                                                  2862:  .word ISLO,DAT,TQKEY,DSTOR
                                                  2863:  .word HAND,EXIT
                                                  2864:  
                                                  2865:  QUIT:   .word   dolst
                                                  2866:  .word RZERO,AT,RPSTO
                                                  2867:  QUIT1:
                                                  2868:  .word LBRAC
                                                  2869:  QUIT2:
                                                  2870:  .word QUERY
                                                  2871:  .word DOLIT,EVAL,CATCH,QDUP
                                                  2872:  .word QBRAN,QUIT2
                                                  2873:  .word TPROM,AT,SWAP
                                                  2874:  .word CONSO,NULLS,OVER,XORR
                                                  2875:  .word QBRAN,QUIT3
                                                  2876:  .word SPACE,COUNT,TYPEE
                                                  2877:  .word DOTQP
                                                  2878:  .ascii "\X02 ?"
                                                  2879:  QUIT3:
                                                  2880:  .word DOLIT,DOTOK,XORR
                                                  2881:  .word QBRAN,QUIT4
                                                  2882:  .word DOLIT,ERR,EMIT
                                                  2883:  QUIT4:
                                                  2884:  .word PRESE
                                                  2885:  .word BRAN,QUIT1
                                                  2886:  
                                                  2887:  TICK:   .word   dolst
                                                  2888:  .word TOKEN,NAMEQ
                                                  2889:  .word QBRAN,TICK1
                                                  2890:  .word EXIT
                                                  2891:  TICK1:
                                                  2892:  .word THROW
                                                  2893:  
                                                  2894:  
                                                  2895:   ##### compiler words #####
                                                  2896:  
                                                  2897:  
                                                  2898:  ALLOT:  .word   dolst
                                                  2899:  .word CP,PSTOR,EXIT
                                                  2900:  
                                                  2901:  COMMA:  .word   dolst
                                                  2902:  .word HERE,DUPP,CELLP
                                                  2903:  .word CP,STORE,STORE,EXIT
                                                  2904:  
                                                  2905:  BCOMP:  .word   dolst
                                                  2906:  .word TICK,COMMA,EXIT
                                                  2907:  
                                                  2908:  COMPI:  .word   dolst
                                                  2909:  .word   RFROM, DUPP, AT, COMMA
                                                  2910:  .word   CELLP, TOR, EXIT
                                                  2911:  
                                                  2912:  LITER:  .word   dolst
                                                  2913:  .word   COMPI, DOLIT, COMMA, EXIT
                                                  2914:  
                                                  2915:  STRCQ:  .word   dolst
                                                  2916:  .word DOLIT,34,WORDD
                                                  2917:  .word COUNT,PLUS,ALGND
                                                  2918:  .word CP,STORE,EXIT
                                                  2919:  
                                                  2920:  RECUR:  .word   dolst
                                                  2921:  .word LAST,AT,NAMET,COMMA,EXIT
                                                  2922:  
                                                  2923:  FOR:    .word   dolst
                                                  2924:  .word COMPI,TOR,HERE,EXIT
                                                  2925:  
                                                  2926:  BEGIN:  .word   dolst
                                                  2927:  .word HERE,EXIT
                                                  2928:  
                                                  2929:  NEXT:   .word   dolst
                                                  2930:  .word COMPI,DONXT,COMMA,EXIT
                                                  2931:  
                                                  2932:  UNTIL:  .word   dolst
                                                  2933:  .word COMPI,QBRAN,COMMA,EXIT
                                                  2934:  
                                                  2935:  AGAIN:  .word   dolst
                                                  2936:  .word COMPI,BRAN,COMMA,EXIT
                                                  2937:  
                                                  2938:  IFF:    .word   dolst
                                                  2939:  .word COMPI,QBRAN,HERE
                                                  2940:  .word ZERO,COMMA,EXIT
                                                  2941:  
                                                  2942:  AHEAD:  .word   dolst
                                                  2943:  .word COMPI,BRAN,HERE,ZERO,COMMA,EXIT
                                                  2944:  
                                                  2945:  REPEA:  .word   dolst
                                                  2946:  .word AGAIN, HERE, SWAP, STORE, EXIT
                                                  2947:  
                                                  2948:  THENN:  .word   dolst
                                                  2949:  .word HERE,SWAP,STORE,EXIT
                                                  2950:  
                                                  2951:  AFT:    .word   dolst
                                                  2952:  .word DROP,AHEAD,BEGIN,SWAP,EXIT
                                                  2953:  
                                                  2954:  ELSEE:  .word   dolst
                                                  2955:  .word AHEAD,SWAP,THENN,EXIT
                                                  2956:  
                                                  2957:  WHILE:  .word   dolst
                                                  2958:  .word IFF,SWAP,EXIT
                                                  2959:  
                                                  2960:  ABRTQ:  .word   dolst
                                                  2961:  .word COMPI,ABORQ,STRCQ,EXIT
                                                  2962:  
                                                  2963:  STRQ:   .word   dolst
                                                  2964:  .word COMPI,STRQP,STRCQ,EXIT
                                                  2965:  
                                                  2966:  DOTQ:   .word   dolst
                                                  2967:  .word COMPI,DOTQP,STRCQ,EXIT
                                                  2968:  
                                                  2969:  UNIQU:  .word   dolst
                                                  2970:  .word DUPP,NAMEQ
                                                  2971:  .word QBRAN,UNIQ1
                                                  2972:  .word DOTQP
                                                  2973:  .ascii "\X07 reDef "  # "D$"
                                                  2974:  .word OVER,COUNT,TYPEE
                                                  2975:  UNIQ1:
                                                  2976:  .word DROP,EXIT
                                                  2977:  
                                                  2978:  SNAME:  .word   dolst
                                                  2979:  .word DUPP,CAT
                                                  2980:  .word QBRAN,PNAM1
                                                  2981:  .word UNIQU
                                                  2982:  .word DUPP,LAST,STORE
                                                  2983:  .word HERE,ALGND,SWAP
                                                  2984:  .word CELLM
                                                  2985:  .word CRRNT,AT,AT,OVER,STORE
                                                  2986:  .word CELLM,DUPP,NP,STORE
                                                  2987:  .word STORE,EXIT
                                                  2988:  PNAM1:
                                                  2989:  .word STRQP
                                                  2990:  .ascii "\X05 name"   # "D$"
                                                  2991:  .word THROW
                                                  2992:  
                                                  2993:  SCOMP:  .word   dolst
                                                  2994:  .word NAMEQ,QDUP
                                                  2995:  .word QBRAN,SCOM2
                                                  2996:  .word AT,DOLIT,0x80000000,ANDD
                                                  2997:  .word QBRAN,SCOM1
                                                  2998:  .word EXECU,EXIT
                                                  2999:  SCOM1:
                                                  3000:  .word COMMA,EXIT
                                                  3001:  SCOM2:
                                                  3002:  .word TNUMB,ATEXE
                                                  3003:  .word QBRAN,SCOM3
                                                  3004:  .word LITER,EXIT
                                                  3005:  SCOM3:
                                                  3006:  .word THROW
                                                  3007:  
                                                  3008:  OVERT:  .word   dolst
                                                  3009:  .word LAST,AT,CRRNT,STORE,EXIT
                                                  3010:  
                                                  3011:  SEMIS:  .word   dolst
                                                  3012:  .word COMPI,EXIT,LBRAC,OVERT,EXIT
                                                  3013:  
                                                  3014:  RBRAC:  .word   dolst
                                                  3015:  .word DOLIT,SCOMP,TEVAL,STORE,EXIT
                                                  3016:  
                                                  3017:  CALLC:  .word   dolst
                                                  3018:  .word DOLIT,CALLC,AT
                                                  3019:  .word COMMA
                                                  3020:  .word EXIT
                                                  3021:  
                                                  3022:  COLON:  .word   dolst
                                                  3023:  .word TOKEN,SNAME,DOLIT,dolst
                                                  3024:  .word COMMA,RBRAC,EXIT
                                                  3025:  
                                                  3026:  IMMED:  .word   dolst
                                                  3027:  .word DOLIT,0x80000000,LAST,AT,AT,ORR
                                                  3028:  .word LAST,AT,STORE,EXIT
                                                  3029:  
                                                  3030:  USER:   .word   dolst
                                                  3031:  .word TOKEN,SNAME,OVERT
                                                  3032:  .word DOLIT,douse,COMMA,COMMA,EXIT
                                                  3033:  
                                                  3034:  CREAT:  .word   dolst
                                                  3035:  .word TOKEN,SNAME,OVERT
                                                  3036:  .word DOLIT,dovar,COMMA
                                                  3037:  .word EXIT
                                                  3038:  
                                                  3039:  VARIA:  .word   dolst
                                                  3040:  .word CREAT,ZERO,COMMA,EXIT
                                                  3041:  
                                                  3042:  CONST:  .word   dolst
                                                  3043:  .word TOKEN,SNAME,OVERT
                                                  3044:  .word DOLIT,docon,COMMA,COMMA,EXIT
                                                  3045:  
                                                  3046:  
                                                  3047:   ##### utility words #####
                                                  3048:  
                                                  3049:  
                                                  3050:  UTYPE:  .word   dolst
                                                  3051:  .word TOR
                                                  3052:  .word BRAN,UTYP2
                                                  3053:  UTYP1:
                                                  3054:  .word DUPP,CAT,TCHAR,EMIT
                                                  3055:  .word ONE,PLUS
                                                  3056:  UTYP2:
                                                  3057:  .word DONXT,UTYP1
                                                  3058:  .word DROP,EXIT
                                                  3059:  
                                                  3060:  DMP:    .word   dolst
                                                  3061:  .word OVER,DOLIT,4,UDOTR,SPACE,TOR
                                                  3062:  .word BRAN,PDUM2
                                                  3063:  PDUM1:
                                                  3064:  .word DUPP,CAT,DOLIT,3,UDOTR
                                                  3065:  .word ONE,PLUS
                                                  3066:  PDUM2:
                                                  3067:  .word DONXT,PDUM1
                                                  3068:  .word EXIT
                                                  3069:  
                                                  3070:  DUMP:   .word   dolst
                                                  3071:  .word BASE,AT,TOR,HEX
                                                  3072:  .word DOLIT,16,SLASH
                                                  3073:  .word TOR
                                                  3074:  DUMP1:
                                                  3075:  .word CR,DOLIT,16,DDUP,DMP
                                                  3076:  .word ROT,ROT
                                                  3077:  .word SPACE,SPACE,UTYPE
                                                  3078:   #      .word NUFQ
                                                  3079:   #      .word INVER
                                                  3080:   #      .word QBRAN,DUMP2
                                                  3081:  .word DONXT,DUMP1
                                                  3082:   #      .word BRAN,DUMP3
                                                  3083:   #      DUMP2:
                                                  3084:   #      .word RFROM,DROP
                                                  3085:  DUMP3:
                                                  3086:  .word DROP,RFROM,BASE,STORE
                                                  3087:  .word EXIT
                                                  3088:  
                                                  3089:  DOTS:   .word   dolst
                                                  3090:  .word CR,DEPTH
                                                  3091:  .word TOR
                                                  3092:  .word BRAN,DOTS2
                                                  3093:  DOTS1:
                                                  3094:  .word RAT,PICK,DOT
                                                  3095:  DOTS2:
                                                  3096:  .word DONXT,DOTS1
                                                  3097:  .word DOTQP
                                                  3098:  .ascii "\X04 <sp"  # D$
                                                  3099:  .word EXIT
                                                  3100:  
                                                  3101:  STCSP:  .word   dolst
                                                  3102:  .word SPAT,CSP,STORE,EXIT
                                                  3103:  
                                                  3104:  QCSP:   .word   dolst
                                                  3105:  .word SPAT,CSP,AT, XORR, ABORQ
                                                  3106:  .ascii  "\X07 stacks"
                                                  3107:  .word   EXIT
                                                  3108:  
                                                  3109:  TNAME:  .word   dolst
                                                  3110:  .word CRRNT
                                                  3111:  TNAM1:
                                                  3112:  .word CELLP,AT,QDUP
                                                  3113:  .word QBRAN,TNAM4
                                                  3114:  .word DDUP
                                                  3115:  TNAM2:
                                                  3116:  .word AT,DUPP
                                                  3117:  .word QBRAN,TNAM3
                                                  3118:  .word DDUP,NAMET,XORR
                                                  3119:  .word QBRAN,TNAM3
                                                  3120:  .word CELLM
                                                  3121:  .word BRAN,TNAM2
                                                  3122:  TNAM3:
                                                  3123:  .word SWAP,DROP,QDUP
                                                  3124:  .word QBRAN,TNAM1
                                                  3125:  .word SWAP,DROP,SWAP,DROP,EXIT
                                                  3126:  TNAM4:
                                                  3127:  .word DROP,ZERO,EXIT
                                                  3128:  
                                                  3129:  DOTID:  .word   dolst
                                                  3130:  .word QDUP
                                                  3131:  .word QBRAN,DOTI1
                                                  3132:  .word COUNT,DOLIT,0x1F,ANDD
                                                  3133:  .word UTYPE,EXIT
                                                  3134:  DOTI1:
                                                  3135:  .word DOTQP
                                                  3136:  .ascii "\X09 {noName}"  # D$
                                                  3137:  .word EXIT
                                                  3138:  
                                                  3139:  SEE:    .word   dolst
                                                  3140:  .word TICK
                                                  3141:  .word CR
                                                  3142:  SEE1:
                                                  3143:  .word CELLP,DUPP,AT
                                                  3144:  .word DOLIT,CALLC,AT,XORR
                                                  3145:  .word QBRAN,SEE5
                                                  3146:  .word DUPP,AT
                                                  3147:  .word TNAME
                                                  3148:  SEE2:
                                                  3149:  .word QDUP
                                                  3150:  .word QBRAN,SEE3
                                                  3151:  .word SPACE,DOTID
                                                  3152:  .word BRAN,SEE4
                                                  3153:  SEE3:
                                                  3154:  .word DUPP,AT,UDOT
                                                  3155:  SEE4:
                                                  3156:   #      .word NUFQ
                                                  3157:  .word BRAN,SEE1
                                                  3158:  SEE5:
                                                  3159:  .word DROP,EXIT
                                                  3160:  
                                                  3161:  WORDS:  .word   dolst
                                                  3162:  .word CR,CNTXT,AT
                                                  3163:  WORS1:
                                                  3164:  .word AT,QDUP
                                                  3165:  .word QBRAN,WORS2
                                                  3166:  .word DUPP,SPACE,DOTID
                                                  3167:  .word CELLM             
                                                  3168:   #      .word NUFQ,QBRAN,WORS1
                                                  3169:  .word BRAN,WORS1
                                                  3170:  .word DROP
                                                  3171:  WORS2:
                                                  3172:  .word EXIT
                                                  3173:  
                                                  3174:   
                                                  3175:   ##### include files #####
                                                  3176:  
                                                  3177:  
                                                  3178:  INCLU:  .word   dolst
                                                  3179:  .word TIB,NTIB,AT,PLUS          # end of text buffer
                                                  3180:  .word BLANK,WORDD,ONE,PLUS      # get file name
                                                  3181:  .word INN,DAT,TOR,TOR           # save >IN and #TIB
                                                  3182:  .word OPEN,QDUP                 # open and read file
                                                  3183:  .word QBRAN,INCL1
                                                  3184:  .word NTIB,AT,INN,STORE         # >IN points to beginning of file
                                                  3185:  .word NTIB,PSTOR                # #TIB points to end of file
                                                  3186:  .word EVAL                      # interpret file
                                                  3187:  INCL1:
                                                  3188:  .word RFROM,RFROM,INN,DSTOR     # restore >IN and #TIB
                                                  3189:  .word EXIT                      # done
                                                  3190:  
                                                  3191:  .word dolst
                                                  3192:  
                                                  3193:   ##### cold start #####
                                                  3194:  
                                                  3195:  
                                                  3196:  VERSN:  .word   dolst
                                                  3197:  .word DOLIT,0x103,EXIT
                                                  3198:  
                                                  3199:  HI:     .word   dolst
                                                  3200:  .word STOIO,CR
                                                  3201:  .word DOTQP
                                                  3202:  .ascii "\X0emips eForth v"
                                                  3203:  .word BASE,AT,HEX
                                                  3204:  .word VERSN,BDIGS,DIG,DIG
                                                  3205:  .word DOLIT,46,HOLD
                                                  3206:  .word DIGS,EDIGS,TYPEE
                                                  3207:  .word BASE,STORE,CR,EXIT
                                                  3208:  
                                                  3209:  TBOOT:  .word   dovar
                                                  3210:  .word HI
                                                  3211:  
                                                  3212:  DIAG:   .word   dolst
                                                  3213:  .word DOLIT,101,TXSTO
                                                  3214:  .word ZERO,ZLESS,DOLIT,-2,ZLESS,UPLUS,DROP
                                                  3215:  .word DOLIT,3,UPLUS,UPLUS,DROP,DOLIT,67,UPLUS,DROP,TXSTO
                                                  3216:  .word DOLIT,79,DOLIT,111,XORR,DOLIT,0xF0,ANDD
                                                  3217:  .word DOLIT,79,ORR,TXSTO
                                                  3218:  .word SPAT,SPAT,SWAP,OVER,XORR,DOLIT,CELLL,ANDD
                                                  3219:  .word DOLIT,114-CELLL,UPLUS,DROP
                                                  3220:  .word SWAP,DUPP,DUPP,SPSTO
                                                  3221:  .word TXSTO
                                                  3222:  .word ZERO
                                                  3223:  QB1:
                                                  3224:  .word QBRAN,QB2,DOLIT,63,TXSTO
                                                  3225:  QB2:
                                                  3226:  .word DOLIT,-1,QBRAN,QB3,DOLIT,116,TXSTO,BRAN,QB4
                                                  3227:  QB3:
                                                  3228:  .word DOLIT,33,TXSTO
                                                  3229:  QB4:
                                                  3230:  .word DOLIT,0xff,SPAT
                                                  3231:  .word DOLIT,0xff,OVER,DOLIT,1,UPLUS,DROP,CSTOR
                                                  3232:  .word DOLIT,104,OVER,AT,ANDD,OVER,STORE
                                                  3233:  .word DUPP,AT,OVER,DOLIT,1,UPLUS,DROP,CAT,ORR
                                                  3234:  .word SWAP,STORE,TXSTO,DOLIT,32,TXSTO
                                                  3235:  
                                                  3236:  .word DOLIT,77,TOR,RPAT
                                                  3237:  .word DOLIT,63,TOR,RPSTO,RFROM
                                                  3238:  .word TXSTO
                                                  3239:  .word SZERO,DOLIT,UPP+16,XORR
                                                  3240:  .word QBRAN,UCHK1,DOLIT,63,TXSTO
                                                  3241:  UCHK1:
                                                  3242:  .word DOLIT,117,TXSTO
                                                  3243:  .word ZERO
                                                  3244:  .word DOLIT,0x1B,TOR
                                                  3245:  FOR1:
                                                  3246:  .word DOLIT,1,UPLUS,DROP,DONXT,FOR1
                                                  3247:  .word DOLIT,0x1C,XORR
                                                  3248:  .word QBRAN,NXTOK,DOLIT,63,TXSTO,EXIT
                                                  3249:  NXTOK:
                                                  3250:  .word DOLIT,108,TXSTO,EXIT
                                                  3251:  
                                                  3252:  COLD:   .word   dolst
                                                  3253:  COLD1:
                                                  3254:  #       .word   DIAG
                                                  3255:  .word DOLIT,LASTN,LAST
                                                  3256:  .word STORE
                                                  3257:  .word PRESE
                                                  3258:  .word TBOOT,ATEXE
                                                  3259:  .word FORTH,CNTXT,AT, DUPP
                                                  3260:  .word CRRNT,DSTOR, OVERT
                                                  3261:  .word QUIT
                                                  3262:  .word BRAN,COLD1  
                                                  3263:          .word   dolst   # stop SEE here
                                                  3264:  
                                                  3265:  
                                                  3266:  
                                                  3267:  # name dictionary in FLASH
                                                  3268:          .word   QRX, p1
                                                  3269:  p0:     .byte   3
                                                  3270:          .ascii  "?RX"
                                                  3271:          .word   TXSTO, p2
                                                  3272:  p1:     .byte   3
                                                  3273:          .ascii  "TX!"
                                                  3274:          .word   STOIO, p3
                                                  3275:  p2:     .byte   3
                                                  3276:          .ascii  "!IO"
                                                  3277:          .word   DOLIT, p4
                                                  3278:  p3:     .byte   5+COMPO
                                                  3279:          .ascii  "doLIT"
                                                  3280:          .word   DOLST, p5
                                                  3281:  p4:     .byte   6+COMPO
                                                  3282:          .ascii  "doLIST"
                                                  3283:          .word   EXIT, p6
                                                  3284:  p5:     .byte   4
                                                  3285:          .ascii  "EXIT"
                                                  3286:          .word   EXECU, p7
                                                  3287:  p6:     .byte   7
                                                  3288:          .ascii  "EXECUTE"
                                                  3289:          .word   DONXT, p8
                                                  3290:  p7:     .byte   4+COMPO
                                                  3291:          .ascii  "next"    
                                                  3292:          .word   QBRAN, p9
                                                  3293:  p8:     .byte   7+COMPO
                                                  3294:          .ascii  "?branch"
                                                  3295:          .word   BRAN, p10
                                                  3296:  p9:     .byte   6+COMPO
                                                  3297:          .ascii  "branch"
                                                  3298:          .word   STORE, p11
                                                  3299:  p10:    .byte   1,33
                                                  3300:          .word   AT, p12
                                                  3301:  p11:    .byte   1
                                                  3302:          .ascii  "@"
                                                  3303:          .word   CSTOR, p13
                                                  3304:  p12:    .byte   2
                                                  3305:          .ascii  "C!"
                                                  3306:          .word   CAT, p11a
                                                  3307:  p13:    .byte   2
                                                  3308:          .ascii  "C@"
                                                  3309:          .word   WAT, p12a
                                                  3310:  p11a:   .byte   2
                                                  3311:          .ascii  "W@"
                                                  3312:          .word   WSTOR, p14
                                                  3313:  p12a:   .byte   2
                                                  3314:          .ascii  "W!"
                                                  3315:          .word   RPAT, p15
                                                  3316:  p14:    .byte   3
                                                  3317:          .ascii  "RP@"
                                                  3318:          .word   RPSTO, p16
                                                  3319:  p15:    .byte   3
                                                  3320:          .ascii  "RP!"
                                                  3321:          .word   RFROM, p17
                                                  3322:  p16:    .byte   2
                                                  3323:          .ascii  "R>"
                                                  3324:          .word   RAT, p18
                                                  3325:  p17:    .byte   2
                                                  3326:          .ascii  "R@"
                                                  3327:          .word   TOR, p19
                                                  3328:  p18:    .byte   2
                                                  3329:          .ascii  ">R"
                                                  3330:          .word   SPAT, p20
                                                  3331:  p19:    .byte   3
                                                  3332:          .ascii  "SP@"
                                                  3333:          .word   SPSTO, p21
                                                  3334:  p20:    .byte   3
                                                  3335:          .ascii  "SP!"
                                                  3336:          .word   DROP, p22
                                                  3337:  p21:    .byte   4
                                                  3338:          .ascii  "DROP"
                                                  3339:          .word   DUPP, p23
                                                  3340:  p22:    .byte   3
                                                  3341:          .ascii  "DUP"
                                                  3342:          .word   SWAP, p24
                                                  3343:  p23:    .byte   4
                                                  3344:          .ascii  "SWAP"
                                                  3345:          .word   OVER, p25
                                                  3346:  p24:    .byte   4
                                                  3347:          .ascii  "OVER"
                                                  3348:          .word   ZLESS, p26
                                                  3349:  p25:    .byte   2
                                                  3350:          .ascii  "0<"
                                                  3351:          .word   ANDD, p27
                                                  3352:  p26:    .byte   3
                                                  3353:          .ascii  "AND"
                                                  3354:          .word   ORR, p28
                                                  3355:  p27:    .byte   2
                                                  3356:          .ascii  "OR"
                                                  3357:          .word   XORR, p29
                                                  3358:  p28:    .byte   3
                                                  3359:          .ascii  "XOR"
                                                  3360:          .word   UPLUS, p31
                                                  3361:  p29:    .byte   3
                                                  3362:          .ascii  "UM+"
                                                  3363:          .word   UP, p33
                                                  3364:  p31:    .byte   2
                                                  3365:          .ascii  "UP"
                                                  3366:          .word   SZERO, p34
                                                  3367:  p33:    .byte   3
                                                  3368:          .ascii  "SP0"
                                                  3369:          .word   RZERO, p35
                                                  3370:  p34:    .byte   3
                                                  3371:          .ascii  "RP0"
                                                  3372:          .word   TQKEY, p36
                                                  3373:  p35:    .byte   5
                                                  3374:          .ascii  "\'?KEY"
                                                  3375:          .word   TEMIT, p37
                                                  3376:  p36:    .byte   5
                                                  3377:          .ascii  "\'EMIT"
                                                  3378:          .word   TEXPE, p38
                                                  3379:  p37:    .byte   7
                                                  3380:          .ascii  "\'EXPECT"
                                                  3381:          .word   TTAP, p39
                                                  3382:  p38:    .byte   4
                                                  3383:          .ascii  "\'TAP"
                                                  3384:          .word   TECHO, p40
                                                  3385:  p39:    .byte   5
                                                  3386:          .ascii  "\'ECHO"
                                                  3387:          .word   TPROM, p41
                                                  3388:  p40:    .byte   6
                                                  3389:          .ascii  "PROMPT"
                                                  3390:          .word   BASE, p42
                                                  3391:  p41:    .byte   4
                                                  3392:          .ascii  "BASE"
                                                  3393:          .word   TEMP, p43
                                                  3394:  p42:    .byte   3
                                                  3395:          .ascii  "tmp"
                                                  3396:          .word   SPAN, p44
                                                  3397:  p43:    .byte   4
                                                  3398:          .ascii  "SPAN"
                                                  3399:          .word   INN, p45
                                                  3400:  p44:    .byte   3
                                                  3401:          .ascii  ">IN"
                                                  3402:          .word   NTIB, p46
                                                  3403:  p45:    .byte   4
                                                  3404:          .ascii  "\#TIB"
                                                  3405:          .word   CSP, p47
                                                  3406:  p46:    .byte   3
                                                  3407:          .ascii  "CSP"
                                                  3408:          .word   TEVAL, p48
                                                  3409:  p47:    .byte   5
                                                  3410:          .ascii  "\'EVAL"
                                                  3411:          .word   TNUMB, p49
                                                  3412:  p48:    .byte   7
                                                  3413:          .ascii  "\'NUMBER"
                                                  3414:          .word   HLD, p50
                                                  3415:  p49:    .byte   3
                                                  3416:          .ascii  "HLD"
                                                  3417:          .word   HANDL, p51
                                                  3418:  p50:    .byte   7
                                                  3419:          .ascii  "HANDLER"
                                                  3420:          .word   CNTXT, p52
                                                  3421:  p51:    .byte   7
                                                  3422:          .ascii  "CONTEXT"
                                                  3423:          .word   CRRNT, p53
                                                  3424:  p52:    .byte   7
                                                  3425:          .ascii  "CURRENT"
                                                  3426:          .word   CP, p54
                                                  3427:  p53:    .byte   2
                                                  3428:          .ascii  "CP"
                                                  3429:          .word   NP, p55
                                                  3430:  p54:    .byte   2
                                                  3431:          .ascii  "NP"
                                                  3432:          .word   LAST, p57
                                                  3433:  p55:    .byte   4
                                                  3434:          .ascii  "LAST"
                                                  3435:          .word   FORTH, p58
                                                  3436:  p57:    .byte   5
                                                  3437:          .ascii  "FORTH"
                                                  3438:          .word   QDUP, p59
                                                  3439:  p58:    .byte   4
                                                  3440:          .ascii  "?DUP"
                                                  3441:          .word   ROT, p60
                                                  3442:  p59:    .byte   3
                                                  3443:          .ascii  "ROT"
                                                  3444:          .word   DDROP, p61
                                                  3445:  p60:    .byte   5
                                                  3446:          .ascii  "2DROP"
                                                  3447:          .word   DDUP, p62
                                                  3448:  p61:    .byte   4
                                                  3449:          .ascii  "2DUP"
                                                  3450:          .word   PLUS, p63
                                                  3451:  p62:    .byte   1
                                                  3452:          .ascii  "+"
                                                  3453:          .word   DPLUS, p64
                                                  3454:  p63:    .byte   2
                                                  3455:          .ascii  "D+"
                                                  3456:          .word   INVER, p65
                                                  3457:  p64:    .byte   3
                                                  3458:          .ascii  "NOT"
                                                  3459:          .word   NEGAT, p66
                                                  3460:  p65:    .byte   6
                                                  3461:          .ascii  "NEGATE"
                                                  3462:          .word   DNEGA, p67
                                                  3463:  p66:    .byte   7
                                                  3464:          .ascii  "DNEGATE"
                                                  3465:          .word   SUBB, p68
                                                  3466:  p67:    .byte   1
                                                  3467:          .ascii  "-"
                                                  3468:          .word   ABSS, p69
                                                  3469:  p68:    .byte   3
                                                  3470:          .ascii  "ABS"
                                                  3471:          .word   EQUAL, p70
                                                  3472:  p69:    .byte   1
                                                  3473:          .ascii  "="
                                                  3474:          .word   ULESS, p71
                                                  3475:  p70:    .byte   2
                                                  3476:          .ascii  "U<"
                                                  3477:          .word   LESS, p72
                                                  3478:  p71:    .byte   1
                                                  3479:          .ascii  "<"
                                                  3480:          .word   MAX, p73
                                                  3481:  p72:    .byte   3
                                                  3482:          .ascii  "MAX"
                                                  3483:          .word   MIN, p74
                                                  3484:  p73:    .byte   3
                                                  3485:          .ascii  "MIN"
                                                  3486:          .word   WITHI, p75
                                                  3487:  p74:    .byte   6
                                                  3488:          .ascii  "WITHIN"
                                                  3489:          .word   UMMOD, p76
                                                  3490:  p75:    .byte   6
                                                  3491:          .ascii  "UM/MOD"
                                                  3492:          .word   MSMOD, p77
                                                  3493:  p76:    .byte   5
                                                  3494:          .ascii  "M/MOD"
                                                  3495:          .word   SLMOD, p78
                                                  3496:  p77:    .byte   4
                                                  3497:          .ascii  "/MOD"
                                                  3498:          .word   MODD, p79
                                                  3499:  p78:    .byte   3
                                                  3500:          .ascii  "MOD"
                                                  3501:          .word   SLASH, p80
                                                  3502:  p79:    .byte   1
                                                  3503:          .ascii  "/"
                                                  3504:          .word   UMSTA, p81
                                                  3505:  p80:    .byte   3
                                                  3506:          .ascii  "UM*"
                                                  3507:          .word   STAR, p82
                                                  3508:  p81:    .byte   1
                                                  3509:          .ascii  "*"
                                                  3510:          .word   MSTAR, p83
                                                  3511:  p82:    .byte   2
                                                  3512:          .ascii  "M*"
                                                  3513:          .word   SSMOD, p84
                                                  3514:  p83:    .byte   5
                                                  3515:          .ascii  "*/MOD"
                                                  3516:          .word   STASL, p85
                                                  3517:  p84:    .byte   2
                                                  3518:          .ascii  "*/"
                                                  3519:          .word   CELLP, p86
                                                  3520:  p85:    .byte   5
                                                  3521:          .ascii  "CELL+"
                                                  3522:          .word   CELLM, p87
                                                  3523:  p86:    .byte   5
                                                  3524:          .ascii  "CELL-"
                                                  3525:          .word   CELLS, p88a
                                                  3526:  p87:    .byte   5
                                                  3527:          .ascii  "CELLS"
                                                  3528:          .word   TWOST, p88b
                                                  3529:  p88a:   .byte   2
                                                  3530:          .ascii  "2*"
                                                  3531:          .word   TWOSL, p88
                                                  3532:  p88b:   .byte   2
                                                  3533:          .ascii  "2/"
                                                  3534:          .word   ALGND, p89
                                                  3535:  p88:    .byte   7
                                                  3536:          .ascii  "ALIGNED"
                                                  3537:          .word   BLANK, p90
                                                  3538:  p89:    .byte   2
                                                  3539:          .ascii  "BL"
                                                  3540:          .word   TCHAR, p91
                                                  3541:  p90:    .byte   5
                                                  3542:          .ascii  ">CHAR"
                                                  3543:          .word   DEPTH, p92
                                                  3544:  p91:    .byte   5
                                                  3545:          .ascii  "DEPTH"
                                                  3546:          .word   PICK, p93
                                                  3547:  p92:    .byte   4
                                                  3548:          .ascii  "PICK"
                                                  3549:          .word   PSTOR, p94
                                                  3550:  p93:    .byte   2
                                                  3551:          .ascii  "+!"
                                                  3552:          .word   DSTOR, p95
                                                  3553:  p94:    .byte   2
                                                  3554:          .ascii  "2!"
                                                  3555:          .word   DAT, p96
                                                  3556:  p95:    .byte   2
                                                  3557:          .ascii  "2@"
                                                  3558:          .word   COUNT, p97
                                                  3559:  p96:    .byte   5
                                                  3560:          .ascii  "COUNT"
                                                  3561:          .word   HERE, p98
                                                  3562:  p97:    .byte   4
                                                  3563:          .ascii  "HERE"
                                                  3564:          .word   PAD, p99
                                                  3565:  p98:    .byte   3
                                                  3566:          .ascii  "PAD"
                                                  3567:          .word   TIB, p100
                                                  3568:  p99:    .byte   3
                                                  3569:          .ascii  "TIB"
                                                  3570:          .word   ATEXE, p101
                                                  3571:  p100:   .byte   8
                                                  3572:          .ascii  "@EXECUTE"
                                                  3573:          .word   CMOVE, p102
                                                  3574:  p101:   .byte   5
                                                  3575:          .ascii  "CMOVE"
                                                  3576:          .word   FILL, p103
                                                  3577:  p102:   .byte   4
                                                  3578:          .ascii  "FILL"
                                                  3579:          .word   DTRAI, p104
                                                  3580:  p103:   .byte   9
                                                  3581:          .ascii  "-TRAILING"
                                                  3582:          .word   PACKS, p105
                                                  3583:  p104:   .byte   5
                                                  3584:          .ascii  "PACK$"
                                                  3585:          .word   DIGIT, p106
                                                  3586:  p105:   .byte   5
                                                  3587:          .ascii  "DIGIT"
                                                  3588:          .word   EXTRC, p107
                                                  3589:  p106:   .byte   7
                                                  3590:          .ascii  "EXTRACT"
                                                  3591:          .word   BDIGS, p108
                                                  3592:  p107:   .byte   2
                                                  3593:          .ascii  "<\#"
                                                  3594:          .word   HOLD, p109
                                                  3595:  p108:   .byte   4
                                                  3596:          .ascii  "HOLD"
                                                  3597:          .word   DIG, p110
                                                  3598:  p109:   .byte   1
                                                  3599:          .ascii  "\#"
                                                  3600:          .word   DIGS, p111
                                                  3601:  p110:   .byte   2
                                                  3602:          .ascii  "#S"
                                                  3603:          .word   SIGN, p112
                                                  3604:  p111:   .byte   4
                                                  3605:          .ascii  "SIGN"
                                                  3606:          .word   EDIGS, p113
                                                  3607:  p112:   .byte   2
                                                  3608:          .ascii  "\#>"
                                                  3609:          .word   STRR, p114
                                                  3610:  p113:   .byte   3
                                                  3611:          .ascii  "str"
                                                  3612:          .word   HEX, p115
                                                  3613:  p114:   .byte   3
                                                  3614:          .ascii  "HEX"
                                                  3615:          .word   DECIM, p116
                                                  3616:  p115:   .byte   7
                                                  3617:          .ascii  "DECIMAL"
                                                  3618:          .word   DIGTQ, p117
                                                  3619:  p116:   .byte   6
                                                  3620:          .ascii  "DIGIT?"
                                                  3621:          .word   NUMBQ, p118
                                                  3622:  p117:   .byte   7
                                                  3623:          .ascii  "NUMBER?"
                                                  3624:          .word   QKEY, p119
                                                  3625:  p118:   .byte   4
                                                  3626:          .ascii  "?KEY"
                                                  3627:          .word   KEY, p120
                                                  3628:  p119:   .byte   3
                                                  3629:          .ascii  "KEY"
                                                  3630:          .word   EMIT, p121
                                                  3631:  p120:   .byte   4
                                                  3632:          .ascii  "EMIT"
                                                  3633:          .word   NUFQ, p122
                                                  3634:  p121:   .byte   4
                                                  3635:          .ascii  "NUF?"
                                                  3636:          .word   PACE, p123
                                                  3637:  p122:   .byte   4
                                                  3638:          .ascii  "PACE"
                                                  3639:          .word   SPACE, p124
                                                  3640:  p123:   .byte   5
                                                  3641:          .ascii  "SPACE"
                                                  3642:          .word   SPACS, p125
                                                  3643:  p124:   .byte   6
                                                  3644:          .ascii  "SPACES"
                                                  3645:          .word   TYPEE, p126
                                                  3646:  p125:   .byte   4
                                                  3647:          .ascii  "TYPE"
                                                  3648:          .word   CR, p127
                                                  3649:  p126:   .byte   2
                                                  3650:          .ascii  "CR"
                                                  3651:          .word   DOSTR, p128
                                                  3652:  p127:   .byte   3+COMPO
                                                  3653:          .ascii  "do$"
                                                  3654:          .word   STRQP, p128a
                                                  3655:  p128:   .byte   3+COMPO
                                                  3656:          .ascii  "$\"|"
                                                  3657:          .word   DOTQP, p129
                                                  3658:  p128a:  .byte   3+COMPO
                                                  3659:          .ascii  ".\"|"
                                                  3660:          .word   DOTR, p130
                                                  3661:  p129:   .byte   2
                                                  3662:          .ascii  ".R"
                                                  3663:          .word   UDOTR, p131
                                                  3664:  p130:   .byte   3
                                                  3665:          .ascii  "U.R"
                                                  3666:          .word   UDOT, p132
                                                  3667:  p131:   .byte   2
                                                  3668:          .ascii  "U."
                                                  3669:          .word   DOT, p133
                                                  3670:  p132:   .byte   1
                                                  3671:          .ascii  "."
                                                  3672:          .word   QUEST, p134
                                                  3673:  p133:   .byte   1
                                                  3674:          .ascii  "?"
                                                  3675:          .word   PARS, p135
                                                  3676:  p134:   .byte   5
                                                  3677:          .ascii  "parse"
                                                  3678:          .word   PARSE, p136
                                                  3679:  p135:   .byte   5
                                                  3680:          .ascii  "PARSE"
                                                  3681:          .word   DOTPR, p137
                                                  3682:  p136:   .byte   2+IMEDD
                                                  3683:          .ascii  ".("
                                                  3684:          .word   PAREN, p138
                                                  3685:  p137:   .byte   1+IMEDD
                                                  3686:          .ascii  "("
                                                  3687:          .word   BKSLA, p139
                                                  3688:  p138:   .byte   1+IMEDD
                                                  3689:          .ascii  "\\"
                                                  3690:          .word   CHAR, p140
                                                  3691:  p139:   .byte   4
                                                  3692:          .ascii  "CHAR"
                                                  3693:          .word   TOKEN, p141
                                                  3694:  p140:   .byte   5
                                                  3695:          .ascii  "TOKEN"
                                                  3696:          .word   WORDD, p142
                                                  3697:  p141:   .byte   4
                                                  3698:          .ascii  "WORD"
                                                  3699:          .word   NAMET, p143
                                                  3700:  p142:   .byte   5
                                                  3701:          .ascii  "NAME>"
                                                  3702:          .word   SAMEQ, p144
                                                  3703:  p143:   .byte   5
                                                  3704:          .ascii  "SAME?"
                                                  3705:          .word   FIND, p145
                                                  3706:  p144:   .byte   4
                                                  3707:          .ascii  "find"
                                                  3708:          .word   NAMEQ, p146
                                                  3709:  p145:   .byte   5
                                                  3710:          .ascii  "NAME?"
                                                  3711:          .word   BKSP, p147
                                                  3712:  p146:   .byte   2
                                                  3713:          .ascii  "^H"
                                                  3714:          .word   TAP, p148
                                                  3715:  p147:   .byte   3
                                                  3716:          .ascii  "TAP"
                                                  3717:          .word   KTAP, p149
                                                  3718:  p148:   .byte   4
                                                  3719:          .ascii  "kTAP"
                                                  3720:          .word   ACCEP, p150
                                                  3721:  p149:   .byte   6
                                                  3722:          .ascii  "accept"
                                                  3723:          .word   EXPEC, p151
                                                  3724:  p150:   .byte   6
                                                  3725:          .ascii  "EXPECT"
                                                  3726:          .word   QUERY, p152
                                                  3727:  p151:   .byte   5
                                                  3728:          .ascii  "QUERY"
                                                  3729:          .word   CATCH, p153
                                                  3730:  p152:   .byte   5
                                                  3731:          .ascii  "CATCH"
                                                  3732:          .word   THROW, p154
                                                  3733:  p153:   .byte   5
                                                  3734:          .ascii  "THROW"
                                                  3735:          .word   NULLS, p155
                                                  3736:  p154:   .byte   5
                                                  3737:          .ascii  "NULL$"
                                                  3738:          .word   ABORT, p156
                                                  3739:  p155:   .byte   5
                                                  3740:          .ascii  "ABORT"
                                                  3741:          .word   ABORQ, p157
                                                  3742:  p156:   .byte   6
                                                  3743:          .ascii  "abort\""
                                                  3744:          .word   INTER, p158
                                                  3745:  p157:   .byte   10
                                                  3746:          .ascii  "$INTERPRET"
                                                  3747:          .word   LBRAC, p159
                                                  3748:  p158:   .byte   1+IMEDD
                                                  3749:          .ascii  "["
                                                  3750:          .word   DOTOK, p160
                                                  3751:  p159:   .byte   3
                                                  3752:          .ascii  ".OK"
                                                  3753:          .word   QSTAC, p161
                                                  3754:  p160:   .byte   6
                                                  3755:          .ascii  "?STACK"
                                                  3756:          .word   EVAL, p162
                                                  3757:  p161:   .byte   4
                                                  3758:          .ascii  "EVAL"
                                                  3759:          .word   PRESE, p163
                                                  3760:  p162:   .byte   6
                                                  3761:          .ascii  "PRESET"
                                                  3762:          .word   XIO, p164
                                                  3763:  p163:   .byte   3+COMPO
                                                  3764:          .ascii  "xio"
                                                  3765:          .word   FILE, p164a
                                                  3766:  p164:   .byte   4
                                                  3767:          .ascii  "FILE"
                                                  3768:          .word   OPEN, p165
                                                  3769:  p164a:  .byte   4
                                                  3770:          .ascii  "OPEN"
                                                  3771:          .word   HAND, p166
                                                  3772:  p165:   .byte   4
                                                  3773:          .ascii  "HAND"
                                                  3774:          .word   ISLO, p167
                                                  3775:  p166:   .byte   3
                                                  3776:          .ascii  "I/O"
                                                  3777:          .word   CONSO, p168
                                                  3778:  p167:   .byte   7
                                                  3779:          .ascii  "CONSOLE"
                                                  3780:          .word   QUIT, p169
                                                  3781:  p168:   .byte   4
                                                  3782:          .ascii  "QUIT"
                                                  3783:          .word   TICK, p170
                                                  3784:  p169:   .byte   1
                                                  3785:          .ascii  "\'"
                                                  3786:          .word   ALLOT, p171
                                                  3787:  p170:   .byte   5
                                                  3788:          .ascii  "ALLOT"
                                                  3789:          .word   COMMA, p172
                                                  3790:  p171:   .byte   1
                                                  3791:          .ascii  ","
                                                  3792:          .word   BCOMP, p173
                                                  3793:  p172:   .byte   9+IMEDD+COMPO
                                                  3794:          .ascii  "[COMPILE]"
                                                  3795:          .word   COMPI, p174
                                                  3796:  p173:   .byte   7+COMPO+COMPO
                                                  3797:          .ascii  "COMPILE"
                                                  3798:          .word   LITER, p175
                                                  3799:  p174:   .byte   7+IMEDD+COMPO
                                                  3800:          .ascii  "LITERAL"
                                                  3801:          .word   STRCQ, p176
                                                  3802:  p175:   .byte   3+COMPO
                                                  3803:          .ascii  "$,\""
                                                  3804:          .word   RECUR, p177
                                                  3805:  p176:   .byte   7+IMEDD+COMPO
                                                  3806:          .ascii  "RECURSE"
                                                  3807:          .word   FOR, p178
                                                  3808:  p177:   .byte   3+IMEDD+COMPO
                                                  3809:          .ascii  "FOR"
                                                  3810:          .word   BEGIN, p179
                                                  3811:  p178:   .byte   5+IMEDD+COMPO
                                                  3812:          .ascii  "BEGIN"
                                                  3813:          .word   NEXT, p180
                                                  3814:  p179:   .byte   4+IMEDD+COMPO
                                                  3815:          .ascii  "NEXT"
                                                  3816:          .word   UNTIL, p181
                                                  3817:  p180:   .byte   5+IMEDD+COMPO
                                                  3818:          .ascii  "UNTIL"
                                                  3819:          .word   AGAIN, p182
                                                  3820:  p181:   .byte   5+IMEDD+COMPO
                                                  3821:          .ascii  "AGAIN"
                                                  3822:          .word   IFF, p183
                                                  3823:  p182:   .byte   2+IMEDD+COMPO
                                                  3824:          .ascii  "IF"
                                                  3825:          .word   AHEAD, p184
                                                  3826:  p183:   .byte   5+IMEDD+COMPO
                                                  3827:          .ascii  "AHEAD"
                                                  3828:          .word   REPEA, p185
                                                  3829:  p184:   .byte   6+IMEDD+COMPO
                                                  3830:          .ascii  "REPEAT"
                                                  3831:          .word   THENN, p186
                                                  3832:  p185:   .byte   4+IMEDD+COMPO
                                                  3833:          .ascii  "THEN"
                                                  3834:          .word   AFT, p187
                                                  3835:  p186:   .byte   3+IMEDD+COMPO
                                                  3836:          .ascii  "AFT"
                                                  3837:          .word   ELSEE, p188
                                                  3838:  p187:   .byte   4+IMEDD+COMPO
                                                  3839:          .ascii  "ELSE"
                                                  3840:          .word   WHILE, p189
                                                  3841:  p188:   .byte   5+IMEDD+COMPO
                                                  3842:          .ascii  "WHILE"
                                                  3843:          .word   ABRTQ, p190
                                                  3844:  p189:   .byte   6+IMEDD+COMPO
                                                  3845:          .ascii  "ABORT\""
                                                  3846:          .word   STRQ, p191
                                                  3847:  p190:   .byte   2+IMEDD+COMPO
                                                  3848:          .ascii  "$\""
                                                  3849:          .word   DOTQ, p192
                                                  3850:  p191:   .byte   2+IMEDD+COMPO
                                                  3851:          .ascii  ".\""
                                                  3852:          .word   UNIQU, p193
                                                  3853:  p192:   .byte   7
                                                  3854:          .ascii  "?UNIQUE"
                                                  3855:          .word   SNAME, p194
                                                  3856:  p193:   .byte   3
                                                  3857:          .ascii  "$\,n"
                                                  3858:          .word   SCOMP, p195
                                                  3859:  p194:   .byte   8
                                                  3860:          .ascii  "$COMPILE"
                                                  3861:          .word   OVERT, p196
                                                  3862:  p195:   .byte   5
                                                  3863:          .ascii  "OVERT"
                                                  3864:          .word   SEMIS, p197
                                                  3865:  p196:   .byte   1+IMEDD+COMPO
                                                  3866:          .ascii  ";"
                                                  3867:          .word   RBRAC, p199
                                                  3868:  p197:   .byte   1
                                                  3869:          .ascii  "]"
                                                  3870:          .word   COLON, p200
                                                  3871:  p199:   .byte   1
                                                  3872:          .ascii  ":"
                                                  3873:          .word   IMMED, p201
                                                  3874:  p200:   .byte   9
                                                  3875:          .ascii  "IMMEDIATE"
                                                  3876:          .word   USER, p202
                                                  3877:  p201:   .byte   4
                                                  3878:          .ascii  "USER"
                                                  3879:          .word   CREAT, p203
                                                  3880:  p202:   .byte   6
                                                  3881:          .ascii  "CREATE"
                                                  3882:          .word   VARIA, p204a
                                                  3883:  p203:   .byte   8
                                                  3884:          .ascii  "VARIABLE"
                                                  3885:          .word   CONST, p204
                                                  3886:  p204a:  .byte   8
                                                  3887:          .ascii  "CONSTANT"
                                                  3888:          .word   UTYPE, p205
                                                  3889:  p204:   .byte   5
                                                  3890:          .ascii  "_TYPE"
                                                  3891:          .word   DMP, p206
                                                  3892:  p205:   .byte   3
                                                  3893:          .ascii  "dm+"
                                                  3894:          .word   DUMP, p207
                                                  3895:  p206:   .byte   4
                                                  3896:          .ascii  "DUMP"
                                                  3897:          .word   DOTS, p208
                                                  3898:  p207:   .byte   2
                                                  3899:          .ascii  ".S"
                                                  3900:          .word   STCSP, p209
                                                  3901:  p208:   .byte   4
                                                  3902:          .ascii  "!CSP"
                                                  3903:          .word   QCSP, p210
                                                  3904:  p209:   .byte   4
                                                  3905:          .ascii  "?CSP"
                                                  3906:          .word   TNAME, p211
                                                  3907:  p210:   .byte   5
                                                  3908:          .ascii  ">NAME"
                                                  3909:          .word   DOTID, p212
                                                  3910:  p211:   .byte   3
                                                  3911:          .ascii  ".ID"
                                                  3912:          .word   SEE, p213
                                                  3913:  p212:   .byte   3
                                                  3914:          .ascii  "SEE"
                                                  3915:          .word   WORDS, p214a
                                                  3916:  p213:   .byte   5
                                                  3917:          .ascii  "WORDS"
                                                  3918:          .word   INCLU, p214
                                                  3919:  p214a:  .byte   7
                                                  3920:          .ascii  "INCLUDE"
                                                  3921:          .word   VERSN, p215
                                                  3922:  p214:   .byte   3
                                                  3923:          .ascii  "VER"
                                                  3924:          .word   HI, p216
                                                  3925:  p215:   .byte   2
                                                  3926:          .ascii  "hi"
                                                  3927:          .word   TBOOT, p217
                                                  3928:  p216:   .byte   5
                                                  3929:          .ascii  "\'BOOT"
                                                  3930:          .word   DIAG, p218
                                                  3931:  p217:   .byte   8
                                                  3932:          .ascii  "DIAGNOSE"
                                                  3933:          .word   COLD, p219
                                                  3934:  p218:   .byte   4
                                                  3935:          .ascii  "COLD"
                                                  3936:          .word   ZERO, p220
                                                  3937:  p219:   .byte   1
                                                  3938:          .ascii  "0"
                                                  3939:          .word   ONE, p221
                                                  3940:  p220:   .byte   1
                                                  3941:          .ascii  "1"
                                                  3942:          .word   TWO, p222
                                                  3943:  p221:   .byte   1
                                                  3944:          .ascii  "2"
                                                  3945:          .word   THREE, p227
                                                  3946:   p222:   .byte   1
                                                  3947:          .ascii  "3"
                                                  3948:  #        .word   GRAPH, p224
                                                  3949:  # p223:   .byte   8
                                                  3950:  #        .ascii  "GRAPHICS"
                                                  3951:  #        .word   FLTNG, p225
                                                  3952:  # p224:   .byte   8
                                                  3953:  #        .ascii  "FLOATING"
                                                  3954:  #        .word   APPLI, 226
                                                  3955:  # p225:   .byte   11
                                                  3956:  #        .ascii  "APPLICATION"
                                                  3957:          .word   DPRT, p227
                                                  3958:  p226:   .byte   6
                                                  3959:          .ascii  "DBGPRT"
                                                  3960:          .word   TRON, p228
                                                  3961:  p227:   .byte 4
                                                  3962:          .ascii  "TRON"
                                                  3963:          .word   TROFF, 0
                                                  3964:  p228:   .byte 5
                                                  3965:          .ascii "TROFF"
                                                  3966:          .word   0
                                                  3967:  p229:   .word   0,0,0,0
                                                  3968:  
                                                  3969:  msg1:   .asciiz "%s\n"
                                                  3970:  msg2:   .asciiz "%80c"
                                                  3971:  msg3:   .asciiz "ok>"
                                                  3972:  msg4:   .asciiz "hi.f\000"
                                                  3973:  msg5:   .asciiz "file read error\X0A\X00"
                                                  3974:  msg6:   .asciiz "%g\040"
                                                  3975:  msg7:   .asciiz "step 7\n"
                                                  3976:  msg8:   .asciiz "rp=%x r0=%x r1=%x\X0A\X00"
                                                  3977:  msg9:   .asciiz "sp=%x ip=%x wp=%x\X0A\X00"
                                                  3978:  msg10:  .asciiz "s0=%x s1=%x s2=%x\X0A\X00"
                                                  3979:  
                                                  3980:  
                                                  3981:          .data
                                                  3982:  DATA0:  .space  512
                                                  3983:  SPP:    .word   0               # data stack
                                                  3984:  INBUF:  .space  512             # buffer for 'read'
                                                  3985:  RPP:    .word   0               # return stack
                                                  3986:  UZERO:
                                                  3987:  UPP:    .space  16              # user area
                                                  3988:          .word   SPP     # 16    SZERO data pointer base
                                                  3989:          .word   RPP     # 20    RZERO return pointer base
                                                  3990:          .word   QRX     # 24    TQKEY
                                                  3991:          .word   TXSTO   # 28    TEMIT
                                                  3992:          .word   ACCEP   # 32    TEXPE
                                                  3993:          .word   KTAP    # 36    TTAP
                                                  3994:          .word   EMIT    # 40    TECHO
                                                  3995:          .word   DOTOK   # 44    TPROM
                                                  3996:          .word   BASEE   # 48    BASE
                                                  3997:          .word   0, 0    # 52    TEMP, SPAN
                                                  3998:  TINN:   .word   0       # 60    INN
                                                  3999:  NTIBB:  .word   0       # 64    NTIB
                                                  4000:          .word   TIBB    # 68
                                                  4001:          .word   0       # 72    CSP
                                                  4002:          .word   INTER   # 76    TEVAL
                                                  4003:          .word   NUMBQ   # 80    TNUMB
                                                  4004:          .word   0, 0    # 84    HLD, HANDL
                                                  4005:  CTXT:   .word   FORTH+4 # 92    CNTXT
                                                  4006:          .word   0       # 96
                                                  4007:          .word   0       # 100
                                                  4008:          .word   0       # 104
                                                  4009:          .word   0       # 108
                                                  4010:          .space  16       # 112
                                                  4011:  CRNT:   .word   0, 0     # 128  CRRNT
                                                  4012:          .word   CTOP     # 136  CP
                                                  4013:          .word   NTOP     # 140  NP
                                                  4014:          .word   LASTN    # 144  LAST
                                                  4015:  ULAST:  .word   0, 0, 0, 0   
                                                  4016:          .word   0, 0, 0, 0   
                                                  4017:  FVOC:   .word   LASTN        
                                                  4018:          .word   0, 0, 0, 0        # editor, assembly, application
                                                  4019:  SAVLINK:.word   0            
                                                  4020:  SAVSP:  .word   0            
                                                  4021:  TRACE:  .word   0
                                                  4022:          
                                                  4023:  TIBB:
                                                  4024:  FBUFF:  .space 10000           # terminal input buffer and file buffer
                                                  4025:  
                                                  4026:  CTOP:   .space 8192 # code dictionary space in RAM upwards
                                                  4027:  
                                                  4028:  
                                                  4029:  RAMN:            # name dictionary in RAM
                                                  4030:  NTOP:   .word   BYE, p0 # free name dictionary space downwards
                                                  4031:  LASTN:                  # name dictionary
                                                  4032:          .byte   3
                                                  4033:          .ascii  "BYE"
                                                  4034:  
                                                  4035:  
                                                  4036:  
                                                  4037:  
                                                  4038:  #        .end    eForth
                                                  4039:  
                                                  4040:  # <107 weaver2 /work/ls>
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/serial_comm.c  ---------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   uart.h
20:                   * Author: Jacques Deschênes
21:                   * Description: fonctions de bas niveau pour communication UART avec le PC
22:                   * Created on 17 avril 2013, 14:48
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "serial_comm.h"
27:                  #include "HardwareProfile.h"
28:                  
29:                  static char unget;
30:                  
31:                  void UartInit(UART_MODULE channel, int baudrate, UART_LINE_CONTROL_MODE LineCtrl){
9D00A4AC  27BDFFE8   ADDIU SP, SP, -24
9D00A4B0  AFBF0014   SW RA, 20(SP)
9D00A4B4  AFBE0010   SW S8, 16(SP)
9D00A4B8  03A0F021   ADDU S8, SP, ZERO
9D00A4BC  AFC40018   SW A0, 24(S8)
9D00A4C0  AFC5001C   SW A1, 28(S8)
9D00A4C4  AFC60020   SW A2, 32(S8)
32:                  /*initialise le périphérique UART*/
33:                     // Configure UART, information dans uart.h
34:                     UARTConfigure(channel, UART_ENABLE_PINS_TX_RX_ONLY); // pas de contrôle de flux matériel.
9D00A4C8  8FC40018   LW A0, 24(S8)
9D00A4CC  00002821   ADDU A1, ZERO, ZERO
9D00A4D0  0F403322   JAL UARTConfigure
9D00A4D4  00000000   NOP
35:                     UARTSetLineControl(channel, LineCtrl);
9D00A4D8  8FC40018   LW A0, 24(S8)
9D00A4DC  8FC50020   LW A1, 32(S8)
9D00A4E0  0F40334C   JAL UARTSetLineControl
9D00A4E4  00000000   NOP
36:                     UARTSetDataRate(channel, mGetPeripheralClock(), baudrate);
9D00A4E8  8FC2001C   LW V0, 28(S8)
9D00A4EC  8FC40018   LW A0, 24(S8)
9D00A4F0  3C03023C   LUI V1, 572
9D00A4F4  34653460   ORI A1, V1, 13408
9D00A4F8  00403021   ADDU A2, V0, ZERO
9D00A4FC  0F4032E6   JAL UARTSetDataRate
9D00A500  00000000   NOP
37:                     // activation du périphérique
38:                     UARTEnable(channel, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D00A504  8FC40018   LW A0, 24(S8)
9D00A508  24050087   ADDIU A1, ZERO, 135
9D00A50C  0F403292   JAL UARTEnable
9D00A510  00000000   NOP
39:                     unget=-1;
9D00A514  2402FFFF   ADDIU V0, ZERO, -1
9D00A518  A3828014   SB V0, -32748(GP)
40:                  };
9D00A51C  03C0E821   ADDU SP, S8, ZERO
9D00A520  8FBF0014   LW RA, 20(SP)
9D00A524  8FBE0010   LW S8, 16(SP)
9D00A528  27BD0018   ADDIU SP, SP, 24
9D00A52C  03E00008   JR RA
9D00A530  00000000   NOP
41:                  
42:                  char UartGetch(UART_MODULE channel){
9D00A534  27BDFFF0   ADDIU SP, SP, -16
9D00A538  AFBE000C   SW S8, 12(SP)
9D00A53C  03A0F021   ADDU S8, SP, ZERO
9D00A540  AFC40010   SW A0, 16(S8)
9D00A544  8FC20010   LW V0, 16(S8)
9D00A548  AFC20000   SW V0, 0(S8)
43:                  /*lecture d'un caractère retourne 0 si aucun disponible*/
44:                      char ch;
45:                      if (!unget==-1) {
46:                          ch=unget;
47:                          unget=-1;
48:                          return ch;
49:                      }else{
50:                          if (UARTReceivedDataIsAvailable (channel)){
9D00A56C  1040000E   BEQ V0, ZERO, 0x9D00A5A8
9D00A570  00000000   NOP
9D00A574  8FC20010   LW V0, 16(S8)
9D00A578  AFC20004   SW V0, 4(S8)
51:                                 return UARTGetDataByte(channel);
9D00A59C  7C021420   SEB V0, V0
9D00A5A0  0B40296B   J 0x9D00A5AC
9D00A5A4  00000000   NOP
52:                          }else{
53:                              return 0;
9D00A5A8  00001021   ADDU V0, ZERO, ZERO
54:                          }
55:                      }
56:                  };
9D00A5AC  03C0E821   ADDU SP, S8, ZERO
9D00A5B0  8FBE000C   LW S8, 12(SP)
9D00A5B4  27BD0010   ADDIU SP, SP, 16
9D00A5B8  03E00008   JR RA
9D00A5BC  00000000   NOP
57:                  
58:                  void UartPutch(UART_MODULE channel, char c){
9D00A5C0  27BDFFE8   ADDIU SP, SP, -24
9D00A5C4  AFBE0014   SW S8, 20(SP)
9D00A5C8  03A0F021   ADDU S8, SP, ZERO
9D00A5CC  AFC40018   SW A0, 24(S8)
9D00A5D0  00A01021   ADDU V0, A1, ZERO
9D00A5D4  A3C2001C   SB V0, 28(S8)
59:                  /*Envoie d'un caractère*/
60:                      while(!UARTTransmitterIsReady(channel));
9D00A5D8  8FC20018   LW V0, 24(S8)
9D00A5DC  AFC20000   SW V0, 0(S8)
9D00A618  1040FFEF   BEQ V0, ZERO, 0x9D00A5D8
9D00A61C  00000000   NOP
61:                        UARTSendDataByte(channel, c);
9D00A620  93C2001C   LBU V0, 28(S8)
9D00A624  8FC30018   LW V1, 24(S8)
9D00A628  AFC30004   SW V1, 4(S8)
9D00A62C  A3C20008   SB V0, 8(S8)
62:                  };
9D00A650  03C0E821   ADDU SP, S8, ZERO
9D00A654  8FBE0014   LW S8, 20(SP)
9D00A658  27BD0018   ADDIU SP, SP, 24
9D00A65C  03E00008   JR RA
9D00A660  00000000   NOP
63:                  
64:                  char UartWaitch(UART_MODULE channel, int delay){
9D00A664  27BDFFD0   ADDIU SP, SP, -48
9D00A668  AFBF002C   SW RA, 44(SP)
9D00A66C  AFBE0028   SW S8, 40(SP)
9D00A670  03A0F021   ADDU S8, SP, ZERO
9D00A674  AFC40030   SW A0, 48(S8)
9D00A678  AFC50034   SW A1, 52(S8)
65:                  /*attend un caractère pour un temps spécifié par delay
66:                  *retourne 0 si aucun reçu avant expiration du délais
67:                  */
68:                      int t;
69:                      char ch;
70:                      if (!unget==-1){
71:                          ch=unget;
72:                          unget=-1;
73:                          return unget;
74:                      }
75:                      if (!delay) while (1) if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D00A67C  8FC20034   LW V0, 52(S8)
9D00A680  1440001D   BNE V0, ZERO, 0x9D00A6F8
9D00A684  00000000   NOP
9D00A688  0B4029A5   J 0x9D00A694
9D00A68C  00000000   NOP
9D00A694  8FC20030   LW V0, 48(S8)
9D00A698  AFC20014   SW V0, 20(S8)
9D00A6BC  1040FFF4   BEQ V0, ZERO, 0x9D00A690
9D00A6C0  00000000   NOP
9D00A6C4  8FC20030   LW V0, 48(S8)
9D00A6C8  AFC20018   SW V0, 24(S8)
9D00A6EC  7C021420   SEB V0, V0
9D00A6F0  0B4029E7   J 0x9D00A79C
9D00A6F4  00000000   NOP
76:                      t=ticks()+delay;
9D00A690  00000000   NOP
9D00A6F8  0F402BC1   JAL ticks
9D00A6FC  00000000   NOP
9D00A700  00401821   ADDU V1, V0, ZERO
9D00A704  8FC20034   LW V0, 52(S8)
9D00A708  00621021   ADDU V0, V1, V0
9D00A70C  AFC20010   SW V0, 16(S8)
77:                      while (ticks()<delay){
9D00A710  0B4029DF   J 0x9D00A77C
9D00A714  00000000   NOP
9D00A718  8FC20030   LW V0, 48(S8)
9D00A71C  AFC2001C   SW V0, 28(S8)
9D00A77C  0F402BC1   JAL ticks
9D00A780  00000000   NOP
9D00A784  00401821   ADDU V1, V0, ZERO
9D00A788  8FC20034   LW V0, 52(S8)
9D00A78C  0062102B   SLTU V0, V1, V0
9D00A790  1440FFE1   BNE V0, ZERO, 0x9D00A718
9D00A794  00000000   NOP
78:                         if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D00A740  1040000E   BEQ V0, ZERO, 0x9D00A77C
9D00A744  00000000   NOP
9D00A748  8FC20030   LW V0, 48(S8)
9D00A74C  AFC20020   SW V0, 32(S8)
9D00A770  7C021420   SEB V0, V0
9D00A774  0B4029E7   J 0x9D00A79C
9D00A778  00000000   NOP
79:                      }
80:                      return 0;
9D00A798  00001021   ADDU V0, ZERO, ZERO
81:                  }
9D00A79C  03C0E821   ADDU SP, S8, ZERO
9D00A7A0  8FBF002C   LW RA, 44(SP)
9D00A7A4  8FBE0028   LW S8, 40(SP)
9D00A7A8  27BD0030   ADDIU SP, SP, 48
9D00A7AC  03E00008   JR RA
9D00A7B0  00000000   NOP
82:                  
83:                  void UartPrint(UART_MODULE channel, const char* str){
9D00A7B4  27BDFFE8   ADDIU SP, SP, -24
9D00A7B8  AFBE0014   SW S8, 20(SP)
9D00A7BC  03A0F021   ADDU S8, SP, ZERO
9D00A7C0  AFC40018   SW A0, 24(S8)
9D00A7C4  AFC5001C   SW A1, 28(S8)
84:                  /* envoie la chaine de caractère str via le UART */
85:                     while(*str != (char)0)
9D00A7C8  0B402A17   J 0x9D00A85C
9D00A7CC  00000000   NOP
9D00A85C  8FC2001C   LW V0, 28(S8)
9D00A860  80420000   LB V0, 0(V0)
9D00A864  1440FFDA   BNE V0, ZERO, 0x9D00A7D0
9D00A868  00000000   NOP
86:                     {
87:                        while(!UARTTransmitterIsReady(channel));
9D00A7D0  8FC20018   LW V0, 24(S8)
9D00A7D4  AFC20000   SW V0, 0(S8)
9D00A810  1040FFEF   BEQ V0, ZERO, 0x9D00A7D0
9D00A814  00000000   NOP
88:                        UARTSendDataByte(channel, *str++);
9D00A818  8FC2001C   LW V0, 28(S8)
9D00A81C  80420000   LB V0, 0(V0)
9D00A820  304200FF   ANDI V0, V0, 255
9D00A824  8FC3001C   LW V1, 28(S8)
9D00A828  24630001   ADDIU V1, V1, 1
9D00A82C  AFC3001C   SW V1, 28(S8)
9D00A830  8FC30018   LW V1, 24(S8)
9D00A834  AFC30004   SW V1, 4(S8)
9D00A838  A3C20008   SB V0, 8(S8)
89:                     }
90:                     while(!UARTTransmissionHasCompleted(channel));
9D00A86C  8FC20018   LW V0, 24(S8)
9D00A870  AFC2000C   SW V0, 12(S8)
9D00A8AC  1040FFEF   BEQ V0, ZERO, 0x9D00A86C
9D00A8B0  00000000   NOP
91:                  };
9D00A8B4  03C0E821   ADDU SP, S8, ZERO
9D00A8B8  8FBE0014   LW S8, 20(SP)
9D00A8BC  27BD0018   ADDIU SP, SP, 24
9D00A8C0  03E00008   JR RA
9D00A8C4  00000000   NOP
92:                  
93:                  int UartReadln(UART_MODULE channel, char *buffer, int buff_len){
9D00A8C8  27BDFFD8   ADDIU SP, SP, -40
9D00A8CC  AFBF0024   SW RA, 36(SP)
9D00A8D0  AFBE0020   SW S8, 32(SP)
9D00A8D4  03A0F021   ADDU S8, SP, ZERO
9D00A8D8  AFC40028   SW A0, 40(S8)
9D00A8DC  AFC5002C   SW A1, 44(S8)
9D00A8E0  AFC60030   SW A2, 48(S8)
94:                  /* lecture d'une chaine se terminant par '\r'
95:                   *  complète la chaine avec un zéro
96:                   *  retourne le nombre de caractère dans le buffer.
97:                   */
98:                      int count=0;
9D00A8E4  AFC00010   SW ZERO, 16(S8)
99:                      char c;
100:                     if (!unget==-1){
101:                         c=unget;
102:                         unget=-1;
103:                         *buffer++=c;
104:                         if (c==CR) return;
105:                     }
106:                     while (count < (buff_len-1)){
9D00A8E8  0B402A79   J 0x9D00A9E4
9D00A8EC  00000000   NOP
9D00A8F0  8FC20028   LW V0, 40(S8)
9D00A8F4  AFC20018   SW V0, 24(S8)
9D00A9E4  8FC20030   LW V0, 48(S8)
9D00A9E8  2443FFFF   ADDIU V1, V0, -1
9D00A9EC  8FC20010   LW V0, 16(S8)
9D00A9F0  0043102A   SLT V0, V0, V1
9D00A9F4  1440FFBE   BNE V0, ZERO, 0x9D00A8F0
9D00A9F8  00000000   NOP
9D00A9FC  0B402A82   J 0x9D00AA08
9D00AA00  00000000   NOP
107:                         if (UARTReceivedDataIsAvailable(channel)){
9D00A918  10400032   BEQ V0, ZERO, 0x9D00A9E4
9D00A91C  00000000   NOP
9D00A920  8FC20028   LW V0, 40(S8)
9D00A924  AFC2001C   SW V0, 28(S8)
108:                             c = UARTGetDataByte(channel);
9D00A948  A3C20014   SB V0, 20(S8)
109:                             if (c==CR) break;
9D00A94C  83C30014   LB V1, 20(S8)
9D00A950  2402000D   ADDIU V0, ZERO, 13
9D00A954  1062002B   BEQ V1, V0, 0x9D00AA04
9D00A958  00000000   NOP
9D00AA04  00000000   NOP
110:                             if (c==BS){
9D00A95C  83C30014   LB V1, 20(S8)
9D00A960  24020008   ADDIU V0, ZERO, 8
9D00A964  14620011   BNE V1, V0, 0x9D00A9AC
9D00A968  00000000   NOP
111:                                 if (count){
9D00A96C  8FC20010   LW V0, 16(S8)
9D00A970  1040001C   BEQ V0, ZERO, 0x9D00A9E4
9D00A974  00000000   NOP
112:                                     buffer--;
9D00A978  8FC2002C   LW V0, 44(S8)
9D00A97C  2442FFFF   ADDIU V0, V0, -1
9D00A980  AFC2002C   SW V0, 44(S8)
113:                                     count--;
9D00A984  8FC20010   LW V0, 16(S8)
9D00A988  2442FFFF   ADDIU V0, V0, -1
9D00A98C  AFC20010   SW V0, 16(S8)
114:                                     UartPrint(channel,"\b \b");
9D00A990  8FC40028   LW A0, 40(S8)
9D00A994  3C029D01   LUI V0, -25343
9D00A998  2445CE14   ADDIU A1, V0, -12780
9D00A99C  0F4029ED   JAL UartPrint
9D00A9A0  00000000   NOP
9D00A9A4  0B402A79   J 0x9D00A9E4
9D00A9A8  00000000   NOP
115:                                 }
116:                             }else{
117:                                 *buffer++=c;
9D00A9AC  8FC2002C   LW V0, 44(S8)
9D00A9B0  93C30014   LBU V1, 20(S8)
9D00A9B4  A0430000   SB V1, 0(V0)
9D00A9B8  8FC2002C   LW V0, 44(S8)
9D00A9BC  24420001   ADDIU V0, V0, 1
9D00A9C0  AFC2002C   SW V0, 44(S8)
118:                                 count++;
9D00A9C4  8FC20010   LW V0, 16(S8)
9D00A9C8  24420001   ADDIU V0, V0, 1
9D00A9CC  AFC20010   SW V0, 16(S8)
119:                                 UartPutch(channel,c);
9D00A9D0  83C20014   LB V0, 20(S8)
9D00A9D4  8FC40028   LW A0, 40(S8)
9D00A9D8  00402821   ADDU A1, V0, ZERO
9D00A9DC  0F402970   JAL UartPutch
9D00A9E0  00000000   NOP
120:                             }
121:                             
122:                         }
123:                     }
124:                     if (count) *buffer = (char)0;
9D00AA08  8FC20010   LW V0, 16(S8)
9D00AA0C  10400003   BEQ V0, ZERO, 0x9D00AA1C
9D00AA10  00000000   NOP
9D00AA14  8FC2002C   LW V0, 44(S8)
9D00AA18  A0400000   SB ZERO, 0(V0)
125:                     UartPutch(channel,'\r');
9D00AA1C  8FC40028   LW A0, 40(S8)
9D00AA20  2405000D   ADDIU A1, ZERO, 13
9D00AA24  0F402970   JAL UartPutch
9D00AA28  00000000   NOP
126:                     return count;
9D00AA2C  8FC20010   LW V0, 16(S8)
127:                 }
9D00AA30  03C0E821   ADDU SP, S8, ZERO
9D00AA34  8FBF0024   LW RA, 36(SP)
9D00AA38  8FBE0020   LW S8, 32(SP)
9D00AA3C  27BD0028   ADDIU SP, SP, 40
9D00AA40  03E00008   JR RA
9D00AA44  00000000   NOP
128:                 
129:                 int UartReceivedBreak(UART_MODULE channel){
9D00AA48  27BDFFE8   ADDIU SP, SP, -24
9D00AA4C  AFBE0014   SW S8, 20(SP)
9D00AA50  03A0F021   ADDU S8, SP, ZERO
9D00AA54  AFC40018   SW A0, 24(S8)
130:                    char ch;
131:                    if (unget==-1 && UARTReceivedDataIsAvailable(channel)) {
9D00AA58  83838014   LB V1, -32748(GP)
9D00AA5C  2402FFFF   ADDIU V0, ZERO, -1
9D00AA60  14620021   BNE V1, V0, 0x9D00AAE8
9D00AA64  00000000   NOP
9D00AA68  8FC20018   LW V0, 24(S8)
9D00AA6C  AFC20004   SW V0, 4(S8)
9D00AA90  10400015   BEQ V0, ZERO, 0x9D00AAE8
9D00AA94  00000000   NOP
9D00AA98  8FC20018   LW V0, 24(S8)
9D00AA9C  AFC20008   SW V0, 8(S8)
132:                        ch=UARTGetDataByte(channel);
9D00AAC0  A3C20000   SB V0, 0(S8)
133:                        if (ch==ESC) return 1; else unget=ch;
9D00AAC4  83C30000   LB V1, 0(S8)
9D00AAC8  2402001B   ADDIU V0, ZERO, 27
9D00AACC  14620004   BNE V1, V0, 0x9D00AAE0
9D00AAD0  00000000   NOP
9D00AAD4  24020001   ADDIU V0, ZERO, 1
9D00AAD8  0B402ABB   J 0x9D00AAEC
9D00AADC  00000000   NOP
9D00AAE0  93C20000   LBU V0, 0(S8)
9D00AAE4  A3828014   SB V0, -32748(GP)
134:                    }
135:                    return 0;
9D00AAE8  00001021   ADDU V0, ZERO, ZERO
136:                 }
9D00AAEC  03C0E821   ADDU SP, S8, ZERO
9D00AAF0  8FBE0014   LW S8, 20(SP)
9D00AAF4  27BD0018   ADDIU SP, SP, 24
9D00AAF8  03E00008   JR RA
9D00AAFC  00000000   NOP
137:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/HardwareProfile.c  -----------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   HardwareProfile.h
21:                   * Author: Jacques Deschênes
22:                   * Description: configuration hardware spécifique, assignation des périphériques
23:                   *     UART2 assigné à PB10,PB11
24:                   * Created on 17 avril 2013, 14:41
25:                   *
26:                   */
27:                  
28:                  #include "HardwareProfile.h"
29:                  #include <plib.h>
30:                  #include "../sound.h"
31:                  
32:                  volatile unsigned int  sys_tick; // compteur pour les milli-secondes
33:                  
34:                  
35:                  void HardwareInit(){
9D00AB00  27BDFFA8   ADDIU SP, SP, -88
9D00AB04  AFBF0054   SW RA, 84(SP)
9D00AB08  AFBE0050   SW S8, 80(SP)
9D00AB0C  03A0F021   ADDU S8, SP, ZERO
9D00AB10  3C02023C   LUI V0, 572
9D00AB14  34423460   ORI V0, V0, 13408
9D00AB18  AFC20010   SW V0, 16(S8)
9D00AB1C  24020005   ADDIU V0, ZERO, 5
9D00AB20  AFC20014   SW V0, 20(S8)
36:                     SYSTEMConfig(mGetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
37:                     INTEnableSystemMultiVectoredInt();
9D00AD28  0F40333F   JAL INTEnableSystemMultiVectoredInt
9D00AD2C  00000000   NOP
38:                     // activation du PROXIMITY TIMER pour les interruption inférieures à IPL=7
39:                  //   INTCONbits.TPC=0;
40:                  //   IPTMRCLR=0xFFFFFFFF;
41:                  //   INTCONbits.TPC=7;
42:                  //   IPTMR=CORE_TICK_RATE/2;
43:                      // configure coretimer pour le sys_tick
44:                  #ifdef USE_CORE_TIMER
45:                     OpenCoreTimer(CORE_TICK_RATE);
9D00AD30  2404493E   ADDIU A0, ZERO, 18750
9D00AD34  0F403370   JAL OpenCoreTimer
9D00AD38  00000000   NOP
46:                     mConfigIntCoreTimer((CT_INT_ON | CT_INT_PRIOR_1 | CT_INT_SUB_PRIOR_0));
9D00AD3C  3C02BF88   LUI V0, -16504
9D00AD40  24030001   ADDIU V1, ZERO, 1
9D00AD44  AC431034   SW V1, 4148(V0)
9D00AD48  3C02BF88   LUI V0, -16504
9D00AD4C  2403001C   ADDIU V1, ZERO, 28
9D00AD50  AC431094   SW V1, 4244(V0)
9D00AD54  3C02BF88   LUI V0, -16504
9D00AD58  24030004   ADDIU V1, ZERO, 4
9D00AD5C  AC431098   SW V1, 4248(V0)
9D00AD60  3C02BF88   LUI V0, -16504
9D00AD64  24030003   ADDIU V1, ZERO, 3
9D00AD68  AC431094   SW V1, 4244(V0)
9D00AD6C  3C02BF88   LUI V0, -16504
9D00AD70  AC401098   SW ZERO, 4248(V0)
9D00AD74  3C02BF88   LUI V0, -16504
9D00AD78  24030001   ADDIU V1, ZERO, 1
9D00AD7C  AC431064   SW V1, 4196(V0)
9D00AD80  3C02BF88   LUI V0, -16504
9D00AD84  24030001   ADDIU V1, ZERO, 1
9D00AD88  AC431068   SW V1, 4200(V0)
47:                  #endif
48:                     // désactivation de toutes les entrée analogiques.
49:                     ANSELBCLR=0xFFFFFFFF;
9D00AD8C  3C02BF88   LUI V0, -16504
9D00AD90  2403FFFF   ADDIU V1, ZERO, -1
9D00AD94  AC436104   SW V1, 24836(V0)
50:                     ANSELACLR=0xFFFFFFFF;
9D00AD98  3C02BF88   LUI V0, -16504
9D00AD9C  2403FFFF   ADDIU V1, ZERO, -1
9D00ADA0  AC436004   SW V1, 24580(V0)
51:                      // configuration PB10 sortie et PB11 entrée
52:                     mPORTBSetBits(TX); // mettre à Vdd pour ne pas généré un faux start bit.
9D00ADA4  3C02BF88   LUI V0, -16504
9D00ADA8  24030400   ADDIU V1, ZERO, 1024
9D00ADAC  AC436138   SW V1, 24888(V0)
53:                     mPORTBSetPinsDigitalOut(TX);      // sortie PB10(Tx), transmission UART2
9D00ADB0  3C02BF88   LUI V0, -16504
9D00ADB4  24030400   ADDIU V1, ZERO, 1024
9D00ADB8  AC436114   SW V1, 24852(V0)
9D00ADBC  3C02BF88   LUI V0, -16504
9D00ADC0  24030400   ADDIU V1, ZERO, 1024
9D00ADC4  AC436104   SW V1, 24836(V0)
54:                     mPORTBSetPinsDigitalIn (RX);      // entrée PB11(Rx), réception UART2
9D00ADC8  3C02BF88   LUI V0, -16504
9D00ADCC  24030800   ADDIU V1, ZERO, 2048
9D00ADD0  AC436118   SW V1, 24856(V0)
9D00ADD4  3C02BF88   LUI V0, -16504
9D00ADD8  24030800   ADDIU V1, ZERO, 2048
9D00ADDC  AC436104   SW V1, 24836(V0)
55:                     // assignation des périphériques aux broches
56:                     // l'information se trouve dans pps.h
57:                     PPSUnLock;                     // déverrouillage configuration assignation périphérique
58:                     //clavier
59:                     I2C1CONbits.DISSLW=1; // voir pic32mx1xxx/2xxx-errata.pdf rev. E, point 9
9D00ADE0  3C03BF80   LUI V1, -16512
9D00ADE4  8C625000   LW V0, 20480(V1)
9D00ADE8  24040001   ADDIU A0, ZERO, 1
9D00ADEC  7C824A44   INS V0, A0, 9, 1
9D00ADF0  AC625000   SW V0, 20480(V1)
60:                     RPA0R=0;  // pas de périphérique sur RA0 (keyboard clock)
9D00ADF4  3C02BF81   LUI V0, -16511
9D00ADF8  AC40FB00   SW ZERO, -1280(V0)
61:                     RPA1R=0;  // pas de périphérique sur RA1 (keyboard data)
9D00ADFC  3C02BF81   LUI V0, -16511
9D00AE00  AC40FB04   SW ZERO, -1276(V0)
62:                     RPB3R=0; //  pas de périphérique sur RB3 (status LED)
9D00AE04  3C02BF81   LUI V0, -16511
9D00AE08  AC40FB38   SW ZERO, -1224(V0)
63:                     RPB15R=0; // pad de périphérique sur RB15
9D00AE0C  3C02BF81   LUI V0, -16511
9D00AE10  AC40FB68   SW ZERO, -1176(V0)
64:                     TRISBCLR=STATUS_LED; // broche status LED en sortie
9D00AE14  3C02BF88   LUI V0, -16504
9D00AE18  24030008   ADDIU V1, ZERO, 8
9D00AE1C  AC436114   SW V1, 24852(V0)
65:                     _status_off();
9D00AE20  3C02BF88   LUI V0, -16504
9D00AE24  8C436120   LW V1, 24864(V0)
9D00AE28  2402FFF7   ADDIU V0, ZERO, -9
9D00AE2C  00621824   AND V1, V1, V0
9D00AE30  3C02BF88   LUI V0, -16504
9D00AE34  AC436120   SW V1, 24864(V0)
66:                     PPSOutput(4, RPB10, U2TX);  // assignation U2TX sur PB10, (groupe, pin, fonction)
9D00AE38  3C03BF81   LUI V1, -16511
9D00AE3C  8C62FB54   LW V0, -1196(V1)
9D00AE40  24040002   ADDIU A0, ZERO, 2
9D00AE44  7C821804   INS V0, A0, 0, 4
9D00AE48  AC62FB54   SW V0, -1196(V1)
67:                     PPSInput (2, U2RX, RPB11);  // assignation U2RX sur PB11, (groupe, fonction, pin)
9D00AE4C  3C03BF81   LUI V1, -16511
9D00AE50  8C62FA58   LW V0, -1448(V1)
9D00AE54  24040003   ADDIU A0, ZERO, 3
9D00AE58  7C821804   INS V0, A0, 0, 4
9D00AE5C  AC62FA58   SW V0, -1448(V1)
68:                     PPSOutput(2,RPB5,OC2); // 5=OC2  sur PB5 sortie synchronistaiton ntsc
9D00AE60  3C03BF81   LUI V1, -16511
9D00AE64  8C62FB40   LW V0, -1216(V1)
9D00AE68  24040005   ADDIU A0, ZERO, 5
9D00AE6C  7C821804   INS V0, A0, 0, 4
9D00AE70  AC62FB40   SW V0, -1216(V1)
69:                     PPSOutput(1,RPB4,OC1);  // 5=OC1 impulsion déclenchant SPI , Fsync vidéo
9D00AE74  3C03BF81   LUI V1, -16511
9D00AE78  8C62FB3C   LW V0, -1220(V1)
9D00AE7C  24040005   ADDIU A0, ZERO, 5
9D00AE80  7C821804   INS V0, A0, 0, 4
9D00AE84  AC62FB3C   SW V0, -1220(V1)
70:                     PPSOutput(3,RPB6,SDO1); // 3=SDO1 sortie SPI1 (vidéo)
9D00AE88  3C03BF81   LUI V1, -16511
9D00AE8C  8C62FB44   LW V0, -1212(V1)
9D00AE90  24040003   ADDIU A0, ZERO, 3
9D00AE94  7C821804   INS V0, A0, 0, 4
9D00AE98  AC62FB44   SW V0, -1212(V1)
71:                     PPSOutput(4,RPB9,OC3); // OC3 sortie audio.
9D00AE9C  3C03BF81   LUI V1, -16511
9D00AEA0  8C62FB50   LW V0, -1200(V1)
9D00AEA4  24040005   ADDIU A0, ZERO, 5
9D00AEA8  7C821804   INS V0, A0, 0, 4
9D00AEAC  AC62FB50   SW V0, -1200(V1)
72:                     PPSInput(1,SS1,RPB7); // entrée Fsync sur RPB7
9D00AEB0  3C03BF81   LUI V1, -16511
9D00AEB4  8C62FA88   LW V0, -1400(V1)
9D00AEB8  24040004   ADDIU A0, ZERO, 4
9D00AEBC  7C821804   INS V0, A0, 0, 4
9D00AEC0  AC62FA88   SW V0, -1400(V1)
73:                     PPSInput(3,SDI2,RPA4); // entrée SDI pour carte SD
9D00AEC4  3C03BF81   LUI V1, -16511
9D00AEC8  8C62FA90   LW V0, -1392(V1)
9D00AECC  24040002   ADDIU A0, ZERO, 2
9D00AED0  7C821804   INS V0, A0, 0, 4
9D00AED4  AC62FA90   SW V0, -1392(V1)
74:                     PPSOutput(2,RPB8,SDO2); // sortie commande carte SD
9D00AED8  3C03BF81   LUI V1, -16511
9D00AEDC  8C62FB4C   LW V0, -1204(V1)
9D00AEE0  24040004   ADDIU A0, ZERO, 4
9D00AEE4  7C821804   INS V0, A0, 0, 4
9D00AEE8  AC62FB4C   SW V0, -1204(V1)
75:                     PPSLock;                       // reverrouille pour éviter assignation accidentelle.
76:                  }
9D00AEEC  03C0E821   ADDU SP, S8, ZERO
9D00AEF0  8FBF0054   LW RA, 84(SP)
9D00AEF4  8FBE0050   LW S8, 80(SP)
9D00AEF8  27BD0058   ADDIU SP, SP, 88
9D00AEFC  03E00008   JR RA
9D00AF00  00000000   NOP
77:                  
78:                  inline unsigned int ticks(void){
9D00AF04  27BDFFF8   ADDIU SP, SP, -8
9D00AF08  AFBE0004   SW S8, 4(SP)
9D00AF0C  03A0F021   ADDU S8, SP, ZERO
79:                      return sys_tick;
9D00AF10  8F828020   LW V0, -32736(GP)
80:                  } //ticks()
9D00AF14  03C0E821   ADDU SP, S8, ZERO
9D00AF18  8FBE0004   LW S8, 4(SP)
9D00AF1C  27BD0008   ADDIU SP, SP, 8
9D00AF20  03E00008   JR RA
9D00AF24  00000000   NOP
81:                  
82:                  inline void delay_us(unsigned int usec){
9D00AF28  27BDFFF8   ADDIU SP, SP, -8
9D00AF2C  AFBE0004   SW S8, 4(SP)
9D00AF30  03A0F021   ADDU S8, SP, ZERO
9D00AF34  AFC40008   SW A0, 8(S8)
83:                      for (usec=usec*(CLK_PER_USEC/3);usec;usec--);
9D00AF38  8FC30008   LW V1, 8(S8)
9D00AF3C  2402000C   ADDIU V0, ZERO, 12
9D00AF40  70621002   MUL V0, V1, V0
9D00AF44  AFC20008   SW V0, 8(S8)
9D00AF48  0B402BD7   J 0x9D00AF5C
9D00AF4C  00000000   NOP
9D00AF50  8FC20008   LW V0, 8(S8)
9D00AF54  2442FFFF   ADDIU V0, V0, -1
9D00AF58  AFC20008   SW V0, 8(S8)
9D00AF5C  8FC20008   LW V0, 8(S8)
9D00AF60  1440FFFB   BNE V0, ZERO, 0x9D00AF50
9D00AF64  00000000   NOP
84:                  }//delay_us()
9D00AF68  03C0E821   ADDU SP, S8, ZERO
9D00AF6C  8FBE0004   LW S8, 4(SP)
9D00AF70  27BD0008   ADDIU SP, SP, 8
9D00AF74  03E00008   JR RA
9D00AF78  00000000   NOP
85:                  
86:                  void delay_ms(unsigned int msec){
9D00AF7C  27BDFFF0   ADDIU SP, SP, -16
9D00AF80  AFBE000C   SW S8, 12(SP)
9D00AF84  03A0F021   ADDU S8, SP, ZERO
9D00AF88  AFC40010   SW A0, 16(S8)
87:                  #ifdef USE_CORE_TIMER
88:                      unsigned int t0;
89:                      t0=sys_tick+msec;
9D00AF8C  8F838020   LW V1, -32736(GP)
9D00AF90  8FC20010   LW V0, 16(S8)
9D00AF94  00621021   ADDU V0, V1, V0
9D00AF98  AFC20000   SW V0, 0(S8)
90:                      while (sys_tick!=t0);
9D00AF9C  00000000   NOP
9D00AFA0  8F838020   LW V1, -32736(GP)
9D00AFA4  8FC20000   LW V0, 0(S8)
9D00AFA8  1462FFFD   BNE V1, V0, 0x9D00AFA0
9D00AFAC  00000000   NOP
91:                  #else
92:                      while (msec--)
93:                          delay_us(1000);
94:                  #endif
95:                  } // delay_ms()
9D00AFB0  03C0E821   ADDU SP, S8, ZERO
9D00AFB4  8FBE000C   LW S8, 12(SP)
9D00AFB8  27BD0010   ADDIU SP, SP, 16
9D00AFBC  03E00008   JR RA
9D00AFC0  00000000   NOP
96:                  
97:                  #ifdef USE_CORE_TIMER
98:                    //déclaration du gestionnaire d'interruption
99:                     void __ISR(_CORE_TIMER_VECTOR, IPL1SOFT)  CoreTimerHandler(void){
9D00AFC4  415DE800   RDPGPR SP, SP
9D00AFC8  401A7000   MFC0 K0, EPC
9D00AFCC  401B6000   MFC0 K1, Status
9D00AFD0  27BDFFE0   ADDIU SP, SP, -32
9D00AFD4  AFBA001C   SW K0, 28(SP)
9D00AFD8  401A6002   MFC0 K0, SRSCtl
9D00AFDC  AFBB0018   SW K1, 24(SP)
9D00AFE0  AFBA0014   SW K0, 20(SP)
9D00AFE4  7C1B7844   INS K1, ZERO, 1, 15
9D00AFE8  377B0400   ORI K1, K1, 1024
9D00AFEC  409B6000   MTC0 K1, Status
9D00AFF0  AFBE000C   SW S8, 12(SP)
9D00AFF4  AFA30008   SW V1, 8(SP)
9D00AFF8  AFA20004   SW V0, 4(SP)
9D00AFFC  03A0F021   ADDU S8, SP, ZERO
100:                        sys_tick++;
9D00B000  8F828020   LW V0, -32736(GP)
9D00B004  24420001   ADDIU V0, V0, 1
9D00B008  AF828020   SW V0, -32736(GP)
101:                        __asm__("mfc0 $v0, $11");
9D00B00C  40025800   MFC0 V0, Compare
102:                        __asm__("addiu $v0,$v0,%0"::"I"(CORE_TICK_RATE));
9D00B010  2442493E   ADDIU V0, V0, 18750
103:                        __asm__("mtc0 $v0, $11");
9D00B014  40825800   MTC0 V0, Compare
104:                        if (tone_on && !(--duration)){
9D00B018  93828015   LBU V0, -32747(GP)
9D00B01C  304200FF   ANDI V0, V0, 255
9D00B020  1040000C   BEQ V0, ZERO, 0x9D00B054
9D00B024  00000000   NOP
9D00B028  8F828024   LW V0, -32732(GP)
9D00B02C  2442FFFF   ADDIU V0, V0, -1
9D00B030  AF828024   SW V0, -32732(GP)
9D00B034  8F828024   LW V0, -32732(GP)
9D00B038  14400006   BNE V0, ZERO, 0x9D00B054
9D00B03C  00000000   NOP
105:                                mTone_off();
9D00B040  3C03BF80   LUI V1, -16512
9D00B044  8C623400   LW V0, 13312(V1)
9D00B048  7C027BC4   INS V0, ZERO, 15, 1
9D00B04C  AC623400   SW V0, 13312(V1)
106:                                tone_on=0;
9D00B050  A3808015   SB ZERO, -32747(GP)
107:                        }
108:                        mCTClearIntFlag();
9D00B054  3C02BF88   LUI V0, -16504
9D00B058  24030001   ADDIU V1, ZERO, 1
9D00B05C  AC431034   SW V1, 4148(V0)
109:                    };
9D00B060  03C0E821   ADDU SP, S8, ZERO
9D00B064  8FBE000C   LW S8, 12(SP)
9D00B068  8FA30008   LW V1, 8(SP)
9D00B06C  8FA20004   LW V0, 4(SP)
9D00B070  41606000   DI ZERO
9D00B074  000000C0   EHB
9D00B078  8FBA001C   LW K0, 28(SP)
9D00B07C  8FBB0018   LW K1, 24(SP)
9D00B080  409A7000   MTC0 K0, EPC
9D00B084  8FBA0014   LW K0, 20(SP)
9D00B088  27BD0020   ADDIU SP, SP, 32
9D00B08C  409A6002   MTC0 K0, SRSCtl
9D00B090  41DDE800   WRPGPR SP, SP
9D00B094  409B6000   MTC0 K1, Status
9D00B098  42000018   ERET
110:                 #endif
111:                 
---  /Volumes/home/c11067/xc32/build/gcc/libgcc2.c  -----------------------------------------------------
9D00B09C  00C04021   ADDU T0, A2, ZERO
9D00B4FC  00C01021   ADDU V0, A2, ZERO
9D00B0A0  00804821   ADDU T1, A0, ZERO
9D00B500  00804021   ADDU T0, A0, ZERO
9D00B0A4  14E0003B   BNE A3, ZERO, 0x9D00B194
9D00B0A8  00A01821   ADDU V1, A1, ZERO
9D00B504  14E0003D   BNE A3, ZERO, 0x9D00B5FC
9D00B508  00A01821   ADDU V1, A1, ZERO
9D00B0AC  00A6102B   SLTU V0, A1, A2
9D00B0B0  10400048   BEQ V0, ZERO, 0x9D00B1D4
9D00B0B4  70C21020   CLZ V0, A2
9D00B50C  00A6302B   SLTU A2, A1, A2
9D00B510  10C00046   BEQ A2, ZERO, 0x9D00B62C
9D00B514  00000000   NOP
9D00B518  70442020   CLZ A0, V0
9D00B0B8  50400008   BEQL V0, ZERO, 0x9D00B0DC
9D00B0BC  00083402   SRL A2, T0, 16
9D00B51C  10800008   BEQ A0, ZERO, 0x9D00B540
9D00B520  00022C02   SRL A1, V0, 16
9D00B0CC  00464004   SLLV T0, A2, V0
9D00B530  00821004   SLLV V0, V0, A0
9D00B0C0  00022023   SUBU A0, ZERO, V0
9D00B0C4  00892006   SRLV A0, T1, A0
9D00B0C8  00451804   SLLV V1, A1, V0
9D00B0D0  00831825   OR V1, A0, V1
9D00B524  00042823   SUBU A1, ZERO, A0
9D00B528  00A82806   SRLV A1, T0, A1
9D00B52C  00831804   SLLV V1, V1, A0
9D00B534  00A31825   OR V1, A1, V1
9D00B0D4  00494804   SLLV T1, T1, V0
9D00B538  00884004   SLLV T0, T0, A0
9D00B0D8  00083402   SRL A2, T0, 16
9D00B0DC  0066001B   DIVU V1, A2
9D00B0E0  00C001F4   TEQ A2, ZERO
9D00B0E4  310CFFFF   ANDI T4, T0, -1
9D00B0E8  00092402   SRL A0, T1, 16
9D00B0EC  00005812   MFLO T3, 0
9D00B0F0  00005010   MFHI T2, 0
9D00B0F4  000A5400   SLL T2, T2, 16
9D00B0F8  01445025   OR T2, T2, A0
9D00B0FC  716C5802   MUL T3, T3, T4
9D00B100  014B682B   SLTU T5, T2, T3
9D00B104  0066001B   DIVU V1, A2
9D00B108  00C001F4   TEQ A2, ZERO
9D00B10C  51A00009   BEQL T5, ZERO, 0x9D00B134
9D00B110  014B5023   SUBU T2, T2, T3
9D00B114  01485021   ADDU T2, T2, T0
9D00B118  0148182B   SLTU V1, T2, T0
9D00B11C  54600005   BNEL V1, ZERO, 0x9D00B134
9D00B120  014B5023   SUBU T2, T2, T3
9D00B124  014B182B   SLTU V1, T2, T3
9D00B128  70682002   MUL A0, V1, T0
9D00B12C  008A5021   ADDU T2, A0, T2
9D00B130  014B5023   SUBU T2, T2, T3
9D00B134  0146001B   DIVU T2, A2
9D00B138  00C001F4   TEQ A2, ZERO
9D00B13C  3129FFFF   ANDI T1, T1, -1
9D00B140  00002012   MFLO A0, 0
9D00B144  00001810   MFHI V1, 0
9D00B148  00031C00   SLL V1, V1, 16
9D00B14C  00694825   OR T1, V1, T1
9D00B150  708C2002   MUL A0, A0, T4
9D00B154  0124182B   SLTU V1, T1, A0
9D00B158  0146001B   DIVU T2, A2
9D00B15C  00C001F4   TEQ A2, ZERO
9D00B160  50600009   BEQL V1, ZERO, 0x9D00B188
9D00B164  01244823   SUBU T1, T1, A0
9D00B168  01284821   ADDU T1, T1, T0
9D00B16C  0128182B   SLTU V1, T1, T0
9D00B170  54600005   BNEL V1, ZERO, 0x9D00B188
9D00B174  01244823   SUBU T1, T1, A0
9D00B178  0124182B   SLTU V1, T1, A0
9D00B17C  70682802   MUL A1, V1, T0
9D00B180  00A94821   ADDU T1, A1, T1
9D00B184  01244823   SUBU T1, T1, A0
9D00B53C  00022C02   SRL A1, V0, 16
9D00B540  0065001B   DIVU V1, A1
9D00B544  00A001F4   TEQ A1, ZERO
9D00B548  304AFFFF   ANDI T2, V0, -1
9D00B54C  00085C02   SRL T3, T0, 16
9D00B550  00004812   MFLO T1, 0
9D00B554  00003810   MFHI A3, 0
9D00B558  00073C00   SLL A3, A3, 16
9D00B55C  00EB3825   OR A3, A3, T3
9D00B560  712A2002   MUL A0, T1, T2
9D00B564  00E4302B   SLTU A2, A3, A0
9D00B568  0065001B   DIVU V1, A1
9D00B56C  00A001F4   TEQ A1, ZERO
9D00B570  10C0000B   BEQ A2, ZERO, 0x9D00B5A0
9D00B574  00E41823   SUBU V1, A3, A0
9D00B578  00E23821   ADDU A3, A3, V0
9D00B57C  00E2182B   SLTU V1, A3, V0
9D00B580  14600006   BNE V1, ZERO, 0x9D00B59C
9D00B584  2529FFFF   ADDIU T1, T1, -1
9D00B588  00E4182B   SLTU V1, A3, A0
9D00B58C  10600004   BEQ V1, ZERO, 0x9D00B5A0
9D00B590  00E41823   SUBU V1, A3, A0
9D00B594  2529FFFF   ADDIU T1, T1, -1
9D00B598  00E23821   ADDU A3, A3, V0
9D00B59C  00E41823   SUBU V1, A3, A0
9D00B5A0  0065001B   DIVU V1, A1
9D00B5A4  00A001F4   TEQ A1, ZERO
9D00B5A8  3108FFFF   ANDI T0, T0, -1
9D00B5AC  00002012   MFLO A0, 0
9D00B5B0  00003010   MFHI A2, 0
9D00B5B4  00063400   SLL A2, A2, 16
9D00B5B8  00C84025   OR T0, A2, T0
9D00B5BC  708A5002   MUL T2, A0, T2
9D00B5C0  010A302B   SLTU A2, T0, T2
9D00B5C4  0065001B   DIVU V1, A1
9D00B5C8  00A001F4   TEQ A1, ZERO
9D00B5CC  10C00006   BEQ A2, ZERO, 0x9D00B5E8
9D00B5D0  01024021   ADDU T0, T0, V0
9D00B5D4  0102102B   SLTU V0, T0, V0
9D00B5D8  14400003   BNE V0, ZERO, 0x9D00B5E8
9D00B5DC  2484FFFF   ADDIU A0, A0, -1
9D00B5E0  010A502B   SLTU T2, T0, T2
9D00B5E4  008A2023   SUBU A0, A0, T2
9D00B5E8  00094C00   SLL T1, T1, 16
9D00B5EC  00892025   OR A0, A0, T1
9D00B5F0  00001821   ADDU V1, ZERO, ZERO
9D00B1D4  14C00006   BNE A2, ZERO, 0x9D00B1F0
9D00B1D8  71021020   CLZ V0, T0
9D00B62C  14400006   BNE V0, ZERO, 0x9D00B648
9D00B630  70463020   CLZ A2, V0
9D00B1DC  24020001   ADDIU V0, ZERO, 1
9D00B1E0  0046001B   DIVU V0, A2
9D00B1E4  00C001F4   TEQ A2, ZERO
9D00B1E8  00004012   MFLO T0, 0
9D00B634  24030001   ADDIU V1, ZERO, 1
9D00B638  0062001B   DIVU V1, V0
9D00B63C  004001F4   TEQ V0, ZERO
9D00B640  00001012   MFLO V0, 0
9D00B1EC  71021020   CLZ V0, T0
9D00B644  70463020   CLZ A2, V0
9D00B1F0  5440007C   BNEL V0, ZERO, 0x9D00B3E4
9D00B1F4  24090020   ADDIU T1, ZERO, 32
9D00B648  54C00077   BNEL A2, ZERO, 0x9D00B828
9D00B64C  24080020   ADDIU T0, ZERO, 32
9D00B1F8  00A82823   SUBU A1, A1, T0
9D00B1FC  00081C02   SRL V1, T0, 16
9D00B200  3107FFFF   ANDI A3, T0, -1
9D00B650  00A24823   SUBU T1, A1, V0
9D00B654  00023C02   SRL A3, V0, 16
9D00B658  304CFFFF   ANDI T4, V0, -1
9D00B65C  24030001   ADDIU V1, ZERO, 1
9D00B3E4  01224823   SUBU T1, T1, V0
9D00B82C  01064023   SUBU T0, T0, A2
9D00B3E8  00484004   SLLV T0, T0, V0
9D00B828  00C21004   SLLV V0, V0, A2
9D00B3EC  01253006   SRLV A2, A1, T1
9D00B830  01055006   SRLV T2, A1, T0
9D00B400  01245806   SRLV T3, A0, T1
9D00B404  00452804   SLLV A1, A1, V0
9D00B408  01655825   OR T3, T3, A1
9D00B840  01044006   SRLV T0, A0, T0
9D00B844  00C52804   SLLV A1, A1, A2
9D00B84C  01052825   OR A1, T0, A1
9D00B410  00444804   SLLV T1, A0, V0
9D00B850  00C44004   SLLV T0, A0, A2
9D00B3F0  00081C02   SRL V1, T0, 16
9D00B3F4  00C3001B   DIVU A2, V1
9D00B3F8  006001F4   TEQ V1, ZERO
9D00B3FC  3107FFFF   ANDI A3, T0, -1
9D00B40C  000B2C02   SRL A1, T3, 16
9D00B414  00005012   MFLO T2, 0
9D00B418  00006010   MFHI T4, 0
9D00B41C  000C2400   SLL A0, T4, 16
9D00B420  00A42025   OR A0, A1, A0
9D00B424  71475002   MUL T2, T2, A3
9D00B428  008A282B   SLTU A1, A0, T2
9D00B42C  00C3001B   DIVU A2, V1
9D00B430  006001F4   TEQ V1, ZERO
9D00B434  50A00006   BEQL A1, ZERO, 0x9D00B450
9D00B438  008A2023   SUBU A0, A0, T2
9D00B43C  00882021   ADDU A0, A0, T0
9D00B440  0088282B   SLTU A1, A0, T0
9D00B444  10A00024   BEQ A1, ZERO, 0x9D00B4D8
9D00B448  008A282B   SLTU A1, A0, T2
9D00B44C  008A2023   SUBU A0, A0, T2
9D00B450  0083001B   DIVU A0, V1
9D00B454  006001F4   TEQ V1, ZERO
9D00B458  316BFFFF   ANDI T3, T3, -1
9D00B45C  00003012   MFLO A2, 0
9D00B460  00002810   MFHI A1, 0
9D00B464  00052C00   SLL A1, A1, 16
9D00B468  00AB2825   OR A1, A1, T3
9D00B46C  70C73002   MUL A2, A2, A3
9D00B470  00A6502B   SLTU T2, A1, A2
9D00B474  0083001B   DIVU A0, V1
9D00B478  006001F4   TEQ V1, ZERO
9D00B47C  5140FF61   BEQL T2, ZERO, 0x9D00B204
9D00B480  00A62823   SUBU A1, A1, A2
9D00B484  00A82821   ADDU A1, A1, T0
9D00B488  00A8202B   SLTU A0, A1, T0
9D00B48C  5480FF5D   BNEL A0, ZERO, 0x9D00B204
9D00B490  00A62823   SUBU A1, A1, A2
9D00B494  00A6202B   SLTU A0, A1, A2
9D00B498  70885002   MUL T2, A0, T0
9D00B49C  01452821   ADDU A1, T2, A1
9D00B4A0  0B402C81   J 0x9D00B204
9D00B4A4  00A62823   SUBU A1, A1, A2
9D00B4D8  70A83002   MUL A2, A1, T0
9D00B4DC  0B402D13   J 0x9D00B44C
9D00B4E0  00C42021   ADDU A0, A2, A0
9D00B834  00023C02   SRL A3, V0, 16
9D00B838  0147001B   DIVU T2, A3
9D00B83C  00E001F4   TEQ A3, ZERO
9D00B848  304CFFFF   ANDI T4, V0, -1
9D00B854  00054C02   SRL T1, A1, 16
9D00B858  00001812   MFLO V1, 0
9D00B85C  00005810   MFHI T3, 0
9D00B860  000B2400   SLL A0, T3, 16
9D00B864  01242025   OR A0, T1, A0
9D00B868  00003012   MFLO A2, 0
9D00B86C  706C1802   MUL V1, V1, T4
9D00B870  0083482B   SLTU T1, A0, V1
9D00B874  0147001B   DIVU T2, A3
9D00B878  00E001F4   TEQ A3, ZERO
9D00B87C  5120000B   BEQL T1, ZERO, 0x9D00B8AC
9D00B880  00832023   SUBU A0, A0, V1
9D00B884  00822021   ADDU A0, A0, V0
9D00B888  0082482B   SLTU T1, A0, V0
9D00B88C  15200006   BNE T1, ZERO, 0x9D00B8A8
9D00B890  24C6FFFF   ADDIU A2, A2, -1
9D00B894  0083482B   SLTU T1, A0, V1
9D00B898  51200004   BEQL T1, ZERO, 0x9D00B8AC
9D00B89C  00832023   SUBU A0, A0, V1
9D00B8A0  24C6FFFF   ADDIU A2, A2, -1
9D00B8A4  00822021   ADDU A0, A0, V0
9D00B8A8  00832023   SUBU A0, A0, V1
9D00B8AC  0087001B   DIVU A0, A3
9D00B8B0  00E001F4   TEQ A3, ZERO
9D00B8B4  30AAFFFF   ANDI T2, A1, -1
9D00B8B8  00001812   MFLO V1, 0
9D00B8BC  00004810   MFHI T1, 0
9D00B8C0  00094C00   SLL T1, T1, 16
9D00B8C4  012A4825   OR T1, T1, T2
9D00B8C8  706C2802   MUL A1, V1, T4
9D00B8CC  0125502B   SLTU T2, T1, A1
9D00B8D0  0087001B   DIVU A0, A3
9D00B8D4  00E001F4   TEQ A3, ZERO
9D00B8D8  5140000B   BEQL T2, ZERO, 0x9D00B908
9D00B8DC  00063400   SLL A2, A2, 16
9D00B8E0  01224821   ADDU T1, T1, V0
9D00B8E4  0122202B   SLTU A0, T1, V0
9D00B8E8  14800006   BNE A0, ZERO, 0x9D00B904
9D00B8EC  2463FFFF   ADDIU V1, V1, -1
9D00B8F0  0125202B   SLTU A0, T1, A1
9D00B8F4  50800004   BEQL A0, ZERO, 0x9D00B908
9D00B8F8  00063400   SLL A2, A2, 16
9D00B8FC  2463FFFF   ADDIU V1, V1, -1
9D00B900  01224821   ADDU T1, T1, V0
9D00B904  00063400   SLL A2, A2, 16
9D00B908  01254823   SUBU T1, T1, A1
9D00B90C  0B402D98   J 0x9D00B660
9D00B910  00661825   OR V1, V1, A2
9D00B204  00A3001B   DIVU A1, V1
9D00B208  006001F4   TEQ V1, ZERO
9D00B20C  00095402   SRL T2, T1, 16
9D00B210  00002012   MFLO A0, 0
9D00B214  00003010   MFHI A2, 0
9D00B218  00063400   SLL A2, A2, 16
9D00B21C  00CA3025   OR A2, A2, T2
9D00B220  70872002   MUL A0, A0, A3
9D00B224  00C4502B   SLTU T2, A2, A0
9D00B228  00A3001B   DIVU A1, V1
9D00B22C  006001F4   TEQ V1, ZERO
9D00B230  51400009   BEQL T2, ZERO, 0x9D00B258
9D00B234  00C43023   SUBU A2, A2, A0
9D00B238  00C83021   ADDU A2, A2, T0
9D00B23C  00C8282B   SLTU A1, A2, T0
9D00B240  54A00005   BNEL A1, ZERO, 0x9D00B258
9D00B244  00C43023   SUBU A2, A2, A0
9D00B248  00C4282B   SLTU A1, A2, A0
9D00B24C  70A85002   MUL T2, A1, T0
9D00B250  01463021   ADDU A2, T2, A2
9D00B254  00C43023   SUBU A2, A2, A0
9D00B258  00C3001B   DIVU A2, V1
9D00B25C  006001F4   TEQ V1, ZERO
9D00B260  3129FFFF   ANDI T1, T1, -1
9D00B264  00005012   MFLO T2, 0
9D00B268  00002010   MFHI A0, 0
9D00B26C  00042400   SLL A0, A0, 16
9D00B270  00894825   OR T1, A0, T1
9D00B274  71473802   MUL A3, T2, A3
9D00B278  0127202B   SLTU A0, T1, A3
9D00B27C  00C3001B   DIVU A2, V1
9D00B280  006001F4   TEQ V1, ZERO
9D00B284  50800009   BEQL A0, ZERO, 0x9D00B2AC
9D00B288  01274823   SUBU T1, T1, A3
9D00B28C  01284821   ADDU T1, T1, T0
9D00B290  0128182B   SLTU V1, T1, T0
9D00B294  54600005   BNEL V1, ZERO, 0x9D00B2AC
9D00B298  01274823   SUBU T1, T1, A3
9D00B29C  0127182B   SLTU V1, T1, A3
9D00B2A0  70682002   MUL A0, V1, T0
9D00B2A4  00894821   ADDU T1, A0, T1
9D00B2A8  01274823   SUBU T1, T1, A3
9D00B660  0127001B   DIVU T1, A3
9D00B664  00E001F4   TEQ A3, ZERO
9D00B668  00086C02   SRL T5, T0, 16
9D00B66C  00005812   MFLO T3, 0
9D00B670  00005010   MFHI T2, 0
9D00B674  000A5400   SLL T2, T2, 16
9D00B678  014D5025   OR T2, T2, T5
9D00B67C  716C2002   MUL A0, T3, T4
9D00B680  0144302B   SLTU A2, T2, A0
9D00B684  0127001B   DIVU T1, A3
9D00B688  00E001F4   TEQ A3, ZERO
9D00B68C  10C00009   BEQ A2, ZERO, 0x9D00B6B4
9D00B690  01442823   SUBU A1, T2, A0
9D00B694  01425021   ADDU T2, T2, V0
9D00B698  0142282B   SLTU A1, T2, V0
9D00B69C  14A00004   BNE A1, ZERO, 0x9D00B6B0
9D00B6A0  256BFFFF   ADDIU T3, T3, -1
9D00B6A4  0144282B   SLTU A1, T2, A0
9D00B6A8  54A000A2   BNEL A1, ZERO, 0x9D00B934
9D00B6AC  256BFFFF   ADDIU T3, T3, -1
9D00B6B0  01442823   SUBU A1, T2, A0
9D00B6B4  00A7001B   DIVU A1, A3
9D00B6B8  00E001F4   TEQ A3, ZERO
9D00B6BC  3108FFFF   ANDI T0, T0, -1
9D00B6C0  00002012   MFLO A0, 0
9D00B6C4  00003010   MFHI A2, 0
9D00B6C8  00063400   SLL A2, A2, 16
9D00B6CC  00C84025   OR T0, A2, T0
9D00B6D0  708C6002   MUL T4, A0, T4
9D00B6D4  010C302B   SLTU A2, T0, T4
9D00B6D8  00A7001B   DIVU A1, A3
9D00B6DC  00E001F4   TEQ A3, ZERO
9D00B6E0  10C00006   BEQ A2, ZERO, 0x9D00B6FC
9D00B6E4  01024021   ADDU T0, T0, V0
9D00B6E8  0102102B   SLTU V0, T0, V0
9D00B6EC  14400003   BNE V0, ZERO, 0x9D00B6FC
9D00B6F0  2484FFFF   ADDIU A0, A0, -1
9D00B6F4  010C602B   SLTU T4, T0, T4
9D00B6F8  008C2023   SUBU A0, A0, T4
9D00B6FC  000B5C00   SLL T3, T3, 16
9D00B700  008B2025   OR A0, A0, T3
9D00B934  0B402DAC   J 0x9D00B6B0
9D00B938  01425021   ADDU T2, T2, V0
9D00B188  00491006   SRLV V0, T1, V0
9D00B2AC  00491006   SRLV V0, T1, V0
9D00B18C  03E00008   JR RA
9D00B190  00001821   ADDU V1, ZERO, ZERO
9D00B2B0  03E00008   JR RA
9D00B2B4  00001821   ADDU V1, ZERO, ZERO
9D00B194  00A7102B   SLTU V0, A1, A3
9D00B198  14400047   BNE V0, ZERO, 0x9D00B2B8
9D00B19C  70E84020   CLZ T0, A3
9D00B5FC  00A7102B   SLTU V0, A1, A3
9D00B600  54400042   BNEL V0, ZERO, 0x9D00B70C
9D00B604  00002021   ADDU A0, ZERO, ZERO
9D00B70C  00001821   ADDU V1, ZERO, ZERO
9D00B2B8  00801021   ADDU V0, A0, ZERO
9D00B2BC  03E00008   JR RA
9D00B2C0  00A01821   ADDU V1, A1, ZERO
9D00B608  70E31820   CLZ V1, A3
9D00B1A0  15000048   BNE T0, ZERO, 0x9D00B2C4
9D00B1A4  240A0020   ADDIU T2, ZERO, 32
9D00B60C  14600042   BNE V1, ZERO, 0x9D00B718
9D00B610  240B0020   ADDIU T3, ZERO, 32
9D00B1A8  00E5102B   SLTU V0, A3, A1
9D00B1AC  14400005   BNE V0, ZERO, 0x9D00B1C4
9D00B1B0  00861023   SUBU V0, A0, A2
9D00B1B4  0086402B   SLTU T0, A0, A2
9D00B1B8  15000088   BNE T0, ZERO, 0x9D00B3DC
9D00B1BC  00801021   ADDU V0, A0, ZERO
9D00B614  00E5282B   SLTU A1, A3, A1
9D00B618  54A000C4   BNEL A1, ZERO, 0x9D00B92C
9D00B61C  00001821   ADDU V1, ZERO, ZERO
9D00B620  0086202B   SLTU A0, A0, A2
9D00B624  0B402D7D   J 0x9D00B5F4
9D00B628  2C840001   SLTIU A0, A0, 1
9D00B92C  0B402D7D   J 0x9D00B5F4
9D00B930  24040001   ADDIU A0, ZERO, 1
9D00B1C0  00861023   SUBU V0, A0, A2
9D00B1C4  00A71823   SUBU V1, A1, A3
9D00B1C8  0082202B   SLTU A0, A0, V0
9D00B1CC  03E00008   JR RA
9D00B1D0  00641823   SUBU V1, V1, A0
9D00B2C4  01485023   SUBU T2, T2, T0
9D00B718  01635823   SUBU T3, T3, V1
9D00B2C8  01461006   SRLV V0, A2, T2
9D00B2CC  01073804   SLLV A3, A3, T0
9D00B2D0  00473825   OR A3, V0, A3
9D00B71C  01661006   SRLV V0, A2, T3
9D00B720  00673804   SLLV A3, A3, V1
9D00B724  00473825   OR A3, V0, A3
9D00B2F8  01063004   SLLV A2, A2, T0
9D00B2D4  01455806   SRLV T3, A1, T2
9D00B728  01654806   SRLV T1, A1, T3
9D00B2E8  01441806   SRLV V1, A0, T2
9D00B2EC  01052804   SLLV A1, A1, T0
9D00B2F0  00652825   OR A1, V1, A1
9D00B73C  01645806   SRLV T3, A0, T3
9D00B740  00652804   SLLV A1, A1, V1
9D00B744  01652825   OR A1, T3, A1
9D00B2D8  00074C02   SRL T1, A3, 16
9D00B2DC  0169001B   DIVU T3, T1
9D00B2E0  012001F4   TEQ T1, ZERO
9D00B2E4  30EDFFFF   ANDI T5, A3, -1
9D00B2F4  00051C02   SRL V1, A1, 16
9D00B2FC  00006012   MFLO T4, 0
9D00B300  00001010   MFHI V0, 0
9D00B304  00021400   SLL V0, V0, 16
9D00B308  00431025   OR V0, V0, V1
9D00B30C  718D7002   MUL T6, T4, T5
9D00B310  004E182B   SLTU V1, V0, T6
9D00B314  0169001B   DIVU T3, T1
9D00B318  012001F4   TEQ T1, ZERO
9D00B31C  1060000A   BEQ V1, ZERO, 0x9D00B348
9D00B320  01042004   SLLV A0, A0, T0
9D00B324  00471021   ADDU V0, V0, A3
9D00B328  0047182B   SLTU V1, V0, A3
9D00B32C  14600006   BNE V1, ZERO, 0x9D00B348
9D00B330  258CFFFF   ADDIU T4, T4, -1
9D00B334  004E182B   SLTU V1, V0, T6
9D00B338  50600004   BEQL V1, ZERO, 0x9D00B34C
9D00B33C  004E1023   SUBU V0, V0, T6
9D00B340  258CFFFF   ADDIU T4, T4, -1
9D00B344  00471021   ADDU V0, V0, A3
9D00B348  004E1023   SUBU V0, V0, T6
9D00B34C  0049001B   DIVU V0, T1
9D00B350  012001F4   TEQ T1, ZERO
9D00B354  30A5FFFF   ANDI A1, A1, -1
9D00B358  00005812   MFLO T3, 0
9D00B35C  00001810   MFHI V1, 0
9D00B360  00031C00   SLL V1, V1, 16
9D00B364  00652825   OR A1, V1, A1
9D00B368  716D6802   MUL T5, T3, T5
9D00B36C  00AD182B   SLTU V1, A1, T5
9D00B370  0049001B   DIVU V0, T1
9D00B374  012001F4   TEQ T1, ZERO
9D00B378  50600006   BEQL V1, ZERO, 0x9D00B394
9D00B37C  000C6400   SLL T4, T4, 16
9D00B380  00A72821   ADDU A1, A1, A3
9D00B384  00A7102B   SLTU V0, A1, A3
9D00B388  1040004D   BEQ V0, ZERO, 0x9D00B4C0
9D00B38C  256BFFFF   ADDIU T3, T3, -1
9D00B390  000C6400   SLL T4, T4, 16
9D00B394  016C5825   OR T3, T3, T4
9D00B39C  00AD2823   SUBU A1, A1, T5
9D00B4C0  00AD102B   SLTU V0, A1, T5
9D00B4C4  5040FFB3   BEQL V0, ZERO, 0x9D00B394
9D00B4C8  000C6400   SLL T4, T4, 16
9D00B4CC  256BFFFF   ADDIU T3, T3, -1
9D00B4D0  0B402CE4   J 0x9D00B390
9D00B4D4  00A72821   ADDU A1, A1, A3
9D00B72C  00071402   SRL V0, A3, 16
9D00B730  0122001B   DIVU T1, V0
9D00B734  004001F4   TEQ V0, ZERO
9D00B738  30ECFFFF   ANDI T4, A3, -1
9D00B748  00055C02   SRL T3, A1, 16
9D00B74C  00005012   MFLO T2, 0
9D00B750  00004010   MFHI T0, 0
9D00B754  00084400   SLL T0, T0, 16
9D00B758  010B4025   OR T0, T0, T3
9D00B75C  714C6802   MUL T5, T2, T4
9D00B760  010D582B   SLTU T3, T0, T5
9D00B764  0122001B   DIVU T1, V0
9D00B768  004001F4   TEQ V0, ZERO
9D00B76C  1160000A   BEQ T3, ZERO, 0x9D00B798
9D00B770  00663004   SLLV A2, A2, V1
9D00B774  01074021   ADDU T0, T0, A3
9D00B778  0107482B   SLTU T1, T0, A3
9D00B77C  15200006   BNE T1, ZERO, 0x9D00B798
9D00B780  254AFFFF   ADDIU T2, T2, -1
9D00B784  010D482B   SLTU T1, T0, T5
9D00B788  51200004   BEQL T1, ZERO, 0x9D00B79C
9D00B78C  010D4023   SUBU T0, T0, T5
9D00B790  254AFFFF   ADDIU T2, T2, -1
9D00B794  01074021   ADDU T0, T0, A3
9D00B798  010D4023   SUBU T0, T0, T5
9D00B79C  0102001B   DIVU T0, V0
9D00B7A0  004001F4   TEQ V0, ZERO
9D00B7A4  30A5FFFF   ANDI A1, A1, -1
9D00B7A8  00004812   MFLO T1, 0
9D00B7AC  00005810   MFHI T3, 0
9D00B7B0  000B5C00   SLL T3, T3, 16
9D00B7B4  01652825   OR A1, T3, A1
9D00B7B8  712C6002   MUL T4, T1, T4
9D00B7BC  00AC582B   SLTU T3, A1, T4
9D00B7C0  0102001B   DIVU T0, V0
9D00B7C4  004001F4   TEQ V0, ZERO
9D00B7C8  5160000B   BEQL T3, ZERO, 0x9D00B7F8
9D00B7CC  000A5400   SLL T2, T2, 16
9D00B7D0  00A72821   ADDU A1, A1, A3
9D00B7D4  00A7102B   SLTU V0, A1, A3
9D00B7D8  14400006   BNE V0, ZERO, 0x9D00B7F4
9D00B7DC  2529FFFF   ADDIU T1, T1, -1
9D00B7E0  00AC102B   SLTU V0, A1, T4
9D00B7E4  50400004   BEQL V0, ZERO, 0x9D00B7F8
9D00B7E8  000A5400   SLL T2, T2, 16
9D00B7EC  2529FFFF   ADDIU T1, T1, -1
9D00B7F0  00A72821   ADDU A1, A1, A3
9D00B7F4  000A5400   SLL T2, T2, 16
9D00B7F8  012A4825   OR T1, T1, T2
9D00B800  00AC2823   SUBU A1, A1, T4
9D00B398  01660019   MULTU 0, T3, A2
9D00B3A0  0000C810   MFHI T9, 0
9D00B3A8  03207021   ADDU T6, T9, ZERO
9D00B3BC  00001012   MFLO V0, 0
9D00B7FC  01260019   MULTU 0, T1, A2
9D00B804  00005810   MFHI T3, 0
9D00B3A4  00B9682B   SLTU T5, A1, T9
9D00B3AC  15A0003E   BNE T5, ZERO, 0x9D00B4A8
9D00B3B0  00004812   MFLO T1, 0
9D00B3B4  10B9004B   BEQ A1, T9, 0x9D00B4E4
9D00B3B8  00B91823   SUBU V1, A1, T9
9D00B4E4  0089182B   SLTU V1, A0, T1
9D00B4E8  5460FFF0   BNEL V1, ZERO, 0x9D00B4AC
9D00B4EC  01261023   SUBU V0, T1, A2
9D00B4F0  00001012   MFLO V0, 0
9D00B4F4  0B402CF0   J 0x9D00B3C0
9D00B4F8  00001821   ADDU V1, ZERO, ZERO
9D00B808  00AB382B   SLTU A3, A1, T3
9D00B80C  14E00044   BNE A3, ZERO, 0x9D00B920
9D00B810  00005012   MFLO T2, 0
9D00B814  50AB003F   BEQL A1, T3, 0x9D00B914
9D00B818  00641804   SLLV V1, A0, V1
9D00B81C  01202021   ADDU A0, T1, ZERO
9D00B820  0B402D7D   J 0x9D00B5F4
9D00B824  00001821   ADDU V1, ZERO, ZERO
9D00B914  006A182B   SLTU V1, V1, T2
9D00B918  1060FF36   BEQ V1, ZERO, 0x9D00B5F4
9D00B91C  01202021   ADDU A0, T1, ZERO
9D00B920  2524FFFF   ADDIU A0, T1, -1
9D00B924  0B402D7D   J 0x9D00B5F4
9D00B928  00001821   ADDU V1, ZERO, ZERO
9D00B4A8  01261023   SUBU V0, T1, A2
9D00B4AC  01C71823   SUBU V1, T6, A3
9D00B4B0  0122482B   SLTU T1, T1, V0
9D00B4B4  00691823   SUBU V1, V1, T1
9D00B4B8  0B402CF0   J 0x9D00B3C0
9D00B4BC  00A31823   SUBU V1, A1, V1
9D00B3C0  00821023   SUBU V0, A0, V0
9D00B3C4  0082202B   SLTU A0, A0, V0
9D00B3C8  00641823   SUBU V1, V1, A0
9D00B3CC  01435004   SLLV T2, V1, T2
9D00B3D0  01021006   SRLV V0, V0, T0
9D00B3D4  004A1025   OR V0, V0, T2
9D00B3D8  01031806   SRLV V1, V1, T0
9D00B3DC  03E00008   JR RA
9D00B3E0  00000000   NOP
9D00B5F4  03E00008   JR RA
9D00B5F8  00801021   ADDU V0, A0, ZERO
9D00B704  03E00008   JR RA
9D00B708  00801021   ADDU V0, A0, ZERO
9D00B710  03E00008   JR RA
9D00B714  00801021   ADDU V0, A0, ZERO
9D00C6A0  27BDFFE0   ADDIU SP, SP, -32
9D00C6A4  AFBF001C   SW RA, 28(SP)
9D00C6A8  AFB20018   SW S2, 24(SP)
9D00C6AC  AFB10014   SW S1, 20(SP)
9D00C6B0  AFB00010   SW S0, 16(SP)
9D00C6B4  10A00027   BEQ A1, ZERO, 0x9D00C754
9D00C6B8  00801021   ADDU V0, A0, ZERO
9D00C754  0F4032FD   JAL __floatunsisf
9D00C758  00000000   NOP
9D00C6BC  70A42020   CLZ A0, A1
9D00C6C0  24110020   ADDIU S1, ZERO, 32
9D00C6C4  02248023   SUBU S0, S1, A0
9D00C6C8  00053040   SLL A2, A1, 1
9D00C6CC  00101827   NOR V1, ZERO, S0
9D00C6D0  00663004   SLLV A2, A2, V1
9D00C6D4  02021806   SRLV V1, V0, S0
9D00C6D8  00C31825   OR V1, A2, V1
9D00C6DC  02052806   SRLV A1, A1, S0
9D00C6E0  32060020   ANDI A2, S0, 32
9D00C6E4  0066280A   MOVZ A1, V1, A2
9D00C6E8  00822004   SLLV A0, V0, A0
9D00C6EC  34A30001   ORI V1, A1, 1
9D00C6F0  0064280B   MOVN A1, V1, A0
9D00C6F4  0F4032FD   JAL __floatunsisf
9D00C6F8  00A02021   ADDU A0, A1, ZERO
9D00C6FC  1211000F   BEQ S0, S1, 0x9D00C73C
9D00C700  00409021   ADDU S2, V0, ZERO
9D00C73C  3C029D01   LUI V0, -25343
9D00C740  0B4031C7   J 0x9D00C71C
9D00C744  8C45CE0C   LW A1, -12788(V0)
9D00C704  2402001F   ADDIU V0, ZERO, 31
9D00C708  1202000F   BEQ S0, V0, 0x9D00C748
9D00C70C  24040001   ADDIU A0, ZERO, 1
9D00C748  3C029D01   LUI V0, -25343
9D00C74C  0B4031C7   J 0x9D00C71C
9D00C750  8C45CE10   LW A1, -12784(V0)
9D00C710  0F402886   JAL sitofp
9D00C714  02042004   SLLV A0, A0, S0
9D00C718  00402821   ADDU A1, V0, ZERO
9D00C71C  0F40278D   JAL __mulsf3
9D00C720  02402021   ADDU A0, S2, ZERO
9D00C724  8FBF001C   LW RA, 28(SP)
9D00C728  8FB20018   LW S2, 24(SP)
9D00C72C  8FB10014   LW S1, 20(SP)
9D00C730  8FB00010   LW S0, 16(SP)
9D00C734  03E00008   JR RA
9D00C738  27BD0020   ADDIU SP, SP, 32
9D00C75C  8FBF001C   LW RA, 28(SP)
9D00C760  8FB20018   LW S2, 24(SP)
9D00C764  8FB10014   LW S1, 20(SP)
9D00C768  8FB00010   LW S0, 16(SP)
9D00C76C  03E00008   JR RA
9D00C770  27BD0020   ADDIU SP, SP, 32
---  /Volumes/home/c11067/xc32/build/gcc/config/floatunsisf.c  ------------------------------------------
9D00CBF4  27BDFFE8   ADDIU SP, SP, -24
9D00CBF8  AFBF0014   SW RA, 20(SP)
9D00CBFC  04800006   BLTZ A0, 0x9D00CC18
9D00CC00  00801021   ADDU V0, A0, ZERO
9D00CC18  30420001   ANDI V0, V0, 1
9D00CC1C  00042042   SRL A0, A0, 1
9D00CC20  0F402886   JAL sitofp
9D00CC24  00822025   OR A0, A0, V0
9D00CC28  00402021   ADDU A0, V0, ZERO
9D00CC2C  0F4026F2   JAL fpadd
9D00CC30  00402821   ADDU A1, V0, ZERO
9D00CC04  0F402886   JAL sitofp
9D00CC08  00000000   NOP
9D00CC0C  8FBF0014   LW RA, 20(SP)
9D00CC10  03E00008   JR RA
9D00CC14  27BD0018   ADDIU SP, SP, 24
9D00CC34  8FBF0014   LW RA, 20(SP)
9D00CC38  03E00008   JR RA
9D00CC3C  27BD0018   ADDIU SP, SP, 24
