Disassembly Listing for vpc-32
Generated From:
C:/Users/Jacques/Documents/GitHub/VPC-32.X/dist/default/production/VPC-32.X.production.elf
2013-09-24 16:21:12

---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/uart.h  ---------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: Constants & Data Types
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  //DOM-IGNORE-BEGIN
74:                  /****
75:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
76:                         the device file.  Also the UART register set could also be placed there
77:                  *****/
78:                  typedef struct
79:                  {
80:                  	volatile UINT	reg;
81:                  	volatile UINT	clr;
82:                  	volatile UINT	set;
83:                  	volatile UINT	inv;
84:                  }REG_SET;
85:                  
86:                  typedef struct
87:                  {
88:                  	volatile REG_SET	mode;
89:                  	volatile REG_SET	sta;
90:                  	volatile REG_SET    tx;
91:                  	volatile REG_SET	rx;
92:                  	volatile REG_SET	brg;
93:                  }UART_REGS;
94:                  
95:                  extern UART_REGS * const uartReg[];
96:                  //DOM-IGNORE-END
97:                  
98:                  // *****************************************************************************
99:                  /* UART Module
100:                 
101:                   Summary:
102:                     UART modules supported.
103:                 
104:                   Description:
105:                     This enumeration identifies the available UART modules.
106:                 */
107:                 
108:                 typedef enum
109:                 {
110:                 #if defined _UART1
111:                     // UART1 Module ID.
112:                     UART1 = 0,
113:                 #endif
114:                 #if defined _UART2
115:                     // UART2 Module ID.
116:                     UART2,
117:                 #endif
118:                 #ifdef _UART3
119:                     // UART3 Module ID.
120:                     UART3,
121:                 #endif
122:                 #ifdef _UART4
123:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
124:                     UART4,
125:                 #endif
126:                 #ifdef _UART5
127:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
128:                     UART5,
129:                 #endif
130:                 #ifdef _UART6
131:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
132:                     UART6,
133:                 #endif
134:                     // Number of available UART modules.
135:                     UART_NUMBER_OF_MODULES
136:                 
137:                 } UART_MODULE;
138:                 
139:                 
140:                 // *****************************************************************************
141:                 /* UART Enable Modes
142:                 
143:                   Summary:
144:                     Operating modes of UART.
145:                 
146:                   Description:
147:                     This enumeration defines the supported modes in which the UART may be
148:                     enabled or disbled.
149:                 
150:                   Remarks:
151:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
152:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
153:                     has been pre-loaded with data.
154:                 
155:                     The caller should not rely on the specific numbers assigned to any of these
156:                     values as they may change from one processor to the next.
157:                 */
158:                 
159:                 typedef enum
160:                 {
161:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
162:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
163:                 
164:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
165:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
166:                 
167:                 
168:                     // UART Module, receiver and transmitter functionality is not.
169:                     // enabled or disabled
170:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
171:                 
172:                     // UART Module receiver.
173:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
174:                 
175:                     // UART Module transmitter.
176:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
177:                 
178:                 
179:                 } UART_ENABLE_MODE;
180:                 
181:                 // *****************************************************************************
182:                 /* UART Enable Helper Macro
183:                 
184:                   Summary:
185:                     Macro for enabling module operating modes.
186:                 
187:                   Description:
188:                     This macro creates the proper flags for enabling operating modes of the UART module.
189:                 
190:                   Example:
191:                     <code>
192:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
193:                     </code>
194:                 
195:                   Remarks:
196:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
197:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
198:                     has been pre-loaded with data.
199:                 */
200:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
201:                 
202:                 // *****************************************************************************
203:                 /* UART Disable Helper Macro
204:                 
205:                   Summary:
206:                     Macro for disabling module operating modes.
207:                 
208:                   Description:
209:                     This macro creates the proper flags for disabling operating modes of the UART module.
210:                 
211:                   Example:
212:                     <code>
213:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
214:                     </code>
215:                 
216:                 */
217:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
218:                 
219:                 // *****************************************************************************
220:                 /* UART Configuration Settings
221:                 
222:                   Summary:
223:                     Supported configuration flags for the UART module.
224:                 
225:                   Description:
226:                     This enumeration defines the various configuration options for the UART
227:                     module.  These values can be OR'd together to create a configuration mask
228:                     passed to the UARTConfigure routine.
229:                 
230:                   Remarks:
231:                     Several of the configuration options are mutually exclusive:
232:                     * Only one of the "ENABLE_PINS" modes can be used at a time
233:                     * Only one of the "RTS_WHEN" modes can be used at a time
234:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
235:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
236:                 
237:                     The caller should not rely on the specific numbers assigned to any of these
238:                     values as they may change from one processor ot the next.
239:                 */
240:                 
241:                 typedef enum
242:                 {
243:                     // Enables high-speed range of the UART (see UARTSetBitRate).
244:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
245:                 
246:                     // Inverts polarity of data interpretation the received (RX) pin.
247:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
248:                 
249:                     // Enables UART TX-to-RX Loop-back mode.
250:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
251:                 
252:                     // Enables Wake-up of the part when a start bit is received.
253:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
254:                 
255:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
256:                     // cannot be used in bit-clock/IrDA mode).
257:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
258:                 
259:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
260:                     // cannot be used in CTS/RTS mode).
261:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
262:                 
263:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
264:                     // be used in RTS-Only mode).
265:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
266:                 
267:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
268:                     // the default mode and this parameter can be left out if it is desired).
269:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
270:                 
271:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
272:                     // is not full (i.e., the UART is ready to receive data).  This is also known
273:                     // as "RTS Flow-Control Mode".
274:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
275:                 
276:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
277:                     // is not empty (i.e., when the UART has data ready to send).  This is also
278:                     // known as "RTS Simplex Mode".
279:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
280:                 
281:                     // Enable the IrDA encoder/decoder.
282:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
283:                 
284:                     // Enables stopping of the UART operation to save power when the core has
285:                     // been put in idle mode.
286:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
287:                 
288:                     // Inverts the polarity of data sent on the transmit (TX) pin.
289:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
290:                 
291:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
292:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
293:                     // Note:  The address must still be set using UARTEnableAddressDetect
294:                     // to support IEEE-485 protocol.
295:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
296:                 
297:                 } UART_CONFIGURATION;
298:                 
299:                 
300:                 // *****************************************************************************
301:                 /* UART FIFO Modes
302:                 
303:                   Summary:
304:                     Supported FIFO modes for the UART module.
305:                 
306:                   Description:
307:                     This enumeration defines supported FIFO modes that determine when the Tx
308:                     and Rx interrupts will occur.
309:                 
310:                   Remarks:
311:                     These modes consist of two sets of mutially exclusive modes:
312:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
313:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
314:                 
315:                     The caller should not rely on the specific numbers assigned to any of these
316:                     values as they may change from one processor ot the next.
317:                 
318:                 */
319:                 
320:                 typedef enum
321:                 {
322:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
323:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
324:                 
325:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
326:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
327:                 
328:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
329:                     // full (i.e. there is space available for more data)  This is the default.
330:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
331:                 
332:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
333:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
334:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
337:                     // (three-quarter) full.
338:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
339:                 
340:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
341:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
342:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
343:                 
344:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
345:                     // data.
346:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
347:                 
348:                 } UART_FIFO_MODE;
349:                 
350:                 
351:                 // *****************************************************************************
352:                 /* UART Line Control Mode
353:                 
354:                   Summary:
355:                     UART line control mode.
356:                 
357:                   Description:
358:                     This data type defines the supported line control modes for the UART.
359:                 
360:                   Remarks:
361:                     Some of the line-control options are mutually exclusive:
362:                     * Only one of the "DATA_SIZE" options can be used at a time
363:                     * Only one of the "PARITY" options can be used at a time
364:                     * Only one of the "STOP_BITS" options can be used at a time
365:                 
366:                     The caller should not rely on the specific numbers assigned to any of these
367:                     values as they may change from one processor ot the next.
368:                 */
369:                 
370:                 typedef enum
371:                 {
372:                     // Sets the data transfer size to 8-bits per frame.
373:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
374:                 
375:                     // Sets the data transfer size to 9-bits per frame.
376:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
377:                 
378:                     // Enables parity bit generation for odd parity.
379:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
380:                 
381:                     // Enables parity bit generation for even parity.
382:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
383:                 
384:                     // Disables parity bit generation.
385:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
386:                 
387:                     // Enables generation of 2 stop bits per frame.
388:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
389:                 
390:                     // Enables generation of 1 stop bit per frame (default).
391:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
392:                 
393:                 } UART_LINE_CONTROL_MODE;
394:                 
395:                 
396:                 // *****************************************************************************
397:                 /* UART Line Status Flags
398:                 
399:                   Summary:
400:                     UART line-status bitmask flags.
401:                 
402:                   Description:
403:                     This enumeration defines the UART line-status bits.  These values are
404:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
405:                 
406:                   Remarks:
407:                     The caller should not rely on the specific numbers assigned to any of these
408:                     values as they may change from one processor ot the next.
409:                 */
410:                 
411:                 typedef enum
412:                 {
413:                     // The transmitter is able to accept data to transmit.
414:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
415:                 
416:                     // The transmitter is empty (no data is available to transmit).
417:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
418:                 
419:                     // The receiver is currently idle.
420:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
421:                 
422:                     // A received data parity error was detected.
423:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
424:                 
425:                     // Data was received that violated the framing protocol (the data word did
426:                     // not start or stop at the appropriate place).  Note:  A break condition
427:                     // will always indicate a framing error.
428:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
429:                 
430:                     // The UART has received more data than it can buffer.  Data has been lost.
431:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
432:                 
433:                     // UART data has been received and is avaiable in the FIFO.
434:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
435:                 
436:                 } UART_LINE_STATUS;
437:                 
438:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
439:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
440:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
441:                 
442:                 
443:                 
444:                 // *****************************************************************************
445:                 /* UART Data
446:                 
447:                   Summary:
448:                     UART data.
449:                 
450:                   Description:
451:                     This data type defines the supported data sizes for the UART.
452:                 */
453:                 
454:                 typedef union
455:                 {
456:                     // 8-bit data
457:                     struct
458:                     {
459:                         UINT16  data8bit    : 8;
460:                     };
461:                 
462:                     // 9-bit data
463:                     struct
464:                     {
465:                         UINT16  data9bit    : 9;
466:                     };
467:                 
468:                     UINT16 __data;
469:                 } UART_DATA;
470:                 
471:                 
472:                 // *****************************************************************************
473:                 // *****************************************************************************
474:                 // Section: UART Peripheral Library Interface Routines
475:                 // *****************************************************************************
476:                 // *****************************************************************************
477:                 
478:                 
479:                 /*******************************************************************************
480:                   Function:
481:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
482:                 
483:                   Summary:
484:                     Enables or disables the given UART module in the desired mode.
485:                 
486:                   Description:
487:                     This routine enables or disables the given UART module in the desired mode.
488:                 
489:                   Precondition:
490:                     The UART module should be appropriately configured before being enabled.
491:                 
492:                   Parameters:
493:                     id    - Identifies the desired UART module.
494:                 
495:                     mode  - Identifies the desired mode of UART operation.
496:                 
497:                   Returns:
498:                     None
499:                 
500:                   Example:
501:                     <code>
502:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
503:                     </code>
504:                 
505:                   Remarks:
506:                     Enabling UART transmissions will immediately cause a TX interrupt to
507:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
508:                     was pre-loaded with data.
509:                   *****************************************************************************/
510:                 
511:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
512:                 
513:                 
514:                 /*******************************************************************************
515:                   Function:
516:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
517:                 
518:                   Summary:
519:                     UART module configuration routine.
520:                 
521:                   Description:
522:                     This routine allows the caller to configure various features of the UART
523:                     module for desired operation.
524:                 
525:                   Precondition:
526:                     None
527:                 
528:                   Parameters:
529:                     id      - Identifies the desired UART module.
530:                 
531:                     flags   - Bit-wise OR of the desired module configuration settings.
532:                 
533:                   Returns:
534:                     None
535:                 
536:                   Example:
537:                     <code>
538:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
539:                     </code>
540:                 
541:                   Remarks:
542:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
543:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
544:                     of these values will result in a value that is not explicitly defined in
545:                     the enumeration.
546:                   *****************************************************************************/
547:                 
548:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
549:                 
550:                 
551:                 /*******************************************************************************
552:                   Function:
553:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
554:                 
555:                   Summary:
556:                     Controls UART module TX and RX FIFO operation.
557:                 
558:                   Description:
559:                     This routine allows the caller to configure when interrupts occur relative
560:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
561:                     or empty the FIFOs are).
562:                 
563:                   Precondition:
564:                     None
565:                 
566:                   Parameters:
567:                     id      - Identifies the desired UART module.
568:                 
569:                     mode    - Bit-wise OR of the desired FIFO mode values.
570:                 
571:                   Returns:
572:                     None
573:                 
574:                   Example:
575:                     <code>
576:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
577:                     </code>
578:                 
579:                   Remarks:
580:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
581:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
582:                     of these values will result in a value that is not explicitly defined in
583:                     the enumeration.
584:                   *****************************************************************************/
585:                 
586:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
587:                 
588:                 
589:                 /*******************************************************************************
590:                   Function:
591:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
592:                 
593:                   Summary:
594:                     Routine to set the UART module's desired data data rate.
595:                 
596:                   Description:
597:                     This routine allows the caller to set the desired data rate for the UART.
598:                 
599:                   Precondition:
600:                     The source clock's frequency must be operating at the frequency passed in the
601:                     "sourceClock" parameter.
602:                 
603:                   Parameters:
604:                     id          - Identifies the desired UART module.
605:                 
606:                     sourceClock - Frequency (Hz) of the source clock being provided to the
607:                                   UART module.
608:                 
609:                     dataRate     - Desired data rate (bits per second).
610:                 
611:                   Returns:
612:                     Actual bit rate selected
613:                 
614:                   Example:
615:                     <code>
616:                 	#define PERIPHERAL_CLOCK    10000000
617:                 	#define DESIRED_DATA_RATE   19200
618:                 	
619:                 	UINT32    actualDataRate;
620:                 
621:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
622:                     </code>
623:                 
624:                   Remarks:
625:                     Actual data rate selected may be slightly different than the data rate
626:                     requested due to truncation error.
627:                 
628:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
629:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
630:                     the maximum data rate is sourceClock/4.
631:                   *****************************************************************************/
632:                 
633:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
634:                 
635:                 
636:                 /*******************************************************************************
637:                   Function:
638:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
639:                 
640:                   Summary:
641:                     Routine to get the UART module's current data data rate.
642:                 
643:                   Description:
644:                     This routine allows the caller to get the current data rate for the UART module.
645:                 
646:                   Precondition:
647:                     The source clock's frequency must be operating at the frequency passed in the
648:                     "sourceClock" parameter.
649:                 
650:                   Parameters:
651:                     id          - Identifies the desired UART module.
652:                 
653:                     sourceClock - Frequency (Hz) of the source clock being provided to the
654:                                   UART module.
655:                 
656:                   Returns:
657:                     The UART's current data rate (bits per second).
658:                 
659:                   Example:
660:                     <code>
661:                 	#define PERIPHERAL_CLOCK    10000000
662:                 	
663:                 	UINT32    currentDataRate;
664:                 
665:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
666:                     </code>
667:                 
668:                   Remarks:
669:                     The current (actual) data rate returned may be slightly different than bit
670:                     rate requested due to truncation error.
671:                   *****************************************************************************/
672:                 
673:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
674:                 
675:                 
676:                 /*******************************************************************************
677:                   Function:
678:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
679:                 
680:                   Summary:
681:                     Routine to set the UART module's desired line control parameters.
682:                 
683:                   Description:
684:                     This routine allows the caller to select the desired size of the UART data
685:                     frame, the generation of parity and framing parameters (collectively
686:                     referred to as the "line control" mode).
687:                 
688:                   Precondition:
689:                 
690:                   Parameters:
691:                     id      - Identifies the desired UART module.
692:                 
693:                     mode    - This is a bit-wise OR of the desired line control mode flags.
694:                 
695:                   Returns:
696:                     None
697:                 
698:                   Example:
699:                     <code>
700:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
701:                     </code>
702:                 
703:                   Remarks:
704:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
705:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
706:                     of these values will result in a value that is not explicitly defined in
707:                     the enumeration.
708:                   *****************************************************************************/
709:                 
710:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
711:                 
712:                 
713:                 /*******************************************************************************
714:                   Function:
715:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
716:                 
717:                   Summary:
718:                     Provides current UART line status.
719:                 
720:                   Description:
721:                     This routine allows the caller to get the current line status of the UART,
722:                     indicating the current state of the transmitter and receiver buffers, and
723:                     if any errors have occurred.
724:                 
725:                   Precondition:
726:                     None
727:                 
728:                   Parameters:
729:                     id      - Identifies the desired UART module.
730:                 
731:                   Returns:
732:                     A bit-wise OR of the current line status flags.
733:                 
734:                   Example:
735:                     <code>
736:                     UART_LINE_STATUS lineStatus;
737:                 	
738:                 	lineStatus = UARTGetLineStatus(UART1);
739:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
740:                     {
741:                         // Handle receiver error
742:                     }
743:                     </code>
744:                 
745:                   Remarks:
746:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
747:                     status flag.
748:                 
749:                     The receiver line status flags are only valid when data has been received
750:                     and for the data at the top of the RX FIFO.
751:                 
752:                     Note that the bitmask resulting from the bit-wise OR of these values will
753:                     result in a value that is not explicitly defined in the enumeration.
754:                   *****************************************************************************/
755:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
756:                 {
757:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
758:                 }
759:                 
760:                 
761:                 /*******************************************************************************
762:                   Function:
763:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
764:                 
765:                   Summary:
766:                     Routine to detect if the transmitter is ready to accept data to transmit.
767:                 
768:                   Description:
769:                     This routine determines if the transmitter is ready to accept more data to
770:                     be transmitted.
771:                 
772:                   Precondition:
773:                     The UART module should have been appropriately configured and enabled.
774:                 
775:                   Parameters:
776:                     id      - Identifies the desired UART module.
777:                 
778:                   Returns:
779:                     Boolean identifying whether or not the transmitter is ready:
780:                     * TRUE    - If the transmitter is ready to accept more data
781:                     * FALSE   - If the transmitter is not ready to accept more data
782:                 
783:                   Example:
784:                     <code>
785:                     unsigned char data;
786:                 	
787:                 	data = 'a';
788:                 	
789:                 	if (UARTTransmitterIsReady(UART1))
790:                     {
791:                         UARTSendDataByte(UART1, data);
792:                     }
793:                     </code>
794:                 
795:                   Remarks:
796:                   *****************************************************************************/
797:                 
798:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
799:                 {
800:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D00CB60  00042080   SLL A0, A0, 2
9D00CB64  3C029D01   LUI V0, -25343
9D00CB68  24420290   ADDIU V0, V0, 656
9D00CB6C  00822021   ADDU A0, A0, V0
9D00CB70  8C830000   LW V1, 0(A0)
9D00CB74  8C620010   LW V0, 16(V1)
9D00CB78  30420200   ANDI V0, V0, 512
9D00CC48  3C029D01   LUI V0, -25343
9D00CC4C  24420290   ADDIU V0, V0, 656
9D00CC50  00621021   ADDU V0, V1, V0
9D00CC54  8C430000   LW V1, 0(V0)
9D00CC58  8C620010   LW V0, 16(V1)
9D00CC5C  30420200   ANDI V0, V0, 512
801:                 }
802:                 
803:                 
804:                 /*******************************************************************************
805:                   Function:
806:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
807:                 
808:                   Summary:
809:                     Routine to send a byte of data.
810:                 
811:                   Description:
812:                     This routine allows the caller to send a byte of data.
813:                 
814:                   Precondition:
815:                     The UART should have been appropriately configured.  The configuration must
816:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
817:                     have been ready, although not necessarily enabled yet.
818:                 
819:                   Parameters:
820:                     id      - Identifies the desired UART module.
821:                 
822:                     data    - Data byte to be sent.
823:                 
824:                   Returns:
825:                     None
826:                 
827:                   Example:
828:                     <code>
829:                 	unsigned char data;
830:                 	
831:                 	data = 'a';
832:                 	
833:                     if (UARTTransmitterIsReady(UART1))
834:                     {
835:                         UARTSendDataByte(UART1, data);
836:                     }
837:                     </code>
838:                 
839:                   Remarks:
840:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
841:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
842:                     data.
843:                   *****************************************************************************/
844:                 
845:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
846:                 {
847:                     uartReg[id]->tx.reg = data;
9D00CB84  30A500FF   ANDI A1, A1, 255
9D00CB88  AC650020   SW A1, 32(V1)
9D00CC6C  30C600FF   ANDI A2, A2, 255
9D00CC70  AC660020   SW A2, 32(V1)
848:                 }
849:                 
850:                 
851:                 /*******************************************************************************
852:                   Function:
853:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
854:                 
855:                   Summary:
856:                     Routine to send data through the UART.
857:                 
858:                   Description:
859:                     This routine allows the caller to send data of any permitted size through
860:                     the UART.
861:                 
862:                   Precondition:
863:                     The UART module should have been appropriately configured.  The configuration must
864:                     have been for desired data size.  The transmitter must have been ready,
865:                     although not necessarily enabled yet.
866:                 
867:                   Parameters:
868:                     id      - Identifies the desired UART module.
869:                 
870:                     data    - Data to be sent.
871:                 
872:                   Returns:
873:                     None
874:                 
875:                   Example:
876:                     <code>
877:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
878:                 	
879:                 	if (UARTTransmitterIsReady(UART1))
880:                     {
881:                         UARTSendData(UART1, data);
882:                     }
883:                     </code>
884:                 
885:                   Remarks:
886:                     Size of the data word size depends on the current configuration (see
887:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
888:                   *****************************************************************************/
889:                 
890:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
891:                 {
892:                     uartReg[id]->tx.reg = data.__data;
893:                 }
894:                 
895:                 /*******************************************************************************
896:                   Function:
897:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
898:                 
899:                   Summary:
900:                     Routine to detect if the UART module has finshed transmitting the most recent
901:                     data.
902:                 
903:                   Description:
904:                     This routine determines if the transmitter has finished sending all
905:                     available data.
906:                 
907:                   Preconditions:
908:                     The UART module should have been appropriately configured and enabled and data
909:                     sent to the UART TX buffer.
910:                 
911:                   Parameters:
912:                     id      - Identifies the desired UART module.
913:                 
914:                   Returns:
915:                     Boolean identifying if the transmission has completed:
916:                     * TRUE    - If the transmitter has completed sending the data
917:                     * FALSE   - If the transmitter is still busy sending the data
918:                 
919:                   Example:
920:                     <code>
921:                 	if (UARTTransmissionHasCompleted(UART1))
922:                     {
923:                         // Perform any tasks necessary when all data has been sent
924:                     }
925:                     </code>
926:                 
927:                   Remarks:
928:                   *****************************************************************************/
929:                 
930:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
931:                 {
932:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
9D00CC80  00042080   SLL A0, A0, 2
9D00CC84  3C029D01   LUI V0, -25343
9D00CC88  24420290   ADDIU V0, V0, 656
9D00CC8C  00822021   ADDU A0, A0, V0
9D00CC90  8C830000   LW V1, 0(A0)
9D00CC94  8C620010   LW V0, 16(V1)
9D00CC98  30420100   ANDI V0, V0, 256
933:                 }
934:                 
935:                 
936:                 /*******************************************************************************
937:                   Function:
938:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
939:                 
940:                   Summary:
941:                     Routine to detect if the receiver has data available.
942:                 
943:                   Description:
944:                     This routine determines if the receiver has data available to be read.
945:                 
946:                   Precondition:
947:                     The UART module must have been configured appropriately and enabled. A complete
948:                     data frame must have been sent to the UART before it will return a TRUE.
949:                 
950:                   Parameters:
951:                     id      - Identifies the desired UART module.
952:                 
953:                   Returns:
954:                     Boolean identifying whether or not data is available:
955:                     * TRUE    - If the receiver has data available
956:                     * FALSE   - If the receiver does not have data availble
957:                 
958:                   Example:
959:                     <code>
960:                     UART_DATA data;
961:                 	
962:                 	if (UARTReceivedDataIsAvailable(UART1))
963:                     {
964:                         data = UARTGetData(UART1);
965:                     }
966:                     </code>
967:                 
968:                   Remarks:
969:                     This routine provides the same information as the UART_DATA_READY line
970:                     status flag.
971:                   *****************************************************************************/
972:                 
973:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
974:                 {
975:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
9D00CB28  00042080   SLL A0, A0, 2
9D00CB2C  3C029D01   LUI V0, -25343
9D00CB30  24420290   ADDIU V0, V0, 656
9D00CB34  00822021   ADDU A0, A0, V0
9D00CB38  8C830000   LW V1, 0(A0)
9D00CB3C  8C640010   LW A0, 16(V1)
9D00CB40  30840001   ANDI A0, A0, 1
9D00CBB0  00048080   SLL S0, A0, 2
9D00CBB4  3C029D01   LUI V0, -25343
9D00CBB8  24420290   ADDIU V0, V0, 656
9D00CBBC  02028021   ADDU S0, S0, V0
9D00CBC0  8E030000   LW V1, 0(S0)
9D00CBC4  8C620010   LW V0, 16(V1)
9D00CBC8  30420001   ANDI V0, V0, 1
9D00CBE8  3C029D01   LUI V0, -25343
9D00CBEC  24420290   ADDIU V0, V0, 656
9D00CBF8  8C430010   LW V1, 16(V0)
9D00CBFC  30630001   ANDI V1, V1, 1
9D00CCDC  00041080   SLL V0, A0, 2
9D00CCE0  3C129D01   LUI S2, -25343
9D00CCE4  26520290   ADDIU S2, S2, 656
9D00CCE8  00529021   ADDU S2, V0, S2
9D00CCF4  8C430010   LW V1, 16(V0)
9D00CCF8  30630001   ANDI V1, V1, 1
9D00CDC4  00042080   SLL A0, A0, 2
9D00CDC8  3C029D01   LUI V0, -25343
9D00CDCC  24420290   ADDIU V0, V0, 656
9D00CDD0  00822021   ADDU A0, A0, V0
9D00CDD4  8C830000   LW V1, 0(A0)
9D00CDD8  8C640010   LW A0, 16(V1)
9D00CDDC  30840001   ANDI A0, A0, 1
976:                 }
977:                 
978:                 
979:                 /*******************************************************************************
980:                   Function:
981:                     BYTE UARTGetDataByte ( UART_MODULE id )
982:                 
983:                   Summary:
984:                     Routine to get a byte of data received by the UART.
985:                 
986:                   Description:
987:                     This routine allows the caller to read a byte of data received by the UART.
988:                 
989:                   Precondition:
990:                     The UART module must have been appropriately configured, the configuration must
991:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
992:                     been enabled.  Also, a complete data frame must have been received by the UART.
993:                 
994:                   Parameters:
995:                     id      - Identifies the desired UART module.
996:                 
997:                   Returns:
998:                     A byte of data received by the UART.
999:                 
1000:                  Example:
1001:                    <code>
1002:                    unsigned char data;
1003:                	
1004:                	if (UARTReceivedDataIsAvailable(UART1))
1005:                    {
1006:                        data = UARTGetDataByte(UART1);
1007:                    }
1008:                    </code>
1009:                
1010:                  Remarks:
1011:                    This routine is optimized for receiving 8-bit data through the UART.
1012:                  *****************************************************************************/
1013:                
1014:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1015:                {
1016:                    return (BYTE)uartReg[id]->rx.reg;
9D00CB4C  8C620030   LW V0, 48(V1)
9D00CBD4  8C620030   LW V0, 48(V1)
9D00CC08  8C420030   LW V0, 48(V0)
9D00CD04  8C450030   LW A1, 48(V0)
9D00CDE8  8C630030   LW V1, 48(V1)
1017:                }
1018:                
1019:                
1020:                /*******************************************************************************
1021:                  Function:
1022:                    UART_DATA UARTGetData ( UART_MODULE id )
1023:                
1024:                  Summary:
1025:                    Routine to get data received by the UART.
1026:                
1027:                  Description:
1028:                    This routine allows the caller to read a data word received by the UART.
1029:                
1030:                  Precondition:
1031:                    The module must have been appropriately configured, the UART module must have been
1032:                    enabled, and a complete data frame must have been received by the UART.
1033:                
1034:                  Parameters:
1035:                    id      - Identifies the desired UART module.
1036:                
1037:                  Returns:
1038:                    Data received by the UART.
1039:                
1040:                  Example:
1041:                    <code>
1042:                    UART_DATA data;
1043:                	
1044:                	if (UARTReceivedDataIsAvailable(UART1))
1045:                    {
1046:                        data = UARTGetData(UART1);
1047:                    }
1048:                    </code>
1049:                
1050:                  Remarks:
1051:                    Size of the data word depends on the current configuration (see
1052:                    UARTSetLineControl).
1053:                  *****************************************************************************/
1054:                
1055:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1056:                {
1057:                    UART_DATA data;
1058:                
1059:                    data.__data = uartReg[id]->rx.reg;
1060:                
1061:                    return data;
1062:                }
1063:                
1064:                
1065:                /*******************************************************************************
1066:                  Function:
1067:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1068:                
1069:                  Summary:
1070:                    Routine to program the address for which the UART module may watch.
1071:                
1072:                  Description:
1073:                    This routine programs the 8-bit address for which the module may watch.
1074:                
1075:                  Precondition:
1076:                    None
1077:                
1078:                  Parameters:
1079:                    id      - Identifies the desired UART module.
1080:                
1081:                    address - 8-bit address for which the module will watch.
1082:                
1083:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1084:                              * TRUE - Enable address watch mode
1085:                              * FALSE - Disable address watch mode
1086:                
1087:                  Returns:
1088:                    None.
1089:                
1090:                  Example:
1091:                    <code>
1092:                    #define SLAVE_ADDRESS  0x42
1093:                	
1094:                	UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1095:                    </code>
1096:                
1097:                  Remarks:
1098:                    The module can be placed into a mode where it will ignore all data received
1099:                    until it identifies the programmed adress.  After the programmed address
1100:                    has been identified, it will begin receiving data normally.  This mode is
1101:                    particularly useful for supporting the IEEE-485 protocol.
1102:                  *****************************************************************************/
1103:                
1104:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1105:                
1106:                
1107:                /*******************************************************************************
1108:                  Function:
1109:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1110:                
1111:                  Summary:
1112:                    Routine to enable or disable recognition of the programmed address byte.
1113:                
1114:                  Description:
1115:                    This routine can enable or disable the "address watch" mode.  In this mode,
1116:                    the UART module will ignore all data until it recognizes the programmed address.
1117:                
1118:                  Precondition:
1119:                    UART should have already been enabled and set with watch address.
1120:                
1121:                  Parameters:
1122:                    id      - Identifies the desired UART module.
1123:                
1124:                    watch   - Determines if the "address watch" mode will be enabled or
1125:                              disabled.
1126:                              * TRUE - Enable address watch mode
1127:                              * FALSE - Disable address watch mode
1128:                
1129:                  Returns:
1130:                    None.
1131:                
1132:                  Example:
1133:                    <code>
1134:                    #define SLAVE_ADDRESS 0x42
1135:                	
1136:                	// Set the address, but don't enable the watch until later,
1137:                	// UART continues to receive data normally
1138:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1139:                
1140:                    // ...
1141:                
1142:                    // Now begin to ignore all UART traffic until we are addressed
1143:                    UARTWatchForAddress(UART1, TRUE);
1144:                    </code>
1145:                
1146:                  Remarks:
1147:                    The UART module can be placed into a mode where it will ignore all data received
1148:                    until it identifies the programmed address.  After the programmed address
1149:                    has been identified, it will begin receiving data normally.  This mode is
1150:                    particularly useful for supporting the IEEE-485 protocol.
1151:                  *****************************************************************************/
1152:                
1153:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1154:                
1155:                
1156:                /*******************************************************************************
1157:                  Function:
1158:                    void UARTSendBreak ( UART_MODULE id )
1159:                
1160:                  Summary:
1161:                    Routine to send a break signal from the UART.
1162:                
1163:                  Description:
1164:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1165:                
1166:                  Precondition:
1167:                    The UART should have been appropriately configured.  The transmitter should
1168:                    be idle, although not necessarily enabled yet.
1169:                
1170:                  Parameters:
1171:                    id      - Identifies the desired UART module.
1172:                
1173:                  Returns:
1174:                    None
1175:                
1176:                  Example:
1177:                    <code>
1178:                    if (UARTTransmissionHasCompleted(UART1))
1179:                    {
1180:                        UARTSendBreak(UART1);
1181:                    }
1182:                    </code>
1183:                
1184:                  Remarks:
1185:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1186:                    data may be pre-loaded into the FIFO and it will be send immediately
1187:                    following the break signal.
1188:                  *****************************************************************************/
1189:                
1190:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1191:                {
1192:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1193:                }
1194:                
1195:                
1196:                /*******************************************************************************
1197:                  Function:
1198:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1199:                
1200:                  Summary:
1201:                    Routine to automatically determine the data rate (bits-per-second) of an
1202:                    external transmitter to the UART.
1203:                
1204:                  Description:
1205:                    This routine initiates the process of automatically determining the data
1206:                    rate (bits-per-second) of an external transmitter to the UART.
1207:                
1208:                  Precondition:
1209:                    The UART should have been appropriately configured.  The transmitter should
1210:                    be idle, although not necessarily enabled yet.
1211:                
1212:                  Parameters:
1213:                    id      - Identifies the desired UART module.
1214:                
1215:                  Returns:
1216:                    None
1217:                
1218:                  Example:
1219:                    <code>
1220:                	// See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1221:                	// methods to detect a Break.
1222:                	
1223:                    if (breakDetected && useAutoRateDetect) 
1224:                    {
1225:                        UARTStartAutoDataRateDetect (UART1);
1226:                    }
1227:                    </code>
1228:                
1229:                  Remarks:
1230:                    The UART module begins measuring the data rate beginning at the next start
1231:                    bit.  The external transmitter should send an alternating pattern (0x55)
1232:                    for the byte to be measured for an effective rate detection.  To ensure
1233:                    an effective measurement sequence, this can be done immediately following
1234:                    a break reception. It is important that this UART module is not
1235:                	transmitting data while it is trying to detect RX baud rate, see the 
1236:                	"PIC32 Family Reference Manual, Sect. 21 UART".
1237:                  *****************************************************************************/
1238:                
1239:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1240:                {
1241:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1242:                }
1243:                
1244:                
1245:                
1246:                /*******************************************************************************
1247:                  Function:
1248:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1249:                
1250:                  Summary:
1251:                    Routine to identify when automatic data rate detection has completed.
1252:                
1253:                  Description:
1254:                    This routine checks to see if automatic data rate detection has completed.
1255:                
1256:                  Precondition:
1257:                    Automatic rate detection should have been previously started.
1258:                
1259:                  Parameters:
1260:                    id      - Identifies the desired UART module.
1261:                
1262:                  Returns:
1263:                    * TRUE    - Indicates that automatic rate detection has completed.
1264:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1265:                
1266:                  Example:
1267:                    <code>
1268:                    #define PERIPHERAL_CLOCK    10000000
1269:                	
1270:                	UINT32 currentRate;
1271:                	
1272:                	if (UARTDataRateDetected(UART1))
1273:                    {
1274:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1275:                    }
1276:                    </code>
1277:                
1278:                  Remarks:
1279:                    This routine returns FALSE after automatic rate detection
1280:                    has been started but before rate is detectdd, it will return TRUE
1281:                	at any other time.
1282:                  *****************************************************************************/
1283:                
1284:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1285:                {
1286:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1287:                }
1288:                
1289:                #ifdef __cplusplus
1290:                  }
1291:                #endif
1292:                
1293:                #endif // _UART_h_
1294:                
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
118:                         pb_clock >>= 1;
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
170:                     {
171:                         wait_states++;
172:                         sys_clock -= FLASH_SPEED_HZ;
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
176:                     mCheConfigure(wait_states);
177:                     INTRestoreInterrupts(int_status);
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
227:                     {
228:                         wait_states++;
229:                         sys_clock -= FLASH_SPEED_HZ;
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
233:                     mCheConfigure(wait_states);
234:                     INTRestoreInterrupts(int_status);
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
279:                 
280:                     int_status=INTDisableInterrupts();
281:                 
282:                     mBMXDisableDRMWaitState();
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
286:                     cache_status |= CHE_CONF_PF_ALL;
287:                     mCheConfigure(cache_status);
288:                     CheKseg0CacheOn();
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
9D00D744  0F4040A2   JAL INTDisableInterrupts
9D00D748  00000000   NOP
342:                 
343:                     mBMXDisableDRMWaitState();
9D00D74C  24040040   ADDIU A0, ZERO, 64
9D00D750  3C03BF88   LUI V1, -16504
9D00D754  AC642004   SW A0, 8196(V1)
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
358:                     {
359:                         cache_status = mCheGetCon();
360:                         cache_status |= CHE_CONF_PF_ALL;
361:                         mCheConfigure(cache_status);
362:                         CheKseg0CacheOn();
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
367:                     pb_clk >>= OSCCONbits.PBDIV;
9D00D758  3C03BF81   LUI V1, -16511
9D00D75C  8C63F000   LW V1, -4096(V1)
368:                 
369:                     INTRestoreInterrupts(int_status);
9D00D760  0F404038   JAL INTRestoreInterrupts
9D00D764  00402021   ADDU A0, V0, ZERO
370:                 
371:                     return pb_clk;
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/vpc-32.c  -----------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /* 
20:                   * File:   vpc-32.c
21:                   * Author: Jacques Deschênes
22:                   *
23:                   * Created on 26 août 2013, 07:38
24:                   */
25:                  
26:                  #include <stdio.h>
27:                  #include <stdlib.h>
28:                  #include <plib.h>
29:                  
30:                  
31:                  #include "hardware/HardwareProfile.h"
32:                  #include "hardware/ntsc.h"
33:                  #include "hardware/serial_comm.h"
34:                  #include "hardware/keyboard.h"
35:                  #include "hardware/Pinguino/diskio.h"
36:                  #include "console.h"
37:                  #include "hardware/Pinguino/ff.h"
38:                  #include "vpForth/opcodes.h"
39:                  #include "vpForth/vpForth.h"
40:                  #include "sound.h"
41:                  
42:                  // PIC32MX150F128B Configuration Bit Settings
43:                  #include <xc.h>
44:                  
45:                  // DEVCFG3
46:                  // USERID = No Setting
47:                  #pragma config PMDL1WAY = OFF           // permet plusieurs configurations des périphériques.
48:                  #pragma config IOL1WAY = OFF            // permet plusieurs configuration des broches.
49:                  
50:                  // DEVCFG2
51:                  #pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
52:                  #if SYSCLK==40000000L
53:                  #pragma config FPLLMUL = MUL_16         // SYSCLK=40Mhz
54:                  #else
55:                  #pragma config FPLLMUL = MUL_15          // PLL Multiplier (15x Multiplier) SYSCLK=37,5Mhz
56:                  #endif
57:                  #pragma config FPLLODIV = DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)
58:                  
59:                  // DEVCFG1
60:                  #pragma config FNOSC = PRIPLL           // Oscillator Selection Bits (Primary Osc w/PLL (XT+,HS+,EC+PLL))
61:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
62:                  #pragma config IESO = OFF               // Internal/External Switch Over (Disabled)
63:                  #pragma config POSCMOD = HS             // Primary Oscillator Configuration (XT osc mode)
64:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
65:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
66:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
67:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
68:                  
69:                  // DEVCFG0
70:                  #pragma config JTAGEN = OFF             // JTAG Enable (JTAG Disabled)
71:                  #pragma config ICESEL = ICS_PGx1        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
72:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
73:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
74:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
75:                  
76:                  
77:                  
78:                  const char *msg1=" ntsc video target\r";
79:                  const char *msg2="01234567890123456789012345678901234567890123456789012"; // 53 caractères par ligne
80:                  
81:                  
82:                  void test_pattern(void){
9D00E870  27BDFFE8   ADDIU SP, SP, -24
9D00E874  AFBF0014   SW RA, 20(SP)
9D00E878  3C06A000   LUI A2, -24576
9D00E87C  24C60370   ADDIU A2, A2, 880
9D00E880  00C03821   ADDU A3, A2, ZERO
9D00E884  24C523F0   ADDIU A1, A2, 9200
9D00E888  00C01021   ADDU V0, A2, ZERO
9D00E8A8  24E30028   ADDIU V1, A3, 40
9D00E8CC  24E71AE8   ADDIU A3, A3, 6888
83:                      int i,j;
84:                      for (i=0;i<VRES;i++){
9D00E8A0  5445FFFD   BNEL V0, A1, 0x9D00E898
9D00E8A4  AC440000   SW A0, 0(V0)
85:                          video_bmp[i][0]=0x80000000;
9D00E88C  3C048000   LUI A0, -32768
9D00E894  AC440000   SW A0, 0(V0)
86:                          video_bmp[i][HRES/32-1]=1;
9D00E890  24030001   ADDIU V1, ZERO, 1
9D00E898  AC430024   SW V1, 36(V0)
9D00E89C  24420028   ADDIU V0, V0, 40
87:                      }
88:                      for (i=0;i<HRES/32;i++){
9D00E8BC  54C3FFFD   BNEL A2, V1, 0x9D00E8B4
9D00E8C0  ACC20000   SW V0, 0(A2)
9D00E8C4  3C02A000   LUI V0, -24576
9D00E8C8  24420C60   ADDIU V0, V0, 3168
89:                          video_bmp[0][i]=0xffffffff;
9D00E8AC  2402FFFF   ADDIU V0, ZERO, -1
9D00E8B0  ACC20000   SW V0, 0(A2)
90:                          video_bmp[VRES-1][i]=0xffffffff;
9D00E8B4  ACC223C8   SW V0, 9160(A2)
9D00E8B8  24C60004   ADDIU A2, A2, 4
91:                      }
92:                      for (i=VRES/4;i<VRES/2+VRES/4;i++){
9D00E904  5447FFFB   BNEL V0, A3, 0x9D00E8F4
9D00E908  AC460000   SW A2, 0(V0)
93:                          video_bmp[i][2]=0xFF00FF00;
9D00E8D0  3C06FF00   LUI A2, -256
9D00E8D4  34C6FF00   ORI A2, A2, -256
9D00E8F0  AC460000   SW A2, 0(V0)
94:                          video_bmp[i][3]=0xF0F0F0F0;
9D00E8D8  3C05F0F0   LUI A1, -3856
9D00E8DC  34A5F0F0   ORI A1, A1, -3856
9D00E8F4  AC450004   SW A1, 4(V0)
95:                          video_bmp[i][4]=0xcccccccc;
9D00E8E0  3C04CCCC   LUI A0, -13108
9D00E8E4  3484CCCC   ORI A0, A0, -13108
9D00E8F8  AC440008   SW A0, 8(V0)
96:                          video_bmp[i][5]=0xaaaaaaaa;
9D00E8E8  3C03AAAA   LUI V1, -21846
9D00E8EC  3463AAAA   ORI V1, V1, -21846
9D00E8FC  AC43000C   SW V1, 12(V0)
9D00E900  24420028   ADDIU V0, V0, 40
97:                      }//i
98:                      print(LOCAL_CON,msg1);
9D00E90C  00002021   ADDU A0, ZERO, ZERO
9D00E910  0F402624   JAL print
9D00E914  8F858050   LW A1, -32688(GP)
99:                      print(LOCAL_CON,msg2);
9D00E918  00002021   ADDU A0, ZERO, ZERO
9D00E91C  0F402624   JAL print
9D00E920  8F858054   LW A1, -32684(GP)
100:                 }//test_pattern()
9D00E924  8FBF0014   LW RA, 20(SP)
9D00E928  03E00008   JR RA
9D00E92C  27BD0018   ADDIU SP, SP, 24
101:                 
102:                 const unsigned int e3k[]={ // rencontre du 3ième type
103:                 784,500, // sol4
104:                 880,500,// la4
105:                 698,500,// fa4
106:                 349,500,// fa3
107:                 523,500,// do4
108:                 0,0
109:                 };
110:                 
111:                 void main(void) {
9D00E930  27BDFFE8   ADDIU SP, SP, -24
9D00E934  AFBF0014   SW RA, 20(SP)
112:                     int code;
113:                     short key;
114:                     unsigned char buff[BLK_SIZE];
115:                     int i;
116:                     unsigned int size;
117:                 
118:                     HardwareInit();
9D00E938  0F4035CF   JAL HardwareInit
9D00E93C  00000000   NOP
119:                     UartInit(STDIO,115200,DEFAULT_LINE_CTRL);
9D00E940  24040001   ADDIU A0, ZERO, 1
9D00E944  3C050001   LUI A1, 1
9D00E948  34A5C200   ORI A1, A1, -15872
9D00E94C  0F4032AD   JAL UartInit
9D00E950  00003021   ADDU A2, ZERO, ZERO
120:                     ln_cnt=0;
9D00E954  AF8080F8   SW ZERO, -32520(GP)
121:                     video=0;
9D00E958  AF8080F4   SW ZERO, -32524(GP)
122:                     test_pattern();
9D00E95C  0F403A1C   JAL test_pattern
9D00E960  00000000   NOP
123:                     UartPrint(STDOUT,"video initialization\r");
9D00E964  24040001   ADDIU A0, ZERO, 1
9D00E968  3C059D01   LUI A1, -25343
9D00E96C  0F40330F   JAL UartPrint
9D00E970  24A5EFD4   ADDIU A1, A1, -4140
124:                     VideoInit();
9D00E974  0F403383   JAL VideoInit
9D00E978  00000000   NOP
125:                     delay_ms(500);
9D00E97C  0F403644   JAL delay_ms
9D00E980  240401F4   ADDIU A0, ZERO, 500
126:                     UartPrint(STDOUT,"keyboard initialization: ");
9D00E984  24040001   ADDIU A0, ZERO, 1
9D00E988  3C059D01   LUI A1, -25343
9D00E98C  0F40330F   JAL UartPrint
9D00E990  24A5EFEC   ADDIU A1, A1, -4116
127:                     if (KeyboardInit()){
9D00E994  0F402161   JAL KeyboardInit
9D00E998  00000000   NOP
9D00E99C  10400006   BEQ V0, ZERO, 0x9D00E9B8
9D00E9A0  24040001   ADDIU A0, ZERO, 1
128:                         UartPrint(STDOUT,"OK\r");
9D00E9A4  3C059D01   LUI A1, -25343
9D00E9A8  0F40330F   JAL UartPrint
9D00E9AC  24A5F008   ADDIU A1, A1, -4088
129:                         comm_channel=LOCAL_CON;
9D00E9B0  0B403A77   J 0x9D00E9DC
9D00E9B4  A3808088   SB ZERO, -32632(GP)
130:                     }else{
131:                         UartPrint(STDOUT,"keyboard error\r");
9D00E9B8  3C059D01   LUI A1, -25343
9D00E9BC  0F40330F   JAL UartPrint
9D00E9C0  24A5F00C   ADDIU A1, A1, -4084
132:                         UartPrint(STDOUT,"Using uart2 channel.\r");
9D00E9C4  24040001   ADDIU A0, ZERO, 1
9D00E9C8  3C059D01   LUI A1, -25343
9D00E9CC  0F40330F   JAL UartPrint
9D00E9D0  24A5F01C   ADDIU A1, A1, -4068
133:                         comm_channel=SERIAL_CON;
9D00E9D4  24020001   ADDIU V0, ZERO, 1
9D00E9D8  A3828088   SB V0, -32632(GP)
134:                     }
135:                     text_coord_t cpos;
136:                     UartPrint(STDOUT,"SD initialization: ");
9D00E9DC  24040001   ADDIU A0, ZERO, 1
9D00E9E0  3C059D01   LUI A1, -25343
9D00E9E4  0F40330F   JAL UartPrint
9D00E9E8  24A5F034   ADDIU A1, A1, -4044
137:                     if (!mount(0)){
9D00E9EC  0F40351D   JAL mount
9D00E9F0  00002021   ADDU A0, ZERO, ZERO
9D00E9F4  14400005   BNE V0, ZERO, 0x9D00EA0C
9D00E9F8  24040001   ADDIU A0, ZERO, 1
138:                         UartPrint(STDOUT,"Failed\r");
9D00E9FC  3C059D01   LUI A1, -25343
9D00EA00  0F40330F   JAL UartPrint
9D00EA04  24A5F048   ADDIU A1, A1, -4024
139:                     }
140:                 //    FIL *fp;
141:                 //    FILINFO *fo;
142:                 //    fp=malloc(sizeof(FIL));
143:                 //    fo=malloc(sizeof(FILINFO));
144:                 //    if (!f_open(fp,"readme.txt",FA_READ)){
145:                 //        f_stat("readme.txt",fo);
146:                 //        if (!f_read(fp,buff,fo->fsize,(UINT*)&i)){
147:                 //            clear_screen();
148:                 //            buff[fo->fsize]=0;
149:                 //            print("file size: ");
150:                 //            print_int(i,10);
151:                 //            put_char('\r');
152:                 //            print(buff);
153:                 //            f_close(fp);
154:                 //            if (i==40){
155:                 //                f_open(fp,"readme.txt",FA_WRITE);
156:                 //                f_lseek(fp,i);
157:                 //                f_write(fp,"test ecriture\r",14,(UINT*)&i);
158:                 //                f_stat("readme.txt",fo);
159:                 //                print("grandeur apres ecriture: ");
160:                 //                print_int(fo->fsize,10);
161:                 //                f_close(fp);
162:                 //            }
163:                 //            free(fp);
164:                 //            free(fo);
165:                 //        }
166:                 //    }
167:                 //    UartPrint(STDOUT,"lecture du registre CSD\r");
168:                 //    clear_screen();
169:                 //    size=disk_ioctl(0,GET_SECTOR_SIZE,buff);
170:                 //    print_int(*(unsigned short *)buff,10);
171:                 //    put_char('\r');
172:                 //    size=disk_ioctl(0,GET_SECTOR_COUNT,buff);
173:                 //    print_int(*(int*)buff,10);
174:                 //    put_char('\r');
175:                 //    size=disk_ioctl(0,GET_BLOCK_SIZE,buff);
176:                 //    print_int(*(int*)buff,10);
177:                 //    put_char('\r');
178:                 //    for (i=511;i;i--){
179:                 //        buff[i]=255;
180:                 //    }
181:                 //    while (1);
182:                 //    delay_ms(2000);
183:                     UartPrint(STDOUT,"sound initialization.\r");
9D00EA08  24040001   ADDIU A0, ZERO, 1
9D00EA0C  3C059D01   LUI A1, -25343
9D00EA10  0F40330F   JAL UartPrint
9D00EA14  24A5F050   ADDIU A1, A1, -4016
184:                     tune(&e3k[0]);
9D00EA18  3C049D01   LUI A0, -25343
9D00EA1C  0F403481   JAL tune
9D00EA20  2484F0D0   ADDIU A0, A0, -3888
185:                     UartPrint(STDOUT,"initialization completed.\r");
9D00EA24  24040001   ADDIU A0, ZERO, 1
9D00EA28  3C059D01   LUI A1, -25343
9D00EA2C  0F40330F   JAL UartPrint
9D00EA30  24A5F068   ADDIU A1, A1, -3992
186:                     set_cursor(CR_BLOCK);
9D00EA34  0F40271D   JAL set_cursor
9D00EA38  24040001   ADDIU A0, ZERO, 1
187:                     clear_screen();
9D00EA3C  0F402616   JAL clear_screen
9D00EA40  00000000   NOP
188:                     shell();
9D00EA44  0F40397F   JAL shell
9D00EA48  00000000   NOP
189:                 } // main()
9D00EA4C  8FBF0014   LW RA, 20(SP)
9D00EA50  03E00008   JR RA
9D00EA54  27BD0018   ADDIU SP, SP, 24
190:                 
191:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/sound.c  ------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   sound.c
20:                   * Author: Jacques Deschênes
21:                   *
22:                   * Created on 13 septembre 2013, 20:42
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "hardware/HardwareProfile.h"
27:                  #include "sound.h"
28:                  
29:                  
30:                  
31:                  volatile unsigned char fSound=0; // indicateurs booléins
32:                  volatile unsigned int duration;
33:                  volatile unsigned int *tones_list;
34:                  
35:                  
36:                  
37:                  void tone(unsigned int freq, // fréquence en hertz
38:                            unsigned int msec){ // durée en  millisecondes
39:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
40:                      OC3CONbits.OCM = 5; //mode pwm
9D00D14C  3C02BF80   LUI V0, -16512
9D00D150  8C433400   LW V1, 13312(V0)
9D00D154  24060005   ADDIU A2, ZERO, 5
9D00D158  7CC31004   INS V1, A2, 0, 3
9D00D15C  AC433400   SW V1, 13312(V0)
41:                      OC3CONbits.OCTSEL=1; // timer 3
9D00D160  8C433400   LW V1, 13312(V0)
9D00D164  24060001   ADDIU A2, ZERO, 1
9D00D168  7CC318C4   INS V1, A2, 3, 1
9D00D16C  AC433400   SW V1, 13312(V0)
42:                      OC3RS=0;
9D00D170  3C03BF80   LUI V1, -16512
9D00D174  AC603420   SW ZERO, 13344(V1)
43:                      T3CON=0;
9D00D178  3C03BF80   LUI V1, -16512
9D00D17C  AC600A00   SW ZERO, 2560(V1)
44:                      T3CONbits.TCKPS=3;
9D00D180  3C03BF80   LUI V1, -16512
9D00D184  8C670A00   LW A3, 2560(V1)
9D00D188  24080003   ADDIU T0, ZERO, 3
9D00D18C  7D073104   INS A3, T0, 4, 3
9D00D190  AC670A00   SW A3, 2560(V1)
45:                      PR3=(SYSCLK/8/freq)-1; // rapport cyclique 50%
9D00D194  3C070047   LUI A3, 71
9D00D198  34E7868C   ORI A3, A3, -31092
9D00D19C  00E4001B   DIVU A3, A0
9D00D1A0  008001F4   TEQ A0, ZERO
9D00D1A4  00003812   MFLO A3, 0
9D00D1A8  24E7FFFF   ADDIU A3, A3, -1
9D00D1AC  3C08BF80   LUI T0, -16512
9D00D1B0  AD070A20   SW A3, 2592(T0)
46:                      OC3R=SYSCLK/16/freq;
9D00D1B4  3C070023   LUI A3, 35
9D00D1B8  34E7C346   ORI A3, A3, -15546
9D00D1BC  00E4001B   DIVU A3, A0
9D00D1C0  008001F4   TEQ A0, ZERO
9D00D1C4  00003812   MFLO A3, 0
9D00D1C8  3C08BF80   LUI T0, -16512
9D00D1CC  AD073410   SW A3, 13328(T0)
47:                      duration=msec;
9D00D1D0  AF85811C   SW A1, -32484(GP)
48:                      fSound |=TONE_ON;
9D00D1D4  93848098   LBU A0, -32616(GP)
9D00D1D8  308400FF   ANDI A0, A0, 255
9D00D1DC  34840001   ORI A0, A0, 1
9D00D1E0  A3848098   SB A0, -32616(GP)
49:                      mTone_on();
9D00D1E4  8C443400   LW A0, 13312(V0)
9D00D1E8  7CC47BC4   INS A0, A2, 15, 1
9D00D1EC  AC443400   SW A0, 13312(V0)
50:                      T3CONbits.ON=1;
9D00D1F0  8C620A00   LW V0, 2560(V1)
9D00D1F4  7CC27BC4   INS V0, A2, 15, 1
9D00D1F8  AC620A00   SW V0, 2560(V1)
51:                  } //tone();
9D00D1FC  03E00008   JR RA
9D00D200  00000000   NOP
52:                  
53:                  // joue une mélodie en arrière plan
54:                  void tune(const unsigned int *buffer){
9D00D204  27BDFFE8   ADDIU SP, SP, -24
9D00D208  AFBF0014   SW RA, 20(SP)
55:                      tones_list=buffer;
9D00D20C  AF848118   SW A0, -32488(GP)
56:                      if (*tones_list && *(tones_list+1)){
9D00D210  8C820000   LW V0, 0(A0)
9D00D214  10400021   BEQ V0, ZERO, 0x9D00D29C
9D00D218  24830004   ADDIU V1, A0, 4
9D00D21C  8C820004   LW V0, 4(A0)
9D00D220  1040001F   BEQ V0, ZERO, 0x9D00D2A0
9D00D224  8FBF0014   LW RA, 20(SP)
57:                          fSound |= PLAY_TUNE;
9D00D228  93828098   LBU V0, -32616(GP)
9D00D22C  304200FF   ANDI V0, V0, 255
9D00D230  34420002   ORI V0, V0, 2
9D00D234  A3828098   SB V0, -32616(GP)
58:                          IPC3bits.T3IP=2;
9D00D238  3C02BF88   LUI V0, -16504
9D00D23C  8C4510C0   LW A1, 4288(V0)
9D00D240  24060002   ADDIU A2, ZERO, 2
9D00D244  7CC52084   INS A1, A2, 2, 3
9D00D248  AC4510C0   SW A1, 4288(V0)
59:                          IPC3bits.T3IS=3;
9D00D24C  8C4510C0   LW A1, 4288(V0)
9D00D250  24060003   ADDIU A2, ZERO, 3
9D00D254  7CC50804   INS A1, A2, 0, 2
9D00D258  AC4510C0   SW A1, 4288(V0)
60:                          IFS0bits.T3IF=0;
9D00D25C  3C02BF88   LUI V0, -16504
9D00D260  8C451030   LW A1, 4144(V0)
9D00D264  7C057384   INS A1, ZERO, 14, 1
9D00D268  AC451030   SW A1, 4144(V0)
61:                          IEC0bits.T3IE=1;
9D00D26C  3C02BF88   LUI V0, -16504
9D00D270  8C451060   LW A1, 4192(V0)
9D00D274  24060001   ADDIU A2, ZERO, 1
9D00D278  7CC57384   INS A1, A2, 14, 1
9D00D27C  AC451060   SW A1, 4192(V0)
62:                          tone(*tones_list++,*tones_list++);
9D00D280  8C820000   LW V0, 0(A0)
9D00D284  AF838118   SW V1, -32488(GP)
9D00D288  8C850004   LW A1, 4(A0)
9D00D28C  24830008   ADDIU V1, A0, 8
9D00D290  AF838118   SW V1, -32488(GP)
9D00D294  0F403453   JAL tone
9D00D298  00402021   ADDU A0, V0, ZERO
63:                      }
64:                  }//tune()
9D00D29C  8FBF0014   LW RA, 20(SP)
9D00D2A0  03E00008   JR RA
9D00D2A4  27BD0018   ADDIU SP, SP, 24
65:                  
66:                  
67:                  
68:                  void __ISR(_TIMER_3_VECTOR, IPL2SOFT)  T3Handler(void){
9D00D2A8  415DE800   RDPGPR SP, SP
9D00D2AC  401A7000   MFC0 K0, EPC
9D00D2B0  401B6000   MFC0 K1, Status
9D00D2B4  27BDFF90   ADDIU SP, SP, -112
9D00D2B8  AFBA006C   SW K0, 108(SP)
9D00D2BC  401A6002   MFC0 K0, SRSCtl
9D00D2C0  AFBB0068   SW K1, 104(SP)
9D00D2C4  AFBA0064   SW K0, 100(SP)
9D00D2C8  7C1B7844   INS K1, ZERO, 1, 15
9D00D2CC  377B0800   ORI K1, K1, 2048
9D00D2D0  409B6000   MTC0 K1, Status
9D00D2D4  AFBF0054   SW RA, 84(SP)
9D00D2D8  AFB90050   SW T9, 80(SP)
9D00D2DC  AFB8004C   SW T8, 76(SP)
9D00D2E0  AFAF0048   SW T7, 72(SP)
9D00D2E4  AFAE0044   SW T6, 68(SP)
9D00D2E8  AFAD0040   SW T5, 64(SP)
9D00D2EC  AFAC003C   SW T4, 60(SP)
9D00D2F0  AFAB0038   SW T3, 56(SP)
9D00D2F4  AFAA0034   SW T2, 52(SP)
9D00D2F8  AFA90030   SW T1, 48(SP)
9D00D2FC  AFA8002C   SW T0, 44(SP)
9D00D300  AFA70028   SW A3, 40(SP)
9D00D304  AFA60024   SW A2, 36(SP)
9D00D308  AFA50020   SW A1, 32(SP)
9D00D30C  AFA4001C   SW A0, 28(SP)
9D00D310  AFA30018   SW V1, 24(SP)
9D00D314  AFA20014   SW V0, 20(SP)
9D00D318  AFA10010   SW AT, 16(SP)
9D00D31C  00001012   MFLO V0, 0
9D00D320  AFA2005C   SW V0, 92(SP)
9D00D324  00001810   MFHI V1, 0
9D00D328  AFA30058   SW V1, 88(SP)
69:                      unsigned int f,d;
70:                         mT3ClearIntFlag();
9D00D32C  24034000   ADDIU V1, ZERO, 16384
9D00D330  3C02BF88   LUI V0, -16504
9D00D334  AC431034   SW V1, 4148(V0)
71:                         if (fSound==PLAY_TUNE){
9D00D338  93838098   LBU V1, -32616(GP)
9D00D33C  306300FF   ANDI V1, V1, 255
9D00D340  24020002   ADDIU V0, ZERO, 2
9D00D344  1462001F   BNE V1, V0, 0x9D00D3C4
9D00D348  8F828118   LW V0, -32488(GP)
72:                             f=*tones_list++;
9D00D34C  8C440000   LW A0, 0(V0)
9D00D350  24430004   ADDIU V1, V0, 4
9D00D354  AF838118   SW V1, -32488(GP)
73:                             d=*tones_list++;
9D00D358  8C450004   LW A1, 4(V0)
9D00D35C  24430008   ADDIU V1, V0, 8
74:                             if (d){
9D00D360  10A0000F   BEQ A1, ZERO, 0x9D00D3A0
9D00D364  AF838118   SW V1, -32488(GP)
75:                                  if (f){
9D00D368  10800005   BEQ A0, ZERO, 0x9D00D380
9D00D36C  00000000   NOP
76:                                      tone(f,d);
9D00D370  0F403453   JAL tone
9D00D374  00000000   NOP
9D00D378  0B4034F1   J 0x9D00D3C4
9D00D37C  00000000   NOP
77:                                  }else{
78:                                      duration=(*tones_list);
9D00D380  8C420008   LW V0, 8(V0)
9D00D384  AF82811C   SW V0, -32484(GP)
79:                                      fSound |= TONE_ON;
9D00D388  93828098   LBU V0, -32616(GP)
9D00D38C  304200FF   ANDI V0, V0, 255
9D00D390  34420001   ORI V0, V0, 1
9D00D394  A3828098   SB V0, -32616(GP)
9D00D398  0B4034F1   J 0x9D00D3C4
9D00D39C  00000000   NOP
80:                                  }
81:                             }else{
82:                                 fSound=0;
9D00D3A0  A3808098   SB ZERO, -32616(GP)
83:                                 IEC0bits.T3IE=0;
9D00D3A4  3C02BF88   LUI V0, -16504
9D00D3A8  8C431060   LW V1, 4192(V0)
9D00D3AC  7C037384   INS V1, ZERO, 14, 1
9D00D3B0  AC431060   SW V1, 4192(V0)
84:                                 T3CONbits.ON=0;
9D00D3B4  3C02BF80   LUI V0, -16512
9D00D3B8  8C430A00   LW V1, 2560(V0)
9D00D3BC  7C037BC4   INS V1, ZERO, 15, 1
9D00D3C0  AC430A00   SW V1, 2560(V0)
85:                             } // if 
86:                         }//if 
87:                  }// T3Handler
9D00D3C4  8FA2005C   LW V0, 92(SP)
9D00D3C8  00400013   MTLO V0, 0
9D00D3CC  8FA30058   LW V1, 88(SP)
9D00D3D0  00600011   MTHI V1, 0
9D00D3D4  8FBF0054   LW RA, 84(SP)
9D00D3D8  8FB90050   LW T9, 80(SP)
9D00D3DC  8FB8004C   LW T8, 76(SP)
9D00D3E0  8FAF0048   LW T7, 72(SP)
9D00D3E4  8FAE0044   LW T6, 68(SP)
9D00D3E8  8FAD0040   LW T5, 64(SP)
9D00D3EC  8FAC003C   LW T4, 60(SP)
9D00D3F0  8FAB0038   LW T3, 56(SP)
9D00D3F4  8FAA0034   LW T2, 52(SP)
9D00D3F8  8FA90030   LW T1, 48(SP)
9D00D3FC  8FA8002C   LW T0, 44(SP)
9D00D400  8FA70028   LW A3, 40(SP)
9D00D404  8FA60024   LW A2, 36(SP)
9D00D408  8FA50020   LW A1, 32(SP)
9D00D40C  8FA4001C   LW A0, 28(SP)
9D00D410  8FA30018   LW V1, 24(SP)
9D00D414  8FA20014   LW V0, 20(SP)
9D00D418  8FA10010   LW AT, 16(SP)
9D00D41C  41606000   DI ZERO
9D00D420  000000C0   EHB
9D00D424  8FBA006C   LW K0, 108(SP)
9D00D428  8FBB0068   LW K1, 104(SP)
9D00D42C  409A7000   MTC0 K0, EPC
9D00D430  8FBA0064   LW K0, 100(SP)
9D00D434  27BD0070   ADDIU SP, SP, 112
9D00D438  409A6002   MTC0 K0, SRSCtl
9D00D43C  41DDE800   WRPGPR SP, SP
9D00D440  409B6000   MTC0 K1, Status
9D00D444  42000018   ERET
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/shell.c  ------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  
20:                  /*
21:                   * File:   shell.h
22:                   * Author: Jacques Deschênes
23:                   *
24:                   * Created on 18 septembre 2013, 07:29
25:                   * Description: un environnement de commande simple pour le VPC-32.
26:                   *   liste des commandes:
27:                   *      ls     liste des fichiers sur la carte SD
28:                   *      rm     efface un fichier.
29:                   *      mv     renomme un fichier.
30:                   *      ed     ouvre l'éditeur
31:                   *      as     assemble un fichier écris en assembleur pour la machine virtuelle.
32:                   *      run    execute un programme compilé pour la machine virtuelle.
33:                   *      cp     copie un fichier
34:                   *      snd    envoie un fichier vers le port sériel
35:                   *      rcv    reçois un fichier par le port sériel
36:                   *      forth  lance l'environnement vpForth
37:                   */
38:                  
39:                  #include <string.h>
40:                  #include "hardware/HardwareProfile.h"
41:                  #include "hardware/keyboard.h"
42:                  #include "console.h"
43:                  #include "hardware/Pinguino/ff.h"
44:                  #include <plib.h>
45:                  
46:                  #define MAX_LINE_LEN 80
47:                  typedef struct{
48:                      char buff[MAX_LINE_LEN]; // chaîne saisie par l'utilisateur.
49:                      unsigned char len;  // longueur de la chaîne.
50:                      unsigned char first; // position du premier caractère du mot
51:                      unsigned char next; // position du du curseur de l'analyseur.
52:                  } input_buff_t;
53:                  
54:                  static input_buff_t cmd_line;
55:                  
56:                  typedef enum CMDS {CMD_LS,CMD_RM,CMD_MV,CMD_ED,CMD_AS,CMD_RUN,
57:                                     CMD_CP,CMD_SND,CMD_RCV,CMD_FORTH} cmds_t;
58:                  
59:                  #define CMD_LEN 10
60:                  const char *commands[CMD_LEN]={
61:                      "ls","rm","mv","ed","as","run","cp","snd","rcv","forth"};
62:                  
63:                  int cmd_search(char *target){
9D00E42C  27BDFFD8   ADDIU SP, SP, -40
9D00E430  AFBF0024   SW RA, 36(SP)
9D00E434  AFB30020   SW S3, 32(SP)
9D00E438  AFB2001C   SW S2, 28(SP)
9D00E43C  AFB10018   SW S1, 24(SP)
9D00E440  AFB00014   SW S0, 20(SP)
9D00E444  00809021   ADDU S2, A0, ZERO
64:                      int i;
65:                      for (i=CMD_LEN-1;i>=0;i--){
9D00E448  3C11A000   LUI S1, -24576
9D00E44C  26312A20   ADDIU S1, S1, 10784
9D00E450  24100009   ADDIU S0, ZERO, 9
9D00E454  2413FFFF   ADDIU S3, ZERO, -1
9D00E46C  2610FFFF   ADDIU S0, S0, -1
9D00E470  1613FFF9   BNE S0, S3, 0x9D00E458
9D00E474  2631FFFC   ADDIU S1, S1, -4
66:                          if (!strcmp(target,commands[i])){
9D00E458  02402021   ADDU A0, S2, ZERO
9D00E45C  0F403C40   JAL 0x9D00F100
9D00E460  8E250000   LW A1, 0(S1)
9D00E464  10400005   BEQ V0, ZERO, 0x9D00E47C
9D00E468  02001021   ADDU V0, S0, ZERO
67:                              break;
68:                          }
69:                      }
70:                      return i;
71:                  }//cmd_search()
9D00E478  02001021   ADDU V0, S0, ZERO
9D00E47C  8FBF0024   LW RA, 36(SP)
9D00E480  8FB30020   LW S3, 32(SP)
9D00E484  8FB2001C   LW S2, 28(SP)
9D00E488  8FB10018   LW S1, 24(SP)
9D00E48C  8FB00014   LW S0, 20(SP)
9D00E490  03E00008   JR RA
9D00E494  27BD0028   ADDIU SP, SP, 40
72:                  
73:                  int next_token(void){
74:                      cmd_line.first=cmd_line.next;
9D00E498  3C03A000   LUI V1, -24576
9D00E49C  246329A8   ADDIU V1, V1, 10664
9D00E4A0  90620052   LBU V0, 82(V1)
9D00E4A4  A0620051   SB V0, 81(V1)
75:                      while (cmd_line.first<cmd_line.len && cmd_line.buff[cmd_line.first]==' '){cmd_line.first++;}
9D00E4A8  90640050   LBU A0, 80(V1)
9D00E4AC  0044182B   SLTU V1, V0, A0
9D00E4B0  10600016   BEQ V1, ZERO, 0x9D00E50C
9D00E4B4  3C03A000   LUI V1, -24576
9D00E4B8  246329A8   ADDIU V1, V1, 10664
9D00E4BC  00431821   ADDU V1, V0, V1
9D00E4C0  80650000   LB A1, 0(V1)
9D00E4C4  24030020   ADDIU V1, ZERO, 32
9D00E4C8  14A30026   BNE A1, V1, 0x9D00E564
9D00E4CC  3C06A000   LUI A2, -24576
9D00E4D0  24C629A8   ADDIU A2, A2, 10664
9D00E4D4  24050020   ADDIU A1, ZERO, 32
9D00E4D8  24420001   ADDIU V0, V0, 1
9D00E4DC  304200FF   ANDI V0, V0, 255
9D00E4E0  14440004   BNE V0, A0, 0x9D00E4F4
9D00E4E4  00461821   ADDU V1, V0, A2
9D00E4E8  3C03A000   LUI V1, -24576
9D00E4EC  0B403943   J 0x9D00E50C
9D00E4F0  A06229F9   SB V0, 10745(V1)
9D00E4F4  80630000   LB V1, 0(V1)
9D00E4F8  5065FFF8   BEQL V1, A1, 0x9D00E4DC
9D00E4FC  24420001   ADDIU V0, V0, 1
9D00E500  3C03A000   LUI V1, -24576
9D00E504  0B403959   J 0x9D00E564
9D00E508  A06229F9   SB V0, 10745(V1)
76:                      cmd_line.next=cmd_line.first;
9D00E50C  3C03A000   LUI V1, -24576
9D00E510  0B403956   J 0x9D00E558
9D00E514  A06229FA   SB V0, 10746(V1)
9D00E564  3C03A000   LUI V1, -24576
9D00E568  246329A8   ADDIU V1, V1, 10664
9D00E56C  A0620052   SB V0, 82(V1)
77:                      while (cmd_line.next<cmd_line.len && cmd_line.buff[cmd_line.next]!=' '){cmd_line.next++;}
9D00E518  3C07A000   LUI A3, -24576
9D00E51C  24E729A8   ADDIU A3, A3, 10664
9D00E520  24060020   ADDIU A2, ZERO, 32
9D00E524  24630001   ADDIU V1, V1, 1
9D00E528  306300FF   ANDI V1, V1, 255
9D00E52C  0064282B   SLTU A1, V1, A0
9D00E530  10A00006   BEQ A1, ZERO, 0x9D00E54C
9D00E534  00672821   ADDU A1, V1, A3
9D00E538  80A50000   LB A1, 0(A1)
9D00E53C  54A6FFFA   BNEL A1, A2, 0x9D00E528
9D00E540  24630001   ADDIU V1, V1, 1
9D00E54C  3C04A000   LUI A0, -24576
9D00E550  A08329FA   SB V1, 10746(A0)
9D00E570  00431821   ADDU V1, V0, V1
9D00E574  80660000   LB A2, 0(V1)
9D00E578  24050020   ADDIU A1, ZERO, 32
9D00E57C  14C5FFE6   BNE A2, A1, 0x9D00E518
9D00E580  00401821   ADDU V1, V0, ZERO
78:                      if (cmd_line.next<(cmd_line.len)){
79:                          cmd_line.buff[cmd_line.next++]=(char)(0);
9D00E544  0B403962   J 0x9D00E588
9D00E548  3C04A000   LUI A0, -24576
9D00E584  3C04A000   LUI A0, -24576
9D00E588  248429A8   ADDIU A0, A0, 10664
9D00E58C  00642821   ADDU A1, V1, A0
9D00E590  A0A00000   SB ZERO, 0(A1)
9D00E594  24630001   ADDIU V1, V1, 1
9D00E598  0B403955   J 0x9D00E554
9D00E59C  A0830052   SB V1, 82(A0)
80:                      }
81:                      if (cmd_line.next>cmd_line.first)
9D00E554  3C03A000   LUI V1, -24576
82:                          return 1;
9D00E558  906329FA   LBU V1, 10746(V1)
83:                      else
84:                          return 0;
85:                  }//next_token()
9D00E55C  03E00008   JR RA
9D00E560  0043102B   SLTU V0, V0, V1
86:                  
87:                  
88:                  void parse_execute(void){
9D00E5A0  27BDFFE0   ADDIU SP, SP, -32
9D00E5A4  AFBF001C   SW RA, 28(SP)
9D00E5A8  AFB10018   SW S1, 24(SP)
9D00E5AC  AFB00014   SW S0, 20(SP)
89:                      while (next_token()){
9D00E5B8  0B403976   J 0x9D00E5D8
9D00E5BC  24110009   ADDIU S1, ZERO, 9
9D00E5D8  0F403926   JAL next_token
9D00E5DC  00000000   NOP
9D00E5E0  5440FFF7   BNEL V0, ZERO, 0x9D00E5C0
9D00E5E4  92040051   LBU A0, 81(S0)
90:                          switch (cmd_search(&cmd_line.buff[cmd_line.first])){
9D00E5B0  3C10A000   LUI S0, -24576
9D00E5B4  261029A8   ADDIU S0, S0, 10664
9D00E5C0  0F40390B   JAL cmd_search
9D00E5C4  02042021   ADDU A0, S0, A0
9D00E5C8  14510003   BNE V0, S1, 0x9D00E5D8
9D00E5CC  00000000   NOP
91:                              case CMD_LS:
92:                                  break;
93:                              case CMD_RM:
94:                                  break;
95:                              case CMD_MV:
96:                                  break;
97:                              case CMD_ED:
98:                                  break;
99:                              case CMD_AS:
100:                                 break;
101:                             case CMD_FORTH:
102:                                 cold();
9D00E5D0  0F400BCD   JAL cold
9D00E5D4  00000000   NOP
103:                                 break;
104:                             case CMD_RUN:
105:                                 break;
106:                             case CMD_SND:
107:                                 break;
108:                             case CMD_RCV:
109:                                 break;
110:                             case CMD_CP:
111:                                 break;
112:                         }
113:                     }
114:                 }// parse_execute()
9D00E5E8  8FBF001C   LW RA, 28(SP)
9D00E5EC  8FB10018   LW S1, 24(SP)
9D00E5F0  8FB00014   LW S0, 20(SP)
9D00E5F4  03E00008   JR RA
9D00E5F8  27BD0020   ADDIU SP, SP, 32
115:                 
116:                 const char *prompt="\r#";
117:                 
118:                 void shell(void){
9D00E5FC  27BDFFE8   ADDIU SP, SP, -24
9D00E600  AFBF0014   SW RA, 20(SP)
9D00E604  AFB00010   SW S0, 16(SP)
119:                     print(comm_channel,"VPC-32 shell\r16384 bytes free RAM.\r");
9D00E608  83848088   LB A0, -32632(GP)
9D00E60C  3C059D01   LUI A1, -25343
9D00E610  0F402624   JAL print
9D00E614  24A5F9E4   ADDIU A1, A1, -1564
120:                     while (1){
121:                         print(comm_channel,prompt);
9D00E620  83848088   LB A0, -32632(GP)
9D00E624  0F402624   JAL print
9D00E628  8F85804C   LW A1, -32692(GP)
9D00E654  0B403989   J 0x9D00E624
9D00E658  83848088   LB A0, -32632(GP)
122:                         cmd_line.first=0;
9D00E618  3C10A000   LUI S0, -24576
9D00E61C  261029A8   ADDIU S0, S0, 10664
9D00E62C  A2000051   SB ZERO, 81(S0)
123:                         cmd_line.next=0;
9D00E630  A2000052   SB ZERO, 82(S0)
124:                         cmd_line.len=readline(comm_channel,cmd_line.buff,CHAR_PER_LINE);
9D00E634  83848088   LB A0, -32632(GP)
9D00E638  02002821   ADDU A1, S0, ZERO
9D00E63C  0F402770   JAL readline
9D00E640  24060035   ADDIU A2, ZERO, 53
125:                         if (cmd_line.len){
9D00E644  1040FFF6   BEQ V0, ZERO, 0x9D00E620
9D00E648  A2020050   SB V0, 80(S0)
126:                             parse_execute();
9D00E64C  0F403968   JAL parse_execute
9D00E650  00000000   NOP
127:                         }
128:                     }//while(1)
129:                 }//shell()
130:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/serial_comm.c  ---------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   uart.h
20:                   * Author: Jacques Deschênes
21:                   * Description: fonctions de bas niveau pour communication UART avec le PC
22:                   * Created on 17 avril 2013, 14:48
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "serial_comm.h"
27:                  #include "HardwareProfile.h"
28:                  
29:                  static char unget;
30:                  
31:                  void UartInit(UART_MODULE channel, int baudrate, UART_LINE_CONTROL_MODE LineCtrl){
9D00CAB4  27BDFFE0   ADDIU SP, SP, -32
9D00CAB8  AFBF001C   SW RA, 28(SP)
9D00CABC  AFB20018   SW S2, 24(SP)
9D00CAC0  AFB10014   SW S1, 20(SP)
9D00CAC4  AFB00010   SW S0, 16(SP)
9D00CAC8  00808021   ADDU S0, A0, ZERO
9D00CACC  00A09021   ADDU S2, A1, ZERO
9D00CAD0  00C08821   ADDU S1, A2, ZERO
32:                  /*initialise le périphérique UART*/
33:                     // Configure UART, information dans uart.h
34:                     UARTConfigure(channel, UART_ENABLE_PINS_TX_RX_ONLY); // pas de contrôle de flux matériel.
9D00CAD4  0F403F1E   JAL UARTConfigure
9D00CAD8  00002821   ADDU A1, ZERO, ZERO
35:                     UARTSetLineControl(channel, LineCtrl);
9D00CADC  02002021   ADDU A0, S0, ZERO
9D00CAE0  0F403FF4   JAL UARTSetLineControl
9D00CAE4  02202821   ADDU A1, S1, ZERO
36:                     UARTSetDataRate(channel, mGetPeripheralClock(), baudrate);
9D00CAE8  02002021   ADDU A0, S0, ZERO
9D00CAEC  3C05023C   LUI A1, 572
9D00CAF0  24A53460   ADDIU A1, A1, 13408
9D00CAF4  0F403E62   JAL UARTSetDataRate
9D00CAF8  02403021   ADDU A2, S2, ZERO
37:                     // activation du périphérique
38:                     UARTEnable(channel, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D00CAFC  02002021   ADDU A0, S0, ZERO
9D00CB00  0F403E29   JAL UARTEnable
9D00CB04  24050087   ADDIU A1, ZERO, 135
39:                     unget=-1;
9D00CB08  2402FFFF   ADDIU V0, ZERO, -1
9D00CB0C  A382807C   SB V0, -32644(GP)
40:                  };
9D00CB10  8FBF001C   LW RA, 28(SP)
9D00CB14  8FB20018   LW S2, 24(SP)
9D00CB18  8FB10014   LW S1, 20(SP)
9D00CB1C  8FB00010   LW S0, 16(SP)
9D00CB20  03E00008   JR RA
9D00CB24  27BD0020   ADDIU SP, SP, 32
41:                  
42:                  char UartGetch(UART_MODULE channel){
43:                  /*lecture d'un caractère retourne 0 si aucun disponible*/
44:                      char ch;
45:                      if (!unget==-1) {
46:                          ch=unget;
47:                          unget=-1;
48:                          return ch;
49:                      }else{
50:                          if (UARTReceivedDataIsAvailable (channel)){
9D00CB44  10800003   BEQ A0, ZERO, 0x9D00CB54
9D00CB48  00001021   ADDU V0, ZERO, ZERO
51:                                 return UARTGetDataByte(channel);
9D00CB50  7C021420   SEB V0, V0
52:                          }else{
53:                              return 0;
54:                          }
55:                      }
56:                  };
9D00CB54  03E00008   JR RA
9D00CB58  00000000   NOP
57:                  
58:                  void UartPutch(UART_MODULE channel, char c){
9D00CB5C  7C052C20   SEB A1, A1
59:                  /*Envoie d'un caractère*/
60:                      while(!UARTTransmitterIsReady(channel));
9D00CB7C  1440FFFD   BNE V0, ZERO, 0x9D00CB74
9D00CB80  00000000   NOP
61:                        UARTSendDataByte(channel, c);
62:                  };
9D00CB8C  03E00008   JR RA
9D00CB90  00000000   NOP
63:                  
64:                  char UartWaitch(UART_MODULE channel, int delay){
9D00CB94  27BDFFE0   ADDIU SP, SP, -32
9D00CB98  AFBF001C   SW RA, 28(SP)
9D00CB9C  AFB10018   SW S1, 24(SP)
9D00CBA0  AFB00014   SW S0, 20(SP)
9D00CBA4  00808021   ADDU S0, A0, ZERO
65:                  /*attend un caractère pour un temps spécifié par delay
66:                  *retourne 0 si aucun reçu avant expiration du délais
67:                  */
68:                      int t;
69:                      char ch;
70:                      if (!unget==-1){
71:                          ch=unget;
72:                          unget=-1;
73:                          return unget;
74:                      }
75:                      if (!delay) while (1) if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D00CBA8  14A0000D   BNE A1, ZERO, 0x9D00CBE0
9D00CBAC  00A08821   ADDU S1, A1, ZERO
9D00CBCC  1040FFFD   BEQ V0, ZERO, 0x9D00CBC4
9D00CBD0  00000000   NOP
9D00CBD8  0B40330A   J 0x9D00CC28
9D00CBDC  7C021420   SEB V0, V0
76:                      t=ticks()+delay;
9D00CBE0  0F403639   JAL ticks
9D00CBE4  00108080   SLL S0, S0, 2
77:                      while (ticks()<delay){
9D00CBF0  0B403305   J 0x9D00CC14
9D00CBF4  02028021   ADDU S0, S0, V0
9D00CC14  0F403639   JAL ticks
9D00CC18  00000000   NOP
9D00CC1C  0051102B   SLTU V0, V0, S1
9D00CC20  5440FFF5   BNEL V0, ZERO, 0x9D00CBF8
9D00CC24  8E020000   LW V0, 0(S0)
78:                         if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D00CC00  10600004   BEQ V1, ZERO, 0x9D00CC14
9D00CC04  00000000   NOP
9D00CC0C  0B40330A   J 0x9D00CC28
9D00CC10  7C021420   SEB V0, V0
79:                      }
80:                      return 0;
81:                  }
9D00CC28  8FBF001C   LW RA, 28(SP)
9D00CC2C  8FB10018   LW S1, 24(SP)
9D00CC30  8FB00014   LW S0, 20(SP)
9D00CC34  03E00008   JR RA
9D00CC38  27BD0020   ADDIU SP, SP, 32
82:                  
83:                  void UartPrint(UART_MODULE channel, const char* str){
84:                  /* envoie la chaine de caractère str via le UART */
85:                     while(*str != (char)0)
9D00CC3C  80A60000   LB A2, 0(A1)
9D00CC40  10C0000F   BEQ A2, ZERO, 0x9D00CC80
9D00CC44  00041880   SLL V1, A0, 2
9D00CC74  80A60000   LB A2, 0(A1)
9D00CC78  14C0FFF7   BNE A2, ZERO, 0x9D00CC58
9D00CC7C  00000000   NOP
86:                     {
87:                        while(!UARTTransmitterIsReady(channel));
9D00CC60  1440FFFD   BNE V0, ZERO, 0x9D00CC58
9D00CC64  00000000   NOP
88:                        UARTSendDataByte(channel, *str++);
9D00CC68  24A50001   ADDIU A1, A1, 1
89:                     }
90:                     while(!UARTTransmissionHasCompleted(channel));
9D00CC9C  1040FFFD   BEQ V0, ZERO, 0x9D00CC94
9D00CCA0  00000000   NOP
91:                  };
9D00CCA4  03E00008   JR RA
9D00CCA8  00000000   NOP
92:                  
93:                  int UartReadln(UART_MODULE channel, char *buffer, int buff_len){
9D00CCAC  27BDFFD0   ADDIU SP, SP, -48
9D00CCB0  AFBF002C   SW RA, 44(SP)
9D00CCB4  AFB50028   SW S5, 40(SP)
9D00CCB8  AFB40024   SW S4, 36(SP)
9D00CCBC  AFB30020   SW S3, 32(SP)
9D00CCC0  AFB2001C   SW S2, 28(SP)
9D00CCC4  AFB10018   SW S1, 24(SP)
9D00CCC8  AFB00014   SW S0, 20(SP)
9D00CCCC  00809821   ADDU S3, A0, ZERO
9D00CCD0  00A0A021   ADDU S4, A1, ZERO
9D00CCD4  00C08821   ADDU S1, A2, ZERO
94:                  /* lecture d'une chaine se terminant par '\r'
95:                   *  complète la chaine avec un zéro
96:                   *  retourne le nombre de caractère dans le buffer.
97:                   */
98:                      int count=0;
9D00CCD8  00008021   ADDU S0, ZERO, ZERO
99:                      char c;
100:                     if (!unget==-1){
101:                         c=unget;
102:                         unget=-1;
103:                         *buffer++=c;
104:                         if (c==CR) return;
105:                     }
106:                     while (count < (buff_len-1)){
9D00CCEC  0B40335A   J 0x9D00CD68
9D00CCF0  3C159D01   LUI S5, -25343
9D00CD50  0B40335B   J 0x9D00CD6C
9D00CD54  2622FFFF   ADDIU V0, S1, -1
9D00CD68  2622FFFF   ADDIU V0, S1, -1
9D00CD6C  0202102A   SLT V0, S0, V0
9D00CD70  5440FFE0   BNEL V0, ZERO, 0x9D00CCF4
9D00CD74  8E420000   LW V0, 0(S2)
107:                         if (UARTReceivedDataIsAvailable(channel)){
9D00CCFC  5060001B   BEQL V1, ZERO, 0x9D00CD6C
9D00CD00  2622FFFF   ADDIU V0, S1, -1
108:                             c = UARTGetDataByte(channel);
9D00CD08  7C052C20   SEB A1, A1
109:                             if (c==CR){UartPutch(channel,'\r'); break;}
9D00CD0C  2402000D   ADDIU V0, ZERO, 13
9D00CD10  14A20006   BNE A1, V0, 0x9D00CD2C
9D00CD14  24020008   ADDIU V0, ZERO, 8
9D00CD18  02602021   ADDU A0, S3, ZERO
9D00CD1C  0F4032D7   JAL UartPutch
9D00CD20  2405000D   ADDIU A1, ZERO, 13
9D00CD24  0B40335E   J 0x9D00CD78
9D00CD28  00000000   NOP
110:                             if (c==BS){
9D00CD2C  54A2000A   BNEL A1, V0, 0x9D00CD58
9D00CD30  A2850000   SB A1, 0(S4)
111:                                 if (count){
9D00CD34  5200000D   BEQL S0, ZERO, 0x9D00CD6C
9D00CD38  2622FFFF   ADDIU V0, S1, -1
112:                                     buffer--;
9D00CD3C  2694FFFF   ADDIU S4, S4, -1
113:                                     count--;
9D00CD40  2610FFFF   ADDIU S0, S0, -1
114:                                     UartPrint(channel,"\b \b");
9D00CD44  02602021   ADDU A0, S3, ZERO
9D00CD48  0F40330F   JAL UartPrint
9D00CD4C  26A502D8   ADDIU A1, S5, 728
115:                                 }
116:                             }else{
117:                                 *buffer++=c;
9D00CD58  26940001   ADDIU S4, S4, 1
118:                                 count++;
9D00CD5C  26100001   ADDIU S0, S0, 1
119:                                 UartPutch(channel,c);
9D00CD60  0F4032D7   JAL UartPutch
9D00CD64  02602021   ADDU A0, S3, ZERO
120:                             }
121:                             
122:                         }
123:                     }
124:                     if (count) *buffer = (char)0;
9D00CD78  56000001   BNEL S0, ZERO, 0x9D00CD80
9D00CD7C  A2800000   SB ZERO, 0(S4)
125:                     UartPutch(channel,'\r');
9D00CD80  02602021   ADDU A0, S3, ZERO
9D00CD84  0F4032D7   JAL UartPutch
9D00CD88  2405000D   ADDIU A1, ZERO, 13
126:                     return count;
127:                 }
9D00CD8C  02001021   ADDU V0, S0, ZERO
9D00CD90  8FBF002C   LW RA, 44(SP)
9D00CD94  8FB50028   LW S5, 40(SP)
9D00CD98  8FB40024   LW S4, 36(SP)
9D00CD9C  8FB30020   LW S3, 32(SP)
9D00CDA0  8FB2001C   LW S2, 28(SP)
9D00CDA4  8FB10018   LW S1, 24(SP)
9D00CDA8  8FB00014   LW S0, 20(SP)
9D00CDAC  03E00008   JR RA
9D00CDB0  27BD0030   ADDIU SP, SP, 48
128:                 
129:                 int UartReceivedBreak(UART_MODULE channel){
130:                    char ch;
131:                    if (unget==-1 && UARTReceivedDataIsAvailable(channel)) {
9D00CDB4  8385807C   LB A1, -32644(GP)
9D00CDB8  2403FFFF   ADDIU V1, ZERO, -1
9D00CDBC  14A30011   BNE A1, V1, 0x9D00CE04
9D00CDC0  00001021   ADDU V0, ZERO, ZERO
9D00CDE0  10800008   BEQ A0, ZERO, 0x9D00CE04
9D00CDE4  00001021   ADDU V0, ZERO, ZERO
132:                        ch=UARTGetDataByte(channel);
9D00CDEC  7C031C20   SEB V1, V1
133:                        if (ch==ESC) return 1; else unget=ch;
9D00CDF0  2404001B   ADDIU A0, ZERO, 27
9D00CDF4  10640003   BEQ V1, A0, 0x9D00CE04
9D00CDF8  24020001   ADDIU V0, ZERO, 1
9D00CDFC  A383807C   SB V1, -32644(GP)
134:                    }
135:                    return 0;
9D00CE00  00001021   ADDU V0, ZERO, ZERO
136:                 }
9D00CE04  03E00008   JR RA
9D00CE08  00000000   NOP
137:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/ntsc.c  ----------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /* 
19:                   * File:   test-ntsc.c
20:                   * Author: Jacques Deschênes
21:                   * Description: test génération signal vidéo NTSC sur PIC32MX150F128B.
22:                   * Created on 20 août 2013, 08:48
23:                   */
24:                  
25:                  #include <stdio.h>
26:                  #include <stdlib.h>
27:                  #include <sys/attribs.h>
28:                  #include <plib.h>
29:                  #include "HardwareProfile.h"
30:                  #include "ntsc.h"
31:                  
32:                  /*
33:                   *  la fréqueence PBCLK influence la largeur des pixels vidéo. Comme PBCLK==SYSCLK
34:                   *  on peut allonger les pixels en diminuant la fréquence légèrement.
35:                   *  pour une résolution horizontale de 320 pixels et une fréquence de 40Mhz le
36:                   *  meilleur diviseur pour le générateur BGR du SPI est de 2 ce qui donne
37:                   *  une fréquence de pixel de  40e6/(2*(2+1)=6,67Mhz et la durée total d'une
38:                   *  ligne vidéo est donc de 320/6,67e6= 48µSec.
39:                   *  En principe pour le standard NTSC on dispose de 52µSec par ligne vidéo.
40:                   *  En pratique on est plutôt à 51µSec. Donc ici on a 3µSec inutilisées.
41:                   *  en résuidant SYSCLK à 37,5Mhz on a 51,2µSec par ligne vidéo. Les pixels
42:                   *  sont donc moins compressé horizontalement. Mais sur certains téléviseurs
43:                   *  on peut perdre quelques pixels en bout de ligne.
44:                   *  la constante SPI_DLY doit-être ajustée en fonction de PBCLK pour que les
45:                   *  320 pixels horizontals soient visibles.
46:                   */
47:                  
48:                  #define PWM_PERIOD (SYSCLK/15748)-1
49:                  #define HSYNC  (SYSCLK/212766)  // 4,7µSec
50:                  #define FIRST_LINE 27   //première ligne de scan visible
51:                  #define LAST_LINE  256  // dernière ligne de scan visible
52:                  #define BITCLK HRES * 1000000L/52 // 52µSec c'est le temps que dure 1 ligne vidéo.
53:                  #if SYSCLK==40000000L
54:                  #define SPI_DLY HSYNC+90 // délais en début de ligne avant l'envoie du signal vidéo.
55:                  #else
56:                  #define SPI_DLY HSYNC+30 // délais en début de ligne avant l'envoie du signal vidéo.
57:                  #endif
58:                  #define _enable_video_out()  SPI1CONSET =(1<<15)
59:                  #define _disable_video_out() SPI1CONCLR =(1<<15)
60:                  
61:                  unsigned int video_bmp[VRES][HRES/32]; // video bitmap 7168 octets
62:                  volatile unsigned int ln_cnt;
63:                  volatile unsigned int video;
64:                  volatile int *DmaSrc;
65:                  
66:                  
67:                  
68:                  void VideoInit(void){
9D00CE0C  27BDFFD8   ADDIU SP, SP, -40
9D00CE10  AFBF0024   SW RA, 36(SP)
9D00CE14  AFB20020   SW S2, 32(SP)
9D00CE18  AFB1001C   SW S1, 28(SP)
9D00CE1C  AFB00018   SW S0, 24(SP)
69:                      //configuration PWM sur OC2 pour SYNC, utilisation TIMER2
70:                      T2CON = 0;
9D00CE20  3C02BF80   LUI V0, -16512
9D00CE24  AC400800   SW ZERO, 2048(V0)
71:                      PR2=PWM_PERIOD;
9D00CE28  2403094C   ADDIU V1, ZERO, 2380
9D00CE2C  3C02BF80   LUI V0, -16512
9D00CE30  AC430820   SW V1, 2080(V0)
72:                      OC2CONbits.OCM = 5; // mode train d'impulsion
9D00CE34  3C02BF80   LUI V0, -16512
9D00CE38  8C433200   LW V1, 12800(V0)
9D00CE3C  24120005   ADDIU S2, ZERO, 5
9D00CE40  7E431004   INS V1, S2, 0, 3
9D00CE44  AC433200   SW V1, 12800(V0)
73:                      OC2RS = 0; 
9D00CE48  3C03BF80   LUI V1, -16512
9D00CE4C  AC603220   SW ZERO, 12832(V1)
74:                      OC2R = HSYNC;
9D00CE50  240400B0   ADDIU A0, ZERO, 176
9D00CE54  3C03BF80   LUI V1, -16512
9D00CE58  AC643210   SW A0, 12816(V1)
75:                      IFS0bits.T2IF=0;
9D00CE5C  3C03BF88   LUI V1, -16504
9D00CE60  8C641030   LW A0, 4144(V1)
9D00CE64  7C044A44   INS A0, ZERO, 9, 1
9D00CE68  AC641030   SW A0, 4144(V1)
76:                      IEC0bits.T2IE=1;
9D00CE6C  3C03BF88   LUI V1, -16504
9D00CE70  8C641060   LW A0, 4192(V1)
9D00CE74  24110001   ADDIU S1, ZERO, 1
9D00CE78  7E244A44   INS A0, S1, 9, 1
9D00CE7C  AC641060   SW A0, 4192(V1)
77:                      IPC2bits.T2IP=7;
9D00CE80  3C03BF88   LUI V1, -16504
9D00CE84  8C6410B0   LW A0, 4272(V1)
9D00CE88  24050007   ADDIU A1, ZERO, 7
9D00CE8C  7CA42084   INS A0, A1, 2, 3
9D00CE90  AC6410B0   SW A0, 4272(V1)
78:                      IPC2bits.T2IS=3;
9D00CE94  8C6410B0   LW A0, 4272(V1)
9D00CE98  24050003   ADDIU A1, ZERO, 3
9D00CE9C  7CA40804   INS A0, A1, 0, 2
9D00CEA0  AC6410B0   SW A0, 4272(V1)
79:                      OC2CONbits.ON =1;  // activation
9D00CEA4  8C433200   LW V1, 12800(V0)
9D00CEA8  7E237BC4   INS V1, S1, 15, 1
9D00CEAC  AC433200   SW V1, 12800(V0)
80:                      T2CONbits.ON=1;  // activation
9D00CEB0  3C02BF80   LUI V0, -16512
9D00CEB4  8C430800   LW V1, 2048(V0)
9D00CEB8  7E237BC4   INS V1, S1, 15, 1
9D00CEBC  AC430800   SW V1, 2048(V0)
81:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
82:                      OC1CONbits.OCM = 5; //mode train d'impulsion
9D00CEC0  3C02BF80   LUI V0, -16512
9D00CEC4  8C433000   LW V1, 12288(V0)
9D00CEC8  7E431004   INS V1, S2, 0, 3
9D00CECC  AC433000   SW V1, 12288(V0)
83:                      OC1RS=0;
9D00CED0  3C03BF80   LUI V1, -16512
9D00CED4  AC603020   SW ZERO, 12320(V1)
84:                      OC1R=HSYNC+SPI_DLY;
9D00CED8  2404017E   ADDIU A0, ZERO, 382
9D00CEDC  3C03BF80   LUI V1, -16512
9D00CEE0  AC643010   SW A0, 12304(V1)
85:                      OC1CONbits.ON=1;
9D00CEE4  8C433000   LW V1, 12288(V0)
9D00CEE8  7E237BC4   INS V1, S1, 15, 1
9D00CEEC  AC433000   SW V1, 12288(V0)
86:                      // configuration SPI pour sortie vidéo
87:                      // configure le DMA
88:                      DmaChnOpen(0,0,DMA_OPEN_DEFAULT);
9D00CEF0  00002021   ADDU A0, ZERO, ZERO
9D00CEF4  00002821   ADDU A1, ZERO, ZERO
9D00CEF8  0F403D0E   JAL DmaChnOpen
9D00CEFC  00003021   ADDU A2, ZERO, ZERO
89:                      DmaChnSetEventControl(0,DMA_EV_START_IRQ_EN|
9D00CF00  00002021   ADDU A0, ZERO, ZERO
9D00CF04  0F403FB3   JAL DmaChnWriteEventControlFlags
9D00CF08  24052610   ADDIU A1, ZERO, 9744
90:                                            DMA_EV_START_IRQ(_SPI1_TX_IRQ));
91:                      DmaChnSetTxfer(0,(void *)DmaSrc,(void *)&SPI1BUF,HRES/8,4,4);
9D00CF0C  24020004   ADDIU V0, ZERO, 4
9D00CF10  AFA20010   SW V0, 16(SP)
9D00CF14  AFA20014   SW V0, 20(SP)
9D00CF18  00002021   ADDU A0, ZERO, ZERO
9D00CF1C  8F8580F0   LW A1, -32528(GP)
9D00CF20  3C06BF80   LUI A2, -16512
9D00CF24  24C65820   ADDIU A2, A2, 22560
9D00CF28  0F403E03   JAL DmaChnSetTxfer
9D00CF2C  24070028   ADDIU A3, ZERO, 40
92:                      // configuration du SPI canal 1
93:                      SPI1CONbits.DISSDI=1; // SDI n'est pas utilisé.
9D00CF30  3C10BF80   LUI S0, -16512
9D00CF34  8E025800   LW V0, 22528(S0)
9D00CF38  7E222104   INS V0, S1, 4, 1
9D00CF3C  AE025800   SW V0, 22528(S0)
94:                      SPI1CONbits.FRMEN=1; // frame mode
9D00CF40  8E025800   LW V0, 22528(S0)
9D00CF44  7E22FFC4   INS V0, S1, 31, 1
9D00CF48  AE025800   SW V0, 22528(S0)
95:                      SPI1CONbits.FRMCNT=5; // 32 octets par frame.
9D00CF4C  8E025800   LW V0, 22528(S0)
9D00CF50  7E42D604   INS V0, S2, 24, 3
9D00CF54  AE025800   SW V0, 22528(S0)
96:                      SPI1CONbits.FRMPOL=1; // sync sur transition montante
9D00CF58  8E025800   LW V0, 22528(S0)
9D00CF5C  7E22EF44   INS V0, S1, 29, 1
9D00CF60  AE025800   SW V0, 22528(S0)
97:                      SPI1CONbits.FRMSYNC=1; // synchronisation esclave
9D00CF64  8E025800   LW V0, 22528(S0)
9D00CF68  7E22F784   INS V0, S1, 30, 1
9D00CF6C  AE025800   SW V0, 22528(S0)
98:                      SPI1CONbits.MSTEN=1; // SPI maître
9D00CF70  8E025800   LW V0, 22528(S0)
9D00CF74  7E222944   INS V0, S1, 5, 1
9D00CF78  AE025800   SW V0, 22528(S0)
99:                     // SPI1CONbits.SPIFE=1; // synchronisation sur clock premier bit.
100:                     SPI1CONbits.MODE32=1; // mode 32 bits
9D00CF7C  8E025800   LW V0, 22528(S0)
9D00CF80  7E225AC4   INS V0, S1, 11, 1
9D00CF84  AE025800   SW V0, 22528(S0)
101:                     SPI1CONbits.STXISEL=1; // interruption sur TBE
9D00CF88  8E025800   LW V0, 22528(S0)
9D00CF8C  7E221884   INS V0, S1, 2, 2
9D00CF90  AE025800   SW V0, 22528(S0)
102:                     SpiChnSetBitRate(SPI_CHANNEL1, PBCLK, BITCLK);
9D00CF94  24040001   ADDIU A0, ZERO, 1
9D00CF98  3C05023C   LUI A1, 572
9D00CF9C  24A53460   ADDIU A1, A1, 13408
9D00CFA0  3C06005D   LUI A2, 93
9D00CFA4  0F403F0F   JAL SpiChnSetBitRate
9D00CFA8  34C6E676   ORI A2, A2, -6538
103:                     SPI1CONbits.ON=1;
9D00CFAC  8E025800   LW V0, 22528(S0)
9D00CFB0  7E227BC4   INS V0, S1, 15, 1
9D00CFB4  AE025800   SW V0, 22528(S0)
104:                 }//init_video()
9D00CFB8  8FBF0024   LW RA, 36(SP)
9D00CFBC  8FB20020   LW S2, 32(SP)
9D00CFC0  8FB1001C   LW S1, 28(SP)
9D00CFC4  8FB00018   LW S0, 24(SP)
9D00CFC8  03E00008   JR RA
9D00CFCC  27BD0028   ADDIU SP, SP, 40
105:                 
106:                 
107:                 
108:                 void __ISR(_TIMER_2_VECTOR,IPL7AUTO) tmr2_isr(void){
9D00CFD0  415DE800   RDPGPR SP, SP
9D00CFD4  401B7000   MFC0 K1, EPC
9D00CFD8  401A6002   MFC0 K0, SRSCtl
9D00CFDC  27BDFFE0   ADDIU SP, SP, -32
9D00CFE0  401B6000   MFC0 K1, Status
9D00CFE4  AFBA001C   SW K0, 28(SP)
9D00CFE8  AFBB0018   SW K1, 24(SP)
9D00CFEC  7C1B7844   INS K1, ZERO, 1, 15
9D00CFF0  377B1C00   ORI K1, K1, 7168
9D00CFF4  409B6000   MTC0 K1, Status
9D00CFF8  AFA30008   SW V1, 8(SP)
9D00CFFC  AFA20004   SW V0, 4(SP)
9D00D000  AFA4000C   SW A0, 12(SP)
109:                     _disable_video_out();
9D00D004  34038000   ORI V1, ZERO, -32768
9D00D008  3C02BF80   LUI V0, -16512
9D00D00C  AC435804   SW V1, 22532(V0)
110:                     ln_cnt++;
9D00D010  8F8280F8   LW V0, -32520(GP)
9D00D014  24420001   ADDIU V0, V0, 1
9D00D018  AF8280F8   SW V0, -32520(GP)
111:                     switch (ln_cnt){
9D00D01C  8F8280F8   LW V0, -32520(GP)
9D00D020  2403001A   ADDIU V1, ZERO, 26
9D00D024  1043001C   BEQ V0, V1, 0x9D00D098
9D00D028  2C43001B   SLTIU V1, V0, 27
9D00D02C  10600009   BEQ V1, ZERO, 0x9D00D054
9D00D030  24030101   ADDIU V1, ZERO, 257
9D00D034  24030001   ADDIU V1, ZERO, 1
9D00D038  1043000D   BEQ V0, V1, 0x9D00D070
9D00D03C  2403089C   ADDIU V1, ZERO, 2204
9D00D040  24030004   ADDIU V1, ZERO, 4
9D00D044  1443001D   BNE V0, V1, 0x9D00D0BC
9D00D048  240300B0   ADDIU V1, ZERO, 176
9D00D054  10430016   BEQ V0, V1, 0x9D00D0B0
9D00D058  00000000   NOP
9D00D05C  24030106   ADDIU V1, ZERO, 262
9D00D060  14430016   BNE V0, V1, 0x9D00D0BC
9D00D064  00000000   NOP
9D00D068  0B403423   J 0x9D00D08C
9D00D06C  00000000   NOP
112:                         case 1:  // début vsync
113:                             OC2R=PWM_PERIOD-HSYNC;
9D00D070  3C02BF80   LUI V0, -16512
9D00D074  AC433210   SW V1, 12816(V0)
114:                             break;
9D00D078  0B403444   J 0x9D00D110
9D00D07C  24030200   ADDIU V1, ZERO, 512
115:                         case 4: // fin vsync
116:                             OC2R=HSYNC;
9D00D04C  0B403420   J 0x9D00D080
9D00D050  3C02BF80   LUI V0, -16512
9D00D080  AC433210   SW V1, 12816(V0)
117:                             break;
9D00D084  0B403444   J 0x9D00D110
9D00D088  24030200   ADDIU V1, ZERO, 512
118:                         case 262:  //fin du frame
119:                             ln_cnt=0;
9D00D08C  AF8080F8   SW ZERO, -32520(GP)
120:                             break;
9D00D090  0B403444   J 0x9D00D110
9D00D094  24030200   ADDIU V1, ZERO, 512
121:                   
122:                         case FIRST_LINE-1:
123:                             video=1;
9D00D098  24020001   ADDIU V0, ZERO, 1
9D00D09C  AF8280F4   SW V0, -32524(GP)
124:                             DmaSrc=(void*)&video_bmp[0];
9D00D0A0  3C02A000   LUI V0, -24576
9D00D0A4  24420370   ADDIU V0, V0, 880
125:                             break;
9D00D0A8  0B403443   J 0x9D00D10C
9D00D0AC  AF8280F0   SW V0, -32528(GP)
126:                         case LAST_LINE+1:
127:                             video=0;
9D00D0B0  AF8080F4   SW ZERO, -32524(GP)
128:                             break;
9D00D0B4  0B403444   J 0x9D00D110
9D00D0B8  24030200   ADDIU V1, ZERO, 512
129:                         default:
130:                             if (video){
9D00D0BC  8F8280F4   LW V0, -32524(GP)
9D00D0C0  10400012   BEQ V0, ZERO, 0x9D00D10C
9D00D0C4  34038000   ORI V1, ZERO, -32768
131:                                 _enable_video_out();
9D00D0C8  3C02BF80   LUI V0, -16512
9D00D0CC  AC435808   SW V1, 22536(V0)
132:                                 IFS1bits.SPI1TXIF=1;
9D00D0D0  3C02BF88   LUI V0, -16504
9D00D0D4  8C431040   LW V1, 4160(V0)
9D00D0D8  24040001   ADDIU A0, ZERO, 1
9D00D0DC  7C833184   INS V1, A0, 6, 1
9D00D0E0  AC431040   SW V1, 4160(V0)
133:                                 DCH0SSA=KVA_TO_PA((void *)DmaSrc);
9D00D0E4  8F8280F0   LW V0, -32528(GP)
9D00D0E8  7C44E000   EXT A0, V0, 0, 29
9D00D0EC  3C03BF88   LUI V1, -16504
9D00D0F0  AC643090   SW A0, 12432(V1)
134:                                 DmaSrc +=HRES/32;
9D00D0F4  24420028   ADDIU V0, V0, 40
9D00D0F8  AF8280F0   SW V0, -32528(GP)
135:                                 DCH0CON |=128; // remplace DmaChnEnable(0); réduit le temps de latence
9D00D0FC  3C02BF88   LUI V0, -16504
9D00D100  8C433060   LW V1, 12384(V0)
9D00D104  34630080   ORI V1, V1, 128
9D00D108  AC433060   SW V1, 12384(V0)
136:                             }
137:                     }//switch (ln_cnt)
138:                     mT2ClearIntFlag();
9D00D10C  24030200   ADDIU V1, ZERO, 512
9D00D110  3C02BF88   LUI V0, -16504
9D00D114  AC431034   SW V1, 4148(V0)
139:                 }//tmr2_isr()
9D00D118  8FA2001C   LW V0, 28(SP)
9D00D11C  3042000F   ANDI V0, V0, 15
9D00D120  14400004   BNE V0, ZERO, 0x9D00D134
9D00D124  8FBB0018   LW K1, 24(SP)
9D00D128  8FA4000C   LW A0, 12(SP)
9D00D12C  8FA30008   LW V1, 8(SP)
9D00D130  8FA20004   LW V0, 4(SP)
9D00D134  8FBA001C   LW K0, 28(SP)
9D00D138  27BD0020   ADDIU SP, SP, 32
9D00D13C  409A6002   MTC0 K0, SRSCtl
9D00D140  41DDE800   WRPGPR SP, SP
9D00D144  409B6000   MTC0 K1, Status
9D00D148  42000018   ERET
140:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/keyboard.c  ------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * Name: keyboard.c
20:                   * Author: Jacques Deschênes
21:                   * Description:  interface avec clavier PS/2
22:                   * Date: 2013-08-26
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "hardwareProfile.h"
27:                  #include "keyboard.h"
28:                  #include "QWERTY.h"
29:                  
30:                  #define KBD_CLK 1  // SET/CLR bit
31:                  #define KBD_DAT 2  // SET/CLR bit
32:                  
33:                  #define _wait_key() while (head==tail)
34:                  
35:                  
36:                  static  unsigned char kbd_queue[32]; // file circulaire pour les codes reçus du clavier.
37:                  volatile  static unsigned char head=0, tail=0; // tête et queue de la file
38:                  volatile  static unsigned char  in_byte=0, bit_cnt=0, parity=0;
39:                  volatile unsigned char rx_flags=0, kbd_leds=0;
40:                  volatile unsigned short key_state; // état des touches d'alteration: shift, ctrl, alt,etc.
41:                  
42:                  #define FN_COUNT 32
43:                  const short fn_keys[FN_COUNT]={CAPS_LOCK,SCROLL_LOCK,NUM_LOCK,LSHIFT,RSHIFT,LCTRL,
44:                  RCTRL,LALT,RALT,F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,PRN,PAUSE,UP_ARROW,DOWN_ARROW,
45:                  LEFT_ARROW,RIGHT_ARROW,INSERT,HOME,PGUP,PGDN,END
46:                  };
47:                  
48:                  static int KbdReset(void);
49:                  
50:                  int KeyboardInit(){ // initialisation E/S et RAZ clavier
9D008584  27BDFFE0   ADDIU SP, SP, -32
9D008588  AFBF001C   SW RA, 28(SP)
9D00858C  AFB20018   SW S2, 24(SP)
9D008590  AFB10014   SW S1, 20(SP)
51:                      unsigned char c;
52:                      unsigned int t0;
53:                      t0=ticks()+750;
9D008594  0F403639   JAL ticks
9D008598  AFB00010   SW S0, 16(SP)
9D00859C  245002EE   ADDIU S0, V0, 750
54:                      head=0;
9D0085A0  A3808083   SB ZERO, -32637(GP)
55:                      tail=0;
9D0085A4  A3808081   SB ZERO, -32639(GP)
56:                      in_byte=0;
9D0085A8  A3808082   SB ZERO, -32638(GP)
57:                      bit_cnt=0;
9D0085AC  A380807F   SB ZERO, -32641(GP)
58:                      parity=0;
9D0085B0  A3808080   SB ZERO, -32640(GP)
59:                      rx_flags=0;
9D0085B4  A380807D   SB ZERO, -32643(GP)
60:                      kbd_leds=0;
9D0085B8  A380807E   SB ZERO, -32642(GP)
61:                      key_state=0;
9D0085BC  A7808100   SH ZERO, -32512(GP)
62:                      TRISASET=KBD_CLK|KBD_DAT;
9D0085C0  24040003   ADDIU A0, ZERO, 3
9D0085C4  3C02BF88   LUI V0, -16504
9D0085C8  AC446018   SW A0, 24600(V0)
63:                      INTCONbits.INT4EP=0; // interruption sur transition descendante
9D0085CC  3C02BF88   LUI V0, -16504
9D0085D0  8C431000   LW V1, 4096(V0)
9D0085D4  7C032104   INS V1, ZERO, 4, 1
9D0085D8  AC431000   SW V1, 4096(V0)
64:                      IPC4bits.INT4IP=6; // priorité 4
9D0085DC  3C02BF88   LUI V0, -16504
9D0085E0  8C4310D0   LW V1, 4304(V0)
9D0085E4  24050006   ADDIU A1, ZERO, 6
9D0085E8  7CA3E684   INS V1, A1, 26, 3
9D0085EC  AC4310D0   SW V1, 4304(V0)
65:                      IPC4bits.INT4IS=3;  // sous-priorité 3.
9D0085F0  8C4310D0   LW V1, 4304(V0)
9D0085F4  7C83CE04   INS V1, A0, 24, 2
9D0085F8  AC4310D0   SW V1, 4304(V0)
66:                      while (!PORTAbits.RA0);
9D0085FC  3C03BF88   LUI V1, -16504
9D008600  8C626020   LW V0, 24608(V1)
9D008604  30420001   ANDI V0, V0, 1
9D008608  1040FFFD   BEQ V0, ZERO, 0x9D008600
9D00860C  3C02BF88   LUI V0, -16504
67:                      IFS0bits.INT4IF=0; // RAZ indicateur interruption
9D008610  8C431030   LW V1, 4144(V0)
9D008614  7C03BDC4   INS V1, ZERO, 23, 1
9D008618  AC431030   SW V1, 4144(V0)
68:                      IEC0SET = _IEC0_INT4IE_MASK; // activation interruption externe 4 (KBD_CLK)
9D00861C  3C030080   LUI V1, 128
9D008620  3C02BF88   LUI V0, -16504
9D008624  AC431068   SW V1, 4200(V0)
69:                      while ((ticks()!=t0) && ((rx_flags & F_ERROR)==0)){
9D008628  0B402191   J 0x9D008644
9D00862C  241100AA   ADDIU S1, ZERO, 170
9D008644  0F403639   JAL ticks
9D008648  00000000   NOP
9D00864C  10500005   BEQ V0, S0, 0x9D008664
9D008650  00000000   NOP
9D008654  9382807D   LBU V0, -32643(GP)
9D008658  30420001   ANDI V0, V0, 1
9D00865C  1040FFF4   BEQ V0, ZERO, 0x9D008630
9D008660  00000000   NOP
70:                          c=KbdScancode();
9D008630  0F401FEF   JAL KbdScancode
9D008634  00000000   NOP
71:                          if (c==BAT_OK){
9D008638  304200FF   ANDI V0, V0, 255
9D00863C  10510026   BEQ V0, S1, 0x9D0086D8
9D008640  24020001   ADDIU V0, ZERO, 1
72:                              return 1;
73:                          }
74:                      }
75:                      if (KbdReset())
76:                          return 1;
77:                      else
78:                          return 0;
79:                  } //KeyboardInit()
9D0086D8  8FBF001C   LW RA, 28(SP)
9D0086DC  8FB20018   LW S2, 24(SP)
9D0086E0  8FB10014   LW S1, 20(SP)
9D0086E4  8FB00010   LW S0, 16(SP)
9D0086E8  03E00008   JR RA
9D0086EC  27BD0020   ADDIU SP, SP, 32
80:                  
81:                  static int KbdReset(void){
82:                      unsigned int t0;
83:                      short c;
84:                      rx_flags = 0;
9D008664  A380807D   SB ZERO, -32643(GP)
85:                      KbdSend(KBD_RESET);
9D008668  0F401F49   JAL KbdSend
9D00866C  2404FFFF   ADDIU A0, ZERO, -1
86:                      t0=ticks()+750;
9D008670  0F403639   JAL ticks
9D008674  00008021   ADDU S0, ZERO, ZERO
9D008678  245102EE   ADDIU S1, V0, 750
87:                      c=0;
88:                      while ((ticks()!=t0) && ((rx_flags & F_ERROR)==0) && !c){
9D008694  0F403639   JAL ticks
9D008698  00000000   NOP
9D00869C  12220007   BEQ S1, V0, 0x9D0086BC
9D0086A0  00000000   NOP
9D0086A4  9382807D   LBU V0, -32643(GP)
9D0086A8  30420001   ANDI V0, V0, 1
9D0086AC  14400003   BNE V0, ZERO, 0x9D0086BC
9D0086B0  00000000   NOP
9D0086B4  1200FFF3   BEQ S0, ZERO, 0x9D008684
9D0086B8  00000000   NOP
89:                              c=KbdScancode();
9D008684  0F401FEF   JAL KbdScancode
9D008688  00000000   NOP
9D00868C  00521826   XOR V1, V0, S2
9D008690  0043800B   MOVN S0, V0, V1
90:                              if (c==KBD_ACK){
9D00867C  0B4021A5   J 0x9D008694
9D008680  241200FA   ADDIU S2, ZERO, 250
91:                                  c=0;
92:                              }
93:                      }
94:                      if ((rx_flags & F_ERROR) || (c!=BAT_OK))
9D0086BC  9383807D   LBU V1, -32643(GP)
9D0086C0  30630001   ANDI V1, V1, 1
9D0086C4  14600003   BNE V1, ZERO, 0x9D0086D4
9D0086C8  00001021   ADDU V0, ZERO, ZERO
95:                          return 0;
9D0086CC  3A0200AA   XORI V0, S0, 170
9D0086D0  2C420001   SLTIU V0, V0, 1
9D0086D4  0002102B   SLTU V0, ZERO, V0
96:                      else
97:                          return 1;
98:                  }//KbdReset()
99:                  
100:                 typedef enum  _STATE {ST0, ST_EXT0, ST_RELEASE, ST_COMPLETED} state_t;
101:                 
102:                 short KbdScancode(){  // obtient le code clavier en tête de la file
9D007FBC  27BDFFE8   ADDIU SP, SP, -24
9D007FC0  AFBF0014   SW RA, 20(SP)
9D007FC4  AFB00010   SW S0, 16(SP)
9D0082B0  3C079D01   LUI A3, -25343
9D0082B4  24E7FBFC   ADDIU A3, A3, -1028
103:                 	unsigned int i, flags;
104:                         state_t state;
105:                 	short code;
106:                         if (head==tail){
9D007FC8  93838083   LBU V1, -32637(GP)
9D007FCC  306300FF   ANDI V1, V1, 255
9D007FD0  93828081   LBU V0, -32639(GP)
9D007FD4  304200FF   ANDI V0, V0, 255
9D007FD8  1462001B   BNE V1, V0, 0x9D008048
9D007FDC  00002021   ADDU A0, ZERO, ZERO
9D008048  00003021   ADDU A2, ZERO, ZERO
107:                             if (rx_flags & F_ERROR){
9D007FE0  9383807D   LBU V1, -32643(GP)
9D007FE4  30630001   ANDI V1, V1, 1
9D007FE8  10600162   BEQ V1, ZERO, 0x9D008574
9D007FEC  00001021   ADDU V0, ZERO, ZERO
108:                                 _status_on();
9D007FF0  3C10BF88   LUI S0, -16504
9D007FF4  8E026120   LW V0, 24864(S0)
9D007FF8  34420008   ORI V0, V0, 8
9D007FFC  AE026120   SW V0, 24864(S0)
109:                                 delay_ms(400);
9D008000  0F403644   JAL delay_ms
9D008004  24040190   ADDIU A0, ZERO, 400
110:                                 _status_off();
9D008008  8E036120   LW V1, 24864(S0)
9D00800C  2402FFF7   ADDIU V0, ZERO, -9
9D008010  00621024   AND V0, V1, V0
9D008014  AE026120   SW V0, 24864(S0)
111:                                 delay_ms(400);
9D008018  0F403644   JAL delay_ms
9D00801C  24040190   ADDIU A0, ZERO, 400
112:                                 rx_flags &= ~F_ERROR;
9D008020  9382807D   LBU V0, -32643(GP)
9D008024  304200FE   ANDI V0, V0, 254
9D008028  A382807D   SB V0, -32643(GP)
113:                                 IEC0bits.INT4IE=1;
9D00802C  3C02BF88   LUI V0, -16504
9D008030  8C431060   LW V1, 4192(V0)
9D008034  24040001   ADDIU A0, ZERO, 1
9D008038  7C83BDC4   INS V1, A0, 23, 1
9D00803C  AC431060   SW V1, 4192(V0)
114:                             }
115:                             return 0; // tampon vide
9D008040  0B40215D   J 0x9D008574
9D008044  00001021   ADDU V0, ZERO, ZERO
116:                         }
117:                 	code = 0;
118:                 	flags=0;
119:                         state=ST0;
120:                 	while (state!=ST_COMPLETED){
9D00805C  240A0003   ADDIU T2, ZERO, 3
9D008220  148AFF91   BNE A0, T2, 0x9D008068
9D008224  00000000   NOP
121:                             _wait_key();
9D008068  93838083   LBU V1, -32637(GP)
9D00806C  306300FF   ANDI V1, V1, 255
9D008070  93828081   LBU V0, -32639(GP)
9D008074  304200FF   ANDI V0, V0, 255
9D008078  1062FFFB   BEQ V1, V0, 0x9D008068
9D00807C  00000000   NOP
122:                             code=kbd_queue[head];
9D00804C  3C08A000   LUI T0, -24576
9D008050  25082A24   ADDIU T0, T0, 10788
9D008080  93828083   LBU V0, -32637(GP)
9D008084  304200FF   ANDI V0, V0, 255
9D008088  00481021   ADDU V0, V0, T0
9D00808C  90430000   LBU V1, 0(V0)
9D008090  7C031620   SEH V0, V1
123:                             head++;
9D008094  93858083   LBU A1, -32637(GP)
9D008098  24A50001   ADDIU A1, A1, 1
9D00809C  30A500FF   ANDI A1, A1, 255
9D0080A0  A3858083   SB A1, -32637(GP)
124:                             head &= 31;
9D0080A4  93858083   LBU A1, -32637(GP)
9D0080A8  30A5001F   ANDI A1, A1, 31
9D0080AC  A3858083   SB A1, -32637(GP)
125:                             switch (state){
9D008054  24070001   ADDIU A3, ZERO, 1
9D0080B0  10870026   BEQ A0, A3, 0x9D00814C
9D0080B4  00000000   NOP
9D0080B8  10800006   BEQ A0, ZERO, 0x9D0080D4
9D0080BC  00000000   NOP
9D0080C0  24030002   ADDIU V1, ZERO, 2
9D0080C4  14830056   BNE A0, V1, 0x9D008220
9D0080C8  00C02821   ADDU A1, A2, ZERO
126:                                 case ST0:
127:                                     switch (code){
9D008060  240B00E1   ADDIU T3, ZERO, 225
9D008064  240C00E0   ADDIU T4, ZERO, 224
9D0080D4  106B000B   BEQ V1, T3, 0x9D008104
9D0080D8  24040007   ADDIU A0, ZERO, 7
9D0080DC  50690005   BEQL V1, T1, 0x9D0080F4
9D0080E0  34C68000   ORI A2, A2, -32768
9D0080E4  146C004E   BNE V1, T4, 0x9D008220
9D0080E8  01402021   ADDU A0, T2, ZERO
128:                                         case KEY_REL:
129:                                             flags |= REL_BIT;
130:                                             state = ST_RELEASE;
131:                                             break;
9D0080F4  0B40201A   J 0x9D008068
9D0080F8  24040002   ADDIU A0, ZERO, 2
132:                                         case XTD_KEY:
133:                                             flags |= XT_BIT;
9D0080EC  0B40203F   J 0x9D0080FC
9D0080F0  34C60100   ORI A2, A2, 256
134:                                             state = ST_EXT0;
135:                                             break;
9D0080FC  0B40201A   J 0x9D008068
9D008100  00E02021   ADDU A0, A3, ZERO
136:                                         case 0xE1:
137:                                             for (i=7;i;i--){     // touche PAUSE élimine les 7 prochains caractères
9D00813C  1480FFF1   BNE A0, ZERO, 0x9D008104
9D008140  240201E1   ADDIU V0, ZERO, 481
138:                                                     _wait_key();
9D008104  93838083   LBU V1, -32637(GP)
9D008108  306300FF   ANDI V1, V1, 255
9D00810C  93828081   LBU V0, -32639(GP)
9D008110  304200FF   ANDI V0, V0, 255
9D008114  1062FFFB   BEQ V1, V0, 0x9D008104
9D008118  00000000   NOP
139:                                                     head++;
9D00811C  93828083   LBU V0, -32637(GP)
9D008120  24420001   ADDIU V0, V0, 1
9D008124  304200FF   ANDI V0, V0, 255
9D008128  A3828083   SB V0, -32637(GP)
140:                                                     head &= 31;
9D00812C  93828083   LBU V0, -32637(GP)
9D008130  3042001F   ANDI V0, V0, 31
9D008134  A3828083   SB V0, -32637(GP)
9D008138  2484FFFF   ADDIU A0, A0, -1
141:                                             }
142:                                             code = PAUSE;
143:                                         default:
144:                                             state=ST_COMPLETED;
145:                                     }//switch(code)
146:                                     break;
147:                                 case ST_EXT0:
148:                                     if (code==KEY_REL){
9D008058  240900F0   ADDIU T1, ZERO, 240
9D00814C  14490004   BNE V0, T1, 0x9D008160
9D008150  30C30100   ANDI V1, A2, 256
149:                                         flags |= REL_BIT;
9D008154  34C68000   ORI A2, A2, -32768
150:                                         state = ST_RELEASE;
9D008158  0B40201A   J 0x9D008068
9D00815C  24040002   ADDIU A0, ZERO, 2
151:                                     }else{
152:                                         if ((flags & XT_BIT) && (code==0x12)){ // touche PrtSc enfoncée.
9D008160  10600031   BEQ V1, ZERO, 0x9D008228
9D008164  00C02821   ADDU A1, A2, ZERO
9D008168  24030012   ADDIU V1, ZERO, 18
9D00816C  1443002F   BNE V0, V1, 0x9D00822C
9D008170  3C03BF88   LUI V1, -16504
9D008174  24040002   ADDIU A0, ZERO, 2
153:                                             for (i=2;i;i--){ // élimine les 2 codes suivants
9D0081B0  1480FFF1   BNE A0, ZERO, 0x9D008178
9D0081B4  24020112   ADDIU V0, ZERO, 274
9D0081B8  0B40208A   J 0x9D008228
9D0081BC  00A03021   ADDU A2, A1, ZERO
154:                                                 _wait_key();
9D008178  93838083   LBU V1, -32637(GP)
9D00817C  306300FF   ANDI V1, V1, 255
9D008180  93828081   LBU V0, -32639(GP)
9D008184  304200FF   ANDI V0, V0, 255
9D008188  1062FFFB   BEQ V1, V0, 0x9D008178
9D00818C  00000000   NOP
155:                                                 head++;
9D008190  93828083   LBU V0, -32637(GP)
9D008194  24420001   ADDIU V0, V0, 1
9D008198  304200FF   ANDI V0, V0, 255
9D00819C  A3828083   SB V0, -32637(GP)
156:                                                 head &=31;
9D0081A0  93828083   LBU V0, -32637(GP)
9D0081A4  3042001F   ANDI V0, V0, 31
9D0081A8  A3828083   SB V0, -32637(GP)
9D0081AC  2484FFFF   ADDIU A0, A0, -1
157:                                             }
158:                                             code = PRN;
159:                                         }
160:                                         state = ST_COMPLETED;
161:                                     }
162:                                     break;
163:                                 case ST_RELEASE:
164:                                     if ((flags & XT_BIT) && (code==0x7c)){ //touche PrtSc relâchée.
9D0080CC  0B402070   J 0x9D0081C0
9D0080D0  30C30100   ANDI V1, A2, 256
9D0081C0  1060001A   BEQ V1, ZERO, 0x9D00822C
9D0081C4  3C03BF88   LUI V1, -16504
9D0081C8  2403007C   ADDIU V1, ZERO, 124
9D0081CC  14430017   BNE V0, V1, 0x9D00822C
9D0081D0  3C03BF88   LUI V1, -16504
9D0081D4  24040003   ADDIU A0, ZERO, 3
165:                                         for (i=3;i;i--){ // élimine les 3 codes suivants.
9D008210  1480FFF1   BNE A0, ZERO, 0x9D0081D8
9D008214  24020112   ADDIU V0, ZERO, 274
9D008218  0B40208A   J 0x9D008228
9D00821C  00A03021   ADDU A2, A1, ZERO
166:                                             _wait_key();
9D0081D8  93838083   LBU V1, -32637(GP)
9D0081DC  306300FF   ANDI V1, V1, 255
9D0081E0  93828081   LBU V0, -32639(GP)
9D0081E4  304200FF   ANDI V0, V0, 255
9D0081E8  1062FFFB   BEQ V1, V0, 0x9D0081D8
9D0081EC  00000000   NOP
167:                                             head++;
9D0081F0  93828083   LBU V0, -32637(GP)
9D0081F4  24420001   ADDIU V0, V0, 1
9D0081F8  304200FF   ANDI V0, V0, 255
9D0081FC  A3828083   SB V0, -32637(GP)
168:                                             head &= 31;
9D008200  93828083   LBU V0, -32637(GP)
9D008204  3042001F   ANDI V0, V0, 31
9D008208  A3828083   SB V0, -32637(GP)
9D00820C  2484FFFF   ADDIU A0, A0, -1
169:                                         }
170:                                         code = PRN;
171:                                     }
172:                                     state=ST_COMPLETED;
173:                                     break;
174:                                 default:;
175:                             }//switch(state)
176:                         }//while(state...)
177:                         IEC0bits.INT4IE=0; // section critique désactive interruption
9D008144  0B40208B   J 0x9D00822C
9D008148  3C03BF88   LUI V1, -16504
9D008228  3C03BF88   LUI V1, -16504
9D00822C  8C641060   LW A0, 4192(V1)
9D008230  7C04BDC4   INS A0, ZERO, 23, 1
9D008234  AC641060   SW A0, 4192(V1)
178:                 	if (head==tail){
9D008238  93848083   LBU A0, -32637(GP)
9D00823C  308400FF   ANDI A0, A0, 255
9D008240  93838081   LBU V1, -32639(GP)
9D008244  306300FF   ANDI V1, V1, 255
9D008248  14830005   BNE A0, V1, 0x9D008260
9D00824C  3C03BF88   LUI V1, -16504
179:                 		rx_flags &= ~F_RCVD;
9D008250  9383807D   LBU V1, -32643(GP)
9D008254  306300FD   ANDI V1, V1, 253
9D008258  A383807D   SB V1, -32643(GP)
180:                 	}
181:                         IEC0bits.INT4IE=1; // fin section critique réactive interruption
9D00825C  3C03BF88   LUI V1, -16504
9D008260  8C641060   LW A0, 4192(V1)
9D008264  24050001   ADDIU A1, ZERO, 1
9D008268  7CA4BDC4   INS A0, A1, 23, 1
9D00826C  AC641060   SW A0, 4192(V1)
182:                         if ((code==KBD_ACK)||(code==KBD_RSND)||(code==BAT_OK)||(code==BAT_ERROR)){
9D008270  240300FA   ADDIU V1, ZERO, 250
9D008274  104300BF   BEQ V0, V1, 0x9D008574
9D008278  240300FE   ADDIU V1, ZERO, 254
9D00827C  104300BD   BEQ V0, V1, 0x9D008574
9D008280  240300AA   ADDIU V1, ZERO, 170
9D008284  104300BB   BEQ V0, V1, 0x9D008574
9D008288  240300FC   ADDIU V1, ZERO, 252
9D00828C  104300B9   BEQ V0, V1, 0x9D008574
9D008290  24030058   ADDIU V1, ZERO, 88
183:                             return code;
184:                         }
185:                         code |= flags;
9D008294  00462825   OR A1, V0, A2
9D008298  30A5FFFF   ANDI A1, A1, -1
9D00829C  7C051620   SEH V0, A1
186:                         for (i=0;i<FN_COUNT;i++){
9D008560  5467FF56   BNEL V1, A3, 0x9D0082BC
9D008564  84640000   LH A0, 0(V1)
187:                             if ((code&0x1ff)==fn_keys[i]){
9D0082A0  30A501FF   ANDI A1, A1, 511
9D0082A4  10A30007   BEQ A1, V1, 0x9D0082C4
9D0082A8  3C039D01   LUI V1, -25343
9D0082AC  2463FBBE   ADDIU V1, V1, -1090
9D0082B8  84640000   LH A0, 0(V1)
9D0082BC  148500A8   BNE A0, A1, 0x9D008560
9D0082C0  24630002   ADDIU V1, V1, 2
188:                                 code |= FN_BIT;
9D0082C4  34420200   ORI V0, V0, 512
9D0082C8  7C021620   SEH V0, V0
189:                                 switch (code&0x1ff){ // les touches d'alteration sont traitées ici.
9D0082CC  304301FF   ANDI V1, V0, 511
9D0082D0  24040059   ADDIU A0, ZERO, 89
9D0082D4  10640030   BEQ V1, A0, 0x9D008398
9D0082D8  2864005A   SLTI A0, V1, 90
9D0082DC  10800011   BEQ A0, ZERO, 0x9D008324
9D0082E0  2404007E   ADDIU A0, ZERO, 126
9D0082E4  24040012   ADDIU A0, ZERO, 18
9D0082E8  1064001D   BEQ V1, A0, 0x9D008360
9D0082EC  28640013   SLTI A0, V1, 19
9D0082F0  10800006   BEQ A0, ZERO, 0x9D00830C
9D0082F4  24040014   ADDIU A0, ZERO, 20
9D0082F8  24040011   ADDIU A0, ZERO, 17
9D0082FC  1464009A   BNE V1, A0, 0x9D008568
9D008300  00000000   NOP
9D00830C  10640030   BEQ V1, A0, 0x9D0083D0
9D008310  24040058   ADDIU A0, ZERO, 88
9D008314  14640094   BNE V1, A0, 0x9D008568
9D008318  00000000   NOP
9D008324  1064007E   BEQ V1, A0, 0x9D008520
9D008328  2864007F   SLTI A0, V1, 127
9D00832C  10800006   BEQ A0, ZERO, 0x9D008348
9D008330  24040111   ADDIU A0, ZERO, 273
9D008334  24040077   ADDIU A0, ZERO, 119
9D008338  1464008B   BNE V1, A0, 0x9D008568
9D00833C  00000000   NOP
9D008348  1064003C   BEQ V1, A0, 0x9D00843C
9D00834C  24040114   ADDIU A0, ZERO, 276
9D008350  14640085   BNE V1, A0, 0x9D008568
9D008354  00000000   NOP
190:                                     case LSHIFT:
191:                                         if (flags & REL_BIT){
9D008360  30C68000   ANDI A2, A2, -32768
9D008364  10C00006   BEQ A2, ZERO, 0x9D008380
9D008368  00000000   NOP
192:                                             key_state &=~F_LSHIFT;
9D00836C  97828100   LHU V0, -32512(GP)
9D008370  3042FFF7   ANDI V0, V0, -9
9D008374  A7828100   SH V0, -32512(GP)
9D008378  0B40215D   J 0x9D008574
9D00837C  00001021   ADDU V0, ZERO, ZERO
193:                                         }else{
194:                                             key_state |= F_LSHIFT;
9D008380  97828100   LHU V0, -32512(GP)
9D008384  3042FFFF   ANDI V0, V0, -1
9D008388  34420008   ORI V0, V0, 8
9D00838C  A7828100   SH V0, -32512(GP)
9D008390  0B40215D   J 0x9D008574
9D008394  00001021   ADDU V0, ZERO, ZERO
195:                                         }
196:                                         code=0;
197:                                         break;
198:                                     case RSHIFT:
199:                                         if (flags & REL_BIT){
9D008398  30C68000   ANDI A2, A2, -32768
9D00839C  10C00006   BEQ A2, ZERO, 0x9D0083B8
9D0083A0  00000000   NOP
200:                                             key_state &=~F_RSHIFT;
9D0083A4  97828100   LHU V0, -32512(GP)
9D0083A8  3042FFEF   ANDI V0, V0, -17
9D0083AC  A7828100   SH V0, -32512(GP)
9D0083B0  0B40215D   J 0x9D008574
9D0083B4  00001021   ADDU V0, ZERO, ZERO
201:                                         }else{
202:                                             key_state |= F_RSHIFT;
9D0083B8  97828100   LHU V0, -32512(GP)
9D0083BC  3042FFFF   ANDI V0, V0, -1
9D0083C0  34420010   ORI V0, V0, 16
9D0083C4  A7828100   SH V0, -32512(GP)
9D0083C8  0B40215D   J 0x9D008574
9D0083CC  00001021   ADDU V0, ZERO, ZERO
203:                                         }
204:                                         code=0;
205:                                         break;
206:                                     case LCTRL:
207:                                         if (flags & REL_BIT){
9D0083D0  30C68000   ANDI A2, A2, -32768
9D0083D4  10C00006   BEQ A2, ZERO, 0x9D0083F0
9D0083D8  00000000   NOP
208:                                             key_state &=~F_LCTRL;
9D0083DC  97828100   LHU V0, -32512(GP)
9D0083E0  3042FFDF   ANDI V0, V0, -33
9D0083E4  A7828100   SH V0, -32512(GP)
9D0083E8  0B40215D   J 0x9D008574
9D0083EC  00001021   ADDU V0, ZERO, ZERO
209:                                         }else{
210:                                             key_state |= F_LCTRL;
9D0083F0  97828100   LHU V0, -32512(GP)
9D0083F4  3042FFFF   ANDI V0, V0, -1
9D0083F8  34420020   ORI V0, V0, 32
9D0083FC  A7828100   SH V0, -32512(GP)
9D008400  0B40215D   J 0x9D008574
9D008404  00001021   ADDU V0, ZERO, ZERO
211:                                         }
212:                                         code=0;
213:                                         break;
214:                                     case RCTRL:
215:                                         if (flags & REL_BIT){
9D008358  0B402102   J 0x9D008408
9D00835C  30C68000   ANDI A2, A2, -32768
9D008408  10C00006   BEQ A2, ZERO, 0x9D008424
9D00840C  00000000   NOP
216:                                             key_state &=~F_RCTRL;
9D008410  97828100   LHU V0, -32512(GP)
9D008414  3042FFBF   ANDI V0, V0, -65
9D008418  A7828100   SH V0, -32512(GP)
9D00841C  0B40215D   J 0x9D008574
9D008420  00001021   ADDU V0, ZERO, ZERO
217:                                         }else{
218:                                             key_state |= F_RCTRL;
9D008424  97828100   LHU V0, -32512(GP)
9D008428  3042FFFF   ANDI V0, V0, -1
9D00842C  34420040   ORI V0, V0, 64
9D008430  A7828100   SH V0, -32512(GP)
9D008434  0B40215D   J 0x9D008574
9D008438  00001021   ADDU V0, ZERO, ZERO
219:                                         }
220:                                         code=0;
221:                                         break;
222:                                     case RALT:
223:                                         if (flags & REL_BIT){
9D00843C  30C68000   ANDI A2, A2, -32768
9D008440  10C00006   BEQ A2, ZERO, 0x9D00845C
9D008444  00000000   NOP
224:                                             key_state &=~F_ALTCHAR;
9D008448  97828100   LHU V0, -32512(GP)
9D00844C  3042FEFF   ANDI V0, V0, -257
9D008450  A7828100   SH V0, -32512(GP)
9D008454  0B40215D   J 0x9D008574
9D008458  00001021   ADDU V0, ZERO, ZERO
225:                                         }else{
226:                                             key_state |= F_ALTCHAR;
9D00845C  97828100   LHU V0, -32512(GP)
9D008460  3042FFFF   ANDI V0, V0, -1
9D008464  34420100   ORI V0, V0, 256
9D008468  A7828100   SH V0, -32512(GP)
9D00846C  0B40215D   J 0x9D008574
9D008470  00001021   ADDU V0, ZERO, ZERO
227:                                         }
228:                                         code=0;
229:                                         break;
230:                                     case LALT:
231:                                         if (flags & REL_BIT){
9D008304  0B40211D   J 0x9D008474
9D008308  30C68000   ANDI A2, A2, -32768
9D008474  10C00006   BEQ A2, ZERO, 0x9D008490
9D008478  00000000   NOP
232:                                             key_state &=~F_LALT;
9D00847C  97828100   LHU V0, -32512(GP)
9D008480  3042FF7F   ANDI V0, V0, -129
9D008484  A7828100   SH V0, -32512(GP)
9D008488  0B40215D   J 0x9D008574
9D00848C  00001021   ADDU V0, ZERO, ZERO
233:                                         }else{
234:                                             key_state |= F_LALT;
9D008490  97828100   LHU V0, -32512(GP)
9D008494  3042FFFF   ANDI V0, V0, -1
9D008498  34420080   ORI V0, V0, 128
9D00849C  A7828100   SH V0, -32512(GP)
9D0084A0  0B40215D   J 0x9D008574
9D0084A4  00001021   ADDU V0, ZERO, ZERO
235:                                         }
236:                                         code=0;
237:                                         break;
238:                                     case NUM_LOCK:
239:                                         if (flags & REL_BIT){
9D008340  0B40212A   J 0x9D0084A8
9D008344  30C68000   ANDI A2, A2, -32768
9D0084A8  10C00032   BEQ A2, ZERO, 0x9D008574
9D0084AC  00001021   ADDU V0, ZERO, ZERO
240:                                             kbd_leds ^= F_NUM;
9D0084B0  9382807E   LBU V0, -32642(GP)
9D0084B4  304200FF   ANDI V0, V0, 255
9D0084B8  38420002   XORI V0, V0, 2
9D0084BC  A382807E   SB V0, -32642(GP)
241:                                             key_state ^= F_NUM;
9D0084C0  97828100   LHU V0, -32512(GP)
9D0084C4  3042FFFF   ANDI V0, V0, -1
9D0084C8  38420002   XORI V0, V0, 2
9D0084CC  A7828100   SH V0, -32512(GP)
242:                                             SetKbdLeds(kbd_leds);
9D0084D0  9384807E   LBU A0, -32642(GP)
9D0084D4  0F401FBA   JAL SetKbdLeds
9D0084D8  308400FF   ANDI A0, A0, 255
9D0084DC  0B40215D   J 0x9D008574
9D0084E0  00001021   ADDU V0, ZERO, ZERO
243:                                         }
244:                                         code=0;
245:                                         break;
246:                                     case CAPS_LOCK:
247:                                         if (flags & REL_BIT){
9D00831C  0B402139   J 0x9D0084E4
9D008320  30C68000   ANDI A2, A2, -32768
9D0084E4  10C00023   BEQ A2, ZERO, 0x9D008574
9D0084E8  00001021   ADDU V0, ZERO, ZERO
248:                                             kbd_leds ^= F_CAPS;
9D0084EC  9382807E   LBU V0, -32642(GP)
9D0084F0  304200FF   ANDI V0, V0, 255
9D0084F4  38420004   XORI V0, V0, 4
9D0084F8  A382807E   SB V0, -32642(GP)
249:                                             key_state ^= F_CAPS;
9D0084FC  97828100   LHU V0, -32512(GP)
9D008500  3042FFFF   ANDI V0, V0, -1
9D008504  38420004   XORI V0, V0, 4
9D008508  A7828100   SH V0, -32512(GP)
250:                                             SetKbdLeds(kbd_leds);
9D00850C  9384807E   LBU A0, -32642(GP)
9D008510  0F401FBA   JAL SetKbdLeds
9D008514  308400FF   ANDI A0, A0, 255
9D008518  0B40215D   J 0x9D008574
9D00851C  00001021   ADDU V0, ZERO, ZERO
251:                                         }
252:                                         code=0;
253:                                         break;
254:                                     case SCROLL_LOCK:
255:                                         if (flags & REL_BIT){
9D008520  30C68000   ANDI A2, A2, -32768
9D008524  10C00013   BEQ A2, ZERO, 0x9D008574
9D008528  00001021   ADDU V0, ZERO, ZERO
256:                                             kbd_leds ^= F_SCROLL;
9D00852C  9382807E   LBU V0, -32642(GP)
9D008530  304200FF   ANDI V0, V0, 255
9D008534  38420001   XORI V0, V0, 1
9D008538  A382807E   SB V0, -32642(GP)
257:                                             key_state ^= F_SCROLL;
9D00853C  97828100   LHU V0, -32512(GP)
9D008540  3042FFFF   ANDI V0, V0, -1
9D008544  38420001   XORI V0, V0, 1
9D008548  A7828100   SH V0, -32512(GP)
258:                                             SetKbdLeds(kbd_leds);
9D00854C  9384807E   LBU A0, -32642(GP)
9D008550  0F401FBA   JAL SetKbdLeds
9D008554  308400FF   ANDI A0, A0, 255
9D008558  0B40215D   J 0x9D008574
9D00855C  00001021   ADDU V0, ZERO, ZERO
259:                                         }
260:                                         code=0;
261:                                         break;
262:                                     default:;
263:                                 }//switch(code)
264:                                 break;
265:                             }// if
266:                         }//for
267:                         if ((code < 0) && !(code & FN_BIT)) // ne retourne pas les relâchement de touche pour les touches caractères.
9D008568  04410002   BGEZ V0, 0x9D008574
9D00856C  30430200   ANDI V1, V0, 512
268:                             return 0;
9D008570  0003100A   MOVZ V0, ZERO, V1
269:                         else
270:                             return code;
271:                 }// GetScancode()
9D008574  8FBF0014   LW RA, 20(SP)
9D008578  8FB00010   LW S0, 16(SP)
9D00857C  03E00008   JR RA
9D008580  27BD0018   ADDIU SP, SP, 24
272:                 
273:                 
274:                 short KbdKey(short scancode){  // obtient la transcription du code en ASCII
9D007B20  7C042620   SEH A0, A0
275:                 	int a,i;
276:                 	a=0;
9D007B8C  0B401F44   J 0x9D007D10
9D007B90  00001021   ADDU V0, ZERO, ZERO
277:                 	if (scancode & XT_BIT){
9D007B24  3086FFFF   ANDI A2, A0, -1
9D007B28  30C20100   ANDI V0, A2, 256
9D007B2C  10400019   BEQ V0, ZERO, 0x9D007B94
9D007B30  3C029D01   LUI V0, -25343
278:                 		i=0;
279:                 		while (qwerty_xt_char[i].code){
9D007B34  8443ED50   LH V1, -4784(V0)
9D007B38  10600075   BEQ V1, ZERO, 0x9D007D10
9D007B3C  00001021   ADDU V0, ZERO, ZERO
9D007B80  84430000   LH V1, 0(V0)
9D007B84  1460FFF2   BNE V1, ZERO, 0x9D007B50
9D007B88  24A50001   ADDIU A1, A1, 1
280:                 			if (qwerty_xt_char[i].code==scancode){
9D007B40  5483000D   BNEL A0, V1, 0x9D007B78
9D007B44  3C029D01   LUI V0, -25343
9D007B48  0B401ED8   J 0x9D007B60
9D007B4C  00002821   ADDU A1, ZERO, ZERO
9D007B50  1483000B   BNE A0, V1, 0x9D007B80
9D007B54  24420004   ADDIU V0, V0, 4
9D007B7C  00002821   ADDU A1, ZERO, ZERO
281:                 				a=qwerty_xt_char[i].ascii;
9D007B58  0B401ED9   J 0x9D007B64
9D007B5C  00052880   SLL A1, A1, 2
9D007B60  00052880   SLL A1, A1, 2
9D007B64  3C029D01   LUI V0, -25343
9D007B68  2442ED50   ADDIU V0, V0, -4784
9D007B6C  00452821   ADDU A1, V0, A1
282:                 				break;
9D007B70  0B401F44   J 0x9D007D10
9D007B74  84A20002   LH V0, 2(A1)
9D007B78  2442ED54   ADDIU V0, V0, -4780
283:                 			}
284:                 			i++;
285:                 		} // while (xt_char[i].code)
286:                 	}else if (key_state & F_SHIFT){
9D007B94  97828100   LHU V0, -32512(GP)
9D007B98  30420018   ANDI V0, V0, 24
9D007B9C  5440000A   BNEL V0, ZERO, 0x9D007BC8
9D007BA0  3C029D01   LUI V0, -25343
287:                 		i=0;
288:                 		while (qwerty_shifted_key[i].code){
9D007BC8  8442ECFC   LH V0, -4868(V0)
9D007BCC  50400019   BEQL V0, ZERO, 0x9D007C34
9D007BD0  3C029D01   LUI V0, -25343
9D007C24  84430000   LH V1, 0(V0)
9D007C28  1460FFEF   BNE V1, ZERO, 0x9D007BE8
9D007C2C  24A50001   ADDIU A1, A1, 1
289:                 			if (qwerty_shifted_key[i].code==(scancode&0xff)){
9D007BD4  30C700FF   ANDI A3, A2, 255
9D007BD8  14470010   BNE V0, A3, 0x9D007C1C
9D007BDC  3C029D01   LUI V0, -25343
9D007BE0  0B401EFE   J 0x9D007BF8
9D007BE4  00002821   ADDU A1, ZERO, ZERO
9D007BE8  1467000E   BNE V1, A3, 0x9D007C24
9D007BEC  24420004   ADDIU V0, V0, 4
9D007C20  00002821   ADDU A1, ZERO, ZERO
290:                 				a=qwerty_shifted_key[i].ascii;
9D007BF0  0B401EFF   J 0x9D007BFC
9D007BF4  00052880   SLL A1, A1, 2
9D007BF8  00052880   SLL A1, A1, 2
9D007BFC  3C029D01   LUI V0, -25343
9D007C00  2442ECFC   ADDIU V0, V0, -4868
9D007C04  00452821   ADDU A1, V0, A1
9D007C08  84A20002   LH V0, 2(A1)
291:                 				break;
292:                 			}
293:                 			i++;
294:                 		}// while (shifted_key.code)
295:                 		if (!a){
9D007C0C  14400041   BNE V0, ZERO, 0x9D007D14
9D007C10  2403FF00   ADDIU V1, ZERO, -256
9D007C1C  2442ED00   ADDIU V0, V0, -4864
296:                 			i=0;
297:                 			while (qwerty[i].code){
9D007C14  0B401F0D   J 0x9D007C34
9D007C18  3C029D01   LUI V0, -25343
9D007C30  3C029D01   LUI V0, -25343
9D007C34  8443EBEC   LH V1, -5140(V0)
9D007C38  10600035   BEQ V1, ZERO, 0x9D007D10
9D007C3C  00001021   ADDU V0, ZERO, ZERO
9D007C94  84430000   LH V1, 0(V0)
9D007C98  1460FFEE   BNE V1, ZERO, 0x9D007C54
9D007C9C  24A50001   ADDIU A1, A1, 1
9D007CA0  0B401F44   J 0x9D007D10
9D007CA4  00001021   ADDU V0, ZERO, ZERO
298:                 				if (qwerty[i].code==(scancode&0xff)){
9D007C40  30C600FF   ANDI A2, A2, 255
9D007C44  54660011   BNEL V1, A2, 0x9D007C8C
9D007C48  3C029D01   LUI V0, -25343
9D007C4C  0B401F19   J 0x9D007C64
9D007C50  00002821   ADDU A1, ZERO, ZERO
9D007C54  14C3000F   BNE A2, V1, 0x9D007C94
9D007C58  24420004   ADDIU V0, V0, 4
9D007C90  00002821   ADDU A1, ZERO, ZERO
299:                 					a=qwerty[i].ascii;
9D007C5C  0B401F1A   J 0x9D007C68
9D007C60  00052880   SLL A1, A1, 2
9D007C64  00052880   SLL A1, A1, 2
9D007C68  3C029D01   LUI V0, -25343
9D007C6C  2442EBEC   ADDIU V0, V0, -5140
9D007C70  00452821   ADDU A1, V0, A1
9D007C74  84A20002   LH V0, 2(A1)
300:                 					break;
301:                 				}
302:                 				i++;
303:                 			}// while (translate.code)
304:                 			if (a>='a' && a<='z'){
9D007C78  2445FF9F   ADDIU A1, V0, -97
9D007C7C  2CA5001A   SLTIU A1, A1, 26
9D007C8C  2442EBF0   ADDIU V0, V0, -5136
305:                 				a -=32;
9D007C80  2443FFE0   ADDIU V1, V0, -32
9D007C84  0B401F44   J 0x9D007D10
9D007C88  0065100B   MOVN V0, V1, A1
306:                 			}
307:                 		} // if (!a)
308:                 	}else{
309:                 		i=0;
310:                 		while (qwerty[i].code){
9D007BA4  3C029D01   LUI V0, -25343
9D007BA8  8443EBEC   LH V1, -5140(V0)
9D007BAC  10600058   BEQ V1, ZERO, 0x9D007D10
9D007BB0  00001021   ADDU V0, ZERO, ZERO
9D007CEC  84430000   LH V1, 0(V0)
9D007CF0  1460FFED   BNE V1, ZERO, 0x9D007CA8
9D007CF4  24A50001   ADDIU A1, A1, 1
9D007CF8  0B401F44   J 0x9D007D10
9D007CFC  00001021   ADDU V0, ZERO, ZERO
311:                 			if (qwerty[i].code==(scancode&0xff)){
9D007BB4  30C600FF   ANDI A2, A2, 255
9D007BB8  1466004A   BNE V1, A2, 0x9D007CE4
9D007BBC  3C029D01   LUI V0, -25343
9D007BC0  0B401F2E   J 0x9D007CB8
9D007BC4  00002821   ADDU A1, ZERO, ZERO
9D007CA8  14660010   BNE V1, A2, 0x9D007CEC
9D007CAC  24420004   ADDIU V0, V0, 4
9D007CE8  00002821   ADDU A1, ZERO, ZERO
312:                 				a=qwerty[i].ascii;
9D007CB0  0B401F2F   J 0x9D007CBC
9D007CB4  00052880   SLL A1, A1, 2
9D007CB8  00052880   SLL A1, A1, 2
9D007CBC  3C029D01   LUI V0, -25343
9D007CC0  2442EBEC   ADDIU V0, V0, -5140
9D007CC4  00452821   ADDU A1, V0, A1
9D007CC8  84A20002   LH V0, 2(A1)
313:                 				break;
314:                 			}
315:                 			i++;
316:                 		}// while (translate.code)
317:                 		if (a>='a' && a<='z' && (key_state & F_CAPS)){
9D007CCC  2443FF9F   ADDIU V1, V0, -97
9D007CD0  2C63001A   SLTIU V1, V1, 26
9D007CD4  1460000A   BNE V1, ZERO, 0x9D007D00
9D007CD8  2403FF00   ADDIU V1, ZERO, -256
9D007CE4  2442EBF0   ADDIU V0, V0, -5136
9D007D00  97858100   LHU A1, -32512(GP)
9D007D04  30A50004   ANDI A1, A1, 4
318:                 			a -=32;
9D007D08  2443FFE0   ADDIU V1, V0, -32
9D007D0C  0065100B   MOVN V0, V1, A1
319:                 		}
320:                 	}
321:                 	return a|(scancode&0xff00);
9D007CDC  0B401F46   J 0x9D007D18
9D007CE0  00832024   AND A0, A0, V1
9D007D10  2403FF00   ADDIU V1, ZERO, -256
9D007D14  00832024   AND A0, A0, V1
9D007D18  00441025   OR V0, V0, A0
322:                 } // GetKey()
9D007D1C  03E00008   JR RA
9D007D20  7C021620   SEH V0, V0
323:                 
324:                 void KbdSend(char cmd){  // envoie une commande au clavier
9D007D24  7C042420   SEB A0, A0
325:                     register unsigned int dly;
326:                         bit_cnt=0;
9D007D28  A380807F   SB ZERO, -32641(GP)
327:                 	parity=0;
9D007D2C  A3808080   SB ZERO, -32640(GP)
328:                 	IEC0CLR=_IEC0_INT4IE_MASK; // désactive les interruptions sur KBD_CLK
9D007D30  3C030080   LUI V1, 128
9D007D34  3C02BF88   LUI V0, -16504
9D007D38  AC431064   SW V1, 4196(V0)
329:                         TRISACLR = KBD_CLK; // MCU prend le contrôle de la ligne KBD_CLK
9D007D3C  24020001   ADDIU V0, ZERO, 1
9D007D40  3C03BF88   LUI V1, -16504
9D007D44  AC626014   SW V0, 24596(V1)
330:                         LATACLR = KBD_CLK; //  mis à 0  KBD_CLK
9D007D48  3C03BF88   LUI V1, -16504
9D007D4C  AC626034   SW V0, 24628(V1)
9D007D50  240204C5   ADDIU V0, ZERO, 1221
9D007D54  2442FFFF   ADDIU V0, V0, -1
331:                         // délais minimum 100µsec
332:                         for (dly=(100/3*CLK_PER_USEC);dly;dly--);
9D007D58  1440FFFF   BNE V0, ZERO, 0x9D007D58
9D007D5C  2442FFFF   ADDIU V0, V0, -1
333:                         TRISACLR = KBD_DAT;	// prend le contrôle de la ligne KBD_DAT
9D007D60  24020002   ADDIU V0, ZERO, 2
9D007D64  3C03BF88   LUI V1, -16504
9D007D68  AC626014   SW V0, 24596(V1)
334:                 	LATACLR = KBD_DAT;   	// met KBD_DAT à zéro
9D007D6C  3C03BF88   LUI V1, -16504
9D007D70  AC626034   SW V0, 24628(V1)
335:                 	TRISASET = KBD_CLK; 	// libère la ligne clock
9D007D74  24030001   ADDIU V1, ZERO, 1
9D007D78  3C02BF88   LUI V0, -16504
9D007D7C  AC436018   SW V1, 24600(V0)
336:                         while (!(PORTAbits.RA0)); // attend que la ligne revienne à 1
9D007D80  3C03BF88   LUI V1, -16504
9D007D84  8C626020   LW V0, 24608(V1)
9D007D88  30420001   ANDI V0, V0, 1
9D007D8C  1040FFFD   BEQ V0, ZERO, 0x9D007D84
9D007D90  00000000   NOP
337:                         while (bit_cnt<8){      // envoie les 8 bits, le moins significatif en premier.
9D007D94  9382807F   LBU V0, -32641(GP)
9D007D98  304200FF   ANDI V0, V0, 255
9D007D9C  2C420008   SLTIU V0, V0, 8
9D007DA0  1040001F   BEQ V0, ZERO, 0x9D007E20
9D007DA4  3C02BF88   LUI V0, -16504
9D007E0C  9383807F   LBU V1, -32641(GP)
9D007E10  306300FF   ANDI V1, V1, 255
9D007E14  2C630008   SLTIU V1, V1, 8
9D007E18  1460FFE6   BNE V1, ZERO, 0x9D007DB4
9D007E1C  00042043   SRA A0, A0, 1
338:                 		while (PORTAbits.RA0);   // attend clock à 0
9D007DB4  8C436020   LW V1, 24608(V0)
9D007DB8  30630001   ANDI V1, V1, 1
9D007DBC  1460FFFD   BNE V1, ZERO, 0x9D007DB4
9D007DC0  30830001   ANDI V1, A0, 1
339:                                 if (cmd&1){
9D007DC4  10600008   BEQ V1, ZERO, 0x9D007DE8
9D007DC8  00000000   NOP
340:                 			LATASET = KBD_DAT;
9D007DB0  3C06BF88   LUI A2, -16504
9D007DCC  ACC56038   SW A1, 24632(A2)
341:                 			parity++;
9D007DD0  93838080   LBU V1, -32640(GP)
9D007DD4  24630001   ADDIU V1, V1, 1
9D007DD8  306300FF   ANDI V1, V1, 255
9D007DDC  A3838080   SB V1, -32640(GP)
9D007DE0  0B401F7B   J 0x9D007DEC
9D007DE4  00000000   NOP
342:                 		}else{
343:                 			LATACLR = KBD_DAT;
9D007DA8  3C07BF88   LUI A3, -16504
9D007DAC  24050002   ADDIU A1, ZERO, 2
9D007DE8  ACE56034   SW A1, 24628(A3)
344:                 		}
345:                 		cmd >>= 1;
346:                 		while (!(PORTAbits.RA0)); // attend clock à 1
9D007DEC  8C436020   LW V1, 24608(V0)
9D007DF0  30630001   ANDI V1, V1, 1
9D007DF4  1060FFFD   BEQ V1, ZERO, 0x9D007DEC
9D007DF8  00000000   NOP
347:                 		bit_cnt++;				  // un bit de plus envoyé.
9D007DFC  9383807F   LBU V1, -32641(GP)
9D007E00  24630001   ADDIU V1, V1, 1
9D007E04  306300FF   ANDI V1, V1, 255
9D007E08  A383807F   SB V1, -32641(GP)
348:                 	}
349:                         while (PORTAbits.RA0);   // attend clock à 0
9D007E20  3C03BF88   LUI V1, -16504
9D007E24  8C626020   LW V0, 24608(V1)
9D007E28  30420001   ANDI V0, V0, 1
9D007E2C  1440FFFD   BNE V0, ZERO, 0x9D007E24
9D007E30  00000000   NOP
350:                 	if (!(parity & 1)){
9D007E34  93828080   LBU V0, -32640(GP)
9D007E38  30420001   ANDI V0, V0, 1
9D007E3C  14400005   BNE V0, ZERO, 0x9D007E54
9D007E40  24030002   ADDIU V1, ZERO, 2
351:                 		LATASET = KBD_DAT;
9D007E44  3C02BF88   LUI V0, -16504
9D007E48  AC436038   SW V1, 24632(V0)
352:                 	}else{
353:                 		LATACLR = KBD_DAT;
9D007E54  3C02BF88   LUI V0, -16504
9D007E58  AC436034   SW V1, 24628(V0)
354:                 	}
355:                 	while (!(PORTAbits.RA0)); // attend clock à 1
9D007E4C  0B401F98   J 0x9D007E60
9D007E50  3C03BF88   LUI V1, -16504
9D007E5C  3C03BF88   LUI V1, -16504
9D007E60  8C626020   LW V0, 24608(V1)
9D007E64  30420001   ANDI V0, V0, 1
9D007E68  1040FFFD   BEQ V0, ZERO, 0x9D007E60
9D007E6C  00000000   NOP
356:                 	while (PORTAbits.RA0);   // attend clock à 0
9D007E70  3C03BF88   LUI V1, -16504
9D007E74  8C626020   LW V0, 24608(V1)
9D007E78  30420001   ANDI V0, V0, 1
9D007E7C  1440FFFD   BNE V0, ZERO, 0x9D007E74
9D007E80  3C02BF88   LUI V0, -16504
357:                 	TRISASET = KBD_DAT;  		// libère la ligne data
9D007E84  24030002   ADDIU V1, ZERO, 2
9D007E88  AC436018   SW V1, 24600(V0)
358:                 	while (!(PORTAbits.RA0)); // attend clock à 1
9D007E8C  3C03BF88   LUI V1, -16504
9D007E90  8C626020   LW V0, 24608(V1)
9D007E94  30420001   ANDI V0, V0, 1
9D007E98  1040FFFD   BEQ V0, ZERO, 0x9D007E90
9D007E9C  00000000   NOP
359:                 	while (PORTA & (KBD_DAT+KBD_CLK)); 	// attend que le clavier mette data et clock à 0
9D007EA0  3C03BF88   LUI V1, -16504
9D007EA4  8C626020   LW V0, 24608(V1)
9D007EA8  30420003   ANDI V0, V0, 3
9D007EAC  1440FFFD   BNE V0, ZERO, 0x9D007EA4
9D007EB0  3C04BF88   LUI A0, -16504
360:                 	while (!((PORTA & (KBD_DAT+KBD_CLK))==(KBD_DAT+KBD_CLK))); // attend que les 2 lignes reviennent à 1.
9D007EB4  24030003   ADDIU V1, ZERO, 3
9D007EB8  8C826020   LW V0, 24608(A0)
9D007EBC  30420003   ANDI V0, V0, 3
9D007EC0  1443FFFD   BNE V0, V1, 0x9D007EB8
9D007EC4  00000000   NOP
361:                 	bit_cnt=0;
9D007EC8  A380807F   SB ZERO, -32641(GP)
362:                         IFS0CLR=_IFS0_INT4IF_MASK;
9D007ECC  3C020080   LUI V0, 128
9D007ED0  3C03BF88   LUI V1, -16504
9D007ED4  AC621034   SW V0, 4148(V1)
363:                 	IEC0SET = _IEC0_INT4IE_MASK; // réactivation interruption
9D007ED8  3C03BF88   LUI V1, -16504
9D007EDC  AC621068   SW V0, 4200(V1)
364:                 } // KbdSend()
9D007EE0  03E00008   JR RA
9D007EE4  00000000   NOP
365:                 
366:                 int SetKbdLeds(unsigned char leds_state){ // contrôle l'état des LEDS du clavier
9D007EE8  27BDFFE0   ADDIU SP, SP, -32
9D007EEC  AFBF001C   SW RA, 28(SP)
9D007EF0  AFB20018   SW S2, 24(SP)
9D007EF4  AFB10014   SW S1, 20(SP)
9D007EF8  AFB00010   SW S0, 16(SP)
367:                     unsigned int t0;
368:                     short c;
369:                     t0=ticks()+100;
9D007EFC  0F403639   JAL ticks
9D007F00  309200FF   ANDI S2, A0, 255
9D007F04  24510064   ADDIU S1, V0, 100
370:                     KbdSend(KBD_LED);
9D007F08  0F401F49   JAL KbdSend
9D007F0C  2404FFED   ADDIU A0, ZERO, -19
371:                     c=0;
372:                     while (!(ticks()==t0) && !(rx_flags & F_ERROR) && !c){
9D007F10  0B401FC9   J 0x9D007F24
9D007F14  00008021   ADDU S0, ZERO, ZERO
9D007F24  0F403639   JAL ticks
9D007F28  00000000   NOP
9D007F2C  10510007   BEQ V0, S1, 0x9D007F4C
9D007F30  240200FA   ADDIU V0, ZERO, 250
9D007F34  9382807D   LBU V0, -32643(GP)
9D007F38  30420001   ANDI V0, V0, 1
9D007F3C  14400003   BNE V0, ZERO, 0x9D007F4C
9D007F40  240200FA   ADDIU V0, ZERO, 250
9D007F44  1200FFF4   BEQ S0, ZERO, 0x9D007F18
9D007F48  00000000   NOP
373:                         c=KbdScancode();
9D007F18  0F401FEF   JAL KbdScancode
9D007F1C  00000000   NOP
9D007F20  00408021   ADDU S0, V0, ZERO
374:                     }
375:                     if (c==KBD_ACK){
9D007F4C  16020015   BNE S0, V0, 0x9D007FA4
9D007F50  24020001   ADDIU V0, ZERO, 1
376:                         t0=ticks()+100;
9D007F54  0F403639   JAL ticks
9D007F58  00008021   ADDU S0, ZERO, ZERO
9D007F5C  24510064   ADDIU S1, V0, 100
377:                         KbdSend(leds_state);
9D007F60  0F401F49   JAL KbdSend
9D007F64  7C122420   SEB A0, S2
378:                         c=0;
379:                         while (!(ticks()==t0) && !(rx_flags & F_ERROR) && !c){
9D007F68  0B401FDF   J 0x9D007F7C
9D007F6C  00000000   NOP
9D007F7C  0F403639   JAL ticks
9D007F80  00000000   NOP
9D007F84  10510007   BEQ V0, S1, 0x9D007FA4
9D007F88  24020001   ADDIU V0, ZERO, 1
9D007F8C  9382807D   LBU V0, -32643(GP)
9D007F90  30420001   ANDI V0, V0, 1
9D007F94  14400003   BNE V0, ZERO, 0x9D007FA4
9D007F98  24020001   ADDIU V0, ZERO, 1
9D007F9C  1200FFF4   BEQ S0, ZERO, 0x9D007F70
9D007FA0  00000000   NOP
380:                             c=KbdScancode();
9D007F70  0F401FEF   JAL KbdScancode
9D007F74  00000000   NOP
9D007F78  00408021   ADDU S0, V0, ZERO
381:                         }
382:                     }
383:                     if (c=KBD_ACK)
384:                         return 1;
385:                     else
386:                         return 0;
387:                 } // SetKbdLeds()
9D007FA4  8FBF001C   LW RA, 28(SP)
9D007FA8  8FB20018   LW S2, 24(SP)
9D007FAC  8FB10014   LW S1, 20(SP)
9D007FB0  8FB00010   LW S0, 16(SP)
9D007FB4  03E00008   JR RA
9D007FB8  27BD0020   ADDIU SP, SP, 32
388:                 
389:                 void __ISR(_EXTERNAL_4_VECTOR,IPL6SOFT) kbd_clk_isr(void){
9D0086F0  415DE800   RDPGPR SP, SP
9D0086F4  401A7000   MFC0 K0, EPC
9D0086F8  401B6000   MFC0 K1, Status
9D0086FC  27BDFFE0   ADDIU SP, SP, -32
9D008700  AFBA001C   SW K0, 28(SP)
9D008704  401A6002   MFC0 K0, SRSCtl
9D008708  AFBB0018   SW K1, 24(SP)
9D00870C  AFBA0014   SW K0, 20(SP)
9D008710  7C1B7844   INS K1, ZERO, 1, 15
9D008714  377B1800   ORI K1, K1, 6144
9D008718  409B6000   MTC0 K1, Status
9D00871C  AFA4000C   SW A0, 12(SP)
9D008720  AFA30008   SW V1, 8(SP)
9D008724  AFA20004   SW V0, 4(SP)
390:                 	switch (bit_cnt){
9D008728  9382807F   LBU V0, -32641(GP)
9D00872C  304200FF   ANDI V0, V0, 255
9D008730  24030009   ADDIU V1, ZERO, 9
9D008734  10430010   BEQ V0, V1, 0x9D008778
9D008738  2403000A   ADDIU V1, ZERO, 10
9D00873C  10430028   BEQ V0, V1, 0x9D0087E0
9D008740  00000000   NOP
9D008744  1440003B   BNE V0, ZERO, 0x9D008834
9D008748  3C02BF88   LUI V0, -16504
391:                 	case 0:   // start bit
392:                 		if (!(PORTA & KBD_DAT)){
9D00874C  8C426020   LW V0, 24608(V0)
9D008750  30420002   ANDI V0, V0, 2
9D008754  5440004C   BNEL V0, ZERO, 0x9D008888
9D008758  3C030080   LUI V1, 128
393:                                     parity=0;
9D00875C  A3808080   SB ZERO, -32640(GP)
394:                                     bit_cnt++;
9D008760  9382807F   LBU V0, -32641(GP)
9D008764  24420001   ADDIU V0, V0, 1
9D008768  304200FF   ANDI V0, V0, 255
9D00876C  A382807F   SB V0, -32641(GP)
395:                                 }
396:                 		break;
397:                 	case 9:   // paritée
398:                 		if (PORTA & KBD_DAT)
9D008778  3C02BF88   LUI V0, -16504
9D00877C  8C426020   LW V0, 24608(V0)
9D008780  30420002   ANDI V0, V0, 2
9D008784  10400005   BEQ V0, ZERO, 0x9D00879C
9D008788  00000000   NOP
399:                 			parity++;
9D00878C  93828080   LBU V0, -32640(GP)
9D008790  24420001   ADDIU V0, V0, 1
9D008794  304200FF   ANDI V0, V0, 255
9D008798  A3828080   SB V0, -32640(GP)
400:                 		if (!(parity & 1)){
9D00879C  93828080   LBU V0, -32640(GP)
9D0087A0  30420001   ANDI V0, V0, 1
9D0087A4  14400008   BNE V0, ZERO, 0x9D0087C8
9D0087A8  00000000   NOP
401:                 			rx_flags |= F_ERROR;
9D0087AC  9382807D   LBU V0, -32643(GP)
9D0087B0  304200FF   ANDI V0, V0, 255
9D0087B4  34420001   ORI V0, V0, 1
9D0087B8  A382807D   SB V0, -32643(GP)
402:                                         IEC0CLR = _IEC0_INT4IE_MASK; // désactive l'interruption
9D0087BC  3C030080   LUI V1, 128
9D0087C0  3C02BF88   LUI V0, -16504
9D0087C4  AC431064   SW V1, 4196(V0)
403:                 		}
404:                 		bit_cnt++;
9D0087C8  9382807F   LBU V0, -32641(GP)
9D0087CC  24420001   ADDIU V0, V0, 1
9D0087D0  304200FF   ANDI V0, V0, 255
9D0087D4  A382807F   SB V0, -32641(GP)
405:                 		break;
9D0087D8  0B402222   J 0x9D008888
9D0087DC  3C030080   LUI V1, 128
406:                 	case 10:  // stop bit
407:                 		kbd_queue[tail]=in_byte;
9D0087E0  93848081   LBU A0, -32639(GP)
9D0087E4  308400FF   ANDI A0, A0, 255
9D0087E8  93838082   LBU V1, -32638(GP)
9D0087EC  3C02A000   LUI V0, -24576
9D0087F0  24422A24   ADDIU V0, V0, 10788
9D0087F4  00821021   ADDU V0, A0, V0
9D0087F8  A0430000   SB V1, 0(V0)
408:                 		tail++;
9D0087FC  93828081   LBU V0, -32639(GP)
9D008800  24420001   ADDIU V0, V0, 1
9D008804  304200FF   ANDI V0, V0, 255
9D008808  A3828081   SB V0, -32639(GP)
409:                 		tail &=31;
9D00880C  93828081   LBU V0, -32639(GP)
9D008810  3042001F   ANDI V0, V0, 31
9D008814  A3828081   SB V0, -32639(GP)
410:                 		bit_cnt=0;
9D008818  A380807F   SB ZERO, -32641(GP)
411:                 		rx_flags |= F_RCVD;
9D00881C  9382807D   LBU V0, -32643(GP)
9D008820  304200FF   ANDI V0, V0, 255
9D008824  34420002   ORI V0, V0, 2
9D008828  A382807D   SB V0, -32643(GP)
412:                 		break;
9D00882C  0B402222   J 0x9D008888
9D008830  3C030080   LUI V1, 128
413:                 	default:
414:                 		in_byte >>=1;
9D008834  93828082   LBU V0, -32638(GP)
9D008838  7C423040   EXT V0, V0, 1, 7
9D00883C  A3828082   SB V0, -32638(GP)
415:                 		if(PORTA & KBD_DAT){
9D008840  3C02BF88   LUI V0, -16504
9D008844  8C426020   LW V0, 24608(V0)
9D008848  30420002   ANDI V0, V0, 2
9D00884C  10400009   BEQ V0, ZERO, 0x9D008874
9D008850  00000000   NOP
416:                 			in_byte |=128;
9D008854  93828082   LBU V0, -32638(GP)
9D008858  3042007F   ANDI V0, V0, 127
9D00885C  34420080   ORI V0, V0, 128
9D008860  A3828082   SB V0, -32638(GP)
417:                 			parity++;
9D008864  93828080   LBU V0, -32640(GP)
9D008868  24420001   ADDIU V0, V0, 1
9D00886C  304200FF   ANDI V0, V0, 255
9D008870  A3828080   SB V0, -32640(GP)
418:                 		}
419:                 		bit_cnt++;
9D008874  9382807F   LBU V0, -32641(GP)
9D008878  24420001   ADDIU V0, V0, 1
9D00887C  304200FF   ANDI V0, V0, 255
9D008880  A382807F   SB V0, -32641(GP)
420:                 	}
421:                         mINT4ClearIntFlag();
9D008770  0B402222   J 0x9D008888
9D008774  3C030080   LUI V1, 128
9D008884  3C030080   LUI V1, 128
9D008888  3C02BF88   LUI V0, -16504
9D00888C  AC431034   SW V1, 4148(V0)
422:                 } // kbd_clk_isr()
9D008890  8FA4000C   LW A0, 12(SP)
9D008894  8FA30008   LW V1, 8(SP)
9D008898  8FA20004   LW V0, 4(SP)
9D00889C  41606000   DI ZERO
9D0088A0  000000C0   EHB
9D0088A4  8FBA001C   LW K0, 28(SP)
9D0088A8  8FBB0018   LW K1, 24(SP)
9D0088AC  409A7000   MTC0 K0, EPC
9D0088B0  8FBA0014   LW K0, 20(SP)
9D0088B4  27BD0020   ADDIU SP, SP, 32
9D0088B8  409A6002   MTC0 K0, SRSCtl
9D0088BC  41DDE800   WRPGPR SP, SP
9D0088C0  409B6000   MTC0 K1, Status
9D0088C4  42000018   ERET
423:                 
424:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/sdmmc.c  ------------------------------
1:                   /*
2:                   ** SDMMC.c SD card interface
3:                   **
4:                   ** 7/20/06 v1.4 LDJ
5:                   ** 7/14/07 v2.0 LDJ
6:                   **
7:                   [30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
8:                   ** 07 May 2012	Changes made to allow SD card library to support
9:                   **					PIC32 Pinguino and PIC32 Pinguino Micro that have neither
10:                  **					SD card presence nor WP switch detection switches.
11:                  **					see functions getCD() and getWP() below.
12:                  */
13:                  
14:                  #ifndef __SDMMC_C__
15:                  #define __SDMMC_C__
16:                  
17:                  //#include <system.c>
18:                  //#include <digitalw.c>
19:                  //#include <spi.c>        // in order to use default SPI port
20:                  #include <plib.h>
21:                  #include "sdmmc.h"
22:                  //#include "diskio.h"
23:                  //#include "ff.h"
24:                  
25:                  // send one byte of data and receive one back at the same time
26:                  unsigned char writeSPI(unsigned char b)
27:                  {
9D00C3F0  308400FF   ANDI A0, A0, 255
28:                  
29:                  	SPI2BUF = b;						
9D00C3F4  3C02BF80   LUI V0, -16512
9D00C3F8  AC445A20   SW A0, 23072(V0)
30:                  	while(!SPI2STATbits.SPIRBF);	// wait transfer complete
9D00C3FC  3C03BF80   LUI V1, -16512
9D00C400  8C625A10   LW V0, 23056(V1)
9D00C404  30420001   ANDI V0, V0, 1
9D00C408  1040FFFD   BEQ V0, ZERO, 0x9D00C400
9D00C40C  3C02BF80   LUI V0, -16512
31:                  	return SPI2BUF;					// read the received value
9D00C410  8C425A20   LW V0, 23072(V0)
32:                  
33:                  /*
34:                  	BUFFER = b;			            // write to buffer for TX
35:                  	while (!STATRX);		        // wait until cycle complete
36:                  	return BUFFER;			        // return with byte read
37:                   */
38:                  }	// writeSPI
9D00C414  03E00008   JR RA
9D00C418  304200FF   ANDI V0, V0, 255
39:                  
40:                  void initSD(void)
41:                  {
42:                  	PORTB |=SDCSEL; //digitalwrite(SDCSEL, HIGH);	// initially keep the SD card disabled
9D00C41C  3C02BF88   LUI V0, -16504
9D00C420  8C436120   LW V1, 24864(V0)
9D00C424  34630004   ORI V1, V1, 4
9D00C428  AC436120   SW V1, 24864(V0)
43:                  	TRISB &=~SDCSEL; //pinmode(SDCSEL, OUTPUT);		// make Card select an output pin
9D00C42C  3C02BF88   LUI V0, -16504
9D00C430  8C446110   LW A0, 24848(V0)
9D00C434  2403FFFB   ADDIU V1, ZERO, -5
9D00C438  00831824   AND V1, A0, V1
9D00C43C  AC436110   SW V1, 24848(V0)
44:                  
45:                  	// init the spi module for a slow (safe) clock speed first
46:                  
47:                  	SPI2CON = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
9D00C440  34038120   ORI V1, ZERO, -32480
9D00C444  3C02BF80   LUI V0, -16512
9D00C448  AC435A00   SW V1, 23040(V0)
48:                  	SPI2BRG = (mGetPeripheralClock() / (2 * 250000)) - 1;
9D00C44C  2403004A   ADDIU V1, ZERO, 74
9D00C450  3C02BF80   LUI V0, -16512
9D00C454  AC435A30   SW V1, 23088(V0)
49:                  
50:                  /*
51:                  	SPICONF = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
52:                  	CLKSPD  = (GetPeripheralClock() / (2 * 250000)) - 1;
53:                  */
54:                  }   // initSD
9D00C458  03E00008   JR RA
9D00C45C  00000000   NOP
55:                  
56:                  #define readSPI()   writeSPI(0xFF)
57:                  #define clockSPI()  writeSPI(0xFF)
58:                  
59:                  void disableSD(void)
60:                  {
9D00C460  27BDFFE8   ADDIU SP, SP, -24
9D00C464  AFBF0014   SW RA, 20(SP)
61:                  
62:                         PORTB |= SDCSEL; //digitalwrite(SDCSEL, HIGH);	// Deselected = SDCSEL high
9D00C468  3C02BF88   LUI V0, -16504
9D00C46C  8C436120   LW V1, 24864(V0)
9D00C470  34630004   ORI V1, V1, 4
9D00C474  AC436120   SW V1, 24864(V0)
63:                         clockSPI();
9D00C478  0F4030FC   JAL writeSPI
9D00C47C  240400FF   ADDIU A0, ZERO, 255
64:                  }
9D00C480  8FBF0014   LW RA, 20(SP)
9D00C484  03E00008   JR RA
9D00C488  27BD0018   ADDIU SP, SP, 24
65:                  
66:                  void enableSD(void)
67:                  {
68:                  	PORTB &= ~ SDCSEL; //digitalwrite(SDCSEL, LOW);	// Selected = SDCSEL low
9D00C48C  3C02BF88   LUI V0, -16504
9D00C490  8C446120   LW A0, 24864(V0)
9D00C494  2403FFFB   ADDIU V1, ZERO, -5
9D00C498  00831824   AND V1, A0, V1
9D00C49C  AC436120   SW V1, 24864(V0)
69:                  }
9D00C4A0  03E00008   JR RA
9D00C4A4  00000000   NOP
70:                  
71:                  // c    command code
72:                  // a    byte address of data block
73:                  int sendSDCmd(unsigned char c, unsigned a)
74:                  {
9D00C4A8  27BDFFE0   ADDIU SP, SP, -32
9D00C4AC  AFBF001C   SW RA, 28(SP)
9D00C4B0  AFB10018   SW S1, 24(SP)
9D00C4B4  AFB00014   SW S0, 20(SP)
9D00C4B8  00A08821   ADDU S1, A1, ZERO
75:                  	int i, r;
76:                  
77:                  	// enable SD card
78:                  	// CS low
79:                  	enableSD();
9D00C4BC  0F403123   JAL enableSD
9D00C4C0  309000FF   ANDI S0, A0, 255
80:                  
81:                  	// send a comand packet (6 bytes)
82:                  	writeSPI(c | 0x40);    // send command
9D00C4C4  0F4030FC   JAL writeSPI
9D00C4C8  36040040   ORI A0, S0, 64
83:                  	writeSPI(a>>24);       // msb of the address
9D00C4CC  0F4030FC   JAL writeSPI
9D00C4D0  00112602   SRL A0, S1, 24
84:                  	writeSPI(a>>16);
9D00C4D4  0F4030FC   JAL writeSPI
9D00C4D8  7E243C00   EXT A0, S1, 16, 8
85:                  	writeSPI(a>>8);
9D00C4DC  0F4030FC   JAL writeSPI
9D00C4E0  7E243A00   EXT A0, S1, 8, 8
86:                  	writeSPI(a);           // lsb
9D00C4E4  0F4030FC   JAL writeSPI
9D00C4E8  322400FF   ANDI A0, S1, 255
87:                  
88:                  	writeSPI(0x95);        // send CMD0 CRC
9D00C4EC  0F4030FC   JAL writeSPI
9D00C4F0  24040095   ADDIU A0, ZERO, 149
9D00C4F4  24100008   ADDIU S0, ZERO, 8
89:                  
90:                  	// now wait for a response, allow for up to 8 bytes delay
91:                  	for(i=0; i<8; i++)
9D00C50C  1600FFFA   BNE S0, ZERO, 0x9D00C4F8
9D00C510  00000000   NOP
92:                  	{
93:                  		r = readSPI();
9D00C4F8  0F4030FC   JAL writeSPI
9D00C4FC  240400FF   ADDIU A0, ZERO, 255
94:                  		if (r != 0xFF)
9D00C500  240300FF   ADDIU V1, ZERO, 255
9D00C504  14430003   BNE V0, V1, 0x9D00C514
9D00C508  2610FFFF   ADDIU S0, S0, -1
95:                  			break;
96:                  	}
97:                  	return (r);
98:                  
99:                  	/* return response
100:                 	FF - timeout
101:                 	00 - command accepted
102:                 	01 - command received, card in idle state after RESET
103:                 
104:                 	other codes:
105:                 	bit 0 = Idle state
106:                 	bit 1 = Erase Reset
107:                 	bit 2 = Illegal command
108:                 	bit 3 = Communication CRC error
109:                 	bit 4 = Erase sequence error
110:                 	bit 5 = Address error
111:                 	bit 6 = Parameter error
112:                 	bit 7 = Always 0
113:                 	*/
114:                 	// NOTE CSCD is still low!
115:                 } // sendSDCmd
9D00C514  8FBF001C   LW RA, 28(SP)
9D00C518  8FB10018   LW S1, 24(SP)
9D00C51C  8FB00014   LW S0, 20(SP)
9D00C520  03E00008   JR RA
9D00C524  27BD0020   ADDIU SP, SP, 32
116:                 
117:                 
118:                 // returns 0 if successful
119:                 //          E_COMMAND_ACK   failed to acknowledge reset command
120:                 //          E_INIT_TIMEOUT  failed to initialize
121:                 int initMedia(void)
122:                 {
9D00C528  27BDFFE0   ADDIU SP, SP, -32
9D00C52C  AFBF001C   SW RA, 28(SP)
9D00C530  AFB10018   SW S1, 24(SP)
123:                 	int i, r;
124:                 
125:                 	// 1. with the card NOT selected
126:                 	// Set DI and CS high
127:                 	disableSD();
9D00C534  0F403118   JAL disableSD
9D00C538  AFB00014   SW S0, 20(SP)
128:                 
129:                 	// 2. send 74 or more clock cycles to start up
130:                 	// apply 74 or more clock pulses to SCLK.
131:                 	// The card will enter its native operating mode and go ready to accept native commands.
132:                 	for (i=0; i<10; i++)
9D00C53C  00008021   ADDU S0, ZERO, ZERO
9D00C540  2411000A   ADDIU S1, ZERO, 10
9D00C54C  26100001   ADDIU S0, S0, 1
9D00C550  1611FFFC   BNE S0, S1, 0x9D00C544
9D00C554  00000000   NOP
133:                 		clockSPI();
9D00C544  0F4030FC   JAL writeSPI
9D00C548  240400FF   ADDIU A0, ZERO, 255
134:                 
135:                 	// 3. now select the card
136:                 	enableSD();
9D00C558  0F403123   JAL enableSD
9D00C55C  00000000   NOP
137:                 
138:                 	//card detection is now in disk_initialize()
139:                 
140:                 	return 0;
141:                 } // init media
9D00C560  00001021   ADDU V0, ZERO, ZERO
9D00C564  8FBF001C   LW RA, 28(SP)
9D00C568  8FB10018   LW S1, 24(SP)
9D00C56C  8FB00014   LW S0, 20(SP)
9D00C570  03E00008   JR RA
9D00C574  27BD0020   ADDIU SP, SP, 32
142:                 
143:                 
144:                 // a        LBA of sector requested
145:                 // p        pointer to sector buffer
146:                 // returns  TRUE if successful
147:                 int readSECTOR(LBA a, char *p)
148:                 {
9D00C578  27BDFFD8   ADDIU SP, SP, -40
9D00C57C  AFBF0024   SW RA, 36(SP)
9D00C580  AFB40020   SW S4, 32(SP)
9D00C584  AFB3001C   SW S3, 28(SP)
9D00C588  AFB20018   SW S2, 24(SP)
9D00C58C  AFB10014   SW S1, 20(SP)
9D00C590  AFB00010   SW S0, 16(SP)
9D00C594  00A08821   ADDU S1, A1, ZERO
149:                 	int r, i;
150:                 
151:                 	#ifdef READ_LED
152:                         _read_off();
9D00C598  3C02BF88   LUI V0, -16504
9D00C59C  8C456120   LW A1, 24864(V0)
9D00C5A0  2403FFF7   ADDIU V1, ZERO, -9
9D00C5A4  00A31824   AND V1, A1, V1
9D00C5A8  AC436120   SW V1, 24864(V0)
153:                 	//digitalwrite(READ_LED, 0);
154:                 	#endif
155:                 
156:                 	// 1. send READ command
157:                 	r = sendSDCmd(READ_SINGLE, (a << 9));
9D00C5AC  00042A40   SLL A1, A0, 9
9D00C5B0  0F40312A   JAL sendSDCmd
9D00C5B4  24040011   ADDIU A0, ZERO, 17
158:                 	if (r == 0)    // check if command was accepted
9D00C5B8  1440001A   BNE V0, ZERO, 0x9D00C624
9D00C5BC  00409021   ADDU S2, V0, ZERO
9D00C5C0  00008021   ADDU S0, ZERO, ZERO
159:                 	{
160:                 	// 2. wait for a response
161:                 	for(i=0; i<R_TIMEOUT; i++)
9D00C5C8  241461A8   ADDIU S4, ZERO, 25000
9D00C5DC  26100001   ADDIU S0, S0, 1
9D00C5E0  1614FFFA   BNE S0, S4, 0x9D00C5CC
9D00C5E4  00000000   NOP
9D00C5E8  0B403189   J 0x9D00C624
9D00C5EC  00000000   NOP
162:                 	{
163:                 	r = readSPI();
9D00C5CC  0F4030FC   JAL writeSPI
9D00C5D0  240400FF   ADDIU A0, ZERO, 255
164:                 	if (r == DATA_START)
9D00C5C4  241300FE   ADDIU S3, ZERO, 254
9D00C5D4  10530006   BEQ V0, S3, 0x9D00C5F0
9D00C5D8  00409021   ADDU S2, V0, ZERO
165:                 	break;
166:                 	}
167:                 
168:                 	// 3. if it did not timeout, read 512 byte of data
169:                 	if (i != R_TIMEOUT)
9D00C5F0  240261A8   ADDIU V0, ZERO, 25000
9D00C5F4  1202000B   BEQ S0, V0, 0x9D00C624
9D00C5F8  26300200   ADDIU S0, S1, 512
170:                 	{
171:                 		i = 512;
172:                 		do{
173:                 			*p++ = readSPI();
9D00C5FC  0F4030FC   JAL writeSPI
9D00C600  240400FF   ADDIU A0, ZERO, 255
9D00C604  A2220000   SB V0, 0(S1)
9D00C608  26310001   ADDIU S1, S1, 1
174:                 		} while (--i>0);
9D00C60C  1630FFFB   BNE S1, S0, 0x9D00C5FC
9D00C610  00000000   NOP
175:                 
176:                 		// 4. ignore CRC
177:                 		readSPI();
9D00C614  0F4030FC   JAL writeSPI
9D00C618  240400FF   ADDIU A0, ZERO, 255
178:                 		readSPI();
9D00C61C  0F4030FC   JAL writeSPI
9D00C620  240400FF   ADDIU A0, ZERO, 255
179:                 
180:                 	} // data arrived
181:                 
182:                 	} // command accepted
183:                 
184:                 	// 5. remember to disable the card
185:                 	disableSD();
9D00C624  0F403118   JAL disableSD
9D00C628  00000000   NOP
186:                 
187:                 	#ifdef READ_LED
188:                         _read_on();
9D00C62C  3C02BF88   LUI V0, -16504
9D00C630  8C436120   LW V1, 24864(V0)
9D00C634  34630008   ORI V1, V1, 8
9D00C638  AC436120   SW V1, 24864(V0)
189:                 	//digital(READ_LED, 1);
190:                 	#endif
191:                 
192:                 	return (r == DATA_START);    // return TRUE if successful
9D00C63C  3A4200FE   XORI V0, S2, 254
193:                 } // readSECTOR
9D00C640  2C420001   SLTIU V0, V0, 1
9D00C644  8FBF0024   LW RA, 36(SP)
9D00C648  8FB40020   LW S4, 32(SP)
9D00C64C  8FB3001C   LW S3, 28(SP)
9D00C650  8FB20018   LW S2, 24(SP)
9D00C654  8FB10014   LW S1, 20(SP)
9D00C658  8FB00010   LW S0, 16(SP)
9D00C65C  03E00008   JR RA
9D00C660  27BD0028   ADDIU SP, SP, 40
194:                 
195:                 
196:                 // a        LBA of sector requested
197:                 // p        pointer to sector buffer
198:                 // returns  TRUE if successful
199:                 int writeSECTOR(LBA a, char *p)
9D00C698  26110200   ADDIU S1, S0, 512
200:                 {
9D00C664  27BDFFE0   ADDIU SP, SP, -32
9D00C668  AFBF001C   SW RA, 28(SP)
9D00C66C  AFB20018   SW S2, 24(SP)
9D00C670  AFB10014   SW S1, 20(SP)
9D00C674  AFB00010   SW S0, 16(SP)
9D00C678  00A08021   ADDU S0, A1, ZERO
201:                 	unsigned r, i;
202:                 
203:                 	// 0. check Write Protect
204:                 //	if (getWP())
205:                 //		return FAIL;
206:                 
207:                 	// 1. send WRITE command
208:                 	r = sendSDCmd(WRITE_SINGLE, (a << 9));
9D00C67C  00042A40   SLL A1, A0, 9
9D00C680  0F40312A   JAL sendSDCmd
9D00C684  24040018   ADDIU A0, ZERO, 24
209:                 	if (r == 0)    // check if command was accepted
9D00C688  14400025   BNE V0, ZERO, 0x9D00C720
9D00C68C  00409021   ADDU S2, V0, ZERO
210:                 	{
211:                 		// 2. send data
212:                 		writeSPI(DATA_START);
9D00C690  0F4030FC   JAL writeSPI
9D00C694  240400FE   ADDIU A0, ZERO, 254
213:                 
214:                 		// send 512 bytes of data
215:                 		for(i=0; i<512; i++)
9D00C6A8  5611FFFD   BNEL S0, S1, 0x9D00C6A0
9D00C6AC  92040000   LBU A0, 0(S0)
216:                 		writeSPI(*p++);
9D00C69C  92040000   LBU A0, 0(S0)
9D00C6A0  0F4030FC   JAL writeSPI
9D00C6A4  26100001   ADDIU S0, S0, 1
217:                 
218:                 		// 3. send dummy CRC
219:                 		clockSPI();
9D00C6B0  0F4030FC   JAL writeSPI
9D00C6B4  240400FF   ADDIU A0, ZERO, 255
220:                 		clockSPI();
9D00C6B8  0F4030FC   JAL writeSPI
9D00C6BC  240400FF   ADDIU A0, ZERO, 255
221:                 
222:                 		// 4. check if data accepted
223:                 		r = readSPI();
9D00C6C0  0F4030FC   JAL writeSPI
9D00C6C4  240400FF   ADDIU A0, ZERO, 255
224:                 		if ((r & 0xf) == DATA_ACCEPT)
9D00C6C8  3042000F   ANDI V0, V0, 15
9D00C6CC  24030005   ADDIU V1, ZERO, 5
9D00C6D0  14430013   BNE V0, V1, 0x9D00C720
9D00C6D4  3C02BF88   LUI V0, -16504
225:                 		{
226:                 			#ifdef WRITE_LED
227:                                         _write_off();
9D00C6D8  8C446120   LW A0, 24864(V0)
9D00C6DC  2403FFF7   ADDIU V1, ZERO, -9
9D00C6E0  00831824   AND V1, A0, V1
9D00C6E4  AC436120   SW V1, 24864(V0)
228:                 			//digitalwrite(WRITE_LED, 0);
229:                 			#endif
230:                 
231:                 			// 5. wait for write completion
232:                 			for(i=0; i<W_TIMEOUT; i++)
9D00C6E8  00008021   ADDU S0, ZERO, ZERO
9D00C6EC  3C110003   LUI S1, 3
9D00C6F0  3631D090   ORI S1, S1, -12144
9D00C704  26100001   ADDIU S0, S0, 1
9D00C708  1611FFFA   BNE S0, S1, 0x9D00C6F4
9D00C70C  00000000   NOP
233:                 			{
234:                 				r = readSPI();
9D00C6F4  0F4030FC   JAL writeSPI
9D00C6F8  240400FF   ADDIU A0, ZERO, 255
235:                 				if (r != 0 )
9D00C6FC  14400004   BNE V0, ZERO, 0x9D00C710
9D00C700  00409021   ADDU S2, V0, ZERO
236:                 					break;
237:                 			}
238:                 			#ifdef WRITE_LED
239:                                         _write_on();
9D00C710  3C02BF88   LUI V0, -16504
9D00C714  8C436120   LW V1, 24864(V0)
9D00C718  34630008   ORI V1, V1, 8
9D00C71C  AC436120   SW V1, 24864(V0)
240:                 			//digitalwrite(WRITE_LED, 1);
241:                 			#endif
242:                 		} // accepted
243:                 		else
244:                 		{
245:                 			r = FAIL;
246:                 		}
247:                 	} // command accepted
248:                 
249:                 	// 6. disable the card
250:                 	disableSD();
9D00C720  0F403118   JAL disableSD
9D00C724  00000000   NOP
251:                 
252:                 	return (r);      // return TRUE if successful
253:                 } // writeSECTOR
9D00C728  02401021   ADDU V0, S2, ZERO
9D00C72C  8FBF001C   LW RA, 28(SP)
9D00C730  8FB20018   LW S2, 24(SP)
9D00C734  8FB10014   LW S1, 20(SP)
9D00C738  8FB00010   LW S0, 16(SP)
9D00C73C  03E00008   JR RA
9D00C740  27BD0020   ADDIU SP, SP, 32
254:                 
255:                 
256:                 // SD card connector presence detection switch
257:                 // returns  TRUE card present
258:                 //          FALSE card not present
259:                 int getCD(void)
260:                 {
261:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
262:                 // 2013-09-05 ** added support for VPC_32
263:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined (EMPEROR460) || defined(VPC_32)
264:                 	return TRUE;
265:                 #else
266:                 	return (SDCD);
267:                 #endif
268:                 }
9D00C744  03E00008   JR RA
9D00C748  24020001   ADDIU V0, ZERO, 1
269:                 
270:                 // card Write Protect tab detection switch
271:                 // returns  TRUE write protect tab on LOCK
272:                 //          FALSE write protection tab OPEN
273:                 int getWP(void)
274:                 {
275:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
276:                 // 2013-09-05 ** added support for VPC_32
277:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined(EMPEROR460) || defined (VPC_32)
278:                 	return FALSE;
279:                 #else
280:                 	return (SDWP);
281:                 #endif
282:                 }
9D00C74C  03E00008   JR RA
9D00C750  00001021   ADDU V0, ZERO, ZERO
283:                 
284:                 #endif /* __SDMMC_C__ */
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/fileio.c  -----------------------------
1:                   /*	----------------------------------------------------------------------------
2:                   	FILE:			fileio.c
3:                   	PROJECT:		pinguino32
4:                   	PURPOSE:		SD Card file system functions
5:                   	AUTHORS:		Alfred Broda <alfredbroda@gmail.com>
6:                   					Mark Harper <markfh@f2s.com>
7:                   					Regis Blanchot <rblanchot@gmail.com>
8:                   	FIRST RELEASE:	23 dec. 2011
9:                   	LAST RELEASE:	06 jan. 2012
10:                  	----------------------------------------------------------------------------
11:                  	based on original code by Regis Blanchot and FatFS example for PIC24
12:                  	----------------------------------------------------------------------------
13:                   	[30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
14:                  	07 May 2012	As part of providing support for PIC32 Pinguino Micro and
15:                  					potentially other cards removed #if defined (PIC32_Pinguino) etc
16:                  					and #endif in function mount() so that SDCS is set via mount 
17:                  					for all cards.
18:                  */
19:                  
20:                  #ifndef __FILEIO_C__
21:                  #define __FILEIO_C__
22:                  
23:                  // standard C libraries used
24:                  #include <ctype.h>      		// toupper...
25:                  #include <string.h>     		// memcpy...
26:                  //#include <malloc.h>				// malloc, free?
27:                  #include <GenericTypeDefs.h>
28:                  
29:                  #include "fileio.h"
30:                  #include "sdmmc.h"
31:                  #include "ff.h"					// Fat Filesystem
32:                  #include "diskio.h"				// card access functions
33:                  #include "../serial_comm.h"
34:                  
35:                  //#define SD_DEBUG
36:                  
37:                  //#ifdef SD_DEBUG
38:                  //    #include <__cdc.c>          // USB CDC functions
39:                  //#endif
40:                  
41:                  /*	----------------------------------------------------------------------------
42:                   mount
43:                   initializes a MEDIA structure for FILEIO access
44:                   will mount only the first partition on the disk/card
45:                   --------------------------------------------------------------------------*/
46:                  
47:                  static FATFS _Fat;
48:                  
49:                  char mount(unsigned char pin) {
9D00D474  27BDFFE0   ADDIU SP, SP, -32
9D00D478  AFBF001C   SW RA, 28(SP)
50:                  	int flag, i;
51:                  	FRESULT r;
52:                  
53:                  	SDCS = pin;
54:                  
55:                  	// 0. init the I/Os
56:                  	initSD();
9D00D47C  0F403107   JAL initSD
9D00D480  A3848114   SB A0, -32492(GP)
57:                  
58:                  #ifdef SD_DEBUG
59:                  	UartPrint(STDOUT,"Looking for SD slot... ");
9D00D484  24040001   ADDIU A0, ZERO, 1
9D00D488  3C059D01   LUI A1, -25343
9D00D48C  0F40330F   JAL UartPrint
9D00D490  24A5F6B8   ADDIU A1, A1, -2376
60:                  #endif
61:                  	// 1. check if the card is in the slot
62:                  	if (!getCD()) {
9D00D494  0F4031D1   JAL getCD
9D00D498  00000000   NOP
9D00D49C  14400008   BNE V0, ZERO, 0x9D00D4C0
9D00D4A0  24040001   ADDIU A0, ZERO, 1
63:                  		FError = FE_NOT_PRESENT;
9D00D4A4  24020002   ADDIU V0, ZERO, 2
9D00D4A8  A3828108   SB V0, -32504(GP)
64:                  #ifdef SD_DEBUG
65:                  		UartPrint(STDOUT, "Failed!\r");
9D00D4AC  3C059D01   LUI A1, -25343
9D00D4B0  0F40330F   JAL UartPrint
9D00D4B4  24A5F6D0   ADDIU A1, A1, -2352
66:                  #endif
67:                  		return FALSE;
9D00D4B8  0B403574   J 0x9D00D5D0
9D00D4BC  00001021   ADDU V0, ZERO, ZERO
68:                  	}
69:                  #ifdef SD_DEBUG
70:                  	UartPrint(STDOUT,"OK\r");
9D00D4C0  3C059D01   LUI A1, -25343
9D00D4C4  0F40330F   JAL UartPrint
9D00D4C8  24A5F6DC   ADDIU A1, A1, -2340
71:                  #endif
72:                  
73:                  	// 2. initialize the card
74:                  #ifdef SD_DEBUG
75:                  	UartPrint(STDOUT,"Initializing SD card... ");
9D00D4CC  24040001   ADDIU A0, ZERO, 1
9D00D4D0  3C059D01   LUI A1, -25343
9D00D4D4  0F40330F   JAL UartPrint
9D00D4D8  24A5F6E0   ADDIU A1, A1, -2336
76:                  #endif
77:                  	initMedia();
9D00D4DC  0F40314A   JAL initMedia
9D00D4E0  00000000   NOP
78:                          if (disk_initialize(0)==STA_NOINIT){
9D00D4E4  0F402309   JAL disk_initialize
9D00D4E8  00002021   ADDU A0, ZERO, ZERO
9D00D4EC  24030001   ADDIU V1, ZERO, 1
9D00D4F0  14430006   BNE V0, V1, 0x9D00D50C
9D00D4F4  24040001   ADDIU A0, ZERO, 1
79:                  #ifdef SD_DEBUG
80:                              UartPrint(STDOUT,"failed!\r");
9D00D4F8  3C059D01   LUI A1, -25343
9D00D4FC  0F40330F   JAL UartPrint
9D00D500  24A5F6FC   ADDIU A1, A1, -2308
81:                  #endif
82:                              return 0;
9D00D504  0B403574   J 0x9D00D5D0
9D00D508  00001021   ADDU V0, ZERO, ZERO
83:                          };
84:                  #ifdef SD_DEBUG
85:                          UartPrint(STDOUT,"OK\r");
9D00D50C  3C059D01   LUI A1, -25343
9D00D510  0F40330F   JAL UartPrint
9D00D514  24A5F6DC   ADDIU A1, A1, -2340
86:                  #endif
87:                  	// We're skipping the old step 3 because there's no need for malloc
88:                  	// This takes 6k off the code size if malloc is not used elsewhere.
89:                  	// Instead, just point it to our _Fat var.
90:                  	// The FATFS struct takes only 560 bytes of mem.
91:                  	Fat = &_Fat;
9D00D518  3C02A000   LUI V0, -24576
9D00D51C  24422778   ADDIU V0, V0, 10104
9D00D520  AF82810C   SW V0, -32500(GP)
92:                  
93:                  	// Mount media
94:                  #ifdef SD_DEBUG
95:                  	UartPrint(STDOUT,"Mounting FAT filesystem... ");
9D00D524  24040001   ADDIU A0, ZERO, 1
9D00D528  3C059D01   LUI A1, -25343
9D00D52C  0F40330F   JAL UartPrint
9D00D530  24A5F708   ADDIU A1, A1, -2296
96:                  #endif
97:                  	r = f_mount(0, Fat);
9D00D534  00002021   ADDU A0, ZERO, ZERO
9D00D538  0F401425   JAL f_mount
9D00D53C  8F85810C   LW A1, -32500(GP)
98:                  	if (r != FR_OK) {
9D00D540  10400007   BEQ V0, ZERO, 0x9D00D560
9D00D544  24040001   ADDIU A0, ZERO, 1
99:                  		FError = r;
9D00D548  A3828108   SB V0, -32504(GP)
100:                 #ifdef SD_DEBUG
101:                 		UartPrint(STDOUT,"Failed!\r");
9D00D54C  3C059D01   LUI A1, -25343
9D00D550  0F40330F   JAL UartPrint
9D00D554  24A5F6D0   ADDIU A1, A1, -2352
102:                 #endif
103:                 		//free(Fat);
104:                 		return FALSE;
9D00D558  0B403574   J 0x9D00D5D0
9D00D55C  00001021   ADDU V0, ZERO, ZERO
105:                 	}
106:                 #ifdef SD_DEBUG
107:                 	UartPrint(STDOUT, "OK\r");
9D00D560  3C059D01   LUI A1, -25343
9D00D564  0F40330F   JAL UartPrint
9D00D568  24A5F6DC   ADDIU A1, A1, -2340
108:                 #endif
109:                 
110:                 #ifdef SD_DEBUG
111:                 	UartPrint(STDOUT,"Checking FAT filesystem... ");
9D00D56C  24040001   ADDIU A0, ZERO, 1
9D00D570  3C059D01   LUI A1, -25343
9D00D574  0F40330F   JAL UartPrint
9D00D578  24A5F724   ADDIU A1, A1, -2268
112:                 #endif
113:                 	const TCHAR * pth = "/";
9D00D57C  3C029D01   LUI V0, -25343
9D00D580  2442F740   ADDIU V0, V0, -2240
9D00D584  AFA20010   SW V0, 16(SP)
114:                 	r = chk_mounted(&pth, &Fat, 0);
9D00D588  27A40010   ADDIU A0, SP, 16
9D00D58C  2785810C   ADDIU A1, GP, -32500
9D00D590  0F4012F3   JAL chk_mounted
9D00D594  00003021   ADDU A2, ZERO, ZERO
115:                 	if (r != FR_OK) {
9D00D598  10400009   BEQ V0, ZERO, 0x9D00D5C0
9D00D59C  24040001   ADDIU A0, ZERO, 1
116:                 		FError = r;
9D00D5A0  A3828108   SB V0, -32504(GP)
117:                 #ifdef SD_DEBUG
118:                 		UartPrint(STDOUT, "Failed!\r");
9D00D5A4  3C059D01   LUI A1, -25343
9D00D5A8  0F40330F   JAL UartPrint
9D00D5AC  24A5F6D0   ADDIU A1, A1, -2352
119:                                  //put_rc(r);
120:                 #endif
121:                 		unmount();
9D00D5B0  0F403512   JAL unmount
9D00D5B4  00000000   NOP
122:                 		return FALSE;
9D00D5B8  0B403574   J 0x9D00D5D0
9D00D5BC  00001021   ADDU V0, ZERO, ZERO
123:                 	}
124:                 #ifdef SD_DEBUG
125:                 	UartPrint(STDOUT, "OK\r");
9D00D5C0  3C059D01   LUI A1, -25343
9D00D5C4  0F40330F   JAL UartPrint
9D00D5C8  24A5F6DC   ADDIU A1, A1, -2340
126:                 #endif
127:                 
128:                 	return TRUE;
9D00D5CC  24020001   ADDIU V0, ZERO, 1
129:                 } // mount
9D00D5D0  8FBF001C   LW RA, 28(SP)
9D00D5D4  03E00008   JR RA
9D00D5D8  27BD0020   ADDIU SP, SP, 32
130:                 
131:                 /*	----------------------------------------------------------------------------
132:                  unmount    initializes a MEDIA structure for FILEIO access
133:                  --------------------------------------------------------------------------*/
134:                 
135:                 void unmount(void) {
9D00D448  27BDFFE8   ADDIU SP, SP, -24
9D00D44C  AFBF0014   SW RA, 20(SP)
136:                 	f_mount(0, NULL);
9D00D450  00002021   ADDU A0, ZERO, ZERO
9D00D454  0F401425   JAL f_mount
9D00D458  00002821   ADDU A1, ZERO, ZERO
137:                 	//free(Fat);
138:                 	SPI2CONCLR = 0x8000; // SPI2 OFF
9D00D45C  34038000   ORI V1, ZERO, -32768
9D00D460  3C02BF80   LUI V0, -16512
9D00D464  AC435A04   SW V1, 23044(V0)
139:                 } // unmount
9D00D468  8FBF0014   LW RA, 20(SP)
9D00D46C  03E00008   JR RA
9D00D470  27BD0018   ADDIU SP, SP, 24
140:                 
141:                 /*	----------------------------------------------------------------------------
142:                  present   test if a SD card is present
143:                  --------------------------------------------------------------------------*/
144:                 
145:                 char SD_present(unsigned char pin) {
9D00D5DC  27BDFFE8   ADDIU SP, SP, -24
9D00D5E0  AFBF0014   SW RA, 20(SP)
146:                 	if (mount(pin)) {
9D00D5E4  0F40351D   JAL mount
9D00D5E8  308400FF   ANDI A0, A0, 255
9D00D5EC  10400004   BEQ V0, ZERO, 0x9D00D600
9D00D5F0  00001821   ADDU V1, ZERO, ZERO
147:                 		unmount();
9D00D5F4  0F403512   JAL unmount
9D00D5F8  00000000   NOP
148:                 		return TRUE;
9D00D5FC  24030001   ADDIU V1, ZERO, 1
149:                 	} else {
150:                 		return FALSE;
151:                 	}
152:                 }
9D00D600  00601021   ADDU V0, V1, ZERO
9D00D604  8FBF0014   LW RA, 20(SP)
9D00D608  03E00008   JR RA
9D00D60C  27BD0018   ADDIU SP, SP, 24
153:                 
154:                 /*	----------------------------------------------------------------------------
155:                  Scans the current disk and compiles a list of files with a given extension
156:                  list     array of file names max * 8
157:                  max      number of entries
158:                  ext      file extension we are searching for
159:                  return   number of files found
160:                  --------------------------------------------------------------------------*/
161:                 
162:                 //unsigned listTYPE(char *listname, long *listsize, int max, const char *ext )
163:                 unsigned listTYPE(DIRTABLE *list, int max, const char *ext)
164:                 //unsigned listTYPE(char *list, int max, const char *ext )
165:                 {
166:                 	//TODO: implement
167:                 
168:                 	return 0;
169:                 } // listTYPE
9D00D610  03E00008   JR RA
9D00D614  00001021   ADDU V0, ZERO, ZERO
170:                 
171:                 /* Prints the directory contents */
172:                 unsigned listDir(const char *path) {
9D00D618  27BDFFC0   ADDIU SP, SP, -64
9D00D61C  AFBF003C   SW RA, 60(SP)
9D00D620  AFB10038   SW S1, 56(SP)
9D00D624  AFB00034   SW S0, 52(SP)
9D00D628  00808021   ADDU S0, A0, ZERO
173:                 	//TODO: remove all CDC references
174:                 	long p1;
175:                 	PF_BYTE res, b;
176:                 	UINT s1, s2;
177:                 	DIR dir; /* Directory object */
178:                 
179:                 	res = f_opendir(&dir, "/");
9D00D62C  27A40010   ADDIU A0, SP, 16
9D00D630  3C059D01   LUI A1, -25343
9D00D634  0F4017A3   JAL f_opendir
9D00D638  24A5F740   ADDIU A1, A1, -2240
180:                 #ifdef SD_DEBUG
181:                 	UartPrint(STDOUT,"f_opendir? ");
9D00D63C  24040001   ADDIU A0, ZERO, 1
9D00D640  3C059D01   LUI A1, -25343
9D00D644  0F40330F   JAL UartPrint
9D00D648  24A5F744   ADDIU A1, A1, -2236
182:                 	//put_rc(res);
183:                 #endif
184:                 	p1 = s1 = s2 = 0;
9D00D66C  00008821   ADDU S1, ZERO, ZERO
185:                 	//CDCprintln("\nf_readdir('%s'): ", path);
186:                         print("\rnf_readdir('");
9D00D64C  3C049D01   LUI A0, -25343
9D00D650  0F402624   JAL print
9D00D654  2484F750   ADDIU A0, A0, -2224
187:                         print(path);
9D00D658  0F402624   JAL print
9D00D65C  02002021   ADDU A0, S0, ZERO
188:                         print("'):");
9D00D660  3C049D01   LUI A0, -25343
9D00D664  0F402624   JAL print
9D00D668  2484F760   ADDIU A0, A0, -2208
189:                 	for (;;) {
190:                 		res = f_readdir(&dir, &Finfo);
9D00D670  3C10A000   LUI S0, -24576
9D00D674  26102760   ADDIU S0, S0, 10080
9D00D678  27A40010   ADDIU A0, SP, 16
9D00D67C  0F4017D4   JAL f_readdir
9D00D680  02002821   ADDU A1, S0, ZERO
191:                 #ifdef SD_DEBUG
192:                 //		put_rc(res);
193:                 #endif
194:                 		if ((res != FR_OK) || !Finfo.fname[0]) {
9D00D684  304200FF   ANDI V0, V0, 255
9D00D688  14400009   BNE V0, ZERO, 0x9D00D6B0
9D00D68C  02201021   ADDU V0, S1, ZERO
9D00D690  82020009   LB V0, 9(S0)
9D00D694  10400006   BEQ V0, ZERO, 0x9D00D6B0
9D00D698  02201021   ADDU V0, S1, ZERO
195:                 			break;
196:                 		}
197:                 
198:                 		if (Finfo.fattrib & AM_DIR) {
9D00D69C  92020008   LBU V0, 8(S0)
9D00D6A0  30420010   ANDI V0, V0, 16
199:                 			s2++;
200:                 		} else {
201:                 			s1++;
9D00D6A4  2C420001   SLTIU V0, V0, 1
9D00D6A8  0B40359E   J 0x9D00D678
9D00D6AC  02228821   ADDU S1, S1, V0
202:                 			p1 += Finfo.fsize;
203:                 		}
204:                 /* what about other outputs ?
205:                 		UartPrint(STDOUT,"%c%c%c%c%c ",
206:                                 (Finfo.fattrib & AM_DIR) ? 'D' : '-',
207:                 				(Finfo.fattrib & AM_RDO) ? 'R' : '-',
208:                 				(Finfo.fattrib & AM_HID) ? 'H' : '-',
209:                 				(Finfo.fattrib & AM_SYS) ? 'S' : '-',
210:                 				(Finfo.fattrib & AM_ARC) ? 'A' : '-');
211:                 		UartPrint(STDOUT,"%u/%02u/%02u %02u:%02u ",
212:                                 (Finfo.fdate >> 9) + 1980,
213:                 				(Finfo.fdate >> 5) & 15, Finfo.fdate & 31, (Finfo.ftime >> 11),
214:                 				(Finfo.ftime >> 5) & 63);
215:                 		UartPrint(STDOUT," %9u ", Finfo.fsize);
216:                 		UartPrint(STDOUT, " %-12s %s", Finfo.fname,
217:                 #if _USE_LFN
218:                 				Lfname);
219:                 #else
220:                 				"");
221:                 #endif
222:                 */
223:                 	}
224:                 
225:                 	return s1;
226:                 } // listDir
9D00D6B0  8FBF003C   LW RA, 60(SP)
9D00D6B4  8FB10038   LW S1, 56(SP)
9D00D6B8  8FB00034   LW S0, 52(SP)
9D00D6BC  03E00008   JR RA
9D00D6C0  27BD0040   ADDIU SP, SP, 64
227:                 
228:                 char isDirectory(FILINFO file) {
9D00D6C4  AFA40000   SW A0, 0(SP)
9D00D6C8  AFA50004   SW A1, 4(SP)
9D00D6CC  AFA60008   SW A2, 8(SP)
9D00D6D0  AFA7000C   SW A3, 12(SP)
229:                 	if (file.fattrib & AM_DIR) {
230:                 		return TRUE;
231:                 	} else {
232:                 		return FALSE;
233:                 	}
234:                 }
9D00D6D4  03E00008   JR RA
9D00D6D8  7CC20100   EXT V0, A2, 4, 1
235:                 
236:                 char isReadOnly(FILINFO file) {
9D00D6DC  AFA40000   SW A0, 0(SP)
9D00D6E0  AFA50004   SW A1, 4(SP)
9D00D6E4  AFA60008   SW A2, 8(SP)
9D00D6E8  AFA7000C   SW A3, 12(SP)
237:                 	if (file.fattrib & AM_RDO) {
238:                 		return TRUE;
239:                 	} else {
240:                 		return FALSE;
241:                 	}
242:                 }
9D00D6EC  03E00008   JR RA
9D00D6F0  30C20001   ANDI V0, A2, 1
243:                 
244:                 char isHidden(FILINFO file) {
9D00D6F4  AFA40000   SW A0, 0(SP)
9D00D6F8  AFA50004   SW A1, 4(SP)
9D00D6FC  AFA60008   SW A2, 8(SP)
9D00D700  AFA7000C   SW A3, 12(SP)
245:                 	if (file.fattrib & AM_HID) {
246:                 		return TRUE;
247:                 	} else {
248:                 		return FALSE;
249:                 	}
250:                 }
9D00D704  03E00008   JR RA
9D00D708  7CC20040   EXT V0, A2, 1, 1
251:                 
252:                 char isSystem(FILINFO file) {
9D00D70C  AFA40000   SW A0, 0(SP)
9D00D710  AFA50004   SW A1, 4(SP)
9D00D714  AFA60008   SW A2, 8(SP)
9D00D718  AFA7000C   SW A3, 12(SP)
253:                 	if (file.fattrib & AM_SYS) {
254:                 		return TRUE;
255:                 	} else {
256:                 		return FALSE;
257:                 	}
258:                 }
9D00D71C  03E00008   JR RA
9D00D720  7CC20080   EXT V0, A2, 2, 1
259:                 
260:                 char isArchive(FILINFO file) {
9D00D724  AFA40000   SW A0, 0(SP)
9D00D728  AFA50004   SW A1, 4(SP)
9D00D72C  AFA60008   SW A2, 8(SP)
9D00D730  AFA7000C   SW A3, 12(SP)
261:                 	if (file.fattrib & AM_ARC) {
262:                 		return TRUE;
263:                 	} else {
264:                 		return FALSE;
265:                 	}
266:                 }
9D00D734  03E00008   JR RA
9D00D738  7CC20140   EXT V0, A2, 5, 1
267:                 #endif /* __FILEIO_C__ */
268:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/ff.c  ---------------------------------
1:                   /*----------------------------------------------------------------------------/
2:                    /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
3:                    /-----------------------------------------------------------------------------/
4:                    / FatFs module is a generic FAT file system module for small embedded systems.
5:                    / This is a free software that opened for education, research and commercial
6:                    / developments under license policy of following terms.
7:                    /
8:                    /  Copyright (C) 2011, ChaN, all right reserved.
9:                    /
10:                   / * The FatFs module is a free software and there is NO WARRANTY.
11:                   / * No restriction on use. You can use, modify and redistribute it for
12:                   /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
13:                   / * Redistributions of source code must retain the above copyright notice.
14:                   /
15:                   /-----------------------------------------------------------------------------/
16:                   / Feb 26,'06 R0.00  Prototype.
17:                   /
18:                   / Apr 29,'06 R0.01  First stable version.
19:                   /
20:                   / Jun 01,'06 R0.02  Added FAT12 support.
21:                   /                   Removed unbuffered mode.
22:                   /                   Fixed a problem on small (<32M) partition.
23:                   / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
24:                   /
25:                   / Sep 22,'06 R0.03  Added f_rename().
26:                   /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
27:                   / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
28:                   /                   Fixed f_mkdir() creates incorrect directory on FAT32.
29:                   /
30:                   / Feb 04,'07 R0.04  Supported multiple drive system.
31:                   /                   Changed some interfaces for multiple drive system.
32:                   /                   Changed f_mountdrv() to f_mount().
33:                   /                   Added f_mkfs().
34:                   / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
35:                   /                   Added a capability of extending file size to f_lseek().
36:                   /                   Added minimization level 3.
37:                   /                   Fixed an endian sensitive code in f_mkfs().
38:                   / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
39:                   /                   Added FSInfo support.
40:                   /                   Fixed DBCS name can result FR_INVALID_NAME.
41:                   /                   Fixed short seek (<= csize) collapses the file object.
42:                   /
43:                   / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
44:                   /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
45:                   /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
46:                   / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
47:                   /                   Fixed off by one error at FAT sub-type determination.
48:                   /                   Fixed btr in f_read() can be mistruncated.
49:                   /                   Fixed cached sector is not flushed when create and close without write.
50:                   /
51:                   / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
52:                   /                   Improved performance of f_lseek() on moving to the same or following cluster.
53:                   /
54:                   / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
55:                   /                   Added long file name feature.
56:                   /                   Added multiple code page feature.
57:                   /                   Added re-entrancy for multitask operation.
58:                   /                   Added auto cluster size selection to f_mkfs().
59:                   /                   Added rewind option to f_readdir().
60:                   /                   Changed result code of critical errors.
61:                   /                   Renamed string functions to avoid name collision.
62:                   / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
63:                   /                   Added multiple sector size feature.
64:                   / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
65:                   /                   Fixed wrong cache control in f_lseek().
66:                   /                   Added relative path feature.
67:                   /                   Added f_chdir() and f_chdrive().
68:                   /                   Added proper case conversion to extended char.
69:                   / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
70:                   /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
71:                   /                   Fixed name matching error on the 13 char boundary.
72:                   /                   Added a configuration option, _LFN_UNICODE.
73:                   /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
74:                   /
75:                   / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
76:                   /                   Added file lock feature. (_FS_SHARE)
77:                   /                   Added fast seek feature. (_USE_FASTSEEK)
78:                   /                   Changed some types on the API, XCHAR->TCHAR.
79:                   /                   Changed fname member in the FILINFO structure on Unicode cfg.
80:                   /                   String functions support UTF-8 encoding files on Unicode cfg.
81:                   / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
82:                   /                   Added sector erase feature. (_USE_ERASE)
83:                   /                   Moved file lock semaphore table from fs object to the bss.
84:                   /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
85:                   /                   Fixed f_mkfs() creates wrong FAT32 volume.
86:                   / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
87:                   /                   f_lseek() reports required table size on creating CLMP.
88:                   /                   Extended format syntax of f_printf function.
89:                   /                   Ignores duplicated directory separators in given path names.
90:                   /
91:                   / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
92:                   /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
93:                   /---------------------------------------------------------------------------
94:                   / 2011-12 Alfred Broda <alfredbroda@gmail.com> adapted for Pinguno Project
95:                   / BYTE and WORD were changed to PF_BYTE and PF_WORD because of a conflict.
96:                   ---------------------------------------------------------------------------*/
97:                  
98:                  #include "ff.h"			/* FatFs configurations and declarations */
99:                  #include "diskio.h"		/* Declarations of low level disk I/O functions */
100:                 
101:                 /*--------------------------------------------------------------------------
102:                 
103:                  Module Private Definitions
104:                 
105:                  ---------------------------------------------------------------------------*/
106:                 
107:                 #if _FATFS != 6502	/* Revision ID */
108:                 #error Wrong include file (ff.h).
109:                 #endif
110:                 
111:                 /* Definitions on sector size */
112:                 #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
113:                 #error Wrong sector size.
114:                 #endif
115:                 #if _MAX_SS != 512
116:                 #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
117:                 #else
118:                 #define	SS(fs)	512U			/* Fixed sector size */
119:                 #endif
120:                 
121:                 /* Reentrancy related */
122:                 #if _FS_REENTRANT
123:                 #if _USE_LFN == 1
124:                 #error Static LFN work area must not be used in re-entrant configuration.
125:                 #endif
126:                 #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
127:                 #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
128:                 #else
129:                 #define	ENTER_FF(fs)
130:                 #define LEAVE_FF(fs, res)	return res
131:                 #endif
132:                 
133:                 #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
134:                 
135:                 /* File shareing feature */
136:                 #if _FS_SHARE
137:                 #if _FS_READONLY
138:                 #error _FS_SHARE must be 0 on read-only cfg.
139:                 #endif
140:                 typedef struct {
141:                 	FATFS *fs; /* File ID 1, volume (NULL:blank entry) */
142:                 	DWORD clu; /* File ID 2, directory */
143:                 	PF_WORD idx; /* File ID 3, directory index */
144:                 	PF_WORD ctr; /* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
145:                 }FILESEM;
146:                 #endif
147:                 
148:                 /* Misc definitions */
149:                 #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
150:                 #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
151:                 
152:                 /* DBCS code ranges and SBCS extend char conversion table */
153:                 
154:                 #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
155:                 #define _DF1S	0x81	/* DBC 1st byte range 1 start */
156:                 #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
157:                 #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
158:                 #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
159:                 #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
160:                 #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
161:                 #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
162:                 #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
163:                 
164:                 #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
165:                 #define _DF1S	0x81
166:                 #define _DF1E	0xFE
167:                 #define _DS1S	0x40
168:                 #define _DS1E	0x7E
169:                 #define _DS2S	0x80
170:                 #define _DS2E	0xFE
171:                 
172:                 #elif _CODE_PAGE == 949	/* Korean */
173:                 #define _DF1S	0x81
174:                 #define _DF1E	0xFE
175:                 #define _DS1S	0x41
176:                 #define _DS1E	0x5A
177:                 #define _DS2S	0x61
178:                 #define _DS2E	0x7A
179:                 #define _DS3S	0x81
180:                 #define _DS3E	0xFE
181:                 
182:                 #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
183:                 #define _DF1S	0x81
184:                 #define _DF1E	0xFE
185:                 #define _DS1S	0x40
186:                 #define _DS1E	0x7E
187:                 #define _DS2S	0xA1
188:                 #define _DS2E	0xFE
189:                 
190:                 #elif _CODE_PAGE == 437	/* U.S. (OEM) */
191:                 #define _DF1S	0
192:                 #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
193:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
194:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
195:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
196:                 
197:                 #elif _CODE_PAGE == 720	/* Arabic (OEM) */
198:                 #define _DF1S	0
199:                 #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
200:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
201:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
202:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
203:                 
204:                 #elif _CODE_PAGE == 737	/* Greek (OEM) */
205:                 #define _DF1S	0
206:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
207:                 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
208:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
209:                 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
210:                 
211:                 #elif _CODE_PAGE == 775	/* Baltic (OEM) */
212:                 #define _DF1S	0
213:                 #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
214:                 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
215:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
216:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
217:                 
218:                 #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
219:                 #define _DF1S	0
220:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
221:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
222:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
223:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
224:                 
225:                 #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
226:                 #define _DF1S	0
227:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
228:                 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
229:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
230:                 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
231:                 
232:                 #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
233:                 #define _DF1S	0
234:                 #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
235:                 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
236:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
237:                 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
238:                 
239:                 #elif _CODE_PAGE == 857	/* Turkish (OEM) */
240:                 #define _DF1S	0
241:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
242:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
243:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
244:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
245:                 
246:                 #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
247:                 #define _DF1S	0
248:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
249:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
250:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
251:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
252:                 
253:                 #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
254:                 #define _DF1S	0
255:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
256:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
257:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
258:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
259:                 
260:                 #elif _CODE_PAGE == 866	/* Russian (OEM) */
261:                 #define _DF1S	0
262:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
263:                 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
264:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
265:                 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
266:                 
267:                 #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
268:                 #define _DF1S	0
269:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
270:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
271:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
272:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
273:                 
274:                 #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
275:                 #define _DF1S	0
276:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
277:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
278:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
279:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
280:                 
281:                 #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
282:                 #define _DF1S	0
283:                 #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
284:                 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
285:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
286:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
287:                 
288:                 #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
289:                 #define _DF1S	0
290:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
291:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
292:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
293:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
294:                 
295:                 #elif _CODE_PAGE == 1253 /* Greek (Windows) */
296:                 #define _DF1S	0
297:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
298:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
299:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
300:                 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
301:                 
302:                 #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
303:                 #define _DF1S	0
304:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
305:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
306:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
307:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
308:                 
309:                 #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
310:                 #define _DF1S	0
311:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
312:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
313:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
314:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
315:                 
316:                 #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
317:                 #define _DF1S	0
318:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
319:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
320:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
321:                 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
322:                 
323:                 #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
324:                 #define _DF1S	0
325:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
326:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
327:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
328:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
329:                 
330:                 #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
331:                 #define _DF1S	0
332:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
333:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
334:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
335:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
336:                 
337:                 #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
338:                 #if _USE_LFN
339:                 #error Cannot use LFN feature without valid code page.
340:                 #endif
341:                 #define _DF1S	0
342:                 
343:                 #else
344:                 #error Unknown code page
345:                 
346:                 #endif
347:                 
348:                 /* Character code support macros */
349:                 #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
350:                 #define IsLower(c)	(((c)>='a')&&((c)<='z'))
351:                 #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
352:                 
353:                 #if _DF1S		/* Code page is DBCS */
354:                 
355:                 #ifdef _DF2S	/* Two 1st byte areas */
356:                 #define IsDBCS1(c)	(((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E) || ((PF_BYTE)(c) >= _DF2S && (PF_BYTE)(c) <= _DF2E))
357:                 #else			/* One 1st byte area */
358:                 #define IsDBCS1(c)	((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E)
359:                 #endif
360:                 
361:                 #ifdef _DS3S	/* Three 2nd byte areas */
362:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E) || ((PF_BYTE)(c) >= _DS3S && (PF_BYTE)(c) <= _DS3E))
363:                 #else			/* Two 2nd byte areas */
364:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E))
365:                 #endif
366:                 
367:                 #else			/* Code page is SBCS */
368:                 
369:                 #define IsDBCS1(c)	0
370:                 #define IsDBCS2(c)	0
371:                 
372:                 #endif /* _DF1S */
373:                 
374:                 /* Name status flags */
375:                 #define NS			11		/* Index of name status byte in fn[] */
376:                 #define NS_LOSS		0x01	/* Out of 8.3 format */
377:                 #define NS_LFN		0x02	/* Force to create LFN entry */
378:                 #define NS_LAST		0x04	/* Last segment */
379:                 #define NS_BODY		0x08	/* Lower case flag (body) */
380:                 #define NS_EXT		0x10	/* Lower case flag (ext) */
381:                 #define NS_DOT		0x20	/* Dot entry */
382:                 
383:                 /* FAT sub-type boundaries */
384:                 /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
385:                 #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
386:                 #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
387:                 
388:                 /* FatFs refers the members in the FAT structures as byte array instead of
389:                  / structure member because the structure is not binary compatible between
390:                  / different platforms */
391:                 
392:                 #define BS_jmpBoot			0	/* Jump instruction (3) */
393:                 #define BS_OEMName			3	/* OEM name (8) */
394:                 #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
395:                 #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
396:                 #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
397:                 #define BPB_NumFATs			16	/* Number of FAT copies (1) */
398:                 #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
399:                 #define BPB_TotSec16		19	/* Volume size [sector] (2) */
400:                 #define BPB_Media			21	/* Media descriptor (1) */
401:                 #define BPB_FATSz16			22	/* FAT size [sector] (2) */
402:                 #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
403:                 #define BPB_NumHeads		26	/* Number of heads (2) */
404:                 #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
405:                 #define BPB_TotSec32		32	/* Volume size [sector] (4) */
406:                 #define BS_DrvNum			36	/* Physical drive number (2) */
407:                 #define BS_BootSig			38	/* Extended boot signature (1) */
408:                 #define BS_VolID			39	/* Volume serial number (4) */
409:                 #define BS_VolLab			43	/* Volume label (8) */
410:                 #define BS_FilSysType		54	/* File system type (1) */
411:                 #define BPB_FATSz32			36	/* FAT size [sector] (4) */
412:                 #define BPB_ExtFlags		40	/* Extended flags (2) */
413:                 #define BPB_FSVer			42	/* File system version (2) */
414:                 #define BPB_RootClus		44	/* Root dir first cluster (4) */
415:                 #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
416:                 #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
417:                 #define BS_DrvNum32			64	/* Physical drive number (2) */
418:                 #define BS_BootSig32		66	/* Extended boot signature (1) */
419:                 #define BS_VolID32			67	/* Volume serial number (4) */
420:                 #define BS_VolLab32			71	/* Volume label (8) */
421:                 #define BS_FilSysType32		82	/* File system type (1) */
422:                 #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
423:                 #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
424:                 #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
425:                 #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
426:                 #define MBR_Table			446	/* MBR: Partition table offset (2) */
427:                 #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
428:                 #define BS_55AA				510	/* Boot sector signature (2) */
429:                 
430:                 #define	DIR_Name			0	/* Short file name (11) */
431:                 #define	DIR_Attr			11	/* Attribute (1) */
432:                 #define	DIR_NTres			12	/* NT flag (1) */
433:                 #define	DIR_CrtTime			14	/* Created time (2) */
434:                 #define	DIR_CrtDate			16	/* Created date (2) */
435:                 #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
436:                 #define	DIR_WrtTime			22	/* Modified time (2) */
437:                 #define	DIR_WrtDate			24	/* Modified date (2) */
438:                 #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
439:                 #define	DIR_FileSize		28	/* File size (4) */
440:                 #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
441:                 #define	LDIR_Attr			11	/* LFN attribute (1) */
442:                 #define	LDIR_Type			12	/* LFN type (1) */
443:                 #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
444:                 #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
445:                 #define	SZ_DIR				32		/* Size of a directory entry */
446:                 #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
447:                 #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
448:                 #define	NDDE				0x05	/* Replacement of a character collides with DDE */
449:                 
450:                 /*------------------------------------------------------------*/
451:                 /* Module private work area                                   */
452:                 /*------------------------------------------------------------*/
453:                 /* Note that uninitialized variables with static duration are
454:                  /  zeroed/nulled at start-up. If not, the compiler or start-up
455:                  /  routine is out of ANSI-C standard.
456:                  */
457:                 
458:                 #if _VOLUMES
459:                 static FATFS *FatFs[_VOLUMES]; /* Pointer to the file system objects (logical drives) */
460:                 #else
461:                 #error Number of volumes must not be 0.
462:                 #endif
463:                 
464:                 static PF_WORD Fsid; /* File system mount ID */
465:                 
466:                 #if _FS_RPATH
467:                 static
468:                 PF_BYTE CurrVol; /* Current drive */
469:                 #endif
470:                 
471:                 #if _FS_SHARE
472:                 static
473:                 FILESEM Files[_FS_SHARE]; /* File lock semaphores */
474:                 #endif
475:                 
476:                 #if _USE_LFN == 0			/* No LFN feature */
477:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
478:                 #define INIT_BUF(dobj)		(dobj).fn = sfn
479:                 #define	FREE_BUF()
480:                 
481:                 #elif _USE_LFN == 1			/* LFN feature with static working buffer */
482:                 static WCHAR LfnBuf[_MAX_LFN+1];
483:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
484:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
485:                 #define	FREE_BUF()
486:                 
487:                 #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
488:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
489:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
490:                 #define	FREE_BUF()
491:                 
492:                 #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
493:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR *lfn
494:                 #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
495:                 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
496:                 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
497:                 #define	FREE_BUF()			ff_memfree(lfn)
498:                 
499:                 #else
500:                 #error Wrong LFN configuration.
501:                 #endif
502:                 
503:                 /*--------------------------------------------------------------------------
504:                 
505:                  Module Private Functions
506:                 
507:                  ---------------------------------------------------------------------------*/
508:                 
509:                 /*-----------------------------------------------------------------------*/
510:                 /* String functions                                                      */
511:                 /*-----------------------------------------------------------------------*/
512:                 
513:                 /* Copy memory to memory */
514:                 static
515:                 void mem_cpy(void* dst, const void* src, UINT cnt) {
9D0037C8  00862021   ADDU A0, A0, A2
516:                 	PF_BYTE *d = (PF_BYTE*) dst;
517:                 	const PF_BYTE *s = (const PF_BYTE*) src;
518:                 
519:                 #if _WORD_ACCESS == 1
520:                 	while (cnt >= sizeof(int)) {
521:                 		*(int*) d = *(int*) s;
522:                 		d += sizeof(int);
523:                 		s += sizeof(int);
524:                 		cnt -= sizeof(int);
525:                 	}
526:                 #endif
527:                 	while (cnt--)
9D0037C0  10C00007   BEQ A2, ZERO, 0x9D0037E0
9D0037C4  00801021   ADDU V0, A0, ZERO
9D0037D8  1444FFFC   BNE V0, A0, 0x9D0037CC
9D0037DC  24A50001   ADDIU A1, A1, 1
9D0037E0  03E00008   JR RA
9D0037E4  00000000   NOP
528:                 		*d++ = *s++;
9D0037CC  90A30000   LBU V1, 0(A1)
9D0037D0  A0430000   SB V1, 0(V0)
9D0037D4  24420001   ADDIU V0, V0, 1
529:                 }
530:                 
531:                 /* Fill memory */
532:                 static
533:                 void mem_set(void* dst, int val, UINT cnt) {
9D0037F0  00862021   ADDU A0, A0, A2
534:                 	PF_BYTE *d = (PF_BYTE*) dst;
535:                 
536:                 	while (cnt--)
9D0037E8  10C00006   BEQ A2, ZERO, 0x9D003804
9D0037EC  00801021   ADDU V0, A0, ZERO
9D0037FC  5444FFFE   BNEL V0, A0, 0x9D0037F8
9D003800  A0450000   SB A1, 0(V0)
9D003804  03E00008   JR RA
9D003808  00000000   NOP
537:                 		*d++ = (PF_BYTE) val;
9D0037F4  A0450000   SB A1, 0(V0)
9D0037F8  24420001   ADDIU V0, V0, 1
538:                 }
539:                 
540:                 /* Compare memory to memory */
541:                 static
542:                 int mem_cmp(const void* dst, const void* src, UINT cnt) {
543:                 	const PF_BYTE *d = (const PF_BYTE *) dst, *s = (const PF_BYTE *) src;
9D004860  01402021   ADDU A0, T2, ZERO
544:                 	int r = 0;
545:                 
546:                 	while (cnt-- && (r = *d++ - *s++) == 0)
9D00486C  50680037   BEQL V1, T0, 0x9D00494C
9D004870  9143000B   LBU V1, 11(T2)
9D004874  90660000   LBU A2, 0(V1)
9D004878  90850000   LBU A1, 0(A0)
9D00487C  24630001   ADDIU V1, V1, 1
9D004880  10C5FFFA   BEQ A2, A1, 0x9D00486C
9D004884  24840001   ADDIU A0, A0, 1
547:                 		;
548:                 	return r;
549:                 }
550:                 
551:                 /* Check if chr is contained in the string */
552:                 static
553:                 int chk_chr(const char* str, int chr) {
554:                 	while (*str && *str != chr)
9D00462C  24160022   ADDIU S6, ZERO, 34
9D004630  3C179D01   LUI S7, -25343
9D004744  10560071   BEQ V0, S6, 0x9D00490C
9D004748  00405021   ADDU T2, V0, ZERO
9D00474C  26E5024C   ADDIU A1, S7, 588
9D004754  80A70000   LB A3, 0(A1)
9D004758  50E00005   BEQL A3, ZERO, 0x9D004770
9D00475C  2445FFBF   ADDIU A1, V0, -65
9D004760  5547FFFC   BNEL T2, A3, 0x9D004754
9D004764  24A50001   ADDIU A1, A1, 1
9D004768  0B401246   J 0x9D004918
9D00476C  24020006   ADDIU V0, ZERO, 6
9D00490C  0B401246   J 0x9D004918
9D004910  24020006   ADDIU V0, ZERO, 6
9D004914  24020006   ADDIU V0, ZERO, 6
555:                 		str++;
9D004750  24A50001   ADDIU A1, A1, 1
556:                 	return *str;
557:                 }
558:                 
559:                 /*-----------------------------------------------------------------------*/
560:                 /* Request/Release grant to access the volume                            */
561:                 /*-----------------------------------------------------------------------*/
562:                 #if _FS_REENTRANT
563:                 
564:                 static
565:                 int lock_fs (
566:                 		FATFS *fs /* File system object */
567:                 )
568:                 {
569:                 	return ff_req_grant(fs->sobj);
570:                 }
571:                 
572:                 static
573:                 void unlock_fs (
574:                 		FATFS *fs, /* File system object */
575:                 		FRESULT res /* Result code to be returned */
576:                 )
577:                 {
578:                 	if (res != FR_NOT_ENABLED &&
579:                 			res != FR_INVALID_DRIVE &&
580:                 			res != FR_INVALID_OBJECT &&
581:                 			res != FR_TIMEOUT) {
582:                 		ff_rel_grant(fs->sobj);
583:                 	}
584:                 }
585:                 #endif
586:                 
587:                 /*-----------------------------------------------------------------------*/
588:                 /* File shareing control functions                                       */
589:                 /*-----------------------------------------------------------------------*/
590:                 #if _FS_SHARE
591:                 
592:                 static
593:                 FRESULT chk_lock ( /* Check if the file can be accessed */
594:                 		DIR* dj, /* Directory object pointing the file to be checked */
595:                 		int acc /* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
596:                 )
597:                 {
598:                 	UINT i, be;
599:                 
600:                 	/* Search file semaphore table */
601:                 	for (i = be = 0; i < _FS_SHARE; i++) {
602:                 		if (Files[i].fs) { /* Existing entry */
603:                 			if (Files[i].fs == dj->fs && /* Check if the file matched with an open file */
604:                 					Files[i].clu == dj->sclust &&
605:                 					Files[i].idx == dj->index) break;
606:                 		} else { /* Blank entry */
607:                 			be++;
608:                 		}
609:                 	}
610:                 	if (i == _FS_SHARE) /* The file is not opened */
611:                 	return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES; /* Is there a blank entry for new file? */
612:                 
613:                 	/* The file has been opened. Reject any open against writing file and all write mode open */
614:                 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
615:                 }
616:                 
617:                 static
618:                 int enq_lock (void) /* Check if an entry is available for a new file */
619:                 {
620:                 	UINT i;
621:                 
622:                 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
623:                 	return (i == _FS_SHARE) ? 0 : 1;
624:                 }
625:                 
626:                 static
627:                 UINT inc_lock ( /* Increment file open counter and returns its index (0:int error) */
628:                 		DIR* dj, /* Directory object pointing the file to register or increment */
629:                 		int acc /* Desired access mode (0:Read, !0:Write) */
630:                 )
631:                 {
632:                 	UINT i;
633:                 
634:                 	for (i = 0; i < _FS_SHARE; i++) { /* Find the file */
635:                 		if (Files[i].fs == dj->fs &&
636:                 				Files[i].clu == dj->sclust &&
637:                 				Files[i].idx == dj->index) break;
638:                 	}
639:                 
640:                 	if (i == _FS_SHARE) { /* Not opened. Register it as new. */
641:                 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
642:                 		if (i == _FS_SHARE) return 0; /* No space to register (int err) */
643:                 		Files[i].fs = dj->fs;
644:                 		Files[i].clu = dj->sclust;
645:                 		Files[i].idx = dj->index;
646:                 		Files[i].ctr = 0;
647:                 	}
648:                 
649:                 	if (acc && Files[i].ctr) return 0; /* Access violation (int err) */
650:                 
651:                 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1; /* Set semaphore value */
652:                 
653:                 	return i + 1;
654:                 }
655:                 
656:                 static
657:                 FRESULT dec_lock ( /* Decrement file open counter */
658:                 		UINT i /* Semaphore index */
659:                 )
660:                 {
661:                 	PF_WORD n;
662:                 	FRESULT res;
663:                 
664:                 	if (--i < _FS_SHARE) {
665:                 		n = Files[i].ctr;
666:                 		if (n == 0x100) n = 0;
667:                 		if (n) n--;
668:                 		Files[i].ctr = n;
669:                 		if (!n) Files[i].fs = 0;
670:                 		res = FR_OK;
671:                 	} else {
672:                 		res = FR_INT_ERR;
673:                 	}
674:                 	return res;
675:                 }
676:                 
677:                 static
678:                 void clear_lock ( /* Clear lock entries of the volume */
679:                 		FATFS *fs
680:                 )
681:                 {
682:                 	UINT i;
683:                 
684:                 	for (i = 0; i < _FS_SHARE; i++) {
685:                 		if (Files[i].fs == fs) Files[i].fs = 0;
686:                 	}
687:                 }
688:                 #endif
689:                 
690:                 /*-----------------------------------------------------------------------*/
691:                 /* Change window offset                                                  */
692:                 /*-----------------------------------------------------------------------*/
693:                 
694:                 static FRESULT move_window(FATFS *fs, /* File system object */
695:                 DWORD sector /* Sector number to make appearance in the fs->win[] */
696:                 ) /* Move to zero only writes back dirty window */
697:                 {
9D0039A8  27BDFFD8   ADDIU SP, SP, -40
9D0039AC  AFBF0024   SW RA, 36(SP)
9D0039B0  AFB40020   SW S4, 32(SP)
9D0039B4  AFB3001C   SW S3, 28(SP)
9D0039B8  AFB20018   SW S2, 24(SP)
9D0039BC  AFB10014   SW S1, 20(SP)
9D0039C0  AFB00010   SW S0, 16(SP)
9D0039C4  00808021   ADDU S0, A0, ZERO
9D0039C8  00A09021   ADDU S2, A1, ZERO
698:                 	DWORD wsect;
699:                 
700:                 	wsect = fs->winsect;
9D0039CC  8C91002C   LW S1, 44(A0)
701:                 	if (wsect != sector) { /* Changed current window */
9D0039D0  1225002D   BEQ S1, A1, 0x9D003A88
9D0039D4  00001821   ADDU V1, ZERO, ZERO
702:                 #if !_FS_READONLY
703:                 		if (fs->wflag) { /* Write back dirty window if needed */
9D0039D8  90820004   LBU V0, 4(A0)
9D0039DC  1040001F   BEQ V0, ZERO, 0x9D003A5C
9D0039E0  02203021   ADDU A2, S1, ZERO
704:                 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
9D0039E4  24940030   ADDIU S4, A0, 48
9D0039E8  90840001   LBU A0, 1(A0)
9D0039EC  02802821   ADDU A1, S4, ZERO
9D0039F0  0F4023D7   JAL disk_write
9D0039F4  24070001   ADDIU A3, ZERO, 1
9D0039F8  14400023   BNE V0, ZERO, 0x9D003A88
9D0039FC  24030001   ADDIU V1, ZERO, 1
705:                 				return FR_DISK_ERR;
706:                 			fs->wflag = 0;
9D003A00  A2000004   SB ZERO, 4(S0)
707:                 			if (wsect < (fs->fatbase + fs->fsize)) { /* In FAT area */
9D003A04  8E03001C   LW V1, 28(S0)
9D003A08  8E020020   LW V0, 32(S0)
9D003A0C  00621021   ADDU V0, V1, V0
9D003A10  0222102B   SLTU V0, S1, V0
9D003A14  10400011   BEQ V0, ZERO, 0x9D003A5C
9D003A18  00000000   NOP
708:                 				PF_BYTE nf;
709:                 				for (nf = fs->n_fats; nf > 1; nf--) { /* Reflect the change to all FAT copies */
9D003A1C  92130003   LBU S3, 3(S0)
9D003A20  2E620002   SLTIU V0, S3, 2
9D003A24  1440000D   BNE V0, ZERO, 0x9D003A5C
9D003A28  00000000   NOP
9D003A48  2673FFFF   ADDIU S3, S3, -1
9D003A4C  327300FF   ANDI S3, S3, 255
9D003A50  24020001   ADDIU V0, ZERO, 1
9D003A54  5662FFF6   BNEL S3, V0, 0x9D003A30
9D003A58  8E02001C   LW V0, 28(S0)
710:                 					wsect += fs->fsize;
9D003A2C  8E02001C   LW V0, 28(S0)
9D003A30  02228821   ADDU S1, S1, V0
711:                 					disk_write(fs->drv, fs->win, wsect, 1);
9D003A34  92040001   LBU A0, 1(S0)
9D003A38  02802821   ADDU A1, S4, ZERO
9D003A3C  02203021   ADDU A2, S1, ZERO
9D003A40  0F4023D7   JAL disk_write
9D003A44  24070001   ADDIU A3, ZERO, 1
712:                 				}
713:                 			}
714:                 		}
715:                 #endif
716:                 		if (sector) {
9D003A5C  1240000A   BEQ S2, ZERO, 0x9D003A88
9D003A60  00001821   ADDU V1, ZERO, ZERO
717:                 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
9D003A64  92040001   LBU A0, 1(S0)
9D003A68  26050030   ADDIU A1, S0, 48
9D003A6C  02403021   ADDU A2, S2, ZERO
9D003A70  0F4023A1   JAL disk_read
9D003A74  24070001   ADDIU A3, ZERO, 1
9D003A78  14400003   BNE V0, ZERO, 0x9D003A88
9D003A7C  24030001   ADDIU V1, ZERO, 1
718:                 				return FR_DISK_ERR;
719:                 			fs->winsect = sector;
9D003A80  AE12002C   SW S2, 44(S0)
720:                 		}
721:                 	}
722:                 
723:                 	return FR_OK;
9D003A84  00001821   ADDU V1, ZERO, ZERO
724:                 }
9D003A88  00601021   ADDU V0, V1, ZERO
9D003A8C  8FBF0024   LW RA, 36(SP)
9D003A90  8FB40020   LW S4, 32(SP)
9D003A94  8FB3001C   LW S3, 28(SP)
9D003A98  8FB20018   LW S2, 24(SP)
9D003A9C  8FB10014   LW S1, 20(SP)
9D003AA0  8FB00010   LW S0, 16(SP)
9D003AA4  03E00008   JR RA
9D003AA8  27BD0028   ADDIU SP, SP, 40
725:                 
726:                 /*-----------------------------------------------------------------------*/
727:                 /* Clean-up cached data                                                  */
728:                 /*-----------------------------------------------------------------------*/
729:                 #if !_FS_READONLY
730:                 static FRESULT sync( /* FR_OK: successful, FR_DISK_ERR: failed */
731:                 FATFS *fs /* File system object */
732:                 ) {
9D003B84  27BDFFE0   ADDIU SP, SP, -32
9D003B88  AFBF001C   SW RA, 28(SP)
9D003B8C  AFB20018   SW S2, 24(SP)
9D003B90  AFB10014   SW S1, 20(SP)
9D003B94  AFB00010   SW S0, 16(SP)
9D003B98  00808821   ADDU S1, A0, ZERO
733:                 	FRESULT res;
734:                 
735:                 	res = move_window(fs, 0);
9D003B9C  0F400E6A   JAL 0x9D0039A8
9D003BA0  00002821   ADDU A1, ZERO, ZERO
736:                 	if (res == FR_OK) {
9D003BA4  1440003A   BNE V0, ZERO, 0x9D003C90
9D003BA8  00408021   ADDU S0, V0, ZERO
737:                 		/* Update FSInfo sector if needed */
738:                 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
9D003BAC  92230000   LBU V1, 0(S1)
9D003BB0  24020003   ADDIU V0, ZERO, 3
9D003BB4  54620031   BNEL V1, V0, 0x9D003C7C
9D003BB8  92240001   LBU A0, 1(S1)
9D003BBC  92220005   LBU V0, 5(S1)
9D003BC0  5040002E   BEQL V0, ZERO, 0x9D003C7C
9D003BC4  92240001   LBU A0, 1(S1)
739:                 			fs->winsect = 0;
9D003BC8  AE20002C   SW ZERO, 44(S1)
740:                 			/* Create FSInfo structure */
741:                 			mem_set(fs->win, 0, 512);
9D003BCC  26320030   ADDIU S2, S1, 48
9D003BD0  02402021   ADDU A0, S2, ZERO
9D003BD4  00002821   ADDU A1, ZERO, ZERO
9D003BD8  0F400DFA   JAL 0x9D0037E8
9D003BDC  24060200   ADDIU A2, ZERO, 512
742:                 			ST_WORD(fs->win+BS_55AA, 0xAA55);
9D003BE0  24020055   ADDIU V0, ZERO, 85
9D003BE4  A222022E   SB V0, 558(S1)
9D003BE8  2402FFAA   ADDIU V0, ZERO, -86
9D003BEC  A222022F   SB V0, 559(S1)
743:                 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
9D003BF0  24020052   ADDIU V0, ZERO, 82
9D003BF4  A2220030   SB V0, 48(S1)
9D003BF8  A2220031   SB V0, 49(S1)
9D003BFC  24020061   ADDIU V0, ZERO, 97
9D003C00  A2220032   SB V0, 50(S1)
9D003C04  24030041   ADDIU V1, ZERO, 65
9D003C08  A2230033   SB V1, 51(S1)
744:                 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
9D003C0C  24040072   ADDIU A0, ZERO, 114
9D003C10  A2240214   SB A0, 532(S1)
9D003C14  A2240215   SB A0, 533(S1)
9D003C18  A2230216   SB V1, 534(S1)
9D003C1C  A2220217   SB V0, 535(S1)
745:                 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
9D003C20  8E220010   LW V0, 16(S1)
9D003C24  A2220218   SB V0, 536(S1)
9D003C28  7C433A00   EXT V1, V0, 8, 8
9D003C2C  A2230219   SB V1, 537(S1)
9D003C30  00021C02   SRL V1, V0, 16
9D003C34  A223021A   SB V1, 538(S1)
9D003C38  00021602   SRL V0, V0, 24
9D003C3C  A222021B   SB V0, 539(S1)
746:                 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
9D003C40  8E22000C   LW V0, 12(S1)
9D003C44  A222021C   SB V0, 540(S1)
9D003C48  7C433A00   EXT V1, V0, 8, 8
9D003C4C  A223021D   SB V1, 541(S1)
9D003C50  00021C02   SRL V1, V0, 16
9D003C54  A223021E   SB V1, 542(S1)
9D003C58  00021602   SRL V0, V0, 24
9D003C5C  A222021F   SB V0, 543(S1)
747:                 			/* Write it into the FSInfo sector */
748:                 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
9D003C60  92240001   LBU A0, 1(S1)
9D003C64  02402821   ADDU A1, S2, ZERO
9D003C68  8E260014   LW A2, 20(S1)
9D003C6C  0F4023D7   JAL disk_write
9D003C70  24070001   ADDIU A3, ZERO, 1
749:                 			fs->fsi_flag = 0;
9D003C74  A2200005   SB ZERO, 5(S1)
750:                 		}
751:                 		/* Make sure that no pending write process in the physical drive */
752:                 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
9D003C78  92240001   LBU A0, 1(S1)
9D003C7C  00002821   ADDU A1, ZERO, ZERO
9D003C80  0F40241C   JAL disk_ioctl
9D003C84  00003021   ADDU A2, ZERO, ZERO
753:                 			res = FR_DISK_ERR;
9D003C88  24030001   ADDIU V1, ZERO, 1
9D003C8C  0062800B   MOVN S0, V1, V0
754:                 	}
755:                 
756:                 	return res;
757:                 }
9D003C90  02001021   ADDU V0, S0, ZERO
9D003C94  8FBF001C   LW RA, 28(SP)
9D003C98  8FB20018   LW S2, 24(SP)
9D003C9C  8FB10014   LW S1, 20(SP)
9D003CA0  8FB00010   LW S0, 16(SP)
9D003CA4  03E00008   JR RA
9D003CA8  27BD0020   ADDIU SP, SP, 32
758:                 #endif
759:                 
760:                 /*-----------------------------------------------------------------------*/
761:                 /* Get sector# from cluster#                                             */
762:                 /*-----------------------------------------------------------------------*/
763:                 
764:                 DWORD clust2sect( /* !=0: Sector number, 0: Failed - invalid cluster# */
765:                 FATFS *fs, /* File system object */
766:                 DWORD clst /* Cluster# to be converted */
767:                 ) {
768:                 	clst -= 2;
9D003CF8  24A5FFFE   ADDIU A1, A1, -2
769:                 	if (clst >= (fs->n_fatent - 2))
9D003CFC  8C830018   LW V1, 24(A0)
9D003D00  2463FFFE   ADDIU V1, V1, -2
9D003D04  00A3182B   SLTU V1, A1, V1
9D003D08  10600005   BEQ V1, ZERO, 0x9D003D20
9D003D0C  00001021   ADDU V0, ZERO, ZERO
770:                 		return 0; /* Invalid cluster# */
771:                 	return clst * fs->csize + fs->database;
9D003D10  90820002   LBU V0, 2(A0)
9D003D14  8C830028   LW V1, 40(A0)
9D003D18  70A22002   MUL A0, A1, V0
9D003D1C  00831021   ADDU V0, A0, V1
772:                 }
9D003D20  03E00008   JR RA
9D003D24  00000000   NOP
773:                 
774:                 /*-----------------------------------------------------------------------*/
775:                 /* FAT access - Read value of a FAT entry                                */
776:                 /*-----------------------------------------------------------------------*/
777:                 
778:                 DWORD get_fat( /* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
779:                 FATFS *fs, /* File system object */
780:                 DWORD clst /* Cluster# to get the link information */
781:                 ) {
9D003D28  27BDFFD8   ADDIU SP, SP, -40
9D003D2C  AFBF0024   SW RA, 36(SP)
9D003D30  AFB30020   SW S3, 32(SP)
9D003D34  AFB2001C   SW S2, 28(SP)
9D003D38  AFB10018   SW S1, 24(SP)
9D003D3C  AFB00014   SW S0, 20(SP)
9D003D40  00808021   ADDU S0, A0, ZERO
9D003D44  00A08821   ADDU S1, A1, ZERO
782:                 	UINT wc, bc;
783:                 	PF_BYTE *p;
784:                 
785:                 	if (clst < 2 || clst >= fs->n_fatent) /* Chack range */
9D003D48  2CA20002   SLTIU V0, A1, 2
9D003D4C  1440004F   BNE V0, ZERO, 0x9D003E8C
9D003D50  24030001   ADDIU V1, ZERO, 1
9D003D54  8C820018   LW V0, 24(A0)
9D003D58  00A2102B   SLTU V0, A1, V0
9D003D5C  1040004C   BEQ V0, ZERO, 0x9D003E90
9D003D60  00601021   ADDU V0, V1, ZERO
786:                 		return 1;
787:                 
788:                 	switch (fs->fs_type) {
9D003D64  90820000   LBU V0, 0(A0)
9D003D68  24030002   ADDIU V1, ZERO, 2
9D003D6C  50430025   BEQL V0, V1, 0x9D003E04
9D003D70  00052A02   SRL A1, A1, 8
9D003D74  24030003   ADDIU V1, ZERO, 3
9D003D78  5043002F   BEQL V0, V1, 0x9D003E38
9D003D7C  000529C2   SRL A1, A1, 7
9D003D80  24030001   ADDIU V1, ZERO, 1
9D003D84  54430041   BNEL V0, V1, 0x9D003E8C
9D003D88  2403FFFF   ADDIU V1, ZERO, -1
789:                 	case FS_FAT12:
790:                 		bc = (UINT) clst;
791:                 		bc += bc / 2;
9D003D8C  00059042   SRL S2, A1, 1
9D003D90  02459021   ADDU S2, S2, A1
792:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D003D94  00122A42   SRL A1, S2, 9
9D003D98  8C820020   LW V0, 32(A0)
9D003D9C  0F400E6A   JAL 0x9D0039A8
9D003DA0  00A22821   ADDU A1, A1, V0
9D003DA4  14400039   BNE V0, ZERO, 0x9D003E8C
9D003DA8  2403FFFF   ADDIU V1, ZERO, -1
793:                 			break;
794:                 		wc = fs->win[bc % SS(fs)];
9D003DAC  324201FF   ANDI V0, S2, 511
9D003DB0  02021021   ADDU V0, S0, V0
9D003DB4  90530030   LBU S3, 48(V0)
795:                 		bc++;
9D003DB8  26520001   ADDIU S2, S2, 1
796:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D003DBC  00122A42   SRL A1, S2, 9
9D003DC0  8E020020   LW V0, 32(S0)
9D003DC4  02002021   ADDU A0, S0, ZERO
9D003DC8  0F400E6A   JAL 0x9D0039A8
9D003DCC  00A22821   ADDU A1, A1, V0
9D003DD0  1440002E   BNE V0, ZERO, 0x9D003E8C
9D003DD4  2403FFFF   ADDIU V1, ZERO, -1
797:                 			break;
798:                 		wc |= fs->win[bc % SS(fs)] << 8;
9D003DD8  325201FF   ANDI S2, S2, 511
9D003DDC  02128021   ADDU S0, S0, S2
9D003DE0  92030030   LBU V1, 48(S0)
9D003DE4  00031A00   SLL V1, V1, 8
9D003DE8  00739825   OR S3, V1, S3
799:                 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
9D003DEC  32310001   ANDI S1, S1, 1
9D003DF0  00131102   SRL V0, S3, 4
9D003DF4  32730FFF   ANDI S3, S3, 4095
9D003DF8  00401821   ADDU V1, V0, ZERO
9D003DFC  0B400FA3   J 0x9D003E8C
9D003E00  0271180A   MOVZ V1, S3, S1
800:                 
801:                 	case FS_FAT16:
802:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))))
9D003E04  8C820020   LW V0, 32(A0)
9D003E08  0F400E6A   JAL 0x9D0039A8
9D003E0C  00A22821   ADDU A1, A1, V0
9D003E10  1440001E   BNE V0, ZERO, 0x9D003E8C
9D003E14  2403FFFF   ADDIU V1, ZERO, -1
803:                 			break;
804:                 		p = &fs->win[clst * 2 % SS(fs)];
9D003E18  00118840   SLL S1, S1, 1
9D003E1C  323101FF   ANDI S1, S1, 511
805:                 		return LD_WORD(p);
9D003E20  02111021   ADDU V0, S0, S1
9D003E24  90430031   LBU V1, 49(V0)
9D003E28  00031A00   SLL V1, V1, 8
9D003E2C  90420030   LBU V0, 48(V0)
9D003E30  0B400FA3   J 0x9D003E8C
9D003E34  00621825   OR V1, V1, V0
806:                 
807:                 	case FS_FAT32:
808:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))))
9D003E38  8C820020   LW V0, 32(A0)
9D003E3C  0F400E6A   JAL 0x9D0039A8
9D003E40  00A22821   ADDU A1, A1, V0
9D003E44  14400011   BNE V0, ZERO, 0x9D003E8C
9D003E48  2403FFFF   ADDIU V1, ZERO, -1
809:                 			break;
810:                 		p = &fs->win[clst * 4 % SS(fs)];
9D003E4C  00118880   SLL S1, S1, 2
9D003E50  323101FF   ANDI S1, S1, 511
9D003E54  26220030   ADDIU V0, S1, 48
9D003E58  02021021   ADDU V0, S0, V0
811:                 		return LD_DWORD(p) & 0x0FFFFFFF;
9D003E5C  90440002   LBU A0, 2(V0)
9D003E60  00042400   SLL A0, A0, 16
9D003E64  90430003   LBU V1, 3(V0)
9D003E68  00031E00   SLL V1, V1, 24
9D003E6C  00831825   OR V1, A0, V1
9D003E70  90420001   LBU V0, 1(V0)
9D003E74  00021200   SLL V0, V0, 8
9D003E78  00621825   OR V1, V1, V0
9D003E7C  02118021   ADDU S0, S0, S1
9D003E80  92020030   LBU V0, 48(S0)
9D003E84  00621825   OR V1, V1, V0
9D003E88  7C63D800   EXT V1, V1, 0, 28
812:                 	}
813:                 
814:                 	return 0xFFFFFFFF; /* An error occurred at the disk I/O layer */
815:                 }
9D003E8C  00601021   ADDU V0, V1, ZERO
9D003E90  8FBF0024   LW RA, 36(SP)
9D003E94  8FB30020   LW S3, 32(SP)
9D003E98  8FB2001C   LW S2, 28(SP)
9D003E9C  8FB10018   LW S1, 24(SP)
9D003EA0  8FB00014   LW S0, 20(SP)
9D003EA4  03E00008   JR RA
9D003EA8  27BD0028   ADDIU SP, SP, 40
816:                 
817:                 /*-----------------------------------------------------------------------*/
818:                 /* FAT access - Change value of a FAT entry                              */
819:                 /*-----------------------------------------------------------------------*/
820:                 #if !_FS_READONLY
821:                 
822:                 FRESULT put_fat(FATFS *fs, /* File system object */
823:                 DWORD clst, /* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
824:                 DWORD val /* New value to mark the cluster */
825:                 ) {
9D004068  27BDFFD8   ADDIU SP, SP, -40
9D00406C  AFBF0024   SW RA, 36(SP)
9D004070  AFB30020   SW S3, 32(SP)
9D004074  AFB2001C   SW S2, 28(SP)
9D004078  AFB10018   SW S1, 24(SP)
9D00407C  AFB00014   SW S0, 20(SP)
9D004080  00808021   ADDU S0, A0, ZERO
9D004084  00A08821   ADDU S1, A1, ZERO
9D004088  00C09021   ADDU S2, A2, ZERO
826:                 	UINT bc;
827:                 	PF_BYTE *p;
828:                 	FRESULT res;
829:                 
830:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D00408C  2CA30002   SLTIU V1, A1, 2
9D004090  1460005D   BNE V1, ZERO, 0x9D004208
9D004094  24020002   ADDIU V0, ZERO, 2
9D004098  8C830018   LW V1, 24(A0)
9D00409C  00A3182B   SLTU V1, A1, V1
9D0040A0  10600059   BEQ V1, ZERO, 0x9D004208
9D0040A4  24030002   ADDIU V1, ZERO, 2
831:                 		res = FR_INT_ERR;
832:                 
833:                 	} else {
834:                 		switch (fs->fs_type) {
9D0040A8  90820000   LBU V0, 0(A0)
9D0040AC  10430030   BEQ V0, V1, 0x9D004170
9D0040B0  24030003   ADDIU V1, ZERO, 3
9D0040B4  1043003B   BEQ V0, V1, 0x9D0041A4
9D0040B8  24030001   ADDIU V1, ZERO, 1
9D0040BC  14430050   BNE V0, V1, 0x9D004200
9D0040C0  24020002   ADDIU V0, ZERO, 2
835:                 		case FS_FAT12:
836:                 			bc = clst;
837:                 			bc += bc / 2;
9D0040C4  00059842   SRL S3, A1, 1
9D0040C8  02659821   ADDU S3, S3, A1
838:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D0040CC  00132A42   SRL A1, S3, 9
9D0040D0  8C820020   LW V0, 32(A0)
9D0040D4  0F400E6A   JAL 0x9D0039A8
9D0040D8  00A22821   ADDU A1, A1, V0
839:                 			if (res != FR_OK)
9D0040DC  14400049   BNE V0, ZERO, 0x9D004204
9D0040E0  24030001   ADDIU V1, ZERO, 1
840:                 				break;
841:                 			p = &fs->win[bc % SS(fs)];
9D0040E4  326301FF   ANDI V1, S3, 511
842:                 			*p = (clst & 1) ? ((*p & 0x0F) | ((PF_BYTE) val << 4))
9D0040E8  32310001   ANDI S1, S1, 1
9D0040EC  12200008   BEQ S1, ZERO, 0x9D004110
9D0040F0  324200FF   ANDI V0, S2, 255
9D0040F4  02031021   ADDU V0, S0, V1
9D0040F8  90440030   LBU A0, 48(V0)
9D0040FC  3084000F   ANDI A0, A0, 15
9D004100  324200FF   ANDI V0, S2, 255
9D004104  00021100   SLL V0, V0, 4
9D004108  00821025   OR V0, A0, V0
9D00410C  304200FF   ANDI V0, V0, 255
9D004110  02031821   ADDU V1, S0, V1
9D004114  A0620030   SB V0, 48(V1)
843:                 					: (PF_BYTE) val;
844:                 			bc++;
9D004118  26730001   ADDIU S3, S3, 1
845:                 			fs->wflag = 1;
9D00411C  24020001   ADDIU V0, ZERO, 1
9D004120  A2020004   SB V0, 4(S0)
846:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D004124  00132A42   SRL A1, S3, 9
9D004128  8E020020   LW V0, 32(S0)
9D00412C  02002021   ADDU A0, S0, ZERO
9D004130  0F400E6A   JAL 0x9D0039A8
9D004134  00A22821   ADDU A1, A1, V0
847:                 			if (res != FR_OK)
9D004138  14400032   BNE V0, ZERO, 0x9D004204
9D00413C  24030001   ADDIU V1, ZERO, 1
848:                 				break;
849:                 			p = &fs->win[bc % SS(fs)];
850:                 			*p = (clst & 1) ? (PF_BYTE) (val >> 4) : ((*p & 0xF0)
9D004140  12200003   BEQ S1, ZERO, 0x9D004150
9D004144  327301FF   ANDI S3, S3, 511
9D004148  0B401059   J 0x9D004164
9D00414C  7E523900   EXT S2, S2, 4, 8
9D004150  02131821   ADDU V1, S0, S3
9D004154  90630030   LBU V1, 48(V1)
9D004158  306300F0   ANDI V1, V1, 240
9D00415C  7E521A00   EXT S2, S2, 8, 4
9D004160  00729025   OR S2, V1, S2
9D004164  02139821   ADDU S3, S0, S3
851:                 					| ((PF_BYTE) (val >> 8) & 0x0F));
852:                 			break;
9D004168  0B401080   J 0x9D004200
9D00416C  A2720030   SB S2, 48(S3)
853:                 
854:                 		case FS_FAT16:
855:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
9D004170  00052A02   SRL A1, A1, 8
9D004174  8C820020   LW V0, 32(A0)
9D004178  0F400E6A   JAL 0x9D0039A8
9D00417C  00A22821   ADDU A1, A1, V0
856:                 			if (res != FR_OK)
9D004180  14400020   BNE V0, ZERO, 0x9D004204
9D004184  24030001   ADDIU V1, ZERO, 1
857:                 				break;
858:                 			p = &fs->win[clst * 2 % SS(fs)];
9D004188  00118840   SLL S1, S1, 1
9D00418C  323101FF   ANDI S1, S1, 511
859:                 			ST_WORD(p, (PF_WORD)val)
9D004190  02111821   ADDU V1, S0, S1
9D004194  A0720030   SB S2, 48(V1)
9D004198  7E523A00   EXT S2, S2, 8, 8
860:                 			;
861:                 			break;
9D00419C  0B401080   J 0x9D004200
9D0041A0  A0720031   SB S2, 49(V1)
862:                 
863:                 		case FS_FAT32:
864:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
9D0041A4  000529C2   SRL A1, A1, 7
9D0041A8  8C820020   LW V0, 32(A0)
9D0041AC  0F400E6A   JAL 0x9D0039A8
9D0041B0  00A22821   ADDU A1, A1, V0
865:                 			if (res != FR_OK)
9D0041B4  14400013   BNE V0, ZERO, 0x9D004204
9D0041B8  24030001   ADDIU V1, ZERO, 1
866:                 				break;
867:                 			p = &fs->win[clst * 4 % SS(fs)];
9D0041BC  00118880   SLL S1, S1, 2
9D0041C0  323101FF   ANDI S1, S1, 511
9D0041C4  26230030   ADDIU V1, S1, 48
9D0041C8  02031821   ADDU V1, S0, V1
868:                 			val |= LD_DWORD(p) & 0xF0000000;
9D0041CC  90640003   LBU A0, 3(V1)
9D0041D0  00042600   SLL A0, A0, 24
9D0041D4  02118821   ADDU S1, S0, S1
9D0041D8  3C05F000   LUI A1, -4096
9D0041DC  00852024   AND A0, A0, A1
9D0041E0  00929025   OR S2, A0, S2
869:                 			ST_DWORD(p, val)
9D0041E4  A2320030   SB S2, 48(S1)
9D0041E8  7E443A00   EXT A0, S2, 8, 8
9D0041EC  A0640001   SB A0, 1(V1)
9D0041F0  00122402   SRL A0, S2, 16
9D0041F4  A0640002   SB A0, 2(V1)
9D0041F8  00129602   SRL S2, S2, 24
9D0041FC  A0720003   SB S2, 3(V1)
870:                 			;
871:                 			break;
872:                 
873:                 		default:
874:                 			res = FR_INT_ERR;
875:                 		}
876:                 		fs->wflag = 1;
9D004200  24030001   ADDIU V1, ZERO, 1
9D004204  A2030004   SB V1, 4(S0)
877:                 	}
878:                 
879:                 	return res;
880:                 }
9D004208  8FBF0024   LW RA, 36(SP)
9D00420C  8FB30020   LW S3, 32(SP)
9D004210  8FB2001C   LW S2, 28(SP)
9D004214  8FB10018   LW S1, 24(SP)
9D004218  8FB00014   LW S0, 20(SP)
9D00421C  03E00008   JR RA
9D004220  27BD0028   ADDIU SP, SP, 40
881:                 #endif /* !_FS_READONLY */
882:                 
883:                 /*-----------------------------------------------------------------------*/
884:                 /* FAT handling - Remove a cluster chain                                 */
885:                 /*-----------------------------------------------------------------------*/
886:                 #if !_FS_READONLY
887:                 static FRESULT remove_chain(FATFS *fs, /* File system object */
888:                 DWORD clst /* Cluster# to remove a chain from */
889:                 ) {
9D004AE4  27BDFFD0   ADDIU SP, SP, -48
9D004AE8  AFBF002C   SW RA, 44(SP)
9D004AEC  AFB50028   SW S5, 40(SP)
9D004AF0  AFB40024   SW S4, 36(SP)
9D004AF4  AFB30020   SW S3, 32(SP)
9D004AF8  AFB2001C   SW S2, 28(SP)
9D004AFC  AFB10018   SW S1, 24(SP)
9D004B00  AFB00014   SW S0, 20(SP)
9D004B04  00808821   ADDU S1, A0, ZERO
9D004B08  00A09021   ADDU S2, A1, ZERO
890:                 	FRESULT res;
891:                 	DWORD nxt;
892:                 #if _USE_ERASE
893:                 	DWORD scl = clst, ecl = clst, resion[2];
894:                 #endif
895:                 
896:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D004B0C  2CA30002   SLTIU V1, A1, 2
9D004B10  14600025   BNE V1, ZERO, 0x9D004BA8
9D004B14  24020002   ADDIU V0, ZERO, 2
9D004B18  8C830018   LW V1, 24(A0)
9D004B1C  00A3182B   SLTU V1, A1, V1
9D004B20  14600003   BNE V1, ZERO, 0x9D004B30
9D004B24  24140001   ADDIU S4, ZERO, 1
897:                 		res = FR_INT_ERR;
898:                 
899:                 	} else {
900:                 		res = FR_OK;
901:                 		while (clst < fs->n_fatent) { /* Not a last link? */
9D004B84  8E230018   LW V1, 24(S1)
9D004B88  0203182B   SLTU V1, S0, V1
9D004B8C  1460FFEA   BNE V1, ZERO, 0x9D004B38
9D004B90  02009021   ADDU S2, S0, ZERO
902:                 			nxt = get_fat(fs, clst); /* Get cluster status */
9D004B38  02202021   ADDU A0, S1, ZERO
9D004B3C  0F400F4A   JAL get_fat
9D004B40  02402821   ADDU A1, S2, ZERO
903:                 			if (nxt == 0)
9D004B44  10400015   BEQ V0, ZERO, 0x9D004B9C
9D004B48  00408021   ADDU S0, V0, ZERO
9D004B9C  0B4012EA   J 0x9D004BA8
9D004BA0  00001021   ADDU V0, ZERO, ZERO
904:                 				break; /* Empty cluster? */
905:                 			if (nxt == 1) {
9D004B4C  50540016   BEQL V0, S4, 0x9D004BA8
9D004B50  24020002   ADDIU V0, ZERO, 2
906:                 				res = FR_INT_ERR;
907:                 				break;
908:                 			} /* Internal error? */
909:                 			if (nxt == 0xFFFFFFFF) {
9D004B30  2413FFFF   ADDIU S3, ZERO, -1
9D004B54  10530013   BEQ V0, S3, 0x9D004BA4
9D004B58  02202021   ADDU A0, S1, ZERO
910:                 				res = FR_DISK_ERR;
9D004BA4  24020001   ADDIU V0, ZERO, 1
911:                 				break;
912:                 			} /* Disk error? */
913:                 			res = put_fat(fs, clst, 0); /* Mark the cluster "empty" */
9D004B5C  02402821   ADDU A1, S2, ZERO
9D004B60  0F40101A   JAL put_fat
9D004B64  00003021   ADDU A2, ZERO, ZERO
914:                 			if (res != FR_OK)
9D004B68  14400010   BNE V0, ZERO, 0x9D004BAC
9D004B6C  8FBF002C   LW RA, 44(SP)
915:                 				break;
916:                 			if (fs->free_clust != 0xFFFFFFFF) { /* Update FSInfo */
9D004B70  8E230010   LW V1, 16(S1)
9D004B74  10730003   BEQ V1, S3, 0x9D004B84
9D004B78  24630001   ADDIU V1, V1, 1
917:                 				fs->free_clust++;
9D004B7C  AE230010   SW V1, 16(S1)
918:                 				fs->fsi_flag = 1;
9D004B34  24150001   ADDIU S5, ZERO, 1
9D004B80  A2350005   SB S5, 5(S1)
919:                 			}
920:                 #if _USE_ERASE
921:                 			if (ecl + 1 == nxt) { /* Next cluster is contiguous */
922:                 				ecl = nxt;
923:                 			} else { /* End of contiguous clusters */
924:                 				resion[0] = clust2sect(fs, scl); /* Start sector */
925:                 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1; /* End sector */
926:                 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion); /* Erase the block */
927:                 				scl = ecl = nxt;
928:                 			}
929:                 #endif
930:                 			clst = nxt; /* Next cluster */
931:                 		}
932:                 	}
933:                 
934:                 	return res;
935:                 }
9D004B28  0B4012EB   J 0x9D004BAC
9D004B2C  8FBF002C   LW RA, 44(SP)
9D004B94  0B4012EB   J 0x9D004BAC
9D004B98  8FBF002C   LW RA, 44(SP)
9D004BA8  8FBF002C   LW RA, 44(SP)
9D004BAC  8FB50028   LW S5, 40(SP)
9D004BB0  8FB40024   LW S4, 36(SP)
9D004BB4  8FB30020   LW S3, 32(SP)
9D004BB8  8FB2001C   LW S2, 28(SP)
9D004BBC  8FB10018   LW S1, 24(SP)
9D004BC0  8FB00014   LW S0, 20(SP)
9D004BC4  03E00008   JR RA
9D004BC8  27BD0030   ADDIU SP, SP, 48
936:                 #endif
937:                 
938:                 /*-----------------------------------------------------------------------*/
939:                 /* FAT handling - Stretch or Create a cluster chain                      */
940:                 /*-----------------------------------------------------------------------*/
941:                 #if !_FS_READONLY
942:                 static DWORD create_chain( /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
943:                 FATFS *fs, /* File system object */
944:                 DWORD clst /* Cluster# to stretch. 0 means create a new chain. */
945:                 ) {
9D004224  27BDFFD0   ADDIU SP, SP, -48
9D004228  AFBF002C   SW RA, 44(SP)
9D00422C  AFB60028   SW S6, 40(SP)
9D004230  AFB50024   SW S5, 36(SP)
9D004234  AFB40020   SW S4, 32(SP)
9D004238  AFB3001C   SW S3, 28(SP)
9D00423C  AFB20018   SW S2, 24(SP)
9D004240  AFB10014   SW S1, 20(SP)
9D004244  AFB00010   SW S0, 16(SP)
9D004248  00808821   ADDU S1, A0, ZERO
946:                 	DWORD cs, ncl, scl;
947:                 	FRESULT res;
948:                 
949:                 	if (clst == 0) { /* Create a new chain */
9D00424C  14A00009   BNE A1, ZERO, 0x9D004274
9D004250  00A0B021   ADDU S6, A1, ZERO
950:                 		scl = fs->last_clust; /* Get suggested start point */
9D004254  8C92000C   LW S2, 12(A0)
951:                 		if (!scl || scl >= fs->n_fatent)
9D004258  52400011   BEQL S2, ZERO, 0x9D0042A0
9D00425C  24120001   ADDIU S2, ZERO, 1
9D004260  8C830018   LW V1, 24(A0)
9D004264  0243182B   SLTU V1, S2, V1
952:                 			scl = 1;
9D004268  24020001   ADDIU V0, ZERO, 1
9D00426C  0B4010A8   J 0x9D0042A0
9D004270  0043900A   MOVZ S2, V0, V1
953:                 	} else { /* Stretch the current chain */
954:                 		cs = get_fat(fs, clst); /* Check the cluster status */
9D004274  0F400F4A   JAL get_fat
9D004278  00000000   NOP
955:                 		if (cs < 2)
9D00427C  2C430002   SLTIU V1, V0, 2
9D004280  5460003F   BNEL V1, ZERO, 0x9D004380
9D004284  24020001   ADDIU V0, ZERO, 1
956:                 			return 1; /* It is an invalid cluster */
957:                 		if (cs < fs->n_fatent)
9D004288  8E230018   LW V1, 24(S1)
9D00428C  0043182B   SLTU V1, V0, V1
9D004290  10600003   BEQ V1, ZERO, 0x9D0042A0
9D004294  02C09021   ADDU S2, S6, ZERO
958:                 			return cs; /* It is already followed by next cluster */
959:                 		scl = clst;
960:                 	}
961:                 
962:                 	ncl = scl; /* Start cluster */
9D0042A0  02408021   ADDU S0, S2, ZERO
963:                 	for (;;) {
964:                 		ncl++; /* Next cluster */
9D0042B0  26100001   ADDIU S0, S0, 1
965:                 		if (ncl >= fs->n_fatent) { /* Wrap around */
9D0042B4  8E220018   LW V0, 24(S1)
9D0042B8  0202102B   SLTU V0, S0, V0
9D0042BC  14400004   BNE V0, ZERO, 0x9D0042D0
9D0042C0  02202021   ADDU A0, S1, ZERO
966:                 			ncl = 2;
967:                 			if (ncl > scl)
9D0042A4  2E550002   SLTIU S5, S2, 2
9D0042C4  16A0002D   BNE S5, ZERO, 0x9D00437C
9D0042C8  24100002   ADDIU S0, ZERO, 2
968:                 				return 0; /* No free cluster */
969:                 		}
970:                 		cs = get_fat(fs, ncl); /* Get the cluster status */
9D0042CC  02202021   ADDU A0, S1, ZERO
9D0042D0  0F400F4A   JAL get_fat
9D0042D4  02002821   ADDU A1, S0, ZERO
971:                 		if (cs == 0)
9D0042D8  50400009   BEQL V0, ZERO, 0x9D004300
9D0042DC  02009021   ADDU S2, S0, ZERO
972:                 			break; /* Found a free cluster */
973:                 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
9D0042A8  2413FFFF   ADDIU S3, ZERO, -1
9D0042AC  24140001   ADDIU S4, ZERO, 1
9D0042E0  10530028   BEQ V0, S3, 0x9D004384
9D0042E4  8FBF002C   LW RA, 44(SP)
9D0042E8  50540027   BEQL V0, S4, 0x9D004388
9D0042EC  8FB60028   LW S6, 40(SP)
974:                 			return cs;
975:                 		if (ncl == scl)
9D0042F0  1612FFF0   BNE S0, S2, 0x9D0042B4
9D0042F4  26100001   ADDIU S0, S0, 1
976:                 			return 0; /* No free cluster */
9D0042F8  0B4010E0   J 0x9D004380
9D0042FC  00001021   ADDU V0, ZERO, ZERO
977:                 	}
978:                 
979:                 	res = put_fat(fs, ncl, 0x0FFFFFFF); /* Mark the new cluster "last link" */
9D004300  02202021   ADDU A0, S1, ZERO
9D004304  02002821   ADDU A1, S0, ZERO
9D004308  3C060FFF   LUI A2, 4095
9D00430C  0F40101A   JAL put_fat
9D004310  34C6FFFF   ORI A2, A2, -1
980:                 	if (res == FR_OK && clst != 0) {
9D004314  54400014   BNEL V0, ZERO, 0x9D004368
9D004318  38420001   XORI V0, V0, 1
9D00431C  52C00008   BEQL S6, ZERO, 0x9D004340
9D004320  AE32000C   SW S2, 12(S1)
981:                 		res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
9D004324  02202021   ADDU A0, S1, ZERO
9D004328  02C02821   ADDU A1, S6, ZERO
9D00432C  0F40101A   JAL put_fat
9D004330  02003021   ADDU A2, S0, ZERO
982:                 	}
983:                 	if (res == FR_OK) {
9D004334  5440000C   BNEL V0, ZERO, 0x9D004368
9D004338  38420001   XORI V0, V0, 1
984:                 		fs->last_clust = ncl; /* Update FSINFO */
9D00433C  AE32000C   SW S2, 12(S1)
985:                 		if (fs->free_clust != 0xFFFFFFFF) {
9D004340  8E230010   LW V1, 16(S1)
9D004344  2404FFFF   ADDIU A0, ZERO, -1
9D004348  1064000D   BEQ V1, A0, 0x9D004380
9D00434C  02001021   ADDU V0, S0, ZERO
986:                 			fs->free_clust--;
9D004350  2463FFFF   ADDIU V1, V1, -1
9D004354  AE230010   SW V1, 16(S1)
987:                 			fs->fsi_flag = 1;
9D004358  24020001   ADDIU V0, ZERO, 1
9D00435C  A2220005   SB V0, 5(S1)
9D004360  0B4010E0   J 0x9D004380
9D004364  02001021   ADDU V0, S0, ZERO
988:                 		}
989:                 	} else {
990:                 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
9D004368  2403FFFF   ADDIU V1, ZERO, -1
9D00436C  24040001   ADDIU A0, ZERO, 1
9D004370  0082180B   MOVN V1, A0, V0
9D004374  0B4010E0   J 0x9D004380
9D004378  00601021   ADDU V0, V1, ZERO
9D00437C  00001021   ADDU V0, ZERO, ZERO
991:                 	}
992:                 
993:                 	return ncl; /* Return new cluster number or error code */
994:                 }
9D004298  0B4010E1   J 0x9D004384
9D00429C  8FBF002C   LW RA, 44(SP)
9D004380  8FBF002C   LW RA, 44(SP)
9D004384  8FB60028   LW S6, 40(SP)
9D004388  8FB50024   LW S5, 36(SP)
9D00438C  8FB40020   LW S4, 32(SP)
9D004390  8FB3001C   LW S3, 28(SP)
9D004394  8FB20018   LW S2, 24(SP)
9D004398  8FB10014   LW S1, 20(SP)
9D00439C  8FB00010   LW S0, 16(SP)
9D0043A0  03E00008   JR RA
9D0043A4  27BD0030   ADDIU SP, SP, 48
995:                 #endif /* !_FS_READONLY */
996:                 
997:                 /*-----------------------------------------------------------------------*/
998:                 /* FAT handling - Convert offset into cluster with link map table        */
999:                 /*-----------------------------------------------------------------------*/
1000:                
1001:                #if _USE_FASTSEEK
1002:                static DWORD clmt_clust( /* <2:Error, >=2:Cluster number */
1003:                FIL* fp, /* Pointer to the file object */
1004:                DWORD ofs /* File offset to be converted to cluster# */
1005:                ) {
1006:                	DWORD cl, ncl, *tbl;
1007:                
1008:                	tbl = fp->cltbl + 1; /* Top of CLMT */
9D00380C  8C820024   LW V0, 36(A0)
9D003810  24470004   ADDIU A3, V0, 4
1009:                	cl = ofs / SS(fp->fs) / fp->fs->csize; /* Cluster order from top of the file */
9D003814  8C860000   LW A2, 0(A0)
9D003818  90C30002   LBU V1, 2(A2)
9D003828  00052A42   SRL A1, A1, 9
9D00382C  00A3001B   DIVU A1, V1
9D003830  006001F4   TEQ V1, ZERO
9D003834  00001812   MFLO V1, 0
9D003838  00001012   MFLO V0, 0
1010:                	for (;;) {
1011:                		ncl = *tbl++; /* Number of cluters in the fragment */
9D00381C  8C460004   LW A2, 4(V0)
9D003850  00603021   ADDU A2, V1, ZERO
9D003860  8C830004   LW V1, 4(A0)
1012:                		if (!ncl)
9D003820  10C00017   BEQ A2, ZERO, 0x9D003880
9D003824  00001021   ADDU V0, ZERO, ZERO
9D003864  5460FFFA   BNEL V1, ZERO, 0x9D003850
9D003868  00461023   SUBU V0, V0, A2
1013:                			return 0; /* End of table? (error) */
9D00386C  03E00008   JR RA
9D003870  00001021   ADDU V0, ZERO, ZERO
1014:                		if (cl < ncl)
9D00383C  0066182B   SLTU V1, V1, A2
9D003840  10600007   BEQ V1, ZERO, 0x9D003860
9D003844  24E40004   ADDIU A0, A3, 4
9D003854  0043182B   SLTU V1, V0, V1
9D003858  14600006   BNE V1, ZERO, 0x9D003874
9D00385C  24840008   ADDIU A0, A0, 8
1015:                			break; /* In this fragment? */
1016:                		cl -= ncl;
1017:                		tbl++; /* Next fragment */
1018:                	}
1019:                	return cl + *tbl; /* Return the cluster number */
9D003848  0B400E1E   J 0x9D003878
9D00384C  8C830000   LW V1, 0(A0)
9D003874  8C830000   LW V1, 0(A0)
9D003878  03E00008   JR RA
9D00387C  00431021   ADDU V0, V0, V1
1020:                }
9D003880  03E00008   JR RA
9D003884  00000000   NOP
1021:                #endif	/* _USE_FASTSEEK */
1022:                
1023:                /*-----------------------------------------------------------------------*/
1024:                /* Directory handling - Set directory index                              */
1025:                /*-----------------------------------------------------------------------*/
1026:                
1027:                static FRESULT dir_sdi(DIR *dj, /* Pointer to directory object */
9D003F54  3294FFFF   ANDI S4, S4, -1
9D003F58  02328823   SUBU S1, S1, S2
9D003F5C  3231FFFF   ANDI S1, S1, -1
9D003F60  2413FFFF   ADDIU S3, ZERO, -1
1028:                PF_WORD idx /* Directory index number */
1029:                ) {
9D003EAC  27BDFFD8   ADDIU SP, SP, -40
9D003EB0  AFBF0024   SW RA, 36(SP)
9D003EB4  AFB40020   SW S4, 32(SP)
9D003EB8  AFB3001C   SW S3, 28(SP)
9D003EBC  AFB20018   SW S2, 24(SP)
9D003EC0  AFB10014   SW S1, 20(SP)
9D003EC4  AFB00010   SW S0, 16(SP)
9D003EC8  00808021   ADDU S0, A0, ZERO
9D003ECC  00A08821   ADDU S1, A1, ZERO
1030:                	DWORD clst;
1031:                	PF_WORD ic;
1032:                
1033:                	dj->index = idx;
9D003ED0  A4850006   SH A1, 6(A0)
1034:                	clst = dj->sclust;
9D003ED4  8C850008   LW A1, 8(A0)
1035:                	if (clst == 1 || clst >= dj->fs->n_fatent) /* Check start cluster range */
9D003ED8  24030001   ADDIU V1, ZERO, 1
9D003EDC  10A30044   BEQ A1, V1, 0x9D003FF0
9D003EE0  24020002   ADDIU V0, ZERO, 2
9D003EE4  8C830000   LW V1, 0(A0)
9D003EE8  8C640018   LW A0, 24(V1)
9D003EEC  00A4202B   SLTU A0, A1, A0
9D003EF0  50800040   BEQL A0, ZERO, 0x9D003FF4
9D003EF4  8FBF0024   LW RA, 36(SP)
1036:                		return FR_INT_ERR;
1037:                	if (!clst && dj->fs->fs_type == FS_FAT32) /* Replace cluster# 0 with root cluster# if in FAT32 */
9D003EF8  54A00012   BNEL A1, ZERO, 0x9D003F44
9D003EFC  90720002   LBU S2, 2(V1)
9D003F00  90640000   LBU A0, 0(V1)
9D003F04  24020003   ADDIU V0, ZERO, 3
9D003F08  54820005   BNEL A0, V0, 0x9D003F20
9D003F0C  AE00000C   SW ZERO, 12(S0)
1038:                		clst = dj->fs->dirbase;
9D003F10  8C650024   LW A1, 36(V1)
1039:                
1040:                	if (clst == 0) { /* Static table (root-dir in FAT12/16) */
9D003F14  54A0000B   BNEL A1, ZERO, 0x9D003F44
9D003F18  90720002   LBU S2, 2(V1)
1041:                		dj->clust = clst;
9D003F1C  AE00000C   SW ZERO, 12(S0)
1042:                		if (idx >= dj->fs->n_rootdir) /* Index is out of range */
9D003F20  94640008   LHU A0, 8(V1)
9D003F24  0224202B   SLTU A0, S1, A0
9D003F28  10800031   BEQ A0, ZERO, 0x9D003FF0
9D003F2C  24020002   ADDIU V0, ZERO, 2
1043:                			return FR_INT_ERR;
1044:                		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D003F30  7E247900   EXT A0, S1, 4, 16
9D003F34  8C620024   LW V0, 36(V1)
9D003F38  00821021   ADDU V0, A0, V0
9D003F3C  0B400FF1   J 0x9D003FC4
9D003F40  AE020010   SW V0, 16(S0)
1045:                	} else { /* Dynamic table (sub-dirs or root-dir in FAT32) */
1046:                		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize; /* Entries per cluster */
9D003F44  00129100   SLL S2, S2, 4
1047:                		while (idx >= ic) { /* Follow cluster chain */
9D003F48  0232102B   SLTU V0, S1, S2
9D003F4C  14400017   BNE V0, ZERO, 0x9D003FAC
9D003F50  0012A023   SUBU S4, ZERO, S2
9D003F98  00521821   ADDU V1, V0, S2
9D003F9C  3063FFFF   ANDI V1, V1, -1
9D003FA0  0072182B   SLTU V1, V1, S2
9D003FA4  5060FFEF   BEQL V1, ZERO, 0x9D003F64
9D003FA8  00408821   ADDU S1, V0, ZERO
1048:                			clst = get_fat(dj->fs, clst); /* Get next cluster */
9D003F64  0F400F4A   JAL get_fat
9D003F68  8E040000   LW A0, 0(S0)
1049:                			if (clst == 0xFFFFFFFF)
9D003F6C  1053001D   BEQ V0, S3, 0x9D003FE4
9D003F70  00402821   ADDU A1, V0, ZERO
1050:                				return FR_DISK_ERR; /* Disk error */
9D003FE4  0B400FFC   J 0x9D003FF0
9D003FE8  24020001   ADDIU V0, ZERO, 1
1051:                			if (clst < 2 || clst >= dj->fs->n_fatent) /* Reached to end of table or int error */
9D003F74  2C420002   SLTIU V0, V0, 2
9D003F78  1440001D   BNE V0, ZERO, 0x9D003FF0
9D003F7C  24020002   ADDIU V0, ZERO, 2
9D003F80  8E020000   LW V0, 0(S0)
9D003F84  8C420018   LW V0, 24(V0)
9D003F88  00A2102B   SLTU V0, A1, V0
9D003F8C  10400017   BEQ V0, ZERO, 0x9D003FEC
9D003F90  02341021   ADDU V0, S1, S4
9D003F94  3042FFFF   ANDI V0, V0, -1
1052:                				return FR_INT_ERR;
9D003FEC  24020002   ADDIU V0, ZERO, 2
1053:                			idx -= ic;
1054:                		}
1055:                		dj->clust = clst;
9D003FAC  AE05000C   SW A1, 12(S0)
1056:                		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D003FB0  0F400F3E   JAL clust2sect
9D003FB4  8E040000   LW A0, 0(S0)
9D003FB8  7E237900   EXT V1, S1, 4, 16
9D003FBC  00621021   ADDU V0, V1, V0
9D003FC0  AE020010   SW V0, 16(S0)
1057:                	}
1058:                
1059:                	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR; /* Ptr to the entry in the sector */
9D003FC4  8E020000   LW V0, 0(S0)
9D003FC8  24420030   ADDIU V0, V0, 48
9D003FCC  3231000F   ANDI S1, S1, 15
9D003FD0  00118940   SLL S1, S1, 5
9D003FD4  00518821   ADDU S1, V0, S1
9D003FD8  AE110014   SW S1, 20(S0)
1060:                
1061:                	return FR_OK; /* Seek succeeded */
9D003FDC  0B400FFC   J 0x9D003FF0
9D003FE0  00001021   ADDU V0, ZERO, ZERO
1062:                }
9D003FF0  8FBF0024   LW RA, 36(SP)
9D003FF4  8FB40020   LW S4, 32(SP)
9D003FF8  8FB3001C   LW S3, 28(SP)
9D003FFC  8FB20018   LW S2, 24(SP)
9D004000  8FB10014   LW S1, 20(SP)
9D004004  8FB00010   LW S0, 16(SP)
9D004008  03E00008   JR RA
9D00400C  27BD0028   ADDIU SP, SP, 40
1063:                
1064:                /*-----------------------------------------------------------------------*/
1065:                /* Directory handling - Move directory index next                        */
1066:                /*-----------------------------------------------------------------------*/
1067:                
1068:                static FRESULT dir_next( /* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
1069:                DIR *dj, /* Pointer to directory object */
1070:                int stretch /* 0: Do not stretch table, 1: Stretch table if needed */
1071:                ) {
9D0043A8  27BDFFD8   ADDIU SP, SP, -40
9D0043AC  AFBF0024   SW RA, 36(SP)
9D0043B0  AFB40020   SW S4, 32(SP)
9D0043B4  AFB3001C   SW S3, 28(SP)
9D0043B8  AFB20018   SW S2, 24(SP)
9D0043BC  AFB10014   SW S1, 20(SP)
9D0043C0  AFB00010   SW S0, 16(SP)
9D0043C4  00808821   ADDU S1, A0, ZERO
9D0043C8  00A08021   ADDU S0, A1, ZERO
1072:                	DWORD clst;
1073:                	PF_WORD i;
1074:                
1075:                	stretch = stretch; /* To suppress warning on read-only cfg. */
1076:                	i = dj->index + 1;
9D0043CC  94920006   LHU S2, 6(A0)
9D0043D0  26520001   ADDIU S2, S2, 1
9D0043D4  3252FFFF   ANDI S2, S2, -1
1077:                	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
9D0043D8  1240006C   BEQ S2, ZERO, 0x9D00458C
9D0043DC  24030004   ADDIU V1, ZERO, 4
9D0043E0  8C820010   LW V0, 16(A0)
9D0043E4  5040006A   BEQL V0, ZERO, 0x9D004590
9D0043E8  00601021   ADDU V0, V1, ZERO
1078:                		return FR_NO_FILE;
1079:                
1080:                	if (!(i % (SS(dj->fs) / SZ_DIR))) { /* Sector changed? */
9D0043EC  3243000F   ANDI V1, S2, 15
9D0043F0  5460005D   BNEL V1, ZERO, 0x9D004568
9D0043F4  A6320006   SH S2, 6(S1)
1081:                		dj->sect++; /* Next sector */
9D0043F8  24420001   ADDIU V0, V0, 1
9D0043FC  AC820010   SW V0, 16(A0)
1082:                
1083:                		if (dj->clust == 0) { /* Static table */
9D004400  8C85000C   LW A1, 12(A0)
9D004404  54A00008   BNEL A1, ZERO, 0x9D004428
9D004408  8C840000   LW A0, 0(A0)
1084:                			if (i >= dj->fs->n_rootdir) /* Report EOT when end of table */
9D00440C  8C820000   LW V0, 0(A0)
9D004410  94420008   LHU V0, 8(V0)
9D004414  0242102B   SLTU V0, S2, V0
9D004418  14400052   BNE V0, ZERO, 0x9D004564
9D00441C  24030004   ADDIU V1, ZERO, 4
1085:                				return FR_NO_FILE;
1086:                		} else { /* Dynamic table */
1087:                			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) { /* Cluster changed? */
9D004428  90820002   LBU V0, 2(A0)
9D00442C  2442FFFF   ADDIU V0, V0, -1
9D004430  00121902   SRL V1, S2, 4
9D004434  00431024   AND V0, V0, V1
9D004438  5440004B   BNEL V0, ZERO, 0x9D004568
9D00443C  A6320006   SH S2, 6(S1)
1088:                				clst = get_fat(dj->fs, dj->clust); /* Get next cluster */
9D004440  0F400F4A   JAL get_fat
9D004444  00000000   NOP
9D004448  00409821   ADDU S3, V0, ZERO
1089:                				if (clst <= 1)
9D00444C  2C420002   SLTIU V0, V0, 2
9D004450  1440004E   BNE V0, ZERO, 0x9D00458C
9D004454  24030002   ADDIU V1, ZERO, 2
1090:                					return FR_INT_ERR;
1091:                				if (clst == 0xFFFFFFFF)
9D004458  2402FFFF   ADDIU V0, ZERO, -1
9D00445C  1262004B   BEQ S3, V0, 0x9D00458C
9D004460  24030001   ADDIU V1, ZERO, 1
1092:                					return FR_DISK_ERR;
1093:                				if (clst >= dj->fs->n_fatent) { /* When it reached end of dynamic table */
9D004464  8E240000   LW A0, 0(S1)
9D004468  8C820018   LW V0, 24(A0)
9D00446C  0262102B   SLTU V0, S3, V0
9D004470  54400038   BNEL V0, ZERO, 0x9D004554
9D004474  AE33000C   SW S3, 12(S1)
1094:                #if !_FS_READONLY
1095:                					PF_BYTE c;
1096:                					if (!stretch)
9D004478  12000044   BEQ S0, ZERO, 0x9D00458C
9D00447C  24030004   ADDIU V1, ZERO, 4
1097:                						return FR_NO_FILE; /* When do not stretch, report EOT */
1098:                					clst = create_chain(dj->fs, dj->clust); /* Stretch cluster chain */
9D004480  0F401089   JAL 0x9D004224
9D004484  8E25000C   LW A1, 12(S1)
9D004488  00409821   ADDU S3, V0, ZERO
1099:                					if (clst == 0)
9D00448C  1040003F   BEQ V0, ZERO, 0x9D00458C
9D004490  24030007   ADDIU V1, ZERO, 7
1100:                						return FR_DENIED; /* No free cluster */
1101:                					if (clst == 1)
9D004494  24020001   ADDIU V0, ZERO, 1
9D004498  1262003C   BEQ S3, V0, 0x9D00458C
9D00449C  24030002   ADDIU V1, ZERO, 2
1102:                						return FR_INT_ERR;
1103:                					if (clst == 0xFFFFFFFF)
9D0044A0  2402FFFF   ADDIU V0, ZERO, -1
9D0044A4  12620039   BEQ S3, V0, 0x9D00458C
9D0044A8  24030001   ADDIU V1, ZERO, 1
1104:                						return FR_DISK_ERR;
1105:                					/* Clean-up stretched table */
1106:                					if (move_window(dj->fs, 0))
9D0044AC  8E240000   LW A0, 0(S1)
9D0044B0  0F400E6A   JAL 0x9D0039A8
9D0044B4  00002821   ADDU A1, ZERO, ZERO
9D0044B8  14400034   BNE V0, ZERO, 0x9D00458C
9D0044BC  24030001   ADDIU V1, ZERO, 1
1107:                						return FR_DISK_ERR; /* Flush active window */
1108:                					mem_set(dj->fs->win, 0, SS(dj->fs)); /* Clear window buffer */
9D0044C0  8E240000   LW A0, 0(S1)
9D0044C4  24840030   ADDIU A0, A0, 48
9D0044C8  00002821   ADDU A1, ZERO, ZERO
9D0044CC  0F400DFA   JAL 0x9D0037E8
9D0044D0  24060200   ADDIU A2, ZERO, 512
1109:                					dj->fs->winsect = clust2sect(dj->fs, clst); /* Cluster start sector */
9D0044D4  8E300000   LW S0, 0(S1)
9D0044D8  02002021   ADDU A0, S0, ZERO
9D0044DC  0F400F3E   JAL clust2sect
9D0044E0  02602821   ADDU A1, S3, ZERO
9D0044E4  AE02002C   SW V0, 44(S0)
1110:                					for (c = 0; c < dj->fs->csize; c++) { /* Fill the new cluster with 0 */
9D0044E8  8E220000   LW V0, 0(S1)
9D0044EC  90430002   LBU V1, 2(V0)
9D0044F0  10600014   BEQ V1, ZERO, 0x9D004544
9D0044F4  00008021   ADDU S0, ZERO, ZERO
9D004524  321000FF   ANDI S0, S0, 255
9D004528  8E220000   LW V0, 0(S1)
9D00452C  90430002   LBU V1, 2(V0)
9D004530  0203182B   SLTU V1, S0, V1
9D004534  5460FFF2   BNEL V1, ZERO, 0x9D004500
9D004538  A0540004   SB S4, 4(V0)
1111:                						dj->fs->wflag = 1;
9D0044F8  24140001   ADDIU S4, ZERO, 1
9D0044FC  A0540004   SB S4, 4(V0)
1112:                						if (move_window(dj->fs, 0))
9D004500  8E240000   LW A0, 0(S1)
9D004504  0F400E6A   JAL 0x9D0039A8
9D004508  00002821   ADDU A1, ZERO, ZERO
9D00450C  1440001E   BNE V0, ZERO, 0x9D004588
9D004510  26100001   ADDIU S0, S0, 1
1113:                							return FR_DISK_ERR;
9D004588  24030001   ADDIU V1, ZERO, 1
1114:                						dj->fs->winsect++;
9D004514  8E220000   LW V0, 0(S1)
9D004518  8C43002C   LW V1, 44(V0)
9D00451C  24630001   ADDIU V1, V1, 1
9D004520  AC43002C   SW V1, 44(V0)
1115:                					}
1116:                					dj->fs->winsect -= c; /* Rewind window address */
9D00453C  0B401152   J 0x9D004548
9D004540  8C43002C   LW V1, 44(V0)
9D004544  8C43002C   LW V1, 44(V0)
9D004548  00708023   SUBU S0, V1, S0
9D00454C  AC50002C   SW S0, 44(V0)
1117:                #else
1118:                					return FR_NO_FILE; /* Report EOT */
1119:                #endif
1120:                				}
1121:                				dj->clust = clst; /* Initialize data for new cluster */
9D004550  AE33000C   SW S3, 12(S1)
1122:                				dj->sect = clust2sect(dj->fs, clst);
9D004554  8E240000   LW A0, 0(S1)
9D004558  0F400F3E   JAL clust2sect
9D00455C  02602821   ADDU A1, S3, ZERO
9D004560  AE220010   SW V0, 16(S1)
1123:                			}
1124:                		}
1125:                	}
1126:                
1127:                	dj->index = i;
9D004564  A6320006   SH S2, 6(S1)
1128:                	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
9D004568  8E220000   LW V0, 0(S1)
9D00456C  24420030   ADDIU V0, V0, 48
9D004570  3252000F   ANDI S2, S2, 15
9D004574  00129140   SLL S2, S2, 5
9D004578  00529021   ADDU S2, V0, S2
9D00457C  AE320014   SW S2, 20(S1)
1129:                
1130:                	return FR_OK;
9D004580  0B401163   J 0x9D00458C
9D004584  00001821   ADDU V1, ZERO, ZERO
1131:                }
9D004420  0B401164   J 0x9D004590
9D004424  00601021   ADDU V0, V1, ZERO
9D00458C  00601021   ADDU V0, V1, ZERO
9D004590  8FBF0024   LW RA, 36(SP)
9D004594  8FB40020   LW S4, 32(SP)
9D004598  8FB3001C   LW S3, 28(SP)
9D00459C  8FB20018   LW S2, 24(SP)
9D0045A0  8FB10014   LW S1, 20(SP)
9D0045A4  8FB00010   LW S0, 16(SP)
9D0045A8  03E00008   JR RA
9D0045AC  27BD0028   ADDIU SP, SP, 40
1132:                
1133:                /*-----------------------------------------------------------------------*/
1134:                /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
1135:                /*-----------------------------------------------------------------------*/
1136:                #if _USE_LFN
1137:                static
1138:                const PF_BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30}; /* Offset of LFN chars in the directory entry */
1139:                
1140:                static
1141:                int cmp_lfn ( /* 1:Matched, 0:Not matched */
1142:                		WCHAR *lfnbuf, /* Pointer to the LFN to be compared */
1143:                		PF_BYTE *dir /* Pointer to the directory entry containing a part of LFN */
1144:                )
1145:                {
1146:                	UINT i, s;
1147:                	WCHAR wc, uc;
1148:                
1149:                	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13; /* Get offset in the LFN buffer */
1150:                	s = 0; wc = 1;
1151:                	do {
1152:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1153:                		if (wc) { /* Last char has not been processed */
1154:                			wc = ff_wtoupper(uc); /* Convert it to upper case */
1155:                			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++])) /* Compare it */
1156:                			return 0; /* Not matched */
1157:                		} else {
1158:                			if (uc != 0xFFFF) return 0; /* Check filler */
1159:                		}
1160:                	}while (++s < 13); /* Repeat until all chars in the entry are checked */
1161:                
1162:                	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i]) /* Last segment matched but different length */
1163:                	return 0;
1164:                
1165:                	return 1; /* The part of LFN matched */
1166:                }
1167:                
1168:                static
1169:                int pick_lfn ( /* 1:Succeeded, 0:Buffer overflow */
1170:                		WCHAR *lfnbuf, /* Pointer to the Unicode-LFN buffer */
1171:                		PF_BYTE *dir /* Pointer to the directory entry */
1172:                )
1173:                {
1174:                	UINT i, s;
1175:                	WCHAR wc, uc;
1176:                
1177:                	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13; /* Offset in the LFN buffer */
1178:                
1179:                	s = 0; wc = 1;
1180:                	do {
1181:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1182:                		if (wc) { /* Last char has not been processed */
1183:                			if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1184:                			lfnbuf[i++] = wc = uc; /* Store it */
1185:                		} else {
1186:                			if (uc != 0xFFFF) return 0; /* Check filler */
1187:                		}
1188:                	}while (++s < 13); /* Read all character in the entry */
1189:                
1190:                	if (dir[LDIR_Ord] & LLE) { /* Put terminator if it is the last LFN part */
1191:                		if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1192:                		lfnbuf[i] = 0;
1193:                	}
1194:                
1195:                	return 1;
1196:                }
1197:                
1198:                #if !_FS_READONLY
1199:                static
1200:                void fit_lfn (
1201:                		const WCHAR *lfnbuf, /* Pointer to the LFN buffer */
1202:                		PF_BYTE *dir, /* Pointer to the directory entry */
1203:                		PF_BYTE ord, /* LFN order (1-20) */
1204:                		PF_BYTE sum /* SFN sum */
1205:                )
1206:                {
1207:                	UINT i, s;
1208:                	WCHAR wc;
1209:                
1210:                	dir[LDIR_Chksum] = sum; /* Set check sum */
1211:                	dir[LDIR_Attr] = AM_LFN; /* Set attribute. LFN entry */
1212:                	dir[LDIR_Type] = 0;
1213:                	ST_WORD(dir+LDIR_FstClusLO, 0);
1214:                
1215:                	i = (ord - 1) * 13; /* Get offset in the LFN buffer */
1216:                	s = wc = 0;
1217:                	do {
1218:                		if (wc != 0xFFFF) wc = lfnbuf[i++]; /* Get an effective char */
1219:                		ST_WORD(dir+LfnOfs[s], wc); /* Put it */
1220:                		if (!wc) wc = 0xFFFF; /* Padding chars following last char */
1221:                	}while (++s < 13);
1222:                	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE; /* Bottom LFN part is the start of LFN sequence */
1223:                	dir[LDIR_Ord] = ord; /* Set the LFN order */
1224:                }
1225:                
1226:                #endif
1227:                #endif
1228:                
1229:                /*-----------------------------------------------------------------------*/
1230:                /* Create numbered name                                                  */
1231:                /*-----------------------------------------------------------------------*/
1232:                #if _USE_LFN
1233:                void gen_numname (
1234:                		PF_BYTE *dst, /* Pointer to generated SFN */
1235:                		const PF_BYTE *src, /* Pointer to source SFN to be modified */
1236:                		const WCHAR *lfn, /* Pointer to LFN */
1237:                		PF_WORD seq /* Sequence number */
1238:                )
1239:                {
1240:                	PF_BYTE ns[8], c;
1241:                	UINT i, j;
1242:                
1243:                	mem_cpy(dst, src, 11);
1244:                
1245:                	if (seq > 5) { /* On many collisions, generate a hash number instead of sequential number */
1246:                		do seq = (seq >> 1) + (seq << 15) + (PF_WORD)*lfn++; while (*lfn);
1247:                	}
1248:                
1249:                	/* itoa (hexdecimal) */
1250:                	i = 7;
1251:                	do {
1252:                		c = (seq % 16) + '0';
1253:                		if (c > '9') c += 7;
1254:                		ns[i--] = c;
1255:                		seq /= 16;
1256:                	}while (seq);
1257:                	ns[i] = '~';
1258:                
1259:                	/* Append the number */
1260:                	for (j = 0; j < i && dst[j] != ' '; j++) {
1261:                		if (IsDBCS1(dst[j])) {
1262:                			if (j == i - 1) break;
1263:                			j++;
1264:                		}
1265:                	}
1266:                	do {
1267:                		dst[j++] = (i < 8) ? ns[i++] : ' ';
1268:                	}while (j < 8);
1269:                }
1270:                #endif
1271:                
1272:                /*-----------------------------------------------------------------------*/
1273:                /* Calculate sum of an SFN                                               */
1274:                /*-----------------------------------------------------------------------*/
1275:                #if _USE_LFN
1276:                static
1277:                PF_BYTE sum_sfn (
1278:                		const PF_BYTE *dir /* Ptr to directory entry */
1279:                )
1280:                {
1281:                	PF_BYTE sum = 0;
1282:                	UINT n = 11;
1283:                
1284:                	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
1285:                	return sum;
1286:                }
1287:                #endif
1288:                
1289:                /*-----------------------------------------------------------------------*/
1290:                /* Directory handling - Find an object in the directory                  */
1291:                /*-----------------------------------------------------------------------*/
1292:                
1293:                static FRESULT dir_find(DIR *dj /* Pointer to the directory object linked to the file name */
1294:                ) {
1295:                	FRESULT res;
1296:                	PF_BYTE c, *dir;
1297:                #if _USE_LFN
1298:                	PF_BYTE a, ord, sum;
1299:                #endif
1300:                
1301:                	res = dir_sdi(dj, 0); /* Rewind directory object */
9D004814  02402021   ADDU A0, S2, ZERO
9D004818  0F400FAB   JAL 0x9D003EAC
9D00481C  00002821   ADDU A1, ZERO, ZERO
1302:                	if (res != FR_OK)
9D004820  5440001F   BNEL V0, ZERO, 0x9D0048A0
9D004824  8E430018   LW V1, 24(S2)
1303:                		return res;
1304:                
1305:                #if _USE_LFN
1306:                	ord = sum = 0xFF;
1307:                #endif
1308:                	do {
1309:                		res = move_window(dj->fs, dj->sect);
9D004828  8E440000   LW A0, 0(S2)
9D00482C  0F400E6A   JAL 0x9D0039A8
9D004830  8E450010   LW A1, 16(S2)
1310:                		if (res != FR_OK)
9D004834  5440001A   BNEL V0, ZERO, 0x9D0048A0
9D004838  8E430018   LW V1, 24(S2)
1311:                			break;
1312:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D00483C  8E470014   LW A3, 20(S2)
1313:                		c = dir[DIR_Name];
1314:                		if (c == 0) {
9D004840  90E30000   LBU V1, 0(A3)
9D004844  50600046   BEQL V1, ZERO, 0x9D004960
9D004848  8E420018   LW V0, 24(S2)
1315:                			res = FR_NO_FILE;
1316:                			break;
1317:                		} /* Reached to end of table */
1318:                #if _USE_LFN	/* LFN configuration */
1319:                		a = dir[DIR_Attr] & AM_MASK;
1320:                		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1321:                			ord = 0xFF;
1322:                		} else {
1323:                			if (a == AM_LFN) { /* An LFN entry is found */
1324:                				if (dj->lfn) {
1325:                					if (c & LLE) { /* Is it start of LFN sequence? */
1326:                						sum = dir[LDIR_Chksum];
1327:                						c &= ~LLE; ord = c; /* LFN start order */
1328:                						dj->lfn_idx = dj->index;
1329:                					}
1330:                					/* Check validity of the LFN entry and compare it with given name */
1331:                					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1332:                				}
1333:                			} else { /* An SFN entry is found */
1334:                				if (!ord && sum == sum_sfn(dir)) break; /* LFN matched? */
1335:                				ord = 0xFF; dj->lfn_idx = 0xFFFF; /* Reset LFN sequence */
1336:                				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break; /* SFN matched? */
1337:                			}
1338:                		}
1339:                #else		/* Non LFN configuration */
1340:                		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
9D00484C  90E9000B   LBU T1, 11(A3)
9D004850  31230008   ANDI V1, T1, 8
9D004854  1460000C   BNE V1, ZERO, 0x9D004888
9D004858  00E01821   ADDU V1, A3, ZERO
9D00485C  8E4A0018   LW T2, 24(S2)
1341:                			break;
1342:                #endif
1343:                		res = dir_next(dj, 0); /* Next entry */
9D004888  02402021   ADDU A0, S2, ZERO
9D00488C  0F4010EA   JAL 0x9D0043A8
9D004890  00002821   ADDU A1, ZERO, ZERO
1344:                	} while (res == FR_OK);
9D004894  5040FFE5   BEQL V0, ZERO, 0x9D00482C
9D004898  8E440000   LW A0, 0(S2)
1345:                
1346:                	return res;
1347:                }
1348:                
1349:                /*-----------------------------------------------------------------------*/
1350:                /* Read an object from the directory                                     */
1351:                /*-----------------------------------------------------------------------*/
1352:                #if _FS_MINIMIZE <= 1
1353:                static FRESULT dir_read(DIR *dj /* Pointer to the directory object that pointing the entry to be read */
1354:                ) {
9D004A3C  27BDFFE0   ADDIU SP, SP, -32
9D004A40  AFBF001C   SW RA, 28(SP)
9D004A44  AFB20018   SW S2, 24(SP)
9D004A48  AFB10014   SW S1, 20(SP)
9D004A4C  AFB00010   SW S0, 16(SP)
9D004A50  00808021   ADDU S0, A0, ZERO
1355:                	FRESULT res;
1356:                	PF_BYTE c, *dir;
1357:                #if _USE_LFN
1358:                	PF_BYTE a, ord = 0xFF, sum = 0xFF;
1359:                #endif
1360:                
1361:                	res = FR_NO_FILE;
9D004A54  24020004   ADDIU V0, ZERO, 4
1362:                	while (dj->sect) {
9D004A5C  0B4012AD   J 0x9D004AB4
9D004A60  2412002E   ADDIU S2, ZERO, 46
9D004AB4  8E050010   LW A1, 16(S0)
9D004AB8  14A0FFEA   BNE A1, ZERO, 0x9D004A64
9D004ABC  00000000   NOP
1363:                		res = move_window(dj->fs, dj->sect);
9D004A64  0F400E6A   JAL 0x9D0039A8
9D004A68  8E040000   LW A0, 0(S0)
1364:                		if (res != FR_OK)
9D004A6C  54400017   BNEL V0, ZERO, 0x9D004ACC
9D004A70  AE000010   SW ZERO, 16(S0)
1365:                			break;
1366:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D004A74  8E040014   LW A0, 20(S0)
1367:                		c = dir[DIR_Name];
9D004A78  90830000   LBU V1, 0(A0)
1368:                		if (c == 0) {
9D004A7C  50600012   BEQL V1, ZERO, 0x9D004AC8
9D004A80  24020004   ADDIU V0, ZERO, 4
1369:                			res = FR_NO_FILE;
1370:                			break;
1371:                		} /* Reached to end of table */
1372:                #if _USE_LFN	/* LFN configuration */
1373:                		a = dir[DIR_Attr] & AM_MASK;
1374:                		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1375:                			ord = 0xFF;
1376:                		} else {
1377:                			if (a == AM_LFN) { /* An LFN entry is found */
1378:                				if (c & LLE) { /* Is it start of LFN sequence? */
1379:                					sum = dir[LDIR_Chksum];
1380:                					c &= ~LLE; ord = c;
1381:                					dj->lfn_idx = dj->index;
1382:                				}
1383:                				/* Check LFN validity and capture it */
1384:                				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1385:                			} else { /* An SFN entry is found */
1386:                				if (ord || sum != sum_sfn(dir)) /* Is there a valid LFN? */
1387:                				dj->lfn_idx = 0xFFFF; /* It has no LFN. */
1388:                				break;
1389:                			}
1390:                		}
1391:                #else		/* Non LFN configuration */
1392:                		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL)) /* Is it a valid entry? */
9D004A58  241100E5   ADDIU S1, ZERO, 229
9D004A84  50710007   BEQL V1, S1, 0x9D004AA4
9D004A88  02002021   ADDU A0, S0, ZERO
9D004A8C  50720005   BEQL V1, S2, 0x9D004AA4
9D004A90  02002021   ADDU A0, S0, ZERO
9D004A94  9083000B   LBU V1, 11(A0)
9D004A98  30630008   ANDI V1, V1, 8
9D004A9C  1060000B   BEQ V1, ZERO, 0x9D004ACC
9D004AA0  02002021   ADDU A0, S0, ZERO
1393:                			break;
1394:                #endif
1395:                		res = dir_next(dj, 0); /* Next entry */
9D004AA4  0F4010EA   JAL 0x9D0043A8
9D004AA8  00002821   ADDU A1, ZERO, ZERO
1396:                		if (res != FR_OK)
9D004AAC  54400007   BNEL V0, ZERO, 0x9D004ACC
9D004AB0  AE000010   SW ZERO, 16(S0)
1397:                			break;
1398:                	}
1399:                
1400:                	if (res != FR_OK)
9D004AC0  10400003   BEQ V0, ZERO, 0x9D004AD0
9D004AC4  8FBF001C   LW RA, 28(SP)
1401:                		dj->sect = 0;
9D004AC8  AE000010   SW ZERO, 16(S0)
1402:                
1403:                	return res;
1404:                }
9D004ACC  8FBF001C   LW RA, 28(SP)
9D004AD0  8FB20018   LW S2, 24(SP)
9D004AD4  8FB10014   LW S1, 20(SP)
9D004AD8  8FB00010   LW S0, 16(SP)
9D004ADC  03E00008   JR RA
9D004AE0  27BD0020   ADDIU SP, SP, 32
1405:                #endif
1406:                
1407:                /*-----------------------------------------------------------------------*/
1408:                /* Register an object to the directory                                   */
1409:                /*-----------------------------------------------------------------------*/
1410:                #if !_FS_READONLY
1411:                static FRESULT dir_register( /* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
1412:                DIR *dj /* Target directory with object name to be created */
1413:                ) {
9D004968  27BDFFE0   ADDIU SP, SP, -32
9D00496C  AFBF001C   SW RA, 28(SP)
9D004970  AFB20018   SW S2, 24(SP)
9D004974  AFB10014   SW S1, 20(SP)
9D004978  AFB00010   SW S0, 16(SP)
9D00497C  00808821   ADDU S1, A0, ZERO
1414:                	FRESULT res;
1415:                	PF_BYTE c, *dir;
1416:                #if _USE_LFN	/* LFN configuration */
1417:                	PF_WORD n, ne, is;
1418:                	PF_BYTE sn[12], *fn, sum;
1419:                	WCHAR *lfn;
1420:                
1421:                	fn = dj->fn; lfn = dj->lfn;
1422:                	mem_cpy(sn, fn, 12);
1423:                
1424:                	if (_FS_RPATH && (sn[NS] & NS_DOT)) /* Cannot create dot entry */
1425:                	return FR_INVALID_NAME;
1426:                
1427:                	if (sn[NS] & NS_LOSS) { /* When LFN is out of 8.3 format, generate a numbered name */
1428:                		fn[NS] = 0; dj->lfn = 0; /* Find only SFN */
1429:                		for (n = 1; n < 100; n++) {
1430:                			gen_numname(fn, sn, lfn, n); /* Generate a numbered name */
1431:                			res = dir_find(dj); /* Check if the name collides with existing SFN */
1432:                			if (res != FR_OK) break;
1433:                		}
1434:                		if (n == 100) return FR_DENIED; /* Abort if too many collisions */
1435:                		if (res != FR_NO_FILE) return res; /* Abort if the result is other than 'not collided' */
1436:                		fn[NS] = sn[NS]; dj->lfn = lfn;
1437:                	}
1438:                
1439:                	if (sn[NS] & NS_LFN) { /* When LFN is to be created, reserve an SFN + LFN entries. */
1440:                		for (ne = 0; lfn[ne]; ne++);
1441:                		ne = (ne + 25) / 13;
1442:                	} else { /* Otherwise reserve only an SFN entry. */
1443:                		ne = 1;
1444:                	}
1445:                
1446:                	/* Reserve contiguous entries */
1447:                	res = dir_sdi(dj, 0);
1448:                	if (res != FR_OK) return res;
1449:                	n = is = 0;
1450:                	do {
1451:                		res = move_window(dj->fs, dj->sect);
1452:                		if (res != FR_OK) break;
1453:                		c = *dj->dir; /* Check the entry status */
1454:                		if (c == DDE || c == 0) { /* Is it a blank entry? */
1455:                			if (n == 0) is = dj->index; /* First index of the contiguous entry */
1456:                			if (++n == ne) break; /* A contiguous entry that required count is found */
1457:                		} else {
1458:                			n = 0; /* Not a blank entry. Restart to search */
1459:                		}
1460:                		res = dir_next(dj, 1); /* Next entry with table stretch */
1461:                	}while (res == FR_OK);
1462:                
1463:                	if (res == FR_OK && ne > 1) { /* Initialize LFN entry if needed */
1464:                		res = dir_sdi(dj, is);
1465:                		if (res == FR_OK) {
1466:                			sum = sum_sfn(dj->fn); /* Sum of the SFN tied to the LFN */
1467:                			ne--;
1468:                			do { /* Store LFN entries in bottom first */
1469:                				res = move_window(dj->fs, dj->sect);
1470:                				if (res != FR_OK) break;
1471:                				fit_lfn(dj->lfn, dj->dir, (PF_BYTE)ne, sum);
1472:                				dj->fs->wflag = 1;
1473:                				res = dir_next(dj, 0); /* Next entry */
1474:                			}while (res == FR_OK && --ne);
1475:                		}
1476:                	}
1477:                
1478:                #else	/* Non LFN configuration */
1479:                	res = dir_sdi(dj, 0);
9D004980  0F400FAB   JAL 0x9D003EAC
9D004984  00002821   ADDU A1, ZERO, ZERO
1480:                	if (res == FR_OK) {
9D004988  1440001E   BNE V0, ZERO, 0x9D004A04
9D00498C  00408021   ADDU S0, V0, ZERO
1481:                		do { /* Find a blank entry for the SFN */
1482:                			res = move_window(dj->fs, dj->sect);
9D004994  8E240000   LW A0, 0(S1)
9D004998  0F400E6A   JAL 0x9D0039A8
9D00499C  8E250010   LW A1, 16(S1)
1483:                			if (res != FR_OK)
9D0049A0  14400018   BNE V0, ZERO, 0x9D004A04
9D0049A4  00408021   ADDU S0, V0, ZERO
1484:                				break;
1485:                			c = *dj->dir;
9D0049A8  8E220014   LW V0, 20(S1)
9D0049AC  90420000   LBU V0, 0(V0)
1486:                			if (c == DDE || c == 0)
9D004990  241200E5   ADDIU S2, ZERO, 229
9D0049B0  5052001C   BEQL V0, S2, 0x9D004A24
9D0049B4  8E240000   LW A0, 0(S1)
9D0049B8  10400019   BEQ V0, ZERO, 0x9D004A20
9D0049BC  02202021   ADDU A0, S1, ZERO
1487:                				break; /* Is it a blank entry? */
1488:                			res = dir_next(dj, 1); /* Next entry with table stretch */
9D0049C0  0F4010EA   JAL 0x9D0043A8
9D0049C4  24050001   ADDIU A1, ZERO, 1
1489:                		} while (res == FR_OK);
9D0049C8  1040FFF2   BEQ V0, ZERO, 0x9D004994
9D0049CC  00408021   ADDU S0, V0, ZERO
1490:                	}
1491:                #endif
1492:                
1493:                	if (res == FR_OK) { /* Initialize the SFN entry */
1494:                		res = move_window(dj->fs, dj->sect);
9D004A20  8E240000   LW A0, 0(S1)
9D004A24  0F400E6A   JAL 0x9D0039A8
9D004A28  8E250010   LW A1, 16(S1)
1495:                		if (res == FR_OK) {
9D004A2C  1440FFF5   BNE V0, ZERO, 0x9D004A04
9D004A30  00408021   ADDU S0, V0, ZERO
1496:                			dir = dj->dir;
9D004A34  0B401276   J 0x9D0049D8
9D004A38  8E320014   LW S2, 20(S1)
1497:                			mem_set(dir, 0, SZ_DIR); /* Clean the entry */
9D0049D8  02402021   ADDU A0, S2, ZERO
9D0049DC  00002821   ADDU A1, ZERO, ZERO
9D0049E0  0F400DFA   JAL 0x9D0037E8
9D0049E4  24060020   ADDIU A2, ZERO, 32
1498:                			mem_cpy(dir, dj->fn, 11); /* Put SFN */
9D0049E8  02402021   ADDU A0, S2, ZERO
9D0049EC  8E250018   LW A1, 24(S1)
9D0049F0  0F400DF0   JAL 0x9D0037C0
9D0049F4  2406000B   ADDIU A2, ZERO, 11
1499:                #if _USE_LFN
1500:                			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT); /* Put NT flag */
1501:                #endif
1502:                			dj->fs->wflag = 1;
9D0049F8  8E220000   LW V0, 0(S1)
9D0049FC  24030001   ADDIU V1, ZERO, 1
9D004A00  A0430004   SB V1, 4(V0)
1503:                		}
1504:                	}
1505:                
1506:                	return res;
1507:                }
9D0049D0  0B401282   J 0x9D004A08
9D0049D4  02001021   ADDU V0, S0, ZERO
9D004A04  02001021   ADDU V0, S0, ZERO
9D004A08  8FBF001C   LW RA, 28(SP)
9D004A0C  8FB20018   LW S2, 24(SP)
9D004A10  8FB10014   LW S1, 20(SP)
9D004A14  8FB00010   LW S0, 16(SP)
9D004A18  03E00008   JR RA
9D004A1C  27BD0020   ADDIU SP, SP, 32
1508:                #endif /* !_FS_READONLY */
1509:                
1510:                /*-----------------------------------------------------------------------*/
1511:                /* Remove an object from the directory                                   */
1512:                /*-----------------------------------------------------------------------*/
1513:                #if !_FS_READONLY && !_FS_MINIMIZE
1514:                static FRESULT dir_remove( /* FR_OK: Successful, FR_DISK_ERR: A disk error */
1515:                DIR *dj /* Directory object pointing the entry to be removed */
1516:                ) {
9D004010  27BDFFE8   ADDIU SP, SP, -24
9D004014  AFBF0014   SW RA, 20(SP)
9D004018  AFB00010   SW S0, 16(SP)
9D00401C  00808021   ADDU S0, A0, ZERO
1517:                	FRESULT res;
1518:                #if _USE_LFN	/* LFN configuration */
1519:                	PF_WORD i;
1520:                
1521:                	i = dj->index; /* SFN index */
1522:                	res = dir_sdi(dj, (PF_WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx)); /* Goto the SFN or top of the LFN entries */
1523:                	if (res == FR_OK) {
1524:                		do {
1525:                			res = move_window(dj->fs, dj->sect);
1526:                			if (res != FR_OK) break;
1527:                			*dj->dir = DDE; /* Mark the entry "deleted" */
1528:                			dj->fs->wflag = 1;
1529:                			if (dj->index >= i) break; /* When reached SFN, all entries of the object has been deleted. */
1530:                			res = dir_next(dj, 0); /* Next entry */
1531:                		}while (res == FR_OK);
1532:                		if (res == FR_NO_FILE) res = FR_INT_ERR;
1533:                	}
1534:                
1535:                #else			/* Non LFN configuration */
1536:                	res = dir_sdi(dj, dj->index);
9D004020  0F400FAB   JAL 0x9D003EAC
9D004024  94850006   LHU A1, 6(A0)
1537:                	if (res == FR_OK) {
9D004028  1440000C   BNE V0, ZERO, 0x9D00405C
9D00402C  8FBF0014   LW RA, 20(SP)
1538:                		res = move_window(dj->fs, dj->sect);
9D004030  8E040000   LW A0, 0(S0)
9D004034  0F400E6A   JAL 0x9D0039A8
9D004038  8E050010   LW A1, 16(S0)
1539:                		if (res == FR_OK) {
9D00403C  14400006   BNE V0, ZERO, 0x9D004058
9D004040  2404FFE5   ADDIU A0, ZERO, -27
1540:                			*dj->dir = DDE; /* Mark the entry "deleted" */
9D004044  8E030014   LW V1, 20(S0)
9D004048  A0640000   SB A0, 0(V1)
1541:                			dj->fs->wflag = 1;
9D00404C  8E030000   LW V1, 0(S0)
9D004050  24040001   ADDIU A0, ZERO, 1
9D004054  A0640004   SB A0, 4(V1)
1542:                		}
1543:                	}
1544:                #endif
1545:                
1546:                	return res;
1547:                }
9D004058  8FBF0014   LW RA, 20(SP)
9D00405C  8FB00010   LW S0, 16(SP)
9D004060  03E00008   JR RA
9D004064  27BD0018   ADDIU SP, SP, 24
1548:                #endif /* !_FS_READONLY */
1549:                
1550:                /*-----------------------------------------------------------------------*/
1551:                /* Pick a segment and create the object name in directory form           */
1552:                /*-----------------------------------------------------------------------*/
1553:                
1554:                static FRESULT create_name(DIR *dj, /* Pointer to the directory object */
1555:                const TCHAR **path /* Pointer to pointer to the segment in the path string */
1556:                ) {
1557:                #ifdef _EXCVT
1558:                	static const PF_BYTE excvt[] = _EXCVT; /* Upper conversion table for extended chars */
1559:                #endif
1560:                
1561:                #if _USE_LFN	/* LFN configuration */
1562:                	PF_BYTE b, cf;
1563:                	WCHAR w, *lfn;
1564:                	UINT i, ni, si, di;
1565:                	const TCHAR *p;
1566:                
1567:                	/* Create LFN in Unicode */
1568:                	for (p = *path; *p == '/' || *p == '\\'; p++); /* Strip duplicated separator */
1569:                	lfn = dj->lfn;
1570:                	si = di = 0;
1571:                	for (;;) {
1572:                		w = p[si++]; /* Get a character */
1573:                		if (w < ' ' || w == '/' || w == '\\') break; /* Break on end of segment */
1574:                		if (di >= _MAX_LFN) /* Reject too long name */
1575:                		return FR_INVALID_NAME;
1576:                #if !_LFN_UNICODE
1577:                		w &= 0xFF;
1578:                		if (IsDBCS1(w)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1579:                			b = (PF_BYTE)p[si++]; /* Get 2nd byte */
1580:                			if (!IsDBCS2(b))
1581:                			return FR_INVALID_NAME; /* Reject invalid sequence */
1582:                			w = (w << 8) + b; /* Create a DBC */
1583:                		}
1584:                		w = ff_convert(w, 1); /* Convert ANSI/OEM to Unicode */
1585:                		if (!w) return FR_INVALID_NAME; /* Reject invalid code */
1586:                #endif
1587:                		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
1588:                		return FR_INVALID_NAME;
1589:                		lfn[di++] = w; /* Store the Unicode char */
1590:                	}
1591:                	*path = &p[si]; /* Return pointer to the next segment */
1592:                	cf = (w < ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
1593:                #if _FS_RPATH
1594:                	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
1595:                			(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
1596:                		lfn[di] = 0;
1597:                		for (i = 0; i < 11; i++)
1598:                		dj->fn[i] = (i < di) ? '.' : ' ';
1599:                		dj->fn[i] = cf | NS_DOT; /* This is a dot entry */
1600:                		return FR_OK;
1601:                	}
1602:                #endif
1603:                	while (di) { /* Strip trailing spaces and dots */
1604:                		w = lfn[di-1];
1605:                		if (w != ' ' && w != '.') break;
1606:                		di--;
1607:                	}
1608:                	if (!di) return FR_INVALID_NAME; /* Reject nul string */
1609:                
1610:                	lfn[di] = 0; /* LFN is created */
1611:                
1612:                	/* Create SFN in directory form */
1613:                	mem_set(dj->fn, ' ', 11);
1614:                	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++); /* Strip leading spaces and dots */
1615:                	if (si) cf |= NS_LOSS | NS_LFN;
1616:                	while (di && lfn[di - 1] != '.') di--; /* Find extension (di<=si: no extension) */
1617:                
1618:                	b = i = 0; ni = 8;
1619:                	for (;;) {
1620:                		w = lfn[si++]; /* Get an LFN char */
1621:                		if (!w) break; /* Break on end of the LFN */
1622:                		if (w == ' ' || (w == '.' && si != di)) { /* Remove spaces and dots */
1623:                			cf |= NS_LOSS | NS_LFN; continue;
1624:                		}
1625:                
1626:                		if (i >= ni || si == di) { /* Extension or end of SFN */
1627:                			if (ni == 11) { /* Long extension */
1628:                				cf |= NS_LOSS | NS_LFN; break;
1629:                			}
1630:                			if (si != di) cf |= NS_LOSS | NS_LFN; /* Out of 8.3 format */
1631:                			if (si > di) break; /* No extension */
1632:                			si = di; i = 8; ni = 11; /* Enter extension section */
1633:                			b <<= 2; continue;
1634:                		}
1635:                
1636:                		if (w >= 0x80) { /* Non ASCII char */
1637:                #ifdef _EXCVT
1638:                			w = ff_convert(w, 0); /* Unicode -> OEM code */
1639:                			if (w) w = excvt[w - 0x80]; /* Convert extended char to upper (SBCS) */
1640:                #else
1641:                			w = ff_convert(ff_wtoupper(w), 0); /* Upper converted Unicode -> OEM code */
1642:                #endif
1643:                			cf |= NS_LFN; /* Force create LFN entry */
1644:                		}
1645:                
1646:                		if (_DF1S && w >= 0x100) { /* Double byte char (always false on SBCS cfg) */
1647:                			if (i >= ni - 1) {
1648:                				cf |= NS_LOSS | NS_LFN; i = ni; continue;
1649:                			}
1650:                			dj->fn[i++] = (PF_BYTE)(w >> 8);
1651:                		} else { /* Single byte char */
1652:                			if (!w || chk_chr("+,;=[]", w)) { /* Replace illegal chars for SFN */
1653:                				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
1654:                			} else {
1655:                				if (IsUpper(w)) { /* ASCII large capital */
1656:                					b |= 2;
1657:                				} else {
1658:                					if (IsLower(w)) { /* ASCII small capital */
1659:                						b |= 1; w -= 0x20;
1660:                					}
1661:                				}
1662:                			}
1663:                		}
1664:                		dj->fn[i++] = (PF_BYTE)w;
1665:                	}
1666:                
1667:                	if (dj->fn[0] == DDE) dj->fn[0] = NDDE; /* If the first char collides with deleted mark, replace it with 0x05 */
1668:                
1669:                	if (ni == 8) b <<= 2;
1670:                	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) /* Create LFN entry when there are composite capitals */
1671:                	cf |= NS_LFN;
1672:                	if (!(cf & NS_LFN)) { /* When LFN is in 8.3 format without extended char, NT flags are created */
1673:                		if ((b & 0x03) == 0x01) cf |= NS_EXT; /* NT flag (Extension has only small capital) */
1674:                		if ((b & 0x0C) == 0x04) cf |= NS_BODY; /* NT flag (Filename has only small capital) */
1675:                	}
1676:                
1677:                	dj->fn[NS] = cf; /* SFN is created */
1678:                
1679:                	return FR_OK;
1680:                
1681:                #else	/* Non-LFN configuration */
1682:                	PF_BYTE b, c, d, *sfn;
1683:                	UINT ni, si, i;
1684:                	const char *p;
1685:                
1686:                	/* Create file name in directory form */
1687:                	for (p = *path; *p == '/' || *p == '\\'; p++)
9D004624  2413005C   ADDIU S3, ZERO, 92
9D004634  82020000   LB V0, 0(S0)
9D004638  5051FFFE   BEQL V0, S1, 0x9D004634
9D00463C  26100001   ADDIU S0, S0, 1
9D004640  5053FFFC   BEQL V0, S3, 0x9D004634
9D004644  26100001   ADDIU S0, S0, 1
1688:                		; /* Strip duplicated separator */
1689:                	sfn = dj->fn;
9D004648  8E550018   LW S5, 24(S2)
1690:                	mem_set(sfn, ' ', 11);
9D00464C  02A02021   ADDU A0, S5, ZERO
9D004650  24050020   ADDIU A1, ZERO, 32
9D004654  0F400DFA   JAL 0x9D0037E8
9D004658  2406000B   ADDIU A2, ZERO, 11
1691:                	si = i = b = 0;
9D00465C  00003021   ADDU A2, ZERO, ZERO
9D004660  00001821   ADDU V1, ZERO, ZERO
9D004668  00004021   ADDU T0, ZERO, ZERO
1692:                	ni = 8;
9D004664  24040008   ADDIU A0, ZERO, 8
1693:                #if _FS_RPATH
1694:                	if (p[si] == '.') { /* Is this a dot entry? */
1695:                		for (;;) {
1696:                			c = (PF_BYTE)p[si++];
1697:                			if (c != '.' || si >= 3) break;
1698:                			sfn[i++] = c;
1699:                		}
1700:                		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
1701:                		*path = &p[si]; /* Return pointer to the next segment */
1702:                		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT; /* Set last segment flag if end of path */
1703:                		return FR_OK;
1704:                	}
1705:                #endif
1706:                	for (;;) {
1707:                		c = (PF_BYTE) p[si++];
9D004670  02031021   ADDU V0, S0, V1
9D004674  80450000   LB A1, 0(V0)
9D004678  30A200FF   ANDI V0, A1, 255
1708:                		if (c <= ' ' || c == '/' || c == '\\')
9D00467C  2C470021   SLTIU A3, V0, 33
9D004680  14E0004C   BNE A3, ZERO, 0x9D0047B4
9D004684  24630001   ADDIU V1, V1, 1
9D004688  505100AE   BEQL V0, S1, 0x9D004944
9D00468C  02038021   ADDU S0, S0, V1
9D004690  505300AC   BEQL V0, S3, 0x9D004944
9D004694  02038021   ADDU S0, S0, V1
1709:                			break; /* Break on end of segment */
1710:                		if (c == '.' || i >= ni) {
9D004628  2414002E   ADDIU S4, ZERO, 46
9D004698  10540003   BEQ V0, S4, 0x9D0046A8
9D00469C  00C4382B   SLTU A3, A2, A0
9D0046A0  14E0000A   BNE A3, ZERO, 0x9D0046CC
9D0046A4  35070003   ORI A3, T0, 3
1711:                			if (ni != 8 || c != '.')
9D00466C  24090008   ADDIU T1, ZERO, 8
9D0046A8  5489009B   BNEL A0, T1, 0x9D004918
9D0046AC  24020006   ADDIU V0, ZERO, 6
9D0046B0  14540099   BNE V0, S4, 0x9D004918
9D0046B4  24020006   ADDIU V0, ZERO, 6
1712:                				return FR_INVALID_NAME;
1713:                			i = 8;
9D0046C0  01203021   ADDU A2, T1, ZERO
1714:                			ni = 11;
9D0046C4  0B40119C   J 0x9D004670
9D0046C8  2404000B   ADDIU A0, ZERO, 11
1715:                			b <<= 2;
9D0046B8  00084080   SLL T0, T0, 2
9D0046BC  310800FF   ANDI T0, T0, 255
1716:                			continue;
1717:                		}
1718:                		if (c >= 0x80) { /* Extended char? */
1719:                			b |= 3; /* Eliminate NT flag */
9D0046CC  28A50000   SLTI A1, A1, 0
9D0046D0  00E5400B   MOVN T0, A3, A1
1720:                #ifdef _EXCVT
1721:                			c = excvt[c-0x80]; /* Upper conversion (SBCS) */
1722:                #else
1723:                #if !_DF1S	/* ASCII only cfg */
1724:                			return FR_INVALID_NAME;
1725:                #endif
1726:                #endif
1727:                		}
1728:                		if (IsDBCS1(c)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
9D0046D4  2445007F   ADDIU A1, V0, 127
9D0046D8  30A500FF   ANDI A1, A1, 255
9D0046DC  2CA5001F   SLTIU A1, A1, 31
9D0046E0  14A00006   BNE A1, ZERO, 0x9D0046FC
9D0046E4  02032821   ADDU A1, S0, V1
9D0046E8  24450020   ADDIU A1, V0, 32
9D0046EC  30A500FF   ANDI A1, A1, 255
9D0046F0  2CA5001D   SLTIU A1, A1, 29
9D0046F4  10A00013   BEQ A1, ZERO, 0x9D004744
9D0046F8  02032821   ADDU A1, S0, V1
1729:                			d = (PF_BYTE) p[si++]; /* Get 2nd byte */
9D0046FC  90A50000   LBU A1, 0(A1)
1730:                			if (!IsDBCS2(d) || i >= ni - 1) /* Reject invalid DBC */
9D004700  24A7FFC0   ADDIU A3, A1, -64
9D004704  30E700FF   ANDI A3, A3, 255
9D004708  2CE7003F   SLTIU A3, A3, 63
9D00470C  14E00005   BNE A3, ZERO, 0x9D004724
9D004710  2487FFFF   ADDIU A3, A0, -1
9D004714  38A70080   XORI A3, A1, 128
9D004718  2CE7007D   SLTIU A3, A3, 125
9D00471C  10E00077   BEQ A3, ZERO, 0x9D0048FC
9D004720  2487FFFF   ADDIU A3, A0, -1
9D004724  00C7382B   SLTU A3, A2, A3
9D004728  10E00076   BEQ A3, ZERO, 0x9D004904
9D00472C  24630001   ADDIU V1, V1, 1
9D0048FC  0B401246   J 0x9D004918
9D004900  24020006   ADDIU V0, ZERO, 6
9D004904  0B401246   J 0x9D004918
9D004908  24020006   ADDIU V0, ZERO, 6
1731:                				return FR_INVALID_NAME;
1732:                			sfn[i++] = c;
9D004730  02A63821   ADDU A3, S5, A2
9D004734  A0E20000   SB V0, 0(A3)
1733:                			sfn[i++] = d;
9D004738  A0E50001   SB A1, 1(A3)
9D00473C  0B40119C   J 0x9D004670
9D004740  24C60002   ADDIU A2, A2, 2
1734:                		} else { /* Single byte code */
1735:                			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) /* Reject illegal chrs for SFN */
1736:                				return FR_INVALID_NAME;
1737:                			if (IsUpper(c)) { /* ASCII large capital? */
9D004770  30A500FF   ANDI A1, A1, 255
9D004774  2CA5001A   SLTIU A1, A1, 26
9D004778  10A00003   BEQ A1, ZERO, 0x9D004788
9D00477C  2445FF9F   ADDIU A1, V0, -97
1738:                				b |= 2;
9D004780  0B4011E9   J 0x9D0047A4
9D004784  35080002   ORI T0, T0, 2
1739:                			} else {
1740:                				if (IsLower(c)) { /* ASCII small capital? */
9D004788  30A500FF   ANDI A1, A1, 255
9D00478C  2CA5001A   SLTIU A1, A1, 26
9D004790  10A00005   BEQ A1, ZERO, 0x9D0047A8
9D004794  02A62821   ADDU A1, S5, A2
1741:                					b |= 1;
9D004798  35080001   ORI T0, T0, 1
1742:                					c -= 0x20;
9D00479C  2442FFE0   ADDIU V0, V0, -32
9D0047A0  304200FF   ANDI V0, V0, 255
1743:                				}
1744:                			}
1745:                			sfn[i++] = c;
9D0047A4  02A62821   ADDU A1, S5, A2
9D0047A8  A0A20000   SB V0, 0(A1)
9D0047AC  0B40119C   J 0x9D004670
9D0047B0  24C60001   ADDIU A2, A2, 1
1746:                		}
1747:                	}
1748:                	*path = &p[si]; /* Return pointer to the next segment */
9D0047B4  02038021   ADDU S0, S0, V1
1749:                	c = (c <= ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
9D0047B8  24020004   ADDIU V0, ZERO, 4
9D004944  0B4011EF   J 0x9D0047BC
9D004948  00001021   ADDU V0, ZERO, ZERO
1750:                
1751:                	if (!i)
9D0047BC  10C00055   BEQ A2, ZERO, 0x9D004914
9D0047C0  240300E5   ADDIU V1, ZERO, 229
1752:                		return FR_INVALID_NAME; /* Reject nul string */
1753:                	if (sfn[0] == DDE)
9D0047C4  92A50000   LBU A1, 0(S5)
9D0047C8  14A30004   BNE A1, V1, 0x9D0047DC
9D0047CC  24030008   ADDIU V1, ZERO, 8
1754:                		sfn[0] = NDDE; /* When first char collides with DDE, replace it with 0x05 */
9D0047D0  24030005   ADDIU V1, ZERO, 5
9D0047D4  A2A30000   SB V1, 0(S5)
1755:                
1756:                	if (ni == 8)
9D0047D8  24030008   ADDIU V1, ZERO, 8
9D0047DC  14830004   BNE A0, V1, 0x9D0047F0
9D0047E0  01002021   ADDU A0, T0, ZERO
1757:                		b <<= 2;
9D0047E4  00084080   SLL T0, T0, 2
9D0047E8  310800FF   ANDI T0, T0, 255
1758:                	if ((b & 0x03) == 0x01)
9D0047EC  01002021   ADDU A0, T0, ZERO
9D0047F0  31080003   ANDI T0, T0, 3
1759:                		c |= NS_EXT; /* NT flag (Name extension has only small capital) */
9D0047F4  34430010   ORI V1, V0, 16
9D0047F8  39080001   XORI T0, T0, 1
9D0047FC  0068100A   MOVZ V0, V1, T0
1760:                	if ((b & 0x0C) == 0x04)
9D004800  3084000C   ANDI A0, A0, 12
1761:                		c |= NS_BODY; /* NT flag (Name body has only small capital) */
9D004804  34430008   ORI V1, V0, 8
9D004808  38840004   XORI A0, A0, 4
9D00480C  0064100A   MOVZ V0, V1, A0
1762:                
1763:                	sfn[NS] = c; /* Store NT flag, File name is created */
9D004810  A2A2000B   SB V0, 11(S5)
1764:                
1765:                	return FR_OK;
1766:                #endif
1767:                }
1768:                
1769:                /*-----------------------------------------------------------------------*/
1770:                /* Get file information from directory entry                             */
1771:                /*-----------------------------------------------------------------------*/
1772:                #if _FS_MINIMIZE <= 1
1773:                static
1774:                void get_fileinfo( /* No return code */
9D0038BC  00C41021   ADDU V0, A2, A0
1775:                DIR *dj, /* Pointer to the directory object */
1776:                FILINFO *fno /* Pointer to the file information to be filled */
1777:                ) {
1778:                	UINT i;
1779:                	PF_BYTE nt, *dir;
1780:                	TCHAR *p, c;
1781:                
1782:                	p = fno->fname;
1783:                	if (dj->sect) {
9D003888  8C820010   LW V0, 16(A0)
9D00388C  10400039   BEQ V0, ZERO, 0x9D003974
9D003890  24A30009   ADDIU V1, A1, 9
1784:                		dir = dj->dir;
9D003894  8C860014   LW A2, 20(A0)
1785:                		nt = dir[DIR_NTres]; /* NT flag */
1786:                		for (i = 0; i < 8; i++) { /* Copy name body */
9D0038B0  24080008   ADDIU T0, ZERO, 8
9D0038D8  24840001   ADDIU A0, A0, 1
9D0038DC  1488FFF7   BNE A0, T0, 0x9D0038BC
9D0038E0  24630001   ADDIU V1, V1, 1
1787:                			c = dir[i];
9D003898  80C20000   LB V0, 0(A2)
9D0038C0  80420000   LB V0, 0(V0)
1788:                			if (c == ' ')
9D00389C  24040020   ADDIU A0, ZERO, 32
9D0038A0  10440010   BEQ V0, A0, 0x9D0038E4
9D0038A4  00002021   ADDU A0, ZERO, ZERO
9D0038B4  0B400E33   J 0x9D0038CC
9D0038B8  240B0020   ADDIU T3, ZERO, 32
9D0038C4  504B0008   BEQL V0, T3, 0x9D0038E8
9D0038C8  90C40008   LBU A0, 8(A2)
1789:                				break;
1790:                			if (c == NDDE)
9D0038A8  240A0005   ADDIU T2, ZERO, 5
1791:                				c = (TCHAR) DDE;
9D0038AC  2409FFE5   ADDIU T1, ZERO, -27
9D0038CC  004A3826   XOR A3, V0, T2
9D0038D0  0127100A   MOVZ V0, T1, A3
1792:                			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c))
1793:                				c += 0x20;
1794:                #if _LFN_UNICODE
1795:                			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
1796:                			c = (c << 8) | dir[++i];
1797:                			c = ff_convert(c, 1);
1798:                			if (!c) c = '?';
1799:                #endif
1800:                			*p++ = c;
9D0038D4  A0620000   SB V0, 0(V1)
1801:                		}
1802:                		if (dir[8] != ' ') { /* Copy name extension */
9D0038E4  90C40008   LBU A0, 8(A2)
9D0038E8  24020020   ADDIU V0, ZERO, 32
9D0038EC  1082000A   BEQ A0, V0, 0x9D003918
9D0038F0  2402002E   ADDIU V0, ZERO, 46
1803:                			*p++ = '.';
9D0038F4  A0620000   SB V0, 0(V1)
1804:                			for (i = 8; i < 11; i++) {
1805:                				c = dir[i];
9D0038F8  80C20008   LB V0, 8(A2)
9D003980  80C20009   LB V0, 9(A2)
9D003994  80C2000A   LB V0, 10(A2)
1806:                				if (c == ' ')
9D0038FC  24040020   ADDIU A0, ZERO, 32
9D003900  1444001E   BNE V0, A0, 0x9D00397C
9D003904  24630001   ADDIU V1, V1, 1
9D003984  24040020   ADDIU A0, ZERO, 32
9D003988  1044FFE3   BEQ V0, A0, 0x9D003918
9D00398C  24630001   ADDIU V1, V1, 1
9D003998  1444FFDD   BNE V0, A0, 0x9D003910
9D00399C  24630001   ADDIU V1, V1, 1
1807:                					break;
1808:                				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c))
1809:                					c += 0x20;
1810:                #if _LFN_UNICODE
1811:                				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
1812:                				c = (c << 8) | dir[++i];
1813:                				c = ff_convert(c, 1);
1814:                				if (!c) c = '?';
1815:                #endif
1816:                				*p++ = c;
9D003910  A0620000   SB V0, 0(V1)
9D003914  24630001   ADDIU V1, V1, 1
9D00397C  A0620000   SB V0, 0(V1)
9D003990  A0620000   SB V0, 0(V1)
1817:                			}
1818:                		}
1819:                		fno->fattrib = dir[DIR_Attr]; /* Attribute */
9D003908  0B400E47   J 0x9D00391C
9D00390C  90C2000B   LBU V0, 11(A2)
9D003918  90C2000B   LBU V0, 11(A2)
9D00391C  A0A20008   SB V0, 8(A1)
9D0039A0  0B400E47   J 0x9D00391C
9D0039A4  90C2000B   LBU V0, 11(A2)
1820:                		fno->fsize = LD_DWORD(dir+DIR_FileSize); /* Size */
9D003920  90C4001F   LBU A0, 31(A2)
9D003924  00042600   SLL A0, A0, 24
9D003928  90C2001E   LBU V0, 30(A2)
9D00392C  00021400   SLL V0, V0, 16
9D003930  00821025   OR V0, A0, V0
9D003934  90C4001C   LBU A0, 28(A2)
9D003938  00441025   OR V0, V0, A0
9D00393C  90C4001D   LBU A0, 29(A2)
9D003940  00042200   SLL A0, A0, 8
9D003944  00441025   OR V0, V0, A0
9D003948  ACA20000   SW V0, 0(A1)
1821:                		fno->fdate = LD_WORD(dir+DIR_WrtDate); /* Date */
9D00394C  90C20019   LBU V0, 25(A2)
9D003950  00021200   SLL V0, V0, 8
9D003954  90C40018   LBU A0, 24(A2)
9D003958  00441025   OR V0, V0, A0
9D00395C  A4A20004   SH V0, 4(A1)
1822:                		fno->ftime = LD_WORD(dir+DIR_WrtTime); /* Time */
9D003960  90C20017   LBU V0, 23(A2)
9D003964  00021200   SLL V0, V0, 8
9D003968  90C40016   LBU A0, 22(A2)
9D00396C  00441025   OR V0, V0, A0
9D003970  A4A20006   SH V0, 6(A1)
1823:                	}
1824:                	*p = 0; /* Terminate SFN str by a \0 */
1825:                
1826:                #if _USE_LFN
1827:                	if (fno->lfname && fno->lfsize) {
1828:                		TCHAR *tp = fno->lfname;
1829:                		WCHAR w, *lfn;
1830:                
1831:                		i = 0;
1832:                		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
1833:                			lfn = dj->lfn;
1834:                			while ((w = *lfn++) != 0) { /* Get an LFN char */
1835:                #if !_LFN_UNICODE
1836:                				w = ff_convert(w, 0); /* Unicode -> OEM conversion */
1837:                				if (!w) {i = 0; break;} /* Could not convert, no LFN */
1838:                				if (_DF1S && w >= 0x100) /* Put 1st byte if it is a DBC (always false on SBCS cfg) */
1839:                				tp[i++] = (TCHAR)(w >> 8);
1840:                #endif
1841:                				if (i >= fno->lfsize - 1) {i = 0; break;} /* Buffer overflow, no LFN */
1842:                				tp[i++] = (TCHAR)w;
1843:                			}
1844:                		}
1845:                		tp[i] = 0; /* Terminate the LFN str by a \0 */
1846:                	}
1847:                #endif
1848:                }
9D003974  03E00008   JR RA
9D003978  A0600000   SB ZERO, 0(V1)
1849:                #endif /* _FS_MINIMIZE <= 1 */
1850:                
1851:                /*-----------------------------------------------------------------------*/
1852:                /* Follow a file path                                                    */
1853:                /*-----------------------------------------------------------------------*/
1854:                
1855:                static FRESULT follow_path( /* FR_OK(0): successful, !=0: error code */
9D004864  0B40121D   J 0x9D004874
9D004868  24E8000B   ADDIU T0, A3, 11
1856:                DIR *dj, /* Directory object to return last directory and found object */
1857:                const TCHAR *path /* Full-path string to find a file or directory */
1858:                ) {
9D0045B0  27BDFFC8   ADDIU SP, SP, -56
9D0045B4  AFBF0034   SW RA, 52(SP)
9D0045B8  AFB70030   SW S7, 48(SP)
9D0045BC  AFB6002C   SW S6, 44(SP)
9D0045C0  AFB50028   SW S5, 40(SP)
9D0045C4  AFB40024   SW S4, 36(SP)
9D0045C8  AFB30020   SW S3, 32(SP)
9D0045CC  AFB2001C   SW S2, 28(SP)
9D0045D0  AFB10018   SW S1, 24(SP)
9D0045D4  AFB00014   SW S0, 20(SP)
9D0045D8  00809021   ADDU S2, A0, ZERO
1859:                	FRESULT res;
1860:                	PF_BYTE *dir, ns;
1861:                
1862:                #if _FS_RPATH
1863:                	if (*path == '/' || *path == '\\') { /* There is a heading separator */
1864:                		path++; dj->sclust = 0; /* Strip it and start from the root dir */
1865:                	} else { /* No heading separator */
1866:                		dj->sclust = dj->fs->cdir; /* Start from the current dir */
1867:                	}
1868:                #else
1869:                	if (*path == '/' || *path == '\\') /* Strip heading separator if exist */
9D0045DC  80A20000   LB V0, 0(A1)
9D0045E0  2403002F   ADDIU V1, ZERO, 47
9D0045E4  10430004   BEQ V0, V1, 0x9D0045F8
9D0045E8  00A08021   ADDU S0, A1, ZERO
9D0045EC  2403005C   ADDIU V1, ZERO, 92
9D0045F0  54430003   BNEL V0, V1, 0x9D004600
9D0045F4  AE400008   SW ZERO, 8(S2)
1870:                		path++;
9D0045F8  26100001   ADDIU S0, S0, 1
1871:                	dj->sclust = 0; /* Start from the root dir */
9D0045FC  AE400008   SW ZERO, 8(S2)
1872:                #endif
1873:                
1874:                	if ((UINT) *path < ' ') { /* Nul path means the start directory itself */
9D004600  92020000   LBU V0, 0(S0)
9D004604  2C420020   SLTIU V0, V0, 32
9D004608  10400006   BEQ V0, ZERO, 0x9D004624
9D00460C  2411002F   ADDIU S1, ZERO, 47
1875:                		res = dir_sdi(dj, 0);
9D004610  02402021   ADDU A0, S2, ZERO
9D004614  0F400FAB   JAL 0x9D003EAC
9D004618  00002821   ADDU A1, ZERO, ZERO
1876:                		dj->dir = 0;
9D00461C  0B401246   J 0x9D004918
9D004620  AE400014   SW ZERO, 20(S2)
1877:                
1878:                	} else { /* Follow path */
1879:                		for (;;) {
1880:                			res = create_name(dj, &path); /* Get a segment */
1881:                			if (res != FR_OK)
1882:                				break;
1883:                			res = dir_find(dj); /* Find it */
9D0048B4  24030004   ADDIU V1, ZERO, 4
9D0048B8  24020005   ADDIU V0, ZERO, 5
9D0048BC  0B401246   J 0x9D004918
9D0048C0  0064100B   MOVN V0, V1, A0
1884:                			ns = *(dj->fn + NS);
9D00489C  8E430018   LW V1, 24(S2)
9D0048A0  9064000B   LBU A0, 11(V1)
9D004960  0B40122C   J 0x9D0048B0
9D004964  9044000B   LBU A0, 11(V0)
1885:                			if (res != FR_OK) { /* Failed to find the object */
1886:                				if (res != FR_NO_FILE)
9D0048A4  24030004   ADDIU V1, ZERO, 4
9D0048A8  1443001C   BNE V0, V1, 0x9D00491C
9D0048AC  8FBF0034   LW RA, 52(SP)
1887:                					break; /* Abort if any hard error occured */
1888:                				/* Object not found */
1889:                				if (_FS_RPATH && (ns & NS_DOT)) { /* If dot entry is not exit */
1890:                					dj->sclust = 0;
1891:                					dj->dir = 0; /* It is the root dir */
1892:                					res = FR_OK;
1893:                					if (!(ns & NS_LAST))
1894:                						continue;
1895:                				} else { /* Could not find the object */
1896:                					if (!(ns & NS_LAST))
9D0048B0  30840004   ANDI A0, A0, 4
1897:                						res = FR_NO_PATH;
1898:                				}
1899:                				break;
1900:                			}
1901:                			if (ns & NS_LAST)
9D00494C  30630004   ANDI V1, V1, 4
9D004950  5060FFDC   BEQL V1, ZERO, 0x9D0048C4
9D004954  31290010   ANDI T1, T1, 16
1902:                				break; /* Last segment match. Function completed. */
1903:                			dir = dj->dir; /* There is next segment. Follow the sub directory */
1904:                			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
9D0048C4  11200014   BEQ T1, ZERO, 0x9D004918
9D0048C8  24020005   ADDIU V0, ZERO, 5
1905:                				res = FR_NO_PATH;
1906:                				break;
1907:                			}
1908:                			dj->sclust = LD_CLUST(dir);
9D0048CC  90E30015   LBU V1, 21(A3)
9D0048D0  00031A00   SLL V1, V1, 8
9D0048D4  90E20014   LBU V0, 20(A3)
9D0048D8  00621825   OR V1, V1, V0
9D0048DC  00031C00   SLL V1, V1, 16
9D0048E0  90E2001B   LBU V0, 27(A3)
9D0048E4  00021200   SLL V0, V0, 8
9D0048E8  90E4001A   LBU A0, 26(A3)
9D0048EC  00441025   OR V0, V0, A0
9D0048F0  00621025   OR V0, V1, V0
9D0048F4  0B40118D   J 0x9D004634
9D0048F8  AE420008   SW V0, 8(S2)
1909:                		}
1910:                	}
1911:                
1912:                	return res;
1913:                }
9D004918  8FBF0034   LW RA, 52(SP)
9D00491C  8FB70030   LW S7, 48(SP)
9D004920  8FB6002C   LW S6, 44(SP)
9D004924  8FB50028   LW S5, 40(SP)
9D004928  8FB40024   LW S4, 36(SP)
9D00492C  8FB30020   LW S3, 32(SP)
9D004930  8FB2001C   LW S2, 28(SP)
9D004934  8FB10018   LW S1, 24(SP)
9D004938  8FB00014   LW S0, 20(SP)
9D00493C  03E00008   JR RA
9D004940  27BD0038   ADDIU SP, SP, 56
9D004958  0B401247   J 0x9D00491C
9D00495C  8FBF0034   LW RA, 52(SP)
1914:                
1915:                /*-----------------------------------------------------------------------*/
1916:                /* Load a sector and check if it is an FAT Volume Boot Record            */
1917:                /*-----------------------------------------------------------------------*/
1918:                
1919:                static PF_BYTE check_fs( /* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
1920:                FATFS *fs, /* File system object */
1921:                DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
1922:                ) {
9D003AAC  27BDFFE8   ADDIU SP, SP, -24
9D003AB0  AFBF0014   SW RA, 20(SP)
9D003AB4  AFB00010   SW S0, 16(SP)
9D003AB8  00808021   ADDU S0, A0, ZERO
9D003ABC  00A03021   ADDU A2, A1, ZERO
1923:                	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK) /* Load boot record */
9D003AC0  90840001   LBU A0, 1(A0)
9D003AC4  26050030   ADDIU A1, S0, 48
9D003AC8  0F4023A1   JAL disk_read
9D003ACC  24070001   ADDIU A3, ZERO, 1
9D003AD0  14400027   BNE V0, ZERO, 0x9D003B70
9D003AD4  24030003   ADDIU V1, ZERO, 3
1924:                		return 3;
9D003B60  3C02FFAB   LUI V0, -85
9D003B64  3442BEBA   ORI V0, V0, -16710
9D003B68  00621821   ADDU V1, V1, V0
9D003B6C  0003182B   SLTU V1, ZERO, V1
1925:                	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55) /* Check record signature (always placed at offset 510 even if the sector size is >512) */
9D003AD8  9204022F   LBU A0, 559(S0)
9D003ADC  00042200   SLL A0, A0, 8
9D003AE0  9202022E   LBU V0, 558(S0)
9D003AE4  00822025   OR A0, A0, V0
9D003AE8  7C042620   SEH A0, A0
9D003AEC  2402AA55   ADDIU V0, ZERO, -21931
9D003AF0  1482001F   BNE A0, V0, 0x9D003B70
9D003AF4  24030002   ADDIU V1, ZERO, 2
1926:                		return 2;
1927:                
1928:                	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) /* Check "FAT" string */
9D003AF8  92040069   LBU A0, 105(S0)
9D003AFC  00042600   SLL A0, A0, 24
9D003B00  92020068   LBU V0, 104(S0)
9D003B04  00021400   SLL V0, V0, 16
9D003B08  00822025   OR A0, A0, V0
9D003B0C  92020066   LBU V0, 102(S0)
9D003B10  00822025   OR A0, A0, V0
9D003B14  92020067   LBU V0, 103(S0)
9D003B18  00021200   SLL V0, V0, 8
9D003B1C  00822025   OR A0, A0, V0
9D003B20  7C84B800   EXT A0, A0, 0, 24
9D003B24  3C020054   LUI V0, 84
9D003B28  24424146   ADDIU V0, V0, 16710
9D003B2C  10820010   BEQ A0, V0, 0x9D003B70
9D003B30  00001821   ADDU V1, ZERO, ZERO
1929:                		return 0;
1930:                	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
9D003B34  92030085   LBU V1, 133(S0)
9D003B38  00031E00   SLL V1, V1, 24
9D003B3C  92020084   LBU V0, 132(S0)
9D003B40  00021400   SLL V0, V0, 16
9D003B44  00621825   OR V1, V1, V0
9D003B48  92020082   LBU V0, 130(S0)
9D003B4C  00621825   OR V1, V1, V0
9D003B50  92020083   LBU V0, 131(S0)
9D003B54  00021200   SLL V0, V0, 8
9D003B58  00621825   OR V1, V1, V0
9D003B5C  7C63B800   EXT V1, V1, 0, 24
1931:                		return 0;
1932:                
1933:                	return 1;
1934:                }
9D003B70  00601021   ADDU V0, V1, ZERO
9D003B74  8FBF0014   LW RA, 20(SP)
9D003B78  8FB00010   LW S0, 16(SP)
9D003B7C  03E00008   JR RA
9D003B80  27BD0018   ADDIU SP, SP, 24
1935:                
1936:                /*-----------------------------------------------------------------------*/
1937:                /* Check if the file system object is valid or not                       */
1938:                /*-----------------------------------------------------------------------*/
1939:                
1940:                FRESULT chk_mounted( /* FR_OK(0): successful, !=0: any error occurred */
1941:                                            const TCHAR **path, /* Pointer to pointer to the path name (drive number) */
1942:                                            FATFS **rfs, /* Pointer to pointer to the found file system object */
1943:                                            PF_BYTE chk_wp /* !=0: Check media write protection for write access */
1944:                                            ) {
9D004BCC  27BDFFE0   ADDIU SP, SP, -32
9D004BD0  AFBF001C   SW RA, 28(SP)
9D004BD4  AFB20018   SW S2, 24(SP)
9D004BD8  AFB10014   SW S1, 20(SP)
9D004BDC  AFB00010   SW S0, 16(SP)
9D004BE0  30D100FF   ANDI S1, A2, 255
1945:                	PF_BYTE fmt, b, pi, *tbl;
1946:                	UINT vol;
1947:                	DSTATUS stat;
1948:                	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
1949:                	PF_WORD nrsv;
1950:                	const TCHAR *p = *path;
9D004BE4  8C820000   LW V0, 0(A0)
1951:                	FATFS *fs;
1952:                
1953:                	/* Get logical drive number from the path name */
1954:                	vol = p[0] - '0'; /* Is there a drive number? */
9D004BE8  80430000   LB V1, 0(V0)
9D004BEC  2463FFD0   ADDIU V1, V1, -48
1955:                	if (vol <= 9 && p[1] == ':') { /* Found a drive number, get and strip it */
9D004BF0  2C66000A   SLTIU A2, V1, 10
9D004BF4  10C0000A   BEQ A2, ZERO, 0x9D004C20
9D004BF8  8F908090   LW S0, -32624(GP)
9D004BFC  80470001   LB A3, 1(V0)
9D004C00  2406003A   ADDIU A2, ZERO, 58
9D004C04  54E60007   BNEL A3, A2, 0x9D004C24
9D004C08  ACB00000   SW S0, 0(A1)
1956:                		p += 2;
9D004C0C  24420002   ADDIU V0, V0, 2
1957:                		*path = p; /* Return pointer to the path name */
9D004C10  AC820000   SW V0, 0(A0)
1958:                	} else { /* No drive number is given */
1959:                #if _FS_RPATH
1960:                		vol = CurrVol; /* Use current drive */
1961:                #else
1962:                		vol = 0; /* Use drive 0 */
1963:                #endif
1964:                	}
1965:                
1966:                	/* Check if the file system object is valid or not */
1967:                	if (vol >= _VOLUMES) /* Is the drive number valid? */
9D004C14  14600112   BNE V1, ZERO, 0x9D005060
9D004C18  2402000B   ADDIU V0, ZERO, 11
1968:                		return FR_INVALID_DRIVE;
1969:                	*rfs = fs = FatFs[vol]; /* Return pointer to the corresponding file system object */
9D004C1C  8F908090   LW S0, -32624(GP)
9D004C20  ACB00000   SW S0, 0(A1)
1970:                	if (!fs)
9D004C24  1200010E   BEQ S0, ZERO, 0x9D005060
9D004C28  2402000C   ADDIU V0, ZERO, 12
1971:                		return FR_NOT_ENABLED; /* Is the file system object available? */
1972:                
1973:                	ENTER_FF(fs); /* Lock file system */
1974:                
1975:                	if (fs->fs_type) { /* If the logical drive has been mounted */
9D004C2C  92020000   LBU V0, 0(S0)
9D004C30  5040000D   BEQL V0, ZERO, 0x9D004C68
9D004C34  A2000000   SB ZERO, 0(S0)
1976:                		stat = disk_status(fs->drv);
9D004C38  0F40239A   JAL disk_status
9D004C3C  92040001   LBU A0, 1(S0)
9D004C40  00401821   ADDU V1, V0, ZERO
1977:                		if (!(stat & STA_NOINIT)) { /* and the physical drive is kept initialized (has not been changed), */
9D004C44  30420001   ANDI V0, V0, 1
9D004C48  54400007   BNEL V0, ZERO, 0x9D004C68
9D004C4C  A2000000   SB ZERO, 0(S0)
1978:                			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check write protection if needed */
9D004C50  12200103   BEQ S1, ZERO, 0x9D005060
9D004C54  2404000A   ADDIU A0, ZERO, 10
9D004C58  30620004   ANDI V0, V1, 4
1979:                				return FR_WRITE_PROTECTED;
1980:                			return FR_OK; /* The file system object is valid */
9D004C5C  0002200A   MOVZ A0, ZERO, V0
9D004C60  0B401418   J 0x9D005060
9D004C64  00801021   ADDU V0, A0, ZERO
1981:                		}
1982:                	}
1983:                
1984:                	/* The file system object is not valid. */
1985:                	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
1986:                
1987:                	fs->fs_type = 0; /* Clear the file system object */
1988:                	fs->drv = LD2PD(vol); /* Bind the logical drive and a physical drive */
9D004C68  A2000001   SB ZERO, 1(S0)
1989:                	stat = disk_initialize(fs->drv); /* Initialize low level disk I/O layer */
9D004C6C  0F402309   JAL disk_initialize
9D004C70  00002021   ADDU A0, ZERO, ZERO
9D004C74  00401821   ADDU V1, V0, ZERO
1990:                	if (stat & STA_NOINIT) /* Check if the initialization succeeded */
9D004C78  30440001   ANDI A0, V0, 1
9D004C7C  148000F8   BNE A0, ZERO, 0x9D005060
9D004C80  24020003   ADDIU V0, ZERO, 3
1991:                		return FR_NOT_READY; /* Failed to initialize due to no media or hard error */
1992:                	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check disk write protection if needed */
9D004C84  12200003   BEQ S1, ZERO, 0x9D004C94
9D004C88  30630004   ANDI V1, V1, 4
9D004C8C  146000F4   BNE V1, ZERO, 0x9D005060
9D004C90  2402000A   ADDIU V0, ZERO, 10
1993:                		return FR_WRITE_PROTECTED;
1994:                #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
1995:                	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
1996:                	return FR_DISK_ERR;
1997:                #endif
1998:                	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
1999:                	fmt = check_fs(fs, bsect = 0); /* Load sector 0 and check if it is an FAT-VBR (in SFD) */
9D004C94  02002021   ADDU A0, S0, ZERO
9D004C98  0F400EAB   JAL 0x9D003AAC
9D004C9C  00002821   ADDU A1, ZERO, ZERO
9D004CA0  00401821   ADDU V1, V0, ZERO
2000:                	if (LD2PT(vol) && !fmt)
2001:                		fmt = 1; /* Force non-SFD if the volume is forced partition */
2002:                	if (fmt == 1) { /* Not an FAT-VBR, the physical drive can be partitioned */
9D004CA4  24020001   ADDIU V0, ZERO, 1
9D004CA8  14620012   BNE V1, V0, 0x9D004CF4
9D004CAC  00008821   ADDU S1, ZERO, ZERO
2003:                		/* Check the partition listed in the partition table */
2004:                		pi = LD2PT(vol);
2005:                		if (pi)
2006:                			pi--;
2007:                		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
2008:                		if (tbl[4]) { /* Is the partition existing? */
9D004CB0  920301F2   LBU V1, 498(S0)
9D004CB4  106000EA   BEQ V1, ZERO, 0x9D005060
9D004CB8  2402000D   ADDIU V0, ZERO, 13
2009:                			bsect = LD_DWORD(&tbl[8]); /* Partition offset in LBA */
9D004CBC  921101F9   LBU S1, 505(S0)
9D004CC0  00118E00   SLL S1, S1, 24
9D004CC4  920201F8   LBU V0, 504(S0)
9D004CC8  00021400   SLL V0, V0, 16
9D004CCC  02228825   OR S1, S1, V0
9D004CD0  920201F6   LBU V0, 502(S0)
9D004CD4  02228825   OR S1, S1, V0
9D004CD8  920201F7   LBU V0, 503(S0)
9D004CDC  00021200   SLL V0, V0, 8
9D004CE0  02228825   OR S1, S1, V0
2010:                			fmt = check_fs(fs, bsect); /* Check the partition */
9D004CE4  02002021   ADDU A0, S0, ZERO
9D004CE8  0F400EAB   JAL 0x9D003AAC
9D004CEC  02202821   ADDU A1, S1, ZERO
9D004CF0  00401821   ADDU V1, V0, ZERO
2011:                		}
2012:                	}
2013:                	if (fmt == 3)
9D004CF4  24040003   ADDIU A0, ZERO, 3
9D004CF8  106400D9   BEQ V1, A0, 0x9D005060
9D004CFC  24020001   ADDIU V0, ZERO, 1
2014:                		return FR_DISK_ERR;
2015:                	if (fmt)
9D004D00  146000D7   BNE V1, ZERO, 0x9D005060
9D004D04  2402000D   ADDIU V0, ZERO, 13
2016:                		return FR_NO_FILESYSTEM; /* No FAT volume is found */
2017:                
2018:                	/* An FAT volume is found. Following code initializes the file system object */
2019:                
2020:                	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs)) /* (BPB_BytsPerSec must be equal to the physical sector size) */
9D004D08  9204003C   LBU A0, 60(S0)
9D004D0C  00042200   SLL A0, A0, 8
9D004D10  9202003B   LBU V0, 59(S0)
9D004D14  00822025   OR A0, A0, V0
9D004D18  7C042620   SEH A0, A0
9D004D1C  24030200   ADDIU V1, ZERO, 512
9D004D20  148300CF   BNE A0, V1, 0x9D005060
9D004D24  2402000D   ADDIU V0, ZERO, 13
2021:                		return FR_NO_FILESYSTEM;
2022:                
2023:                	fasize = LD_WORD(fs->win+BPB_FATSz16); /* Number of sectors per FAT */
9D004D28  92030047   LBU V1, 71(S0)
9D004D2C  00031A00   SLL V1, V1, 8
9D004D30  92020046   LBU V0, 70(S0)
9D004D34  00621825   OR V1, V1, V0
2024:                	if (!fasize)
9D004D38  5460000C   BNEL V1, ZERO, 0x9D004D6C
9D004D3C  AE03001C   SW V1, 28(S0)
2025:                		fasize = LD_DWORD(fs->win+BPB_FATSz32);
9D004D40  92030057   LBU V1, 87(S0)
9D004D44  00031E00   SLL V1, V1, 24
9D004D48  92020056   LBU V0, 86(S0)
9D004D4C  00021400   SLL V0, V0, 16
9D004D50  00621825   OR V1, V1, V0
9D004D54  92020054   LBU V0, 84(S0)
9D004D58  00621825   OR V1, V1, V0
9D004D5C  92020055   LBU V0, 85(S0)
9D004D60  00021200   SLL V0, V0, 8
9D004D64  00621825   OR V1, V1, V0
2026:                	fs->fsize = fasize;
9D004D68  AE03001C   SW V1, 28(S0)
2027:                
2028:                	fs->n_fats = b = fs->win[BPB_NumFATs]; /* Number of FAT copies */
9D004D6C  92040040   LBU A0, 64(S0)
9D004D70  A2040003   SB A0, 3(S0)
2029:                	if (b != 1 && b != 2)
9D004D74  2485FFFF   ADDIU A1, A0, -1
9D004D78  30A500FF   ANDI A1, A1, 255
9D004D7C  2CA50002   SLTIU A1, A1, 2
9D004D80  10A000B7   BEQ A1, ZERO, 0x9D005060
9D004D84  2402000D   ADDIU V0, ZERO, 13
2030:                		return FR_NO_FILESYSTEM; /* (Must be 1 or 2) */
2031:                	fasize *= b; /* Number of sectors for FAT area */
9D004E18  70642002   MUL A0, V1, A0
2032:                
2033:                	fs->csize = b = fs->win[BPB_SecPerClus]; /* Number of sectors per cluster */
9D004D88  9205003D   LBU A1, 61(S0)
2034:                	if (!b || (b & (b - 1)))
9D004D8C  10A000B4   BEQ A1, ZERO, 0x9D005060
9D004D90  A2050002   SB A1, 2(S0)
9D004D94  24A6FFFF   ADDIU A2, A1, -1
9D004D98  00C53024   AND A2, A2, A1
9D004D9C  14C000B1   BNE A2, ZERO, 0x9D005064
9D004DA0  8FBF001C   LW RA, 28(SP)
2035:                		return FR_NO_FILESYSTEM; /* (Must be power of 2) */
2036:                
2037:                	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt); /* Number of root directory entries */
9D004DA4  92060042   LBU A2, 66(S0)
9D004DA8  00063200   SLL A2, A2, 8
9D004DAC  92020041   LBU V0, 65(S0)
9D004DB0  00C23025   OR A2, A2, V0
9D004DB4  A6060008   SH A2, 8(S0)
2038:                	if (fs->n_rootdir % (SS(fs) / SZ_DIR))
9D004DB8  30C7000F   ANDI A3, A2, 15
9D004DBC  14E000A8   BNE A3, ZERO, 0x9D005060
9D004DC0  2402000D   ADDIU V0, ZERO, 13
2039:                		return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be sector aligned) */
2040:                
2041:                	tsect = LD_WORD(fs->win+BPB_TotSec16); /* Number of sectors on the volume */
9D004DC4  92070044   LBU A3, 68(S0)
9D004DC8  00073A00   SLL A3, A3, 8
9D004DCC  92020043   LBU V0, 67(S0)
9D004DD0  00E23825   OR A3, A3, V0
2042:                	if (!tsect)
9D004DD4  14E0000B   BNE A3, ZERO, 0x9D004E04
9D004DD8  9208003F   LBU T0, 63(S0)
2043:                		tsect = LD_DWORD(fs->win+BPB_TotSec32);
9D004DDC  92070053   LBU A3, 83(S0)
9D004DE0  00073E00   SLL A3, A3, 24
9D004DE4  92020052   LBU V0, 82(S0)
9D004DE8  00021400   SLL V0, V0, 16
9D004DEC  00E23825   OR A3, A3, V0
9D004DF0  92020050   LBU V0, 80(S0)
9D004DF4  00E23825   OR A3, A3, V0
9D004DF8  92020051   LBU V0, 81(S0)
9D004DFC  00021200   SLL V0, V0, 8
9D004E00  00E23825   OR A3, A3, V0
2044:                
2045:                	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt); /* Number of reserved sectors */
9D004E04  00084200   SLL T0, T0, 8
9D004E08  9202003E   LBU V0, 62(S0)
9D004E0C  01024025   OR T0, T0, V0
2046:                	if (!nrsv)
9D004E10  11000093   BEQ T0, ZERO, 0x9D005060
9D004E14  2402000D   ADDIU V0, ZERO, 13
2047:                		return FR_NO_FILESYSTEM; /* (BPB_RsvdSecCnt must not be 0) */
2048:                
2049:                	/* Determine the FAT sub type */
2050:                	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR); /* RSV+FAT+DIR */
9D004E1C  00064902   SRL T1, A2, 4
9D004E20  01284821   ADDU T1, T1, T0
9D004E24  01244821   ADDU T1, T1, A0
2051:                	if (tsect < sysect)
9D004E28  00E9502B   SLTU T2, A3, T1
9D004E2C  1540008D   BNE T2, ZERO, 0x9D005064
9D004E30  8FBF001C   LW RA, 28(SP)
2052:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2053:                	nclst = (tsect - sysect) / fs->csize; /* Number of clusters */
9D004E34  00E93823   SUBU A3, A3, T1
9D004E38  00E5001B   DIVU A3, A1
9D004E3C  00A001F4   TEQ A1, ZERO
9D004E40  00002812   MFLO A1, 0
2054:                	if (!nclst)
9D004E44  10A00086   BEQ A1, ZERO, 0x9D005060
9D004E48  2CB20FF6   SLTIU S2, A1, 4086
2055:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2056:                	fmt = FS_FAT12;
9D004E4C  24020001   ADDIU V0, ZERO, 1
9D004E50  240A0002   ADDIU T2, ZERO, 2
9D004E54  0152100A   MOVZ V0, T2, S2
9D004E58  00409021   ADDU S2, V0, ZERO
2057:                	if (nclst >= MIN_FAT16)
2058:                		fmt = FS_FAT16;
2059:                	if (nclst >= MIN_FAT32)
9D004E5C  3402FFF6   ORI V0, ZERO, -10
9D004E60  00A2102B   SLTU V0, A1, V0
9D004E64  10400084   BEQ V0, ZERO, 0x9D005078
9D004E68  24A50002   ADDIU A1, A1, 2
2060:                		fmt = FS_FAT32;
9D00508C  0B4013A2   J 0x9D004E88
9D005090  24120003   ADDIU S2, ZERO, 3
2061:                
2062:                	/* Boundaries and Limits */
2063:                	fs->n_fatent = nclst + 2; /* Number of FAT entries */
9D004E6C  AE050018   SW A1, 24(S0)
9D005078  AE050018   SW A1, 24(S0)
2064:                	fs->database = bsect + sysect; /* Data start sector */
9D004E70  02294821   ADDU T1, S1, T1
9D004E74  AE090028   SW T1, 40(S0)
9D00507C  02294821   ADDU T1, S1, T1
9D005080  AE090028   SW T1, 40(S0)
2065:                	fs->fatbase = bsect + nrsv; /* FAT start sector */
9D004E78  02284021   ADDU T0, S1, T0
9D005084  02284021   ADDU T0, S1, T0
9D005088  AE080020   SW T0, 32(S0)
2066:                	if (fmt == FS_FAT32) {
9D004E7C  24020003   ADDIU V0, ZERO, 3
9D004E80  16420010   BNE S2, V0, 0x9D004EC4
9D004E84  AE080020   SW T0, 32(S0)
2067:                		if (fs->n_rootdir)
9D004E88  14C00075   BNE A2, ZERO, 0x9D005060
9D004E8C  2402000D   ADDIU V0, ZERO, 13
2068:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be 0) */
2069:                		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
9D004E90  9204005F   LBU A0, 95(S0)
9D004E94  00042600   SLL A0, A0, 24
9D004E98  9202005E   LBU V0, 94(S0)
9D004E9C  00021400   SLL V0, V0, 16
9D004EA0  00822025   OR A0, A0, V0
9D004EA4  9202005C   LBU V0, 92(S0)
9D004EA8  00822025   OR A0, A0, V0
9D004EAC  9202005D   LBU V0, 93(S0)
9D004EB0  00021200   SLL V0, V0, 8
9D004EB4  00821025   OR V0, A0, V0
9D004EB8  AE020024   SW V0, 36(S0)
2070:                		szbfat = fs->n_fatent * 4; /* (Required FAT size) */
9D004EBC  0B4013BE   J 0x9D004EF8
9D004EC0  00052880   SLL A1, A1, 2
2071:                	} else {
2072:                		if (!fs->n_rootdir)
9D004EC4  10C00066   BEQ A2, ZERO, 0x9D005060
9D004EC8  2402000D   ADDIU V0, ZERO, 13
2073:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must not be 0) */
2074:                		fs->dirbase = fs->fatbase + fasize; /* Root directory start sector */
9D004ECC  00882021   ADDU A0, A0, T0
2075:                		szbfat = (fmt == FS_FAT16) ? /* (Required FAT size) */
2076:                		fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
9D004ED0  24020002   ADDIU V0, ZERO, 2
9D004ED4  16420003   BNE S2, V0, 0x9D004EE4
9D004ED8  AE040024   SW A0, 36(S0)
9D004EDC  0B4013BE   J 0x9D004EF8
9D004EE0  00052840   SLL A1, A1, 1
9D004EE4  24020003   ADDIU V0, ZERO, 3
9D004EE8  70A21002   MUL V0, A1, V0
9D004EEC  00021042   SRL V0, V0, 1
9D004EF0  30A50001   ANDI A1, A1, 1
9D004EF4  00452821   ADDU A1, V0, A1
2077:                	}
2078:                	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) /* (BPB_FATSz must not be less than required) */
9D004EF8  24A501FF   ADDIU A1, A1, 511
9D004EFC  00052A42   SRL A1, A1, 9
9D004F00  0065182B   SLTU V1, V1, A1
9D004F04  14600056   BNE V1, ZERO, 0x9D005060
9D004F08  2402000D   ADDIU V0, ZERO, 13
2079:                		return FR_NO_FILESYSTEM;
2080:                
2081:                #if !_FS_READONLY
2082:                	/* Initialize cluster allocation information */
2083:                	fs->free_clust = 0xFFFFFFFF;
9D004F0C  2402FFFF   ADDIU V0, ZERO, -1
9D004F10  AE020010   SW V0, 16(S0)
2084:                	fs->last_clust = 0;
2085:                
2086:                	/* Get fsinfo if available */
2087:                	if (fmt == FS_FAT32) {
9D004F14  24020003   ADDIU V0, ZERO, 3
9D004F18  16420048   BNE S2, V0, 0x9D00503C
9D004F1C  AE00000C   SW ZERO, 12(S0)
2088:                		fs->fsi_flag = 0;
9D004F20  A2000005   SB ZERO, 5(S0)
2089:                		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
9D004F24  92060061   LBU A2, 97(S0)
9D004F28  00063200   SLL A2, A2, 8
9D004F2C  92020060   LBU V0, 96(S0)
9D004F30  00C23025   OR A2, A2, V0
9D004F34  02263021   ADDU A2, S1, A2
9D004F38  AE060014   SW A2, 20(S0)
2090:                		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK
9D004F3C  92040001   LBU A0, 1(S0)
9D004F40  26050030   ADDIU A1, S0, 48
9D004F44  0F4023A1   JAL disk_read
9D004F48  24070001   ADDIU A3, ZERO, 1
9D004F4C  5440003C   BNEL V0, ZERO, 0x9D005040
9D004F50  A2120000   SB S2, 0(S0)
2091:                				&& LD_WORD(fs->win+BS_55AA) == 0xAA55
9D004F54  9203022F   LBU V1, 559(S0)
9D004F58  00031A00   SLL V1, V1, 8
9D004F5C  9202022E   LBU V0, 558(S0)
9D004F60  00621825   OR V1, V1, V0
9D004F64  7C031E20   SEH V1, V1
9D004F68  2402AA55   ADDIU V0, ZERO, -21931
9D004F6C  54620034   BNEL V1, V0, 0x9D005040
9D004F70  A2120000   SB S2, 0(S0)
2092:                				&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
9D004F74  92030033   LBU V1, 51(S0)
9D004F78  00031E00   SLL V1, V1, 24
9D004F7C  92020032   LBU V0, 50(S0)
9D004F80  00021400   SLL V0, V0, 16
9D004F84  00621825   OR V1, V1, V0
9D004F88  92020030   LBU V0, 48(S0)
9D004F8C  00621825   OR V1, V1, V0
9D004F90  92020031   LBU V0, 49(S0)
9D004F94  00021200   SLL V0, V0, 8
9D004F98  00621825   OR V1, V1, V0
9D004F9C  3C024161   LUI V0, 16737
9D004FA0  24425252   ADDIU V0, V0, 21074
9D004FA4  54620026   BNEL V1, V0, 0x9D005040
9D004FA8  A2120000   SB S2, 0(S0)
2093:                				&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
9D004FAC  92030217   LBU V1, 535(S0)
9D004FB0  00031E00   SLL V1, V1, 24
9D004FB4  92020216   LBU V0, 534(S0)
9D004FB8  00021400   SLL V0, V0, 16
9D004FBC  00621825   OR V1, V1, V0
9D004FC0  92020214   LBU V0, 532(S0)
9D004FC4  00621825   OR V1, V1, V0
9D004FC8  92020215   LBU V0, 533(S0)
9D004FCC  00021200   SLL V0, V0, 8
9D004FD0  00621825   OR V1, V1, V0
9D004FD4  3C026141   LUI V0, 24897
9D004FD8  24427272   ADDIU V0, V0, 29298
9D004FDC  54620018   BNEL V1, V0, 0x9D005040
9D004FE0  A2120000   SB S2, 0(S0)
2094:                			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
9D004FE4  9203021F   LBU V1, 543(S0)
9D004FE8  00031E00   SLL V1, V1, 24
9D004FEC  9202021E   LBU V0, 542(S0)
9D004FF0  00021400   SLL V0, V0, 16
9D004FF4  00621825   OR V1, V1, V0
9D004FF8  9202021C   LBU V0, 540(S0)
9D004FFC  00621825   OR V1, V1, V0
9D005000  9202021D   LBU V0, 541(S0)
9D005004  00021200   SLL V0, V0, 8
9D005008  00621025   OR V0, V1, V0
9D00500C  AE02000C   SW V0, 12(S0)
2095:                			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
9D005010  9203021B   LBU V1, 539(S0)
9D005014  00031E00   SLL V1, V1, 24
9D005018  9202021A   LBU V0, 538(S0)
9D00501C  00021400   SLL V0, V0, 16
9D005020  00621825   OR V1, V1, V0
9D005024  92020218   LBU V0, 536(S0)
9D005028  00621825   OR V1, V1, V0
9D00502C  92020219   LBU V0, 537(S0)
9D005030  00021200   SLL V0, V0, 8
9D005034  00621025   OR V0, V1, V0
9D005038  AE020010   SW V0, 16(S0)
2096:                		}
2097:                	}
2098:                #endif
2099:                	fs->fs_type = fmt; /* FAT sub-type */
9D00503C  A2120000   SB S2, 0(S0)
2100:                	fs->id = ++Fsid; /* File system mount ID */
9D005040  97828094   LHU V0, -32620(GP)
9D005044  24420001   ADDIU V0, V0, 1
9D005048  3042FFFF   ANDI V0, V0, -1
9D00504C  A7828094   SH V0, -32620(GP)
9D005050  A6020006   SH V0, 6(S0)
2101:                	fs->winsect = 0; /* Invalidate sector cache */
9D005054  AE00002C   SW ZERO, 44(S0)
2102:                	fs->wflag = 0;
9D005058  A2000004   SB ZERO, 4(S0)
2103:                #if _FS_RPATH
2104:                	fs->cdir = 0; /* Current directory (root dir) */
2105:                #endif
2106:                #if _FS_SHARE				/* Clear file lock semaphores */
2107:                	clear_lock(fs);
2108:                #endif
2109:                
2110:                	return FR_OK;
9D00505C  00001021   ADDU V0, ZERO, ZERO
2111:                }
9D005060  8FBF001C   LW RA, 28(SP)
9D005064  8FB20018   LW S2, 24(SP)
9D005068  8FB10014   LW S1, 20(SP)
9D00506C  8FB00010   LW S0, 16(SP)
9D005070  03E00008   JR RA
9D005074  27BD0020   ADDIU SP, SP, 32
2112:                
2113:                /*-----------------------------------------------------------------------*/
2114:                /* Check if the file/dir object is valid or not                          */
2115:                /*-----------------------------------------------------------------------*/
2116:                
2117:                static FRESULT validate( /* FR_OK(0): The object is valid, !=0: Invalid */
2118:                FATFS *fs, /* Pointer to the file system object */
2119:                PF_WORD id /* Member id of the target object to be checked */
2120:                ) {
9D003CAC  27BDFFE8   ADDIU SP, SP, -24
9D003CB0  AFBF0014   SW RA, 20(SP)
2121:                	if (!fs || !fs->fs_type || fs->id != id)
9D003CB4  1080000D   BEQ A0, ZERO, 0x9D003CEC
9D003CB8  24020009   ADDIU V0, ZERO, 9
9D003CBC  90830000   LBU V1, 0(A0)
9D003CC0  1060000B   BEQ V1, ZERO, 0x9D003CF0
9D003CC4  8FBF0014   LW RA, 20(SP)
9D003CC8  94830006   LHU V1, 6(A0)
9D003CCC  14650008   BNE V1, A1, 0x9D003CF0
9D003CD0  00000000   NOP
2122:                		return FR_INVALID_OBJECT;
2123:                
2124:                	ENTER_FF(fs); /* Lock file system */
2125:                
2126:                	if (disk_status(fs->drv) & STA_NOINIT)
9D003CD4  0F40239A   JAL disk_status
9D003CD8  90840001   LBU A0, 1(A0)
9D003CDC  30420001   ANDI V0, V0, 1
2127:                		return FR_NOT_READY;
9D003CE0  24030003   ADDIU V1, ZERO, 3
9D003CE4  0002180A   MOVZ V1, ZERO, V0
9D003CE8  00601021   ADDU V0, V1, ZERO
2128:                
2129:                	return FR_OK;
2130:                }
9D003CEC  8FBF0014   LW RA, 20(SP)
9D003CF0  03E00008   JR RA
9D003CF4  27BD0018   ADDIU SP, SP, 24
2131:                
2132:                /*--------------------------------------------------------------------------
2133:                
2134:                 Public Functions
2135:                
2136:                 --------------------------------------------------------------------------*/
2137:                
2138:                /*-----------------------------------------------------------------------*/
2139:                /* Mount/Unmount a Logical Drive                                         */
2140:                /*-----------------------------------------------------------------------*/
2141:                
2142:                FRESULT f_mount(PF_BYTE vol, /* Logical drive number to be mounted/unmounted */
2143:                                FATFS *fs /* Pointer to new file system object (NULL for unmount)*/
2144:                                ) {
9D005094  308400FF   ANDI A0, A0, 255
2145:                	FATFS *rfs;
2146:                
2147:                	if (vol >= _VOLUMES) {/* Check if the drive number is valid */
9D005098  14800008   BNE A0, ZERO, 0x9D0050BC
9D00509C  2402000B   ADDIU V0, ZERO, 11
2148:                		return FR_INVALID_DRIVE;
2149:                	}
2150:                	rfs = FatFs[vol]; /* Get current fs object */
9D0050A0  8F828090   LW V0, -32624(GP)
2151:                
2152:                	if (rfs) {
9D0050A4  54400001   BNEL V0, ZERO, 0x9D0050AC
9D0050A8  A0400000   SB ZERO, 0(V0)
2153:                #if _FS_SHARE
2154:                		clear_lock(rfs);
2155:                #endif
2156:                #if _FS_REENTRANT				/* Discard sync object of the current volume */
2157:                		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2158:                #endif
2159:                		rfs->fs_type = 0; /* Clear old fs object */
2160:                	}
2161:                
2162:                	if (fs) {
9D0050AC  54A00001   BNEL A1, ZERO, 0x9D0050B4
9D0050B0  A0A00000   SB ZERO, 0(A1)
2163:                		fs->fs_type = 0; /* Clear new fs object */
2164:                #if _FS_REENTRANT				/* Create sync object for the new volume */
2165:                		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2166:                #endif
2167:                	}
2168:                	FatFs[vol] = fs; /* Register new fs object */
9D0050B4  AF858090   SW A1, -32624(GP)
2169:                
2170:                	return FR_OK;
9D0050B8  00001021   ADDU V0, ZERO, ZERO
2171:                }
9D0050BC  03E00008   JR RA
9D0050C0  00000000   NOP
2172:                
2173:                /*-----------------------------------------------------------------------*/
2174:                /* Open or Create a File                                                 */
2175:                /*-----------------------------------------------------------------------*/
2176:                
2177:                FRESULT f_open(FIL *fp, /* Pointer to the blank file object */
2178:                                const TCHAR *path, /* Pointer to the file name */
2179:                                PF_BYTE mode /* Access mode and file open mode flags */
2180:                                ) {
9D0050C4  27BDFFB0   ADDIU SP, SP, -80
9D0050C8  AFBF004C   SW RA, 76(SP)
9D0050CC  AFB40048   SW S4, 72(SP)
9D0050D0  AFB30044   SW S3, 68(SP)
9D0050D4  AFB20040   SW S2, 64(SP)
9D0050D8  AFB1003C   SW S1, 60(SP)
9D0050DC  AFB00038   SW S0, 56(SP)
9D0050E0  00808821   ADDU S1, A0, ZERO
9D0050E4  AFA50054   SW A1, 84(SP)
2181:                	FRESULT res;
2182:                	DIR dj;
2183:                	PF_BYTE *dir;
2184:                	DEF_NAMEBUF;
2185:                
2186:                	fp->fs = 0; /* Clear file object */
9D0050E8  AC800000   SW ZERO, 0(A0)
2187:                
2188:                #if !_FS_READONLY
2189:                	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS
9D0050EC  30D2001F   ANDI S2, A2, 31
2190:                			| FA_CREATE_NEW;
2191:                	res = chk_mounted(&path, &dj.fs, (PF_BYTE) (mode & ~FA_READ));
9D0050F0  02409821   ADDU S3, S2, ZERO
9D0050F4  27A40054   ADDIU A0, SP, 84
9D0050F8  27A50010   ADDIU A1, SP, 16
9D0050FC  0F4012F3   JAL chk_mounted
9D005100  3246001E   ANDI A2, S2, 30
2192:                #else
2193:                	mode &= FA_READ;
2194:                	res = chk_mounted(&path, &dj.fs, 0);
2195:                #endif
2196:                	INIT_BUF(dj);
9D005104  27A3002C   ADDIU V1, SP, 44
2197:                	if (res == FR_OK)
9D005108  14400086   BNE V0, ZERO, 0x9D005324
9D00510C  AFA30028   SW V1, 40(SP)
2198:                		res = follow_path(&dj, path); /* Follow the file path */
9D005110  27A40010   ADDIU A0, SP, 16
9D005114  0F40116C   JAL 0x9D0045B0
9D005118  8FA50054   LW A1, 84(SP)
2199:                	dir = dj.dir;
9D005324  0B40144B   J 0x9D00512C
9D005328  8FB00024   LW S0, 36(SP)
2200:                
2201:                #if !_FS_READONLY	/* R/W configuration */
2202:                	if (res == FR_OK) {
9D00511C  14400003   BNE V0, ZERO, 0x9D00512C
9D005120  8FB00024   LW S0, 36(SP)
2203:                		if (!dir) /* Current dir itself */
2204:                			res = FR_INVALID_NAME;
9D005124  24030006   ADDIU V1, ZERO, 6
9D005128  0070100A   MOVZ V0, V1, S0
2205:                #if _FS_SHARE
2206:                		else
2207:                		res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2208:                #endif
2209:                	}
2210:                	/* Create or Open a file */
2211:                	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
9D00512C  3263001C   ANDI V1, S3, 28
9D005130  10600044   BEQ V1, ZERO, 0x9D005244
9D005134  00000000   NOP
2212:                		DWORD dw, cl;
2213:                
2214:                		if (res != FR_OK) { /* No file, create new */
9D005138  5040000B   BEQL V0, ZERO, 0x9D005168
9D00513C  9203000B   LBU V1, 11(S0)
2215:                			if (res == FR_NO_FILE) /* There is no file to open, create a new entry */
9D005140  24030004   ADDIU V1, ZERO, 4
9D005144  14430070   BNE V0, V1, 0x9D005308
9D005148  8FBF004C   LW RA, 76(SP)
2216:                #if _FS_SHARE
2217:                				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
2218:                #else
2219:                				res = dir_register(&dj);
9D00514C  0F40125A   JAL 0x9D004968
9D005150  27A40010   ADDIU A0, SP, 16
2220:                #endif
2221:                			mode |= FA_CREATE_ALWAYS; /* File is created */
2222:                			dir = dj.dir; /* New entry */
9D005154  8FB00024   LW S0, 36(SP)
2223:                		} else { /* Any object is already existing */
2224:                			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) { /* Cannot overwrite it (R/O or DIR) */
9D005168  30630011   ANDI V1, V1, 17
9D00516C  14600065   BNE V1, ZERO, 0x9D005304
9D005170  24020007   ADDIU V0, ZERO, 7
2225:                				res = FR_DENIED;
2226:                			} else {
2227:                				if (mode & FA_CREATE_NEW) /* Cannot create as new file */
9D005174  32730004   ANDI S3, S3, 4
9D005178  16600062   BNE S3, ZERO, 0x9D005304
9D00517C  24020008   ADDIU V0, ZERO, 8
2228:                					res = FR_EXIST;
2229:                			}
2230:                		}
2231:                		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) { /* Truncate it if overwrite mode */
9D005158  10400009   BEQ V0, ZERO, 0x9D005180
9D00515C  36520008   ORI S2, S2, 8
9D005180  32420008   ANDI V0, S2, 8
9D005184  1040003F   BEQ V0, ZERO, 0x9D005284
9D005188  8FA30010   LW V1, 16(SP)
2232:                			dw = get_fattime(); /* Created time */
9D00518C  0F4024FC   JAL get_fattime
9D005190  00000000   NOP
2233:                			ST_DWORD(dir+DIR_CrtTime, dw);
9D005194  A202000E   SB V0, 14(S0)
9D005198  7C433A00   EXT V1, V0, 8, 8
9D00519C  A203000F   SB V1, 15(S0)
9D0051A0  00021C02   SRL V1, V0, 16
9D0051A4  A2030010   SB V1, 16(S0)
9D0051A8  00021602   SRL V0, V0, 24
9D0051AC  A2020011   SB V0, 17(S0)
2234:                			dir[DIR_Attr] = 0; /* Reset attribute */
9D0051B0  A200000B   SB ZERO, 11(S0)
2235:                			ST_DWORD(dir+DIR_FileSize, 0); /* size = 0 */
9D0051B4  A200001C   SB ZERO, 28(S0)
9D0051B8  A200001D   SB ZERO, 29(S0)
9D0051BC  A200001E   SB ZERO, 30(S0)
9D0051C0  A200001F   SB ZERO, 31(S0)
2236:                			cl = LD_CLUST(dir); /* Get start cluster */
9D0051C4  92020015   LBU V0, 21(S0)
9D0051C8  00021200   SLL V0, V0, 8
9D0051CC  92030014   LBU V1, 20(S0)
9D0051D0  00431025   OR V0, V0, V1
9D0051D4  00021400   SLL V0, V0, 16
9D0051D8  9213001B   LBU S3, 27(S0)
9D0051DC  00139A00   SLL S3, S3, 8
9D0051E0  9203001A   LBU V1, 26(S0)
9D0051E4  02639825   OR S3, S3, V1
9D0051E8  00539825   OR S3, V0, S3
2237:                			ST_CLUST(dir, 0); /* cluster = 0 */
9D0051EC  A200001A   SB ZERO, 26(S0)
9D0051F0  A200001B   SB ZERO, 27(S0)
9D0051F4  A2000014   SB ZERO, 20(S0)
9D0051F8  A2000015   SB ZERO, 21(S0)
2238:                			dj.fs->wflag = 1;
9D0051FC  8FA40010   LW A0, 16(SP)
9D005200  24020001   ADDIU V0, ZERO, 1
2239:                			if (cl) { /* Remove the cluster chain if exist */
9D005204  12600049   BEQ S3, ZERO, 0x9D00532C
9D005208  A0820004   SB V0, 4(A0)
2240:                				dw = dj.fs->winsect;
9D00520C  8C94002C   LW S4, 44(A0)
2241:                				res = remove_chain(dj.fs, cl);
9D005210  0F4012B9   JAL 0x9D004AE4
9D005214  02602821   ADDU A1, S3, ZERO
2242:                				if (res == FR_OK) {
9D005218  1440003B   BNE V0, ZERO, 0x9D005308
9D00521C  8FBF004C   LW RA, 76(SP)
2243:                					dj.fs->last_clust = cl - 1; /* Reuse the cluster hole */
9D005220  8FA40010   LW A0, 16(SP)
9D005224  2673FFFF   ADDIU S3, S3, -1
9D005228  AC93000C   SW S3, 12(A0)
2244:                					res = move_window(dj.fs, dw);
9D00522C  0F400E6A   JAL 0x9D0039A8
9D005230  02802821   ADDU A1, S4, ZERO
2245:                				}
2246:                			}
2247:                		}
2248:                	} else { /* Open an existing file */
2249:                		if (res == FR_OK) { /* Follow succeeded */
9D005244  14400030   BNE V0, ZERO, 0x9D005308
9D005248  8FBF004C   LW RA, 76(SP)
2250:                			if (dir[DIR_Attr] & AM_DIR) { /* It is a directory */
9D00524C  9203000B   LBU V1, 11(S0)
9D005250  30640010   ANDI A0, V1, 16
9D005254  1480002B   BNE A0, ZERO, 0x9D005304
9D005258  24020004   ADDIU V0, ZERO, 4
2251:                				res = FR_NO_FILE;
2252:                			} else {
2253:                				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
9D00525C  32730002   ANDI S3, S3, 2
9D005260  12600033   BEQ S3, ZERO, 0x9D005330
9D005264  32420008   ANDI V0, S2, 8
9D005268  30630001   ANDI V1, V1, 1
9D00526C  14600025   BNE V1, ZERO, 0x9D005304
9D005270  24020007   ADDIU V0, ZERO, 7
2254:                					res = FR_DENIED;
2255:                			}
2256:                		}
2257:                	}
2258:                	if (res == FR_OK) {
9D005234  10400012   BEQ V0, ZERO, 0x9D005280
9D005238  36520020   ORI S2, S2, 32
2259:                		if (mode & FA_CREATE_ALWAYS) /* Set file change flag if created or overwritten */
9D005274  0B4014CC   J 0x9D005330
9D005278  32420008   ANDI V0, S2, 8
9D00532C  32420008   ANDI V0, S2, 8
9D005330  1040FFD4   BEQ V0, ZERO, 0x9D005284
9D005334  8FA30010   LW V1, 16(SP)
9D005338  0B40149F   J 0x9D00527C
9D00533C  00001021   ADDU V0, ZERO, ZERO
2260:                			mode |= FA__WRITTEN;
9D00527C  36520020   ORI S2, S2, 32
2261:                		fp->dir_sect = dj.fs->winsect; /* Pointer to the directory entry */
9D005280  8FA30010   LW V1, 16(SP)
9D005284  8C64002C   LW A0, 44(V1)
9D005288  AE24001C   SW A0, 28(S1)
2262:                		fp->dir_ptr = dir;
9D00528C  AE300020   SW S0, 32(S1)
2263:                #if _FS_SHARE
2264:                		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2265:                		if (!fp->lockid) res = FR_INT_ERR;
2266:                #endif
2267:                	}
2268:                
2269:                #else				/* R/O configuration */
2270:                	if (res == FR_OK) { /* Follow succeeded */
2271:                		if (!dir) { /* Current dir itself */
2272:                			res = FR_INVALID_NAME;
2273:                		} else {
2274:                			if (dir[DIR_Attr] & AM_DIR) /* It is a directory */
2275:                			res = FR_NO_FILE;
2276:                		}
2277:                	}
2278:                #endif
2279:                	FREE_BUF();
2280:                
2281:                	if (res == FR_OK) {
2282:                		fp->flag = mode; /* File access mode */
9D005290  A2320006   SB S2, 6(S1)
2283:                		fp->sclust = LD_CLUST(dir); /* File start cluster */
9D005294  92050015   LBU A1, 21(S0)
9D005298  00052A00   SLL A1, A1, 8
9D00529C  92060014   LBU A2, 20(S0)
9D0052A0  00A62825   OR A1, A1, A2
9D0052A4  00052C00   SLL A1, A1, 16
9D0052A8  9204001B   LBU A0, 27(S0)
9D0052AC  00042200   SLL A0, A0, 8
9D0052B0  9206001A   LBU A2, 26(S0)
9D0052B4  00862025   OR A0, A0, A2
9D0052B8  00A42025   OR A0, A1, A0
9D0052BC  AE240010   SW A0, 16(S1)
2284:                		fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
9D0052C0  9205001F   LBU A1, 31(S0)
9D0052C4  00052E00   SLL A1, A1, 24
9D0052C8  9204001E   LBU A0, 30(S0)
9D0052CC  00042400   SLL A0, A0, 16
9D0052D0  00A42025   OR A0, A1, A0
9D0052D4  9205001C   LBU A1, 28(S0)
9D0052D8  00852025   OR A0, A0, A1
9D0052DC  9205001D   LBU A1, 29(S0)
9D0052E0  00052A00   SLL A1, A1, 8
9D0052E4  00852025   OR A0, A0, A1
9D0052E8  AE24000C   SW A0, 12(S1)
2285:                		fp->fptr = 0; /* File pointer */
9D0052EC  AE200008   SW ZERO, 8(S1)
2286:                		fp->dsect = 0;
9D0052F0  AE200018   SW ZERO, 24(S1)
2287:                #if _USE_FASTSEEK
2288:                		fp->cltbl = 0; /* Normal seek mode */
9D0052F4  AE200024   SW ZERO, 36(S1)
2289:                #endif
2290:                		fp->fs = dj.fs;
9D0052F8  AE230000   SW V1, 0(S1)
2291:                		fp->id = dj.fs->id; /* Validate file object */
9D0052FC  94630006   LHU V1, 6(V1)
9D005300  A6230004   SH V1, 4(S1)
2292:                	}
2293:                
2294:                	LEAVE_FF(dj.fs, res);
2295:                }
9D005160  0B4014C2   J 0x9D005308
9D005164  8FBF004C   LW RA, 76(SP)
9D00523C  0B4014C2   J 0x9D005308
9D005240  8FBF004C   LW RA, 76(SP)
9D005304  8FBF004C   LW RA, 76(SP)
9D005308  8FB40048   LW S4, 72(SP)
9D00530C  8FB30044   LW S3, 68(SP)
9D005310  8FB20040   LW S2, 64(SP)
9D005314  8FB1003C   LW S1, 60(SP)
9D005318  8FB00038   LW S0, 56(SP)
9D00531C  03E00008   JR RA
9D005320  27BD0050   ADDIU SP, SP, 80
2296:                
2297:                /*-----------------------------------------------------------------------*/
2298:                /* Read File                                                             */
2299:                /*-----------------------------------------------------------------------*/
2300:                
2301:                FRESULT f_read(FIL *fp, /* Pointer to the file object */
2302:                                void *buff, /* Pointer to data buffer */
2303:                                UINT btr, /* Number of bytes to read */
2304:                                UINT *br /* Pointer to number of bytes read */
2305:                                ) {
9D005340  27BDFFC8   ADDIU SP, SP, -56
9D005344  AFBF0034   SW RA, 52(SP)
9D005348  AFBE0030   SW S8, 48(SP)
9D00534C  AFB7002C   SW S7, 44(SP)
9D005350  AFB60028   SW S6, 40(SP)
9D005354  AFB50024   SW S5, 36(SP)
9D005358  AFB40020   SW S4, 32(SP)
9D00535C  AFB3001C   SW S3, 28(SP)
9D005360  AFB20018   SW S2, 24(SP)
9D005364  AFB10014   SW S1, 20(SP)
9D005368  AFB00010   SW S0, 16(SP)
9D00536C  00808021   ADDU S0, A0, ZERO
9D005370  00A0A021   ADDU S4, A1, ZERO
9D005374  00C08821   ADDU S1, A2, ZERO
9D005378  00E09821   ADDU S3, A3, ZERO
2306:                	FRESULT res;
2307:                	DWORD clst, sect, remain;
2308:                	UINT rcnt, cc;
2309:                	PF_BYTE csect, *rbuff = buff;
2310:                
2311:                	*br = 0; /* Initialize byte counter */
9D00537C  ACE00000   SW ZERO, 0(A3)
2312:                
2313:                	res = validate(fp->fs, fp->id); /* Check validity */
9D005380  8C840000   LW A0, 0(A0)
9D005384  0F400F2B   JAL 0x9D003CAC
9D005388  96050004   LHU A1, 4(S0)
2314:                	if (res != FR_OK)
9D00538C  1440008A   BNE V0, ZERO, 0x9D0055B8
9D005390  0040B821   ADDU S7, V0, ZERO
2315:                		LEAVE_FF(fp->fs, res);
2316:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D005394  92020006   LBU V0, 6(S0)
9D005398  7C021C20   SEB V1, V0
9D00539C  04600085   BLTZ V1, 0x9D0055B4
9D0053A0  30420001   ANDI V0, V0, 1
2317:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2318:                	if (!(fp->flag & FA_READ)) /* Check access mode */
9D0053A4  50400084   BEQL V0, ZERO, 0x9D0055B8
9D0053A8  24170007   ADDIU S7, ZERO, 7
9D0053B8  0251102B   SLTU V0, S2, S1
9D0053BC  0222900A   MOVZ S2, S1, V0
2319:                		LEAVE_FF(fp->fs, FR_DENIED);
2320:                	remain = fp->fsize - fp->fptr;
9D0053AC  8E12000C   LW S2, 12(S0)
9D0053B0  8E020008   LW V0, 8(S0)
9D0053B4  02429023   SUBU S2, S2, V0
2321:                	if (btr > remain)
2322:                		btr = (UINT) remain; /* Truncate btr by remaining bytes */
2323:                
2324:                	for (; btr; /* Repeat until all data read */
9D0053C0  1240007E   BEQ S2, ZERO, 0x9D0055BC
9D0053C4  02E01021   ADDU V0, S7, ZERO
9D0055A4  12400004   BEQ S2, ZERO, 0x9D0055B8
9D0055A8  AE620000   SW V0, 0(S3)
2325:                	rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
9D00558C  8E020008   LW V0, 8(S0)
9D005590  00511021   ADDU V0, V0, S1
9D005594  AE020008   SW V0, 8(S0)
9D005598  8E620000   LW V0, 0(S3)
9D00559C  00511021   ADDU V0, V0, S1
9D0055A0  02519023   SUBU S2, S2, S1
9D0055AC  0B4014F2   J 0x9D0053C8
9D0055B0  0291A021   ADDU S4, S4, S1
9D0055B4  24170002   ADDIU S7, ZERO, 2
2326:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D0053C8  8E050008   LW A1, 8(S0)
9D0053CC  30A201FF   ANDI V0, A1, 511
9D0053D0  54400057   BNEL V0, ZERO, 0x9D005530
9D0053D4  8E110008   LW S1, 8(S0)
2327:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D0053D8  8E040000   LW A0, 0(S0)
9D0053DC  00051242   SRL V0, A1, 9
9D0053E0  90950002   LBU S5, 2(A0)
9D0053E4  26B5FFFF   ADDIU S5, S5, -1
9D0053E8  0055A824   AND S5, V0, S5
9D0053EC  32B500FF   ANDI S5, S5, 255
2328:                			if (!csect) { /* On the cluster boundary? */
9D0053F0  56A0001F   BNEL S5, ZERO, 0x9D005470
9D0053F4  8E160000   LW S6, 0(S0)
2329:                				if (fp->fptr == 0) { /* On the top of the file? */
9D0053F8  54A00003   BNEL A1, ZERO, 0x9D005408
9D0053FC  8E020024   LW V0, 36(S0)
2330:                					clst = fp->sclust; /* Follow from the origin */
9D005400  0B40150A   J 0x9D005428
9D005404  8E020010   LW V0, 16(S0)
2331:                				} else { /* Middle or end of the file */
2332:                #if _USE_FASTSEEK
2333:                					if (fp->cltbl)
9D005408  10400005   BEQ V0, ZERO, 0x9D005420
9D00540C  00000000   NOP
2334:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D005410  0F400E03   JAL 0x9D00380C
9D005414  02002021   ADDU A0, S0, ZERO
2335:                					else
2336:                #endif
2337:                						clst = get_fat(fp->fs, fp->clust); /* Follow cluster chain on the FAT */
9D005420  0F400F4A   JAL get_fat
9D005424  8E050014   LW A1, 20(S0)
2338:                				}
2339:                				if (clst < 2)
9D005418  0B40150B   J 0x9D00542C
9D00541C  2C430002   SLTIU V1, V0, 2
9D005428  2C430002   SLTIU V1, V0, 2
9D00542C  10600007   BEQ V1, ZERO, 0x9D00544C
9D005430  2403FFFF   ADDIU V1, ZERO, -1
2340:                					ABORT(fp->fs, FR_INT_ERR);
9D005434  92030006   LBU V1, 6(S0)
9D005438  2402FF80   ADDIU V0, ZERO, -128
9D00543C  00621025   OR V0, V1, V0
9D005440  A2020006   SB V0, 6(S0)
9D005444  0B40156E   J 0x9D0055B8
9D005448  24170002   ADDIU S7, ZERO, 2
2341:                				if (clst == 0xFFFFFFFF)
9D00544C  54430007   BNEL V0, V1, 0x9D00546C
9D005450  AE020014   SW V0, 20(S0)
2342:                					ABORT(fp->fs, FR_DISK_ERR);
9D005454  92030006   LBU V1, 6(S0)
9D005458  2402FF80   ADDIU V0, ZERO, -128
9D00545C  00621025   OR V0, V1, V0
9D005460  A2020006   SB V0, 6(S0)
9D005464  0B40156E   J 0x9D0055B8
9D005468  24170001   ADDIU S7, ZERO, 1
2343:                				fp->clust = clst; /* Update current cluster */
2344:                			}
2345:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D00546C  8E160000   LW S6, 0(S0)
9D005470  02C02021   ADDU A0, S6, ZERO
9D005474  0F400F3E   JAL clust2sect
9D005478  8E050014   LW A1, 20(S0)
2346:                			if (!sect)
9D00547C  14400007   BNE V0, ZERO, 0x9D00549C
9D005480  00128A42   SRL S1, S2, 9
2347:                				ABORT(fp->fs, FR_INT_ERR);
9D005484  92030006   LBU V1, 6(S0)
9D005488  2402FF80   ADDIU V0, ZERO, -128
9D00548C  00621025   OR V0, V1, V0
9D005490  A2020006   SB V0, 6(S0)
9D005494  0B40156E   J 0x9D0055B8
9D005498  24170002   ADDIU S7, ZERO, 2
2348:                			sect += csect;
2349:                			cc = btr / SS(fp->fs); /* When remaining bytes >= sector size, */
2350:                			if (cc) { /* Read maximum contiguous sectors directly */
9D00549C  12200022   BEQ S1, ZERO, 0x9D005528
9D0054A0  0055F021   ADDU S8, V0, S5
2351:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D0054A4  92C20002   LBU V0, 2(S6)
9D0054A8  02351821   ADDU V1, S1, S5
9D0054AC  0043182B   SLTU V1, V0, V1
2352:                					cc = fp->fs->csize - csect;
9D0054B0  0055A823   SUBU S5, V0, S5
9D0054B4  02A3880B   MOVN S1, S5, V1
2353:                				if (disk_read(fp->fs->drv, rbuff, sect, (PF_BYTE) cc) != RES_OK)
9D0054B8  92C40001   LBU A0, 1(S6)
9D0054BC  02802821   ADDU A1, S4, ZERO
9D0054C0  03C03021   ADDU A2, S8, ZERO
9D0054C4  0F4023A1   JAL disk_read
9D0054C8  322700FF   ANDI A3, S1, 255
9D0054CC  50400007   BEQL V0, ZERO, 0x9D0054EC
9D0054D0  8E050000   LW A1, 0(S0)
2354:                					ABORT(fp->fs, FR_DISK_ERR);
9D0054D4  92030006   LBU V1, 6(S0)
9D0054D8  2402FF80   ADDIU V0, ZERO, -128
9D0054DC  00621025   OR V0, V1, V0
9D0054E0  A2020006   SB V0, 6(S0)
9D0054E4  0B40156E   J 0x9D0055B8
9D0054E8  24170001   ADDIU S7, ZERO, 1
2355:                #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
2356:                #if _FS_TINY
2357:                				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
9D0054EC  90A20004   LBU V0, 4(A1)
9D0054F0  50400026   BEQL V0, ZERO, 0x9D00558C
9D0054F4  00118A40   SLL S1, S1, 9
9D0054F8  8CA2002C   LW V0, 44(A1)
9D0054FC  005EF023   SUBU S8, V0, S8
9D005500  03D1102B   SLTU V0, S8, S1
9D005504  50400021   BEQL V0, ZERO, 0x9D00558C
9D005508  00118A40   SLL S1, S1, 9
2358:                				mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
9D00550C  001EF240   SLL S8, S8, 9
9D005510  029E2021   ADDU A0, S4, S8
9D005514  24A50030   ADDIU A1, A1, 48
9D005518  0F400DF0   JAL 0x9D0037C0
9D00551C  24060200   ADDIU A2, ZERO, 512
2359:                #else
2360:                				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
2361:                					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf,
2362:                							SS(fp->fs));
2363:                #endif
2364:                #endif
2365:                				rcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2366:                				continue;
9D005520  0B401563   J 0x9D00558C
9D005524  00118A40   SLL S1, S1, 9
2367:                			}
2368:                #if !_FS_TINY
2369:                			if (fp->dsect != sect) { /* Load data sector if not in cache */
2370:                #if !_FS_READONLY
2371:                				if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2372:                					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2373:                							!= RES_OK)
2374:                						ABORT(fp->fs, FR_DISK_ERR);
2375:                					fp->flag &= ~FA__DIRTY;
2376:                				}
2377:                #endif
2378:                				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK) /* Fill sector cache */
2379:                					ABORT(fp->fs, FR_DISK_ERR);
2380:                			}
2381:                #endif
2382:                			fp->dsect = sect;
9D005528  AE1E0018   SW S8, 24(S0)
2383:                		}
2384:                		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs)); /* Get partial sector data from sector buffer */
9D00552C  8E110008   LW S1, 8(S0)
9D00555C  24020200   ADDIU V0, ZERO, 512
9D005560  00518823   SUBU S1, V0, S1
9D005564  0232102B   SLTU V0, S1, S2
9D005568  0242880A   MOVZ S1, S2, V0
2385:                		if (rcnt > btr)
2386:                			rcnt = btr;
2387:                #if _FS_TINY
2388:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D005530  8E040000   LW A0, 0(S0)
9D005534  0F400E6A   JAL 0x9D0039A8
9D005538  8E050018   LW A1, 24(S0)
9D00553C  10400007   BEQ V0, ZERO, 0x9D00555C
9D005540  323101FF   ANDI S1, S1, 511
2389:                		ABORT(fp->fs, FR_DISK_ERR);
9D005544  92030006   LBU V1, 6(S0)
9D005548  2402FF80   ADDIU V0, ZERO, -128
9D00554C  00621025   OR V0, V1, V0
9D005550  A2020006   SB V0, 6(S0)
9D005554  0B40156E   J 0x9D0055B8
9D005558  24170001   ADDIU S7, ZERO, 1
2390:                		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
9D00556C  8E050000   LW A1, 0(S0)
9D005570  24A50030   ADDIU A1, A1, 48
9D005574  8E020008   LW V0, 8(S0)
9D005578  304201FF   ANDI V0, V0, 511
9D00557C  02802021   ADDU A0, S4, ZERO
9D005580  00A22821   ADDU A1, A1, V0
9D005584  0F400DF0   JAL 0x9D0037C0
9D005588  02203021   ADDU A2, S1, ZERO
2391:                #else
2392:                		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
2393:                #endif
2394:                	}
2395:                
2396:                	LEAVE_FF(fp->fs, FR_OK);
2397:                }
9D0055B8  02E01021   ADDU V0, S7, ZERO
9D0055BC  8FBF0034   LW RA, 52(SP)
9D0055C0  8FBE0030   LW S8, 48(SP)
9D0055C4  8FB7002C   LW S7, 44(SP)
9D0055C8  8FB60028   LW S6, 40(SP)
9D0055CC  8FB50024   LW S5, 36(SP)
9D0055D0  8FB40020   LW S4, 32(SP)
9D0055D4  8FB3001C   LW S3, 28(SP)
9D0055D8  8FB20018   LW S2, 24(SP)
9D0055DC  8FB10014   LW S1, 20(SP)
9D0055E0  8FB00010   LW S0, 16(SP)
9D0055E4  03E00008   JR RA
9D0055E8  27BD0038   ADDIU SP, SP, 56
2398:                
2399:                #if !_FS_READONLY
2400:                /*-----------------------------------------------------------------------*/
2401:                /* Write File                                                            */
2402:                /*-----------------------------------------------------------------------*/
2403:                
2404:                FRESULT f_write(FIL *fp, /* Pointer to the file object */
2405:                                const void *buff, /* Pointer to the data to be written */
2406:                                UINT btw, /* Number of bytes to write */
2407:                                UINT *bw /* Pointer to number of bytes written */
2408:                                ) {
9D0055EC  27BDFFC8   ADDIU SP, SP, -56
9D0055F0  AFBF0034   SW RA, 52(SP)
9D0055F4  AFBE0030   SW S8, 48(SP)
9D0055F8  AFB7002C   SW S7, 44(SP)
9D0055FC  AFB60028   SW S6, 40(SP)
9D005600  AFB50024   SW S5, 36(SP)
9D005604  AFB40020   SW S4, 32(SP)
9D005608  AFB3001C   SW S3, 28(SP)
9D00560C  AFB20018   SW S2, 24(SP)
9D005610  AFB10014   SW S1, 20(SP)
9D005614  AFB00010   SW S0, 16(SP)
9D005618  00808021   ADDU S0, A0, ZERO
9D00561C  00A0A021   ADDU S4, A1, ZERO
9D005620  00C08821   ADDU S1, A2, ZERO
9D005624  00E09821   ADDU S3, A3, ZERO
2409:                	FRESULT res;
2410:                	DWORD clst, sect;
2411:                	UINT wcnt, cc;
2412:                	const PF_BYTE *wbuff = buff;
2413:                	PF_BYTE csect;
2414:                
2415:                	*bw = 0; /* Initialize byte counter */
9D005628  ACE00000   SW ZERO, 0(A3)
2416:                
2417:                	res = validate(fp->fs, fp->id); /* Check validity */
9D00562C  8C840000   LW A0, 0(A0)
9D005630  0F400F2B   JAL 0x9D003CAC
9D005634  96050004   LHU A1, 4(S0)
2418:                	if (res != FR_OK)
9D005638  144000BA   BNE V0, ZERO, 0x9D005924
9D00563C  0040B821   ADDU S7, V0, ZERO
2419:                		LEAVE_FF(fp->fs, res);
2420:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D005640  92020006   LBU V0, 6(S0)
9D005644  7C021C20   SEB V1, V0
9D005648  046000B5   BLTZ V1, 0x9D005920
9D00564C  30420002   ANDI V0, V0, 2
2421:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2422:                	if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D005650  504000B4   BEQL V0, ZERO, 0x9D005924
9D005654  24170007   ADDIU S7, ZERO, 7
2423:                		LEAVE_FF(fp->fs, FR_DENIED);
2424:                	if ((DWORD) (fp->fsize + btw) < fp->fsize)
9D005658  8E02000C   LW V0, 12(S0)
9D00565C  02221821   ADDU V1, S1, V0
9D005660  0062102B   SLTU V0, V1, V0
9D005664  544000A6   BNEL V0, ZERO, 0x9D005900
9D005668  8E020008   LW V0, 8(S0)
2425:                		btw = 0; /* File size cannot reach 4GB */
2426:                
2427:                	for (; btw; /* Repeat until all data written */
9D00566C  522000A4   BEQL S1, ZERO, 0x9D005900
9D005670  8E020008   LW V0, 8(S0)
9D0058EC  12200003   BEQ S1, ZERO, 0x9D0058FC
9D0058F0  AE620000   SW V0, 0(S3)
2428:                	wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
9D0058D4  8E020008   LW V0, 8(S0)
9D0058D8  00521021   ADDU V0, V0, S2
9D0058DC  AE020008   SW V0, 8(S0)
9D0058E0  8E620000   LW V0, 0(S3)
9D0058E4  00521021   ADDU V0, V0, S2
9D0058E8  02328823   SUBU S1, S1, S2
9D0058F4  0B40159D   J 0x9D005674
9D0058F8  0292A021   ADDU S4, S4, S2
2429:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D005674  8E050008   LW A1, 8(S0)
9D005678  30A201FF   ANDI V0, A1, 511
9D00567C  5440007B   BNEL V0, ZERO, 0x9D00586C
9D005680  8E120008   LW S2, 8(S0)
2430:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D005684  8E040000   LW A0, 0(S0)
9D005688  00051242   SRL V0, A1, 9
9D00568C  90950002   LBU S5, 2(A0)
9D005690  26B5FFFF   ADDIU S5, S5, -1
9D005694  0055A824   AND S5, V0, S5
9D005698  32B500FF   ANDI S5, S5, 255
2431:                			if (!csect) { /* On the cluster boundary? */
9D00569C  56A00026   BNEL S5, ZERO, 0x9D005738
9D0056A0  8C83002C   LW V1, 44(A0)
2432:                				if (fp->fptr == 0) { /* On the top of the file? */
9D0056A4  54A00008   BNEL A1, ZERO, 0x9D0056C8
9D0056A8  8E020024   LW V0, 36(S0)
2433:                					clst = fp->sclust; /* Follow from the origin */
9D0056AC  8E020010   LW V0, 16(S0)
2434:                					if (clst == 0) /* When no cluster is allocated, */
9D0056B0  1440000F   BNE V0, ZERO, 0x9D0056F0
9D0056B4  24030001   ADDIU V1, ZERO, 1
2435:                						fp->sclust = clst = create_chain(fp->fs, 0); /* Create a new cluster chain */
9D0056B8  0F401089   JAL 0x9D004224
9D0056BC  00000000   NOP
9D0056C0  0B4015BA   J 0x9D0056E8
9D0056C4  AE020010   SW V0, 16(S0)
2436:                				} else { /* Middle or end of the file */
2437:                #if _USE_FASTSEEK
2438:                					if (fp->cltbl)
9D0056C8  10400005   BEQ V0, ZERO, 0x9D0056E0
9D0056CC  00000000   NOP
2439:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D0056D0  0F400E03   JAL 0x9D00380C
9D0056D4  02002021   ADDU A0, S0, ZERO
9D0056D8  0B4015BA   J 0x9D0056E8
9D0056DC  00000000   NOP
2440:                					else
2441:                #endif
2442:                						clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
9D0056E0  0F401089   JAL 0x9D004224
9D0056E4  8E050014   LW A1, 20(S0)
2443:                				}
2444:                				if (clst == 0)
9D0056E8  10400084   BEQ V0, ZERO, 0x9D0058FC
9D0056EC  24030001   ADDIU V1, ZERO, 1
2445:                					break; /* Could not allocate a new cluster (disk full) */
2446:                				if (clst == 1)
9D0056F0  14430007   BNE V0, V1, 0x9D005710
9D0056F4  2403FFFF   ADDIU V1, ZERO, -1
2447:                					ABORT(fp->fs, FR_INT_ERR);
9D0056F8  92030006   LBU V1, 6(S0)
9D0056FC  2402FF80   ADDIU V0, ZERO, -128
9D005700  00621025   OR V0, V1, V0
9D005704  A2020006   SB V0, 6(S0)
9D005708  0B401649   J 0x9D005924
9D00570C  24170002   ADDIU S7, ZERO, 2
2448:                				if (clst == 0xFFFFFFFF)
9D005710  54430007   BNEL V0, V1, 0x9D005730
9D005714  AE020014   SW V0, 20(S0)
2449:                					ABORT(fp->fs, FR_DISK_ERR);
9D005718  92030006   LBU V1, 6(S0)
9D00571C  2402FF80   ADDIU V0, ZERO, -128
9D005720  00621025   OR V0, V1, V0
9D005724  A2020006   SB V0, 6(S0)
9D005728  0B401649   J 0x9D005924
9D00572C  24170001   ADDIU S7, ZERO, 1
2450:                				fp->clust = clst; /* Update current cluster */
2451:                			}
2452:                #if _FS_TINY
2453:                			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0)) /* Write-back sector cache */
9D005730  8E040000   LW A0, 0(S0)
9D005734  8C83002C   LW V1, 44(A0)
9D005738  8E020018   LW V0, 24(S0)
9D00573C  5462000B   BNEL V1, V0, 0x9D00576C
9D005740  8E160000   LW S6, 0(S0)
9D005744  0F400E6A   JAL 0x9D0039A8
9D005748  00002821   ADDU A1, ZERO, ZERO
9D00574C  50400007   BEQL V0, ZERO, 0x9D00576C
9D005750  8E160000   LW S6, 0(S0)
2454:                			ABORT(fp->fs, FR_DISK_ERR);
9D005754  92030006   LBU V1, 6(S0)
9D005758  2402FF80   ADDIU V0, ZERO, -128
9D00575C  00621025   OR V0, V1, V0
9D005760  A2020006   SB V0, 6(S0)
9D005764  0B401649   J 0x9D005924
9D005768  24170001   ADDIU S7, ZERO, 1
2455:                #else
2456:                			if (fp->flag & FA__DIRTY) { /* Write-back sector cache */
2457:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2458:                					ABORT(fp->fs, FR_DISK_ERR);
2459:                				fp->flag &= ~FA__DIRTY;
2460:                			}
2461:                #endif
2462:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D00576C  02C02021   ADDU A0, S6, ZERO
9D005770  0F400F3E   JAL clust2sect
9D005774  8E050014   LW A1, 20(S0)
2463:                			if (!sect)
9D005778  14400007   BNE V0, ZERO, 0x9D005798
9D00577C  00119242   SRL S2, S1, 9
2464:                				ABORT(fp->fs, FR_INT_ERR);
9D005780  92030006   LBU V1, 6(S0)
9D005784  2402FF80   ADDIU V0, ZERO, -128
9D005788  00621025   OR V0, V1, V0
9D00578C  A2020006   SB V0, 6(S0)
9D005790  0B401649   J 0x9D005924
9D005794  24170002   ADDIU S7, ZERO, 2
2465:                			sect += csect;
2466:                			cc = btw / SS(fp->fs); /* When remaining bytes >= sector size, */
2467:                			if (cc) { /* Write maximum contiguous sectors directly */
9D005798  12400021   BEQ S2, ZERO, 0x9D005820
9D00579C  0055F021   ADDU S8, V0, S5
2468:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D0057A0  92C20002   LBU V0, 2(S6)
9D0057A4  02551821   ADDU V1, S2, S5
9D0057A8  0043182B   SLTU V1, V0, V1
2469:                					cc = fp->fs->csize - csect;
9D0057AC  0055A823   SUBU S5, V0, S5
9D0057B0  02A3900B   MOVN S2, S5, V1
2470:                				if (disk_write(fp->fs->drv, wbuff, sect, (PF_BYTE) cc)
9D0057B4  92C40001   LBU A0, 1(S6)
9D0057B8  02802821   ADDU A1, S4, ZERO
9D0057BC  03C03021   ADDU A2, S8, ZERO
9D0057C0  0F4023D7   JAL disk_write
9D0057C4  324700FF   ANDI A3, S2, 255
9D0057C8  50400007   BEQL V0, ZERO, 0x9D0057E8
9D0057CC  8E040000   LW A0, 0(S0)
2471:                						!= RES_OK)
2472:                					ABORT(fp->fs, FR_DISK_ERR);
9D0057D0  92030006   LBU V1, 6(S0)
9D0057D4  2402FF80   ADDIU V0, ZERO, -128
9D0057D8  00621025   OR V0, V1, V0
9D0057DC  A2020006   SB V0, 6(S0)
9D0057E0  0B401649   J 0x9D005924
9D0057E4  24170001   ADDIU S7, ZERO, 1
2473:                #if _FS_TINY
2474:                				if (fp->fs->winsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
9D0057E8  8C82002C   LW V0, 44(A0)
9D0057EC  005EF023   SUBU S8, V0, S8
9D0057F0  03D2102B   SLTU V0, S8, S2
9D0057F4  50400037   BEQL V0, ZERO, 0x9D0058D4
9D0057F8  00129240   SLL S2, S2, 9
2475:                					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
9D0057FC  001EF240   SLL S8, S8, 9
9D005800  24840030   ADDIU A0, A0, 48
9D005804  029E2821   ADDU A1, S4, S8
9D005808  0F400DF0   JAL 0x9D0037C0
9D00580C  24060200   ADDIU A2, ZERO, 512
2476:                					fp->fs->wflag = 0;
9D005810  8E020000   LW V0, 0(S0)
9D005814  A0400004   SB ZERO, 4(V0)
2477:                				}
2478:                #else
2479:                				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
2480:                					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)),
2481:                							SS(fp->fs));
2482:                					fp->flag &= ~FA__DIRTY;
2483:                				}
2484:                #endif
2485:                				wcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2486:                				continue;
9D005818  0B401635   J 0x9D0058D4
9D00581C  00129240   SLL S2, S2, 9
2487:                			}
2488:                #if _FS_TINY
2489:                			if (fp->fptr >= fp->fsize) { /* Avoid silly cache filling at growing edge */
9D005820  8E030008   LW V1, 8(S0)
9D005824  8E02000C   LW V0, 12(S0)
9D005828  0062102B   SLTU V0, V1, V0
9D00582C  5440000E   BNEL V0, ZERO, 0x9D005868
9D005830  AE1E0018   SW S8, 24(S0)
2490:                				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
9D005834  02C02021   ADDU A0, S6, ZERO
9D005838  0F400E6A   JAL 0x9D0039A8
9D00583C  00002821   ADDU A1, ZERO, ZERO
9D005840  50400007   BEQL V0, ZERO, 0x9D005860
9D005844  8E020000   LW V0, 0(S0)
9D005848  92030006   LBU V1, 6(S0)
9D00584C  2402FF80   ADDIU V0, ZERO, -128
9D005850  00621025   OR V0, V1, V0
9D005854  A2020006   SB V0, 6(S0)
9D005858  0B401649   J 0x9D005924
9D00585C  24170001   ADDIU S7, ZERO, 1
2491:                				fp->fs->winsect = sect;
9D005860  AC5E002C   SW S8, 44(V0)
2492:                			}
2493:                #else
2494:                			if (fp->dsect != sect) { /* Fill sector cache with file data */
2495:                				if (fp->fptr < fp->fsize && disk_read(fp->fs->drv, fp->buf,
2496:                						sect, 1) != RES_OK)
2497:                					ABORT(fp->fs, FR_DISK_ERR);
2498:                			}
2499:                #endif
2500:                			fp->dsect = sect;
9D005864  AE1E0018   SW S8, 24(S0)
2501:                		}
2502:                		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
9D005868  8E120008   LW S2, 8(S0)
9D005898  24020200   ADDIU V0, ZERO, 512
9D00589C  00529023   SUBU S2, V0, S2
9D0058A0  0251102B   SLTU V0, S2, S1
9D0058A4  0222900A   MOVZ S2, S1, V0
2503:                		if (wcnt > btw)
2504:                			wcnt = btw;
2505:                #if _FS_TINY
2506:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D00586C  8E040000   LW A0, 0(S0)
9D005870  0F400E6A   JAL 0x9D0039A8
9D005874  8E050018   LW A1, 24(S0)
9D005878  10400007   BEQ V0, ZERO, 0x9D005898
9D00587C  325201FF   ANDI S2, S2, 511
2507:                		ABORT(fp->fs, FR_DISK_ERR);
9D005880  92030006   LBU V1, 6(S0)
9D005884  2402FF80   ADDIU V0, ZERO, -128
9D005888  00621025   OR V0, V1, V0
9D00588C  A2020006   SB V0, 6(S0)
9D005890  0B401649   J 0x9D005924
9D005894  24170001   ADDIU S7, ZERO, 1
2508:                		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
9D0058A8  8E040000   LW A0, 0(S0)
9D0058AC  24840030   ADDIU A0, A0, 48
9D0058B0  8E020008   LW V0, 8(S0)
9D0058B4  304201FF   ANDI V0, V0, 511
9D0058B8  00822021   ADDU A0, A0, V0
9D0058BC  02802821   ADDU A1, S4, ZERO
9D0058C0  0F400DF0   JAL 0x9D0037C0
9D0058C4  02403021   ADDU A2, S2, ZERO
2509:                		fp->fs->wflag = 1;
9D0058C8  8E020000   LW V0, 0(S0)
9D0058CC  24030001   ADDIU V1, ZERO, 1
9D0058D0  A0430004   SB V1, 4(V0)
2510:                #else
2511:                		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
2512:                		fp->flag |= FA__DIRTY;
2513:                #endif
2514:                	}
2515:                
2516:                	if (fp->fptr > fp->fsize)
9D0058FC  8E020008   LW V0, 8(S0)
9D005900  8E03000C   LW V1, 12(S0)
9D005904  0062182B   SLTU V1, V1, V0
9D005908  54600001   BNEL V1, ZERO, 0x9D005910
9D00590C  AE02000C   SW V0, 12(S0)
2517:                		fp->fsize = fp->fptr; /* Update file size if needed */
2518:                	fp->flag |= FA__WRITTEN; /* Set file change flag */
9D005910  92020006   LBU V0, 6(S0)
9D005914  34420020   ORI V0, V0, 32
2519:                
2520:                	LEAVE_FF(fp->fs, FR_OK);
9D005918  0B401649   J 0x9D005924
9D00591C  A2020006   SB V0, 6(S0)
9D005920  24170002   ADDIU S7, ZERO, 2
2521:                }
9D005924  02E01021   ADDU V0, S7, ZERO
9D005928  8FBF0034   LW RA, 52(SP)
9D00592C  8FBE0030   LW S8, 48(SP)
9D005930  8FB7002C   LW S7, 44(SP)
9D005934  8FB60028   LW S6, 40(SP)
9D005938  8FB50024   LW S5, 36(SP)
9D00593C  8FB40020   LW S4, 32(SP)
9D005940  8FB3001C   LW S3, 28(SP)
9D005944  8FB20018   LW S2, 24(SP)
9D005948  8FB10014   LW S1, 20(SP)
9D00594C  8FB00010   LW S0, 16(SP)
9D005950  03E00008   JR RA
9D005954  27BD0038   ADDIU SP, SP, 56
2522:                
2523:                /*-----------------------------------------------------------------------*/
2524:                /* Synchronize the File Object                                           */
2525:                /*-----------------------------------------------------------------------*/
2526:                
2527:                FRESULT f_sync(FIL *fp /* Pointer to the file object */
2528:                ) {
9D005958  27BDFFE0   ADDIU SP, SP, -32
9D00595C  AFBF001C   SW RA, 28(SP)
9D005960  AFB10018   SW S1, 24(SP)
9D005964  AFB00014   SW S0, 20(SP)
9D005968  00808021   ADDU S0, A0, ZERO
2529:                	FRESULT res;
2530:                	DWORD tim;
2531:                	PF_BYTE *dir;
2532:                
2533:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D00596C  8C840000   LW A0, 0(A0)
9D005970  0F400F2B   JAL 0x9D003CAC
9D005974  96050004   LHU A1, 4(S0)
2534:                	if (res == FR_OK) {
9D005978  14400032   BNE V0, ZERO, 0x9D005A44
9D00597C  8FBF001C   LW RA, 28(SP)
2535:                		if (fp->flag & FA__WRITTEN) { /* Has the file been written? */
9D005980  92030006   LBU V1, 6(S0)
9D005984  30630020   ANDI V1, V1, 32
9D005988  1060002F   BEQ V1, ZERO, 0x9D005A48
9D00598C  8FB10018   LW S1, 24(SP)
2536:                #if !_FS_TINY	/* Write-back dirty buffer */
2537:                			if (fp->flag & FA__DIRTY) {
2538:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2539:                					LEAVE_FF(fp->fs, FR_DISK_ERR);
2540:                				fp->flag &= ~FA__DIRTY;
2541:                			}
2542:                #endif
2543:                			/* Update the directory entry */
2544:                			res = move_window(fp->fs, fp->dir_sect);
9D005990  8E040000   LW A0, 0(S0)
9D005994  0F400E6A   JAL 0x9D0039A8
9D005998  8E05001C   LW A1, 28(S0)
2545:                			if (res == FR_OK) {
9D00599C  14400029   BNE V0, ZERO, 0x9D005A44
9D0059A0  8FBF001C   LW RA, 28(SP)
2546:                				dir = fp->dir_ptr;
9D0059A4  8E110020   LW S1, 32(S0)
2547:                				dir[DIR_Attr] |= AM_ARC; /* Set archive bit */
9D0059A8  9222000B   LBU V0, 11(S1)
9D0059AC  34420020   ORI V0, V0, 32
9D0059B0  A222000B   SB V0, 11(S1)
2548:                				ST_DWORD(dir+DIR_FileSize, fp->fsize); /* Update file size */
9D0059B4  8E02000C   LW V0, 12(S0)
9D0059B8  A222001C   SB V0, 28(S1)
9D0059BC  9602000C   LHU V0, 12(S0)
9D0059C0  00021202   SRL V0, V0, 8
9D0059C4  A222001D   SB V0, 29(S1)
9D0059C8  9602000E   LHU V0, 14(S0)
9D0059CC  A222001E   SB V0, 30(S1)
9D0059D0  9202000F   LBU V0, 15(S0)
9D0059D4  A222001F   SB V0, 31(S1)
2549:                				ST_CLUST(dir, fp->sclust); /* Update start cluster */
9D0059D8  8E020010   LW V0, 16(S0)
9D0059DC  A222001A   SB V0, 26(S1)
9D0059E0  96020010   LHU V0, 16(S0)
9D0059E4  00021202   SRL V0, V0, 8
9D0059E8  A222001B   SB V0, 27(S1)
9D0059EC  96020012   LHU V0, 18(S0)
9D0059F0  A2220014   SB V0, 20(S1)
9D0059F4  96020012   LHU V0, 18(S0)
9D0059F8  00021202   SRL V0, V0, 8
2550:                				tim = get_fattime(); /* Update updated time */
9D0059FC  0F4024FC   JAL get_fattime
9D005A00  A2220015   SB V0, 21(S1)
2551:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D005A04  A2220016   SB V0, 22(S1)
9D005A08  7C433A00   EXT V1, V0, 8, 8
9D005A0C  A2230017   SB V1, 23(S1)
9D005A10  00021C02   SRL V1, V0, 16
9D005A14  A2230018   SB V1, 24(S1)
9D005A18  00021602   SRL V0, V0, 24
9D005A1C  A2220019   SB V0, 25(S1)
2552:                				fp->flag &= ~FA__WRITTEN;
9D005A20  92020006   LBU V0, 6(S0)
9D005A24  304200DF   ANDI V0, V0, 223
9D005A28  A2020006   SB V0, 6(S0)
2553:                				fp->fs->wflag = 1;
9D005A2C  8E020000   LW V0, 0(S0)
9D005A30  24030001   ADDIU V1, ZERO, 1
9D005A34  A0430004   SB V1, 4(V0)
2554:                				res = sync(fp->fs);
9D005A38  0F400EE1   JAL 0x9D003B84
9D005A3C  8E040000   LW A0, 0(S0)
2555:                			}
2556:                		}
2557:                	}
2558:                
2559:                	LEAVE_FF(fp->fs, res);
2560:                }
9D005A40  8FBF001C   LW RA, 28(SP)
9D005A44  8FB10018   LW S1, 24(SP)
9D005A48  8FB00014   LW S0, 20(SP)
9D005A4C  03E00008   JR RA
9D005A50  27BD0020   ADDIU SP, SP, 32
2561:                
2562:                #endif /* !_FS_READONLY */
2563:                
2564:                /*-----------------------------------------------------------------------*/
2565:                /* Close File                                                            */
2566:                /*-----------------------------------------------------------------------*/
2567:                
2568:                FRESULT f_close(FIL *fp /* Pointer to the file object to be closed */
2569:                ) {
9D005A54  27BDFFE8   ADDIU SP, SP, -24
9D005A58  AFBF0014   SW RA, 20(SP)
9D005A5C  AFB00010   SW S0, 16(SP)
2570:                	FRESULT res;
2571:                
2572:                #if _FS_READONLY
2573:                	FATFS *fs = fp->fs;
2574:                	res = validate(fs, fp->id);
2575:                	if (res == FR_OK) fp->fs = 0; /* Discard file object */
2576:                	LEAVE_FF(fs, res);
2577:                
2578:                #else
2579:                	res = f_sync(fp); /* Flush cached data */
9D005A60  0F401656   JAL f_sync
9D005A64  00808021   ADDU S0, A0, ZERO
2580:                #if _FS_SHARE
2581:                	if (res == FR_OK) { /* Decrement open counter */
2582:                #if _FS_REENTRANT
2583:                		res = validate(fp->fs, fp->id);
2584:                		if (res == FR_OK) {
2585:                			res = dec_lock(fp->lockid);
2586:                			unlock_fs(fp->fs, FR_OK);
2587:                		}
2588:                #else
2589:                		res = dec_lock(fp->lockid);
2590:                #endif
2591:                	}
2592:                #endif
2593:                	if (res == FR_OK)
9D005A68  50400001   BEQL V0, ZERO, 0x9D005A70
9D005A6C  AE000000   SW ZERO, 0(S0)
2594:                		fp->fs = 0; /* Discard file object */
2595:                	return res;
2596:                #endif
2597:                }
9D005A70  8FBF0014   LW RA, 20(SP)
9D005A74  8FB00010   LW S0, 16(SP)
9D005A78  03E00008   JR RA
9D005A7C  27BD0018   ADDIU SP, SP, 24
2598:                
2599:                /*-----------------------------------------------------------------------*/
2600:                /* Current Drive/Directory Handlings                                     */
2601:                /*-----------------------------------------------------------------------*/
2602:                
2603:                #if _FS_RPATH >= 1
2604:                
2605:                FRESULT f_chdrive (
2606:                		PF_BYTE drv /* Drive number */
2607:                )
2608:                {
2609:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
2610:                
2611:                	CurrVol = drv;
2612:                
2613:                	return FR_OK;
2614:                }
2615:                
2616:                FRESULT f_chdir (
2617:                		const TCHAR *path /* Pointer to the directory path */
2618:                )
2619:                {
2620:                	FRESULT res;
2621:                	DIR dj;
2622:                	DEF_NAMEBUF;
2623:                
2624:                	res = chk_mounted(&path, &dj.fs, 0);
2625:                	if (res == FR_OK) {
2626:                		INIT_BUF(dj);
2627:                		res = follow_path(&dj, path); /* Follow the path */
2628:                		FREE_BUF();
2629:                		if (res == FR_OK) { /* Follow completed */
2630:                			if (!dj.dir) {
2631:                				dj.fs->cdir = dj.sclust; /* Start directory itself */
2632:                			} else {
2633:                				if (dj.dir[DIR_Attr] & AM_DIR) /* Reached to the directory */
2634:                				dj.fs->cdir = LD_CLUST(dj.dir);
2635:                				else
2636:                				res = FR_NO_PATH; /* Reached but a file */
2637:                			}
2638:                		}
2639:                		if (res == FR_NO_FILE) res = FR_NO_PATH;
2640:                	}
2641:                
2642:                	LEAVE_FF(dj.fs, res);
2643:                }
2644:                
2645:                #if _FS_RPATH >= 2
2646:                FRESULT f_getcwd (
2647:                		TCHAR *path, /* Pointer to the directory path */
2648:                		UINT sz_path /* Size of path */
2649:                )
2650:                {
2651:                	FRESULT res;
2652:                	DIR dj;
2653:                	UINT i, n;
2654:                	DWORD ccl;
2655:                	TCHAR *tp;
2656:                	FILINFO fno;
2657:                	DEF_NAMEBUF;
2658:                
2659:                	*path = 0;
2660:                	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0); /* Get current volume */
2661:                	if (res == FR_OK) {
2662:                		INIT_BUF(dj);
2663:                		i = sz_path; /* Bottom of buffer (dir stack base) */
2664:                		dj.sclust = dj.fs->cdir; /* Start to follow upper dir from current dir */
2665:                		while ((ccl = dj.sclust) != 0) { /* Repeat while current dir is a sub-dir */
2666:                			res = dir_sdi(&dj, 1); /* Get parent dir */
2667:                			if (res != FR_OK) break;
2668:                			res = dir_read(&dj);
2669:                			if (res != FR_OK) break;
2670:                			dj.sclust = LD_CLUST(dj.dir); /* Goto parent dir */
2671:                			res = dir_sdi(&dj, 0);
2672:                			if (res != FR_OK) break;
2673:                			do { /* Find the entry links to the child dir */
2674:                				res = dir_read(&dj);
2675:                				if (res != FR_OK) break;
2676:                				if (ccl == LD_CLUST(dj.dir)) break; /* Found the entry */
2677:                				res = dir_next(&dj, 0);
2678:                			}while (res == FR_OK);
2679:                			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
2680:                			if (res != FR_OK) break;
2681:                #if _USE_LFN
2682:                			fno.lfname = path;
2683:                			fno.lfsize = i;
2684:                #endif
2685:                			get_fileinfo(&dj, &fno); /* Get the dir name and push it to the buffer */
2686:                			tp = fno.fname;
2687:                			if (_USE_LFN && *path) tp = path;
2688:                			for (n = 0; tp[n]; n++);
2689:                			if (i < n + 3) {
2690:                				res = FR_NOT_ENOUGH_CORE; break;
2691:                			}
2692:                			while (n) path[--i] = tp[--n];
2693:                			path[--i] = '/';
2694:                		}
2695:                		tp = path;
2696:                		if (res == FR_OK) {
2697:                			*tp++ = '0' + CurrVol; /* Put drive number */
2698:                			*tp++ = ':';
2699:                			if (i == sz_path) { /* Root-dir */
2700:                				*tp++ = '/';
2701:                			} else { /* Sub-dir */
2702:                				do /* Add stacked path str */
2703:                				*tp++ = path[i++];
2704:                				while (i < sz_path);
2705:                			}
2706:                		}
2707:                		*tp = 0;
2708:                		FREE_BUF();
2709:                	}
2710:                
2711:                	LEAVE_FF(dj.fs, res);
2712:                }
2713:                #endif /* _FS_RPATH >= 2 */
2714:                #endif /* _FS_RPATH >= 1 */
2715:                
2716:                #if _FS_MINIMIZE <= 2
2717:                /*-----------------------------------------------------------------------*/
2718:                /* Seek File R/W Pointer                                                 */
2719:                /*-----------------------------------------------------------------------*/
2720:                
2721:                FRESULT f_lseek(FIL *fp, /* Pointer to the file object */
9D005D1C  02539023   SUBU S2, S2, S3
9D005D20  2414FFFF   ADDIU S4, ZERO, -1
2722:                                DWORD ofs /* File pointer from top of file */
2723:                                ) {
9D005A80  27BDFFC8   ADDIU SP, SP, -56
9D005A84  AFBF0034   SW RA, 52(SP)
9D005A88  AFBE0030   SW S8, 48(SP)
9D005A8C  AFB7002C   SW S7, 44(SP)
9D005A90  AFB60028   SW S6, 40(SP)
9D005A94  AFB50024   SW S5, 36(SP)
9D005A98  AFB40020   SW S4, 32(SP)
9D005A9C  AFB3001C   SW S3, 28(SP)
9D005AA0  AFB20018   SW S2, 24(SP)
9D005AA4  AFB10014   SW S1, 20(SP)
9D005AA8  AFB00010   SW S0, 16(SP)
9D005AAC  00808021   ADDU S0, A0, ZERO
9D005AB0  00A09021   ADDU S2, A1, ZERO
2724:                	FRESULT res;
2725:                
2726:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D005AB4  8C840000   LW A0, 0(A0)
9D005AB8  0F400F2B   JAL 0x9D003CAC
9D005ABC  96050004   LHU A1, 4(S0)
2727:                	if (res != FR_OK)
9D005AC0  144000E5   BNE V0, ZERO, 0x9D005E58
9D005AC4  00408821   ADDU S1, V0, ZERO
2728:                		LEAVE_FF(fp->fs, res);
2729:                	if (fp->flag & FA__ERROR) /* Check abort flag */
9D005AC8  92130006   LBU S3, 6(S0)
9D005ACC  7C131420   SEB V0, S3
9D005AD0  044200E1   BLTZL V0, 0x9D005E58
9D005AD4  24110002   ADDIU S1, ZERO, 2
2730:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2731:                
2732:                #if _USE_FASTSEEK
2733:                	if (fp->cltbl) { /* Fast seek */
9D005AD8  8E170024   LW S7, 36(S0)
9D005ADC  12E00055   BEQ S7, ZERO, 0x9D005C34
9D005AE0  2402FFFF   ADDIU V0, ZERO, -1
2734:                		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
2735:                
2736:                		if (ofs == CREATE_LINKMAP) { /* Create CLMT */
9D005AE4  56420034   BNEL S2, V0, 0x9D005BB8
9D005AE8  8E02000C   LW V0, 12(S0)
2737:                			tbl = fp->cltbl;
2738:                			tlen = *tbl++;
9D005AEC  8EFE0000   LW S8, 0(S7)
9D005AF0  26F70004   ADDIU S7, S7, 4
2739:                			ulen = 2; /* Given table size and required table size */
9D005AF8  24150002   ADDIU S5, ZERO, 2
2740:                			cl = fp->sclust; /* Top of the chain */
9D005AF4  8E160010   LW S6, 16(S0)
2741:                			if (cl) {
9D005AFC  16C00003   BNE S6, ZERO, 0x9D005B0C
9D005B00  2414FFFF   ADDIU S4, ZERO, -1
2742:                				do {
2743:                					/* Get a fragment */
2744:                					tcl = cl;
2745:                					ncl = 0;
9D005B10  00009821   ADDU S3, ZERO, ZERO
2746:                					ulen += 2; /* Top, length and used items */
9D005B6C  26B50002   ADDIU S5, S5, 2
2747:                					do {
2748:                						pcl = cl;
2749:                						ncl++;
2750:                						cl = get_fat(fp->fs, cl);
9D005B0C  02C09021   ADDU S2, S6, ZERO
9D005B14  8E040000   LW A0, 0(S0)
9D005B18  0F400F4A   JAL get_fat
9D005B1C  02402821   ADDU A1, S2, ZERO
2751:                						if (cl <= 1)
9D005B20  2C430002   SLTIU V1, V0, 2
9D005B24  10600007   BEQ V1, ZERO, 0x9D005B44
9D005B28  00000000   NOP
2752:                							ABORT(fp->fs, FR_INT_ERR);
9D005B2C  92030006   LBU V1, 6(S0)
9D005B30  2402FF80   ADDIU V0, ZERO, -128
9D005B34  00621025   OR V0, V1, V0
9D005B38  A2020006   SB V0, 6(S0)
9D005B3C  0B401796   J 0x9D005E58
9D005B40  24110002   ADDIU S1, ZERO, 2
2753:                						if (cl == 0xFFFFFFFF)
9D005B44  14540007   BNE V0, S4, 0x9D005B64
9D005B48  26520001   ADDIU S2, S2, 1
2754:                							ABORT(fp->fs, FR_DISK_ERR);
9D005B4C  92030006   LBU V1, 6(S0)
9D005B50  2402FF80   ADDIU V0, ZERO, -128
9D005B54  00621025   OR V0, V1, V0
9D005B58  A2020006   SB V0, 6(S0)
9D005B5C  0B401796   J 0x9D005E58
9D005B60  24110001   ADDIU S1, ZERO, 1
2755:                					} while (cl == pcl + 1);
9D005B64  1242FFEB   BEQ S2, V0, 0x9D005B14
9D005B68  26730001   ADDIU S3, S3, 1
2756:                					if (ulen <= tlen) { /* Store the length and top of the fragment */
9D005B70  03D5182B   SLTU V1, S8, S5
9D005B74  54600005   BNEL V1, ZERO, 0x9D005B8C
9D005B78  8E030000   LW V1, 0(S0)
2757:                						*tbl++ = ncl;
9D005B7C  AEF30000   SW S3, 0(S7)
2758:                						*tbl++ = tcl;
9D005B80  AEF60004   SW S6, 4(S7)
9D005B84  26F70008   ADDIU S7, S7, 8
2759:                					}
2760:                				} while (cl < fp->fs->n_fatent); /* Repeat until end of chain */
9D005B88  8E030000   LW V1, 0(S0)
9D005B8C  8C630018   LW V1, 24(V1)
9D005B90  0043182B   SLTU V1, V0, V1
9D005B94  1460FFDD   BNE V1, ZERO, 0x9D005B0C
9D005B98  0040B021   ADDU S6, V0, ZERO
2761:                			}
2762:                			*fp->cltbl = ulen; /* Number of items used */
9D005B04  0B4016E8   J 0x9D005BA0
9D005B08  8E020024   LW V0, 36(S0)
9D005B9C  8E020024   LW V0, 36(S0)
9D005BA0  AC550000   SW S5, 0(V0)
2763:                			if (ulen <= tlen)
9D005BA4  03D5A82B   SLTU S5, S8, S5
9D005BA8  56A000AB   BNEL S5, ZERO, 0x9D005E58
9D005BAC  24110011   ADDIU S1, ZERO, 17
2764:                				*tbl = 0; /* Terminate table */
9D005BB0  0B401796   J 0x9D005E58
9D005BB4  AEE00000   SW ZERO, 0(S7)
9D005BB8  0052182B   SLTU V1, V0, S2
9D005BBC  0043900B   MOVN S2, V0, V1
2765:                			else
2766:                				res = FR_NOT_ENOUGH_CORE; /* Given table size is smaller than required */
2767:                
2768:                		} else { /* Fast seek */
2769:                			if (ofs > fp->fsize) /* Clip offset at the file size */
2770:                				ofs = fp->fsize;
2771:                			fp->fptr = ofs; /* Set file pointer */
2772:                			if (ofs) {
9D005BC0  124000A5   BEQ S2, ZERO, 0x9D005E58
9D005BC4  AE120008   SW S2, 8(S0)
2773:                				fp->clust = clmt_clust(fp, ofs - 1);
9D005BC8  2655FFFF   ADDIU S5, S2, -1
9D005BCC  02002021   ADDU A0, S0, ZERO
9D005BD0  0F400E03   JAL 0x9D00380C
9D005BD4  02A02821   ADDU A1, S5, ZERO
9D005BD8  AE020014   SW V0, 20(S0)
2774:                				dsc = clust2sect(fp->fs, fp->clust);
9D005BDC  8E140000   LW S4, 0(S0)
9D005BE0  02802021   ADDU A0, S4, ZERO
9D005BE4  0F400F3E   JAL clust2sect
9D005BE8  00402821   ADDU A1, V0, ZERO
2775:                				if (!dsc)
9D005BEC  14400006   BNE V0, ZERO, 0x9D005C08
9D005BF0  325201FF   ANDI S2, S2, 511
2776:                					ABORT(fp->fs, FR_INT_ERR);
9D005BF4  2402FF80   ADDIU V0, ZERO, -128
9D005BF8  02629825   OR S3, S3, V0
9D005BFC  A2130006   SB S3, 6(S0)
9D005C00  0B401796   J 0x9D005E58
9D005C04  24110002   ADDIU S1, ZERO, 2
2777:                				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
9D005C10  0015AA42   SRL S5, S5, 9
9D005C14  2463FFFF   ADDIU V1, V1, -1
9D005C18  02A31824   AND V1, S5, V1
9D005C1C  00431021   ADDU V0, V0, V1
2778:                				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) { /* Refill sector cache if needed */
9D005C08  12400093   BEQ S2, ZERO, 0x9D005E58
9D005C0C  92830002   LBU V1, 2(S4)
9D005C20  8E030018   LW V1, 24(S0)
9D005C24  5462008C   BNEL V1, V0, 0x9D005E58
9D005C28  AE020018   SW V0, 24(S0)
2779:                #if !_FS_TINY
2780:                #if !_FS_READONLY
2781:                					if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2782:                						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2783:                								!= RES_OK)
2784:                							ABORT(fp->fs, FR_DISK_ERR);
2785:                						fp->flag &= ~FA__DIRTY;
2786:                					}
2787:                #endif
2788:                					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK) /* Load current sector */
2789:                						ABORT(fp->fs, FR_DISK_ERR);
2790:                #endif
2791:                					fp->dsect = dsc;
2792:                				}
2793:                			}
2794:                		}
2795:                	} else
2796:                #endif
2797:                
2798:                	/* Normal Seek */
2799:                	{
2800:                		DWORD clst, bcs, nsect, ifptr;
2801:                
2802:                		if (ofs > fp->fsize /* In read-only mode, clip offset with the file size */
9D005C34  8E02000C   LW V0, 12(S0)
9D005C38  0052182B   SLTU V1, V0, S2
9D005C3C  50600004   BEQL V1, ZERO, 0x9D005C50
9D005C40  8E020008   LW V0, 8(S0)
2803:                #if !_FS_READONLY
2804:                				&& !(fp->flag & FA_WRITE)
9D005C44  32730002   ANDI S3, S3, 2
2805:                #endif
2806:                		)
2807:                			ofs = fp->fsize;
9D005C48  0053900A   MOVZ S2, V0, S3
2808:                
2809:                		ifptr = fp->fptr;
9D005C4C  8E020008   LW V0, 8(S0)
2810:                		fp->fptr = nsect = 0;
2811:                		if (ofs) {
9D005C50  12400081   BEQ S2, ZERO, 0x9D005E58
9D005C54  AE000008   SW ZERO, 8(S0)
2812:                			bcs = (DWORD) fp->fs->csize * SS(fp->fs); /* Cluster size (byte) */
9D005C58  8E040000   LW A0, 0(S0)
9D005C5C  90930002   LBU S3, 2(A0)
2813:                			if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
9D005C60  10400012   BEQ V0, ZERO, 0x9D005CAC
9D005C64  00139A40   SLL S3, S3, 9
9D005C68  2442FFFF   ADDIU V0, V0, -1
9D005C6C  2643FFFF   ADDIU V1, S2, -1
9D005C70  0073001B   DIVU V1, S3
9D005C74  026001F4   TEQ S3, ZERO
9D005C78  00001812   MFLO V1, 0
9D005C7C  0053001B   DIVU V0, S3
9D005C80  026001F4   TEQ S3, ZERO
9D005C84  00002812   MFLO A1, 0
9D005C88  0065182B   SLTU V1, V1, A1
9D005C8C  54600008   BNEL V1, ZERO, 0x9D005CB0
9D005C90  8E020010   LW V0, 16(S0)
2814:                				fp->fptr = (ifptr - 1) & ~(bcs - 1); /* start from the current cluster */
9D005C94  00131823   SUBU V1, ZERO, S3
9D005C98  00621024   AND V0, V1, V0
9D005C9C  AE020008   SW V0, 8(S0)
2815:                				ofs -= fp->fptr;
9D005CA0  02429023   SUBU S2, S2, V0
2816:                				clst = fp->clust;
9D005CA4  0B401742   J 0x9D005D08
9D005CA8  8E020014   LW V0, 20(S0)
2817:                			} else { /* When seek to back cluster, */
2818:                				clst = fp->sclust; /* start from the first cluster */
9D005CAC  8E020010   LW V0, 16(S0)
2819:                #if !_FS_READONLY
2820:                				if (clst == 0) { /* If no cluster chain, create a new chain */
9D005CB0  54400015   BNEL V0, ZERO, 0x9D005D08
9D005CB4  AE020014   SW V0, 20(S0)
2821:                					clst = create_chain(fp->fs, 0);
9D005CB8  0F401089   JAL 0x9D004224
9D005CBC  00002821   ADDU A1, ZERO, ZERO
2822:                					if (clst == 1)
9D005CC0  24030001   ADDIU V1, ZERO, 1
9D005CC4  14430007   BNE V0, V1, 0x9D005CE4
9D005CC8  2403FFFF   ADDIU V1, ZERO, -1
2823:                						ABORT(fp->fs, FR_INT_ERR);
9D005CCC  92030006   LBU V1, 6(S0)
9D005CD0  2402FF80   ADDIU V0, ZERO, -128
9D005CD4  00621025   OR V0, V1, V0
9D005CD8  A2020006   SB V0, 6(S0)
9D005CDC  0B401796   J 0x9D005E58
9D005CE0  24110002   ADDIU S1, ZERO, 2
2824:                					if (clst == 0xFFFFFFFF)
9D005CE4  54430007   BNEL V0, V1, 0x9D005D04
9D005CE8  AE020010   SW V0, 16(S0)
2825:                						ABORT(fp->fs, FR_DISK_ERR);
9D005CEC  92030006   LBU V1, 6(S0)
9D005CF0  2402FF80   ADDIU V0, ZERO, -128
9D005CF4  00621025   OR V0, V1, V0
9D005CF8  A2020006   SB V0, 6(S0)
9D005CFC  0B401796   J 0x9D005E58
9D005D00  24110001   ADDIU S1, ZERO, 1
2826:                					fp->sclust = clst;
2827:                				}
2828:                #endif
2829:                				fp->clust = clst;
9D005D04  AE020014   SW V0, 20(S0)
2830:                			}
2831:                			if (clst != 0) {
9D005D08  10400043   BEQ V0, ZERO, 0x9D005E18
9D005D0C  00001821   ADDU V1, ZERO, ZERO
2832:                				while (ofs > bcs) { /* Cluster following loop */
9D005D10  0272182B   SLTU V1, S3, S2
9D005D14  1060002E   BEQ V1, ZERO, 0x9D005DD0
9D005D18  0013A823   SUBU S5, ZERO, S3
9D005DB8  00732021   ADDU A0, V1, S3
9D005DBC  0264202B   SLTU A0, S3, A0
9D005DC0  5480FFD8   BNEL A0, ZERO, 0x9D005D24
9D005DC4  00609021   ADDU S2, V1, ZERO
2833:                #if !_FS_READONLY
2834:                					if (fp->flag & FA_WRITE) { /* Check if in write mode or not */
9D005D24  92030006   LBU V1, 6(S0)
9D005D28  30630002   ANDI V1, V1, 2
9D005D2C  10600007   BEQ V1, ZERO, 0x9D005D4C
9D005D30  8E040000   LW A0, 0(S0)
2835:                						clst = create_chain(fp->fs, clst); /* Force stretch if in write mode */
9D005D34  0F401089   JAL 0x9D004224
9D005D38  00402821   ADDU A1, V0, ZERO
2836:                						if (clst == 0) { /* When disk gets full, clip file size */
9D005D3C  14400005   BNE V0, ZERO, 0x9D005D54
9D005D40  00000000   NOP
2837:                							ofs = bcs;
9D005D44  0B401774   J 0x9D005DD0
9D005D48  02609021   ADDU S2, S3, ZERO
2838:                							break;
2839:                						}
2840:                					} else
2841:                #endif
2842:                						clst = get_fat(fp->fs, clst); /* Follow cluster chain if not in write mode */
9D005D4C  0F400F4A   JAL get_fat
9D005D50  00402821   ADDU A1, V0, ZERO
2843:                					if (clst == 0xFFFFFFFF)
9D005D54  14540007   BNE V0, S4, 0x9D005D74
9D005D58  2C430002   SLTIU V1, V0, 2
2844:                						ABORT(fp->fs, FR_DISK_ERR);
9D005D5C  92030006   LBU V1, 6(S0)
9D005D60  2402FF80   ADDIU V0, ZERO, -128
9D005D64  00621025   OR V0, V1, V0
9D005D68  A2020006   SB V0, 6(S0)
9D005D6C  0B401796   J 0x9D005E58
9D005D70  24110001   ADDIU S1, ZERO, 1
2845:                					if (clst <= 1 || clst >= fp->fs->n_fatent)
9D005D74  54600007   BNEL V1, ZERO, 0x9D005D94
9D005D78  92030006   LBU V1, 6(S0)
9D005D7C  8E030000   LW V1, 0(S0)
9D005D80  8C630018   LW V1, 24(V1)
9D005D84  0043182B   SLTU V1, V0, V1
9D005D88  54600007   BNEL V1, ZERO, 0x9D005DA8
9D005D8C  AE020014   SW V0, 20(S0)
2846:                						ABORT(fp->fs, FR_INT_ERR);
9D005D90  92030006   LBU V1, 6(S0)
9D005D94  2402FF80   ADDIU V0, ZERO, -128
9D005D98  00621025   OR V0, V1, V0
9D005D9C  A2020006   SB V0, 6(S0)
9D005DA0  0B401796   J 0x9D005E58
9D005DA4  24110002   ADDIU S1, ZERO, 2
2847:                					fp->clust = clst;
2848:                					fp->fptr += bcs;
9D005DA8  8E030008   LW V1, 8(S0)
9D005DAC  00731821   ADDU V1, V1, S3
9D005DB0  AE030008   SW V1, 8(S0)
9D005DB4  02551821   ADDU V1, S2, S5
2849:                					ofs -= bcs;
2850:                				}
2851:                				fp->fptr += ofs;
9D005DC8  0B401775   J 0x9D005DD4
9D005DCC  8E030008   LW V1, 8(S0)
9D005DD0  8E030008   LW V1, 8(S0)
9D005DD4  00721821   ADDU V1, V1, S2
9D005DD8  AE030008   SW V1, 8(S0)
2852:                				if (ofs % SS(fp->fs)) {
9D005DDC  324401FF   ANDI A0, S2, 511
9D005DE0  1080000D   BEQ A0, ZERO, 0x9D005E18
9D005DE4  00001821   ADDU V1, ZERO, ZERO
2853:                					nsect = clust2sect(fp->fs, clst); /* Current sector */
9D005DE8  8E040000   LW A0, 0(S0)
9D005DEC  0F400F3E   JAL clust2sect
9D005DF0  00402821   ADDU A1, V0, ZERO
2854:                					if (!nsect)
9D005DF4  14400007   BNE V0, ZERO, 0x9D005E14
9D005DF8  00121A42   SRL V1, S2, 9
2855:                						ABORT(fp->fs, FR_INT_ERR);
9D005DFC  92030006   LBU V1, 6(S0)
9D005E00  2402FF80   ADDIU V0, ZERO, -128
9D005E04  00621025   OR V0, V1, V0
9D005E08  A2020006   SB V0, 6(S0)
9D005E0C  0B401796   J 0x9D005E58
9D005E10  24110002   ADDIU S1, ZERO, 2
2856:                					nsect += ofs / SS(fp->fs);
9D005E14  00431821   ADDU V1, V0, V1
2857:                				}
2858:                			}
2859:                		}
2860:                		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) { /* Fill sector cache if needed */
9D005E18  8E020008   LW V0, 8(S0)
9D005E1C  304201FF   ANDI V0, V0, 511
9D005E20  50400005   BEQL V0, ZERO, 0x9D005E38
9D005E24  8E020008   LW V0, 8(S0)
9D005E28  8E020018   LW V0, 24(S0)
9D005E2C  54430001   BNEL V0, V1, 0x9D005E34
9D005E30  AE030018   SW V1, 24(S0)
2861:                #if !_FS_TINY
2862:                #if !_FS_READONLY
2863:                			if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2864:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2865:                					ABORT(fp->fs, FR_DISK_ERR);
2866:                				fp->flag &= ~FA__DIRTY;
2867:                			}
2868:                #endif
2869:                			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK) /* Fill sector cache */
2870:                				ABORT(fp->fs, FR_DISK_ERR);
2871:                #endif
2872:                			fp->dsect = nsect;
2873:                		}
2874:                #if !_FS_READONLY
2875:                		if (fp->fptr > fp->fsize) { /* Set file change flag if the file size is extended */
9D005E34  8E020008   LW V0, 8(S0)
9D005E38  8E03000C   LW V1, 12(S0)
9D005E3C  0062182B   SLTU V1, V1, V0
9D005E40  50600006   BEQL V1, ZERO, 0x9D005E5C
9D005E44  02201021   ADDU V0, S1, ZERO
2876:                			fp->fsize = fp->fptr;
9D005E48  AE02000C   SW V0, 12(S0)
2877:                			fp->flag |= FA__WRITTEN;
9D005E4C  92020006   LBU V0, 6(S0)
9D005E50  34420020   ORI V0, V0, 32
9D005E54  A2020006   SB V0, 6(S0)
2878:                		}
2879:                #endif
2880:                	}
2881:                
2882:                	LEAVE_FF(fp->fs, res);
2883:                }
9D005C2C  0B401797   J 0x9D005E5C
9D005C30  02201021   ADDU V0, S1, ZERO
9D005E58  02201021   ADDU V0, S1, ZERO
9D005E5C  8FBF0034   LW RA, 52(SP)
9D005E60  8FBE0030   LW S8, 48(SP)
9D005E64  8FB7002C   LW S7, 44(SP)
9D005E68  8FB60028   LW S6, 40(SP)
9D005E6C  8FB50024   LW S5, 36(SP)
9D005E70  8FB40020   LW S4, 32(SP)
9D005E74  8FB3001C   LW S3, 28(SP)
9D005E78  8FB20018   LW S2, 24(SP)
9D005E7C  8FB10014   LW S1, 20(SP)
9D005E80  8FB00010   LW S0, 16(SP)
9D005E84  03E00008   JR RA
9D005E88  27BD0038   ADDIU SP, SP, 56
2884:                
2885:                #if _FS_MINIMIZE <= 1
2886:                /*-----------------------------------------------------------------------*/
2887:                /* Create a Directroy Object                                             */
2888:                /*-----------------------------------------------------------------------*/
2889:                
2890:                FRESULT f_opendir(DIR *dj, /* Pointer to directory object to create */
2891:                const TCHAR *path /* Pointer to the directory path */
2892:                ) {
9D005E8C  27BDFFD8   ADDIU SP, SP, -40
9D005E90  AFBF0024   SW RA, 36(SP)
9D005E94  AFB00020   SW S0, 32(SP)
9D005E98  00808021   ADDU S0, A0, ZERO
9D005E9C  AFA5002C   SW A1, 44(SP)
2893:                	FRESULT res;
2894:                	DEF_NAMEBUF;
2895:                
2896:                	res = chk_mounted(&path, &dj->fs, 0);
9D005EA0  27A4002C   ADDIU A0, SP, 44
9D005EA4  02002821   ADDU A1, S0, ZERO
9D005EA8  0F4012F3   JAL chk_mounted
9D005EAC  00003021   ADDU A2, ZERO, ZERO
2897:                	if (res == FR_OK) {
9D005EB0  14400024   BNE V0, ZERO, 0x9D005F44
9D005EB4  8FBF0024   LW RA, 36(SP)
2898:                		INIT_BUF(*dj);
9D005EB8  27A20010   ADDIU V0, SP, 16
9D005EBC  AE020018   SW V0, 24(S0)
2899:                		res = follow_path(dj, path); /* Follow the path to the directory */
9D005EC0  02002021   ADDU A0, S0, ZERO
9D005EC4  0F40116C   JAL 0x9D0045B0
9D005EC8  8FA5002C   LW A1, 44(SP)
2900:                		FREE_BUF();
2901:                		if (res == FR_OK) { /* Follow completed */
9D005ECC  1440001A   BNE V0, ZERO, 0x9D005F38
9D005ED0  38440004   XORI A0, V0, 4
2902:                			if (dj->dir) { /* It is not the root dir */
9D005ED4  8E030014   LW V1, 20(S0)
9D005ED8  50600011   BEQL V1, ZERO, 0x9D005F20
9D005EDC  8E020000   LW V0, 0(S0)
2903:                				if (dj->dir[DIR_Attr] & AM_DIR) { /* The object is a directory */
9D005EE0  9064000B   LBU A0, 11(V1)
9D005EE4  30840010   ANDI A0, A0, 16
9D005EE8  10800015   BEQ A0, ZERO, 0x9D005F40
9D005EEC  24020005   ADDIU V0, ZERO, 5
2904:                					dj->sclust = LD_CLUST(dj->dir);
9D005EF0  90640015   LBU A0, 21(V1)
9D005EF4  00042200   SLL A0, A0, 8
9D005EF8  90620014   LBU V0, 20(V1)
9D005EFC  00822025   OR A0, A0, V0
9D005F00  00042400   SLL A0, A0, 16
9D005F04  9062001B   LBU V0, 27(V1)
9D005F08  00021200   SLL V0, V0, 8
9D005F0C  9063001A   LBU V1, 26(V1)
9D005F10  00431025   OR V0, V0, V1
9D005F14  00821025   OR V0, A0, V0
9D005F18  AE020008   SW V0, 8(S0)
2905:                				} else { /* The object is not a directory */
2906:                					res = FR_NO_PATH;
2907:                				}
2908:                			}
2909:                			if (res == FR_OK) {
2910:                				dj->id = dj->fs->id;
9D005F1C  8E020000   LW V0, 0(S0)
9D005F20  94420006   LHU V0, 6(V0)
9D005F24  A6020004   SH V0, 4(S0)
2911:                				res = dir_sdi(dj, 0); /* Rewind dir */
9D005F28  02002021   ADDU A0, S0, ZERO
9D005F2C  0F400FAB   JAL 0x9D003EAC
9D005F30  00002821   ADDU A1, ZERO, ZERO
2912:                			}
2913:                		}
2914:                		if (res == FR_NO_FILE)
2915:                			res = FR_NO_PATH;
9D005F34  38440004   XORI A0, V0, 4
9D005F38  24030005   ADDIU V1, ZERO, 5
9D005F3C  0064100A   MOVZ V0, V1, A0
2916:                	}
2917:                
2918:                	LEAVE_FF(dj->fs, res);
2919:                }
9D005F40  8FBF0024   LW RA, 36(SP)
9D005F44  8FB00020   LW S0, 32(SP)
9D005F48  03E00008   JR RA
9D005F4C  27BD0028   ADDIU SP, SP, 40
2920:                
2921:                /*-----------------------------------------------------------------------*/
2922:                /* Read Directory Entry in Sequense                                      */
2923:                /*-----------------------------------------------------------------------*/
2924:                
2925:                FRESULT f_readdir(DIR *dj, /* Pointer to the open directory object */
2926:                FILINFO *fno /* Pointer to file information to return */
2927:                ) {
9D005F50  27BDFFD0   ADDIU SP, SP, -48
9D005F54  AFBF002C   SW RA, 44(SP)
9D005F58  AFB20028   SW S2, 40(SP)
9D005F5C  AFB10024   SW S1, 36(SP)
9D005F60  AFB00020   SW S0, 32(SP)
9D005F64  00808821   ADDU S1, A0, ZERO
9D005F68  00A09021   ADDU S2, A1, ZERO
2928:                	FRESULT res;
2929:                	DEF_NAMEBUF;
2930:                
2931:                	res = validate(dj->fs, dj->id); /* Check validity of the object */
9D005F6C  8C840000   LW A0, 0(A0)
9D005F70  0F400F2B   JAL 0x9D003CAC
9D005F74  96250004   LHU A1, 4(S1)
2932:                	if (res == FR_OK) {
9D005F78  1440001C   BNE V0, ZERO, 0x9D005FEC
9D005F7C  00408021   ADDU S0, V0, ZERO
2933:                		if (!fno) {
9D005F80  16400006   BNE S2, ZERO, 0x9D005F9C
9D005F84  27A20010   ADDIU V0, SP, 16
2934:                			res = dir_sdi(dj, 0); /* Rewind the directory object */
9D005F88  02202021   ADDU A0, S1, ZERO
9D005F8C  0F400FAB   JAL 0x9D003EAC
9D005F90  00002821   ADDU A1, ZERO, ZERO
9D005F94  0B4017FB   J 0x9D005FEC
9D005F98  00408021   ADDU S0, V0, ZERO
2935:                		} else {
2936:                			INIT_BUF(*dj);
9D005F9C  AE220018   SW V0, 24(S1)
2937:                			res = dir_read(dj); /* Read an directory item */
9D005FA0  0F40128F   JAL 0x9D004A3C
9D005FA4  02202021   ADDU A0, S1, ZERO
2938:                			if (res == FR_NO_FILE) { /* Reached end of dir */
9D005FA8  24030004   ADDIU V1, ZERO, 4
9D005FAC  14430003   BNE V0, V1, 0x9D005FBC
9D005FB0  00000000   NOP
2939:                				dj->sect = 0;
9D005FB4  0B4017F1   J 0x9D005FC4
9D005FB8  AE200010   SW ZERO, 16(S1)
2940:                				res = FR_OK;
2941:                			}
2942:                			if (res == FR_OK) { /* A valid entry is found */
9D005FBC  5440000B   BNEL V0, ZERO, 0x9D005FEC
9D005FC0  00408021   ADDU S0, V0, ZERO
2943:                				get_fileinfo(dj, fno); /* Get the object information */
9D005FC4  02202021   ADDU A0, S1, ZERO
9D005FC8  0F400E22   JAL 0x9D003888
9D005FCC  02402821   ADDU A1, S2, ZERO
2944:                				res = dir_next(dj, 0); /* Increment index for next */
9D005FD0  02202021   ADDU A0, S1, ZERO
9D005FD4  0F4010EA   JAL 0x9D0043A8
9D005FD8  00002821   ADDU A1, ZERO, ZERO
2945:                				if (res == FR_NO_FILE) {
9D005FDC  24030004   ADDIU V1, ZERO, 4
9D005FE0  54430002   BNEL V0, V1, 0x9D005FEC
9D005FE4  00408021   ADDU S0, V0, ZERO
9D005FE8  AE200010   SW ZERO, 16(S1)
2946:                					dj->sect = 0;
2947:                					res = FR_OK;
2948:                				}
2949:                			} FREE_BUF();
2950:                		}
2951:                	}
2952:                
2953:                	LEAVE_FF(dj->fs, res);
2954:                }
9D005FEC  02001021   ADDU V0, S0, ZERO
9D005FF0  8FBF002C   LW RA, 44(SP)
9D005FF4  8FB20028   LW S2, 40(SP)
9D005FF8  8FB10024   LW S1, 36(SP)
9D005FFC  8FB00020   LW S0, 32(SP)
9D006000  03E00008   JR RA
9D006004  27BD0030   ADDIU SP, SP, 48
2955:                
2956:                #if _FS_MINIMIZE == 0
2957:                /*-----------------------------------------------------------------------*/
2958:                /* Get File Status                                                       */
2959:                /*-----------------------------------------------------------------------*/
2960:                
2961:                FRESULT f_stat(const TCHAR *path, /* Pointer to the file path */
2962:                                FILINFO *fno /* Pointer to file information to return */
2963:                                ) {
9D006008  27BDFFB8   ADDIU SP, SP, -72
9D00600C  AFBF0044   SW RA, 68(SP)
9D006010  AFB10040   SW S1, 64(SP)
9D006014  AFB0003C   SW S0, 60(SP)
9D006018  AFA40048   SW A0, 72(SP)
9D00601C  00A08821   ADDU S1, A1, ZERO
2964:                	FRESULT res;
2965:                	DIR dj;
2966:                	DEF_NAMEBUF;
2967:                
2968:                	res = chk_mounted(&path, &dj.fs, 0);
9D006020  27A40048   ADDIU A0, SP, 72
9D006024  27A50010   ADDIU A1, SP, 16
9D006028  0F4012F3   JAL chk_mounted
9D00602C  00003021   ADDU A2, ZERO, ZERO
2969:                	if (res == FR_OK) {
9D006030  14400010   BNE V0, ZERO, 0x9D006074
9D006034  00408021   ADDU S0, V0, ZERO
2970:                		INIT_BUF(dj);
9D006038  27A2002C   ADDIU V0, SP, 44
9D00603C  AFA20028   SW V0, 40(SP)
2971:                		res = follow_path(&dj, path); /* Follow the file path */
9D006040  27A40010   ADDIU A0, SP, 16
9D006044  0F40116C   JAL 0x9D0045B0
9D006048  8FA50048   LW A1, 72(SP)
2972:                		if (res == FR_OK) { /* Follow completed */
9D00604C  14400009   BNE V0, ZERO, 0x9D006074
9D006050  00408021   ADDU S0, V0, ZERO
2973:                			if (dj.dir) /* Found an object */
9D006054  8FA20024   LW V0, 36(SP)
9D006058  10400005   BEQ V0, ZERO, 0x9D006070
9D00605C  27A40010   ADDIU A0, SP, 16
2974:                				get_fileinfo(&dj, fno);
9D006060  0F400E22   JAL 0x9D003888
9D006064  02202821   ADDU A1, S1, ZERO
2975:                			else
2976:                				/* It is root dir */
2977:                				res = FR_INVALID_NAME;
9D006070  24100006   ADDIU S0, ZERO, 6
2978:                		}FREE_BUF();
2979:                	}
2980:                
2981:                	LEAVE_FF(dj.fs, res);
2982:                }
9D006068  0B40181E   J 0x9D006078
9D00606C  02001021   ADDU V0, S0, ZERO
9D006074  02001021   ADDU V0, S0, ZERO
9D006078  8FBF0044   LW RA, 68(SP)
9D00607C  8FB10040   LW S1, 64(SP)
9D006080  8FB0003C   LW S0, 60(SP)
9D006084  03E00008   JR RA
9D006088  27BD0048   ADDIU SP, SP, 72
2983:                
2984:                #if !_FS_READONLY
2985:                /*-----------------------------------------------------------------------*/
2986:                /* Get Number of Free Clusters                                           */
2987:                /*-----------------------------------------------------------------------*/
2988:                
2989:                FRESULT f_getfree(const TCHAR *path, /* Pointer to the logical drive number (root dir) */
2990:                DWORD *nclst, /* Pointer to the variable to return number of free clusters */
2991:                FATFS **fatfs /* Pointer to pointer to corresponding file system object to return */
2992:                ) {
9D00608C  27BDFFC8   ADDIU SP, SP, -56
9D006090  AFBF0034   SW RA, 52(SP)
9D006094  AFB70030   SW S7, 48(SP)
9D006098  AFB6002C   SW S6, 44(SP)
9D00609C  AFB50028   SW S5, 40(SP)
9D0060A0  AFB40024   SW S4, 36(SP)
9D0060A4  AFB30020   SW S3, 32(SP)
9D0060A8  AFB2001C   SW S2, 28(SP)
9D0060AC  AFB10018   SW S1, 24(SP)
9D0060B0  AFB00014   SW S0, 20(SP)
9D0060B4  AFA40038   SW A0, 56(SP)
9D0060B8  00A0B821   ADDU S7, A1, ZERO
9D0060BC  00C09021   ADDU S2, A2, ZERO
2993:                	FRESULT res;
2994:                	DWORD n, clst, sect, stat;
2995:                	UINT i;
2996:                	PF_BYTE fat, *p;
2997:                
2998:                	/* Get drive number */
2999:                	res = chk_mounted(&path, fatfs, 0);
9D0060C0  27A40038   ADDIU A0, SP, 56
9D0060C4  00C02821   ADDU A1, A2, ZERO
9D0060C8  0F4012F3   JAL chk_mounted
9D0060CC  00003021   ADDU A2, ZERO, ZERO
3000:                	if (res == FR_OK) {
9D0060D0  1440005A   BNE V0, ZERO, 0x9D00623C
9D0060D4  00408021   ADDU S0, V0, ZERO
3001:                		/* If free_clust is valid, return it without full cluster scan */
3002:                		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
9D0060D8  8E420000   LW V0, 0(S2)
9D0060DC  8C430010   LW V1, 16(V0)
9D0060E0  8C510018   LW S1, 24(V0)
9D0060E4  2624FFFE   ADDIU A0, S1, -2
9D0060E8  0083202B   SLTU A0, A0, V1
9D0060EC  54800003   BNEL A0, ZERO, 0x9D0060FC
9D0060F0  90540000   LBU S4, 0(V0)
3003:                			*nclst = (*fatfs)->free_clust;
9D0060F4  0B40188F   J 0x9D00623C
9D0060F8  AEE30000   SW V1, 0(S7)
3004:                		} else {
3005:                			/* Get number of free clusters */
3006:                			fat = (*fatfs)->fs_type;
3007:                			n = 0;
9D006160  00009821   ADDU S3, ZERO, ZERO
3008:                			if (fat == FS_FAT12) {
9D0060FC  24030001   ADDIU V1, ZERO, 1
9D006100  56830015   BNEL S4, V1, 0x9D006158
9D006104  8C560020   LW S6, 32(V0)
9D006108  24110002   ADDIU S1, ZERO, 2
9D00610C  00009821   ADDU S3, ZERO, ZERO
3009:                				clst = 2;
3010:                				do {
3011:                					stat = get_fat(*fatfs, clst);
9D006118  8E440000   LW A0, 0(S2)
9D00611C  0F400F4A   JAL get_fat
9D006120  02202821   ADDU A1, S1, ZERO
3012:                					if (stat == 0xFFFFFFFF) {
9D006110  2415FFFF   ADDIU S5, ZERO, -1
9D006124  5055003C   BEQL V0, S5, 0x9D006218
9D006128  24100001   ADDIU S0, ZERO, 1
3013:                						res = FR_DISK_ERR;
3014:                						break;
3015:                					}
3016:                					if (stat == 1) {
9D006114  24160001   ADDIU S6, ZERO, 1
9D00612C  10560037   BEQ V0, S6, 0x9D00620C
9D006130  2C420001   SLTIU V0, V0, 1
3017:                						res = FR_INT_ERR;
9D00620C  0B401886   J 0x9D006218
9D006210  24100002   ADDIU S0, ZERO, 2
3018:                						break;
3019:                					}
3020:                					if (stat == 0)
3021:                						n++;
9D006134  02629821   ADDU S3, S3, V0
3022:                				} while (++clst < (*fatfs)->n_fatent);
9D006138  26310001   ADDIU S1, S1, 1
9D00613C  8E420000   LW V0, 0(S2)
9D006140  8C430018   LW V1, 24(V0)
9D006144  0223182B   SLTU V1, S1, V1
9D006148  5460FFF4   BNEL V1, ZERO, 0x9D00611C
9D00614C  8E440000   LW A0, 0(S2)
3023:                			} else {
3024:                				clst = (*fatfs)->n_fatent;
3025:                				sect = (*fatfs)->fatbase;
3026:                				i = 0;
9D00615C  00001821   ADDU V1, ZERO, ZERO
3027:                				p = 0;
9D006158  00001021   ADDU V0, ZERO, ZERO
3028:                				do {
3029:                					if (!i) {
9D006168  14600009   BNE V1, ZERO, 0x9D006190
9D00616C  00000000   NOP
3030:                						res = move_window(*fatfs, sect++);
9D006170  8E440000   LW A0, 0(S2)
9D006174  0F400E6A   JAL 0x9D0039A8
9D006178  02C02821   ADDU A1, S6, ZERO
9D006214  00408021   ADDU S0, V0, ZERO
3031:                						if (res != FR_OK)
9D00617C  14400025   BNE V0, ZERO, 0x9D006214
9D006180  26D60001   ADDIU S6, S6, 1
3032:                							break;
3033:                						p = (*fatfs)->win;
9D006184  8E420000   LW V0, 0(S2)
9D006188  24420030   ADDIU V0, V0, 48
3034:                						i = SS(*fatfs);
9D00618C  24030200   ADDIU V1, ZERO, 512
3035:                					}
3036:                					if (fat == FS_FAT16) {
9D006164  24150002   ADDIU S5, ZERO, 2
9D006190  5695000B   BNEL S4, S5, 0x9D0061C0
9D006194  90450003   LBU A1, 3(V0)
3037:                						if (LD_WORD(p) == 0)
9D006198  90440001   LBU A0, 1(V0)
9D00619C  00042200   SLL A0, A0, 8
9D0061A0  90450000   LBU A1, 0(V0)
9D0061A4  00852025   OR A0, A0, A1
9D0061A8  7C042620   SEH A0, A0
3038:                							n++;
9D0061AC  2C840001   SLTIU A0, A0, 1
9D0061B0  02649821   ADDU S3, S3, A0
3039:                						p += 2;
9D0061B4  24420002   ADDIU V0, V0, 2
3040:                						i -= 2;
9D0061B8  0B40187E   J 0x9D0061F8
9D0061BC  2463FFFE   ADDIU V1, V1, -2
3041:                					} else {
3042:                						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0)
9D0061C0  00052E00   SLL A1, A1, 24
9D0061C4  90440002   LBU A0, 2(V0)
9D0061C8  00042400   SLL A0, A0, 16
9D0061CC  00A42025   OR A0, A1, A0
9D0061D0  90450000   LBU A1, 0(V0)
9D0061D4  00852025   OR A0, A0, A1
9D0061D8  90450001   LBU A1, 1(V0)
9D0061DC  00052A00   SLL A1, A1, 8
9D0061E0  00852025   OR A0, A0, A1
9D0061E4  7C84D800   EXT A0, A0, 0, 28
3043:                							n++;
9D0061E8  2C840001   SLTIU A0, A0, 1
9D0061EC  02649821   ADDU S3, S3, A0
3044:                						p += 4;
9D0061F0  24420004   ADDIU V0, V0, 4
3045:                						i -= 4;
9D0061F4  2463FFFC   ADDIU V1, V1, -4
3046:                					}
3047:                				} while (--clst);
9D0061F8  2631FFFF   ADDIU S1, S1, -1
9D0061FC  1620FFDA   BNE S1, ZERO, 0x9D006168
9D006200  00000000   NOP
3048:                			}
3049:                			(*fatfs)->free_clust = n;
9D006150  0B40188E   J 0x9D006238
9D006154  AC530010   SW S3, 16(V0)
9D006204  0B401887   J 0x9D00621C
9D006208  8E420000   LW V0, 0(S2)
9D006218  8E420000   LW V0, 0(S2)
9D00621C  AC530010   SW S3, 16(V0)
3050:                			if (fat == FS_FAT32)
9D006220  24020003   ADDIU V0, ZERO, 3
9D006224  56820005   BNEL S4, V0, 0x9D00623C
9D006228  AEF30000   SW S3, 0(S7)
3051:                				(*fatfs)->fsi_flag = 1;
9D00622C  8E420000   LW V0, 0(S2)
9D006230  24030001   ADDIU V1, ZERO, 1
9D006234  A0430005   SB V1, 5(V0)
3052:                			*nclst = n;
9D006238  AEF30000   SW S3, 0(S7)
3053:                		}
3054:                	}
3055:                	LEAVE_FF(*fatfs, res);
3056:                }
9D00623C  02001021   ADDU V0, S0, ZERO
9D006240  8FBF0034   LW RA, 52(SP)
9D006244  8FB70030   LW S7, 48(SP)
9D006248  8FB6002C   LW S6, 44(SP)
9D00624C  8FB50028   LW S5, 40(SP)
9D006250  8FB40024   LW S4, 36(SP)
9D006254  8FB30020   LW S3, 32(SP)
9D006258  8FB2001C   LW S2, 28(SP)
9D00625C  8FB10018   LW S1, 24(SP)
9D006260  8FB00014   LW S0, 20(SP)
9D006264  03E00008   JR RA
9D006268  27BD0038   ADDIU SP, SP, 56
3057:                
3058:                /*-----------------------------------------------------------------------*/
3059:                /* Truncate File                                                         */
3060:                /*-----------------------------------------------------------------------*/
3061:                
3062:                FRESULT f_truncate(FIL *fp /* Pointer to the file object */
3063:                ) {
9D00626C  27BDFFE0   ADDIU SP, SP, -32
9D006270  AFBF001C   SW RA, 28(SP)
9D006274  AFB10018   SW S1, 24(SP)
9D006278  AFB00014   SW S0, 20(SP)
9D00627C  00808021   ADDU S0, A0, ZERO
3064:                	FRESULT res;
3065:                	DWORD ncl;
3066:                
3067:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D006280  8C840000   LW A0, 0(A0)
9D006284  0F400F2B   JAL 0x9D003CAC
9D006288  96050004   LHU A1, 4(S0)
3068:                	if (res == FR_OK) {
9D00628C  14400033   BNE V0, ZERO, 0x9D00635C
9D006290  8FBF001C   LW RA, 28(SP)
3069:                		if (fp->flag & FA__ERROR) { /* Check abort flag */
9D006294  92030006   LBU V1, 6(S0)
9D006298  7C032420   SEB A0, V1
9D00629C  04800005   BLTZ A0, 0x9D0062B4
9D0062A0  30640002   ANDI A0, V1, 2
3070:                			res = FR_INT_ERR;
9D0062B4  0B4018D6   J 0x9D006358
9D0062B8  24020002   ADDIU V0, ZERO, 2
3071:                		} else {
3072:                			if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D0062A4  54800031   BNEL A0, ZERO, 0x9D00636C
9D0062A8  8E040008   LW A0, 8(S0)
3073:                				res = FR_DENIED;
9D0062AC  0B4018D6   J 0x9D006358
9D0062B0  24020007   ADDIU V0, ZERO, 7
3074:                		}
3075:                	}
3076:                	if (res == FR_OK) {
3077:                		if (fp->fsize > fp->fptr) {
9D00636C  8E05000C   LW A1, 12(S0)
9D006370  0085282B   SLTU A1, A0, A1
9D006374  54A0FFD1   BNEL A1, ZERO, 0x9D0062BC
9D006378  AE04000C   SW A0, 12(S0)
3078:                			fp->fsize = fp->fptr; /* Set file size to current R/W point */
3079:                			fp->flag |= FA__WRITTEN;
9D0062BC  34630020   ORI V1, V1, 32
3080:                			if (fp->fptr == 0) { /* When set file size to zero, remove entire cluster chain */
9D0062C0  14800006   BNE A0, ZERO, 0x9D0062DC
9D0062C4  A2030006   SB V1, 6(S0)
3081:                				res = remove_chain(fp->fs, fp->sclust);
9D0062C8  8E040000   LW A0, 0(S0)
9D0062CC  0F4012B9   JAL 0x9D004AE4
9D0062D0  8E050010   LW A1, 16(S0)
3082:                				fp->sclust = 0;
9D0062D4  0B4018D0   J 0x9D006340
9D0062D8  AE000010   SW ZERO, 16(S0)
3083:                			} else { /* When truncate a part of the file, remove remaining clusters */
3084:                				ncl = get_fat(fp->fs, fp->clust);
9D0062DC  8E040000   LW A0, 0(S0)
9D0062E0  0F400F4A   JAL get_fat
9D0062E4  8E050014   LW A1, 20(S0)
9D0062E8  00408821   ADDU S1, V0, ZERO
3085:                				res = FR_OK;
9D0062F8  26220001   ADDIU V0, S1, 1
9D0062FC  2C420001   SLTIU V0, V0, 1
3086:                				if (ncl == 0xFFFFFFFF)
3087:                					res = FR_DISK_ERR;
3088:                				if (ncl == 1)
9D0062EC  24020001   ADDIU V0, ZERO, 1
9D0062F0  12220015   BEQ S1, V0, 0x9D006348
9D0062F4  24020002   ADDIU V0, ZERO, 2
3089:                					res = FR_INT_ERR;
3090:                				if (res == FR_OK && ncl < fp->fs->n_fatent) {
9D006300  54400012   BNEL V0, ZERO, 0x9D00634C
9D006304  92040006   LBU A0, 6(S0)
9D006308  8E040000   LW A0, 0(S0)
9D00630C  8C830018   LW V1, 24(A0)
9D006310  0223182B   SLTU V1, S1, V1
9D006314  10600011   BEQ V1, ZERO, 0x9D00635C
9D006318  8FBF001C   LW RA, 28(SP)
3091:                					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
9D00631C  8E050014   LW A1, 20(S0)
9D006320  3C060FFF   LUI A2, 4095
9D006324  0F40101A   JAL put_fat
9D006328  34C6FFFF   ORI A2, A2, -1
3092:                					if (res == FR_OK)
9D00632C  54400007   BNEL V0, ZERO, 0x9D00634C
9D006330  92040006   LBU A0, 6(S0)
3093:                						res = remove_chain(fp->fs, ncl);
9D006334  8E040000   LW A0, 0(S0)
9D006338  0F4012B9   JAL 0x9D004AE4
9D00633C  02202821   ADDU A1, S1, ZERO
3094:                				}
3095:                			}
3096:                		}
3097:                		if (res != FR_OK)
9D006340  10400006   BEQ V0, ZERO, 0x9D00635C
9D006344  8FBF001C   LW RA, 28(SP)
3098:                			fp->flag |= FA__ERROR;
9D006348  92040006   LBU A0, 6(S0)
9D00634C  2403FF80   ADDIU V1, ZERO, -128
9D006350  00831825   OR V1, A0, V1
9D006354  A2030006   SB V1, 6(S0)
3099:                	}
3100:                
3101:                	LEAVE_FF(fp->fs, res);
3102:                }
9D006358  8FBF001C   LW RA, 28(SP)
9D00635C  8FB10018   LW S1, 24(SP)
9D006360  8FB00014   LW S0, 20(SP)
9D006364  03E00008   JR RA
9D006368  27BD0020   ADDIU SP, SP, 32
9D00637C  0B4018D7   J 0x9D00635C
9D006380  8FBF001C   LW RA, 28(SP)
3103:                
3104:                /*-----------------------------------------------------------------------*/
3105:                /* Delete a File or Directory                                            */
3106:                /*-----------------------------------------------------------------------*/
3107:                
3108:                FRESULT f_unlink(const TCHAR *path /* Pointer to the file or directory path */
3109:                ) {
9D006384  27BDFFA0   ADDIU SP, SP, -96
9D006388  AFBF005C   SW RA, 92(SP)
9D00638C  AFB00058   SW S0, 88(SP)
9D006390  AFA40060   SW A0, 96(SP)
3110:                	FRESULT res;
3111:                	DIR dj, sdj;
3112:                	PF_BYTE *dir;
3113:                	DWORD dclst;
3114:                	DEF_NAMEBUF;
3115:                
3116:                	res = chk_mounted(&path, &dj.fs, 1);
9D006394  27A40060   ADDIU A0, SP, 96
9D006398  27A50010   ADDIU A1, SP, 16
9D00639C  0F4012F3   JAL chk_mounted
9D0063A0  24060001   ADDIU A2, ZERO, 1
3117:                	if (res == FR_OK) {
9D0063A4  1440002E   BNE V0, ZERO, 0x9D006460
9D0063A8  8FBF005C   LW RA, 92(SP)
3118:                		INIT_BUF(dj);
9D0063AC  27A20048   ADDIU V0, SP, 72
9D0063B0  AFA20028   SW V0, 40(SP)
3119:                		res = follow_path(&dj, path); /* Follow the file path */
9D0063B4  27A40010   ADDIU A0, SP, 16
9D0063B8  0F40116C   JAL 0x9D0045B0
9D0063BC  8FA50060   LW A1, 96(SP)
3120:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3121:                			res = FR_INVALID_NAME; /* Cannot remove dot entry */
3122:                #if _FS_SHARE
3123:                		if (res == FR_OK) res = chk_lock(&dj, 2); /* Cannot remove open file */
3124:                #endif
3125:                		if (res == FR_OK) { /* The object is accessible */
9D0063C0  14400026   BNE V0, ZERO, 0x9D00645C
9D0063C4  8FA30024   LW V1, 36(SP)
3126:                			dir = dj.dir;
3127:                			if (!dir) {
9D0063C8  10600024   BEQ V1, ZERO, 0x9D00645C
9D0063CC  24020006   ADDIU V0, ZERO, 6
3128:                				res = FR_INVALID_NAME; /* Cannot remove the start directory */
3129:                			} else {
3130:                				if (dir[DIR_Attr] & AM_RDO)
9D0063D0  9062000B   LBU V0, 11(V1)
9D0063D4  30420001   ANDI V0, V0, 1
9D0063D8  5040002A   BEQL V0, ZERO, 0x9D006484
9D0063DC  90620015   LBU V0, 21(V1)
3131:                					res = FR_DENIED; /* Cannot remove R/O object */
9D0063E0  0B401917   J 0x9D00645C
9D0063E4  24020007   ADDIU V0, ZERO, 7
3132:                			}
3133:                			dclst = LD_CLUST(dir);
9D006484  00021200   SLL V0, V0, 8
9D006488  90640014   LBU A0, 20(V1)
9D00648C  00441025   OR V0, V0, A0
9D006490  00021400   SLL V0, V0, 16
9D006494  9070001B   LBU S0, 27(V1)
9D006498  00108200   SLL S0, S0, 8
9D00649C  9064001A   LBU A0, 26(V1)
9D0064A0  02048025   OR S0, S0, A0
9D0064A4  00508025   OR S0, V0, S0
3134:                			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) { /* Is it a sub-dir? */
9D0064A8  9062000B   LBU V0, 11(V1)
9D0064AC  30420010   ANDI V0, V0, 16
9D0064B0  1440FFCD   BNE V0, ZERO, 0x9D0063E8
9D0064B4  2E030002   SLTIU V1, S0, 2
9D0064B8  0B40191B   J 0x9D00646C
9D0064BC  00000000   NOP
3135:                				if (dclst < 2) {
9D0063E8  1460001C   BNE V1, ZERO, 0x9D00645C
9D0063EC  24020002   ADDIU V0, ZERO, 2
3136:                					res = FR_INT_ERR;
3137:                				} else {
3138:                					mem_cpy(&sdj, &dj, sizeof(DIR)); /* Check if the sub-dir is empty or not */
9D0063F0  27A4002C   ADDIU A0, SP, 44
9D0063F4  27A50010   ADDIU A1, SP, 16
9D0063F8  0F400DF0   JAL 0x9D0037C0
9D0063FC  2406001C   ADDIU A2, ZERO, 28
3139:                					sdj.sclust = dclst;
9D006400  AFB00034   SW S0, 52(SP)
3140:                					res = dir_sdi(&sdj, 2); /* Exclude dot entries */
9D006404  27A4002C   ADDIU A0, SP, 44
9D006408  0F400FAB   JAL 0x9D003EAC
9D00640C  24050002   ADDIU A1, ZERO, 2
3141:                					if (res == FR_OK) {
9D006410  14400013   BNE V0, ZERO, 0x9D006460
9D006414  8FBF005C   LW RA, 92(SP)
3142:                						res = dir_read(&sdj);
9D006418  0F40128F   JAL 0x9D004A3C
9D00641C  27A4002C   ADDIU A0, SP, 44
3143:                						if (res == FR_OK /* Not empty dir */
9D006420  5040000E   BEQL V0, ZERO, 0x9D00645C
9D006424  24020007   ADDIU V0, ZERO, 7
3144:                #if _FS_RPATH
3145:                							|| dclst == sdj.fs->cdir /* Current dir */
3146:                #endif
3147:                							) res = FR_DENIED;
3148:                						if (res == FR_NO_FILE)
9D006428  24030004   ADDIU V1, ZERO, 4
9D00642C  1043000F   BEQ V0, V1, 0x9D00646C
9D006430  8FBF005C   LW RA, 92(SP)
3149:                							res = FR_OK; /* Empty */
3150:                					}
3151:                				}
3152:                			}
3153:                			if (res == FR_OK) {
3154:                				res = dir_remove(&dj); /* Remove the directory entry */
9D00646C  0F401004   JAL 0x9D004010
9D006470  27A40010   ADDIU A0, SP, 16
3155:                				if (res == FR_OK) {
9D006474  1040FFF1   BEQ V0, ZERO, 0x9D00643C
9D006478  8FBF005C   LW RA, 92(SP)
3156:                					if (dclst) /* Remove the cluster chain if exist */
9D00643C  12000005   BEQ S0, ZERO, 0x9D006454
9D006440  8FA40010   LW A0, 16(SP)
3157:                						res = remove_chain(dj.fs, dclst);
9D006444  0F4012B9   JAL 0x9D004AE4
9D006448  02002821   ADDU A1, S0, ZERO
3158:                					if (res == FR_OK)
9D00644C  14400004   BNE V0, ZERO, 0x9D006460
9D006450  8FBF005C   LW RA, 92(SP)
3159:                						res = sync(dj.fs);
9D006454  0F400EE1   JAL 0x9D003B84
9D006458  8FA40010   LW A0, 16(SP)
3160:                				}
3161:                			}
3162:                		}FREE_BUF();
3163:                	}
3164:                	LEAVE_FF(dj.fs, res);
3165:                }
9D006434  0B401919   J 0x9D006464
9D006438  8FB00058   LW S0, 88(SP)
9D00645C  8FBF005C   LW RA, 92(SP)
9D006460  8FB00058   LW S0, 88(SP)
9D006464  03E00008   JR RA
9D006468  27BD0060   ADDIU SP, SP, 96
9D00647C  0B401919   J 0x9D006464
9D006480  8FB00058   LW S0, 88(SP)
3166:                
3167:                /*-----------------------------------------------------------------------*/
3168:                /* Create a Directory                                                    */
3169:                /*-----------------------------------------------------------------------*/
3170:                
3171:                FRESULT f_mkdir(const TCHAR *path /* Pointer to the directory path */
9D006684  32B500FF   ANDI S5, S5, 255
9D006688  26B50001   ADDIU S5, S5, 1
9D00668C  02B2A821   ADDU S5, S5, S2
3172:                ) {
9D0064C0  27BDFF88   ADDIU SP, SP, -120
9D0064C4  AFBF0074   SW RA, 116(SP)
9D0064C8  AFBE0070   SW S8, 112(SP)
9D0064CC  AFB7006C   SW S7, 108(SP)
9D0064D0  AFB60068   SW S6, 104(SP)
9D0064D4  AFB50064   SW S5, 100(SP)
9D0064D8  AFB40060   SW S4, 96(SP)
9D0064DC  AFB3005C   SW S3, 92(SP)
9D0064E0  AFB20058   SW S2, 88(SP)
9D0064E4  AFB10054   SW S1, 84(SP)
9D0064E8  AFB00050   SW S0, 80(SP)
3173:                	FRESULT res;
3174:                	DIR dj;
3175:                	PF_BYTE *dir, n;
3176:                	DWORD dsc, dcl, pcl, tim = get_fattime();
9D0064EC  0F4024FC   JAL get_fattime
9D0064F0  AFA40078   SW A0, 120(SP)
9D0064F4  00408821   ADDU S1, V0, ZERO
3177:                	DEF_NAMEBUF;
3178:                
3179:                	res = chk_mounted(&path, &dj.fs, 1);
9D0064F8  27A40078   ADDIU A0, SP, 120
9D0064FC  27A50010   ADDIU A1, SP, 16
9D006500  0F4012F3   JAL chk_mounted
9D006504  24060001   ADDIU A2, ZERO, 1
3180:                	if (res == FR_OK) {
9D006508  1440008C   BNE V0, ZERO, 0x9D00673C
9D00650C  00408021   ADDU S0, V0, ZERO
3181:                		INIT_BUF(dj);
9D006510  27A2002C   ADDIU V0, SP, 44
9D006514  AFA20028   SW V0, 40(SP)
3182:                		res = follow_path(&dj, path); /* Follow the file path */
9D006518  27A40010   ADDIU A0, SP, 16
9D00651C  0F40116C   JAL 0x9D0045B0
9D006520  8FA50078   LW A1, 120(SP)
3183:                		if (res == FR_OK)
9D006524  50400085   BEQL V0, ZERO, 0x9D00673C
9D006528  24100008   ADDIU S0, ZERO, 8
3184:                			res = FR_EXIST; /* Any object with same name is already existing */
3185:                		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
3186:                			res = FR_INVALID_NAME;
3187:                		if (res == FR_NO_FILE) { /* Can create a new directory */
9D00652C  24030004   ADDIU V1, ZERO, 4
9D006530  54430082   BNEL V0, V1, 0x9D00673C
9D006534  00408021   ADDU S0, V0, ZERO
3188:                			dcl = create_chain(dj.fs, 0); /* Allocate a cluster for the new directory table */
9D006538  8FA40010   LW A0, 16(SP)
9D00653C  0F401089   JAL 0x9D004224
9D006540  00002821   ADDU A1, ZERO, ZERO
3189:                			res = FR_OK;
3190:                			if (dcl == 0)
9D006544  10400009   BEQ V0, ZERO, 0x9D00656C
9D006548  00409821   ADDU S3, V0, ZERO
3191:                				res = FR_DENIED; /* No space to allocate a new cluster */
9D00656C  24100007   ADDIU S0, ZERO, 7
3192:                			if (dcl == 1)
9D00654C  24020001   ADDIU V0, ZERO, 1
9D006550  52620060   BEQL S3, V0, 0x9D0066D4
9D006554  24100002   ADDIU S0, ZERO, 2
3193:                				res = FR_INT_ERR;
3194:                			if (dcl == 0xFFFFFFFF)
9D006558  2402FFFF   ADDIU V0, ZERO, -1
9D00655C  5262005D   BEQL S3, V0, 0x9D0066D4
9D006560  24100001   ADDIU S0, ZERO, 1
9D006564  0B40195C   J 0x9D006570
9D006568  00000000   NOP
3195:                				res = FR_DISK_ERR;
3196:                			if (res == FR_OK) /* Flush FAT */
9D006570  16000058   BNE S0, ZERO, 0x9D0066D4
9D006574  8FA40010   LW A0, 16(SP)
3197:                				res = move_window(dj.fs, 0);
9D006578  0F400E6A   JAL 0x9D0039A8
9D00657C  00002821   ADDU A1, ZERO, ZERO
3198:                			if (res == FR_OK) { /* Initialize the new directory table */
9D006580  14400054   BNE V0, ZERO, 0x9D0066D4
9D006584  00408021   ADDU S0, V0, ZERO
3199:                				dsc = clust2sect(dj.fs, dcl);
9D006588  8FB00010   LW S0, 16(SP)
9D00658C  02002021   ADDU A0, S0, ZERO
9D006590  0F400F3E   JAL clust2sect
9D006594  02602821   ADDU A1, S3, ZERO
9D006598  00409021   ADDU S2, V0, ZERO
3200:                				dir = dj.fs->win;
9D00659C  26140030   ADDIU S4, S0, 48
3201:                				mem_set(dir, 0, SS(dj.fs));
9D0065A0  02802021   ADDU A0, S4, ZERO
9D0065A4  00002821   ADDU A1, ZERO, ZERO
9D0065A8  0F400DFA   JAL 0x9D0037E8
9D0065AC  24060200   ADDIU A2, ZERO, 512
3202:                				mem_set(dir + DIR_Name, ' ', 8 + 3); /* Create "." entry */
9D0065B0  02802021   ADDU A0, S4, ZERO
9D0065B4  24050020   ADDIU A1, ZERO, 32
9D0065B8  0F400DFA   JAL 0x9D0037E8
9D0065BC  2406000B   ADDIU A2, ZERO, 11
3203:                				dir[DIR_Name] = '.';
9D0065C0  2415002E   ADDIU S5, ZERO, 46
9D0065C4  A2150030   SB S5, 48(S0)
3204:                				dir[DIR_Attr] = AM_DIR;
9D0065C8  24020010   ADDIU V0, ZERO, 16
9D0065CC  A202003B   SB V0, 59(S0)
3205:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D0065D0  322200FF   ANDI V0, S1, 255
9D0065D4  AFA20038   SW V0, 56(SP)
9D0065D8  A2020046   SB V0, 70(S0)
9D0065DC  00111A02   SRL V1, S1, 8
9D0065E0  A3A30048   SB V1, 72(SP)
9D0065E4  A2030047   SB V1, 71(S0)
9D0065E8  7E223C00   EXT V0, S1, 16, 8
9D0065EC  AFA2003C   SW V0, 60(SP)
9D0065F0  A2020048   SB V0, 72(S0)
9D0065F4  00118E02   SRL S1, S1, 24
9D0065F8  AFB10040   SW S1, 64(SP)
9D0065FC  A2110049   SB S1, 73(S0)
3206:                				ST_CLUST(dir, dcl);
9D006600  326300FF   ANDI V1, S3, 255
9D006604  AFA30044   SW V1, 68(SP)
9D006608  A203004A   SB V1, 74(S0)
9D00660C  0013BA02   SRL S7, S3, 8
9D006610  A217004B   SB S7, 75(S0)
9D006614  0013B402   SRL S6, S3, 16
9D006618  32DE00FF   ANDI S8, S6, 255
9D00661C  A21E0044   SB S8, 68(S0)
9D006620  0016B202   SRL S6, S6, 8
9D006624  A2160045   SB S6, 69(S0)
3207:                				mem_cpy(dir + SZ_DIR, dir, SZ_DIR); /* Create ".." entry */
9D006628  26040050   ADDIU A0, S0, 80
9D00662C  02802821   ADDU A1, S4, ZERO
9D006630  0F400DF0   JAL 0x9D0037C0
9D006634  24060020   ADDIU A2, ZERO, 32
3208:                				dir[33] = '.';
9D006638  A2150051   SB S5, 81(S0)
3209:                				pcl = dj.sclust;
3210:                				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
9D00663C  8FA30010   LW V1, 16(SP)
9D006640  90650000   LBU A1, 0(V1)
9D006644  24040003   ADDIU A0, ZERO, 3
9D006648  14A40004   BNE A1, A0, 0x9D00665C
9D00664C  8FA20018   LW V0, 24(SP)
9D006650  8C640024   LW A0, 36(V1)
3211:                					pcl = 0;
9D006654  00822026   XOR A0, A0, V0
9D006658  0004100A   MOVZ V0, ZERO, A0
3212:                				ST_CLUST(dir+SZ_DIR, pcl);
9D00665C  A202006A   SB V0, 106(S0)
9D006660  7C443A00   EXT A0, V0, 8, 8
9D006664  A204006B   SB A0, 107(S0)
9D006668  00021402   SRL V0, V0, 16
9D00666C  A2020064   SB V0, 100(S0)
9D006670  00021202   SRL V0, V0, 8
9D006674  A2020065   SB V0, 101(S0)
3213:                				for (n = dj.fs->csize; n; n--) { /* Write dot entries and clear following sectors */
9D006678  90620002   LBU V0, 2(V1)
9D00667C  1040003C   BEQ V0, ZERO, 0x9D006770
9D006680  2455FFFF   ADDIU S5, V0, -1
9D0066C4  1655FFF4   BNE S2, S5, 0x9D006698
9D0066C8  8FA40010   LW A0, 16(SP)
9D0066CC  0B4019DC   J 0x9D006770
9D0066D0  00000000   NOP
3214:                					dj.fs->winsect = dsc++;
9D006694  8FA40010   LW A0, 16(SP)
9D006698  AC92002C   SW S2, 44(A0)
9D00669C  26520001   ADDIU S2, S2, 1
3215:                					dj.fs->wflag = 1;
9D006690  24110001   ADDIU S1, ZERO, 1
9D0066A0  A0910004   SB S1, 4(A0)
3216:                					res = move_window(dj.fs, 0);
9D0066A4  0F400E6A   JAL 0x9D0039A8
9D0066A8  00002821   ADDU A1, ZERO, ZERO
3217:                					if (res != FR_OK)
9D0066AC  14400009   BNE V0, ZERO, 0x9D0066D4
9D0066B0  00408021   ADDU S0, V0, ZERO
3218:                						break;
3219:                					mem_set(dir, 0, SS(dj.fs));
9D0066B4  02802021   ADDU A0, S4, ZERO
9D0066B8  00002821   ADDU A1, ZERO, ZERO
9D0066BC  0F400DFA   JAL 0x9D0037E8
9D0066C0  24060200   ADDIU A2, ZERO, 512
3220:                				}
3221:                			}
3222:                			if (res == FR_OK)
3223:                				res = dir_register(&dj); /* Register the object to the directoy */
9D006770  0F40125A   JAL 0x9D004968
9D006774  27A40010   ADDIU A0, SP, 16
3224:                			if (res != FR_OK) {
9D006778  1040FFDB   BEQ V0, ZERO, 0x9D0066E8
9D00677C  00408021   ADDU S0, V0, ZERO
3225:                				remove_chain(dj.fs, dcl); /* Could not register, remove cluster chain */
9D0066D4  8FA40010   LW A0, 16(SP)
9D0066D8  0F4012B9   JAL 0x9D004AE4
9D0066DC  02602821   ADDU A1, S3, ZERO
9D006780  0B4019B6   J 0x9D0066D8
9D006784  8FA40010   LW A0, 16(SP)
3226:                			} else {
3227:                				dir = dj.dir;
9D0066E8  8FA20024   LW V0, 36(SP)
3228:                				dir[DIR_Attr] = AM_DIR; /* Attribute */
9D0066EC  24030010   ADDIU V1, ZERO, 16
9D0066F0  A043000B   SB V1, 11(V0)
3229:                				ST_DWORD(dir+DIR_WrtTime, tim); /* Created time */
9D0066F4  8FA30038   LW V1, 56(SP)
9D0066F8  A0430016   SB V1, 22(V0)
9D0066FC  93A30048   LBU V1, 72(SP)
9D006700  A0430017   SB V1, 23(V0)
9D006704  8FA3003C   LW V1, 60(SP)
9D006708  A0430018   SB V1, 24(V0)
9D00670C  8FA30040   LW V1, 64(SP)
9D006710  A0430019   SB V1, 25(V0)
3230:                				ST_CLUST(dir, dcl); /* Table start cluster */
9D006714  8FA30044   LW V1, 68(SP)
9D006718  A043001A   SB V1, 26(V0)
9D00671C  A057001B   SB S7, 27(V0)
9D006720  A05E0014   SB S8, 20(V0)
9D006724  A0560015   SB S6, 21(V0)
3231:                				dj.fs->wflag = 1;
9D006728  8FA40010   LW A0, 16(SP)
9D00672C  24020001   ADDIU V0, ZERO, 1
3232:                				res = sync(dj.fs);
9D006730  0F400EE1   JAL 0x9D003B84
9D006734  A0820004   SB V0, 4(A0)
9D006738  00408021   ADDU S0, V0, ZERO
3233:                			}
3234:                		}FREE_BUF();
3235:                	}
3236:                
3237:                	LEAVE_FF(dj.fs, res);
3238:                }
9D0066E0  0B4019D0   J 0x9D006740
9D0066E4  02001021   ADDU V0, S0, ZERO
9D00673C  02001021   ADDU V0, S0, ZERO
9D006740  8FBF0074   LW RA, 116(SP)
9D006744  8FBE0070   LW S8, 112(SP)
9D006748  8FB7006C   LW S7, 108(SP)
9D00674C  8FB60068   LW S6, 104(SP)
9D006750  8FB50064   LW S5, 100(SP)
9D006754  8FB40060   LW S4, 96(SP)
9D006758  8FB3005C   LW S3, 92(SP)
9D00675C  8FB20058   LW S2, 88(SP)
9D006760  8FB10054   LW S1, 84(SP)
9D006764  8FB00050   LW S0, 80(SP)
9D006768  03E00008   JR RA
9D00676C  27BD0078   ADDIU SP, SP, 120
3239:                
3240:                /*-----------------------------------------------------------------------*/
3241:                /* Change Attribute                                                      */
3242:                /*-----------------------------------------------------------------------*/
3243:                
3244:                FRESULT f_chmod(const TCHAR *path, /* Pointer to the file path */
3245:                PF_BYTE value, /* Attribute bits */
3246:                PF_BYTE mask /* Attribute mask to change */
3247:                ) {
9D006788  27BDFFB8   ADDIU SP, SP, -72
9D00678C  AFBF0044   SW RA, 68(SP)
9D006790  AFB10040   SW S1, 64(SP)
9D006794  AFB0003C   SW S0, 60(SP)
9D006798  AFA40048   SW A0, 72(SP)
9D00679C  30B100FF   ANDI S1, A1, 255
9D0067A0  30D000FF   ANDI S0, A2, 255
3248:                	FRESULT res;
3249:                	DIR dj;
3250:                	PF_BYTE *dir;
3251:                	DEF_NAMEBUF;
3252:                
3253:                	res = chk_mounted(&path, &dj.fs, 1);
9D0067A4  27A40048   ADDIU A0, SP, 72
9D0067A8  27A50010   ADDIU A1, SP, 16
9D0067AC  0F4012F3   JAL chk_mounted
9D0067B0  24060001   ADDIU A2, ZERO, 1
3254:                	if (res == FR_OK) {
9D0067B4  14400016   BNE V0, ZERO, 0x9D006810
9D0067B8  8FBF0044   LW RA, 68(SP)
3255:                		INIT_BUF(dj);
9D0067BC  27A2002C   ADDIU V0, SP, 44
9D0067C0  AFA20028   SW V0, 40(SP)
3256:                		res = follow_path(&dj, path); /* Follow the file path */
9D0067C4  27A40010   ADDIU A0, SP, 16
9D0067C8  0F40116C   JAL 0x9D0045B0
9D0067CC  8FA50048   LW A1, 72(SP)
3257:                		FREE_BUF();
3258:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3259:                			res = FR_INVALID_NAME;
3260:                		if (res == FR_OK) {
9D0067D0  1440000E   BNE V0, ZERO, 0x9D00680C
9D0067D4  8FA30024   LW V1, 36(SP)
3261:                			dir = dj.dir;
3262:                			if (!dir) { /* Is it a root directory? */
9D0067D8  1060000C   BEQ V1, ZERO, 0x9D00680C
9D0067DC  24020006   ADDIU V0, ZERO, 6
3263:                				res = FR_INVALID_NAME;
3264:                			} else { /* File or sub directory */
3265:                				mask &= AM_RDO | AM_HID | AM_SYS | AM_ARC; /* Valid attribute mask */
9D0067E0  32100027   ANDI S0, S0, 39
3266:                				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr]
9D0067E8  9062000B   LBU V0, 11(V1)
9D0067EC  00821024   AND V0, A0, V0
9D0067F0  02118024   AND S0, S0, S1
9D0067F4  00508025   OR S0, V0, S0
9D0067F8  A070000B   SB S0, 11(V1)
3267:                						& (PF_BYTE) ~mask); /* Apply attribute change */
9D0067E4  00102027   NOR A0, ZERO, S0
3268:                				dj.fs->wflag = 1;
9D0067FC  8FA40010   LW A0, 16(SP)
9D006800  24020001   ADDIU V0, ZERO, 1
3269:                				res = sync(dj.fs);
9D006804  0F400EE1   JAL 0x9D003B84
9D006808  A0820004   SB V0, 4(A0)
3270:                			}
3271:                		}
3272:                	}
3273:                
3274:                	LEAVE_FF(dj.fs, res);
3275:                }
9D00680C  8FBF0044   LW RA, 68(SP)
9D006810  8FB10040   LW S1, 64(SP)
9D006814  8FB0003C   LW S0, 60(SP)
9D006818  03E00008   JR RA
9D00681C  27BD0048   ADDIU SP, SP, 72
3276:                
3277:                /*-----------------------------------------------------------------------*/
3278:                /* Change Timestamp                                                      */
3279:                /*-----------------------------------------------------------------------*/
3280:                
3281:                FRESULT f_utime(const TCHAR *path, /* Pointer to the file/directory name */
3282:                const FILINFO *fno /* Pointer to the time stamp to be set */
3283:                ) {
9D006820  27BDFFC0   ADDIU SP, SP, -64
9D006824  AFBF003C   SW RA, 60(SP)
9D006828  AFB00038   SW S0, 56(SP)
9D00682C  AFA40040   SW A0, 64(SP)
9D006830  00A08021   ADDU S0, A1, ZERO
3284:                	FRESULT res;
3285:                	DIR dj;
3286:                	PF_BYTE *dir;
3287:                	DEF_NAMEBUF;
3288:                
3289:                	res = chk_mounted(&path, &dj.fs, 1);
9D006834  27A40040   ADDIU A0, SP, 64
9D006838  27A50010   ADDIU A1, SP, 16
9D00683C  0F4012F3   JAL chk_mounted
9D006840  24060001   ADDIU A2, ZERO, 1
3290:                	if (res == FR_OK) {
9D006844  14400019   BNE V0, ZERO, 0x9D0068AC
9D006848  8FBF003C   LW RA, 60(SP)
3291:                		INIT_BUF(dj);
9D00684C  27A2002C   ADDIU V0, SP, 44
9D006850  AFA20028   SW V0, 40(SP)
3292:                		res = follow_path(&dj, path); /* Follow the file path */
9D006854  27A40010   ADDIU A0, SP, 16
9D006858  0F40116C   JAL 0x9D0045B0
9D00685C  8FA50040   LW A1, 64(SP)
3293:                		FREE_BUF();
3294:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3295:                			res = FR_INVALID_NAME;
3296:                		if (res == FR_OK) {
9D006860  14400011   BNE V0, ZERO, 0x9D0068A8
9D006864  8FA30024   LW V1, 36(SP)
3297:                			dir = dj.dir;
3298:                			if (!dir) { /* Root directory */
9D006868  1060000F   BEQ V1, ZERO, 0x9D0068A8
9D00686C  24020006   ADDIU V0, ZERO, 6
3299:                				res = FR_INVALID_NAME;
3300:                			} else { /* File or sub-directory */
3301:                				ST_WORD(dir+DIR_WrtTime, fno->ftime);
9D006870  96020006   LHU V0, 6(S0)
9D006874  A0620016   SB V0, 22(V1)
9D006878  96020006   LHU V0, 6(S0)
9D00687C  00021202   SRL V0, V0, 8
9D006880  A0620017   SB V0, 23(V1)
3302:                				ST_WORD(dir+DIR_WrtDate, fno->fdate);
9D006884  96020004   LHU V0, 4(S0)
9D006888  A0620018   SB V0, 24(V1)
9D00688C  96020004   LHU V0, 4(S0)
9D006890  00021202   SRL V0, V0, 8
9D006894  A0620019   SB V0, 25(V1)
3303:                				dj.fs->wflag = 1;
9D006898  8FA40010   LW A0, 16(SP)
9D00689C  24020001   ADDIU V0, ZERO, 1
3304:                				res = sync(dj.fs);
9D0068A0  0F400EE1   JAL 0x9D003B84
9D0068A4  A0820004   SB V0, 4(A0)
3305:                			}
3306:                		}
3307:                	}
3308:                
3309:                	LEAVE_FF(dj.fs, res);
3310:                }
9D0068A8  8FBF003C   LW RA, 60(SP)
9D0068AC  8FB00038   LW S0, 56(SP)
9D0068B0  03E00008   JR RA
9D0068B4  27BD0040   ADDIU SP, SP, 64
3311:                
3312:                /*-----------------------------------------------------------------------*/
3313:                /* Rename File/Directory                                                 */
3314:                /*-----------------------------------------------------------------------*/
3315:                
3316:                FRESULT f_rename(const TCHAR *path_old, /* Pointer to the old name */
3317:                const TCHAR *path_new /* Pointer to the new name */
3318:                ) {
9D0068B8  27BDFF80   ADDIU SP, SP, -128
9D0068BC  AFBF007C   SW RA, 124(SP)
9D0068C0  AFB10078   SW S1, 120(SP)
9D0068C4  AFB00074   SW S0, 116(SP)
9D0068C8  AFA40080   SW A0, 128(SP)
9D0068CC  00A08021   ADDU S0, A1, ZERO
3319:                	FRESULT res;
3320:                	DIR djo, djn;
3321:                	PF_BYTE buf[21], *dir;
3322:                	DWORD dw;
3323:                	DEF_NAMEBUF;
3324:                
3325:                	res = chk_mounted(&path_old, &djo.fs, 1);
9D0068D0  27A40080   ADDIU A0, SP, 128
9D0068D4  27A50010   ADDIU A1, SP, 16
9D0068D8  0F4012F3   JAL chk_mounted
9D0068DC  24060001   ADDIU A2, ZERO, 1
3326:                	if (res == FR_OK) {
9D0068E0  14400064   BNE V0, ZERO, 0x9D006A74
9D0068E4  8FBF007C   LW RA, 124(SP)
3327:                		djn.fs = djo.fs;
9D0068E8  8FA20010   LW V0, 16(SP)
9D0068EC  AFA2002C   SW V0, 44(SP)
3328:                		INIT_BUF(djo);
9D0068F0  27A20060   ADDIU V0, SP, 96
9D0068F4  AFA20028   SW V0, 40(SP)
3329:                		res = follow_path(&djo, path_old); /* Check old object */
9D0068F8  27A40010   ADDIU A0, SP, 16
9D0068FC  0F40116C   JAL 0x9D0045B0
9D006900  8FA50080   LW A1, 128(SP)
3330:                		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
3331:                			res = FR_INVALID_NAME;
3332:                #if _FS_SHARE
3333:                		if (res == FR_OK) res = chk_lock(&djo, 2);
3334:                #endif
3335:                		if (res == FR_OK) { /* Old object is found */
9D006904  1440005A   BNE V0, ZERO, 0x9D006A70
9D006908  8FA50024   LW A1, 36(SP)
3336:                			if (!djo.dir) { /* Is root dir? */
9D00690C  10A00058   BEQ A1, ZERO, 0x9D006A70
9D006910  24020004   ADDIU V0, ZERO, 4
3337:                				res = FR_NO_FILE;
3338:                			} else {
3339:                				mem_cpy(buf, djo.dir + DIR_Attr, 21); /* Save the object information except for name */
9D006914  27A40048   ADDIU A0, SP, 72
9D006918  24A5000B   ADDIU A1, A1, 11
9D00691C  0F400DF0   JAL 0x9D0037C0
9D006920  24060015   ADDIU A2, ZERO, 21
3340:                				mem_cpy(&djn, &djo, sizeof(DIR)); /* Check new object */
9D006924  27A4002C   ADDIU A0, SP, 44
9D006928  27A50010   ADDIU A1, SP, 16
9D00692C  0F400DF0   JAL 0x9D0037C0
9D006930  2406001C   ADDIU A2, ZERO, 28
3341:                				res = follow_path(&djn, path_new);
9D006934  27A4002C   ADDIU A0, SP, 44
9D006938  0F40116C   JAL 0x9D0045B0
9D00693C  02002821   ADDU A1, S0, ZERO
3342:                				if (res == FR_OK)
9D006940  5040004B   BEQL V0, ZERO, 0x9D006A70
9D006944  24020008   ADDIU V0, ZERO, 8
3343:                					res = FR_EXIST; /* The new object name is already existing */
3344:                				if (res == FR_NO_FILE) { /* Is it a valid path and no name collision? */
9D006948  24030004   ADDIU V1, ZERO, 4
9D00694C  14430049   BNE V0, V1, 0x9D006A74
9D006950  8FBF007C   LW RA, 124(SP)
3345:                					/* Start critical section that any interruption or error can cause cross-link */
3346:                					res = dir_register(&djn); /* Register the new entry */
9D006954  0F40125A   JAL 0x9D004968
9D006958  27A4002C   ADDIU A0, SP, 44
3347:                					if (res == FR_OK) {
9D00695C  14400045   BNE V0, ZERO, 0x9D006A74
9D006960  8FBF007C   LW RA, 124(SP)
3348:                						dir = djn.dir; /* Copy object information except for name */
9D006964  8FB00040   LW S0, 64(SP)
3349:                						mem_cpy(dir + 13, buf + 2, 19);
9D006968  2604000D   ADDIU A0, S0, 13
9D00696C  27A5004A   ADDIU A1, SP, 74
9D006970  0F400DF0   JAL 0x9D0037C0
9D006974  24060013   ADDIU A2, ZERO, 19
3350:                						dir[DIR_Attr] = buf[0] | AM_ARC;
9D006978  93A20048   LBU V0, 72(SP)
9D00697C  34420020   ORI V0, V0, 32
9D006980  A202000B   SB V0, 11(S0)
3351:                						djo.fs->wflag = 1;
9D006984  24030001   ADDIU V1, ZERO, 1
9D006988  8FA20010   LW V0, 16(SP)
9D00698C  A0430004   SB V1, 4(V0)
3352:                						if (djo.sclust != djn.sclust
9D006990  8FA20034   LW V0, 52(SP)
9D006994  8FA30018   LW V1, 24(SP)
9D006998  1062002D   BEQ V1, V0, 0x9D006A50
9D00699C  00000000   NOP
3353:                								&& (dir[DIR_Attr] & AM_DIR)) { /* Update .. entry in the directory if needed */
9D0069A0  9202000B   LBU V0, 11(S0)
9D0069A4  30420010   ANDI V0, V0, 16
9D0069A8  10400029   BEQ V0, ZERO, 0x9D006A50
9D0069AC  8FB1002C   LW S1, 44(SP)
3354:                							dw = clust2sect(djn.fs, LD_CLUST(dir));
9D0069B0  92050015   LBU A1, 21(S0)
9D0069B4  00052A00   SLL A1, A1, 8
9D0069B8  92020014   LBU V0, 20(S0)
9D0069BC  00A22825   OR A1, A1, V0
9D0069C0  00052C00   SLL A1, A1, 16
9D0069C4  9203001B   LBU V1, 27(S0)
9D0069C8  00031A00   SLL V1, V1, 8
9D0069CC  9202001A   LBU V0, 26(S0)
9D0069D0  00621025   OR V0, V1, V0
9D0069D4  02202021   ADDU A0, S1, ZERO
9D0069D8  0F400F3E   JAL clust2sect
9D0069DC  00A22825   OR A1, A1, V0
9D0069E0  00402821   ADDU A1, V0, ZERO
3355:                							if (!dw) {
9D0069E4  10A00022   BEQ A1, ZERO, 0x9D006A70
9D0069E8  24020002   ADDIU V0, ZERO, 2
3356:                								res = FR_INT_ERR;
3357:                							} else {
3358:                								res = move_window(djn.fs, dw);
9D0069EC  0F400E6A   JAL 0x9D0039A8
9D0069F0  02202021   ADDU A0, S1, ZERO
3359:                								dir = djn.fs->win + SZ_DIR; /* .. entry */
3360:                								if (res == FR_OK && dir[1] == '.') {
9D0069F4  1440001E   BNE V0, ZERO, 0x9D006A70
9D0069F8  8FA3002C   LW V1, 44(SP)
9D0069FC  90640051   LBU A0, 81(V1)
9D006A00  2402002E   ADDIU V0, ZERO, 46
9D006A04  14820012   BNE A0, V0, 0x9D006A50
9D006A08  24020003   ADDIU V0, ZERO, 3
3361:                									dw
3362:                											= (djn.fs->fs_type == FS_FAT32
3363:                													&& djn.sclust
3364:                															== djn.fs->dirbase) ? 0
3365:                													: djn.sclust;
9D006A0C  90640000   LBU A0, 0(V1)
9D006A10  14820006   BNE A0, V0, 0x9D006A2C
9D006A14  8FA20034   LW V0, 52(SP)
9D006A18  8C640024   LW A0, 36(V1)
9D006A1C  8FA50034   LW A1, 52(SP)
9D006A20  10A40002   BEQ A1, A0, 0x9D006A2C
9D006A24  00001021   ADDU V0, ZERO, ZERO
9D006A28  8FA20034   LW V0, 52(SP)
3366:                									ST_CLUST(dir, dw);
9D006A2C  A062006A   SB V0, 106(V1)
9D006A30  7C443A00   EXT A0, V0, 8, 8
9D006A34  A064006B   SB A0, 107(V1)
9D006A38  00021402   SRL V0, V0, 16
9D006A3C  A0620064   SB V0, 100(V1)
9D006A40  00021202   SRL V0, V0, 8
9D006A44  A0620065   SB V0, 101(V1)
3367:                									djn.fs->wflag = 1;
9D006A48  24020001   ADDIU V0, ZERO, 1
9D006A4C  A0620004   SB V0, 4(V1)
3368:                								}
3369:                							}
3370:                						}
3371:                						if (res == FR_OK) {
3372:                							res = dir_remove(&djo); /* Remove old entry */
9D006A50  0F401004   JAL 0x9D004010
9D006A54  27A40010   ADDIU A0, SP, 16
3373:                							if (res == FR_OK)
9D006A58  54400006   BNEL V0, ZERO, 0x9D006A74
9D006A5C  8FBF007C   LW RA, 124(SP)
3374:                								res = sync(djo.fs);
9D006A60  0F400EE1   JAL 0x9D003B84
9D006A64  8FA40010   LW A0, 16(SP)
3375:                						}
3376:                					}
3377:                					/* End critical section */
3378:                				}
3379:                			}
3380:                		}FREE_BUF();
3381:                	}
3382:                	LEAVE_FF(djo.fs, res);
3383:                }
9D006A68  0B401A9D   J 0x9D006A74
9D006A6C  8FBF007C   LW RA, 124(SP)
9D006A70  8FBF007C   LW RA, 124(SP)
9D006A74  8FB10078   LW S1, 120(SP)
9D006A78  8FB00074   LW S0, 116(SP)
9D006A7C  03E00008   JR RA
9D006A80  27BD0080   ADDIU SP, SP, 128
3384:                
3385:                #endif /* !_FS_READONLY */
3386:                #endif /* _FS_MINIMIZE == 0 */
3387:                #endif /* _FS_MINIMIZE <= 1 */
3388:                #endif /* _FS_MINIMIZE <= 2 */
3389:                
3390:                /*-----------------------------------------------------------------------*/
3391:                /* Forward data to the stream directly (available on only tiny cfg)      */
3392:                /*-----------------------------------------------------------------------*/
3393:                #if _USE_FORWARD && _FS_TINY
3394:                
3395:                FRESULT f_forward (
3396:                		FIL *fp, /* Pointer to the file object */
3397:                		UINT (*func)(const PF_BYTE*,UINT), /* Pointer to the streaming function */
3398:                		UINT btr, /* Number of bytes to forward */
3399:                		UINT *bf /* Pointer to number of bytes forwarded */
3400:                )
3401:                {
3402:                	FRESULT res;
3403:                	DWORD remain, clst, sect;
3404:                	UINT rcnt;
3405:                	PF_BYTE csect;
3406:                
3407:                	*bf = 0; /* Initialize byte counter */
3408:                
3409:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
3410:                	if (res != FR_OK) LEAVE_FF(fp->fs, res);
3411:                	if (fp->flag & FA__ERROR) /* Check error flag */
3412:                	LEAVE_FF(fp->fs, FR_INT_ERR);
3413:                	if (!(fp->flag & FA_READ)) /* Check access mode */
3414:                	LEAVE_FF(fp->fs, FR_DENIED);
3415:                
3416:                	remain = fp->fsize - fp->fptr;
3417:                	if (btr > remain) btr = (UINT)remain; /* Truncate btr by remaining bytes */
3418:                
3419:                	for (; btr && (*func)(0, 0); /* Repeat until all data transferred or stream becomes busy */
3420:                			fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
3421:                		csect = (PF_BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
3422:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
3423:                			if (!csect) { /* On the cluster boundary? */
3424:                				clst = (fp->fptr == 0) ? /* On the top of the file? */
3425:                				fp->sclust : get_fat(fp->fs, fp->clust);
3426:                				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
3427:                				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
3428:                				fp->clust = clst; /* Update current cluster */
3429:                			}
3430:                		}
3431:                		sect = clust2sect(fp->fs, fp->clust); /* Get current data sector */
3432:                		if (!sect) ABORT(fp->fs, FR_INT_ERR);
3433:                		sect += csect;
3434:                		if (move_window(fp->fs, sect)) /* Move sector window */
3435:                		ABORT(fp->fs, FR_DISK_ERR);
3436:                		fp->dsect = sect;
3437:                		rcnt = SS(fp->fs) - (PF_WORD)(fp->fptr % SS(fp->fs)); /* Forward data from sector window */
3438:                		if (rcnt > btr) rcnt = btr;
3439:                		rcnt = (*func)(&fp->fs->win[(PF_WORD)fp->fptr % SS(fp->fs)], rcnt);
3440:                		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
3441:                	}
3442:                
3443:                	LEAVE_FF(fp->fs, FR_OK);
3444:                }
3445:                #endif /* _USE_FORWARD */
3446:                
3447:                #if _USE_MKFS && !_FS_READONLY
3448:                /*-----------------------------------------------------------------------*/
3449:                /* Create File System on the Drive                                       */
3450:                /*-----------------------------------------------------------------------*/
3451:                #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
3452:                #define N_FATS		1		/* Number of FAT copies (1 or 2) */
3453:                
3454:                FRESULT f_mkfs (
3455:                		PF_BYTE drv, /* Logical drive number */
3456:                		PF_BYTE sfd, /* Partitioning rule 0:FDISK, 1:SFD */
3457:                		UINT au /* Allocation unit size [bytes] */
3458:                )
3459:                {
3460:                	static const PF_WORD vst[] = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0};
3461:                	static const PF_WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
3462:                	PF_BYTE fmt, md, sys, *tbl, pdrv, part;
3463:                	DWORD n_clst, vs, n, wsect;
3464:                	UINT i;
3465:                	DWORD b_vol, b_fat, b_dir, b_data; /* LBA */
3466:                	DWORD n_vol, n_rsv, n_fat, n_dir; /* Size */
3467:                	FATFS *fs;
3468:                	DSTATUS stat;
3469:                
3470:                	/* Check mounted drive and clear work area */
3471:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
3472:                	if (sfd > 1) return FR_INVALID_PARAMETER;
3473:                	if (au & (au - 1)) return FR_INVALID_PARAMETER;
3474:                	fs = FatFs[drv];
3475:                	if (!fs) return FR_NOT_ENABLED;
3476:                	fs->fs_type = 0;
3477:                	pdrv = LD2PD(drv); /* Physical drive */
3478:                	part = LD2PT(drv); /* Partition (0:auto detect, 1-4:get from partition table)*/
3479:                
3480:                	/* Get disk statics */
3481:                	stat = disk_initialize(pdrv);
3482:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3483:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3484:                #if _MAX_SS != 512					/* Get disk sector size */
3485:                	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
3486:                	return FR_DISK_ERR;
3487:                #endif
3488:                	if (_MULTI_PARTITION && part) {
3489:                		/* Get partition information from partition table in the MBR */
3490:                		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3491:                		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
3492:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3493:                		if (!tbl[4]) return FR_MKFS_ABORTED; /* No partition? */
3494:                		b_vol = LD_DWORD(tbl+8); /* Volume start sector */
3495:                		n_vol = LD_DWORD(tbl+12); /* Volume size */
3496:                	} else {
3497:                		/* Create a partition in this function */
3498:                		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
3499:                		return FR_DISK_ERR;
3500:                		b_vol = (sfd) ? 0 : 63; /* Volume start sector */
3501:                		n_vol -= b_vol; /* Volume size */
3502:                	}
3503:                
3504:                	if (!au) { /* AU auto selection */
3505:                		vs = n_vol / (2000 / (SS(fs) / 512));
3506:                		for (i = 0; vs < vst[i]; i++);
3507:                		au = cst[i];
3508:                	}
3509:                	au /= SS(fs); /* Number of sectors per cluster */
3510:                	if (au == 0) au = 1;
3511:                	if (au > 128) au = 128;
3512:                
3513:                	/* Pre-compute number of clusters and FAT syb-type */
3514:                	n_clst = n_vol / au;
3515:                	fmt = FS_FAT12;
3516:                	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
3517:                	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
3518:                
3519:                	/* Determine offset and size of FAT structure */
3520:                	if (fmt == FS_FAT32) {
3521:                		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
3522:                		n_rsv = 32;
3523:                		n_dir = 0;
3524:                	} else {
3525:                		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
3526:                		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
3527:                		n_rsv = 1;
3528:                		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
3529:                	}
3530:                	b_fat = b_vol + n_rsv; /* FAT area start sector */
3531:                	b_dir = b_fat + n_fat * N_FATS; /* Directory area start sector */
3532:                	b_data = b_dir + n_dir; /* Data area start sector */
3533:                	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED; /* Too small volume */
3534:                
3535:                	/* Align data start sector to erase block boundary (for flash memory media) */
3536:                	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
3537:                	n = (b_data + n - 1) & ~(n - 1); /* Next nearest erase block from current data start */
3538:                	n = (n - b_data) / N_FATS;
3539:                	if (fmt == FS_FAT32) { /* FAT32: Move FAT offset */
3540:                		n_rsv += n;
3541:                		b_fat += n;
3542:                	} else { /* FAT12/16: Expand FAT size */
3543:                		n_fat += n;
3544:                	}
3545:                
3546:                	/* Determine number of clusters and final check of validity of the FAT sub-type */
3547:                	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
3548:                	if ( (fmt == FS_FAT16 && n_clst < MIN_FAT16)
3549:                			|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
3550:                	return FR_MKFS_ABORTED;
3551:                
3552:                	switch (fmt) { /* Determine system ID for partition table */
3553:                		case FS_FAT12: sys = 0x01; break;
3554:                		case FS_FAT16: sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
3555:                		default: sys = 0x0C;
3556:                	}
3557:                
3558:                	if (_MULTI_PARTITION && part) {
3559:                		/* Update system ID in the partition table */
3560:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3561:                		tbl[4] = sys;
3562:                		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3563:                		md = 0xF8;
3564:                	} else {
3565:                		if (sfd) { /* No patition table (SFD) */
3566:                			md = 0xF0;
3567:                		} else { /* Create partition table (FDISK) */
3568:                			mem_set(fs->win, 0, SS(fs));
3569:                			tbl = fs->win+MBR_Table; /* Create partiton table for single partition in the drive */
3570:                			tbl[1] = 1; /* Partition start head */
3571:                			tbl[2] = 1; /* Partition start sector */
3572:                			tbl[3] = 0; /* Partition start cylinder */
3573:                			tbl[4] = sys; /* System type */
3574:                			tbl[5] = 254; /* Partition end head */
3575:                			n = (b_vol + n_vol) / 63 / 255;
3576:                			tbl[6] = (PF_BYTE)((n >> 2) | 63); /* Partiiton end sector */
3577:                			tbl[7] = (PF_BYTE)n; /* End cylinder */
3578:                			ST_DWORD(tbl+8, 63); /* Partition start in LBA */
3579:                			ST_DWORD(tbl+12, n_vol); /* Partition size in LBA */
3580:                			ST_WORD(fs->win+BS_55AA, 0xAA55); /* MBR signature */
3581:                			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) /* Write it to the MBR sector */
3582:                			return FR_DISK_ERR;
3583:                			md = 0xF8;
3584:                		}
3585:                	}
3586:                
3587:                	/* Create BPB in the VBR */
3588:                	tbl = fs->win; /* Clear sector */
3589:                	mem_set(tbl, 0, SS(fs));
3590:                	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
3591:                	i = SS(fs); /* Sector size */
3592:                	ST_WORD(tbl+BPB_BytsPerSec, i);
3593:                	tbl[BPB_SecPerClus] = (PF_BYTE)au; /* Sectors per cluster */
3594:                	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv); /* Reserved sectors */
3595:                	tbl[BPB_NumFATs] = N_FATS; /* Number of FATs */
3596:                	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR; /* Number of rootdir entries */
3597:                	ST_WORD(tbl+BPB_RootEntCnt, i);
3598:                	if (n_vol < 0x10000) { /* Number of total sectors */
3599:                		ST_WORD(tbl+BPB_TotSec16, n_vol);
3600:                	} else {
3601:                		ST_DWORD(tbl+BPB_TotSec32, n_vol);
3602:                	}
3603:                	tbl[BPB_Media] = md; /* Media descriptor */
3604:                	ST_WORD(tbl+BPB_SecPerTrk, 63); /* Number of sectors per track */
3605:                	ST_WORD(tbl+BPB_NumHeads, 255); /* Number of heads */
3606:                	ST_DWORD(tbl+BPB_HiddSec, b_vol); /* Hidden sectors */
3607:                	n = get_fattime(); /* Use current time as VSN */
3608:                	if (fmt == FS_FAT32) {
3609:                		ST_DWORD(tbl+BS_VolID32, n); /* VSN */
3610:                		ST_DWORD(tbl+BPB_FATSz32, n_fat); /* Number of sectors per FAT */
3611:                		ST_DWORD(tbl+BPB_RootClus, 2); /* Root directory start cluster (2) */
3612:                		ST_WORD(tbl+BPB_FSInfo, 1); /* FSInfo record offset (VBR+1) */
3613:                		ST_WORD(tbl+BPB_BkBootSec, 6); /* Backup boot record offset (VBR+6) */
3614:                		tbl[BS_DrvNum32] = 0x80; /* Drive number */
3615:                		tbl[BS_BootSig32] = 0x29; /* Extended boot signature */
3616:                		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19); /* Volume label, FAT signature */
3617:                	} else {
3618:                		ST_DWORD(tbl+BS_VolID, n); /* VSN */
3619:                		ST_WORD(tbl+BPB_FATSz16, n_fat); /* Number of sectors per FAT */
3620:                		tbl[BS_DrvNum] = 0x80; /* Drive number */
3621:                		tbl[BS_BootSig] = 0x29; /* Extended boot signature */
3622:                		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19); /* Volume label, FAT signature */
3623:                	}
3624:                	ST_WORD(tbl+BS_55AA, 0xAA55); /* Signature (Offset is fixed here regardless of sector size) */
3625:                	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK) /* Write it to the VBR sector */
3626:                	return FR_DISK_ERR;
3627:                	if (fmt == FS_FAT32) /* Write backup VBR if needed (VBR+6) */
3628:                	disk_write(pdrv, tbl, b_vol + 6, 1);
3629:                
3630:                	/* Initialize FAT area */
3631:                	wsect = b_fat;
3632:                	for (i = 0; i < N_FATS; i++) { /* Initialize each FAT copy */
3633:                		mem_set(tbl, 0, SS(fs)); /* 1st sector of the FAT  */
3634:                		n = md; /* Media descriptor byte */
3635:                		if (fmt != FS_FAT32) {
3636:                			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
3637:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT12/16) */
3638:                		} else {
3639:                			n |= 0xFFFFFF00;
3640:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT32) */
3641:                			ST_DWORD(tbl+4, 0xFFFFFFFF);
3642:                			ST_DWORD(tbl+8, 0x0FFFFFFF); /* Reserve cluster #2 for root dir */
3643:                		}
3644:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3645:                		return FR_DISK_ERR;
3646:                		mem_set(tbl, 0, SS(fs)); /* Fill following FAT entries with zero */
3647:                		for (n = 1; n < n_fat; n++) { /* This loop may take a time on FAT32 volume due to many single sector writes */
3648:                			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3649:                			return FR_DISK_ERR;
3650:                		}
3651:                	}
3652:                
3653:                	/* Initialize root directory */
3654:                	i = (fmt == FS_FAT32) ? au : n_dir;
3655:                	do {
3656:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3657:                		return FR_DISK_ERR;
3658:                	}while (--i);
3659:                
3660:                #if _USE_ERASE	/* Erase data area if needed */
3661:                	{
3662:                		DWORD eb[2];
3663:                
3664:                		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
3665:                		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
3666:                	}
3667:                #endif
3668:                
3669:                	/* Create FSInfo if needed */
3670:                	if (fmt == FS_FAT32) {
3671:                		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
3672:                		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
3673:                		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1); /* Number of free clusters */
3674:                		ST_DWORD(tbl+FSI_Nxt_Free, 2); /* Last allocated cluster# */
3675:                		ST_WORD(tbl+BS_55AA, 0xAA55);
3676:                		disk_write(pdrv, tbl, b_vol + 1, 1); /* Write original (VBR+1) */
3677:                		disk_write(pdrv, tbl, b_vol + 7, 1); /* Write backup (VBR+7) */
3678:                	}
3679:                
3680:                	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
3681:                }
3682:                
3683:                #if _MULTI_PARTITION == 2
3684:                /*-----------------------------------------------------------------------*/
3685:                /* Divide Physical Drive                                                 */
3686:                /*-----------------------------------------------------------------------*/
3687:                
3688:                FRESULT f_fdisk (
3689:                		PF_BYTE pdrv, /* Physical drive number */
3690:                		const DWORD szt[], /* Pointer to the size table for each partitions */
3691:                		void* work /* Pointer to the working buffer */
3692:                )
3693:                {
3694:                	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
3695:                	PF_BYTE s_hd, e_hd, *p, *buf = (PF_BYTE*)work;
3696:                	DSTATUS stat;
3697:                	DWORD sz_disk, sz_part, s_part;
3698:                
3699:                	stat = disk_initialize(pdrv);
3700:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3701:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3702:                	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
3703:                
3704:                	/* Determine CHS in the table regardless of the drive geometry */
3705:                	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2);
3706:                	if (n == 256) n--;
3707:                	e_hd = n - 1;
3708:                	sz_cyl = 63 * n;
3709:                	tot_cyl = sz_disk / sz_cyl;
3710:                
3711:                	/* Create partition table */
3712:                	mem_set(buf, 0, _MAX_SS);
3713:                	p = buf + MBR_Table; b_cyl = 0;
3714:                	for (i = 0; i < 4; i++, p += SZ_PTE) {
3715:                		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
3716:                		if (!p_cyl) continue;
3717:                		s_part = (DWORD)sz_cyl * b_cyl;
3718:                		sz_part = (DWORD)sz_cyl * p_cyl;
3719:                		if (i == 0) { /* Exclude first track of cylinder 0 */
3720:                			s_hd = 1;
3721:                			s_part += 63; sz_part -= 63;
3722:                		} else {
3723:                			s_hd = 0;
3724:                		}
3725:                		e_cyl = b_cyl + p_cyl - 1;
3726:                		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
3727:                
3728:                		/* Set partition table */
3729:                		p[1] = s_hd; /* Start head */
3730:                		p[2] = (PF_BYTE)((b_cyl >> 2) + 1); /* Start sector */
3731:                		p[3] = (PF_BYTE)b_cyl; /* Start cylinder */
3732:                		p[4] = 0x06; /* System type (temporary setting) */
3733:                		p[5] = e_hd; /* End head */
3734:                		p[6] = (PF_BYTE)((e_cyl >> 2) + 63); /* End sector */
3735:                		p[7] = (PF_BYTE)e_cyl; /* End cylinder */
3736:                		ST_DWORD(p + 8, s_part); /* Start sector in LBA */
3737:                		ST_DWORD(p + 12, sz_part); /* Partition size */
3738:                
3739:                		/* Next partition */
3740:                		b_cyl += p_cyl;
3741:                	}
3742:                	ST_WORD(p, 0xAA55);
3743:                
3744:                	/* Write it to the MBR */
3745:                	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
3746:                }
3747:                
3748:                #endif /* _MULTI_PARTITION == 2 */
3749:                #endif /* _USE_MKFS && !_FS_READONLY */
3750:                
3751:                #if _USE_STRFUNC
3752:                /*-----------------------------------------------------------------------*/
3753:                /* Get a string from the file                                            */
3754:                /*-----------------------------------------------------------------------*/
3755:                TCHAR* f_gets (
3756:                		TCHAR* buff, /* Pointer to the string buffer to read */
3757:                		int len, /* Size of string buffer (characters) */
3758:                		FIL* fil /* Pointer to the file object */
3759:                )
3760:                {
3761:                	int n = 0;
3762:                	TCHAR c, *p = buff;
3763:                	PF_BYTE s[2];
3764:                	UINT rc;
3765:                
3766:                	while (n < len - 1) { /* Read bytes until buffer gets filled */
3767:                		f_read(fil, s, 1, &rc);
3768:                		if (rc != 1) break; /* Break on EOF or error */
3769:                		c = s[0];
3770:                #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
3771:                		if (c >= 0x80) {
3772:                			if (c < 0xC0) continue; /* Skip stray trailer */
3773:                			if (c < 0xE0) { /* Two-byte sequense */
3774:                				f_read(fil, s, 1, &rc);
3775:                				if (rc != 1) break;
3776:                				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
3777:                				if (c < 0x80) c = '?';
3778:                			} else {
3779:                				if (c < 0xF0) { /* Three-byte sequense */
3780:                					f_read(fil, s, 2, &rc);
3781:                					if (rc != 2) break;
3782:                					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
3783:                					if (c < 0x800) c = '?';
3784:                				} else { /* Reject four-byte sequense */
3785:                					c = '?';
3786:                				}
3787:                			}
3788:                		}
3789:                #endif
3790:                #if _USE_STRFUNC >= 2
3791:                		if (c == '\r') continue; /* Strip '\r' */
3792:                #endif
3793:                		*p++ = c;
3794:                		n++;
3795:                		if (c == '\n') break; /* Break on EOL */
3796:                	}
3797:                	*p = 0;
3798:                	return n ? buff : 0; /* When no data read (eof or error), return with error. */
3799:                }
3800:                
3801:                #if !_FS_READONLY
3802:                #include <stdarg.h>
3803:                /*-----------------------------------------------------------------------*/
3804:                /* Put a character to the file                                           */
3805:                /*-----------------------------------------------------------------------*/
3806:                int f_putc (
3807:                		TCHAR c, /* A character to be output */
3808:                		FIL* fil /* Pointer to the file object */
3809:                )
3810:                {
3811:                	UINT bw, btw;
3812:                	PF_BYTE s[3];
3813:                
3814:                #if _USE_STRFUNC >= 2
3815:                	if (c == '\n') f_putc ('\r', fil); /* LF -> CRLF conversion */
3816:                #endif
3817:                
3818:                #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
3819:                	if (c < 0x80) { /* 7-bit */
3820:                		s[0] = (PF_BYTE)c;
3821:                		btw = 1;
3822:                	} else {
3823:                		if (c < 0x800) { /* 11-bit */
3824:                			s[0] = (PF_BYTE)(0xC0 | (c >> 6));
3825:                			s[1] = (PF_BYTE)(0x80 | (c & 0x3F));
3826:                			btw = 2;
3827:                		} else { /* 16-bit */
3828:                			s[0] = (PF_BYTE)(0xE0 | (c >> 12));
3829:                			s[1] = (PF_BYTE)(0x80 | ((c >> 6) & 0x3F));
3830:                			s[2] = (PF_BYTE)(0x80 | (c & 0x3F));
3831:                			btw = 3;
3832:                		}
3833:                	}
3834:                #else				/* Write the character without conversion */
3835:                	s[0] = (PF_BYTE)c;
3836:                	btw = 1;
3837:                #endif
3838:                	f_write(fil, s, btw, &bw); /* Write the char to the file */
3839:                	return (bw == btw) ? 1 : EOF; /* Return the result */
3840:                }
3841:                
3842:                /*-----------------------------------------------------------------------*/
3843:                /* Put a string to the file                                              */
3844:                /*-----------------------------------------------------------------------*/
3845:                int f_puts (
3846:                		const TCHAR* str, /* Pointer to the string to be output */
3847:                		FIL* fil /* Pointer to the file object */
3848:                )
3849:                {
3850:                	int n;
3851:                
3852:                	for (n = 0; *str; str++, n++) {
3853:                		if (f_putc(*str, fil) == EOF) return EOF;
3854:                	}
3855:                	return n;
3856:                }
3857:                
3858:                /*-----------------------------------------------------------------------*/
3859:                /* Put a formatted string to the file                                    */
3860:                /*-----------------------------------------------------------------------*/
3861:                int f_printf (
3862:                		FIL* fil, /* Pointer to the file object */
3863:                		const TCHAR* str, /* Pointer to the format string */
3864:                		... /* Optional arguments... */
3865:                )
3866:                {
3867:                	va_list arp;
3868:                	PF_BYTE f, r;
3869:                	UINT i, j, w;
3870:                	ULONG v;
3871:                	TCHAR c, d, s[16], *p;
3872:                	int res, chc, cc;
3873:                
3874:                	va_start(arp, str);
3875:                
3876:                	for (cc = res = 0; cc != EOF; res += cc) {
3877:                		c = *str++;
3878:                		if (c == 0) break; /* End of string */
3879:                		if (c != '%') { /* Non escape character */
3880:                			cc = f_putc(c, fil);
3881:                			if (cc != EOF) cc = 1;
3882:                			continue;
3883:                		}
3884:                		w = f = 0;
3885:                		c = *str++;
3886:                		if (c == '0') { /* Flag: '0' padding */
3887:                			f = 1; c = *str++;
3888:                		} else {
3889:                			if (c == '-') { /* Flag: left justified */
3890:                				f = 2; c = *str++;
3891:                			}
3892:                		}
3893:                		while (IsDigit(c)) { /* Precision */
3894:                			w = w * 10 + c - '0';
3895:                			c = *str++;
3896:                		}
3897:                		if (c == 'l' || c == 'L') { /* Prefix: Size is long int */
3898:                			f |= 4; c = *str++;
3899:                		}
3900:                		if (!c) break;
3901:                		d = c;
3902:                		if (IsLower(d)) d -= 0x20;
3903:                		switch (d) { /* Type is... */
3904:                			case 'S' : /* String */
3905:                			p = va_arg(arp, TCHAR*);
3906:                			for (j = 0; p[j]; j++);
3907:                			chc = 0;
3908:                			if (!(f & 2)) {
3909:                				while (j++ < w) chc += (cc = f_putc(' ', fil));
3910:                			}
3911:                			chc += (cc = f_puts(p, fil));
3912:                			while (j++ < w) chc += (cc = f_putc(' ', fil));
3913:                			if (cc != EOF) cc = chc;
3914:                			continue;
3915:                			case 'C' : /* Character */
3916:                			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
3917:                			case 'B' : /* Binary */
3918:                			r = 2; break;
3919:                			case 'O' : /* Octal */
3920:                			r = 8; break;
3921:                			case 'D' : /* Signed decimal */
3922:                			case 'U' : /* Unsigned decimal */
3923:                			r = 10; break;
3924:                			case 'X' : /* Hexdecimal */
3925:                			r = 16; break;
3926:                			default: /* Unknown type (passthrough) */
3927:                			cc = f_putc(c, fil); continue;
3928:                		}
3929:                
3930:                		/* Get an argument and put it in numeral */
3931:                		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
3932:                		if (d == 'D' && (v & 0x80000000)) {
3933:                			v = 0 - v;
3934:                			f |= 8;
3935:                		}
3936:                		i = 0;
3937:                		do {
3938:                			d = (TCHAR)(v % r); v /= r;
3939:                			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
3940:                			s[i++] = d + '0';
3941:                		}while (v && i < sizeof(s) / sizeof(s[0]));
3942:                		if (f & 8) s[i++] = '-';
3943:                		j = i; d = (f & 1) ? '0' : ' ';
3944:                		res = 0;
3945:                		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
3946:                		do res += (cc = f_putc(s[--i], fil)); while(i);
3947:                		while (j++ < w) res += (cc = f_putc(' ', fil));
3948:                		if (cc != EOF) cc = res;
3949:                	}
3950:                
3951:                	va_end(arp);
3952:                	return (cc == EOF) ? cc : res;
3953:                }
3954:                
3955:                #endif /* !_FS_READONLY */
3956:                #endif /* _USE_STRFUNC */
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/diskio.c  -----------------------------
1:                   /*------------------------------------------------------------------------/
2:                    /  MMCv3/SDv1/SDv2 (in SPI mode) control module
3:                    /-------------------------------------------------------------------------/
4:                    /
5:                    /  Copyright (C) 2010, ChaN, all right reserved.
6:                    /
7:                    / * This software is a free software and there is NO WARRANTY.
8:                    / * No restriction on use. You can use, modify and redistribute it for
9:                    /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
10:                   / * Redistributions of source code must retain the above copyright notice.
11:                   /
12:                   /-------------------------------------------------------------------------*/
13:                  
14:                  // 07 May 2012 Changes made to allow SD card library to support
15:                  //					PIC32 Pinguino Micro and potentially other cards that
16:                  //					do not support the use of the RTCC library.
17:                  // 25 May 2012 Added includes for delay.c and digitalw.c
18:                  
19:                  //#include "ff.h"
20:                  #include "diskio.h"
21:                  //#include <delay.c>
22:                  //#include <digitalw.c>
23:                  #include "../HardwareProfile.h"
24:                  #include "sdmmc.h"
25:                  
26:                  // For boards known to support the RTCC library ***Added 07 May 2012
27:                  // to allow SD Library to support PIC32 Pinguino Micro, which
28:                  // which does not have a RTCC crystal and associated components,
29:                  // and would not operate if #include <rtcc.c> is included.
30:                  // See also changes to get_fattime() below.
31:                  
32:                  #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
33:                  	#include <rtcc.c>
34:                  #endif
35:                  
36:                  /* Definitions for MMC/SDC command */
37:                  #define CMD0   (0)			/* GO_IDLE_STATE */
38:                  #define CMD1   (1)			/* SEND_OP_COND */
39:                  #define ACMD41 (41|0x80)	/* SEND_OP_COND (SDC) */
40:                  #define CMD8   (8)			/* SEND_IF_COND */
41:                  #define CMD9   (9)			/* SEND_CSD */
42:                  #define CMD10  (10)			/* SEND_CID */
43:                  #define CMD12  (12)			/* STOP_TRANSMISSION */
44:                  #define ACMD13 (13|0x80)	/* SD_STATUS (SDC) */
45:                  #define CMD16  (16)			/* SET_BLOCKLEN */
46:                  #define CMD17  (17)			/* READ_SINGLE_BLOCK */
47:                  #define CMD18  (18)			/* READ_MULTIPLE_BLOCK */
48:                  #define CMD23  (23)			/* SET_BLOCK_COUNT */
49:                  #define ACMD23 (23|0x80)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
50:                  #define CMD24  (24)			/* WRITE_BLOCK */
51:                  #define CMD25  (25)			/* WRITE_MULTIPLE_BLOCK */
52:                  #define CMD41  (41)			/* SEND_OP_COND (ACMD) */
53:                  #define CMD55  (55)			/* APP_CMD */
54:                  #define CMD58  (58)			/* READ_OCR */
55:                  
56:                  /* Port Controls  (Platform dependent) */
57:                  //#define SOCKPORT	PORTB		/* Socket contact port */
58:                  //#define SOCKWP	(1<<10)		/* Write protect switch (RB10) */
59:                  //#define SOCKINS	(1<<11)		/* Card detect switch (RB11) */
60:                  
61:                  //#define	FCLK_SLOW()			/* Set slow clock (100k-400k) */
62:                  //#define	FCLK_FAST()			/* Set fast clock (depends on the CSD) */
63:                  
64:                  
65:                  /*--------------------------------------------------------------------------
66:                  
67:                   Module Private Functions
68:                  
69:                   ---------------------------------------------------------------------------*/
70:                  
71:                  static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
72:                  
73:                  static volatile UINT16 Timer1, Timer2; /* 1000Hz decrement timer */
74:                  
75:                  static UINT16 CardType;
76:                  
77:                  /*-----------------------------------------------------------------------*/
78:                  /* Exchange a byte between PIC and MMC via SPI  (Platform dependent)     */
79:                  /*-----------------------------------------------------------------------*/
80:                  
81:                  #define xmit_spi(dat) 	writeSPI(dat)
82:                  #define rcvr_spi()	writeSPI(0xFF)
83:                  #define rcvr_spi_m(p)	SPI2BUF = 0xFF; while (!SPI2STATbits.SPIRBF); *(p) = (PF_BYTE)SPI2BUF;
84:                  #define xchg_spi (dat)  writeSPI(dat)
85:                  #define DLY_US(i)	delay_us(i)
86:                  #define CS_H()		(PORTB|=SDCSEL)//digitalwrite(SDCS, HIGH)
87:                  #define CS_L()		(PORTB&=~SDCSEL)//digitalwrite(SDCS, LOW)
88:                  
89:                  /*-----------------------------------------------------------------------*/
90:                  /* Wait for card ready                                                   */
91:                  /*-----------------------------------------------------------------------*/
92:                  
93:                  static
94:                  int wait_ready(void) {
9D0088C8  27BDFFE0   ADDIU SP, SP, -32
9D0088CC  AFBF001C   SW RA, 28(SP)
9D0088D0  AFB10018   SW S1, 24(SP)
9D0088D4  AFB00014   SW S0, 20(SP)
9D0088D8  24111388   ADDIU S1, ZERO, 5000
95:                  	PF_BYTE d;
96:                  	UINT16 tmr;
97:                  
98:                  	for (tmr = 5000; tmr; tmr--) { /* Wait for ready in timeout of 500ms */
9D008904  1620FFF5   BNE S1, ZERO, 0x9D0088DC
9D008908  3A0200FF   XORI V0, S0, 255
99:                  		d = rcvr_spi();
9D0088DC  0F4030FC   JAL writeSPI
9D0088E0  240400FF   ADDIU A0, ZERO, 255
9D0088E4  00408021   ADDU S0, V0, ZERO
100:                 		if (d == 0xFF)
9D0088E8  240200FF   ADDIU V0, ZERO, 255
9D0088EC  12020007   BEQ S0, V0, 0x9D00890C
9D0088F0  3A0200FF   XORI V0, S0, 255
101:                 			break;
102:                 		DLY_US(100);
9D0088F4  0F40363C   JAL delay_us
9D0088F8  24040064   ADDIU A0, ZERO, 100
9D0088FC  2631FFFF   ADDIU S1, S1, -1
9D008900  3231FFFF   ANDI S1, S1, -1
103:                 	}
104:                 
105:                 	return (d == 0xFF) ? 1 : 0;
106:                 }
9D00890C  2C420001   SLTIU V0, V0, 1
9D008910  8FBF001C   LW RA, 28(SP)
9D008914  8FB10018   LW S1, 24(SP)
9D008918  8FB00014   LW S0, 20(SP)
9D00891C  03E00008   JR RA
9D008920  27BD0020   ADDIU SP, SP, 32
107:                 
108:                 /*-----------------------------------------------------------------------*/
109:                 /* Deselect the card and release SPI bus                                 */
110:                 /*-----------------------------------------------------------------------*/
111:                 
112:                 #define deselect() disableSD();
113:                 
114:                 /*-----------------------------------------------------------------------*/
115:                 /* Select the card and wait ready                                        */
116:                 /*-----------------------------------------------------------------------*/
117:                 
118:                 static int select(void) /* 1:Successful, 0:Timeout */
119:                 {
9D008924  27BDFFE8   ADDIU SP, SP, -24
9D008928  AFBF0014   SW RA, 20(SP)
120:                 	enableSD();
9D00892C  0F403123   JAL enableSD
9D008930  00000000   NOP
121:                 	rcvr_spi(); /* Dummy clock (force DO enabled) */
9D008934  0F4030FC   JAL writeSPI
9D008938  240400FF   ADDIU A0, ZERO, 255
122:                 
123:                 	if (wait_ready())
9D00893C  0F402232   JAL 0x9D0088C8
9D008940  00000000   NOP
9D008944  14400004   BNE V0, ZERO, 0x9D008958
9D008948  24030001   ADDIU V1, ZERO, 1
124:                 		return 1; /* OK */
125:                 	deselect();
9D00894C  0F403118   JAL disableSD
9D008950  00000000   NOP
126:                 	return 0; /* Timeout */
9D008954  00001821   ADDU V1, ZERO, ZERO
127:                 }
9D008958  00601021   ADDU V0, V1, ZERO
9D00895C  8FBF0014   LW RA, 20(SP)
9D008960  03E00008   JR RA
9D008964  27BD0018   ADDIU SP, SP, 24
128:                 
129:                 /*-----------------------------------------------------------------------*/
130:                 /* Receive a data packet from MMC                                        */
131:                 /*-----------------------------------------------------------------------*/
132:                 
133:                 static int rcvr_datablock( /* 1:OK, 0:Failed */
9D008BEC  0B4022DC   J 0x9D008B70
9D008BF0  26310004   ADDIU S1, S1, 4
134:                                           PF_BYTE *buff, /* Data buffer to store received data */
135:                                           UINT16 btr /* Byte count (must be multiple of 4) */
136:                                           ) {
9D008B08  27BDFFE0   ADDIU SP, SP, -32
9D008B0C  AFBF001C   SW RA, 28(SP)
9D008B10  AFB20018   SW S2, 24(SP)
9D008B14  AFB10014   SW S1, 20(SP)
9D008B18  AFB00010   SW S0, 16(SP)
9D008B1C  00808821   ADDU S1, A0, ZERO
9D008B20  00A09021   ADDU S2, A1, ZERO
9D008B24  241003E8   ADDIU S0, ZERO, 1000
137:                 	PF_BYTE d;
138:                 	UINT16 tmr;
139:                 
140:                 	for (tmr = 1000; tmr; tmr--) { /* Wait for data packet in timeout of 100ms */
9D008B4C  1600FFF6   BNE S0, ZERO, 0x9D008B28
9D008B50  00001821   ADDU V1, ZERO, ZERO
141:                 		d = rcvr_spi();
9D008B28  0F4030FC   JAL writeSPI
9D008B2C  240400FF   ADDIU A0, ZERO, 255
142:                 		if (d != 0xFF)
9D008B30  240300FF   ADDIU V1, ZERO, 255
9D008B34  14430009   BNE V0, V1, 0x9D008B5C
9D008B38  240400FE   ADDIU A0, ZERO, 254
143:                 			break;
144:                 		DLY_US(100);
9D008B3C  0F40363C   JAL delay_us
9D008B40  24040064   ADDIU A0, ZERO, 100
9D008B44  2610FFFF   ADDIU S0, S0, -1
9D008B48  3210FFFF   ANDI S0, S0, -1
145:                 	}
146:                 	if (d != 0xFE)
9D008B5C  1444002A   BNE V0, A0, 0x9D008C08
9D008B60  00001821   ADDU V1, ZERO, ZERO
147:                 		return 0; /* If not valid data token, return with error */
148:                 
149:                 	do { /* Receive the data block into buffer */
150:                 		rcvr_spi_m(buff++);
9D008B64  3C04BF80   LUI A0, -16512
9D008B68  240500FF   ADDIU A1, ZERO, 255
9D008B6C  3C02BF80   LUI V0, -16512
9D008B70  AC855A20   SW A1, 23072(A0)
9D008B74  8C435A10   LW V1, 23056(V0)
9D008B78  30630001   ANDI V1, V1, 1
9D008B7C  1060FFFD   BEQ V1, ZERO, 0x9D008B74
9D008B80  00000000   NOP
9D008B84  8C835A20   LW V1, 23072(A0)
9D008B88  A2230000   SB V1, 0(S1)
151:                 		rcvr_spi_m(buff++);
9D008B8C  AC855A20   SW A1, 23072(A0)
9D008B90  8C435A10   LW V1, 23056(V0)
9D008B94  30630001   ANDI V1, V1, 1
9D008B98  1060FFFD   BEQ V1, ZERO, 0x9D008B90
9D008B9C  00000000   NOP
9D008BA0  8C835A20   LW V1, 23072(A0)
9D008BA4  A2230001   SB V1, 1(S1)
152:                 		rcvr_spi_m(buff++);
9D008BA8  AC855A20   SW A1, 23072(A0)
9D008BAC  8C435A10   LW V1, 23056(V0)
9D008BB0  30630001   ANDI V1, V1, 1
9D008BB4  1060FFFD   BEQ V1, ZERO, 0x9D008BAC
9D008BB8  00000000   NOP
9D008BBC  8C835A20   LW V1, 23072(A0)
9D008BC0  A2230002   SB V1, 2(S1)
153:                 		rcvr_spi_m(buff++);
9D008BC4  AC855A20   SW A1, 23072(A0)
9D008BC8  8C435A10   LW V1, 23056(V0)
9D008BCC  30630001   ANDI V1, V1, 1
9D008BD0  1060FFFD   BEQ V1, ZERO, 0x9D008BC8
9D008BD4  00000000   NOP
9D008BD8  8C835A20   LW V1, 23072(A0)
154:                 	} while (btr -= 4);
9D008BDC  2652FFFC   ADDIU S2, S2, -4
9D008BE0  3252FFFF   ANDI S2, S2, -1
9D008BE4  12400003   BEQ S2, ZERO, 0x9D008BF4
9D008BE8  A2230003   SB V1, 3(S1)
155:                 	rcvr_spi(); /* Discard CRC */
9D008BF4  0F4030FC   JAL writeSPI
9D008BF8  240400FF   ADDIU A0, ZERO, 255
156:                 	rcvr_spi();
9D008BFC  0F4030FC   JAL writeSPI
9D008C00  240400FF   ADDIU A0, ZERO, 255
157:                 
158:                 	return 1; /* Return with success */
9D008C04  24030001   ADDIU V1, ZERO, 1
159:                 }
9D008B54  0B402303   J 0x9D008C0C
9D008B58  00601021   ADDU V0, V1, ZERO
9D008C08  00601021   ADDU V0, V1, ZERO
9D008C0C  8FBF001C   LW RA, 28(SP)
9D008C10  8FB20018   LW S2, 24(SP)
9D008C14  8FB10014   LW S1, 20(SP)
9D008C18  8FB00010   LW S0, 16(SP)
9D008C1C  03E00008   JR RA
9D008C20  27BD0020   ADDIU SP, SP, 32
160:                 
161:                 /*-----------------------------------------------------------------------*/
162:                 /* Send a data packet to MMC                                             */
163:                 /*-----------------------------------------------------------------------*/
164:                 
165:                 #if _READONLY == 0
166:                 static int xmit_datablock( /* 1:OK, 0:Failed */
9D008AAC  26110200   ADDIU S1, S0, 512
9D008AE8  38630005   XORI V1, V1, 5
9D008AEC  2C630001   SLTIU V1, V1, 1
167:                                           const PF_BYTE *buff, /* 512 byte data block to be transmitted */
168:                                           PF_BYTE token /* Data token */
169:                                           ) {
9D008A74  27BDFFE0   ADDIU SP, SP, -32
9D008A78  AFBF001C   SW RA, 28(SP)
9D008A7C  AFB10018   SW S1, 24(SP)
9D008A80  AFB00014   SW S0, 20(SP)
9D008A84  00808021   ADDU S0, A0, ZERO
170:                 	PF_BYTE resp;
171:                 	UINT16 bc = BLK_SIZE;
172:                 
173:                 	if (!wait_ready())
9D008A88  0F402232   JAL 0x9D0088C8
9D008A8C  00A08821   ADDU S1, A1, ZERO
9D008A90  10400017   BEQ V0, ZERO, 0x9D008AF0
9D008A94  00001821   ADDU V1, ZERO, ZERO
174:                 		return 0;
175:                 
176:                 	xmit_spi(token); /* Xmit a token */
9D008A98  0F4030FC   JAL writeSPI
9D008A9C  02202021   ADDU A0, S1, ZERO
177:                 	if (token != 0xFD) { /* Not StopTran token */
9D008AA0  240200FD   ADDIU V0, ZERO, 253
9D008AA4  12220012   BEQ S1, V0, 0x9D008AF0
9D008AA8  24030001   ADDIU V1, ZERO, 1
178:                 		do { /* Xmit the 512 byte data block to the MMC */
179:                 			xmit_spi(*buff++);
9D008AB0  0F4030FC   JAL writeSPI
9D008AB4  92040000   LBU A0, 0(S0)
180:                 			xmit_spi(*buff++);
9D008AB8  92040001   LBU A0, 1(S0)
9D008ABC  0F4030FC   JAL writeSPI
9D008AC0  26100002   ADDIU S0, S0, 2
181:                 		} while (bc -= 2);
9D008AC4  1630FFFA   BNE S1, S0, 0x9D008AB0
9D008AC8  00000000   NOP
182:                 		xmit_spi(0xFF); /* CRC (Dummy) */
9D008ACC  0F4030FC   JAL writeSPI
9D008AD0  240400FF   ADDIU A0, ZERO, 255
183:                 		xmit_spi(0xFF);
9D008AD4  0F4030FC   JAL writeSPI
9D008AD8  240400FF   ADDIU A0, ZERO, 255
184:                 		resp = rcvr_spi(); /* Receive a data response */
9D008ADC  0F4030FC   JAL writeSPI
9D008AE0  240400FF   ADDIU A0, ZERO, 255
185:                 		if ((resp & 0x1F) != 0x05) /* If not accepted, return with error */
9D008AE4  3043001F   ANDI V1, V0, 31
186:                 			return 0;
187:                 	}
188:                 
189:                 	return 1;
190:                 }
9D008AF0  00601021   ADDU V0, V1, ZERO
9D008AF4  8FBF001C   LW RA, 28(SP)
9D008AF8  8FB10018   LW S1, 24(SP)
9D008AFC  8FB00014   LW S0, 20(SP)
9D008B00  03E00008   JR RA
9D008B04  27BD0020   ADDIU SP, SP, 32
191:                 #endif	/* _READONLY */
192:                 
193:                 /*-----------------------------------------------------------------------*/
194:                 /* Send a command packet to MMC                                          */
195:                 /*-----------------------------------------------------------------------*/
196:                 
197:                 static PF_BYTE send_cmd(PF_BYTE cmd, /* Command byte */
198:                                         DWORD arg /* Argument */
199:                                         ) {
9D008968  27BDFFE0   ADDIU SP, SP, -32
9D00896C  AFBF001C   SW RA, 28(SP)
9D008970  AFB10018   SW S1, 24(SP)
9D008974  AFB00014   SW S0, 20(SP)
9D008978  00A08821   ADDU S1, A1, ZERO
9D008A14  2410000A   ADDIU S0, ZERO, 10
9D008A5C  0B402286   J 0x9D008A18
9D008A60  2410000A   ADDIU S0, ZERO, 10
9D008A6C  0B402286   J 0x9D008A18
9D008A70  2410000A   ADDIU S0, ZERO, 10
200:                 	PF_BYTE n, res;
201:                 
202:                 	if (cmd & 0x80) { /* ACMD<n> is the command sequense of CMD55-CMD<n> */
9D00897C  7C041420   SEB V0, A0
9D008980  04410009   BGEZ V0, 0x9D0089A8
9D008984  00808021   ADDU S0, A0, ZERO
203:                 		cmd &= 0x7F;
9D0089A4  3210007F   ANDI S0, S0, 127
204:                 		res = send_cmd(CMD55, 0);
9D008988  24040037   ADDIU A0, ZERO, 55
9D00898C  0F40225A   JAL 0x9D008968
9D008990  00002821   ADDU A1, ZERO, ZERO
9D008994  00401821   ADDU V1, V0, ZERO
205:                 		if (res > 1)
9D008998  2C420002   SLTIU V0, V0, 2
9D00899C  10400028   BEQ V0, ZERO, 0x9D008A40
9D0089A0  00601021   ADDU V0, V1, ZERO
206:                 			return res;
207:                 	}
208:                 
209:                 	/* Select the card and wait for ready */
210:                 	deselect();
9D0089A8  0F403118   JAL disableSD
9D0089AC  00000000   NOP
211:                 	if (!select())
9D0089B0  0F402249   JAL 0x9D008924
9D0089B4  00000000   NOP
9D0089B8  10400020   BEQ V0, ZERO, 0x9D008A3C
9D0089BC  240300FF   ADDIU V1, ZERO, 255
212:                 		return 0xFF;
213:                 
214:                 	/* Send command packet */
215:                 	xmit_spi(0x40 | cmd); /* Start + Command index */
9D0089C0  0F4030FC   JAL writeSPI
9D0089C4  36040040   ORI A0, S0, 64
216:                 	xmit_spi((PF_BYTE)(arg >> 24)); /* Argument[31..24] */
9D0089C8  0F4030FC   JAL writeSPI
9D0089CC  00112602   SRL A0, S1, 24
217:                 	xmit_spi((PF_BYTE)(arg >> 16)); /* Argument[23..16] */
9D0089D0  0F4030FC   JAL writeSPI
9D0089D4  7E243C00   EXT A0, S1, 16, 8
218:                 	xmit_spi((PF_BYTE)(arg >> 8)); /* Argument[15..8] */
9D0089D8  0F4030FC   JAL writeSPI
9D0089DC  7E243A00   EXT A0, S1, 8, 8
219:                 	xmit_spi((PF_BYTE)arg); /* Argument[7..0] */
9D0089E0  0F4030FC   JAL writeSPI
9D0089E4  322400FF   ANDI A0, S1, 255
220:                 	n = 0x01; /* Dummy CRC + Stop */
221:                 	if (cmd == CMD0)
9D0089E8  1200001E   BEQ S0, ZERO, 0x9D008A64
9D0089EC  24020008   ADDIU V0, ZERO, 8
222:                 		n = 0x95; /* Valid CRC for CMD0(0) */
223:                 	if (cmd == CMD8)
9D0089F0  12020018   BEQ S0, V0, 0x9D008A54
9D0089F4  00000000   NOP
224:                 		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
225:                 	xmit_spi(n);
9D0089F8  0F4030FC   JAL writeSPI
9D0089FC  24040001   ADDIU A0, ZERO, 1
9D008A54  0F4030FC   JAL writeSPI
9D008A58  24040087   ADDIU A0, ZERO, 135
9D008A64  0F4030FC   JAL writeSPI
9D008A68  24040095   ADDIU A0, ZERO, 149
226:                 
227:                 	/* Receive command response */
228:                 	if (cmd == CMD12)
9D008A00  2402000C   ADDIU V0, ZERO, 12
9D008A04  16020004   BNE S0, V0, 0x9D008A18
9D008A08  2410000A   ADDIU S0, ZERO, 10
229:                 		rcvr_spi(); /* Skip a stuff byte when stop reading */
9D008A0C  0F4030FC   JAL writeSPI
9D008A10  240400FF   ADDIU A0, ZERO, 255
230:                 	n = 10; /* Wait for a valid response in timeout of 10 attempts */
231:                 	do
232:                 		res = rcvr_spi();
9D008A18  0F4030FC   JAL writeSPI
9D008A1C  240400FF   ADDIU A0, ZERO, 255
9D008A20  00401821   ADDU V1, V0, ZERO
233:                 	while ((res & 0x80) && --n);
9D008A24  7C021420   SEB V0, V0
9D008A28  04410004   BGEZ V0, 0x9D008A3C
9D008A2C  2610FFFF   ADDIU S0, S0, -1
9D008A30  321000FF   ANDI S0, S0, 255
9D008A34  1600FFF8   BNE S0, ZERO, 0x9D008A18
9D008A38  00000000   NOP
234:                 
235:                 	return res; /* Return with the response value */
236:                 }
9D008A3C  00601021   ADDU V0, V1, ZERO
9D008A40  8FBF001C   LW RA, 28(SP)
9D008A44  8FB10018   LW S1, 24(SP)
9D008A48  8FB00014   LW S0, 20(SP)
9D008A4C  03E00008   JR RA
9D008A50  27BD0020   ADDIU SP, SP, 32
237:                 
238:                 /*--------------------------------------------------------------------------
239:                 
240:                  Public Functions
241:                 
242:                  ---------------------------------------------------------------------------*/
243:                 
244:                 /*-----------------------------------------------------------------------*/
245:                 /* Initialize Disk Drive                                                 */
246:                 /*-----------------------------------------------------------------------*/
247:                 
248:                 DSTATUS disk_initialize(PF_BYTE drv /* Physical drive number (0) */
9D008CD4  27B10014   ADDIU S1, SP, 20
9D008D70  27A40010   ADDIU A0, SP, 16
9D008D74  00901821   ADDU V1, A0, S0
249:                                         ) {
9D008C24  27BDFFD8   ADDIU SP, SP, -40
9D008C28  AFBF0024   SW RA, 36(SP)
9D008C2C  AFB10020   SW S1, 32(SP)
9D008C30  AFB0001C   SW S0, 28(SP)
9D008C34  308400FF   ANDI A0, A0, 255
250:                 	PF_BYTE n, ty, cmd, buf[4];
251:                 	UINT16 tmr;
252:                 	DSTATUS s = 0;
253:                 	if (drv)
9D008C38  14800084   BNE A0, ZERO, 0x9D008E4C
9D008C3C  24020001   ADDIU V0, ZERO, 1
254:                 		return STA_NOINIT; /* Supports only single drive */
255:                 	if (Stat & STA_NODISK)
9D008C40  93828044   LBU V0, -32700(GP)
9D008C44  30420002   ANDI V0, V0, 2
9D008C48  10400004   BEQ V0, ZERO, 0x9D008C5C
9D008C4C  00000000   NOP
256:                 		return Stat; /* No card in the socket */
9D008C50  93828044   LBU V0, -32700(GP)
9D008C54  0B402393   J 0x9D008E4C
9D008C58  304200FF   ANDI V0, V0, 255
257:                 
258:                 	deselect(); /* Force socket power on */
9D008C5C  0F403118   JAL disableSD
9D008C60  2410000A   ADDIU S0, ZERO, 10
259:                 	//FCLK_SLOW();
260:                 	for (n = 10; n; n--)
9D008C74  1600FFFB   BNE S0, ZERO, 0x9D008C64
9D008C78  3C02BF88   LUI V0, -16504
261:                 		rcvr_spi(); /* 80 dummy clocks */
9D008C64  0F4030FC   JAL writeSPI
9D008C68  240400FF   ADDIU A0, ZERO, 255
9D008C6C  2610FFFF   ADDIU S0, S0, -1
9D008C70  321000FF   ANDI S0, S0, 255
262:                 	CS_H();
9D008C7C  8C436120   LW V1, 24864(V0)
9D008C80  34630004   ORI V1, V1, 4
9D008C84  AC436120   SW V1, 24864(V0)
9D008C88  2410000A   ADDIU S0, ZERO, 10
263:                 	for (n = 10; n; n--)
9D008C9C  1600FFFB   BNE S0, ZERO, 0x9D008C8C
9D008CA0  00002021   ADDU A0, ZERO, ZERO
264:                 		rcvr_spi(); /* 80 dummy clocks */
9D008C8C  0F4030FC   JAL writeSPI
9D008C90  240400FF   ADDIU A0, ZERO, 255
9D008C94  2610FFFF   ADDIU S0, S0, -1
9D008C98  321000FF   ANDI S0, S0, 255
265:                 
266:                 	ty = 0;
267:                 	if (send_cmd(CMD0, 0) == 1) { /* Enter Idle state */
9D008CA4  0F40225A   JAL 0x9D008968
9D008CA8  00002821   ADDU A1, ZERO, ZERO
9D008CAC  24030001   ADDIU V1, ZERO, 1
9D008CB0  5443006B   BNEL V0, V1, 0x9D008E60
9D008CB4  A7808084   SH ZERO, -32636(GP)
268:                 		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2? */
9D008CB8  24040008   ADDIU A0, ZERO, 8
9D008CBC  0F40225A   JAL 0x9D008968
9D008CC0  240501AA   ADDIU A1, ZERO, 426
9D008CC4  24030001   ADDIU V1, ZERO, 1
9D008CC8  14430035   BNE V0, V1, 0x9D008DA0
9D008CCC  240400A9   ADDIU A0, ZERO, 169
9D008CD0  27B00010   ADDIU S0, SP, 16
269:                 			for (n = 0; n < 4; n++)
9D008CE8  1611FFFB   BNE S0, S1, 0x9D008CD8
9D008CEC  93A30012   LBU V1, 18(SP)
270:                 				buf[n] = rcvr_spi(); /* Get trailing return value of R7 resp */
9D008CD8  0F4030FC   JAL writeSPI
9D008CDC  240400FF   ADDIU A0, ZERO, 255
9D008CE0  A2020000   SB V0, 0(S0)
9D008CE4  26100001   ADDIU S0, S0, 1
271:                 			if (buf[2] == 0x01 && buf[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
9D008CF0  24020001   ADDIU V0, ZERO, 1
9D008CF4  54620050   BNEL V1, V0, 0x9D008E38
9D008CF8  A7808084   SH ZERO, -32636(GP)
9D008CFC  93A30013   LBU V1, 19(SP)
9D008D00  240200AA   ADDIU V0, ZERO, 170
9D008D04  54620056   BNEL V1, V0, 0x9D008E60
9D008D08  A7808084   SH ZERO, -32636(GP)
9D008D0C  241003E8   ADDIU S0, ZERO, 1000
272:                 				for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state (ACMD41 with HCS bit) */
9D008D2C  2610FFFF   ADDIU S0, S0, -1
9D008D30  3210FFFF   ANDI S0, S0, -1
9D008D34  1600FFF7   BNE S0, ZERO, 0x9D008D14
9D008D38  240400A9   ADDIU A0, ZERO, 169
273:                 					if (send_cmd(ACMD41, 1UL << 30) == 0)
9D008D10  240400A9   ADDIU A0, ZERO, 169
9D008D14  0F40225A   JAL 0x9D008968
9D008D18  3C054000   LUI A1, 16384
9D008D1C  10400009   BEQ V0, ZERO, 0x9D008D44
9D008D20  00000000   NOP
274:                 						break;
275:                 					DLY_US(1000);
9D008D24  0F40363C   JAL delay_us
9D008D28  240403E8   ADDIU A0, ZERO, 1000
276:                 				}
277:                 				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
9D008D44  52000046   BEQL S0, ZERO, 0x9D008E60
9D008D48  A7808084   SH ZERO, -32636(GP)
9D008D4C  2404003A   ADDIU A0, ZERO, 58
9D008D50  0F40225A   JAL 0x9D008968
9D008D54  00002821   ADDU A1, ZERO, ZERO
9D008D58  54400041   BNEL V0, ZERO, 0x9D008E60
9D008D5C  A7808084   SH ZERO, -32636(GP)
9D008D60  00008021   ADDU S0, ZERO, ZERO
278:                 					for (n = 0; n < 4; n++)
9D008D64  24110004   ADDIU S1, ZERO, 4
9D008D7C  1611FFFA   BNE S0, S1, 0x9D008D68
9D008D80  A0620000   SB V0, 0(V1)
279:                 						buf[n] = rcvr_spi();
9D008D68  0F4030FC   JAL writeSPI
9D008D6C  240400FF   ADDIU A0, ZERO, 255
9D008D78  26100001   ADDIU S0, S0, 1
280:                 					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 */
9D008D84  93A40010   LBU A0, 16(SP)
9D008D88  30840040   ANDI A0, A0, 64
9D008D8C  24030004   ADDIU V1, ZERO, 4
9D008D90  2402000C   ADDIU V0, ZERO, 12
9D008D94  0064100A   MOVZ V0, V1, A0
281:                 				}
282:                 			}
283:                 		} else { /* SDv1 or MMCv3 */
284:                 			if (send_cmd(ACMD41, 0) <= 1) {
9D008DA0  0F40225A   JAL 0x9D008968
9D008DA4  00002821   ADDU A1, ZERO, ZERO
9D008DA8  2C420002   SLTIU V0, V0, 2
285:                 				ty = CT_SD1;
9D008DAC  24030002   ADDIU V1, ZERO, 2
9D008DB0  24040001   ADDIU A0, ZERO, 1
9D008DB4  00608821   ADDU S1, V1, ZERO
9D008DB8  0082880A   MOVZ S1, A0, V0
286:                 				cmd = ACMD41; /* SDv1 */
287:                 			} else {
288:                 				ty = CT_MMC;
289:                 				cmd = CMD1; /* MMCv3 */
290:                 			}
291:                 			for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state */
9D008DBC  241003E8   ADDIU S0, ZERO, 1000
9D008DDC  2610FFFF   ADDIU S0, S0, -1
9D008DE0  3210FFFF   ANDI S0, S0, -1
9D008DE4  1600FFF7   BNE S0, ZERO, 0x9D008DC4
9D008DE8  240400A9   ADDIU A0, ZERO, 169
292:                 				if (send_cmd(ACMD41, 0) == 0)
9D008DC0  240400A9   ADDIU A0, ZERO, 169
9D008DC4  0F40225A   JAL 0x9D008968
9D008DC8  00002821   ADDU A1, ZERO, ZERO
9D008DCC  10400009   BEQ V0, ZERO, 0x9D008DF4
9D008DD0  00000000   NOP
293:                 					break;
294:                 				DLY_US(1000);
9D008DD4  0F40363C   JAL delay_us
9D008DD8  240403E8   ADDIU A0, ZERO, 1000
295:                 			}
296:                 			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
9D008DF4  5200001A   BEQL S0, ZERO, 0x9D008E60
9D008DF8  A7808084   SH ZERO, -32636(GP)
9D008DFC  24040010   ADDIU A0, ZERO, 16
9D008E00  0F40225A   JAL 0x9D008968
9D008E04  24050200   ADDIU A1, ZERO, 512
9D008E08  54400015   BNEL V0, ZERO, 0x9D008E60
9D008E0C  A7808084   SH ZERO, -32636(GP)
297:                 				ty = 0;
298:                 		}
299:                 	}
300:                 	CardType = ty;
9D008D3C  0B402398   J 0x9D008E60
9D008D40  A7808084   SH ZERO, -32636(GP)
9D008D98  0B402387   J 0x9D008E1C
9D008D9C  A7828084   SH V0, -32636(GP)
9D008DEC  0B402398   J 0x9D008E60
9D008DF0  A7808084   SH ZERO, -32636(GP)
9D008E10  A7918084   SH S1, -32636(GP)
301:                 	if (ty) {/* Initialization succeded */
9D008E14  12200008   BEQ S1, ZERO, 0x9D008E38
9D008E18  24020001   ADDIU V0, ZERO, 1
302:                 		s &= ~STA_NOINIT;
9D008E34  00001021   ADDU V0, ZERO, ZERO
303:                 		// 6. increase speed
304:                 		SPI2CON = 0; // disable the SPI2 module
9D008E1C  3C02BF80   LUI V0, -16512
9D008E20  AC405A00   SW ZERO, 23040(V0)
305:                 		SPI2BRG = 0; // maximum possible baud rate = Fpb/2
9D008E24  3C03BF80   LUI V1, -16512
9D008E28  AC605A30   SW ZERO, 23088(V1)
306:                 		SPI2CON = 0x8120; // re-enable the SPI2 module
9D008E2C  34038120   ORI V1, ZERO, -32480
9D008E30  AC435A00   SW V1, 23040(V0)
307:                 	} else {
308:                 		/* Initialization failed */
309:                 		s |= STA_NOINIT;
9D008E60  0B40238E   J 0x9D008E38
9D008E64  24020001   ADDIU V0, ZERO, 1
310:                 	}
311:                 	Stat = s;
9D008E38  A3828044   SB V0, -32700(GP)
312:                 
313:                 	deselect();
9D008E3C  0F403118   JAL disableSD
9D008E40  00000000   NOP
314:                 
315:                 	return Stat;
9D008E44  93828044   LBU V0, -32700(GP)
9D008E48  304200FF   ANDI V0, V0, 255
316:                 }
9D008E4C  8FBF0024   LW RA, 36(SP)
9D008E50  8FB10020   LW S1, 32(SP)
9D008E54  8FB0001C   LW S0, 28(SP)
9D008E58  03E00008   JR RA
9D008E5C  27BD0028   ADDIU SP, SP, 40
317:                 
318:                 /*-----------------------------------------------------------------------*/
319:                 /* Get Disk Status                                                       */
320:                 /*-----------------------------------------------------------------------*/
321:                 
322:                 DSTATUS disk_status(PF_BYTE drv /* Physical drive number (0) */
323:                 ) {
9D008E68  308400FF   ANDI A0, A0, 255
324:                 	if (drv)
9D008E6C  14800003   BNE A0, ZERO, 0x9D008E7C
9D008E70  24020001   ADDIU V0, ZERO, 1
325:                 		return STA_NOINIT; /* Supports only single drive */
326:                 	return Stat;
9D008E74  93828044   LBU V0, -32700(GP)
9D008E78  304200FF   ANDI V0, V0, 255
327:                 }
9D008E7C  03E00008   JR RA
9D008E80  00000000   NOP
328:                 
329:                 /*-----------------------------------------------------------------------*/
330:                 /* Read Sector(s)                                                        */
331:                 /*-----------------------------------------------------------------------*/
332:                 
333:                 DRESULT disk_read(PF_BYTE drv, /* Physical drive nmuber (0) */
334:                                   PF_BYTE *buff, /* Pointer to the data buffer to store read data */
335:                                   DWORD sector, /* Start sector number (LBA) */
336:                                   PF_BYTE count /* Sector count (1..255) */
337:                                   ) {
9D008E84  27BDFFE0   ADDIU SP, SP, -32
9D008E88  AFBF001C   SW RA, 28(SP)
9D008E8C  AFB10018   SW S1, 24(SP)
9D008E90  AFB00014   SW S0, 20(SP)
9D008E94  00A08821   ADDU S1, A1, ZERO
9D008E98  308400FF   ANDI A0, A0, 255
9D008E9C  30F000FF   ANDI S0, A3, 255
338:                 	if (drv || !count)
9D008EA0  14800029   BNE A0, ZERO, 0x9D008F48
9D008EA4  24020004   ADDIU V0, ZERO, 4
9D008EA8  52000028   BEQL S0, ZERO, 0x9D008F4C
9D008EAC  8FBF001C   LW RA, 28(SP)
339:                 		return RES_PARERR;
340:                 	if (Stat & STA_NOINIT)
9D008EB0  93838044   LBU V1, -32700(GP)
9D008EB4  30630001   ANDI V1, V1, 1
9D008EB8  14600023   BNE V1, ZERO, 0x9D008F48
9D008EBC  24020003   ADDIU V0, ZERO, 3
341:                 		return RES_NOTRDY;
342:                 
343:                 	if (!(CardType & CT_BLOCK))
9D008EC0  97838084   LHU V1, -32636(GP)
9D008EC4  30630008   ANDI V1, V1, 8
344:                 		sector *= BLK_SIZE; /* Convert to byte address if needed */
9D008EC8  00061240   SLL V0, A2, 9
9D008ECC  0043300A   MOVZ A2, V0, V1
345:                 
346:                 	if (count == 1) { /* Single block read */
9D008ED0  24020001   ADDIU V0, ZERO, 1
9D008ED4  1602000A   BNE S0, V0, 0x9D008F00
9D008ED8  24040012   ADDIU A0, ZERO, 18
347:                 		if ((send_cmd(CMD17, sector) == 0) /* READ_SINGLE_BLOCK */
9D008EDC  24040011   ADDIU A0, ZERO, 17
9D008EE0  0F40225A   JAL 0x9D008968
9D008EE4  00C02821   ADDU A1, A2, ZERO
9D008EE8  14400014   BNE V0, ZERO, 0x9D008F3C
9D008EEC  02202021   ADDU A0, S1, ZERO
348:                 		&& rcvr_datablock(buff, BLK_SIZE))
9D008EF0  0F4022C2   JAL 0x9D008B08
9D008EF4  24050200   ADDIU A1, ZERO, 512
349:                 			count = 0;
9D008EF8  0B4023CF   J 0x9D008F3C
9D008EFC  0002800B   MOVN S0, ZERO, V0
350:                 	} else { /* Multiple block read */
351:                 		if (send_cmd(CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
9D008F00  0F40225A   JAL 0x9D008968
9D008F04  00C02821   ADDU A1, A2, ZERO
9D008F08  1440000C   BNE V0, ZERO, 0x9D008F3C
9D008F0C  00000000   NOP
352:                 			do {
353:                 				if (!rcvr_datablock(buff, BLK_SIZE))
9D008F10  02202021   ADDU A0, S1, ZERO
9D008F14  0F4022C2   JAL 0x9D008B08
9D008F18  24050200   ADDIU A1, ZERO, 512
9D008F1C  10400005   BEQ V0, ZERO, 0x9D008F34
9D008F20  2404000C   ADDIU A0, ZERO, 12
354:                 					break;
355:                 				buff += BLK_SIZE;
356:                 			} while (--count);
9D008F24  2610FFFF   ADDIU S0, S0, -1
9D008F28  321000FF   ANDI S0, S0, 255
9D008F2C  1600FFF8   BNE S0, ZERO, 0x9D008F10
9D008F30  26310200   ADDIU S1, S1, 512
357:                 			send_cmd(CMD12, 0); /* STOP_TRANSMISSION */
9D008F34  0F40225A   JAL 0x9D008968
9D008F38  00002821   ADDU A1, ZERO, ZERO
358:                 		}
359:                 	}
360:                 	deselect();
9D008F3C  0F403118   JAL disableSD
9D008F40  00000000   NOP
361:                 
362:                 	return count ? RES_ERROR : RES_OK;
9D008F44  0010102B   SLTU V0, ZERO, S0
363:                 }
9D008F48  8FBF001C   LW RA, 28(SP)
9D008F4C  8FB10018   LW S1, 24(SP)
9D008F50  8FB00014   LW S0, 20(SP)
9D008F54  03E00008   JR RA
9D008F58  27BD0020   ADDIU SP, SP, 32
364:                 
365:                 /*-----------------------------------------------------------------------*/
366:                 /* Write Sector(s)                                                       */
367:                 /*-----------------------------------------------------------------------*/
368:                 
369:                 #if _READONLY == 0
370:                 DRESULT disk_write(PF_BYTE drv, /* Physical drive number (0) */
371:                                    const PF_BYTE *buff, /* Pointer to the data to be written */
372:                                    DWORD sector, /* Start sector number (LBA) */
373:                                    PF_BYTE count /* Sector count (1..255) */
374:                                    ) {
9D008F5C  27BDFFE0   ADDIU SP, SP, -32
9D008F60  AFBF001C   SW RA, 28(SP)
9D008F64  AFB20018   SW S2, 24(SP)
9D008F68  AFB10014   SW S1, 20(SP)
9D008F6C  AFB00010   SW S0, 16(SP)
9D008F70  00A08821   ADDU S1, A1, ZERO
9D008F74  00C08021   ADDU S0, A2, ZERO
9D008F78  308400FF   ANDI A0, A0, 255
9D008F7C  30F200FF   ANDI S2, A3, 255
375:                 	if (drv || !count)
9D008F80  14800035   BNE A0, ZERO, 0x9D009058
9D008F84  24020004   ADDIU V0, ZERO, 4
9D008F88  52400034   BEQL S2, ZERO, 0x9D00905C
9D008F8C  8FBF001C   LW RA, 28(SP)
376:                 		return RES_PARERR;
377:                 	if (Stat & STA_NOINIT)
9D008F90  93838044   LBU V1, -32700(GP)
9D008F94  30630001   ANDI V1, V1, 1
9D008F98  1460002F   BNE V1, ZERO, 0x9D009058
9D008F9C  24020003   ADDIU V0, ZERO, 3
378:                 		return RES_NOTRDY;
379:                 	if (Stat & STA_PROTECT)
9D008FA0  93838044   LBU V1, -32700(GP)
9D008FA4  30630004   ANDI V1, V1, 4
9D008FA8  1460002B   BNE V1, ZERO, 0x9D009058
9D008FAC  24020002   ADDIU V0, ZERO, 2
380:                 		return RES_WRPRT;
381:                 
382:                 	if (!(CardType & CT_BLOCK))
9D008FB0  97828084   LHU V0, -32636(GP)
9D008FB4  30440008   ANDI A0, V0, 8
383:                 		sector *= 512; /* Convert to byte address if needed */
9D008FB8  00061A40   SLL V1, A2, 9
9D008FBC  0064800A   MOVZ S0, V1, A0
384:                 
385:                 	if (count == 1) { /* Single block write */
9D008FC0  24030001   ADDIU V1, ZERO, 1
9D008FC4  1643000A   BNE S2, V1, 0x9D008FF0
9D008FC8  30420006   ANDI V0, V0, 6
386:                 		if ((send_cmd(CMD24, sector) == 0) /* WRITE_BLOCK */
9D008FCC  24040018   ADDIU A0, ZERO, 24
9D008FD0  0F40225A   JAL 0x9D008968
9D008FD4  02002821   ADDU A1, S0, ZERO
9D008FD8  1440001C   BNE V0, ZERO, 0x9D00904C
9D008FDC  02202021   ADDU A0, S1, ZERO
387:                 		&& xmit_datablock(buff, 0xFE))
9D008FE0  0F40229D   JAL 0x9D008A74
9D008FE4  240500FE   ADDIU A1, ZERO, 254
388:                 			count = 0;
9D008FE8  0B402413   J 0x9D00904C
9D008FEC  0002900B   MOVN S2, ZERO, V0
389:                 	} else { /* Multiple block write */
390:                 		if (CardType & CT_SDC)
9D008FF0  10400005   BEQ V0, ZERO, 0x9D009008
9D008FF4  24040019   ADDIU A0, ZERO, 25
391:                 			send_cmd(ACMD23, count);
9D008FF8  24040097   ADDIU A0, ZERO, 151
9D008FFC  0F40225A   JAL 0x9D008968
9D009000  02402821   ADDU A1, S2, ZERO
392:                 		if (send_cmd(CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
9D009004  24040019   ADDIU A0, ZERO, 25
9D009008  0F40225A   JAL 0x9D008968
9D00900C  02002821   ADDU A1, S0, ZERO
9D009010  1440000E   BNE V0, ZERO, 0x9D00904C
9D009014  00000000   NOP
393:                 			do {
394:                 				if (!xmit_datablock(buff, 0xFC))
9D009018  02202021   ADDU A0, S1, ZERO
9D00901C  0F40229D   JAL 0x9D008A74
9D009020  240500FC   ADDIU A1, ZERO, 252
9D009024  10400005   BEQ V0, ZERO, 0x9D00903C
9D009028  00002021   ADDU A0, ZERO, ZERO
395:                 					break;
396:                 				buff += 512;
397:                 			} while (--count);
9D00902C  2652FFFF   ADDIU S2, S2, -1
9D009030  325200FF   ANDI S2, S2, 255
9D009034  1640FFF8   BNE S2, ZERO, 0x9D009018
9D009038  26310200   ADDIU S1, S1, 512
398:                 			if (!xmit_datablock(0, 0xFD)) /* STOP_TRAN token */
9D00903C  0F40229D   JAL 0x9D008A74
9D009040  240500FD   ADDIU A1, ZERO, 253
399:                 				count = 1;
9D009044  24030001   ADDIU V1, ZERO, 1
9D009048  0062900A   MOVZ S2, V1, V0
400:                 		}
401:                 	}
402:                 	deselect();
9D00904C  0F403118   JAL disableSD
9D009050  00000000   NOP
403:                 
404:                 	return count ? RES_ERROR : RES_OK;
9D009054  0012102B   SLTU V0, ZERO, S2
405:                 }
9D009058  8FBF001C   LW RA, 28(SP)
9D00905C  8FB20018   LW S2, 24(SP)
9D009060  8FB10014   LW S1, 20(SP)
9D009064  8FB00010   LW S0, 16(SP)
9D009068  03E00008   JR RA
9D00906C  27BD0020   ADDIU SP, SP, 32
406:                 #endif /* _READONLY */
407:                 
408:                 /*-----------------------------------------------------------------------*/
409:                 /* Miscellaneous Functions                                               */
410:                 /*-----------------------------------------------------------------------*/
411:                 
412:                 DRESULT disk_ioctl(PF_BYTE drv, /* Physical drive number (0) */
9D009374  26300004   ADDIU S0, S1, 4
413:                                    PF_BYTE ctrl, /* Control code */
414:                                    void *buff /* Buffer to send/receive data block */
415:                                    ) {
9D009070  27BDFFD0   ADDIU SP, SP, -48
9D009074  AFBF002C   SW RA, 44(SP)
9D009078  AFB20028   SW S2, 40(SP)
9D00907C  AFB10024   SW S1, 36(SP)
9D009080  AFB00020   SW S0, 32(SP)
9D009084  00C08821   ADDU S1, A2, ZERO
9D009088  308400FF   ANDI A0, A0, 255
9D00908C  30A500FF   ANDI A1, A1, 255
416:                 	DRESULT res;
417:                 	PF_BYTE n, csd[16], *ptr = buff;
418:                 	DWORD csize;
419:                 
420:                 	if (drv)
9D009090  148000D0   BNE A0, ZERO, 0x9D0093D4
9D009094  24100004   ADDIU S0, ZERO, 4
421:                 		return RES_PARERR;
422:                 	if (Stat & STA_NOINIT)
9D009098  93828044   LBU V0, -32700(GP)
9D00909C  30420001   ANDI V0, V0, 1
9D0090A0  144000CC   BNE V0, ZERO, 0x9D0093D4
9D0090A4  24100003   ADDIU S0, ZERO, 3
423:                 		return RES_NOTRDY;
424:                 
425:                 	res = RES_ERROR;
9D00932C  0B4024F3   J 0x9D0093CC
9D009330  2C500001   SLTIU S0, V0, 1
9D009354  0B4024F3   J 0x9D0093CC
9D009358  2C500001   SLTIU S0, V0, 1
9D0093C0  0B4024F3   J 0x9D0093CC
9D0093C4  2C500001   SLTIU S0, V0, 1
426:                 	switch (ctrl) {
9D0090A8  2CA2000F   SLTIU V0, A1, 15
9D0090AC  504000C7   BEQL V0, ZERO, 0x9D0093CC
9D0090B0  24100004   ADDIU S0, ZERO, 4
9D0090B4  00052880   SLL A1, A1, 2
9D0090B8  3C029D01   LUI V0, -25343
9D0090BC  244290D0   ADDIU V0, V0, -28464
9D0090C0  00452821   ADDU A1, V0, A1
9D0090C4  8CA20000   LW V0, 0(A1)
9D0090C8  00400008   JR V0
9D0090CC  00000000   NOP
427:                 	case CTRL_SYNC: /* Flush dirty buffer if present */
428:                 		if (select()) {
9D00910C  0F402249   JAL 0x9D008924
9D009110  24100001   ADDIU S0, ZERO, 1
9D009114  104000AD   BEQ V0, ZERO, 0x9D0093CC
9D009118  00000000   NOP
429:                 			deselect();
9D00911C  0F403118   JAL disableSD
9D009120  00008021   ADDU S0, ZERO, ZERO
9D009124  0B4024F3   J 0x9D0093CC
9D009128  00000000   NOP
430:                 			res = RES_OK;
431:                 		}
432:                 		break;
433:                 
434:                 	case GET_SECTOR_COUNT: /* Get number of sectors on the disk (WORD) */
435:                 		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
9D00912C  24040009   ADDIU A0, ZERO, 9
9D009130  0F40225A   JAL 0x9D008968
9D009134  00002821   ADDU A1, ZERO, ZERO
9D009138  144000A4   BNE V0, ZERO, 0x9D0093CC
9D00913C  24100001   ADDIU S0, ZERO, 1
9D009140  27A40010   ADDIU A0, SP, 16
9D009144  0F4022C2   JAL 0x9D008B08
9D009148  24050010   ADDIU A1, ZERO, 16
9D00914C  1040009F   BEQ V0, ZERO, 0x9D0093CC
9D009150  93A30010   LBU V1, 16(SP)
436:                 			if ((csd[0] >> 6) == 1) { /* SDv2? */
9D009154  00031982   SRL V1, V1, 6
9D009158  24020001   ADDIU V0, ZERO, 1
9D00915C  1462000A   BNE V1, V0, 0x9D009188
9D009160  93A30018   LBU V1, 24(SP)
437:                 				csize = csd[9] + ((WORD) csd[8] << 8) + 1;
9D009164  93A30019   LBU V1, 25(SP)
9D009168  24630001   ADDIU V1, V1, 1
9D00916C  93A20018   LBU V0, 24(SP)
9D009170  00021200   SLL V0, V0, 8
9D009174  00621021   ADDU V0, V1, V0
438:                 				*(DWORD*) buff = (DWORD) csize << 10;
9D009178  00021280   SLL V0, V0, 10
9D00917C  AE220000   SW V0, 0(S1)
439:                 			} else { /* SDv1 or MMCv2 */
440:                 				n = (csd[5] & 15) + ((csd[10] & 128) >> 7)
9D0091AC  93A40015   LBU A0, 21(SP)
9D0091B0  3084000F   ANDI A0, A0, 15
9D0091B4  93A2001A   LBU V0, 26(SP)
9D0091B8  000211C2   SRL V0, V0, 7
9D0091BC  00822021   ADDU A0, A0, V0
9D0091C0  93A20019   LBU V0, 25(SP)
9D0091C4  30420003   ANDI V0, V0, 3
9D0091C8  00021040   SLL V0, V0, 1
441:                 						+ ((csd[9] & 3) << 1) + 2;
442:                 				csize = (csd[8] >> 6) + ((WORD) csd[7] << 2) + ((WORD) (csd[6]
9D009188  00031982   SRL V1, V1, 6
9D00918C  93A20017   LBU V0, 23(SP)
9D009190  00021080   SLL V0, V0, 2
9D009194  00621821   ADDU V1, V1, V0
9D009198  24630001   ADDIU V1, V1, 1
443:                 						& 3) << 10) + 1;
9D00919C  93A20016   LBU V0, 22(SP)
9D0091A0  30420003   ANDI V0, V0, 3
9D0091A4  00021280   SLL V0, V0, 10
9D0091A8  00621821   ADDU V1, V1, V0
444:                 				*(DWORD*) buff = (DWORD) csize << (n - 9);
9D0091CC  00821021   ADDU V0, A0, V0
9D0091D0  2442FFF9   ADDIU V0, V0, -7
9D0091D4  00431004   SLLV V0, V1, V0
9D0091D8  AE220000   SW V0, 0(S1)
445:                 			}
446:                 			res = RES_OK;
9D009180  0B4024F3   J 0x9D0093CC
9D009184  00008021   ADDU S0, ZERO, ZERO
9D0091DC  0B4024F3   J 0x9D0093CC
9D0091E0  00008021   ADDU S0, ZERO, ZERO
447:                 		}
448:                 		break;
449:                 
450:                 	case GET_SECTOR_SIZE: /* Get sectors on the disk (WORD) */
451:                 		*(WORD*) buff = 512;
9D0091E4  24020200   ADDIU V0, ZERO, 512
9D0091E8  A4C20000   SH V0, 0(A2)
452:                 		res = RES_OK;
453:                 		break;
9D0091EC  0B4024F3   J 0x9D0093CC
9D0091F0  00008021   ADDU S0, ZERO, ZERO
454:                 
455:                 	case GET_BLOCK_SIZE: /* Get erase block size in unit of sectors (DWORD) */
456:                 		if (CardType & CT_SD2) { /* SDv2? */
9D0091F4  97828084   LHU V0, -32636(GP)
9D0091F8  30420004   ANDI V0, V0, 4
9D0091FC  10400019   BEQ V0, ZERO, 0x9D009264
9D009200  24040009   ADDIU A0, ZERO, 9
457:                 			if (send_cmd(ACMD13, 0) == 0) { /* Read SD status */
9D009204  2404008D   ADDIU A0, ZERO, 141
9D009208  0F40225A   JAL 0x9D008968
9D00920C  00002821   ADDU A1, ZERO, ZERO
9D009210  1440006E   BNE V0, ZERO, 0x9D0093CC
9D009214  24100001   ADDIU S0, ZERO, 1
458:                 				rcvr_spi();
9D009218  0F4030FC   JAL writeSPI
9D00921C  240400FF   ADDIU A0, ZERO, 255
459:                 				if (rcvr_datablock(csd, 16)) { /* Read partial block */
9D009220  27A40010   ADDIU A0, SP, 16
9D009224  0F4022C2   JAL 0x9D008B08
9D009228  24050010   ADDIU A1, ZERO, 16
9D00922C  10400067   BEQ V0, ZERO, 0x9D0093CC
9D009230  00000000   NOP
9D009234  24100030   ADDIU S0, ZERO, 48
460:                 					for (n = 64 - 16; n; n--)
9D009240  2610FFFF   ADDIU S0, S0, -1
9D009244  321000FF   ANDI S0, S0, 255
9D009248  1600FFFB   BNE S0, ZERO, 0x9D009238
9D00924C  93A2001A   LBU V0, 26(SP)
461:                 						rcvr_spi(); /* Purge trailing data */
9D009238  0F4030FC   JAL writeSPI
9D00923C  240400FF   ADDIU A0, ZERO, 255
462:                 					*(DWORD*) buff = 16UL << (csd[10] >> 4);
9D009250  00021102   SRL V0, V0, 4
9D009254  24030010   ADDIU V1, ZERO, 16
9D009258  00431004   SLLV V0, V1, V0
9D00925C  0B4024F3   J 0x9D0093CC
9D009260  AE220000   SW V0, 0(S1)
463:                 					res = RES_OK;
464:                 				}
465:                 			}
466:                 		} else { /* SDv1 or MMCv3 */
467:                 			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) { /* Read CSD */
9D009264  0F40225A   JAL 0x9D008968
9D009268  00002821   ADDU A1, ZERO, ZERO
9D00926C  14400057   BNE V0, ZERO, 0x9D0093CC
9D009270  24100001   ADDIU S0, ZERO, 1
9D009274  27A40010   ADDIU A0, SP, 16
9D009278  0F4022C2   JAL 0x9D008B08
9D00927C  24050010   ADDIU A1, ZERO, 16
9D009280  10400052   BEQ V0, ZERO, 0x9D0093CC
9D009284  97828084   LHU V0, -32636(GP)
468:                 				if (CardType & CT_SD1) { /* SDv1 */
9D009288  30420002   ANDI V0, V0, 2
9D00928C  1040000F   BEQ V0, ZERO, 0x9D0092CC
9D009290  93A2001B   LBU V0, 27(SP)
469:                 					*(DWORD*) buff = (((csd[10] & 63) << 1) + ((WORD) (csd[11]
9D00929C  24630001   ADDIU V1, V1, 1
9D0092A0  93A2001A   LBU V0, 26(SP)
9D0092A4  3042003F   ANDI V0, V0, 63
9D0092A8  00021040   SLL V0, V0, 1
9D0092C0  AE220000   SW V0, 0(S1)
470:                 							& 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
9D009294  93A3001B   LBU V1, 27(SP)
9D009298  000319C2   SRL V1, V1, 7
9D0092AC  00621821   ADDU V1, V1, V0
9D0092B0  93A2001D   LBU V0, 29(SP)
9D0092B4  00021182   SRL V0, V0, 6
9D0092B8  2442FFFF   ADDIU V0, V0, -1
9D0092BC  00431004   SLLV V0, V1, V0
471:                 				} else { /* MMCv3 */
472:                 					*(DWORD*) buff = ((WORD) ((csd[10] & 124) >> 2) + 1)
9D0092CC  93A3001A   LBU V1, 26(SP)
9D0092D0  7C632080   EXT V1, V1, 2, 5
9D0092D4  24630001   ADDIU V1, V1, 1
9D0092F0  AE220000   SW V0, 0(S1)
473:                 							* (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5)
9D0092D8  00022142   SRL A0, V0, 5
9D0092DC  24840001   ADDIU A0, A0, 1
9D0092E0  30420003   ANDI V0, V0, 3
9D0092E4  000210C0   SLL V0, V0, 3
9D0092EC  70621002   MUL V0, V1, V0
474:                 									+ 1);
9D0092E8  00821021   ADDU V0, A0, V0
475:                 				}
476:                 				res = RES_OK;
9D0092C4  0B4024F3   J 0x9D0093CC
9D0092C8  00008021   ADDU S0, ZERO, ZERO
9D0092F4  0B4024F3   J 0x9D0093CC
9D0092F8  00008021   ADDU S0, ZERO, ZERO
477:                 			}
478:                 		}
479:                 		break;
480:                 
481:                 	case MMC_GET_TYPE: /* Get card type flags (1 byte) */
482:                 		*ptr = CardType;
9D0092FC  97828084   LHU V0, -32636(GP)
9D009300  A0C20000   SB V0, 0(A2)
483:                 		res = RES_OK;
484:                 		break;
9D009304  0B4024F3   J 0x9D0093CC
9D009308  00008021   ADDU S0, ZERO, ZERO
485:                 
486:                 	case MMC_GET_CSD: /* Receive CSD as a data block (16 bytes) */
487:                 		if ((send_cmd(CMD9, 0) == 0) /* READ_CSD */
9D00930C  24040009   ADDIU A0, ZERO, 9
9D009310  0F40225A   JAL 0x9D008968
9D009314  00002821   ADDU A1, ZERO, ZERO
9D009318  1440002C   BNE V0, ZERO, 0x9D0093CC
9D00931C  24100001   ADDIU S0, ZERO, 1
488:                 		&& rcvr_datablock(buff, 16))
9D009320  02202021   ADDU A0, S1, ZERO
9D009324  0F4022C2   JAL 0x9D008B08
9D009328  24050010   ADDIU A1, ZERO, 16
489:                 			res = RES_OK;
490:                 		break;
491:                 
492:                 	case MMC_GET_CID: /* Receive CID as a data block (16 bytes) */
493:                 		if ((send_cmd(CMD10, 0) == 0) /* READ_CID */
9D009334  2404000A   ADDIU A0, ZERO, 10
9D009338  0F40225A   JAL 0x9D008968
9D00933C  00002821   ADDU A1, ZERO, ZERO
9D009340  14400022   BNE V0, ZERO, 0x9D0093CC
9D009344  24100001   ADDIU S0, ZERO, 1
494:                 		&& rcvr_datablock(buff, 16))
9D009348  02202021   ADDU A0, S1, ZERO
9D00934C  0F4022C2   JAL 0x9D008B08
9D009350  24050010   ADDIU A1, ZERO, 16
495:                 			res = RES_OK;
496:                 		break;
497:                 
498:                 	case MMC_GET_OCR: /* Receive OCR as an R3 resp (4 bytes) */
499:                 		if (send_cmd(CMD58, 0) == 0) { /* READ_OCR */
9D00935C  2404003A   ADDIU A0, ZERO, 58
9D009360  0F40225A   JAL 0x9D008968
9D009364  00002821   ADDU A1, ZERO, ZERO
9D009368  14400018   BNE V0, ZERO, 0x9D0093CC
9D00936C  24100001   ADDIU S0, ZERO, 1
9D009370  02209021   ADDU S2, S1, ZERO
500:                 			for (n = 0; n < 4; n++)
9D009388  1650FFFB   BNE S2, S0, 0x9D009378
9D00938C  00000000   NOP
501:                 				*((PF_BYTE*) buff + n) = rcvr_spi();
9D009378  0F4030FC   JAL writeSPI
9D00937C  240400FF   ADDIU A0, ZERO, 255
9D009380  A2420000   SB V0, 0(S2)
9D009384  26520001   ADDIU S2, S2, 1
502:                 			res = RES_OK;
9D009390  0B4024F3   J 0x9D0093CC
9D009394  00008021   ADDU S0, ZERO, ZERO
503:                 		}
504:                 		break;
505:                 
506:                 	case MMC_GET_SDSTAT: /* Receive SD status as a data block (64 bytes) */
507:                 		if (send_cmd(ACMD13, 0) == 0) { /* SD_STATUS */
9D009398  2404008D   ADDIU A0, ZERO, 141
9D00939C  0F40225A   JAL 0x9D008968
9D0093A0  00002821   ADDU A1, ZERO, ZERO
9D0093A4  14400009   BNE V0, ZERO, 0x9D0093CC
9D0093A8  24100001   ADDIU S0, ZERO, 1
508:                 			rcvr_spi();
9D0093AC  0F4030FC   JAL writeSPI
9D0093B0  240400FF   ADDIU A0, ZERO, 255
509:                 			if (rcvr_datablock(buff, 64))
9D0093B4  02202021   ADDU A0, S1, ZERO
9D0093B8  0F4022C2   JAL 0x9D008B08
9D0093BC  24050040   ADDIU A1, ZERO, 64
510:                 				res = RES_OK;
511:                 		}
512:                 		break;
513:                 
514:                 	default:
515:                 		res = RES_PARERR;
9D0093C8  24100004   ADDIU S0, ZERO, 4
516:                 	}
517:                 
518:                 	deselect();
9D0093CC  0F403118   JAL disableSD
9D0093D0  00000000   NOP
519:                 
520:                 	return res;
521:                 }
9D0093D4  02001021   ADDU V0, S0, ZERO
9D0093D8  8FBF002C   LW RA, 44(SP)
9D0093DC  8FB20028   LW S2, 40(SP)
9D0093E0  8FB10024   LW S1, 36(SP)
9D0093E4  8FB00020   LW S0, 32(SP)
9D0093E8  03E00008   JR RA
9D0093EC  27BD0030   ADDIU SP, SP, 48
522:                 
523:                 /*-----------------------------------------------------------------------*/
524:                 /* Device Timer Interrupt Procedure  (Platform dependent)                */
525:                 /*-----------------------------------------------------------------------*/
526:                 /* This function must be called in period of 1ms                         */
527:                 /*
528:                 void disk_timerproc(void) {
529:                 	static WORD pv;
530:                 	WORD p;
531:                 	PF_BYTE s;
532:                 	UINT16 n;
533:                 
534:                 	n = Timer1; // 1000Hz decrement timer
535:                 	if (n)
536:                 		Timer1 = --n;
537:                 	n = Timer2;
538:                 	if (n)
539:                 		Timer2 = --n;
540:                 
541:                 	p = pv;
542:                 	pv = getCD() & getWP(); // Sample socket switch
543:                 
544:                 	if (p == pv) { // Have contacts stabled?
545:                 		s = Stat;
546:                 
547:                 		if (p & getWP()) // WP is H (write protected)
548:                 			s |= STA_PROTECT;
549:                 		else
550:                 			//* WP is L (write enabled)
551:                 			s &= ~STA_PROTECT;
552:                 
553:                 		if (p & getCD()) // INS = H (Socket empty)
554:                 			s |= (STA_NODISK | STA_NOINIT);
555:                 		else
556:                 			// INS = L (Card inserted)
557:                 			s &= ~STA_NODISK;
558:                 
559:                 		Stat = s;
560:                 	}
561:                 }
562:                 */
563:                 
564:                 /*---------------------------------------------------------*/
565:                 /* User Provided RTC Function for FatFs module             */
566:                 /*---------------------------------------------------------*/
567:                 /* This is a real time clock service to be called from     */
568:                 /* FatFs module. Any valid time must be returned even if   */
569:                 /* the system does not support an RTC.                     */
570:                 /* This function is not required in read-only cfg.         */
571:                 
572:                 /*	The current time is returned packed into a DWORD
573:                 	(32 bit) value. The bit fields are as follows:
574:                 		bits 31:25	Year from 1980 (0..127)
575:                 		bits 24:21	Month (1..12)
576:                 		bits 20:16	Day in month (1..31)
577:                 		bits 15:11	Hour (0..23)
578:                 		bits 10:05	Minute (0..59)
579:                 		bits 04:00	Second / 2 (0..29)						*/
580:                 
581:                 DWORD get_fattime(void) {
582:                 	DWORD tmr = 0;
583:                 
584:                 // Pre-processor commands added so only use RTCC if the board is known
585:                 // to support the RTCC ** Added 07 May 2012
586:                 
587:                 // For boards known to support the RTCC library
588:                 
589:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
590:                 	rtccTime pTm, cTm;
591:                 	rtccDate pDt, cDt;
592:                 
593:                 	RTCC_GetTimeDate(&pTm, &pDt);	// get time and date from RTC
594:                 											// assumes RTC has been set and is running
595:                 											// OK - could be expanded to check that RTC
596:                 											// is running and that a valid value is
597:                 											// being returned by the RTC
598:                 	cTm = RTCC_ConvertTime(&pTm);	// convert time from bcd to decimal format
599:                 	cDt = RTCC_ConvertDate(&pDt);	// convert date from bcd to decimal format
600:                 
601:                 	/* Pack date and time into a DWORD variable */
602:                 //	tmr = (((DWORD) pDt.year - 80)) | ((DWORD) pDt.mon) | ((DWORD) pDt.mday)
603:                 //			| (WORD) (pTm.hour) | (WORD) (pTm.min) | (WORD) (pTm.sec);
604:                 	tmr = cDt.year + 20;
605:                    
606:                   // Correction according to a newer rtcc library, with diff struct members.
607:                   
608:                 	 tmr = (tmr << 4) | cDt.month;		// shifts left 4 bits and adds monthth
609:                 	tmr = (tmr << 5) | cDt.dayofmonth;		// shifts left 5 bits and adds m.day
610:                 	tmr = (tmr << 5) | cTm.hours;		// shifts left 5 bits and adds hour
611:                 	tmr = (tmr << 6) | cTm.minutes;		// shift left 6 bits and adds minutes
612:                 	tmr = (tmr << 5) | (cTm.seconds/2);	// shifts left 5 bits and adds seconds/2
613:                 
614:                 //	For other boards use a fixed date and time of 01 Jan 2012 12:00:00
615:                 #else
616:                      tmr = 12 + 20;
617:                      tmr = (tmr << 4) | 1;       // shifts left 4 bits and adds month
618:                      tmr = (tmr << 5) | 1;    	// shifts left 5 bits and adds m.day
619:                      tmr = (tmr << 5) | 12;    	// shifts left 5 bits and adds hour
620:                      tmr = (tmr << 6) | 0;       // shift left 6 bits and adds minutes
621:                      tmr = (tmr << 5) | (0/2);   // shifts left 5 bits and adds seconds/2
622:                 #endif
623:                 
624:                 	return tmr;
625:                 }
9D0093F0  3C024021   LUI V0, 16417
9D0093F4  03E00008   JR RA
9D0093F8  24426000   ADDIU V0, V0, 24576
626:                 
627:                 void put_rc(FRESULT rc) {
628:                 	const char *str =
629:                                         "OK\0" "DISK_ERR\0" "INT_ERR\0" "NOT_READY\0" "NO_FILE\0" "NO_PATH\0"
630:                                                 "INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
631:                                                 "INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
632:                                                 "LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0";
633:                 	FRESULT i;
634:                 
635:                 	for (i = 0; i != rc && *str; i++) {
636:                 		while (*str++)
637:                 			;
638:                 	}
639:                 	//CDCprintln("rc=%u FR_%s", (UINT16) rc, str);
640:                         print("rc=");
641:                         print_int(rc,5);
642:                         cursor_right();
643:                         print(str);
644:                         put_char('\r');
645:                 }
646:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/HardwareProfile.c  -----------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   HardwareProfile.h
21:                   * Author: Jacques Deschênes
22:                   * Description: configuration hardware spécifique, assignation des périphériques
23:                   *     UART2 assigné à PB10,PB11
24:                   * Created on 17 avril 2013, 14:41
25:                   *
26:                   */
27:                  
28:                  #include "HardwareProfile.h"
29:                  #include <plib.h>
30:                  #include "../sound.h"
31:                  
32:                  volatile unsigned int  sys_tick; // compteur pour les milli-secondes
33:                  
34:                  
35:                  void HardwareInit(){
9D00D73C  27BDFFE8   ADDIU SP, SP, -24
9D00D740  AFBF0014   SW RA, 20(SP)
36:                     SYSTEMConfig(mGetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
37:                     INTEnableSystemMultiVectoredInt();
9D00D768  0F403F82   JAL INTEnableSystemMultiVectoredInt
9D00D76C  00000000   NOP
38:                     // activation du PROXIMITY TIMER pour les interruption inférieures à IPL=7
39:                  //   INTCONbits.TPC=0;
40:                  //   IPTMRCLR=0xFFFFFFFF;
41:                  //   INTCONbits.TPC=7;
42:                  //   IPTMR=CORE_TICK_RATE/2;
43:                      // configure coretimer pour le sys_tick
44:                  #ifdef USE_CORE_TIMER
45:                     OpenCoreTimer(CORE_TICK_RATE);
9D00D770  0F404097   JAL OpenCoreTimer
9D00D774  2404493E   ADDIU A0, ZERO, 18750
46:                     mConfigIntCoreTimer((CT_INT_ON | CT_INT_PRIOR_1 | CT_INT_SUB_PRIOR_0));
9D00D778  24020001   ADDIU V0, ZERO, 1
9D00D77C  3C03BF88   LUI V1, -16504
9D00D780  AC621034   SW V0, 4148(V1)
9D00D784  3C06BF88   LUI A2, -16504
9D00D788  2403001C   ADDIU V1, ZERO, 28
9D00D78C  ACC31094   SW V1, 4244(A2)
9D00D790  3C05BF88   LUI A1, -16504
9D00D794  24030004   ADDIU V1, ZERO, 4
9D00D798  ACA31098   SW V1, 4248(A1)
9D00D79C  24040003   ADDIU A0, ZERO, 3
9D00D7A0  ACC41094   SW A0, 4244(A2)
9D00D7A4  ACA01098   SW ZERO, 4248(A1)
9D00D7A8  3C05BF88   LUI A1, -16504
9D00D7AC  ACA21064   SW V0, 4196(A1)
9D00D7B0  3C05BF88   LUI A1, -16504
9D00D7B4  ACA21068   SW V0, 4200(A1)
47:                  #endif
48:                     // désactivation de toutes les entrée analogiques.
49:                     ANSELBCLR=0xFFFFFFFF;
9D00D7B8  3C05BF88   LUI A1, -16504
9D00D7BC  2406FFFF   ADDIU A2, ZERO, -1
9D00D7C0  ACA66104   SW A2, 24836(A1)
50:                     ANSELACLR=0xFFFFFFFF;
9D00D7C4  3C07BF88   LUI A3, -16504
9D00D7C8  ACE66004   SW A2, 24580(A3)
51:                      // configuration PB10 sortie et PB11 entrée
52:                     mPORTBSetBits(TX); // mettre à Vdd pour ne pas généré un faux start bit.
9D00D7CC  24060400   ADDIU A2, ZERO, 1024
9D00D7D0  3C07BF88   LUI A3, -16504
9D00D7D4  ACE66138   SW A2, 24888(A3)
53:                     mPORTBSetPinsDigitalOut(TX);      // sortie PB10(Tx), transmission UART2
9D00D7D8  3C07BF88   LUI A3, -16504
9D00D7DC  ACE66114   SW A2, 24852(A3)
9D00D7E0  ACA66104   SW A2, 24836(A1)
54:                     mPORTBSetPinsDigitalIn (RX);      // entrée PB11(Rx), réception UART2
9D00D7E4  24060800   ADDIU A2, ZERO, 2048
9D00D7E8  3C08BF88   LUI T0, -16504
9D00D7EC  AD066118   SW A2, 24856(T0)
9D00D7F0  ACA66104   SW A2, 24836(A1)
55:                     // assignation des périphériques aux broches
56:                     // l'information se trouve dans pps.h
57:                     PPSUnLock;                     // déverrouillage configuration assignation périphérique
58:                     //clavier
59:                     I2C1CONbits.DISSLW=1; // voir pic32mx1xxx/2xxx-errata.pdf rev. E, point 9
9D00D7F4  3C05BF80   LUI A1, -16512
9D00D7F8  8CA65000   LW A2, 20480(A1)
9D00D7FC  7C464A44   INS A2, V0, 9, 1
9D00D800  ACA65000   SW A2, 20480(A1)
60:                     RPA0R=0;  // pas de périphérique sur RA0 (keyboard clock)
9D00D804  3C02BF81   LUI V0, -16511
9D00D808  AC40FB00   SW ZERO, -1280(V0)
61:                     RPA1R=0;  // pas de périphérique sur RA1 (keyboard data)
9D00D80C  3C02BF81   LUI V0, -16511
9D00D810  AC40FB04   SW ZERO, -1276(V0)
62:                     RPB3R=0; //  pas de périphérique sur RB3 (status LED)
9D00D814  3C02BF81   LUI V0, -16511
9D00D818  AC40FB38   SW ZERO, -1224(V0)
63:                     RPB15R=0; // pad de périphérique sur RB15
9D00D81C  3C02BF81   LUI V0, -16511
9D00D820  AC40FB68   SW ZERO, -1176(V0)
64:                     TRISBCLR=STATUS_LED; // broche status LED en sortie
9D00D824  24020008   ADDIU V0, ZERO, 8
9D00D828  ACE26114   SW V0, 24852(A3)
65:                     _status_off();
9D00D82C  3C02BF88   LUI V0, -16504
9D00D830  8C466120   LW A2, 24864(V0)
9D00D834  2405FFF7   ADDIU A1, ZERO, -9
9D00D838  00C52824   AND A1, A2, A1
9D00D83C  AC456120   SW A1, 24864(V0)
66:                     PPSOutput(4, RPB10, U2TX);  // assignation U2TX sur PB10, (groupe, pin, fonction)
9D00D840  3C02BF81   LUI V0, -16511
9D00D844  8C46FB54   LW A2, -1196(V0)
9D00D848  24050002   ADDIU A1, ZERO, 2
9D00D84C  7CA61804   INS A2, A1, 0, 4
9D00D850  AC46FB54   SW A2, -1196(V0)
67:                     PPSInput (2, U2RX, RPB11);  // assignation U2RX sur PB11, (groupe, fonction, pin)
9D00D854  3C02BF81   LUI V0, -16511
9D00D858  8C46FA58   LW A2, -1448(V0)
9D00D85C  7C861804   INS A2, A0, 0, 4
9D00D860  AC46FA58   SW A2, -1448(V0)
68:                     PPSOutput(2,RPB5,OC2); // 5=OC2  sur PB5 sortie synchronistaiton ntsc
9D00D864  3C06BF81   LUI A2, -16511
9D00D868  8CC7FB40   LW A3, -1216(A2)
9D00D86C  24020005   ADDIU V0, ZERO, 5
9D00D870  7C471804   INS A3, V0, 0, 4
9D00D874  ACC7FB40   SW A3, -1216(A2)
69:                     PPSOutput(1,RPB4,OC1);  // 5=OC1 impulsion déclenchant SPI , Fsync vidéo
9D00D878  3C06BF81   LUI A2, -16511
9D00D87C  8CC7FB3C   LW A3, -1220(A2)
9D00D880  7C471804   INS A3, V0, 0, 4
9D00D884  ACC7FB3C   SW A3, -1220(A2)
70:                     PPSOutput(3,RPB6,SDO1); // 3=SDO1 sortie SPI1 (vidéo)
9D00D888  3C06BF81   LUI A2, -16511
9D00D88C  8CC7FB44   LW A3, -1212(A2)
9D00D890  7C871804   INS A3, A0, 0, 4
9D00D894  ACC7FB44   SW A3, -1212(A2)
71:                     PPSOutput(4,RPB9,OC3); // OC3 sortie audio.
9D00D898  3C04BF81   LUI A0, -16511
9D00D89C  8C86FB50   LW A2, -1200(A0)
9D00D8A0  7C461804   INS A2, V0, 0, 4
9D00D8A4  AC86FB50   SW A2, -1200(A0)
72:                     PPSInput(1,SS1,RPB7); // entrée Fsync sur RPB7
9D00D8A8  3C02BF81   LUI V0, -16511
9D00D8AC  8C44FA88   LW A0, -1400(V0)
9D00D8B0  7C641804   INS A0, V1, 0, 4
9D00D8B4  AC44FA88   SW A0, -1400(V0)
73:                     PPSInput(3,SDI2,RPA4); // entrée SDI pour carte SD
9D00D8B8  3C02BF81   LUI V0, -16511
9D00D8BC  8C44FA90   LW A0, -1392(V0)
9D00D8C0  7CA41804   INS A0, A1, 0, 4
9D00D8C4  AC44FA90   SW A0, -1392(V0)
74:                     PPSOutput(2,RPB8,SDO2); // sortie commande carte SD
9D00D8C8  3C02BF81   LUI V0, -16511
9D00D8CC  8C44FB4C   LW A0, -1204(V0)
9D00D8D0  7C641804   INS A0, V1, 0, 4
9D00D8D4  AC44FB4C   SW A0, -1204(V0)
75:                     PPSLock;                       // reverrouille pour éviter assignation accidentelle.
76:                  }
9D00D8D8  8FBF0014   LW RA, 20(SP)
9D00D8DC  03E00008   JR RA
9D00D8E0  27BD0018   ADDIU SP, SP, 24
77:                  
78:                  inline unsigned int ticks(void){
79:                      return sys_tick;
9D00D8E4  8F8280FC   LW V0, -32516(GP)
80:                  } //ticks()
9D00D8E8  03E00008   JR RA
9D00D8EC  00000000   NOP
81:                  
82:                  inline void delay_us(unsigned int usec){
83:                      for (usec=usec*(CLK_PER_USEC/3);usec;usec--);
9D00D8F0  2402000C   ADDIU V0, ZERO, 12
9D00D8F4  70821002   MUL V0, A0, V0
9D00D8F8  10400003   BEQ V0, ZERO, 0x9D00D908
9D00D8FC  2442FFFF   ADDIU V0, V0, -1
9D00D900  1440FFFF   BNE V0, ZERO, 0x9D00D900
9D00D904  2442FFFF   ADDIU V0, V0, -1
9D00D908  03E00008   JR RA
9D00D90C  00000000   NOP
84:                  }//delay_us()
85:                  
86:                  void delay_ms(unsigned int msec){
87:                  #ifdef USE_CORE_TIMER
88:                      unsigned int t0;
89:                      t0=sys_tick+msec;
9D00D910  8F8280FC   LW V0, -32516(GP)
9D00D914  00821021   ADDU V0, A0, V0
90:                      while (sys_tick!=t0);
9D00D918  8F8380FC   LW V1, -32516(GP)
9D00D91C  1462FFFE   BNE V1, V0, 0x9D00D918
9D00D920  00000000   NOP
91:                  #else
92:                      while (msec--)
93:                          delay_us(1000);
94:                  #endif
95:                  } // delay_ms()
9D00D924  03E00008   JR RA
9D00D928  00000000   NOP
96:                  
97:                  #ifdef USE_CORE_TIMER
98:                    //déclaration du gestionnaire d'interruption
99:                     void __ISR(_CORE_TIMER_VECTOR, IPL1SOFT)  CoreTimerHandler(void){
9D00D92C  415DE800   RDPGPR SP, SP
9D00D930  401A7000   MFC0 K0, EPC
9D00D934  401B6000   MFC0 K1, Status
9D00D938  27BDFFE8   ADDIU SP, SP, -24
9D00D93C  AFBA0014   SW K0, 20(SP)
9D00D940  401A6002   MFC0 K0, SRSCtl
9D00D944  AFBB0010   SW K1, 16(SP)
9D00D948  AFBA000C   SW K0, 12(SP)
9D00D94C  7C1B7844   INS K1, ZERO, 1, 15
9D00D950  377B0400   ORI K1, K1, 1024
9D00D954  409B6000   MTC0 K1, Status
9D00D958  AFA30004   SW V1, 4(SP)
9D00D95C  AFA20000   SW V0, 0(SP)
100:                        sys_tick++;
9D00D960  8F8280FC   LW V0, -32516(GP)
9D00D964  24420001   ADDIU V0, V0, 1
9D00D968  AF8280FC   SW V0, -32516(GP)
101:                        __asm__("mfc0 $v0, $11");
9D00D96C  40025800   MFC0 V0, Compare
102:                        __asm__("addiu $v0,$v0,%0"::"I"(CORE_TICK_RATE));
9D00D970  2442493E   ADDIU V0, V0, 18750
103:                        __asm__("mtc0 $v0, $11");
9D00D974  40825800   MTC0 V0, Compare
104:                        mCTClearIntFlag();
9D00D978  24030001   ADDIU V1, ZERO, 1
9D00D97C  3C02BF88   LUI V0, -16504
9D00D980  AC431034   SW V1, 4148(V0)
105:                        if ((fSound & TONE_ON) && !(--duration)){
9D00D984  93828098   LBU V0, -32616(GP)
9D00D988  30420001   ANDI V0, V0, 1
9D00D98C  1040000E   BEQ V0, ZERO, 0x9D00D9C8
9D00D990  00000000   NOP
9D00D994  8F82811C   LW V0, -32484(GP)
9D00D998  2442FFFF   ADDIU V0, V0, -1
9D00D99C  AF82811C   SW V0, -32484(GP)
9D00D9A0  8F82811C   LW V0, -32484(GP)
9D00D9A4  14400008   BNE V0, ZERO, 0x9D00D9C8
9D00D9A8  00000000   NOP
106:                            fSound &= ~TONE_ON;
9D00D9AC  93828098   LBU V0, -32616(GP)
9D00D9B0  304200FE   ANDI V0, V0, 254
9D00D9B4  A3828098   SB V0, -32616(GP)
107:                            mTone_off();
9D00D9B8  3C02BF80   LUI V0, -16512
9D00D9BC  8C433400   LW V1, 13312(V0)
9D00D9C0  7C037BC4   INS V1, ZERO, 15, 1
9D00D9C4  AC433400   SW V1, 13312(V0)
108:                        }
109:                    };
9D00D9C8  8FA30004   LW V1, 4(SP)
9D00D9CC  8FA20000   LW V0, 0(SP)
9D00D9D0  41606000   DI ZERO
9D00D9D4  000000C0   EHB
9D00D9D8  8FBA0014   LW K0, 20(SP)
9D00D9DC  8FBB0010   LW K1, 16(SP)
9D00D9E0  409A7000   MTC0 K0, EPC
9D00D9E4  8FBA000C   LW K0, 12(SP)
9D00D9E8  27BD0018   ADDIU SP, SP, 24
9D00D9EC  409A6002   MTC0 K0, SRSCtl
9D00D9F0  41DDE800   WRPGPR SP, SP
9D00D9F4  409B6000   MTC0 K1, Status
9D00D9F8  42000018   ERET
110:                 #endif
111:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/editor.c  -----------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   editor.h
20:                   * Author: Jacques Deschênes
21:                   *
22:                   * Created on 18 septembre 2013, 07:18
23:                   * Description: un éditeur simple pour le VPC-32
24:                   *
25:                   */
26:                  
27:                  
28:                  #include "hardware/HardwareProfile.h"
29:                  #include "hardware/keyboard.h"
30:                  #include "console.h"
31:                  
32:                  
33:                  void ed(char *file_name){
9D00FE70  27BDFFE8   ADDIU SP, SP, -24
9D00FE74  AFBF0014   SW RA, 20(SP)
34:                      if (comm_channel!=LOCAL_CON){
9D00FE78  93848088   LBU A0, -32632(GP)
9D00FE7C  10800006   BEQ A0, ZERO, 0x9D00FE98
9D00FE80  8FBF0014   LW RA, 20(SP)
35:                          print(comm_channel, "Cet editeur fonctionne seulement sur la console locale\r");
9D00FE84  7C042420   SEB A0, A0
9D00FE88  3C059D01   LUI A1, -25343
9D00FE8C  0F402624   JAL print
9D00FE90  24A5FD28   ADDIU A1, A1, -728
36:                          return;
37:                      }
38:                  
39:                  } // ed()
9D00FE94  8FBF0014   LW RA, 20(SP)
9D00FE98  03E00008   JR RA
9D00FE9C  27BD0018   ADDIU SP, SP, 24
40:                  
41:                  
42:                  
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/console.c  ----------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   *  Name: console.c
21:                   *  Description: text console for NTSC video output
22:                   *  Author: Jacques Deschênes
23:                   *  Date Created: 2013-09-06
24:                   */
25:                  
26:                  #include "console.h"
27:                  #include "hardware/HardwareProfile.h"
28:                  #include "hardware/serial_comm.h"
29:                  #include "hardware/keyboard.h"
30:                  
31:                  #define X_OFS  ((HRES%CWIDTH)/2)  // offset vidéo position curseur x
32:                  #define Y_OFS  ((VRES%CHEIGHT)/2)  // offset vidéo position curseur y
33:                  
34:                  // indicateurs booléens
35:                  #define CUR_SHOW 1  // curseur actif
36:                  #define CUR_VIS  2  // curseur visible
37:                  
38:                  
39:                  static unsigned short cx=X_OFS, cy=Y_OFS;  // coordonnée courante du curseur texte en pixels.
40:                  static unsigned char tab_width=TAB_WIDTH;
41:                  static cursor_t cur_shape=CR_UNDER;
42:                  static unsigned short flags=0;
43:                  
44:                  unsigned char comm_channel=LOCAL_CON;
45:                  
46:                  
47:                  void scroll_up(void){
9D0094B8  27BDFFE8   ADDIU SP, SP, -24
9D0094BC  AFBF0014   SW RA, 20(SP)
9D0094C0  AFB00010   SW S0, 16(SP)
48:                      char *src, *dst;
49:                      dst = (char*)video_bmp+Y_OFS*HRES/8;
9D0094C4  3C10A000   LUI S0, -24576
9D0094C8  26100370   ADDIU S0, S0, 880
50:                      src = (char*)video_bmp +(CHEIGHT+Y_OFS)*HRES/8;
51:                      memmove(dst,src,(LINE_PER_SCREEN-1)*CHEIGHT*HRES/8);
9D0094CC  26040078   ADDIU A0, S0, 120
9D0094D0  260501B8   ADDIU A1, S0, 440
9D0094D4  0F403E49   JAL memmove
9D0094D8  240621C0   ADDIU A2, ZERO, 8640
52:                      dst= (char*)video_bmp+(CHEIGHT*(LINE_PER_SCREEN-1)+Y_OFS)*HRES/8;
53:                      memset(dst,0,HRES/8*CHEIGHT);
9D0094DC  26042238   ADDIU A0, S0, 8760
9D0094E0  00002821   ADDU A1, ZERO, ZERO
9D0094E4  0F403DD9   JAL 0x9D00F764
9D0094E8  24060140   ADDIU A2, ZERO, 320
54:                  }//scroll_up();
9D0094EC  8FBF0014   LW RA, 20(SP)
9D0094F0  8FB00010   LW S0, 16(SP)
9D0094F4  03E00008   JR RA
9D0094F8  27BD0018   ADDIU SP, SP, 24
55:                  
56:                  void scroll_down(void){
9D0094FC  27BDFFE8   ADDIU SP, SP, -24
9D009500  AFBF0014   SW RA, 20(SP)
9D009504  AFB00010   SW S0, 16(SP)
57:                      char *src, *dst;
58:                      src = (char*)video_bmp+Y_OFS*HRES/8;
9D009508  3C04A000   LUI A0, -24576
9D00950C  24840370   ADDIU A0, A0, 880
9D009510  24900078   ADDIU S0, A0, 120
59:                      dst = (char*)video_bmp+(CHEIGHT+Y_OFS)*HRES/8;
60:                      memmove(dst,src,(LINE_PER_SCREEN-1)*CHEIGHT*HRES/8);
9D009514  248401B8   ADDIU A0, A0, 440
9D009518  02002821   ADDU A1, S0, ZERO
9D00951C  0F403E49   JAL memmove
9D009520  240621C0   ADDIU A2, ZERO, 8640
61:                      dst=(char*)video_bmp+Y_OFS*HRES/8;
62:                      memset(dst,0,HRES/8*CHEIGHT);
9D009524  02002021   ADDU A0, S0, ZERO
9D009528  00002821   ADDU A1, ZERO, ZERO
9D00952C  0F403DD9   JAL 0x9D00F764
9D009530  24060140   ADDIU A2, ZERO, 320
63:                  }//scroll_down()
9D009534  8FBF0014   LW RA, 20(SP)
9D009538  8FB00010   LW S0, 16(SP)
9D00953C  03E00008   JR RA
9D009540  27BD0018   ADDIU SP, SP, 24
64:                  
65:                  
66:                  void cursor_right(void){
9D009544  27BDFFE8   ADDIU SP, SP, -24
9D009548  AFBF0014   SW RA, 20(SP)
67:                      cx += CWIDTH;
9D00954C  97828046   LHU V0, -32698(GP)
9D009550  24420006   ADDIU V0, V0, 6
9D009554  3042FFFF   ANDI V0, V0, -1
9D009558  A7828046   SH V0, -32698(GP)
68:                      if (cx>(CHAR_PER_LINE*CWIDTH)){
9D00955C  2C42013F   SLTIU V0, V0, 319
9D009560  1440000E   BNE V0, ZERO, 0x9D00959C
9D009564  24020001   ADDIU V0, ZERO, 1
69:                          cx = X_OFS;
9D009568  A7828046   SH V0, -32698(GP)
70:                          cy += CHEIGHT;
9D00956C  97828048   LHU V0, -32696(GP)
9D009570  24420008   ADDIU V0, V0, 8
9D009574  3042FFFF   ANDI V0, V0, -1
9D009578  A7828048   SH V0, -32696(GP)
71:                          if (cy>(LINE_PER_SCREEN*CHEIGHT)){
9D00957C  2C4200E1   SLTIU V0, V0, 225
9D009580  14400007   BNE V0, ZERO, 0x9D0095A0
9D009584  8FBF0014   LW RA, 20(SP)
72:                              scroll_up();
9D009588  0F40252E   JAL scroll_up
9D00958C  00000000   NOP
73:                              cy -= CHEIGHT;
9D009590  97828048   LHU V0, -32696(GP)
9D009594  2442FFF8   ADDIU V0, V0, -8
9D009598  A7828048   SH V0, -32696(GP)
74:                          }
75:                      }
76:                  } // cursor_right()
9D00959C  8FBF0014   LW RA, 20(SP)
9D0095A0  03E00008   JR RA
9D0095A4  27BD0018   ADDIU SP, SP, 24
77:                  
78:                  void cursor_left(void){
9D0095A8  27BDFFE8   ADDIU SP, SP, -24
9D0095AC  AFBF0014   SW RA, 20(SP)
79:                      if (cx>=(X_OFS+CWIDTH)){
9D0095B0  97828046   LHU V0, -32698(GP)
9D0095B4  2C430007   SLTIU V1, V0, 7
9D0095B8  54600004   BNEL V1, ZERO, 0x9D0095CC
9D0095BC  24020139   ADDIU V0, ZERO, 313
80:                          cx -= CWIDTH;
9D0095C0  2442FFFA   ADDIU V0, V0, -6
9D0095C4  0B40257C   J 0x9D0095F0
9D0095C8  A7828046   SH V0, -32698(GP)
81:                      }else{
82:                          cx = X_OFS+CWIDTH*(CHAR_PER_LINE-1);
9D0095CC  A7828046   SH V0, -32698(GP)
83:                          if (cy>=(Y_OFS+CHEIGHT)){
9D0095D0  97828048   LHU V0, -32696(GP)
9D0095D4  2C43000B   SLTIU V1, V0, 11
9D0095D8  14600003   BNE V1, ZERO, 0x9D0095E8
9D0095DC  2442FFF8   ADDIU V0, V0, -8
84:                              cy -= CHEIGHT;
9D0095E0  0B40257C   J 0x9D0095F0
9D0095E4  A7828048   SH V0, -32696(GP)
85:                          }else{
86:                              scroll_down();
9D0095E8  0F40253F   JAL scroll_down
9D0095EC  00000000   NOP
87:                          }
88:                      }
89:                  }// cursor_left()
9D0095F0  8FBF0014   LW RA, 20(SP)
9D0095F4  03E00008   JR RA
9D0095F8  27BD0018   ADDIU SP, SP, 24
90:                  
91:                  void cursor_up(void){
9D0095FC  27BDFFE8   ADDIU SP, SP, -24
9D009600  AFBF0014   SW RA, 20(SP)
92:                      if (cy>=(Y_OFS+CHEIGHT)){
9D009604  97828048   LHU V0, -32696(GP)
9D009608  2C43000B   SLTIU V1, V0, 11
9D00960C  14600003   BNE V1, ZERO, 0x9D00961C
9D009610  2442FFF8   ADDIU V0, V0, -8
93:                          cy -= CHEIGHT;
9D009614  0B402589   J 0x9D009624
9D009618  A7828048   SH V0, -32696(GP)
94:                      }else{
95:                          scroll_down();
9D00961C  0F40253F   JAL scroll_down
9D009620  00000000   NOP
96:                      }
97:                  }// cursor_up()
9D009624  8FBF0014   LW RA, 20(SP)
9D009628  03E00008   JR RA
9D00962C  27BD0018   ADDIU SP, SP, 24
98:                  
99:                  void cursor_down(void){
9D009630  27BDFFE8   ADDIU SP, SP, -24
9D009634  AFBF0014   SW RA, 20(SP)
100:                     if (cy<=(Y_OFS+(CHEIGHT*(LINE_PER_SCREEN-2)))){
9D009638  97828048   LHU V0, -32696(GP)
9D00963C  2C4300D4   SLTIU V1, V0, 212
9D009640  10600003   BEQ V1, ZERO, 0x9D009650
9D009644  24420008   ADDIU V0, V0, 8
101:                         cy += CHEIGHT;
9D009648  0B402596   J 0x9D009658
9D00964C  A7828048   SH V0, -32696(GP)
102:                     }else{
103:                         scroll_up();
9D009650  0F40252E   JAL scroll_up
9D009654  00000000   NOP
104:                     }
105:                 }//cursor_down()
9D009658  8FBF0014   LW RA, 20(SP)
9D00965C  03E00008   JR RA
9D009660  27BD0018   ADDIU SP, SP, 24
106:                 
107:                 void crlf(void){
9D009664  27BDFFE8   ADDIU SP, SP, -24
9D009668  AFBF0014   SW RA, 20(SP)
108:                     cx=X_OFS;
9D00966C  24020001   ADDIU V0, ZERO, 1
9D009670  A7828046   SH V0, -32698(GP)
109:                     if (cy==(Y_OFS+(LINE_PER_SCREEN-1)*CHEIGHT)){
9D009674  97828048   LHU V0, -32696(GP)
9D009678  240300DB   ADDIU V1, ZERO, 219
9D00967C  14430005   BNE V0, V1, 0x9D009694
9D009680  24420008   ADDIU V0, V0, 8
110:                         scroll_up();
9D009684  0F40252E   JAL scroll_up
9D009688  00000000   NOP
111:                     }else{
112:                         cy += CHEIGHT;
9D009694  A7828048   SH V0, -32696(GP)
113:                     }
114:                 }//crlf()
9D00968C  0B4025A7   J 0x9D00969C
9D009690  8FBF0014   LW RA, 20(SP)
9D009698  8FBF0014   LW RA, 20(SP)
9D00969C  03E00008   JR RA
9D0096A0  27BD0018   ADDIU SP, SP, 24
115:                 
116:                 void put_char(dev_t channel, char c){
9D0096A4  27BDFFE8   ADDIU SP, SP, -24
9D0096A8  AFBF0014   SW RA, 20(SP)
9D0096AC  7C042420   SEB A0, A0
9D0096B0  7C052C20   SEB A1, A1
9D0097A4  24660001   ADDIU A2, V1, 1
9D0097A8  2404000A   ADDIU A0, ZERO, 10
9D0097AC  70644802   MUL T1, V1, A0
9D0097B0  01282021   ADDU A0, T1, T0
9D0097B4  00044080   SLL T0, A0, 2
9D0097B8  3C04A000   LUI A0, -24576
9D0097BC  24840370   ADDIU A0, A0, 880
9D0097C0  00882021   ADDU A0, A0, T0
9D0097C4  3C089D01   LUI T0, -25343
9D0097C8  2509D9FC   ADDIU T1, T0, -9732
9D0097CC  24080007   ADDIU T0, ZERO, 7
9D0097D0  70A85002   MUL T2, A1, T0
9D0097D4  01492821   ADDU A1, T2, T1
9D0097D8  24630008   ADDIU V1, V1, 8
117:                     register int i,l,r,b,x,y;
118:                     x=cx;
9D0096B4  97828046   LHU V0, -32698(GP)
119:                     y=cy;
120:                     if (channel==LOCAL_CON){
9D0096B8  14800062   BNE A0, ZERO, 0x9D009844
9D0096BC  97838048   LHU V1, -32696(GP)
121:                         switch (c){
9D0096C0  24040009   ADDIU A0, ZERO, 9
9D0096C4  10A4000B   BEQ A1, A0, 0x9D0096F4
9D0096C8  2404000D   ADDIU A0, ZERO, 13
9D0096CC  10A40005   BEQ A1, A0, 0x9D0096E4
9D0096D0  24040008   ADDIU A0, ZERO, 8
9D0096D4  14A4001F   BNE A1, A0, 0x9D009754
9D0096D8  28A40020   SLTI A0, A1, 32
9D0096DC  0B4025D1   J 0x9D009744
9D0096E0  00000000   NOP
122:                             case CR:
123:                                 crlf();
9D0096E4  0F402599   JAL crlf
9D0096E8  00000000   NOP
124:                                 break;
9D0096EC  0B402614   J 0x9D009850
9D0096F0  8FBF0014   LW RA, 20(SP)
125:                             case TAB:
126:                                 cx += (cx%tab_width);
9D0096F4  9384804A   LBU A0, -32694(GP)
9D0096F8  0044001A   DIV V0, A0
9D0096FC  008001F4   TEQ A0, ZERO
9D009700  00002010   MFHI A0, 0
9D009704  00441021   ADDU V0, V0, A0
9D009708  3042FFFF   ANDI V0, V0, -1
9D00970C  A7828046   SH V0, -32698(GP)
127:                                 if (cx>=(X_OFS+CHAR_PER_LINE*CWIDTH)){
9D009710  2C42013F   SLTIU V0, V0, 319
9D009714  1440004D   BNE V0, ZERO, 0x9D00984C
9D009718  24020001   ADDIU V0, ZERO, 1
128:                                     cx = X_OFS;
9D00971C  A7828046   SH V0, -32698(GP)
129:                                     if (cy==(Y_OFS+(LINE_PER_SCREEN-1)*CHEIGHT)){
9D009720  240200DB   ADDIU V0, ZERO, 219
9D009724  14620005   BNE V1, V0, 0x9D00973C
9D009728  24630008   ADDIU V1, V1, 8
130:                                         scroll_up();
9D00972C  0F40252E   JAL scroll_up
9D009730  00000000   NOP
131:                                     }else{
132:                                         cy += CHEIGHT;
9D00973C  0B402613   J 0x9D00984C
9D009740  A7838048   SH V1, -32696(GP)
133:                                     }
134:                                 }
135:                                 break;
136:                             case '\b':
137:                                 cursor_left();
9D009744  0F40256A   JAL cursor_left
9D009748  00000000   NOP
138:                                 break;
9D00974C  0B402614   J 0x9D009850
9D009750  8FBF0014   LW RA, 20(SP)
139:                             default:
140:                                 if ((c<32) || (c>(FONT_SIZE+32))) break;
9D009754  1480003D   BNE A0, ZERO, 0x9D00984C
9D009758  24A5FFE0   ADDIU A1, A1, -32
141:                                 c -=32;
9D00975C  7C052C20   SEB A1, A1
142:                                 b=x>>5;
9D009760  00024143   SRA T0, V0, 5
143:                                 r=0;
144:                                 l=27-(x&0x1f);
9D009764  3042001F   ANDI V0, V0, 31
9D009768  2406001B   ADDIU A2, ZERO, 27
9D00976C  00C21023   SUBU V0, A2, V0
145:                                 if (l<0){
146:                                     r=-l;
9D009770  00023023   SUBU A2, ZERO, V0
9D009774  28470000   SLTI A3, V0, 0
9D009778  0007300A   MOVZ A2, ZERO, A3
9D00977C  00C03821   ADDU A3, A2, ZERO
147:                                 }
148:                                 for (i=0;i<7;i++){
9D00982C  14C3FFEB   BNE A2, V1, 0x9D0097DC
9D009830  24A50001   ADDIU A1, A1, 1
149:                                     if (r){
9D0097DC  10E0000C   BEQ A3, ZERO, 0x9D009810
9D0097E0  8C890000   LW T1, 0(A0)
150:                                         video_bmp[y][b] &= ~(0x1f>>r);
9D009780  240C001F   ADDIU T4, ZERO, 31
9D009784  00CC7007   SRAV T6, T4, A2
9D009788  000E7027   NOR T6, ZERO, T6
9D0097E8  01C94824   AND T1, T6, T1
151:                                         video_bmp[y][b] |= font5x7[c][i]>>r;
9D0097E4  90A80000   LBU T0, 0(A1)
9D0097EC  00E85007   SRAV T2, T0, A3
9D0097F0  012A4825   OR T1, T1, T2
9D0097F4  AC890000   SW T1, 0(A0)
152:                                         video_bmp[y][b+1] &= ~(0x1f<<32-r);
9D00978C  240B0020   ADDIU T3, ZERO, 32
9D009790  01665823   SUBU T3, T3, A2
9D009794  016C6804   SLLV T5, T4, T3
9D009798  000D6827   NOR T5, ZERO, T5
9D0097F8  8C890004   LW T1, 4(A0)
9D0097FC  01A94824   AND T1, T5, T1
153:                                         video_bmp[y][b+1] |= font5x7[c][i]<<(32-r);
9D009800  01684004   SLLV T0, T0, T3
9D009804  01284025   OR T0, T1, T0
9D009808  0B402609   J 0x9D009824
9D00980C  AC880004   SW T0, 4(A0)
154:                                         y++;
155:                                     } else{
156:                                         video_bmp[y][b] &= ~(0x1f<<l);
9D00979C  004C6004   SLLV T4, T4, V0
9D0097A0  000C6027   NOR T4, ZERO, T4
9D009810  01894824   AND T1, T4, T1
157:                                         video_bmp[y++][b] |= font5x7[c][i]<<l;
9D009814  90A80000   LBU T0, 0(A1)
9D009818  00484004   SLLV T0, T0, V0
9D00981C  01284025   OR T0, T1, T0
9D009820  AC880000   SW T0, 0(A0)
9D009824  24C60001   ADDIU A2, A2, 1
9D009828  24840028   ADDIU A0, A0, 40
158:                                     }
159:                                 }
160:                                 cursor_right();
9D009834  0F402551   JAL cursor_right
9D009838  00000000   NOP
161:                         }//switch(c)
162:                     }else{
163:                         UartPutch(channel,c);
9D009844  0F4032D7   JAL UartPutch
9D009848  00000000   NOP
164:                     }
165:                 }//put_char()
9D009734  0B402614   J 0x9D009850
9D009738  8FBF0014   LW RA, 20(SP)
9D00983C  0B402614   J 0x9D009850
9D009840  8FBF0014   LW RA, 20(SP)
9D00984C  8FBF0014   LW RA, 20(SP)
9D009850  03E00008   JR RA
9D009854  27BD0018   ADDIU SP, SP, 24
166:                 
167:                 void clear_screen(){
9D009858  27BDFFE8   ADDIU SP, SP, -24
9D00985C  AFBF0014   SW RA, 20(SP)
168:                     memset(video_bmp,0,HRES/8*VRES);
9D009860  3C04A000   LUI A0, -24576
9D009864  24840370   ADDIU A0, A0, 880
9D009868  00002821   ADDU A1, ZERO, ZERO
9D00986C  0F403DD9   JAL 0x9D00F764
9D009870  240623F0   ADDIU A2, ZERO, 9200
169:                     cx=X_OFS;
9D009874  24020001   ADDIU V0, ZERO, 1
9D009878  A7828046   SH V0, -32698(GP)
170:                     cy=Y_OFS;
9D00987C  24020003   ADDIU V0, ZERO, 3
9D009880  A7828048   SH V0, -32696(GP)
171:                 } // clear_screen()
9D009884  8FBF0014   LW RA, 20(SP)
9D009888  03E00008   JR RA
9D00988C  27BD0018   ADDIU SP, SP, 24
172:                 
173:                 void print(dev_t channel, const char *text){
9D009890  27BDFFE8   ADDIU SP, SP, -24
9D009894  AFBF0014   SW RA, 20(SP)
9D009898  AFB00010   SW S0, 16(SP)
9D00989C  7C042420   SEB A0, A0
174:                     if (channel==LOCAL_CON){
9D0098A0  1480000C   BNE A0, ZERO, 0x9D0098D4
9D0098A4  00A08021   ADDU S0, A1, ZERO
175:                         while (*text){
9D0098A8  80A50000   LB A1, 0(A1)
9D0098AC  10A0000C   BEQ A1, ZERO, 0x9D0098E0
9D0098B0  8FBF0014   LW RA, 20(SP)
9D0098C0  82050000   LB A1, 0(S0)
9D0098C4  14A0FFFC   BNE A1, ZERO, 0x9D0098B8
9D0098C8  26100001   ADDIU S0, S0, 1
176:                             put_char(channel, *text++);
9D0098B4  26100001   ADDIU S0, S0, 1
9D0098B8  0F4025A9   JAL put_char
9D0098BC  00002021   ADDU A0, ZERO, ZERO
177:                         }
178:                     }else{
179:                         UartPrint(channel,text);
9D0098D4  0F40330F   JAL UartPrint
9D0098D8  00000000   NOP
180:                     }
181:                 }// print()
9D0098CC  0B402638   J 0x9D0098E0
9D0098D0  8FBF0014   LW RA, 20(SP)
9D0098DC  8FBF0014   LW RA, 20(SP)
9D0098E0  8FB00010   LW S0, 16(SP)
9D0098E4  03E00008   JR RA
9D0098E8  27BD0018   ADDIU SP, SP, 24
182:                 
183:                 void print_hex(dev_t channel, unsigned int hex, unsigned char width){
9D0098EC  27BDFFD8   ADDIU SP, SP, -40
9D0098F0  AFBF0024   SW RA, 36(SP)
9D0098F4  7C042420   SEB A0, A0
184:                     char c[12], *d;
185:                     int i;
186:                     c[11]=0;
9D0098F8  A3A0001B   SB ZERO, 27(SP)
187:                     d= &c[10];
188:                     for(i=width;i>=0||hex;i--){
9D0098FC  30C600FF   ANDI A2, A2, 255
9D009900  0B40264D   J 0x9D009934
9D009904  27A2001A   ADDIU V0, SP, 26
9D009930  24C6FFFF   ADDIU A2, A2, -1
9D009934  04C1FFF4   BGEZ A2, 0x9D009908
9D009938  30A3000F   ANDI V1, A1, 15
9D00993C  14A0FFF3   BNE A1, ZERO, 0x9D00990C
9D009940  2867000A   SLTI A3, V1, 10
189:                         *d=(hex%16);
190:                         if (*d<10)
9D009908  2867000A   SLTI A3, V1, 10
9D00990C  10E00004   BEQ A3, ZERO, 0x9D009920
9D009910  A0430000   SB V1, 0(V0)
191:                             *d += '0';
9D009914  24630030   ADDIU V1, V1, 48
9D009918  0B40264A   J 0x9D009928
9D00991C  A0430000   SB V1, 0(V0)
192:                         else
193:                             *d += 'A'-10;
9D009920  24630037   ADDIU V1, V1, 55
9D009924  A0430000   SB V1, 0(V0)
194:                         hex /=16;
9D009928  00052902   SRL A1, A1, 4
195:                         d--;
9D00992C  2442FFFF   ADDIU V0, V0, -1
196:                     }
197:                     print(channel, ++d);
9D009944  0F402624   JAL print
9D009948  24450001   ADDIU A1, V0, 1
198:                 } // print_hex()
9D00994C  8FBF0024   LW RA, 36(SP)
9D009950  03E00008   JR RA
9D009954  27BD0028   ADDIU SP, SP, 40
199:                 
200:                 void print_int(dev_t channel, int number, unsigned short width){ // imprime entier,width inclus le signe
9D009958  27BDFFD8   ADDIU SP, SP, -40
9D00995C  AFBF0024   SW RA, 36(SP)
9D009960  7C042420   SEB A0, A0
9D0099EC  00463023   SUBU A2, V0, A2
9D0099F0  00401821   ADDU V1, V0, ZERO
201:                     int sign=0, i;
202:                     char str[14], *d;
203:                     str[13]=0;
9D009964  30C2FFFF   ANDI V0, A2, -1
9D009968  2C42000E   SLTIU V0, V0, 14
9D00996C  14400002   BNE V0, ZERO, 0x9D009978
9D009970  A3A0001D   SB ZERO, 29(SP)
9D009974  2406000D   ADDIU A2, ZERO, 13
9D009978  30C6FFFF   ANDI A2, A2, -1
204:                     d=&str[12];
9D009994  27A2001C   ADDIU V0, SP, 28
9D0099D0  27A2001C   ADDIU V0, SP, 28
205:                     if (width>13){width=13;}
206:                     if (number<0){
9D00997C  04A10003   BGEZ A1, 0x9D00998C
9D009980  00004021   ADDU T0, ZERO, ZERO
207:                         sign=1;
9D009988  24080001   ADDIU T0, ZERO, 1
208:                         number = -number;
9D009984  00052823   SUBU A1, ZERO, A1
209:                     }
210:                     //for (i=--width;i>=0||number;i--){
211:                     i=width;
212:                     while (number>0){
9D00998C  18A00010   BLEZ A1, 0x9D0099D0
9D009990  00C04821   ADDU T1, A2, ZERO
9D0099B8  1CA0FFF8   BGTZ A1, 0x9D00999C
9D0099BC  24C6FFFF   ADDIU A2, A2, -1
213:                        *d--=(number%10)+'0';
9D009998  2403000A   ADDIU V1, ZERO, 10
9D00999C  00A3001A   DIV A1, V1
9D0099A0  006001F4   TEQ V1, ZERO
9D0099A4  00003810   MFHI A3, 0
9D0099A8  00002812   MFLO A1, 0
9D0099AC  24E70030   ADDIU A3, A3, 48
9D0099B0  A0470000   SB A3, 0(V0)
9D0099B4  2442FFFF   ADDIU V0, V0, -1
214:                         number /= 10;
215:                         i--;
216:                     }
217:                     if (i==width){
9D0099C0  15260008   BNE T1, A2, 0x9D0099E4
9D0099C4  24030030   ADDIU V1, ZERO, 48
218:                         *d--='0';
9D0099C8  0B402677   J 0x9D0099DC
9D0099CC  A0430000   SB V1, 0(V0)
9D0099D4  24030030   ADDIU V1, ZERO, 48
9D0099D8  A0430000   SB V1, 0(V0)
9D0099DC  2442FFFF   ADDIU V0, V0, -1
219:                         i--;
9D0099E0  24C6FFFF   ADDIU A2, A2, -1
220:                     }
221:                     while (i>0){
9D0099E4  18C00009   BLEZ A2, 0x9D009A0C
9D0099E8  00C03821   ADDU A3, A2, ZERO
9D009A00  5466FFFE   BNEL V1, A2, 0x9D0099FC
9D009A04  A0650000   SB A1, 0(V1)
9D009A08  00471023   SUBU V0, V0, A3
222:                         *d--=' ';
9D0099F4  24050020   ADDIU A1, ZERO, 32
9D0099F8  A0650000   SB A1, 0(V1)
9D0099FC  2463FFFF   ADDIU V1, V1, -1
223:                         i--;
224:                     }
225:                     if (sign){*d='-';}else{*d=' ';}
9D009A0C  11000004   BEQ T0, ZERO, 0x9D009A20
9D009A10  24030020   ADDIU V1, ZERO, 32
9D009A14  2403002D   ADDIU V1, ZERO, 45
9D009A18  0B402689   J 0x9D009A24
9D009A1C  A0430000   SB V1, 0(V0)
9D009A20  A0430000   SB V1, 0(V0)
226:                     
227:                     print(channel, d);
9D009A24  0F402624   JAL print
9D009A28  00402821   ADDU A1, V0, ZERO
228:                 }// print_int()
9D009A2C  8FBF0024   LW RA, 36(SP)
9D009A30  03E00008   JR RA
9D009A34  27BD0028   ADDIU SP, SP, 40
229:                 
230:                 void set_tab_width(unsigned char width){
231:                     tab_width=width;
232:                 }// set_tab_width()
9D009A38  03E00008   JR RA
9D009A3C  A384804A   SB A0, -32694(GP)
233:                 
234:                 void clear_eol(void){
9D009A40  27BDFFE0   ADDIU SP, SP, -32
9D009A44  AFBF001C   SW RA, 28(SP)
9D009A48  AFB10018   SW S1, 24(SP)
9D009A4C  AFB00014   SW S0, 20(SP)
235:                     int x,y;
236:                     x=cx;
9D009A50  97908046   LHU S0, -32698(GP)
237:                     y=cy;
238:                     while (cx<(X_OFS+CWIDTH*(CHAR_PER_LINE-1))){
9D009A54  2E020139   SLTIU V0, S0, 313
9D009A58  1040000A   BEQ V0, ZERO, 0x9D009A84
9D009A5C  97918048   LHU S1, -32696(GP)
9D009A74  97828046   LHU V0, -32698(GP)
9D009A78  2C420139   SLTIU V0, V0, 313
9D009A7C  1440FFF9   BNE V0, ZERO, 0x9D009A64
9D009A80  00002021   ADDU A0, ZERO, ZERO
239:                         put_char(LOCAL_CON, 32);
9D009A60  00002021   ADDU A0, ZERO, ZERO
9D009A64  0F4025A9   JAL put_char
9D009A68  24050020   ADDIU A1, ZERO, 32
240:                         cursor_right();
9D009A6C  0F402551   JAL cursor_right
9D009A70  00000000   NOP
241:                     }
242:                     put_char(LOCAL_CON, 32);
9D009A84  00002021   ADDU A0, ZERO, ZERO
9D009A88  0F4025A9   JAL put_char
9D009A8C  24050020   ADDIU A1, ZERO, 32
243:                     cx=x;
9D009A90  A7908046   SH S0, -32698(GP)
244:                     cy=y;
9D009A94  A7918048   SH S1, -32696(GP)
245:                 }// clear_eol()
9D009A98  8FBF001C   LW RA, 28(SP)
9D009A9C  8FB10018   LW S1, 24(SP)
9D009AA0  8FB00014   LW S0, 20(SP)
9D009AA4  03E00008   JR RA
9D009AA8  27BD0020   ADDIU SP, SP, 32
246:                 
247:                 text_coord_t get_curpos(){
9D009AAC  00801021   ADDU V0, A0, ZERO
248:                     text_coord_t cpos;
249:                     cpos.x = (cx-X_OFS)/CWIDTH;
9D009AC8  97838046   LHU V1, -32698(GP)
9D009ACC  2463FFFF   ADDIU V1, V1, -1
9D009AD0  3C052AAA   LUI A1, 10922
9D009AD4  34A5AAAB   ORI A1, A1, -21845
9D009AD8  00650018   MULT 0, V1, A1
9D009ADC  00031FC3   SRA V1, V1, 31
9D009AE0  00003810   MFHI A3, 0
9D009AE4  00E31823   SUBU V1, A3, V1
9D009AE8  A4430000   SH V1, 0(V0)
250:                     cpos.y = (cy-Y_OFS)/CHEIGHT;
9D009AB0  97848048   LHU A0, -32696(GP)
9D009AB4  2483FFFD   ADDIU V1, A0, -3
9D009AB8  24840004   ADDIU A0, A0, 4
9D009ABC  28650000   SLTI A1, V1, 0
9D009AC0  0065200A   MOVZ A0, V1, A1
9D009AC4  7C8478C0   EXT A0, A0, 3, 16
251:                     return cpos;
252:                 } // get_cursor_pos()
9D009AEC  03E00008   JR RA
9D009AF0  A4440002   SH A0, 2(V0)
253:                 
254:                 void set_curpos(unsigned short x, unsigned short y){// {x,y} coordonnée caractère
9D009AF4  3084FFFF   ANDI A0, A0, -1
255:                     if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
9D009AF8  2C820035   SLTIU V0, A0, 53
9D009AFC  1040000A   BEQ V0, ZERO, 0x9D009B28
9D009B00  30A5FFFF   ANDI A1, A1, -1
9D009B04  2CA2001C   SLTIU V0, A1, 28
9D009B08  10400007   BEQ V0, ZERO, 0x9D009B28
9D009B0C  24020006   ADDIU V0, ZERO, 6
256:                         return;
257:                     cx=x*CWIDTH+X_OFS;
9D009B10  70822002   MUL A0, A0, V0
9D009B14  24840001   ADDIU A0, A0, 1
9D009B18  A7848046   SH A0, -32698(GP)
258:                     cy=y*CHEIGHT+Y_OFS;
9D009B1C  000528C0   SLL A1, A1, 3
9D009B20  24A50003   ADDIU A1, A1, 3
9D009B24  A7858048   SH A1, -32696(GP)
9D009B28  03E00008   JR RA
9D009B2C  00000000   NOP
259:                 }//set_curpos()
260:                 
261:                 void invert_char(void){// inverse vidéo du caractère à la position courante
9D009B6C  24A30001   ADDIU V1, A1, 1
9D009B70  2402000A   ADDIU V0, ZERO, 10
9D009B74  70A25002   MUL T2, A1, V0
9D009B78  01461021   ADDU V0, T2, A2
9D009B7C  00023080   SLL A2, V0, 2
9D009B80  3C02A000   LUI V0, -24576
9D009B84  24420370   ADDIU V0, V0, 880
9D009B88  00461021   ADDU V0, V0, A2
9D009B8C  24A50009   ADDIU A1, A1, 9
262:                     register int i,l,r,b,x,y;
263:                     x=cx;
9D009B30  97878046   LHU A3, -32698(GP)
264:                     y=cy;
9D009B34  97858048   LHU A1, -32696(GP)
265:                     b=x>>5;
9D009B38  00073143   SRA A2, A3, 5
266:                     r=0;
267:                     l=27-(x&0x1f);
9D009B3C  30E7001F   ANDI A3, A3, 31
9D009B40  2403001B   ADDIU V1, ZERO, 27
9D009B44  00673823   SUBU A3, V1, A3
268:                     if (l<0){
269:                         r=-l;
9D009B48  00071823   SUBU V1, ZERO, A3
9D009B4C  28E40000   SLTI A0, A3, 0
9D009B50  0004180A   MOVZ V1, ZERO, A0
9D009B54  00602021   ADDU A0, V1, ZERO
270:                     }
271:                     for (i=8;i;i--){
9D009BBC  1465FFF4   BNE V1, A1, 0x9D009B90
9D009BC0  24420028   ADDIU V0, V0, 40
272:                         if (r){
9D009B90  10800007   BEQ A0, ZERO, 0x9D009BB0
9D009B94  8C460000   LW A2, 0(V0)
273:                             video_bmp[y][b] ^= (0x1f>>r);
9D009B58  2403001F   ADDIU V1, ZERO, 31
9D009B5C  00834807   SRAV T1, V1, A0
9D009B98  00C93026   XOR A2, A2, T1
9D009B9C  AC460000   SW A2, 0(V0)
274:                             video_bmp[y][b+1] ^= (0x1f<<32-r);
9D009B60  00044023   SUBU T0, ZERO, A0
9D009B64  01034004   SLLV T0, V1, T0
9D009BA0  8C460004   LW A2, 4(V0)
9D009BA4  00C83026   XOR A2, A2, T0
9D009BA8  0B4026EE   J 0x9D009BB8
9D009BAC  AC460004   SW A2, 4(V0)
275:                             y++;
276:                         } else{
277:                             video_bmp[y++][b] ^= (0x1f<<l);
9D009B68  00E33804   SLLV A3, V1, A3
9D009BB0  00C73026   XOR A2, A2, A3
9D009BB4  AC460000   SW A2, 0(V0)
9D009BB8  24630001   ADDIU V1, V1, 1
278:                         }
279:                     }
280:                 }//invert_char()
9D009BC4  03E00008   JR RA
9D009BC8  00000000   NOP
281:                 
282:                 static void toggle_underscore(void){
283:                     register int l,r,b,x;
284:                     x=cx;
9D0093FC  97828046   LHU V0, -32698(GP)
285:                     b=x>>5;
9D009400  00025143   SRA T2, V0, 5
286:                     r=0;
287:                     l=27-(x&0x1f);
9D009404  3042001F   ANDI V0, V0, 31
9D009408  2403001B   ADDIU V1, ZERO, 27
9D00940C  00621023   SUBU V0, V1, V0
288:                     if (l<0){
9D009410  0441001B   BGEZ V0, 0x9D009480
9D009414  97838048   LHU V1, -32696(GP)
289:                         r=-l;
9D009418  00022023   SUBU A0, ZERO, V0
290:                     }
291:                     if (r){
9D00941C  10800018   BEQ A0, ZERO, 0x9D009480
9D009420  2405000A   ADDIU A1, ZERO, 10
292:                         video_bmp[cy+CHEIGHT-1][b] ^= (0x1f>>r);
9D009424  97828048   LHU V0, -32696(GP)
9D009428  24420007   ADDIU V0, V0, 7
9D00942C  70451002   MUL V0, V0, A1
9D009430  004A3821   ADDU A3, V0, T2
9D009434  00073880   SLL A3, A3, 2
9D009438  3C06A000   LUI A2, -24576
9D00943C  24C60370   ADDIU A2, A2, 880
9D009440  00E63821   ADDU A3, A3, A2
9D009444  2405001F   ADDIU A1, ZERO, 31
9D009448  00854807   SRAV T1, A1, A0
9D00944C  8CE80000   LW T0, 0(A3)
9D009450  01284026   XOR T0, T1, T0
9D009454  ACE80000   SW T0, 0(A3)
293:                         video_bmp[cy+CHEIGHT-1][b+1] ^= (0x1f<<32-r);
9D009458  25430001   ADDIU V1, T2, 1
9D00945C  00431021   ADDU V0, V0, V1
9D009460  00021080   SLL V0, V0, 2
9D009464  00461021   ADDU V0, V0, A2
9D009468  00042023   SUBU A0, ZERO, A0
9D00946C  00852804   SLLV A1, A1, A0
9D009470  8C430000   LW V1, 0(V0)
9D009474  00A32826   XOR A1, A1, V1
9D009478  03E00008   JR RA
9D00947C  AC450000   SW A1, 0(V0)
294:                     } else{
295:                         video_bmp[cy+CHEIGHT-1][b] ^= (0x1f<<l);
9D009480  24630007   ADDIU V1, V1, 7
9D009484  2404000A   ADDIU A0, ZERO, 10
9D009488  70642802   MUL A1, V1, A0
9D00948C  00AA1821   ADDU V1, A1, T2
9D009490  00031880   SLL V1, V1, 2
9D009494  3C04A000   LUI A0, -24576
9D009498  24840370   ADDIU A0, A0, 880
9D00949C  00641821   ADDU V1, V1, A0
9D0094A0  2404001F   ADDIU A0, ZERO, 31
9D0094A4  00441004   SLLV V0, A0, V0
9D0094A8  8C640000   LW A0, 0(V1)
9D0094AC  00441026   XOR V0, V0, A0
9D0094B0  03E00008   JR RA
9D0094B4  AC620000   SW V0, 0(V1)
296:                     }
297:                 }//toggle_underscore()
298:                 
299:                 void show_cursor(BOOL show){
9D009BCC  27BDFFE8   ADDIU SP, SP, -24
9D009BD0  AFBF0014   SW RA, 20(SP)
300:                     if (show){
9D009BD4  10800011   BEQ A0, ZERO, 0x9D009C1C
9D009BD8  AFB00010   SW S0, 16(SP)
301:                         flags |= CUR_SHOW;
9D009BDC  9782808A   LHU V0, -32630(GP)
9D009BE0  34420001   ORI V0, V0, 1
302:                         flags ^= CUR_VIS;
9D009BE4  38420002   XORI V0, V0, 2
9D009BE8  A782808A   SH V0, -32630(GP)
303:                         if (cur_shape==CR_BLOCK){
9D009BEC  24020001   ADDIU V0, ZERO, 1
9D009BF0  8F83808C   LW V1, -32628(GP)
9D009BF4  14620005   BNE V1, V0, 0x9D009C0C
9D009BF8  00000000   NOP
304:                             invert_char();
9D009BFC  0F4026CC   JAL invert_char
9D009C00  00000000   NOP
305:                         }else{
306:                             toggle_underscore();
9D009C0C  0F4024FF   JAL 0x9D0093FC
9D009C10  00000000   NOP
307:                         }
308:                     }else{
309:                         if (flags & CUR_VIS){
9D009C1C  9790808A   LHU S0, -32630(GP)
9D009C20  32020002   ANDI V0, S0, 2
9D009C24  1040000D   BEQ V0, ZERO, 0x9D009C5C
9D009C28  9782808A   LHU V0, -32630(GP)
310:                             if (cur_shape==CR_BLOCK){
9D009C2C  24020001   ADDIU V0, ZERO, 1
9D009C30  8F83808C   LW V1, -32628(GP)
9D009C34  14620005   BNE V1, V0, 0x9D009C4C
9D009C38  00000000   NOP
311:                                 invert_char();
9D009C3C  0F4026CC   JAL invert_char
9D009C40  3210FFFD   ANDI S0, S0, -3
312:                             }else{
313:                                 toggle_underscore();
9D009C4C  0F4024FF   JAL 0x9D0093FC
9D009C50  3210FFFD   ANDI S0, S0, -3
314:                             }
315:                             flags &= ~CUR_VIS;
9D009C44  0B402716   J 0x9D009C58
9D009C48  A790808A   SH S0, -32630(GP)
9D009C54  A790808A   SH S0, -32630(GP)
316:                         }
317:                         flags &= ~CUR_SHOW;
9D009C58  9782808A   LHU V0, -32630(GP)
9D009C5C  3042FFFE   ANDI V0, V0, -2
9D009C60  A782808A   SH V0, -32630(GP)
318:                     }
319:                 
320:                 }// show_cursor()
9D009C04  0B40271A   J 0x9D009C68
9D009C08  8FBF0014   LW RA, 20(SP)
9D009C14  0B40271A   J 0x9D009C68
9D009C18  8FBF0014   LW RA, 20(SP)
9D009C64  8FBF0014   LW RA, 20(SP)
9D009C68  8FB00010   LW S0, 16(SP)
9D009C6C  03E00008   JR RA
9D009C70  27BD0018   ADDIU SP, SP, 24
321:                 
322:                 void set_cursor(cursor_t shape){
9D009C74  27BDFFE8   ADDIU SP, SP, -24
9D009C78  AFBF0014   SW RA, 20(SP)
9D009C7C  AFB00010   SW S0, 16(SP)
323:                     if (flags & CUR_VIS){
9D009C80  9782808A   LHU V0, -32630(GP)
9D009C84  30420002   ANDI V0, V0, 2
9D009C88  10400008   BEQ V0, ZERO, 0x9D009CAC
9D009C8C  00808021   ADDU S0, A0, ZERO
324:                         show_cursor(FALSE);
9D009C90  0F4026F3   JAL show_cursor
9D009C94  00002021   ADDU A0, ZERO, ZERO
325:                         cur_shape=shape;
9D009C98  AF90808C   SW S0, -32628(GP)
326:                         show_cursor(TRUE);
9D009C9C  0F4026F3   JAL show_cursor
9D009CA0  24040001   ADDIU A0, ZERO, 1
327:                     }else{
328:                         cur_shape=shape;
9D009CAC  AF84808C   SW A0, -32628(GP)
329:                     }
330:                 }// set_cursor()
9D009CA4  0B40272D   J 0x9D009CB4
9D009CA8  8FBF0014   LW RA, 20(SP)
9D009CB0  8FBF0014   LW RA, 20(SP)
9D009CB4  8FB00010   LW S0, 16(SP)
9D009CB8  03E00008   JR RA
9D009CBC  27BD0018   ADDIU SP, SP, 24
331:                 
332:                 unsigned short get_key(dev_t channel){ // lecture touche clavier, retourne 0 s'il n'y a pas de touche ou touche relâchée.
9D009CC0  27BDFFE8   ADDIU SP, SP, -24
9D009CC4  7C042420   SEB A0, A0
333:                     unsigned short code;
334:                     if (channel==LOCAL_CON){
9D009CC8  1480000C   BNE A0, ZERO, 0x9D009CFC
9D009CCC  AFBF0014   SW RA, 20(SP)
335:                         code=  KbdScancode();
9D009CD0  0F401FEF   JAL KbdScancode
9D009CD4  00000000   NOP
9D009CD8  00402021   ADDU A0, V0, ZERO
9D009CDC  3042FFFF   ANDI V0, V0, -1
336:                         if (!(code & FN_BIT)){
9D009CE0  30430200   ANDI V1, V0, 512
9D009CE4  14600009   BNE V1, ZERO, 0x9D009D0C
9D009CE8  8FBF0014   LW RA, 20(SP)
337:                             code = KbdKey(code);
9D009CEC  0F401EC8   JAL KbdKey
9D009CF0  00000000   NOP
9D009CF4  0B402742   J 0x9D009D08
9D009CF8  3042FFFF   ANDI V0, V0, -1
338:                         }
339:                     }else{
340:                         code=UartGetch(STDIN);
9D009CFC  0F4032CA   JAL UartGetch
9D009D00  24040001   ADDIU A0, ZERO, 1
9D009D04  3042FFFF   ANDI V0, V0, -1
341:                         if (code==-1){
342:                             code=0;
343:                         }
344:                     }
345:                     return code;
346:                 }//get_key()
9D009D08  8FBF0014   LW RA, 20(SP)
9D009D0C  03E00008   JR RA
9D009D10  27BD0018   ADDIU SP, SP, 24
347:                 
348:                 unsigned short wait_key(dev_t channel){ // attend qu'une touche soit enfoncée et retourne sa valeur.
9D009D14  27BDFFE0   ADDIU SP, SP, -32
9D009D18  AFBF001C   SW RA, 28(SP)
9D009D1C  AFB10018   SW S1, 24(SP)
9D009D20  AFB00014   SW S0, 20(SP)
349:                     unsigned short key;
350:                     unsigned int t0;
351:                     t0=ticks()+500;
9D009D24  0F403639   JAL ticks
9D009D28  7C048420   SEB S0, A0
352:                     if (channel==LOCAL_CON){
9D009D2C  12000013   BEQ S0, ZERO, 0x9D009D7C
9D009D30  245101F4   ADDIU S1, V0, 500
353:                         while (!(key=get_key(channel))){
9D009D7C  0F402730   JAL get_key
9D009D80  00002021   ADDU A0, ZERO, ZERO
9D009D84  1040FFED   BEQ V0, ZERO, 0x9D009D3C
9D009D88  00408021   ADDU S0, V0, ZERO
354:                             if (ticks()==t0){
9D009D3C  0F403639   JAL ticks
9D009D40  00000000   NOP
9D009D44  1451000D   BNE V0, S1, 0x9D009D7C
9D009D48  9782808A   LHU V0, -32630(GP)
355:                                 if (flags & CUR_SHOW){
9D009D4C  30420001   ANDI V0, V0, 1
9D009D50  10400005   BEQ V0, ZERO, 0x9D009D68
9D009D54  00000000   NOP
356:                                     show_cursor(FALSE);
9D009D58  0F4026F3   JAL show_cursor
9D009D5C  00002021   ADDU A0, ZERO, ZERO
9D009D60  0B40275C   J 0x9D009D70
9D009D64  00000000   NOP
357:                                 }else{
358:                                     show_cursor(TRUE);
9D009D68  0F4026F3   JAL show_cursor
9D009D6C  24040001   ADDIU A0, ZERO, 1
359:                                 }
360:                                 t0=ticks()+500;
9D009D70  0F403639   JAL ticks
9D009D74  00000000   NOP
9D009D78  245101F4   ADDIU S1, V0, 500
361:                             }
362:                         };
363:                         show_cursor(FALSE);
9D009D8C  0F4026F3   JAL show_cursor
9D009D90  00002021   ADDU A0, ZERO, ZERO
364:                     }else{
365:                         key=UartWaitch(STDIN,0);
9D009D34  0B402767   J 0x9D009D9C
9D009D38  24040001   ADDIU A0, ZERO, 1
9D009D9C  0F4032E5   JAL UartWaitch
9D009DA0  00002821   ADDU A1, ZERO, ZERO
9D009DA4  3050FFFF   ANDI S0, V0, -1
366:                     }
367:                     return key;
368:                 }//wait_key()
9D009D94  0B40276B   J 0x9D009DAC
9D009D98  02001021   ADDU V0, S0, ZERO
9D009DA8  02001021   ADDU V0, S0, ZERO
9D009DAC  8FBF001C   LW RA, 28(SP)
9D009DB0  8FB10018   LW S1, 24(SP)
9D009DB4  8FB00014   LW S0, 20(SP)
9D009DB8  03E00008   JR RA
9D009DBC  27BD0020   ADDIU SP, SP, 32
369:                 
370:                 unsigned char readline(dev_t channel, unsigned char *ibuff,unsigned char max_char){ // lit une ligne au clavier, retourne la longueur de texte.
9D009DC0  27BDFFD0   ADDIU SP, SP, -48
9D009DC4  AFBF002C   SW RA, 44(SP)
9D009DC8  AFB50028   SW S5, 40(SP)
9D009DCC  AFB40024   SW S4, 36(SP)
9D009DD0  AFB30020   SW S3, 32(SP)
9D009DD4  AFB2001C   SW S2, 28(SP)
9D009DD8  AFB10018   SW S1, 24(SP)
9D009DDC  AFB00014   SW S0, 20(SP)
9D009DE0  00A09821   ADDU S3, A1, ZERO
9D009DE4  7C042420   SEB A0, A0
371:                     unsigned char c=0, count=0;
372:                     if (channel==LOCAL_CON){
9D009DE8  14800025   BNE A0, ZERO, 0x9D009E80
9D009DEC  30D400FF   ANDI S4, A2, 255
9D009DF0  00008021   ADDU S0, ZERO, ZERO
373:                         while ((c!='\r') && (count<=max_char)){
9D009E4C  0B40279C   J 0x9D009E70
9D009E50  0290102B   SLTU V0, S4, S0
9D009E6C  0290102B   SLTU V0, S4, S0
9D009E70  1040FFE4   BEQ V0, ZERO, 0x9D009E04
9D009E74  00000000   NOP
374:                             c=wait_key(channel);
9D009E04  0F402745   JAL wait_key
9D009E08  00002021   ADDU A0, ZERO, ZERO
9D009E0C  304200FF   ANDI V0, V0, 255
375:                             if (c==CR){
9D009DF4  2411000D   ADDIU S1, ZERO, 13
9D009E10  14510005   BNE V0, S1, 0x9D009E28
9D009E14  00002021   ADDU A0, ZERO, ZERO
376:                                 put_char(channel,'\r');
9D009E18  0F4025A9   JAL put_char
9D009E1C  2405000D   ADDIU A1, ZERO, 13
377:                                 break;
9D009E20  0B4027A4   J 0x9D009E90
9D009E24  A2600000   SB ZERO, 0(S3)
378:                             }else if (c==BS){
9D009DF8  24120008   ADDIU S2, ZERO, 8
9D009E28  5452000A   BNEL V0, S2, 0x9D009E54
9D009E2C  A2620000   SB V0, 0(S3)
379:                                 if (count){
9D009E30  1200FFF4   BEQ S0, ZERO, 0x9D009E04
9D009E34  00002021   ADDU A0, ZERO, ZERO
380:                                     ibuff--;
9D009E38  2673FFFF   ADDIU S3, S3, -1
381:                                     count--;
9D009E3C  2610FFFF   ADDIU S0, S0, -1
9D009E40  321000FF   ANDI S0, S0, 255
382:                                     print(channel,"\b \b");
9D009DFC  3C159D01   LUI S5, -25343
9D009E00  26B502DC   ADDIU S5, S5, 732
9D009E44  0F402624   JAL print
9D009E48  02A02821   ADDU A1, S5, ZERO
383:                                 }
384:                             }else if ((c & FN_BIT)==0){
385:                                 *ibuff++=c;
9D009E54  26730001   ADDIU S3, S3, 1
386:                                 count++;
9D009E58  26100001   ADDIU S0, S0, 1
9D009E5C  321000FF   ANDI S0, S0, 255
387:                                 put_char(channel, c);
9D009E60  00002021   ADDU A0, ZERO, ZERO
9D009E64  0F4025A9   JAL put_char
9D009E68  7C022C20   SEB A1, V0
388:                             }
389:                         }// while
390:                         *ibuff=(char)0;
9D009E78  0B4027A4   J 0x9D009E90
9D009E7C  A2600000   SB ZERO, 0(S3)
391:                     }else{
392:                         count=UartReadln(STDIN,ibuff,max_char);
9D009E80  24040001   ADDIU A0, ZERO, 1
9D009E84  0F40332B   JAL UartReadln
9D009E88  02803021   ADDU A2, S4, ZERO
9D009E8C  305000FF   ANDI S0, V0, 255
393:                     }
394:                     return count;
395:                 } // readline()
9D009E90  02001021   ADDU V0, S0, ZERO
9D009E94  8FBF002C   LW RA, 44(SP)
9D009E98  8FB50028   LW S5, 40(SP)
9D009E9C  8FB40024   LW S4, 36(SP)
9D009EA0  8FB30020   LW S3, 32(SP)
9D009EA4  8FB2001C   LW S2, 28(SP)
9D009EA8  8FB10018   LW S1, 24(SP)
9D009EAC  8FB00014   LW S0, 20(SP)
9D009EB0  03E00008   JR RA
9D009EB4  27BD0030   ADDIU SP, SP, 48
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/DiosForth.X/source/VM/VMword.c  -------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*********************************************************************
19:                   *
20:                   *                  VMword
21:                   *                  DIOS Forth
22:                   *
23:                   * v.1.0 - 20.12.2012, L.Pekny
24:                   ********************************************************************/
25:                  
26:                  #include <stdlib.h>
27:                  #include <math.h>
28:                  
29:                  #include <plib.h>
30:                  #include <errno.h>
31:                  #include "../../../hardware/HardwareProfile.h"
32:                  #include "..\GenericTypeDefs.h"
33:                  //#include "..\HardwareProfile.h"
34:                  #ifdef VPC_32
35:                  #include "../../../console.h"
36:                  #include "../../../sound.h"
37:                  #else
38:                  #include "..\Uart\UartBuf.h"	// emit ?emit key ?key
39:                  #endif
40:                  #include "..\NVMem\NVMem.h"		// flash >flash ;flash
41:                  #ifndef VPC_32
42:                  #include "..\Main.h"			// devhead  devcall
43:                  #endif
44:                  #include "VMcore.h"
45:                  #include "VMword.h"
46:                  
47:                  #ifdef VPC_32
48:                  char *vTib=NULL, *vPad=NULL, *vDict=NULL, *vMem=NULL;
49:                  #else
50:                  char  vTib[tibsize+4], vPad[padsize+4];
51:                  char  vDict[dictsize], vMem[memsize];
52:                  #endif
53:                  //char  *pDict=vDict, *pMem=vMem;
54:                  char *vHere, *vHead, *vHeap, *vCurrent, *vContext;
55:                  char *vHereBak, *vHeadBak;
56:                  BYTE  vIN=0, vSharpTib=0, vBase=16, vState=0, vErrors=0;
57:                  WORD  PrimLast=0;
58:                  BYTE  AddrRAM, AddrROM;
59:                  const char StrVer[]=VerVM;
60:                  
61:                  // forward referenced functions (XC32 complain if prototypes not declared before call)
62:                  void abortf(void);
63:                  void linkg(void);
64:                  void comma(void);
65:                  void tick(void);
66:                  void crf(void);
67:                  void aborts(void);
68:                  void udot(void);
69:                  void ver(void);
70:                  void toflash(void);
71:                  void dotstring(void);
72:                  
73:                  // ********** C UTIL **********
74:                  
75:                  void FindLastC(void)  // Find last primitive word
76:                  {
77:                  	WORD i=0;
9D002B08  00001821   ADDU V1, ZERO, ZERO
78:                  	while(primwords[i].wlink!=0xFF) {i++;}
9D002B0C  2406000C   ADDIU A2, ZERO, 12
9D002B10  3C029D00   LUI V0, -25344
9D002B14  2447707C   ADDIU A3, V0, 28796
9D002B18  240500FF   ADDIU A1, ZERO, 255
9D002B1C  24620001   ADDIU V0, V1, 1
9D002B20  3042FFFF   ANDI V0, V0, -1
9D002B24  70464002   MUL T0, V0, A2
9D002B28  01072021   ADDU A0, T0, A3
9D002B2C  94840000   LHU A0, 0(A0)
9D002B30  5485FFFA   BNEL A0, A1, 0x9D002B1C
9D002B34  00401821   ADDU V1, V0, ZERO
79:                  	PrimLast=--i;
80:                  }
9D002B38  03E00008   JR RA
9D002B3C  A7838070   SH V1, -32656(GP)
81:                  
82:                  
83:                  void EEcold(void)  // Find empty 4kB or find last FHere in EETAB, recovery He..
9D002BF0  3C069CFF   LUI A2, -25345
9D002BF4  34C6FFFC   ORI A2, A2, -4
9D002BF8  01463021   ADDU A2, T2, A2
84:                  {
85:                  	UINT i, f=1, uFHere;
86:                  	UINT *pEETAB;
87:                  
88:                  	i=EETAB; pEETAB=(UINT *)i;		// Cannot make pointer directly from EETAB
9D002B40  3C02BF88   LUI V0, -16504
9D002B44  8C4A2060   LW T2, 8288(V0)
9D002B48  3C0B9CFF   LUI T3, -25345
9D002B4C  356BF000   ORI T3, T3, -4096
9D002B50  014B5821   ADDU T3, T2, T3
89:                  
90:                  	vFHead=0; uFHere=(int)StrVer&~0xFFF;	// Find empty flash 4kB
9D002B54  AF8080EC   SW ZERO, -32532(GP)
9D002B58  2402F000   ADDIU V0, ZERO, -4096
9D002B5C  3C069D00   LUI A2, -25344
9D002B60  24C66A98   ADDIU A2, A2, 27288
9D002B64  00C23024   AND A2, A2, V0
91:                  	while (f)
9D002BD0  5460FFEA   BNEL V1, ZERO, 0x9D002B7C
9D002BD4  24C61000   ADDIU A2, A2, 4096
92:                  	{ f=0;
93:                  	  uFHere+=FLASH_PAGE_SIZE;
9D002B78  24C61000   ADDIU A2, A2, 4096
9D002B7C  24C41000   ADDIU A0, A2, 4096
9D002BD8  00C02021   ADDU A0, A2, ZERO
94:                  	  for (i=uFHere; i<(uFHere+FLASH_PAGE_SIZE); i+=4)
9D002B80  00C4382B   SLTU A3, A2, A0
9D002B84  10E0000E   BEQ A3, ZERO, 0x9D002BC0
9D002B88  00001821   ADDU V1, ZERO, ZERO
9D002BAC  24420004   ADDIU V0, V0, 4
9D002BB0  0044182B   SLTU V1, V0, A0
9D002BB4  5460FFFB   BNEL V1, ZERO, 0x9D002BA4
9D002BB8  8C430000   LW V1, 0(V0)
9D002BBC  00001821   ADDU V1, ZERO, ZERO
95:                  	  {
96:                  		if (*(int *)i!=-1) {f=1; break;}
9D002B68  2405FFFF   ADDIU A1, ZERO, -1
9D002B8C  8CC70000   LW A3, 0(A2)
9D002B90  24030001   ADDIU V1, ZERO, 1
9D002B94  10E50005   BEQ A3, A1, 0x9D002BAC
9D002B98  00C01021   ADDU V0, A2, ZERO
9D002B9C  0B400AF0   J 0x9D002BC0
9D002BA0  00000000   NOP
9D002BA4  14650006   BNE V1, A1, 0x9D002BC0
9D002BA8  24030001   ADDIU V1, ZERO, 1
97:                  	  }
98:                  	  if (uFHere==EETAB) {f=0;}				// End of flash
9D002B6C  3C09BF88   LUI T1, -16504
9D002B70  3C089CFF   LUI T0, -25345
9D002B74  3508F000   ORI T0, T0, -4096
9D002BC0  8D242060   LW A0, 8288(T1)
9D002BC4  00882021   ADDU A0, A0, T0
9D002BC8  50860005   BEQL A0, A2, 0x9D002BE0
9D002BCC  AF8480E8   SW A0, -32536(GP)
99:                  	}
100:                 	vFHere=(UINT *)uFHere;
9D002BDC  AF8480E8   SW A0, -32536(GP)
101:                 
102:                 	if (*pEETAB!=-1)						// Read last vector from EETAB
9D002BE0  8D640000   LW A0, 0(T3)
9D002BE4  2402FFFF   ADDIU V0, ZERO, -1
9D002BE8  10820017   BEQ A0, V0, 0x9D002C48
9D002BEC  25620004   ADDIU V0, T3, 4
103:                 	{ f=0;
104:                 	  for (i=0; i<FLASH_PAGE_SIZE; i+=4)	// Find last FHere
9D002C0C  10460003   BEQ V0, A2, 0x9D002C1C
9D002C10  24420004   ADDIU V0, V0, 4
105:                 	  {
106:                 		if (*pEETAB==-1) {break;} else {uFHere=*pEETAB; f=1;}
9D002BFC  2405FFFF   ADDIU A1, ZERO, -1
9D002C00  8C430000   LW V1, 0(V0)
9D002C04  50650007   BEQL V1, A1, 0x9D002C24
9D002C08  AF8480E8   SW A0, -32536(GP)
9D002C14  0B400B00   J 0x9D002C00
9D002C18  00602021   ADDU A0, V1, ZERO
9D002C1C  00602021   ADDU A0, V1, ZERO
107:                 		pEETAB++;
108:                 	  }
109:                 	  vFHere=(UINT *)uFHere;
9D002C20  AF8480E8   SW A0, -32536(GP)
110:                 	  if (f&&(*(vFHere-1)==(uFHere-4)))		// Recovery Head, Heap
9D002C24  2482FFFC   ADDIU V0, A0, -4
9D002C28  8C83FFFC   LW V1, -4(A0)
9D002C2C  14620006   BNE V1, V0, 0x9D002C48
9D002C30  00000000   NOP
111:                 	    {vFHead=(UINT *)(*(vFHere-2)); vHeap=(char *)(*(vFHere-3)); vHead=(char *)vFHead;}
9D002C34  8C82FFF8   LW V0, -8(A0)
9D002C38  AF8280EC   SW V0, -32532(GP)
9D002C3C  8C83FFF4   LW V1, -12(A0)
9D002C40  AF8380E0   SW V1, -32544(GP)
9D002C44  AF8280D8   SW V0, -32552(GP)
9D002C48  03E00008   JR RA
9D002C4C  00000000   NOP
112:                 	}
113:                 }
114:                 
115:                 
116:                 void CompileCxt(WORD i)  // compile xt primitive for C
117:                 {
9D002C50  27BDFFE8   ADDIU SP, SP, -24
9D002C54  AFBF0014   SW RA, 20(SP)
9D002C58  3084FFFF   ANDI A0, A0, -1
118:                 	PUSH((ucell)&primwords[i].wcall); comma(); // XT ,
9D002C5C  8F828008   LW V0, -32760(GP)
9D002C60  24430004   ADDIU V1, V0, 4
9D002C64  AF838008   SW V1, -32760(GP)
9D002C68  2403000C   ADDIU V1, ZERO, 12
9D002C6C  70832002   MUL A0, A0, V1
9D002C70  24840008   ADDIU A0, A0, 8
9D002C74  3C039D00   LUI V1, -25344
9D002C78  2463707C   ADDIU V1, V1, 28796
9D002C7C  00641821   ADDU V1, V1, A0
9D002C80  0F4007DD   JAL comma
9D002C84  AC430004   SW V1, 4(V0)
119:                 }
9D002C88  8FBF0014   LW RA, 20(SP)
9D002C8C  03E00008   JR RA
9D002C90  27BD0018   ADDIU SP, SP, 24
120:                 
121:                 
122:                 void CompileCpfa(WORD i)  // compile pfa primitive for C
123:                 {
9D003328  27BDFFE8   ADDIU SP, SP, -24
9D00332C  AFBF0014   SW RA, 20(SP)
9D003330  3084FFFF   ANDI A0, A0, -1
124:                 	PUSH((ucell)primwords[i].wcall); comma();  // PFA ,
9D003334  8F828008   LW V0, -32760(GP)
9D003338  24430004   ADDIU V1, V0, 4
9D00333C  AF838008   SW V1, -32760(GP)
9D003340  3C039D00   LUI V1, -25344
9D003344  2465707C   ADDIU A1, V1, 28796
9D003348  2403000C   ADDIU V1, ZERO, 12
9D00334C  70833002   MUL A2, A0, V1
9D003350  00C51821   ADDU V1, A2, A1
9D003354  8C630008   LW V1, 8(V1)
9D003358  0F4007DD   JAL comma
9D00335C  AC430004   SW V1, 4(V0)
125:                 }
9D003360  8FBF0014   LW RA, 20(SP)
9D003364  03E00008   JR RA
9D003368  27BD0018   ADDIU SP, SP, 24
126:                 
127:                 
128:                 void CompileCcon(void *i)  // compile const for C
129:                 {
9D00353C  27BDFFE8   ADDIU SP, SP, -24
9D003540  AFBF0014   SW RA, 20(SP)
130:                 	PUSH((ucell)i); comma(); // x ,
9D003544  8F828008   LW V0, -32760(GP)
9D003548  24430004   ADDIU V1, V0, 4
9D00354C  AF838008   SW V1, -32760(GP)
9D003550  0F4007DD   JAL comma
9D003554  AC440004   SW A0, 4(V0)
131:                 }
9D003558  8FBF0014   LW RA, 20(SP)
9D00355C  03E00008   JR RA
9D003560  27BD0018   ADDIU SP, SP, 24
132:                 
133:                 
134:                 // ********** STACK **********
135:                 
136:                 // drop ( x --  )
137:                 void drop(void) {pDS--;}
9D000020  8F828008   LW V0, -32760(GP)
9D000024  2442FFFC   ADDIU V0, V0, -4
9D000028  03E00008   JR RA
9D00002C  AF828008   SW V0, -32760(GP)
138:                 
139:                 
140:                 // 2drop ( x1 x2 --  )
141:                 void twodrop(void) {pDS-=2;}
9D000030  8F828008   LW V0, -32760(GP)
9D000034  2442FFF8   ADDIU V0, V0, -8
9D000038  03E00008   JR RA
9D00003C  AF828008   SW V0, -32760(GP)
142:                 
143:                 
144:                 // dup (x1 -- x1 x1 )
145:                 void dup(void) {cell tmp=TOS; PUSH(tmp);}
9D000040  8F828008   LW V0, -32760(GP)
9D000044  8C430000   LW V1, 0(V0)
9D000048  24440004   ADDIU A0, V0, 4
9D00004C  AF848008   SW A0, -32760(GP)
9D000050  03E00008   JR RA
9D000054  AC430004   SW V1, 4(V0)
146:                 
147:                 
148:                 // 2dup ( x1 x2 -- x1 x2 x1 x2 )
149:                 void twodup(void) {cell tmp=TOSi(1); PUSH(tmp); tmp=TOSi(1); PUSH(tmp);}
9D000058  8F828008   LW V0, -32760(GP)
9D00005C  8C43FFFC   LW V1, -4(V0)
9D000060  24440004   ADDIU A0, V0, 4
9D000064  AF848008   SW A0, -32760(GP)
9D000068  AC430004   SW V1, 4(V0)
9D00006C  8F828008   LW V0, -32760(GP)
9D000070  8C43FFFC   LW V1, -4(V0)
9D000074  24440004   ADDIU A0, V0, 4
9D000078  AF848008   SW A0, -32760(GP)
9D00007C  03E00008   JR RA
9D000080  AC430004   SW V1, 4(V0)
150:                 
151:                 
152:                 // ?dup ( x -- 0 | x x )
153:                 void isdup(void) {cell tmp=TOS;	if (tmp) {PUSH(tmp);}}
9D000084  8F828008   LW V0, -32760(GP)
9D000088  8C430000   LW V1, 0(V0)
9D00008C  10600003   BEQ V1, ZERO, 0x9D00009C
9D000090  24440004   ADDIU A0, V0, 4
9D000094  AF848008   SW A0, -32760(GP)
9D000098  AC430004   SW V1, 4(V0)
9D00009C  03E00008   JR RA
9D0000A0  00000000   NOP
154:                 
155:                 
156:                 // nip ( x1 x2 -- x2 )
157:                 void nip(void) {TOSi(1)=TOS; pDS--;}
9D0000A4  8F828008   LW V0, -32760(GP)
9D0000A8  8C430000   LW V1, 0(V0)
9D0000AC  AC43FFFC   SW V1, -4(V0)
9D0000B0  8F828008   LW V0, -32760(GP)
9D0000B4  2442FFFC   ADDIU V0, V0, -4
9D0000B8  03E00008   JR RA
9D0000BC  AF828008   SW V0, -32760(GP)
158:                 
159:                 
160:                 // over ( x y -- x y x )
161:                 void over(void) {cell tmp=TOSi(1); PUSH(tmp);}
9D0000C0  8F828008   LW V0, -32760(GP)
9D0000C4  8C43FFFC   LW V1, -4(V0)
9D0000C8  24440004   ADDIU A0, V0, 4
9D0000CC  AF848008   SW A0, -32760(GP)
9D0000D0  03E00008   JR RA
9D0000D4  AC430004   SW V1, 4(V0)
162:                 
163:                 
164:                 // 2over ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
165:                 void twoover(void) {cell tmp=TOSi(3); PUSH(tmp); tmp=TOSi(3); PUSH(tmp);}
9D0000D8  8F828008   LW V0, -32760(GP)
9D0000DC  8C43FFF4   LW V1, -12(V0)
9D0000E0  24440004   ADDIU A0, V0, 4
9D0000E4  AF848008   SW A0, -32760(GP)
9D0000E8  AC430004   SW V1, 4(V0)
9D0000EC  8F828008   LW V0, -32760(GP)
9D0000F0  8C43FFF4   LW V1, -12(V0)
9D0000F4  24440004   ADDIU A0, V0, 4
9D0000F8  AF848008   SW A0, -32760(GP)
9D0000FC  03E00008   JR RA
9D000100  AC430004   SW V1, 4(V0)
166:                 
167:                 
168:                 // pick ( xu ... x1 x0 u -- xu ... x1 x0 xu )  copy xu
169:                 void pick(void) {ucell u=TOS; if (DScnt>u+1) {TOS=TOSi(u+1);} else {vErrors|=4; abortf();}}
9D00134C  27BDFFE8   ADDIU SP, SP, -24
9D001350  AFBF0014   SW RA, 20(SP)
9D001354  8F828008   LW V0, -32760(GP)
9D001358  8C430000   LW V1, 0(V0)
9D00135C  8F848004   LW A0, -32764(GP)
9D001360  00442023   SUBU A0, V0, A0
9D001364  00042083   SRA A0, A0, 2
9D001368  24650001   ADDIU A1, V1, 1
9D00136C  00A4202B   SLTU A0, A1, A0
9D001370  10800006   BEQ A0, ZERO, 0x9D00138C
9D001374  00031827   NOR V1, ZERO, V1
9D001378  00031880   SLL V1, V1, 2
9D00137C  00431821   ADDU V1, V0, V1
9D001380  8C630000   LW V1, 0(V1)
9D001384  0B4004E7   J 0x9D00139C
9D001388  AC430000   SW V1, 0(V0)
9D00138C  9382806F   LBU V0, -32657(GP)
9D001390  34420004   ORI V0, V0, 4
9D001394  0F400360   JAL abortf
9D001398  A382806F   SB V0, -32657(GP)
9D00139C  8FBF0014   LW RA, 20(SP)
9D0013A0  03E00008   JR RA
9D0013A4  27BD0018   ADDIU SP, SP, 24
170:                 
171:                 
172:                 // stick ( xu ... x1 x0 xunew u -- xunew ... x1 x0 )  overwrite xu
173:                 void stick(void) {cell u=POP, new=POP; if (DScnt>u) {TOSi(u)=new;} else {vErrors|=4; abortf();}}
9D0012E8  27BDFFE8   ADDIU SP, SP, -24
9D0012EC  AFBF0014   SW RA, 20(SP)
9D0012F0  8F828008   LW V0, -32760(GP)
9D0012F4  8C430000   LW V1, 0(V0)
9D0012F8  2444FFFC   ADDIU A0, V0, -4
9D0012FC  AF848008   SW A0, -32760(GP)
9D001300  8C45FFFC   LW A1, -4(V0)
9D001304  2442FFF8   ADDIU V0, V0, -8
9D001308  AF828008   SW V0, -32760(GP)
9D00130C  8F848004   LW A0, -32764(GP)
9D001310  00442023   SUBU A0, V0, A0
9D001314  00042083   SRA A0, A0, 2
9D001318  0064202A   SLT A0, V1, A0
9D00131C  10800004   BEQ A0, ZERO, 0x9D001330
9D001320  00031880   SLL V1, V1, 2
9D001324  00431023   SUBU V0, V0, V1
9D001328  0B4004D0   J 0x9D001340
9D00132C  AC450000   SW A1, 0(V0)
9D001330  9382806F   LBU V0, -32657(GP)
9D001334  34420004   ORI V0, V0, 4
9D001338  0F400360   JAL abortf
9D00133C  A382806F   SB V0, -32657(GP)
9D001340  8FBF0014   LW RA, 20(SP)
9D001344  03E00008   JR RA
9D001348  27BD0018   ADDIU SP, SP, 24
174:                 
175:                 
176:                 // roll ( xu ... x1 x0 u -- xu-1... x1 x0 xu )  move xu to TOS
177:                 void roll(void)
178:                 {
9D001250  27BDFFE8   ADDIU SP, SP, -24
9D001254  AFBF0014   SW RA, 20(SP)
179:                 	ucell u=POP, *p=(ucell *)pDSzero;
9D001258  8F838008   LW V1, -32760(GP)
9D00125C  8C620000   LW V0, 0(V1)
9D001260  2463FFFC   ADDIU V1, V1, -4
9D001264  AF838008   SW V1, -32760(GP)
180:                 	cell cnt=DScnt;
9D001268  8F868004   LW A2, -32764(GP)
9D00126C  00663023   SUBU A2, V1, A2
9D001270  00063083   SRA A2, A2, 2
181:                 
182:                 	if (!cnt) {return;}
9D001274  10C00019   BEQ A2, ZERO, 0x9D0012DC
9D001278  0046202B   SLTU A0, V0, A2
183:                 	if (cnt>u)
9D00127C  10800013   BEQ A0, ZERO, 0x9D0012CC
9D001280  00022080   SLL A0, V0, 2
184:                 	{
185:                 		int i;
186:                 		cell xu=TOSi(u);
9D001284  00641823   SUBU V1, V1, A0
9D001288  8C670000   LW A3, 0(V1)
187:                 		for (i=cnt-u; i<cnt; i++) {*(pDSzero+i)=*(pDSzero+i+1);}
9D00128C  00C21023   SUBU V0, A2, V0
9D001290  0046202A   SLT A0, V0, A2
9D001294  1080000A   BEQ A0, ZERO, 0x9D0012C0
9D001298  00401821   ADDU V1, V0, ZERO
9D00129C  00021080   SLL V0, V0, 2
9D0012A0  8F848004   LW A0, -32764(GP)
9D0012A4  00822821   ADDU A1, A0, V0
9D0012A8  24420004   ADDIU V0, V0, 4
9D0012AC  00822021   ADDU A0, A0, V0
9D0012B0  8C840000   LW A0, 0(A0)
9D0012B4  24630001   ADDIU V1, V1, 1
9D0012B8  1466FFF9   BNE V1, A2, 0x9D0012A0
9D0012BC  ACA40000   SW A0, 0(A1)
188:                 		TOS=xu;
9D0012C0  8F828008   LW V0, -32760(GP)
9D0012C4  0B4004B7   J 0x9D0012DC
9D0012C8  AC470000   SW A3, 0(V0)
189:                 	} else {vErrors|=4; abortf();}
9D0012CC  9382806F   LBU V0, -32657(GP)
9D0012D0  34420004   ORI V0, V0, 4
9D0012D4  0F400360   JAL abortf
9D0012D8  A382806F   SB V0, -32657(GP)
190:                 }
9D0012DC  8FBF0014   LW RA, 20(SP)
9D0012E0  03E00008   JR RA
9D0012E4  27BD0018   ADDIU SP, SP, 24
191:                 
192:                 
193:                 // -roll ( xu ... x1 x0 u -- x0 xu... x1 )  insert TOS to xu
194:                 void minusroll(void)
195:                 {
9D0011A8  27BDFFE8   ADDIU SP, SP, -24
9D0011AC  AFBF0014   SW RA, 20(SP)
196:                 	ucell u=POP;
9D0011B0  8F848008   LW A0, -32760(GP)
9D0011B4  8C870000   LW A3, 0(A0)
9D0011B8  2482FFFC   ADDIU V0, A0, -4
9D0011BC  AF828008   SW V0, -32760(GP)
197:                 	cell cnt=DScnt;
9D0011C0  8F838004   LW V1, -32764(GP)
9D0011C4  00431023   SUBU V0, V0, V1
9D0011C8  00021083   SRA V0, V0, 2
198:                 
199:                 	if (!cnt) {return;}
9D0011CC  1040001D   BEQ V0, ZERO, 0x9D001244
9D0011D0  00E2282B   SLTU A1, A3, V0
200:                 	if (cnt>u)
9D0011D4  10A00017   BEQ A1, ZERO, 0x9D001234
9D0011D8  00401821   ADDU V1, V0, ZERO
201:                 	{
202:                 		int i;
203:                 		cell x0=TOS;
9D0011DC  8C88FFFC   LW T0, -4(A0)
204:                 		for (i=cnt; i>cnt-u; i--) {*(pDSzero+i)=*(pDSzero+i-1);}
9D0011E0  00473023   SUBU A2, V0, A3
9D0011E4  00C2202B   SLTU A0, A2, V0
9D0011E8  5080000E   BEQL A0, ZERO, 0x9D001224
9D0011EC  00073880   SLL A3, A3, 2
9D0011F0  8F848004   LW A0, -32764(GP)
9D0011F4  00032880   SLL A1, V1, 2
9D0011F8  00852821   ADDU A1, A0, A1
9D0011FC  2463FFFF   ADDIU V1, V1, -1
9D001200  00031880   SLL V1, V1, 2
9D001204  00832021   ADDU A0, A0, V1
9D001208  8C830000   LW V1, 0(A0)
9D00120C  ACA30000   SW V1, 0(A1)
9D001210  2442FFFF   ADDIU V0, V0, -1
9D001214  00C2202B   SLTU A0, A2, V0
9D001218  1480FFF5   BNE A0, ZERO, 0x9D0011F0
9D00121C  00401821   ADDU V1, V0, ZERO
205:                 		TOSi(u)=x0;
9D001220  00073880   SLL A3, A3, 2
9D001224  8F828008   LW V0, -32760(GP)
9D001228  00473823   SUBU A3, V0, A3
9D00122C  0B400491   J 0x9D001244
9D001230  ACE80000   SW T0, 0(A3)
206:                 	} else {vErrors|=4; abortf();}
9D001234  9382806F   LBU V0, -32657(GP)
9D001238  34420004   ORI V0, V0, 4
9D00123C  0F400360   JAL abortf
9D001240  A382806F   SB V0, -32657(GP)
207:                 }
9D001244  8FBF0014   LW RA, 20(SP)
9D001248  03E00008   JR RA
9D00124C  27BD0018   ADDIU SP, SP, 24
208:                 
209:                 
210:                 // rot ( x1 x2 x3 -- x2 x3 x1 )
211:                 void rot(void) {cell tmp=TOS; TOS=TOSi(2); TOSi(2)=TOSi(1); TOSi(1)=tmp;}
9D000104  8F828008   LW V0, -32760(GP)
9D000108  8C430000   LW V1, 0(V0)
9D00010C  8C44FFF8   LW A0, -8(V0)
9D000110  AC440000   SW A0, 0(V0)
9D000114  8F828008   LW V0, -32760(GP)
9D000118  8C44FFFC   LW A0, -4(V0)
9D00011C  AC44FFF8   SW A0, -8(V0)
9D000120  8F828008   LW V0, -32760(GP)
9D000124  03E00008   JR RA
9D000128  AC43FFFC   SW V1, -4(V0)
212:                 
213:                 
214:                 // -rot ( x1 x2 x3 -- x3 x1 x2 )
215:                 void minusrot(void) {cell tmp=TOS; TOS=TOSi(1); TOSi(1)=TOSi(2); TOSi(2)=tmp;}
9D00012C  8F828008   LW V0, -32760(GP)
9D000130  8C430000   LW V1, 0(V0)
9D000134  8C44FFFC   LW A0, -4(V0)
9D000138  AC440000   SW A0, 0(V0)
9D00013C  8F828008   LW V0, -32760(GP)
9D000140  8C44FFF8   LW A0, -8(V0)
9D000144  AC44FFFC   SW A0, -4(V0)
9D000148  8F828008   LW V0, -32760(GP)
9D00014C  03E00008   JR RA
9D000150  AC43FFF8   SW V1, -8(V0)
216:                 
217:                 
218:                 // swap ( x1 x2 -- x2 x1 )
219:                 void swap(void) {cell tmp=TOS; TOS=TOSi(1); TOSi(1)=tmp;}
9D000154  8F828008   LW V0, -32760(GP)
9D000158  8C430000   LW V1, 0(V0)
9D00015C  8C44FFFC   LW A0, -4(V0)
9D000160  AC440000   SW A0, 0(V0)
9D000164  8F828008   LW V0, -32760(GP)
9D000168  03E00008   JR RA
9D00016C  AC43FFFC   SW V1, -4(V0)
220:                 
221:                 
222:                 // 2swap ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
223:                 void twoswap(void)
224:                 {
225:                 	cell tmp=TOS, tmp2=TOSi(1);
9D000170  8F828008   LW V0, -32760(GP)
9D000174  8C440000   LW A0, 0(V0)
9D000178  8C43FFFC   LW V1, -4(V0)
226:                 	TOS=TOSi(2); TOSi(1)=TOSi(3);
9D00017C  8C45FFF8   LW A1, -8(V0)
9D000180  AC450000   SW A1, 0(V0)
9D000184  8F828008   LW V0, -32760(GP)
9D000188  8C45FFF4   LW A1, -12(V0)
9D00018C  AC45FFFC   SW A1, -4(V0)
227:                 	TOSi(2)=tmp; TOSi(3)=tmp2;
9D000190  8F828008   LW V0, -32760(GP)
9D000194  AC44FFF8   SW A0, -8(V0)
9D000198  8F828008   LW V0, -32760(GP)
228:                 }
9D00019C  03E00008   JR RA
9D0001A0  AC43FFF4   SW V1, -12(V0)
229:                 
230:                 
231:                 // >r ( x -- ) (R: -- x ) 
232:                 void tor(void) {PUSHR(POP);}
9D0001A4  8F838010   LW V1, -32752(GP)
9D0001A8  24620004   ADDIU V0, V1, 4
9D0001AC  AF828010   SW V0, -32752(GP)
9D0001B0  8F828008   LW V0, -32760(GP)
9D0001B4  8C440000   LW A0, 0(V0)
9D0001B8  AC640004   SW A0, 4(V1)
9D0001BC  2442FFFC   ADDIU V0, V0, -4
9D0001C0  03E00008   JR RA
9D0001C4  AF828008   SW V0, -32760(GP)
233:                 
234:                 
235:                 // r> ( -- x ) (R: x -- )
236:                 void rfrom(void) {PUSH(POPR);}
9D0001C8  8F838008   LW V1, -32760(GP)
9D0001CC  24620004   ADDIU V0, V1, 4
9D0001D0  AF828008   SW V0, -32760(GP)
9D0001D4  8F828010   LW V0, -32752(GP)
9D0001D8  8C440000   LW A0, 0(V0)
9D0001DC  AC640004   SW A0, 4(V1)
9D0001E0  2442FFFC   ADDIU V0, V0, -4
9D0001E4  03E00008   JR RA
9D0001E8  AF828010   SW V0, -32752(GP)
237:                 
238:                 
239:                 // r@ ( -- x ) (R: x -- x )
240:                 void rfetch(void) {PUSH(TOSR);}
9D0001EC  8F828008   LW V0, -32760(GP)
9D0001F0  24430004   ADDIU V1, V0, 4
9D0001F4  AF838008   SW V1, -32760(GP)
9D0001F8  8F838010   LW V1, -32752(GP)
9D0001FC  8C630000   LW V1, 0(V1)
9D000200  03E00008   JR RA
9D000204  AC430004   SW V1, 4(V0)
241:                 
242:                 
243:                 // depth (  -- x )
244:                 void depth(void) {cell tmp=DScnt; PUSH(tmp);}
9D000208  8F828008   LW V0, -32760(GP)
9D00020C  8F838004   LW V1, -32764(GP)
9D000210  00431823   SUBU V1, V0, V1
9D000214  00031883   SRA V1, V1, 2
9D000218  24440004   ADDIU A0, V0, 4
9D00021C  AF848008   SW A0, -32760(GP)
9D000220  03E00008   JR RA
9D000224  AC430004   SW V1, 4(V0)
245:                 
246:                 
247:                 // depth! ( ... u --  x1 x2 .. xu )
248:                 void depthwrite(void) {ucell tmp=POP; pDS=pDSzero+tmp;}
9D000228  8F828008   LW V0, -32760(GP)
9D00022C  8C420000   LW V0, 0(V0)
9D000230  00021080   SLL V0, V0, 2
9D000234  8F838004   LW V1, -32764(GP)
9D000238  00621021   ADDU V0, V1, V0
9D00023C  03E00008   JR RA
9D000240  AF828008   SW V0, -32760(GP)
249:                 
250:                 
251:                 // rdepth (  -- u )
252:                 void rdepth(void) {cell tmp=RScnt; PUSH(tmp);}
9D000244  8F82800C   LW V0, -32756(GP)
9D000248  8F838010   LW V1, -32752(GP)
9D00024C  00621823   SUBU V1, V1, V0
9D000250  00031883   SRA V1, V1, 2
9D000254  8F828008   LW V0, -32760(GP)
9D000258  24440004   ADDIU A0, V0, 4
9D00025C  AF848008   SW A0, -32760(GP)
9D000260  03E00008   JR RA
9D000264  AC430004   SW V1, 4(V0)
253:                 
254:                 
255:                 // rdepth! ( u --  ) ( R: ... -- x1 x2 .. xu )
256:                 void rdepthwrite(void) {ucell tmp=POP; pRS=pRSzero+tmp;}
9D000268  8F828008   LW V0, -32760(GP)
9D00026C  8C430000   LW V1, 0(V0)
9D000270  2442FFFC   ADDIU V0, V0, -4
9D000274  AF828008   SW V0, -32760(GP)
9D000278  00031080   SLL V0, V1, 2
9D00027C  8F83800C   LW V1, -32756(GP)
9D000280  00621021   ADDU V0, V1, V0
9D000284  03E00008   JR RA
9D000288  AF828010   SW V0, -32752(GP)
257:                 
258:                 
259:                 // sp@ (  -- addr )
260:                 void spfetch(void) {ucell tmp=(ucell)&TOS; PUSH(tmp);}
9D00028C  8F828008   LW V0, -32760(GP)
9D000290  24430004   ADDIU V1, V0, 4
9D000294  AF838008   SW V1, -32760(GP)
9D000298  03E00008   JR RA
9D00029C  AC420004   SW V0, 4(V0)
261:                 
262:                 
263:                 // rp@ (  -- u )
264:                 void rpfetch(void) {ucell tmp=(ucell)&TOSR; PUSH(tmp);}
9D0002A0  8F828008   LW V0, -32760(GP)
9D0002A4  24430004   ADDIU V1, V0, 4
9D0002A8  AF838008   SW V1, -32760(GP)
9D0002AC  8F838010   LW V1, -32752(GP)
9D0002B0  03E00008   JR RA
9D0002B4  AC430004   SW V1, 4(V0)
265:                 
266:                 
267:                 // ********** OTHER **********
268:                 
269:                 
270:                 // nop ( -- )
271:                 void nop(void) { }
9D0002B8  03E00008   JR RA
9D0002BC  00000000   NOP
272:                 
273:                 
274:                 // emit ( char --  )
275:                 void emit(void)
276:                 {
9D002338  27BDFFE8   ADDIU SP, SP, -24
9D00233C  AFBF0014   SW RA, 20(SP)
277:                 	// while (!isUARTwrite(UARTcon));
278:                 #ifdef VPC_32
279:                     put_char(comm_channel,POP);
9D002340  83848088   LB A0, -32632(GP)
9D002344  8F828008   LW V0, -32760(GP)
9D002348  80450000   LB A1, 0(V0)
9D00234C  2442FFFC   ADDIU V0, V0, -4
9D002350  0F4025A9   JAL put_char
9D002354  AF828008   SW V0, -32760(GP)
280:                 #else
281:                         if (!isUARTwrite(UARTcon)) {delay_us(20000000/UART[UARTcon].Speed);}
282:                 	UARTwrite(UARTcon,POP);
283:                 #endif
284:                 }
9D002358  8FBF0014   LW RA, 20(SP)
9D00235C  03E00008   JR RA
9D002360  27BD0018   ADDIU SP, SP, 24
285:                 
286:                 #ifndef VPC_32
287:                 // ?emit ( char --  )
288:                 void isemit(void) {   
289:                     PUSH((cell) isUARTwrite(UARTcon));
290:                 }
291:                 #endif
292:                 
293:                 
294:                 // key (  -- char )
295:                 void key(void)
296:                 {
9D002304  27BDFFE8   ADDIU SP, SP, -24
9D002308  AFBF0014   SW RA, 20(SP)
9D00230C  AFB00010   SW S0, 16(SP)
297:                 #ifdef VPC_32
298:                     PUSH (wait_key(comm_channel));
9D002310  8F908008   LW S0, -32760(GP)
9D002314  26020004   ADDIU V0, S0, 4
9D002318  AF828008   SW V0, -32760(GP)
9D00231C  0F402745   JAL wait_key
9D002320  83848088   LB A0, -32632(GP)
9D002324  AE020004   SW V0, 4(S0)
299:                 #else
300:                 	while (!isUARTread(UARTcon));
301:                 	PUSH(UARTread(UARTcon));
302:                 #endif
303:                 } 
9D002328  8FBF0014   LW RA, 20(SP)
9D00232C  8FB00010   LW S0, 16(SP)
9D002330  03E00008   JR RA
9D002334  27BD0018   ADDIU SP, SP, 24
304:                 
305:                 
306:                 // ?key (  -- pressed? )
307:                 void iskey(void) {
9D0022D0  27BDFFE8   ADDIU SP, SP, -24
9D0022D4  AFBF0014   SW RA, 20(SP)
9D0022D8  AFB00010   SW S0, 16(SP)
308:                 #ifdef VPC_32
309:                     PUSH((cell) get_key(comm_channel));
9D0022DC  8F908008   LW S0, -32760(GP)
9D0022E0  26020004   ADDIU V0, S0, 4
9D0022E4  AF828008   SW V0, -32760(GP)
9D0022E8  0F402730   JAL get_key
9D0022EC  83848088   LB A0, -32632(GP)
9D0022F0  AE020004   SW V0, 4(S0)
310:                 #else
311:                     PUSH((cell) isUARTread(UARTcon));
312:                 #endif
313:                 }
9D0022F4  8FBF0014   LW RA, 20(SP)
9D0022F8  8FB00010   LW S0, 16(SP)
9D0022FC  03E00008   JR RA
9D002300  27BD0018   ADDIU SP, SP, 24
314:                 
315:                 
316:                 // i ( -- i )
317:                 void loop_i(void) {PUSH(TOSR);}
9D0002C0  8F828008   LW V0, -32760(GP)
9D0002C4  24430004   ADDIU V1, V0, 4
9D0002C8  AF838008   SW V1, -32760(GP)
9D0002CC  8F838010   LW V1, -32752(GP)
9D0002D0  8C630000   LW V1, 0(V1)
9D0002D4  03E00008   JR RA
9D0002D8  AC430004   SW V1, 4(V0)
318:                 
319:                 
320:                 // j ( -- j )
321:                 void loop_j(void) {PUSH(TOSRi(3));}
9D0002DC  8F828008   LW V0, -32760(GP)
9D0002E0  24430004   ADDIU V1, V0, 4
9D0002E4  AF838008   SW V1, -32760(GP)
9D0002E8  8F838010   LW V1, -32752(GP)
9D0002EC  8C63FFF4   LW V1, -12(V1)
9D0002F0  03E00008   JR RA
9D0002F4  AC430004   SW V1, 4(V0)
322:                 
323:                 
324:                 // k ( -- k )
325:                 void loop_k(void) {PUSH(TOSRi(6));}
9D0002F8  8F828008   LW V0, -32760(GP)
9D0002FC  24430004   ADDIU V1, V0, 4
9D000300  AF838008   SW V1, -32760(GP)
9D000304  8F838010   LW V1, -32752(GP)
9D000308  8C63FFE8   LW V1, -24(V1)
9D00030C  03E00008   JR RA
9D000310  AC430004   SW V1, 4(V0)
326:                 
327:                 
328:                 // ********** MEMORY **********
329:                 
330:                 
331:                 // @ ( addr -- x )
332:                 void fetch(void) {TOS=pDATA TOS;}
9D000314  8F828008   LW V0, -32760(GP)
9D000318  8C430000   LW V1, 0(V0)
9D00031C  8C630000   LW V1, 0(V1)
9D000320  03E00008   JR RA
9D000324  AC430000   SW V1, 0(V0)
333:                 
334:                 
335:                 // c@ ( addr -- byte )
336:                 void cfetch(void) {TOS=*(BYTE *)TOS;}
9D000328  8F828008   LW V0, -32760(GP)
9D00032C  8C430000   LW V1, 0(V0)
9D000330  90630000   LBU V1, 0(V1)
9D000334  03E00008   JR RA
9D000338  AC430000   SW V1, 0(V0)
337:                 
338:                 
339:                 // w@ ( addr -- w )
340:                 void wfetch(void) {TOS=*(WORD *)TOS;}
9D00033C  8F828008   LW V0, -32760(GP)
9D000340  8C430000   LW V1, 0(V0)
9D000344  94630000   LHU V1, 0(V1)
9D000348  03E00008   JR RA
9D00034C  AC430000   SW V1, 0(V0)
341:                 
342:                 
343:                 // ! ( x addr -- )
344:                 void store(void) {ucell addr=POP; pDATA addr=POP;}
9D000350  8F828008   LW V0, -32760(GP)
9D000354  8C430000   LW V1, 0(V0)
9D000358  2444FFFC   ADDIU A0, V0, -4
9D00035C  AF848008   SW A0, -32760(GP)
9D000360  8C44FFFC   LW A0, -4(V0)
9D000364  AC640000   SW A0, 0(V1)
9D000368  2442FFF8   ADDIU V0, V0, -8
9D00036C  03E00008   JR RA
9D000370  AF828008   SW V0, -32760(GP)
345:                 
346:                 
347:                 // c! ( byte addr -- )
348:                 void cstore(void) {ucell addr=POP; *(BYTE *) addr=POP;}
9D000374  8F828008   LW V0, -32760(GP)
9D000378  8C430000   LW V1, 0(V0)
9D00037C  2444FFFC   ADDIU A0, V0, -4
9D000380  AF848008   SW A0, -32760(GP)
9D000384  8C44FFFC   LW A0, -4(V0)
9D000388  A0640000   SB A0, 0(V1)
9D00038C  2442FFF8   ADDIU V0, V0, -8
9D000390  03E00008   JR RA
9D000394  AF828008   SW V0, -32760(GP)
349:                 
350:                 
351:                 // w! ( w addr -- )
352:                 void wstore(void) {ucell addr=POP; *(WORD *) addr=POP;}
9D000398  8F828008   LW V0, -32760(GP)
9D00039C  8C430000   LW V1, 0(V0)
9D0003A0  2444FFFC   ADDIU A0, V0, -4
9D0003A4  AF848008   SW A0, -32760(GP)
9D0003A8  8C44FFFC   LW A0, -4(V0)
9D0003AC  A4640000   SH A0, 0(V1)
9D0003B0  2442FFF8   ADDIU V0, V0, -8
9D0003B4  03E00008   JR RA
9D0003B8  AF828008   SW V0, -32760(GP)
353:                 
354:                 
355:                 // +! ( n addr -- )
356:                 void plusstore(void) {ucell addr=POP; pDATA addr+=POP;}
9D0003BC  8F828008   LW V0, -32760(GP)
9D0003C0  8C430000   LW V1, 0(V0)
9D0003C4  2444FFFC   ADDIU A0, V0, -4
9D0003C8  AF848008   SW A0, -32760(GP)
9D0003CC  8C650000   LW A1, 0(V1)
9D0003D0  8C44FFFC   LW A0, -4(V0)
9D0003D4  00A42021   ADDU A0, A1, A0
9D0003D8  AC640000   SW A0, 0(V1)
9D0003DC  2442FFF8   ADDIU V0, V0, -8
9D0003E0  03E00008   JR RA
9D0003E4  AF828008   SW V0, -32760(GP)
357:                 
358:                 
359:                 // fill ( addr len c -- )
360:                 void fillf(void)  // fill c
361:                 {
9D002290  27BDFFE8   ADDIU SP, SP, -24
9D002294  AFBF0014   SW RA, 20(SP)
362:                 	ucell value=POP, count=POP, src=POP;
9D002298  8F828008   LW V0, -32760(GP)
9D00229C  8C450000   LW A1, 0(V0)
9D0022A0  2443FFFC   ADDIU V1, V0, -4
9D0022A4  AF838008   SW V1, -32760(GP)
9D0022A8  8C46FFFC   LW A2, -4(V0)
9D0022AC  2443FFF8   ADDIU V1, V0, -8
9D0022B0  AF838008   SW V1, -32760(GP)
9D0022B4  8C44FFF8   LW A0, -8(V0)
9D0022B8  2442FFF4   ADDIU V0, V0, -12
363:                 	memset((char *)src, value, count);
9D0022BC  0F403DD9   JAL 0x9D00F764
9D0022C0  AF828008   SW V0, -32760(GP)
364:                 }
9D0022C4  8FBF0014   LW RA, 20(SP)
9D0022C8  03E00008   JR RA
9D0022CC  27BD0018   ADDIU SP, SP, 24
365:                 
366:                 
367:                 // move ( src-addr dest-addr len -- )
368:                 void movef(void)  // move c
369:                 {
9D002250  27BDFFE8   ADDIU SP, SP, -24
9D002254  AFBF0014   SW RA, 20(SP)
370:                 	ucell count=POP, dest=POP, src=POP;
9D002258  8F828008   LW V0, -32760(GP)
9D00225C  8C460000   LW A2, 0(V0)
9D002260  2443FFFC   ADDIU V1, V0, -4
9D002264  AF838008   SW V1, -32760(GP)
9D002268  8C44FFFC   LW A0, -4(V0)
9D00226C  2443FFF8   ADDIU V1, V0, -8
9D002270  AF838008   SW V1, -32760(GP)
9D002274  8C45FFF8   LW A1, -8(V0)
9D002278  2442FFF4   ADDIU V0, V0, -12
371:                 	memmove((char *)dest, (char *)src, count);
9D00227C  0F403E49   JAL memmove
9D002280  AF828008   SW V0, -32760(GP)
372:                 }
9D002284  8FBF0014   LW RA, 20(SP)
9D002288  03E00008   JR RA
9D00228C  27BD0018   ADDIU SP, SP, 24
373:                 
374:                 
375:                 // here ( -- u )
376:                 void here(void) {PUSH((ucell)vHere);}
9D0003E8  8F828008   LW V0, -32760(GP)
9D0003EC  24430004   ADDIU V1, V0, 4
9D0003F0  AF838008   SW V1, -32760(GP)
9D0003F4  8F8380D0   LW V1, -32560(GP)
9D0003F8  03E00008   JR RA
9D0003FC  AC430004   SW V1, 4(V0)
377:                 
378:                 
379:                 // here! ( u -- )
380:                 void herewrite(void) {vHere=(char *)POP;}  // set vHere
9D000400  8F828008   LW V0, -32760(GP)
9D000404  8C430000   LW V1, 0(V0)
9D000408  AF8380D0   SW V1, -32560(GP)
9D00040C  2442FFFC   ADDIU V0, V0, -4
9D000410  03E00008   JR RA
9D000414  AF828008   SW V0, -32760(GP)
381:                 
382:                 
383:                 // head (  -- u )
384:                 void head(void) {PUSH((ucell)vHead);}
9D000418  8F828008   LW V0, -32760(GP)
9D00041C  24430004   ADDIU V1, V0, 4
9D000420  AF838008   SW V1, -32760(GP)
9D000424  8F8380D8   LW V1, -32552(GP)
9D000428  03E00008   JR RA
9D00042C  AC430004   SW V1, 4(V0)
385:                 
386:                 
387:                 // head! ( u -- )
388:                 void headwrite(void) {vHead=(char *)POP;}
9D000430  8F828008   LW V0, -32760(GP)
9D000434  8C430000   LW V1, 0(V0)
9D000438  AF8380D8   SW V1, -32552(GP)
9D00043C  2442FFFC   ADDIU V0, V0, -4
9D000440  03E00008   JR RA
9D000444  AF828008   SW V0, -32760(GP)
389:                 
390:                 
391:                 // heap (  -- u )
392:                 void heap(void) {PUSH((ucell)vHeap);}
9D000448  8F828008   LW V0, -32760(GP)
9D00044C  24430004   ADDIU V1, V0, 4
9D000450  AF838008   SW V1, -32760(GP)
9D000454  8F8380E0   LW V1, -32544(GP)
9D000458  03E00008   JR RA
9D00045C  AC430004   SW V1, 4(V0)
393:                 
394:                 
395:                 // heap! ( u -- )
396:                 void heapwrite(void) {vHeap=(char *)POP;}
9D000460  8F828008   LW V0, -32760(GP)
9D000464  8C430000   LW V1, 0(V0)
9D000468  AF8380E0   SW V1, -32544(GP)
9D00046C  2442FFFC   ADDIU V0, V0, -4
9D000470  03E00008   JR RA
9D000474  AF828008   SW V0, -32760(GP)
397:                 
398:                 
399:                 // ********** ARITHMETIC **********
400:                 
401:                 
402:                 // + ( n1 n2 -- n )
403:                 void plus(void) {cell n2=POP; TOS=TOS+n2;}
9D000478  8F828008   LW V0, -32760(GP)
9D00047C  8C430000   LW V1, 0(V0)
9D000480  2444FFFC   ADDIU A0, V0, -4
9D000484  AF848008   SW A0, -32760(GP)
9D000488  8C44FFFC   LW A0, -4(V0)
9D00048C  00831821   ADDU V1, A0, V1
9D000490  03E00008   JR RA
9D000494  AC43FFFC   SW V1, -4(V0)
404:                 
405:                 
406:                 // - ( n1 n2 -- n )
407:                 void minus(void) {cell n2=POP; TOS=TOS-n2;}
9D000498  8F828008   LW V0, -32760(GP)
9D00049C  8C430000   LW V1, 0(V0)
9D0004A0  2444FFFC   ADDIU A0, V0, -4
9D0004A4  AF848008   SW A0, -32760(GP)
9D0004A8  8C44FFFC   LW A0, -4(V0)
9D0004AC  00831823   SUBU V1, A0, V1
9D0004B0  03E00008   JR RA
9D0004B4  AC43FFFC   SW V1, -4(V0)
408:                 
409:                 
410:                 // d+ ( d1 d2 -- d )
411:                 void dplus(void) 
412:                 {
413:                 	dcell d1, d2;
414:                 	DPOP(d2); DPOP(d1);
9D0004B8  8F828008   LW V0, -32760(GP)
9D0004BC  8C460000   LW A2, 0(V0)
9D0004C0  2443FFFC   ADDIU V1, V0, -4
9D0004C4  AF838008   SW V1, -32760(GP)
9D0004C8  8C44FFFC   LW A0, -4(V0)
9D0004CC  2443FFF8   ADDIU V1, V0, -8
9D0004D0  AF838008   SW V1, -32760(GP)
9D0004D4  8C47FFF8   LW A3, -8(V0)
9D0004D8  2445FFF4   ADDIU A1, V0, -12
9D0004DC  AF858008   SW A1, -32760(GP)
9D0004E0  8C43FFF4   LW V1, -12(V0)
415:                 	DPUSH(d1+d2);
9D0004E4  00642021   ADDU A0, V1, A0
9D0004E8  AC44FFF4   SW A0, -12(V0)
9D0004EC  8F828008   LW V0, -32760(GP)
9D0004F0  24450004   ADDIU A1, V0, 4
9D0004F4  AF858008   SW A1, -32760(GP)
9D0004F8  0083182B   SLTU V1, A0, V1
9D0004FC  00E62821   ADDU A1, A3, A2
9D000500  00651821   ADDU V1, V1, A1
416:                 }
9D000504  03E00008   JR RA
9D000508  AC430004   SW V1, 4(V0)
417:                 
418:                 
419:                 // d- ( d1 d2 -- d )
420:                 void dminus(void)
421:                 {
422:                 	dcell d1, d2;
423:                 	DPOP(d2); DPOP(d1);
9D00050C  8F828008   LW V0, -32760(GP)
9D000510  8C460000   LW A2, 0(V0)
9D000514  2443FFFC   ADDIU V1, V0, -4
9D000518  AF838008   SW V1, -32760(GP)
9D00051C  8C44FFFC   LW A0, -4(V0)
9D000520  2443FFF8   ADDIU V1, V0, -8
9D000524  AF838008   SW V1, -32760(GP)
9D000528  8C47FFF8   LW A3, -8(V0)
9D00052C  2445FFF4   ADDIU A1, V0, -12
9D000530  AF858008   SW A1, -32760(GP)
9D000534  8C43FFF4   LW V1, -12(V0)
424:                 	DPUSH(d1-d2);
9D000538  00642023   SUBU A0, V1, A0
9D00053C  AC44FFF4   SW A0, -12(V0)
9D000540  8F828008   LW V0, -32760(GP)
9D000544  24450004   ADDIU A1, V0, 4
9D000548  AF858008   SW A1, -32760(GP)
9D00054C  0064202B   SLTU A0, V1, A0
9D000550  00E61823   SUBU V1, A3, A2
9D000554  00641823   SUBU V1, V1, A0
425:                 }
9D000558  03E00008   JR RA
9D00055C  AC430004   SW V1, 4(V0)
426:                 
427:                 
428:                 // * ( n1 n2 -- n )
429:                 void mult(void) {cell n2=POP; TOS=TOS*n2;}
9D000560  8F828008   LW V0, -32760(GP)
9D000564  8C430000   LW V1, 0(V0)
9D000568  2444FFFC   ADDIU A0, V0, -4
9D00056C  AF848008   SW A0, -32760(GP)
9D000570  8C44FFFC   LW A0, -4(V0)
9D000574  70831802   MUL V1, A0, V1
9D000578  03E00008   JR RA
9D00057C  AC43FFFC   SW V1, -4(V0)
430:                 
431:                 
432:                 // u* ( u1 u2 -- u ) same as mult
433:                 //void umult(void) {ucell u2=POP; TOS=(ucell)TOS*u2;}
434:                 
435:                 
436:                 // m* ( n1 n2 -- d )
437:                 void mmult(void) {cell n2=POP, n1=POP;	DPUSH((dcell)n1*n2);}
9D000580  8F848008   LW A0, -32760(GP)
9D000584  8C820000   LW V0, 0(A0)
9D000588  2485FFFC   ADDIU A1, A0, -4
9D00058C  AF858008   SW A1, -32760(GP)
9D000590  8C83FFFC   LW V1, -4(A0)
9D000594  70622802   MUL A1, V1, V0
9D000598  AC85FFFC   SW A1, -4(A0)
9D00059C  8F858008   LW A1, -32760(GP)
9D0005A0  24A40004   ADDIU A0, A1, 4
9D0005A4  AF848008   SW A0, -32760(GP)
9D0005A8  000337C3   SRA A2, V1, 31
9D0005AC  000227C3   SRA A0, V0, 31
9D0005B0  00830018   MULT 0, A0, V1
9D0005B4  70C20000   MADD 0, A2, V0
9D0005B8  00002012   MFLO A0, 0
9D0005BC  00620019   MULTU 0, V1, V0
9D0005C0  00001810   MFHI V1, 0
9D0005C4  00832021   ADDU A0, A0, V1
9D0005C8  03E00008   JR RA
9D0005CC  ACA40004   SW A0, 4(A1)
438:                 
439:                 
440:                 // um* ( u1 u2 -- ud )
441:                 void ummult(void) {ucell u2=POP, u1=POP; DPUSH((udcell)u1*u2);}
9D0005D0  8F828008   LW V0, -32760(GP)
9D0005D4  8C430000   LW V1, 0(V0)
9D0005D8  2445FFFC   ADDIU A1, V0, -4
9D0005DC  AF858008   SW A1, -32760(GP)
9D0005E0  8C44FFFC   LW A0, -4(V0)
9D0005E4  70832802   MUL A1, A0, V1
9D0005E8  AC45FFFC   SW A1, -4(V0)
9D0005EC  8F828008   LW V0, -32760(GP)
9D0005F0  24450004   ADDIU A1, V0, 4
9D0005F4  AF858008   SW A1, -32760(GP)
9D0005F8  00830019   MULTU 0, A0, V1
9D0005FC  00002810   MFHI A1, 0
9D000600  03E00008   JR RA
9D000604  AC450004   SW A1, 4(V0)
442:                 
443:                 
444:                 // sqrt ( u1 -- u )
445:                 void sqrtu(void) {ucell u=TOS; TOS=sqrtf(u);}
9D002214  27BDFFE8   ADDIU SP, SP, -24
9D002218  AFBF0014   SW RA, 20(SP)
9D00221C  AFB00010   SW S0, 16(SP)
9D002220  8F908008   LW S0, -32760(GP)
9D002224  0F403ECA   JAL __floatunsisf
9D002228  8E040000   LW A0, 0(S0)
9D00222C  0F403EA2   JAL sqrtf
9D002230  00402021   ADDU A0, V0, ZERO
9D002234  0F40296E   JAL __fixsfsi
9D002238  00402021   ADDU A0, V0, ZERO
9D00223C  AE020000   SW V0, 0(S0)
9D002240  8FBF0014   LW RA, 20(SP)
9D002244  8FB00010   LW S0, 16(SP)
9D002248  03E00008   JR RA
9D00224C  27BD0018   ADDIU SP, SP, 24
446:                 
447:                 
448:                 // um/mod ( ud u1 -- rem u )
449:                 void umdivmod(void)
450:                 {
9D0010EC  27BDFFD8   ADDIU SP, SP, -40
9D0010F0  AFBF0024   SW RA, 36(SP)
9D0010F4  AFB40020   SW S4, 32(SP)
9D0010F8  AFB3001C   SW S3, 28(SP)
9D0010FC  AFB20018   SW S2, 24(SP)
9D001100  AFB10014   SW S1, 20(SP)
9D001104  AFB00010   SW S0, 16(SP)
451:                 	udcell ud, u1=POP;
9D001108  8F828008   LW V0, -32760(GP)
9D00110C  8C500000   LW S0, 0(V0)
9D001110  00108FC3   SRA S1, S0, 31
9D001114  2452FFFC   ADDIU S2, V0, -4
452:                 	if (u1==0) {vErrors|=8; abortf();}
9D001118  02111825   OR V1, S0, S1
9D00111C  14600007   BNE V1, ZERO, 0x9D00113C
9D001120  AF928008   SW S2, -32760(GP)
9D001124  9382806F   LBU V0, -32657(GP)
9D001128  34420008   ORI V0, V0, 8
9D00112C  0F400360   JAL abortf
9D001130  A382806F   SB V0, -32657(GP)
453:                 	else {DPOP(ud); PUSH(ud%u1); PUSH(ud/u1);}
9D00113C  8C54FFFC   LW S4, -4(V0)
9D001140  2642FFFC   ADDIU V0, S2, -4
9D001144  AF828008   SW V0, -32760(GP)
9D001148  8E53FFFC   LW S3, -4(S2)
9D00114C  02602021   ADDU A0, S3, ZERO
9D001150  02802821   ADDU A1, S4, ZERO
9D001154  02003021   ADDU A2, S0, ZERO
9D001158  0F402ED4   JAL __umoddi3
9D00115C  02203821   ADDU A3, S1, ZERO
9D001160  AE42FFFC   SW V0, -4(S2)
9D001164  8F928008   LW S2, -32760(GP)
9D001168  26420004   ADDIU V0, S2, 4
9D00116C  AF828008   SW V0, -32760(GP)
9D001170  02602021   ADDU A0, S3, ZERO
9D001174  02802821   ADDU A1, S4, ZERO
9D001178  02003021   ADDU A2, S0, ZERO
9D00117C  0F402FEC   JAL __udivdi3
9D001180  02203821   ADDU A3, S1, ZERO
9D001184  AE420004   SW V0, 4(S2)
454:                 } 
9D001134  0B400463   J 0x9D00118C
9D001138  8FBF0024   LW RA, 36(SP)
9D001188  8FBF0024   LW RA, 36(SP)
9D00118C  8FB40020   LW S4, 32(SP)
9D001190  8FB3001C   LW S3, 28(SP)
9D001194  8FB20018   LW S2, 24(SP)
9D001198  8FB10014   LW S1, 20(SP)
9D00119C  8FB00010   LW S0, 16(SP)
9D0011A0  03E00008   JR RA
9D0011A4  27BD0028   ADDIU SP, SP, 40
455:                 
456:                 
457:                 // m/mod ( d n1 -- rem n )
458:                 void mdivmod(void)
459:                 {
9D001030  27BDFFD8   ADDIU SP, SP, -40
9D001034  AFBF0024   SW RA, 36(SP)
9D001038  AFB40020   SW S4, 32(SP)
9D00103C  AFB3001C   SW S3, 28(SP)
9D001040  AFB20018   SW S2, 24(SP)
9D001044  AFB10014   SW S1, 20(SP)
9D001048  AFB00010   SW S0, 16(SP)
460:                 	dcell d, n1=POP;
9D00104C  8F828008   LW V0, -32760(GP)
9D001050  8C500000   LW S0, 0(V0)
9D001054  00108FC3   SRA S1, S0, 31
9D001058  2452FFFC   ADDIU S2, V0, -4
461:                 	if (n1==0) {vErrors|=8; abortf();}
9D00105C  02111825   OR V1, S0, S1
9D001060  14600007   BNE V1, ZERO, 0x9D001080
9D001064  AF928008   SW S2, -32760(GP)
9D001068  9382806F   LBU V0, -32657(GP)
9D00106C  34420008   ORI V0, V0, 8
9D001070  0F400360   JAL abortf
9D001074  A382806F   SB V0, -32657(GP)
462:                 	else {DPOP(d); PUSH(d%n1); PUSH(d/n1);}
9D001080  8C54FFFC   LW S4, -4(V0)
9D001084  2642FFFC   ADDIU V0, S2, -4
9D001088  AF828008   SW V0, -32760(GP)
9D00108C  8E53FFFC   LW S3, -4(S2)
9D001090  02602021   ADDU A0, S3, ZERO
9D001094  02802821   ADDU A1, S4, ZERO
9D001098  02003021   ADDU A2, S0, ZERO
9D00109C  0F402B3F   JAL __moddi3
9D0010A0  02203821   ADDU A3, S1, ZERO
9D0010A4  AE42FFFC   SW V0, -4(S2)
9D0010A8  8F928008   LW S2, -32760(GP)
9D0010AC  26420004   ADDIU V0, S2, 4
9D0010B0  AF828008   SW V0, -32760(GP)
9D0010B4  02602021   ADDU A0, S3, ZERO
9D0010B8  02802821   ADDU A1, S4, ZERO
9D0010BC  02003021   ADDU A2, S0, ZERO
9D0010C0  0F402DAA   JAL __divdi3
9D0010C4  02203821   ADDU A3, S1, ZERO
9D0010C8  AE420004   SW V0, 4(S2)
463:                 } 
9D001078  0B400434   J 0x9D0010D0
9D00107C  8FBF0024   LW RA, 36(SP)
9D0010CC  8FBF0024   LW RA, 36(SP)
9D0010D0  8FB40020   LW S4, 32(SP)
9D0010D4  8FB3001C   LW S3, 28(SP)
9D0010D8  8FB20018   LW S2, 24(SP)
9D0010DC  8FB10014   LW S1, 20(SP)
9D0010E0  8FB00010   LW S0, 16(SP)
9D0010E4  03E00008   JR RA
9D0010E8  27BD0028   ADDIU SP, SP, 40
464:                 
465:                 
466:                 // u/mod ( u1 u2 -- rem u )
467:                 void udivmod(void)
468:                 {
9D000FD8  27BDFFE8   ADDIU SP, SP, -24
9D000FDC  AFBF0014   SW RA, 20(SP)
469:                 	ucell u2=TOS, u1=TOSi(1);
9D000FE0  8F828008   LW V0, -32760(GP)
9D000FE4  8C430000   LW V1, 0(V0)
470:                 	if (u2==0) {vErrors|=8; abortf();}
9D000FE8  14600007   BNE V1, ZERO, 0x9D001008
9D000FEC  8C44FFFC   LW A0, -4(V0)
9D000FF0  9382806F   LBU V0, -32657(GP)
9D000FF4  34420008   ORI V0, V0, 8
9D000FF8  0F400360   JAL abortf
9D000FFC  A382806F   SB V0, -32657(GP)
471:                 	else {TOSi(1)=u1%u2; TOS=u1/u2;}
9D001008  0083001B   DIVU A0, V1
9D00100C  006001F4   TEQ V1, ZERO
9D001010  00001810   MFHI V1, 0
9D001014  00002012   MFLO A0, 0
9D001018  AC43FFFC   SW V1, -4(V0)
9D00101C  8F828008   LW V0, -32760(GP)
9D001020  AC440000   SW A0, 0(V0)
472:                 } 
9D001000  0B40040A   J 0x9D001028
9D001004  8FBF0014   LW RA, 20(SP)
9D001024  8FBF0014   LW RA, 20(SP)
9D001028  03E00008   JR RA
9D00102C  27BD0018   ADDIU SP, SP, 24
473:                 
474:                 
475:                 // /mod ( n1 n2 -- rem n )
476:                 void divmod(void)
477:                 {
9D000F80  27BDFFE8   ADDIU SP, SP, -24
9D000F84  AFBF0014   SW RA, 20(SP)
478:                 	cell n2=TOS, n1=TOSi(1);
9D000F88  8F828008   LW V0, -32760(GP)
9D000F8C  8C430000   LW V1, 0(V0)
479:                 	if (n2==0) {vErrors|=8; abortf();}
9D000F90  14600007   BNE V1, ZERO, 0x9D000FB0
9D000F94  8C44FFFC   LW A0, -4(V0)
9D000F98  9382806F   LBU V0, -32657(GP)
9D000F9C  34420008   ORI V0, V0, 8
9D000FA0  0F400360   JAL abortf
9D000FA4  A382806F   SB V0, -32657(GP)
480:                 	else {TOSi(1)=n1%n2; TOS=n1/n2;}
9D000FB0  0083001A   DIV A0, V1
9D000FB4  006001F4   TEQ V1, ZERO
9D000FB8  00001810   MFHI V1, 0
9D000FBC  00002012   MFLO A0, 0
9D000FC0  AC43FFFC   SW V1, -4(V0)
9D000FC4  8F828008   LW V0, -32760(GP)
9D000FC8  AC440000   SW A0, 0(V0)
481:                 } 
9D000FA8  0B4003F4   J 0x9D000FD0
9D000FAC  8FBF0014   LW RA, 20(SP)
9D000FCC  8FBF0014   LW RA, 20(SP)
9D000FD0  03E00008   JR RA
9D000FD4  27BD0018   ADDIU SP, SP, 24
482:                 
483:                 
484:                 //  / ( n1 n2 -- n )
485:                 void divf(void)
486:                 {
9D000F2C  27BDFFE8   ADDIU SP, SP, -24
9D000F30  AFBF0014   SW RA, 20(SP)
487:                 	cell n2=POP, n1=TOS;
9D000F34  8F828008   LW V0, -32760(GP)
9D000F38  8C430000   LW V1, 0(V0)
9D000F3C  2444FFFC   ADDIU A0, V0, -4
9D000F40  AF848008   SW A0, -32760(GP)
488:                 	if (n2==0) {vErrors|=8; abortf();}
9D000F44  14600007   BNE V1, ZERO, 0x9D000F64
9D000F48  8C44FFFC   LW A0, -4(V0)
9D000F4C  9382806F   LBU V0, -32657(GP)
9D000F50  34420008   ORI V0, V0, 8
9D000F54  0F400360   JAL abortf
9D000F58  A382806F   SB V0, -32657(GP)
489:                 	else {TOS=n1/n2;}
9D000F64  0083001A   DIV A0, V1
9D000F68  006001F4   TEQ V1, ZERO
9D000F6C  00002012   MFLO A0, 0
9D000F70  AC44FFFC   SW A0, -4(V0)
490:                 } 
9D000F5C  0B4003DE   J 0x9D000F78
9D000F60  8FBF0014   LW RA, 20(SP)
9D000F74  8FBF0014   LW RA, 20(SP)
9D000F78  03E00008   JR RA
9D000F7C  27BD0018   ADDIU SP, SP, 24
491:                 
492:                 
493:                 // mod ( n1 n2 -- rem )
494:                 void modn(void)
495:                 {
9D000ED8  27BDFFE8   ADDIU SP, SP, -24
9D000EDC  AFBF0014   SW RA, 20(SP)
496:                 	cell n2=POP, n1=TOS;
9D000EE0  8F828008   LW V0, -32760(GP)
9D000EE4  8C430000   LW V1, 0(V0)
9D000EE8  2444FFFC   ADDIU A0, V0, -4
9D000EEC  AF848008   SW A0, -32760(GP)
497:                 	if (n2==0) {vErrors|=8; abortf();}
9D000EF0  14600007   BNE V1, ZERO, 0x9D000F10
9D000EF4  8C44FFFC   LW A0, -4(V0)
9D000EF8  9382806F   LBU V0, -32657(GP)
9D000EFC  34420008   ORI V0, V0, 8
9D000F00  0F400360   JAL abortf
9D000F04  A382806F   SB V0, -32657(GP)
498:                 	else {TOS=n1%n2;}
9D000F10  0083001A   DIV A0, V1
9D000F14  006001F4   TEQ V1, ZERO
9D000F18  00001810   MFHI V1, 0
9D000F1C  AC43FFFC   SW V1, -4(V0)
499:                 } 
9D000F08  0B4003C9   J 0x9D000F24
9D000F0C  8FBF0014   LW RA, 20(SP)
9D000F20  8FBF0014   LW RA, 20(SP)
9D000F24  03E00008   JR RA
9D000F28  27BD0018   ADDIU SP, SP, 24
500:                 
501:                 
502:                 // u*/ ( u1 u2 u3 -- u )
503:                 void umuldiv(void)
504:                 {
9D000E3C  27BDFFE8   ADDIU SP, SP, -24
9D000E40  AFBF0014   SW RA, 20(SP)
9D000E44  AFB00010   SW S0, 16(SP)
505:                 	udcell u3=POP, u2=POP, u1=POP;
9D000E48  8F908008   LW S0, -32760(GP)
9D000E4C  8E060000   LW A2, 0(S0)
9D000E50  00063FC3   SRA A3, A2, 31
9D000E54  2602FFFC   ADDIU V0, S0, -4
9D000E58  AF828008   SW V0, -32760(GP)
9D000E5C  8E02FFFC   LW V0, -4(S0)
9D000E60  2603FFF8   ADDIU V1, S0, -8
9D000E64  AF838008   SW V1, -32760(GP)
9D000E68  8E04FFF8   LW A0, -8(S0)
9D000E6C  2610FFF4   ADDIU S0, S0, -12
9D000E9C  00042FC3   SRA A1, A0, 31
9D000EA0  00021FC3   SRA V1, V0, 31
506:                 	if (u3==0) {vErrors|=8; abortf();}
9D000E70  00C71825   OR V1, A2, A3
9D000E74  14600007   BNE V1, ZERO, 0x9D000E94
9D000E78  AF908008   SW S0, -32760(GP)
9D000E7C  9382806F   LBU V0, -32657(GP)
9D000E80  34420008   ORI V0, V0, 8
9D000E84  0F400360   JAL abortf
9D000E88  A382806F   SB V0, -32657(GP)
507:                 	else {PUSH((u1*u2)/u3);}
9D000E94  26030004   ADDIU V1, S0, 4
9D000E98  AF838008   SW V1, -32760(GP)
9D000EA4  00640018   MULT 0, V1, A0
9D000EA8  70A20000   MADD 0, A1, V0
9D000EAC  00001812   MFLO V1, 0
9D000EB0  00820019   MULTU 0, A0, V0
9D000EB4  00002012   MFLO A0, 0
9D000EB8  00002810   MFHI A1, 0
9D000EBC  0F402FEC   JAL __udivdi3
9D000EC0  00652821   ADDU A1, V1, A1
9D000EC4  AE020004   SW V0, 4(S0)
508:                 }
9D000E8C  0B4003B3   J 0x9D000ECC
9D000E90  8FBF0014   LW RA, 20(SP)
9D000EC8  8FBF0014   LW RA, 20(SP)
9D000ECC  8FB00010   LW S0, 16(SP)
9D000ED0  03E00008   JR RA
9D000ED4  27BD0018   ADDIU SP, SP, 24
509:                 
510:                 
511:                 // */ ( n1 n2 n3 -- n )
512:                 void muldiv(void)
513:                 {
9D000DA0  27BDFFE8   ADDIU SP, SP, -24
9D000DA4  AFBF0014   SW RA, 20(SP)
9D000DA8  AFB00010   SW S0, 16(SP)
514:                 	dcell n3=POP, n2=POP, n1=POP;
9D000DAC  8F908008   LW S0, -32760(GP)
9D000DB0  8E060000   LW A2, 0(S0)
9D000DB4  00063FC3   SRA A3, A2, 31
9D000DB8  2602FFFC   ADDIU V0, S0, -4
9D000DBC  AF828008   SW V0, -32760(GP)
9D000DC0  8E02FFFC   LW V0, -4(S0)
9D000DC4  2603FFF8   ADDIU V1, S0, -8
9D000DC8  AF838008   SW V1, -32760(GP)
9D000DCC  8E04FFF8   LW A0, -8(S0)
9D000DD0  2610FFF4   ADDIU S0, S0, -12
9D000E00  00042FC3   SRA A1, A0, 31
9D000E04  00021FC3   SRA V1, V0, 31
515:                 	if (n3==0) {vErrors|=8; abortf();}
9D000DD4  00C71825   OR V1, A2, A3
9D000DD8  14600007   BNE V1, ZERO, 0x9D000DF8
9D000DDC  AF908008   SW S0, -32760(GP)
9D000DE0  9382806F   LBU V0, -32657(GP)
9D000DE4  34420008   ORI V0, V0, 8
9D000DE8  0F400360   JAL abortf
9D000DEC  A382806F   SB V0, -32657(GP)
516:                 	else {PUSH((n1*n2)/n3);}
9D000DF8  26030004   ADDIU V1, S0, 4
9D000DFC  AF838008   SW V1, -32760(GP)
9D000E08  00640018   MULT 0, V1, A0
9D000E0C  70A20000   MADD 0, A1, V0
9D000E10  00001812   MFLO V1, 0
9D000E14  00820019   MULTU 0, A0, V0
9D000E18  00002012   MFLO A0, 0
9D000E1C  00002810   MFHI A1, 0
9D000E20  0F402DAA   JAL __divdi3
9D000E24  00652821   ADDU A1, V1, A1
9D000E28  AE020004   SW V0, 4(S0)
517:                 }
9D000DF0  0B40038C   J 0x9D000E30
9D000DF4  8FBF0014   LW RA, 20(SP)
9D000E2C  8FBF0014   LW RA, 20(SP)
9D000E30  8FB00010   LW S0, 16(SP)
9D000E34  03E00008   JR RA
9D000E38  27BD0018   ADDIU SP, SP, 24
518:                 
519:                 
520:                 // >>a ( n1 u -- n )
521:                 void arshift(void) {ucell u=POP; TOS=(cell)TOS>>u;}
9D000608  8F828008   LW V0, -32760(GP)
9D00060C  8C430000   LW V1, 0(V0)
9D000610  2444FFFC   ADDIU A0, V0, -4
9D000614  AF848008   SW A0, -32760(GP)
9D000618  8C44FFFC   LW A0, -4(V0)
9D00061C  00641807   SRAV V1, A0, V1
9D000620  03E00008   JR RA
9D000624  AC43FFFC   SW V1, -4(V0)
522:                 
523:                 
524:                 // >> ( x1 u -- x )
525:                 void rshift(void) {ucell u=POP; TOS=(ucell)TOS>>u;}
9D000628  8F828008   LW V0, -32760(GP)
9D00062C  8C430000   LW V1, 0(V0)
9D000630  2444FFFC   ADDIU A0, V0, -4
9D000634  AF848008   SW A0, -32760(GP)
9D000638  8C44FFFC   LW A0, -4(V0)
9D00063C  00641806   SRLV V1, A0, V1
9D000640  03E00008   JR RA
9D000644  AC43FFFC   SW V1, -4(V0)
526:                 
527:                 
528:                 // << ( x1 u -- x )
529:                 void lshift(void) {ucell u=POP; TOS=(ucell)TOS<<u;}
9D000648  8F828008   LW V0, -32760(GP)
9D00064C  8C430000   LW V1, 0(V0)
9D000650  2444FFFC   ADDIU A0, V0, -4
9D000654  AF848008   SW A0, -32760(GP)
9D000658  8C44FFFC   LW A0, -4(V0)
9D00065C  00641804   SLLV V1, A0, V1
9D000660  03E00008   JR RA
9D000664  AC43FFFC   SW V1, -4(V0)
530:                 
531:                 
532:                 // 2* ( n1 -- n )
533:                 void twomul(void) {TOS=TOS<<1;}
9D000668  8F828008   LW V0, -32760(GP)
9D00066C  8C430000   LW V1, 0(V0)
9D000670  00031840   SLL V1, V1, 1
9D000674  03E00008   JR RA
9D000678  AC430000   SW V1, 0(V0)
534:                 
535:                 
536:                 // 2/ ( n1 -- n )
537:                 void twodiv(void) {TOS=TOS>>1;}
9D00067C  8F828008   LW V0, -32760(GP)
9D000680  8C430000   LW V1, 0(V0)
9D000684  00031843   SRA V1, V1, 1
9D000688  03E00008   JR RA
9D00068C  AC430000   SW V1, 0(V0)
538:                 
539:                 
540:                 // min ( n1 n2 -- n1|n2 )
541:                 void minf(void) {cell n2=POP; TOS=(n2<TOS) ? n2:TOS;}
9D000690  8F828008   LW V0, -32760(GP)
9D000694  8C430000   LW V1, 0(V0)
9D000698  2444FFFC   ADDIU A0, V0, -4
9D00069C  AF848008   SW A0, -32760(GP)
9D0006A0  8C44FFFC   LW A0, -4(V0)
9D0006A4  0064282A   SLT A1, V1, A0
9D0006A8  0085180A   MOVZ V1, A0, A1
9D0006AC  03E00008   JR RA
9D0006B0  AC43FFFC   SW V1, -4(V0)
542:                 
543:                 
544:                 // max ( n1 n2 -- n1|n2 )
545:                 void maxf(void) {cell n2=POP; TOS=(n2>TOS) ? n2:TOS;}
9D0006B4  8F828008   LW V0, -32760(GP)
9D0006B8  8C430000   LW V1, 0(V0)
9D0006BC  2444FFFC   ADDIU A0, V0, -4
9D0006C0  AF848008   SW A0, -32760(GP)
9D0006C4  8C44FFFC   LW A0, -4(V0)
9D0006C8  0083282A   SLT A1, A0, V1
9D0006CC  0085180A   MOVZ V1, A0, A1
9D0006D0  03E00008   JR RA
9D0006D4  AC43FFFC   SW V1, -4(V0)
546:                 
547:                 
548:                 // abs ( n -- u )
549:                 void absf(void) {TOS=(TOS<0) ? -TOS:TOS;}
9D0006D8  8F828008   LW V0, -32760(GP)
9D0006DC  8C440000   LW A0, 0(V0)
9D0006E0  00041FC3   SRA V1, A0, 31
9D0006E4  00832026   XOR A0, A0, V1
9D0006E8  00831823   SUBU V1, A0, V1
9D0006EC  03E00008   JR RA
9D0006F0  AC430000   SW V1, 0(V0)
550:                 
551:                 
552:                 // 1+ ( n1 -- n )
553:                 void incf(void) {TOS++;} 
9D0006F4  8F828008   LW V0, -32760(GP)
9D0006F8  8C430000   LW V1, 0(V0)
9D0006FC  24630001   ADDIU V1, V1, 1
9D000700  03E00008   JR RA
9D000704  AC430000   SW V1, 0(V0)
554:                 
555:                 
556:                 // 1- ( n1 -- n )
557:                 void decf(void) {TOS--;} 
9D000708  8F828008   LW V0, -32760(GP)
9D00070C  8C430000   LW V1, 0(V0)
9D000710  2463FFFF   ADDIU V1, V1, -1
9D000714  03E00008   JR RA
9D000718  AC430000   SW V1, 0(V0)
558:                 
559:                 
560:                 // negate ( n1 -- n )
561:                 void negate(void) {TOS=-TOS;} 
9D00071C  8F828008   LW V0, -32760(GP)
9D000720  8C430000   LW V1, 0(V0)
9D000724  00031823   SUBU V1, ZERO, V1
9D000728  03E00008   JR RA
9D00072C  AC430000   SW V1, 0(V0)
562:                 
563:                 
564:                 // invert ( n1 -- n )
565:                 void invert(void) {TOS=TOS^-1;} 
9D000730  8F828008   LW V0, -32760(GP)
9D000734  8C430000   LW V1, 0(V0)
9D000738  00031827   NOR V1, ZERO, V1
9D00073C  03E00008   JR RA
9D000740  AC430000   SW V1, 0(V0)
566:                 
567:                 
568:                 // and ( x1 x2 -- x )
569:                 void andf(void) {cell x2=POP; TOS=TOS&x2;}
9D000744  8F828008   LW V0, -32760(GP)
9D000748  8C430000   LW V1, 0(V0)
9D00074C  2444FFFC   ADDIU A0, V0, -4
9D000750  AF848008   SW A0, -32760(GP)
9D000754  8C44FFFC   LW A0, -4(V0)
9D000758  00831824   AND V1, A0, V1
9D00075C  03E00008   JR RA
9D000760  AC43FFFC   SW V1, -4(V0)
570:                 
571:                 
572:                 // or ( x1 x2 -- x )
573:                 void orf(void) {cell x2=POP; TOS=TOS|x2;}
9D000764  8F828008   LW V0, -32760(GP)
9D000768  8C430000   LW V1, 0(V0)
9D00076C  2444FFFC   ADDIU A0, V0, -4
9D000770  AF848008   SW A0, -32760(GP)
9D000774  8C44FFFC   LW A0, -4(V0)
9D000778  00831825   OR V1, A0, V1
9D00077C  03E00008   JR RA
9D000780  AC43FFFC   SW V1, -4(V0)
574:                 
575:                 
576:                 // xor ( x1 x2 -- x )
577:                 void xorf(void) {cell x2=POP; TOS=TOS^x2;}
9D000784  8F828008   LW V0, -32760(GP)
9D000788  8C430000   LW V1, 0(V0)
9D00078C  2444FFFC   ADDIU A0, V0, -4
9D000790  AF848008   SW A0, -32760(GP)
9D000794  8C44FFFC   LW A0, -4(V0)
9D000798  00831826   XOR V1, A0, V1
9D00079C  03E00008   JR RA
9D0007A0  AC43FFFC   SW V1, -4(V0)
578:                 
579:                 
580:                 // ********** LOGIC **********
581:                 
582:                 
583:                 // andl ( x1 x2 -- fl )
584:                 void andl(void) {cell x2=POP; TOS=(x2&&TOS) ? -1:0;;}
9D0007A4  8F828008   LW V0, -32760(GP)
9D0007A8  8C440000   LW A0, 0(V0)
9D0007AC  2443FFFC   ADDIU V1, V0, -4
9D0007B0  AF838008   SW V1, -32760(GP)
9D0007B4  10800004   BEQ A0, ZERO, 0x9D0007C8
9D0007B8  00001821   ADDU V1, ZERO, ZERO
9D0007BC  8C44FFFC   LW A0, -4(V0)
9D0007C0  2403FFFF   ADDIU V1, ZERO, -1
9D0007C4  0004180A   MOVZ V1, ZERO, A0
9D0007C8  03E00008   JR RA
9D0007CC  AC43FFFC   SW V1, -4(V0)
585:                 
586:                 
587:                 // orl ( x1 x2 -- fl )
588:                 void orl(void) {cell x2=POP; TOS=(x2||TOS) ? -1:0;}
9D0007D0  8F828008   LW V0, -32760(GP)
9D0007D4  8C440000   LW A0, 0(V0)
9D0007D8  2443FFFC   ADDIU V1, V0, -4
9D0007DC  AF838008   SW V1, -32760(GP)
9D0007E0  14800003   BNE A0, ZERO, 0x9D0007F0
9D0007E4  2403FFFF   ADDIU V1, ZERO, -1
9D0007E8  8C44FFFC   LW A0, -4(V0)
9D0007EC  0004180A   MOVZ V1, ZERO, A0
9D0007F0  03E00008   JR RA
9D0007F4  AC43FFFC   SW V1, -4(V0)
589:                 
590:                 
591:                 // not ( x1 -- fl )
592:                 void notl(void) {TOS=(TOS) ? 0:-1;}
9D0007F8  8F828008   LW V0, -32760(GP)
9D0007FC  8C440000   LW A0, 0(V0)
9D000800  2403FFFF   ADDIU V1, ZERO, -1
9D000804  0004180B   MOVN V1, ZERO, A0
9D000808  03E00008   JR RA
9D00080C  AC430000   SW V1, 0(V0)
593:                 
594:                 
595:                 // = ( n1 n2 -- fl )
596:                 void equals(void) {cell n2=POP;	TOS=(TOS==n2) ? -1:0;}
9D000810  8F828008   LW V0, -32760(GP)
9D000814  8C430000   LW V1, 0(V0)
9D000818  2444FFFC   ADDIU A0, V0, -4
9D00081C  AF848008   SW A0, -32760(GP)
9D000820  8C44FFFC   LW A0, -4(V0)
9D000824  00831826   XOR V1, A0, V1
9D000828  2404FFFF   ADDIU A0, ZERO, -1
9D00082C  0003200B   MOVN A0, ZERO, V1
9D000830  03E00008   JR RA
9D000834  AC44FFFC   SW A0, -4(V0)
597:                 
598:                 
599:                 // <> ( n1 n2 -- fl )
600:                 void notequals(void) {cell n2=POP; TOS=(TOS!=n2) ? -1:0;}
9D000838  8F828008   LW V0, -32760(GP)
9D00083C  8C430000   LW V1, 0(V0)
9D000840  2444FFFC   ADDIU A0, V0, -4
9D000844  AF848008   SW A0, -32760(GP)
9D000848  8C44FFFC   LW A0, -4(V0)
9D00084C  00831826   XOR V1, A0, V1
9D000850  2404FFFF   ADDIU A0, ZERO, -1
9D000854  0003200A   MOVZ A0, ZERO, V1
9D000858  03E00008   JR RA
9D00085C  AC44FFFC   SW A0, -4(V0)
601:                 
602:                 
603:                 // > ( n1 n2 -- fl )
604:                 void greater(void) {cell n2=POP; TOS=(TOS>n2) ? -1:0;}
9D000860  8F828008   LW V0, -32760(GP)
9D000864  8C440000   LW A0, 0(V0)
9D000868  2443FFFC   ADDIU V1, V0, -4
9D00086C  AF838008   SW V1, -32760(GP)
9D000870  8C43FFFC   LW V1, -4(V0)
9D000874  0083182A   SLT V1, A0, V1
9D000878  2404FFFF   ADDIU A0, ZERO, -1
9D00087C  0003200A   MOVZ A0, ZERO, V1
9D000880  03E00008   JR RA
9D000884  AC44FFFC   SW A0, -4(V0)
605:                 
606:                 
607:                 // < ( n1 n2 -- fl )
608:                 void less(void) {cell n2=POP; TOS=(TOS<n2) ? -1:0;}
9D000888  8F828008   LW V0, -32760(GP)
9D00088C  8C440000   LW A0, 0(V0)
9D000890  2443FFFC   ADDIU V1, V0, -4
9D000894  AF838008   SW V1, -32760(GP)
9D000898  8C43FFFC   LW V1, -4(V0)
9D00089C  0064182A   SLT V1, V1, A0
9D0008A0  2404FFFF   ADDIU A0, ZERO, -1
9D0008A4  0003200A   MOVZ A0, ZERO, V1
9D0008A8  03E00008   JR RA
9D0008AC  AC44FFFC   SW A0, -4(V0)
609:                 
610:                 
611:                 // >= ( n1 n2 -- fl )
612:                 void greaterequals(void) {cell n2=POP; TOS=(TOS>=n2) ? -1:0;}
9D0008B0  8F828008   LW V0, -32760(GP)
9D0008B4  8C440000   LW A0, 0(V0)
9D0008B8  2443FFFC   ADDIU V1, V0, -4
9D0008BC  AF838008   SW V1, -32760(GP)
9D0008C0  8C43FFFC   LW V1, -4(V0)
9D0008C4  0064182A   SLT V1, V1, A0
9D0008C8  2404FFFF   ADDIU A0, ZERO, -1
9D0008CC  0003200B   MOVN A0, ZERO, V1
9D0008D0  03E00008   JR RA
9D0008D4  AC44FFFC   SW A0, -4(V0)
613:                 
614:                 
615:                 // <= ( n1 n2 -- fl )
616:                 void lessequals(void) {cell n2=POP;	TOS=(TOS<=n2) ? -1:0;}
9D0008D8  8F828008   LW V0, -32760(GP)
9D0008DC  8C440000   LW A0, 0(V0)
9D0008E0  2443FFFC   ADDIU V1, V0, -4
9D0008E4  AF838008   SW V1, -32760(GP)
9D0008E8  8C43FFFC   LW V1, -4(V0)
9D0008EC  0083182A   SLT V1, A0, V1
9D0008F0  2404FFFF   ADDIU A0, ZERO, -1
9D0008F4  0003200B   MOVN A0, ZERO, V1
9D0008F8  03E00008   JR RA
9D0008FC  AC44FFFC   SW A0, -4(V0)
617:                 
618:                 
619:                 // 0= ( x1 -- fl )
620:                 void zeroequals(void) {TOS=(TOS==0) ? -1:0;}
9D000900  8F828008   LW V0, -32760(GP)
9D000904  8C440000   LW A0, 0(V0)
9D000908  2403FFFF   ADDIU V1, ZERO, -1
9D00090C  0004180B   MOVN V1, ZERO, A0
9D000910  03E00008   JR RA
9D000914  AC430000   SW V1, 0(V0)
621:                 
622:                 
623:                 // 0< ( n1 -- fl )
624:                 void zeroless(void) {TOS=(TOS<0) ? -1:0;}
9D000918  8F828008   LW V0, -32760(GP)
9D00091C  8C430000   LW V1, 0(V0)
9D000920  28630000   SLTI V1, V1, 0
9D000924  2404FFFF   ADDIU A0, ZERO, -1
9D000928  0003200A   MOVZ A0, ZERO, V1
9D00092C  03E00008   JR RA
9D000930  AC440000   SW A0, 0(V0)
625:                 
626:                 
627:                 // 0> ( x1 -- fl )
628:                 void zerogreater(void) {TOS=(TOS>0) ? -1:0;}
9D000934  8F828008   LW V0, -32760(GP)
9D000938  8C430000   LW V1, 0(V0)
9D00093C  28630001   SLTI V1, V1, 1
9D000940  2404FFFF   ADDIU A0, ZERO, -1
9D000944  0003200B   MOVN A0, ZERO, V1
9D000948  03E00008   JR RA
9D00094C  AC440000   SW A0, 0(V0)
629:                 
630:                 
631:                 // u> ( u1 u2 -- fl )
632:                 void ugreater(void) {ucell u2=POP; TOS=((ucell)TOS>u2) ? -1:0;}
9D000950  8F828008   LW V0, -32760(GP)
9D000954  8C440000   LW A0, 0(V0)
9D000958  2443FFFC   ADDIU V1, V0, -4
9D00095C  AF838008   SW V1, -32760(GP)
9D000960  8C43FFFC   LW V1, -4(V0)
9D000964  0083182B   SLTU V1, A0, V1
9D000968  2404FFFF   ADDIU A0, ZERO, -1
9D00096C  0003200A   MOVZ A0, ZERO, V1
9D000970  03E00008   JR RA
9D000974  AC44FFFC   SW A0, -4(V0)
633:                 
634:                 
635:                 // u< ( u1 u2 -- fl )
636:                 void uless(void) {ucell u2=POP;	TOS=((ucell)TOS<u2) ? -1:0;}
9D000978  8F828008   LW V0, -32760(GP)
9D00097C  8C440000   LW A0, 0(V0)
9D000980  2443FFFC   ADDIU V1, V0, -4
9D000984  AF838008   SW V1, -32760(GP)
9D000988  8C43FFFC   LW V1, -4(V0)
9D00098C  0064182B   SLTU V1, V1, A0
9D000990  2404FFFF   ADDIU A0, ZERO, -1
9D000994  0003200A   MOVZ A0, ZERO, V1
9D000998  03E00008   JR RA
9D00099C  AC44FFFC   SW A0, -4(V0)
637:                 
638:                 
639:                 // u>= ( u1 u2 -- fl )
640:                 void ugreaterequals(void) {ucell u2=POP; TOS=((ucell)TOS>=u2) ? -1:0;}
9D0009A0  8F828008   LW V0, -32760(GP)
9D0009A4  8C440000   LW A0, 0(V0)
9D0009A8  2443FFFC   ADDIU V1, V0, -4
9D0009AC  AF838008   SW V1, -32760(GP)
9D0009B0  8C43FFFC   LW V1, -4(V0)
9D0009B4  0064182B   SLTU V1, V1, A0
9D0009B8  2404FFFF   ADDIU A0, ZERO, -1
9D0009BC  0003200B   MOVN A0, ZERO, V1
9D0009C0  03E00008   JR RA
9D0009C4  AC44FFFC   SW A0, -4(V0)
641:                 
642:                 
643:                 // u<= ( u1 u2 -- fl )
644:                 void ulessequals(void) {ucell u2=POP; TOS=((ucell)TOS<=u2) ? -1:0;}
9D0009C8  8F828008   LW V0, -32760(GP)
9D0009CC  8C440000   LW A0, 0(V0)
9D0009D0  2443FFFC   ADDIU V1, V0, -4
9D0009D4  AF838008   SW V1, -32760(GP)
9D0009D8  8C43FFFC   LW V1, -4(V0)
9D0009DC  0083182B   SLTU V1, A0, V1
9D0009E0  2404FFFF   ADDIU A0, ZERO, -1
9D0009E4  0003200B   MOVN A0, ZERO, V1
9D0009E8  03E00008   JR RA
9D0009EC  AC44FFFC   SW A0, -4(V0)
645:                 
646:                 
647:                 // d= ( d1 d2 -- fl )
648:                 void dequals(void)
649:                 {
650:                 	dcell d1, d2;
651:                 	DPOP(d2); DPOP(d1);
9D0009F0  8F828008   LW V0, -32760(GP)
9D0009F4  8C440000   LW A0, 0(V0)
9D0009F8  2443FFFC   ADDIU V1, V0, -4
9D0009FC  AF838008   SW V1, -32760(GP)
9D000A00  8C43FFFC   LW V1, -4(V0)
9D000A04  00803021   ADDU A2, A0, ZERO
9D000A08  2444FFF8   ADDIU A0, V0, -8
9D000A0C  AF848008   SW A0, -32760(GP)
9D000A10  8C45FFF8   LW A1, -8(V0)
9D000A14  2444FFF4   ADDIU A0, V0, -12
9D000A18  AF848008   SW A0, -32760(GP)
9D000A1C  8C44FFF4   LW A0, -12(V0)
9D000A20  00A03821   ADDU A3, A1, ZERO
9D000A24  2445FFF0   ADDIU A1, V0, -16
652:                 	TOS=(d1==d2) ? -1:0;
9D000A28  14830003   BNE A0, V1, 0x9D000A38
9D000A2C  AF858008   SW A1, -32760(GP)
9D000A30  10E60002   BEQ A3, A2, 0x9D000A3C
9D000A34  2403FFFF   ADDIU V1, ZERO, -1
9D000A38  00001821   ADDU V1, ZERO, ZERO
653:                 }
9D000A3C  03E00008   JR RA
9D000A40  AC43FFF0   SW V1, -16(V0)
654:                 
655:                 
656:                 // d<> ( d1 d2 -- fl )
657:                 void dnotequals(void)
658:                 {
659:                 	dcell d1, d2;
660:                 	DPOP(d2); DPOP(d1);
9D000A44  8F828008   LW V0, -32760(GP)
9D000A48  8C440000   LW A0, 0(V0)
9D000A4C  2443FFFC   ADDIU V1, V0, -4
9D000A50  AF838008   SW V1, -32760(GP)
9D000A54  8C43FFFC   LW V1, -4(V0)
9D000A58  00803021   ADDU A2, A0, ZERO
9D000A5C  2444FFF8   ADDIU A0, V0, -8
9D000A60  AF848008   SW A0, -32760(GP)
9D000A64  8C45FFF8   LW A1, -8(V0)
9D000A68  2444FFF4   ADDIU A0, V0, -12
9D000A6C  AF848008   SW A0, -32760(GP)
9D000A70  8C44FFF4   LW A0, -12(V0)
9D000A74  00A03821   ADDU A3, A1, ZERO
9D000A78  2445FFF0   ADDIU A1, V0, -16
661:                 	TOS=(d1!=d2) ? -1:0;
9D000A7C  14830003   BNE A0, V1, 0x9D000A8C
9D000A80  AF858008   SW A1, -32760(GP)
9D000A84  10E60002   BEQ A3, A2, 0x9D000A90
9D000A88  00001821   ADDU V1, ZERO, ZERO
9D000A8C  2403FFFF   ADDIU V1, ZERO, -1
662:                 }
9D000A90  03E00008   JR RA
9D000A94  AC43FFF0   SW V1, -16(V0)
663:                 
664:                 
665:                 // d> ( d1 d2 -- fl )
666:                 void dgreater(void)
667:                 {
668:                 	dcell d1, d2;
669:                 	DPOP(d2); DPOP(d1);
9D000A98  8F828008   LW V0, -32760(GP)
9D000A9C  8C430000   LW V1, 0(V0)
9D000AA0  2444FFFC   ADDIU A0, V0, -4
9D000AA4  AF848008   SW A0, -32760(GP)
9D000AA8  8C48FFFC   LW T0, -4(V0)
9D000AAC  00603021   ADDU A2, V1, ZERO
9D000AB0  2444FFF8   ADDIU A0, V0, -8
9D000AB4  AF848008   SW A0, -32760(GP)
9D000AB8  8C44FFF8   LW A0, -8(V0)
9D000ABC  2445FFF4   ADDIU A1, V0, -12
9D000AC0  AF858008   SW A1, -32760(GP)
9D000AC4  8C49FFF4   LW T1, -12(V0)
9D000AC8  2445FFF0   ADDIU A1, V0, -16
670:                 	TOS=(d1>d2) ? -1:0;
9D000ACC  0064182A   SLT V1, V1, A0
9D000AD0  14600006   BNE V1, ZERO, 0x9D000AEC
9D000AD4  AF858008   SW A1, -32760(GP)
9D000AD8  14860005   BNE A0, A2, 0x9D000AF0
9D000ADC  00001821   ADDU V1, ZERO, ZERO
9D000AE0  0109402B   SLTU T0, T0, T1
9D000AE4  51000004   BEQL T0, ZERO, 0x9D000AF8
9D000AE8  AC43FFF0   SW V1, -16(V0)
9D000AEC  2403FFFF   ADDIU V1, ZERO, -1
671:                 }
9D000AF0  03E00008   JR RA
9D000AF4  AC43FFF0   SW V1, -16(V0)
9D000AF8  03E00008   JR RA
9D000AFC  00000000   NOP
672:                 
673:                 
674:                 // d< ( d1 d2 -- fl )
675:                 void dless(void)
676:                 {
677:                 	dcell d1, d2;
678:                 	DPOP(d2); DPOP(d1);
9D000B00  8F828008   LW V0, -32760(GP)
9D000B04  8C440000   LW A0, 0(V0)
9D000B08  2443FFFC   ADDIU V1, V0, -4
9D000B0C  AF838008   SW V1, -32760(GP)
9D000B10  8C49FFFC   LW T1, -4(V0)
9D000B14  2443FFF8   ADDIU V1, V0, -8
9D000B18  AF838008   SW V1, -32760(GP)
9D000B1C  8C43FFF8   LW V1, -8(V0)
9D000B20  2445FFF4   ADDIU A1, V0, -12
9D000B24  AF858008   SW A1, -32760(GP)
9D000B28  8C48FFF4   LW T0, -12(V0)
9D000B2C  00603021   ADDU A2, V1, ZERO
9D000B30  2445FFF0   ADDIU A1, V0, -16
679:                 	TOS=(d1<d2) ? -1:0;
9D000B34  0064182A   SLT V1, V1, A0
9D000B38  14600006   BNE V1, ZERO, 0x9D000B54
9D000B3C  AF858008   SW A1, -32760(GP)
9D000B40  14860005   BNE A0, A2, 0x9D000B58
9D000B44  00001821   ADDU V1, ZERO, ZERO
9D000B48  0109402B   SLTU T0, T0, T1
9D000B4C  51000004   BEQL T0, ZERO, 0x9D000B60
9D000B50  AC43FFF0   SW V1, -16(V0)
9D000B54  2403FFFF   ADDIU V1, ZERO, -1
680:                 }
9D000B58  03E00008   JR RA
9D000B5C  AC43FFF0   SW V1, -16(V0)
9D000B60  03E00008   JR RA
9D000B64  00000000   NOP
681:                 
682:                 
683:                 // within ( u min max -- fl )
684:                 void within(void)  // min <= u <max
685:                 {
686:                 	ucell u2=POP, u1=POP, u=TOS;
9D000B68  8F828008   LW V0, -32760(GP)
9D000B6C  8C450000   LW A1, 0(V0)
9D000B70  2443FFFC   ADDIU V1, V0, -4
9D000B74  AF838008   SW V1, -32760(GP)
9D000B78  8C43FFFC   LW V1, -4(V0)
9D000B7C  2444FFF8   ADDIU A0, V0, -8
9D000B80  AF848008   SW A0, -32760(GP)
687:                 	TOS=((u-u1)<(u2-u1)) ? -1:0;
9D000B84  8C44FFF8   LW A0, -8(V0)
9D000B88  00832023   SUBU A0, A0, V1
9D000B8C  00A31823   SUBU V1, A1, V1
9D000B90  0083182B   SLTU V1, A0, V1
9D000B94  2404FFFF   ADDIU A0, ZERO, -1
9D000B98  0003200A   MOVZ A0, ZERO, V1
688:                 }
9D000B9C  03E00008   JR RA
9D000BA0  AC44FFF8   SW A0, -8(V0)
689:                 
690:                 
691:                 // ********** HIGH FORTH **********
692:                 
693:                 // ********** VARIABLE **********
694:                 
695:                 
696:                 // tib ( -- addr )
697:                 void tib(void) {PUSH((ucell)vTib);}
9D000BA4  8F828008   LW V0, -32760(GP)
9D000BA8  24430004   ADDIU V1, V0, 4
9D000BAC  AF838008   SW V1, -32760(GP)
9D000BB0  8F83805C   LW V1, -32676(GP)
9D000BB4  03E00008   JR RA
9D000BB8  AC430004   SW V1, 4(V0)
698:                 
699:                 
700:                 // #tib ( -- addr )
701:                 void sharptib(void) {PUSH((ucell)&vSharpTib);}
9D000BBC  8F828008   LW V0, -32760(GP)
9D000BC0  24430004   ADDIU V1, V0, 4
9D000BC4  AF838008   SW V1, -32760(GP)
9D000BC8  2783806D   ADDIU V1, GP, -32659
9D000BCC  03E00008   JR RA
9D000BD0  AC430004   SW V1, 4(V0)
702:                 
703:                 
704:                 // >in ( -- addr )
705:                 void gin(void) {PUSH((ucell)&vIN);}
9D000BD4  8F828008   LW V0, -32760(GP)
9D000BD8  24430004   ADDIU V1, V0, 4
9D000BDC  AF838008   SW V1, -32760(GP)
9D000BE0  2783806C   ADDIU V1, GP, -32660
9D000BE4  03E00008   JR RA
9D000BE8  AC430004   SW V1, 4(V0)
706:                 
707:                 
708:                 // base ( -- addr )
709:                 void base(void)
710:                 {PUSH((ucell)&vBase); vBase=(vBase<2) ? 2:vBase; vBase=(vBase>32) ? 32:vBase;}
9D000BEC  8F828008   LW V0, -32760(GP)
9D000BF0  24430004   ADDIU V1, V0, 4
9D000BF4  AF838008   SW V1, -32760(GP)
9D000BF8  27838014   ADDIU V1, GP, -32748
9D000BFC  AC430004   SW V1, 4(V0)
9D000C00  93828014   LBU V0, -32748(GP)
9D000C04  304300FF   ANDI V1, V0, 255
9D000C08  2C630002   SLTIU V1, V1, 2
9D000C0C  54600001   BNEL V1, ZERO, 0x9D000C14
9D000C10  24020002   ADDIU V0, ZERO, 2
9D000C14  00401821   ADDU V1, V0, ZERO
9D000C18  304200FF   ANDI V0, V0, 255
9D000C1C  2C420021   SLTIU V0, V0, 33
9D000C20  50400001   BEQL V0, ZERO, 0x9D000C28
9D000C24  24030020   ADDIU V1, ZERO, 32
9D000C28  03E00008   JR RA
9D000C2C  A3838014   SB V1, -32748(GP)
711:                 
712:                 
713:                 // state ( -- addr )
714:                 void state(void) {PUSH((ucell)&vState);}
9D000C30  8F828008   LW V0, -32760(GP)
9D000C34  24430004   ADDIU V1, V0, 4
9D000C38  AF838008   SW V1, -32760(GP)
9D000C3C  2783806E   ADDIU V1, GP, -32658
9D000C40  03E00008   JR RA
9D000C44  AC430004   SW V1, 4(V0)
715:                 
716:                 
717:                 // pad ( -- addr )
718:                 void pad(void) {PUSH((ucell)vPad);}
9D000C48  8F828008   LW V0, -32760(GP)
9D000C4C  24430004   ADDIU V1, V0, 4
9D000C50  AF838008   SW V1, -32760(GP)
9D000C54  8F838060   LW V1, -32672(GP)
9D000C58  03E00008   JR RA
9D000C5C  AC430004   SW V1, 4(V0)
719:                 
720:                 
721:                 // current ( -- addr )
722:                 void current(void) {PUSH((ucell)&vCurrent);}
9D003790  8F828008   LW V0, -32760(GP)
9D003794  24430004   ADDIU V1, V0, 4
9D003798  AF838008   SW V1, -32760(GP)
9D00379C  278380D4   ADDIU V1, GP, -32556
9D0037A0  03E00008   JR RA
9D0037A4  AC430004   SW V1, 4(V0)
723:                 
724:                 
725:                 // context ( -- addr )
726:                 void context(void) {PUSH((ucell)&vContext);}
9D0037A8  8F828008   LW V0, -32760(GP)
9D0037AC  24430004   ADDIU V1, V0, 4
9D0037B0  AF838008   SW V1, -32760(GP)
9D0037B4  278380DC   ADDIU V1, GP, -32548
9D0037B8  03E00008   JR RA
9D0037BC  AC430004   SW V1, 4(V0)
727:                 
728:                 
729:                 // bl ( -- n )
730:                 void blf(void) {PUSH(Spc);}
9D000C60  8F828008   LW V0, -32760(GP)
9D000C64  24430004   ADDIU V1, V0, 4
9D000C68  AF838008   SW V1, -32760(GP)
9D000C6C  24030020   ADDIU V1, ZERO, 32
9D000C70  03E00008   JR RA
9D000C74  AC430004   SW V1, 4(V0)
731:                 
732:                 
733:                 // ********** CTRLFLOW **********
734:                 
735:                 
736:                 // <mark ( -- addr )
737:                 void lmark(void) {here(); TOS-=cellsize;}
9D000C78  27BDFFE8   ADDIU SP, SP, -24
9D000C7C  AFBF0014   SW RA, 20(SP)
9D000C80  0F4000FA   JAL here
9D000C84  00000000   NOP
9D000C88  8F828008   LW V0, -32760(GP)
9D000C8C  8C430000   LW V1, 0(V0)
9D000C90  2463FFFC   ADDIU V1, V1, -4
9D000C94  AC430000   SW V1, 0(V0)
9D000C98  8FBF0014   LW RA, 20(SP)
9D000C9C  03E00008   JR RA
9D000CA0  27BD0018   ADDIU SP, SP, 24
738:                 
739:                 
740:                 // <resolve ( addr -- )
741:                 void lresolve(void) {comma();}
9D002118  27BDFFE8   ADDIU SP, SP, -24
9D00211C  AFBF0014   SW RA, 20(SP)
9D002120  0F4007DD   JAL comma
9D002124  00000000   NOP
9D002128  8FBF0014   LW RA, 20(SP)
9D00212C  03E00008   JR RA
9D002130  27BD0018   ADDIU SP, SP, 24
742:                 
743:                 
744:                 // >mark ( -- addr )
745:                 void gmark(void) {here(); vHere+=cellsize;}
9D000CA4  27BDFFE8   ADDIU SP, SP, -24
9D000CA8  AFBF0014   SW RA, 20(SP)
9D000CAC  0F4000FA   JAL here
9D000CB0  00000000   NOP
9D000CB4  8F8280D0   LW V0, -32560(GP)
9D000CB8  24420004   ADDIU V0, V0, 4
9D000CBC  AF8280D0   SW V0, -32560(GP)
9D000CC0  8FBF0014   LW RA, 20(SP)
9D000CC4  03E00008   JR RA
9D000CC8  27BD0018   ADDIU SP, SP, 24
746:                 
747:                 
748:                 // >resolve ( addr -- )
749:                 void gresolve(void) {here(); TOS-=cellsize; swap(); store();}
9D000CCC  27BDFFE8   ADDIU SP, SP, -24
9D000CD0  AFBF0014   SW RA, 20(SP)
9D000CD4  0F4000FA   JAL here
9D000CD8  00000000   NOP
9D000CDC  8F828008   LW V0, -32760(GP)
9D000CE0  8C430000   LW V1, 0(V0)
9D000CE4  2463FFFC   ADDIU V1, V1, -4
9D000CE8  0F400055   JAL swap
9D000CEC  AC430000   SW V1, 0(V0)
9D000CF0  0F4000D4   JAL store
9D000CF4  00000000   NOP
9D000CF8  8FBF0014   LW RA, 20(SP)
9D000CFC  03E00008   JR RA
9D000D00  27BD0018   ADDIU SP, SP, 24
750:                 
751:                 
752:                 // do ( -- addr )
753:                 void dof(void) {CompileCxt(iDODO); gmark(); lmark();}
9D0032FC  27BDFFE8   ADDIU SP, SP, -24
9D003300  AFBF0014   SW RA, 20(SP)
9D003304  0F400B14   JAL CompileCxt
9D003308  2404000A   ADDIU A0, ZERO, 10
9D00330C  0F400329   JAL gmark
9D003310  00000000   NOP
9D003314  0F40031E   JAL lmark
9D003318  00000000   NOP
9D00331C  8FBF0014   LW RA, 20(SP)
9D003320  03E00008   JR RA
9D003324  27BD0018   ADDIU SP, SP, 24
754:                 
755:                 
756:                 // ?do ( -- addr )
757:                 void isdof(void) {CompileCxt(iISDO); gmark(); lmark();}
9D0032D0  27BDFFE8   ADDIU SP, SP, -24
9D0032D4  AFBF0014   SW RA, 20(SP)
9D0032D8  0F400B14   JAL CompileCxt
9D0032DC  2404000B   ADDIU A0, ZERO, 11
9D0032E0  0F400329   JAL gmark
9D0032E4  00000000   NOP
9D0032E8  0F40031E   JAL lmark
9D0032EC  00000000   NOP
9D0032F0  8FBF0014   LW RA, 20(SP)
9D0032F4  03E00008   JR RA
9D0032F8  27BD0018   ADDIU SP, SP, 24
758:                 
759:                 
760:                 // loop ( addr -- )
761:                 void loop(void) {CompileCxt(iLOOP); lresolve(); gresolve();}
9D0032A4  27BDFFE8   ADDIU SP, SP, -24
9D0032A8  AFBF0014   SW RA, 20(SP)
9D0032AC  0F400B14   JAL CompileCxt
9D0032B0  2404000C   ADDIU A0, ZERO, 12
9D0032B4  0F400846   JAL lresolve
9D0032B8  00000000   NOP
9D0032BC  0F400333   JAL gresolve
9D0032C0  00000000   NOP
9D0032C4  8FBF0014   LW RA, 20(SP)
9D0032C8  03E00008   JR RA
9D0032CC  27BD0018   ADDIU SP, SP, 24
762:                 
763:                 
764:                 // +loop ( addr -- )
765:                 void plusloop(void) {CompileCxt(iPLOOP); lresolve(); gresolve();}
9D003278  27BDFFE8   ADDIU SP, SP, -24
9D00327C  AFBF0014   SW RA, 20(SP)
9D003280  0F400B14   JAL CompileCxt
9D003284  2404000D   ADDIU A0, ZERO, 13
9D003288  0F400846   JAL lresolve
9D00328C  00000000   NOP
9D003290  0F400333   JAL gresolve
9D003294  00000000   NOP
9D003298  8FBF0014   LW RA, 20(SP)
9D00329C  03E00008   JR RA
9D0032A0  27BD0018   ADDIU SP, SP, 24
766:                 
767:                 
768:                 // if ( -- addr )
769:                 void iff(void) {CompileCxt(iDOCBR); gmark();}
9D003254  27BDFFE8   ADDIU SP, SP, -24
9D003258  AFBF0014   SW RA, 20(SP)
9D00325C  0F400B14   JAL CompileCxt
9D003260  2404000F   ADDIU A0, ZERO, 15
9D003264  0F400329   JAL gmark
9D003268  00000000   NOP
9D00326C  8FBF0014   LW RA, 20(SP)
9D003270  03E00008   JR RA
9D003274  27BD0018   ADDIU SP, SP, 24
770:                 
771:                 
772:                 // then ( addr -- )
773:                 void thenf(void) {gresolve();}
9D000D04  27BDFFE8   ADDIU SP, SP, -24
9D000D08  AFBF0014   SW RA, 20(SP)
9D000D0C  0F400333   JAL gresolve
9D000D10  00000000   NOP
9D000D14  8FBF0014   LW RA, 20(SP)
9D000D18  03E00008   JR RA
9D000D1C  27BD0018   ADDIU SP, SP, 24
774:                 
775:                 
776:                 // else ( addr1 -- addr2 )
777:                 void elsef(void) {CompileCxt(iDOBR); gmark(); swap(); gresolve();}
9D003220  27BDFFE8   ADDIU SP, SP, -24
9D003224  AFBF0014   SW RA, 20(SP)
9D003228  0F400B14   JAL CompileCxt
9D00322C  2404000E   ADDIU A0, ZERO, 14
9D003230  0F400329   JAL gmark
9D003234  00000000   NOP
9D003238  0F400055   JAL swap
9D00323C  00000000   NOP
9D003240  0F400333   JAL gresolve
9D003244  00000000   NOP
9D003248  8FBF0014   LW RA, 20(SP)
9D00324C  03E00008   JR RA
9D003250  27BD0018   ADDIU SP, SP, 24
778:                 
779:                 
780:                 // begin ( -- addr )
781:                 void beginf(void) {lmark();}
9D000D20  27BDFFE8   ADDIU SP, SP, -24
9D000D24  AFBF0014   SW RA, 20(SP)
9D000D28  0F40031E   JAL lmark
9D000D2C  00000000   NOP
9D000D30  8FBF0014   LW RA, 20(SP)
9D000D34  03E00008   JR RA
9D000D38  27BD0018   ADDIU SP, SP, 24
782:                 
783:                 
784:                 // while ( dest -- orig dest )
785:                 void whilef(void) {CompileCxt(iDOCBR); gmark(); swap();}
9D0031F4  27BDFFE8   ADDIU SP, SP, -24
9D0031F8  AFBF0014   SW RA, 20(SP)
9D0031FC  0F400B14   JAL CompileCxt
9D003200  2404000F   ADDIU A0, ZERO, 15
9D003204  0F400329   JAL gmark
9D003208  00000000   NOP
9D00320C  0F400055   JAL swap
9D003210  00000000   NOP
9D003214  8FBF0014   LW RA, 20(SP)
9D003218  03E00008   JR RA
9D00321C  27BD0018   ADDIU SP, SP, 24
786:                 
787:                 
788:                 // until ( addr -- )
789:                 void untilf(void) {CompileCxt(iDOCBR); lresolve();}
9D0031D0  27BDFFE8   ADDIU SP, SP, -24
9D0031D4  AFBF0014   SW RA, 20(SP)
9D0031D8  0F400B14   JAL CompileCxt
9D0031DC  2404000F   ADDIU A0, ZERO, 15
9D0031E0  0F400846   JAL lresolve
9D0031E4  00000000   NOP
9D0031E8  8FBF0014   LW RA, 20(SP)
9D0031EC  03E00008   JR RA
9D0031F0  27BD0018   ADDIU SP, SP, 24
790:                 
791:                 
792:                 // repeat ( addr1 -- addr2 )
793:                 void repeatf(void) {CompileCxt(iDOBR); lresolve(); gresolve();}
9D0031A4  27BDFFE8   ADDIU SP, SP, -24
9D0031A8  AFBF0014   SW RA, 20(SP)
9D0031AC  0F400B14   JAL CompileCxt
9D0031B0  2404000E   ADDIU A0, ZERO, 14
9D0031B4  0F400846   JAL lresolve
9D0031B8  00000000   NOP
9D0031BC  0F400333   JAL gresolve
9D0031C0  00000000   NOP
9D0031C4  8FBF0014   LW RA, 20(SP)
9D0031C8  03E00008   JR RA
9D0031CC  27BD0018   ADDIU SP, SP, 24
794:                 
795:                 
796:                 // again ( addr -- )
797:                 void againf(void) {CompileCxt(iDOBR); lresolve();}
9D003180  27BDFFE8   ADDIU SP, SP, -24
9D003184  AFBF0014   SW RA, 20(SP)
9D003188  0F400B14   JAL CompileCxt
9D00318C  2404000E   ADDIU A0, ZERO, 14
9D003190  0F400846   JAL lresolve
9D003194  00000000   NOP
9D003198  8FBF0014   LW RA, 20(SP)
9D00319C  03E00008   JR RA
9D0031A0  27BD0018   ADDIU SP, SP, 24
798:                 
799:                 
800:                 // leave ( -- )
801:                 void leavef(void) {pRS-=2; EXIT}
9D000D3C  8F828010   LW V0, -32752(GP)
9D000D40  2443FFF8   ADDIU V1, V0, -8
9D000D44  AF838010   SW V1, -32752(GP)
9D000D48  8C43FFF8   LW V1, -8(V0)
9D000D4C  AF8380BC   SW V1, -32580(GP)
9D000D50  2442FFF4   ADDIU V0, V0, -12
9D000D54  03E00008   JR RA
9D000D58  AF828010   SW V0, -32752(GP)
802:                 
803:                 
804:                 // unloop ( -- )
805:                 void unloopf(void) {pRS-=3;}
9D000D5C  8F828010   LW V0, -32752(GP)
9D000D60  2442FFF4   ADDIU V0, V0, -12
9D000D64  03E00008   JR RA
9D000D68  AF828010   SW V0, -32752(GP)
806:                 
807:                 
808:                 // recurse ( -- )
809:                 void recursef(void) {linkg(); comma();}
9D0020F4  27BDFFE8   ADDIU SP, SP, -24
9D0020F8  AFBF0014   SW RA, 20(SP)
9D0020FC  0F40061E   JAL linkg
9D002100  00000000   NOP
9D002104  0F4007DD   JAL comma
9D002108  00000000   NOP
9D00210C  8FBF0014   LW RA, 20(SP)
9D002110  03E00008   JR RA
9D002114  27BD0018   ADDIU SP, SP, 24
810:                 
811:                 
812:                 // case ( -- 0 )
813:                 void casef(void) {PUSH(0);}
9D000D6C  8F828008   LW V0, -32760(GP)
9D000D70  24430004   ADDIU V1, V0, 4
9D000D74  AF838008   SW V1, -32760(GP)
9D000D78  03E00008   JR RA
9D000D7C  AC400004   SW ZERO, 4(V0)
814:                 
815:                 const void *xt_over=over;
816:                 const void *xt_equal=equals;
817:                 const void *xt_drop=drop;
818:                 const void *xt_if=iff;
819:                 const void *xt_then=thenf;
820:                 const void *xt_else=elsef;
821:                 
822:                 
823:                 // of ( #of -- orig #of+1 / x -- )
824:                 void caseof(void)
825:                 {
9D003730  27BDFFE8   ADDIU SP, SP, -24
9D003734  AFBF0014   SW RA, 20(SP)
826:                 	TOS++; tor();
9D003738  8F828008   LW V0, -32760(GP)
9D00373C  8C430000   LW V1, 0(V0)
9D003740  24630001   ADDIU V1, V1, 1
9D003744  0F400069   JAL tor
9D003748  AC430000   SW V1, 0(V0)
827:                 	CompileCcon(&xt_over);
9D00374C  0F400D4F   JAL CompileCcon
9D003750  27848018   ADDIU A0, GP, -32744
828:                 	CompileCcon(&xt_equal);
9D003754  0F400D4F   JAL CompileCcon
9D003758  2784801C   ADDIU A0, GP, -32740
829:                 	PUSH((ucell)&xt_if); executew();
9D00375C  8F828008   LW V0, -32760(GP)
9D003760  24430004   ADDIU V1, V0, 4
9D003764  AF838008   SW V1, -32760(GP)
9D003768  27838024   ADDIU V1, GP, -32732
9D00376C  0F402C7C   JAL executew
9D003770  AC430004   SW V1, 4(V0)
830:                 	CompileCcon(&xt_drop);
9D003774  0F400D4F   JAL CompileCcon
9D003778  27848020   ADDIU A0, GP, -32736
831:                 	rfrom();
9D00377C  0F400072   JAL rfrom
9D003780  00000000   NOP
832:                 }
9D003784  8FBF0014   LW RA, 20(SP)
9D003788  03E00008   JR RA
9D00378C  27BD0018   ADDIU SP, SP, 24
833:                 
834:                 
835:                 // endof ( orig1 #of -- orig2 #of )
836:                 void endof(void)
837:                 {
9D001B64  27BDFFE8   ADDIU SP, SP, -24
9D001B68  AFBF0014   SW RA, 20(SP)
838:                 	tor(); PUSH((ucell)&xt_else); executew(); rfrom();
9D001B6C  0F400069   JAL tor
9D001B70  00000000   NOP
9D001B74  8F828008   LW V0, -32760(GP)
9D001B78  24430004   ADDIU V1, V0, 4
9D001B7C  AF838008   SW V1, -32760(GP)
9D001B80  2783802C   ADDIU V1, GP, -32724
9D001B84  0F402C7C   JAL executew
9D001B88  AC430004   SW V1, 4(V0)
9D001B8C  0F400072   JAL rfrom
9D001B90  00000000   NOP
839:                 }
9D001B94  8FBF0014   LW RA, 20(SP)
9D001B98  03E00008   JR RA
9D001B9C  27BD0018   ADDIU SP, SP, 24
840:                 
841:                 
842:                 // endcase ( orig 1..orign #of -- )
843:                 void endcase(void)
844:                 {
9D0036C0  27BDFFE0   ADDIU SP, SP, -32
9D0036C4  AFBF001C   SW RA, 28(SP)
9D0036C8  AFB20018   SW S2, 24(SP)
9D0036CC  AFB10014   SW S1, 20(SP)
9D0036D0  AFB00010   SW S0, 16(SP)
845:                 	ucell i, u=POP;
9D0036D4  8F828008   LW V0, -32760(GP)
9D0036D8  8C510000   LW S1, 0(V0)
9D0036DC  2442FFFC   ADDIU V0, V0, -4
9D0036E0  AF828008   SW V0, -32760(GP)
846:                 	CompileCcon(&xt_drop);
9D0036E4  0F400D4F   JAL CompileCcon
9D0036E8  27848020   ADDIU A0, GP, -32736
847:                 	if (u>0) {for (i=0; i<u; i++) {PUSH((ucell)&xt_then); executew();}}
9D0036EC  1220000A   BEQ S1, ZERO, 0x9D003718
9D0036F0  00008021   ADDU S0, ZERO, ZERO
9D0036F4  27928028   ADDIU S2, GP, -32728
9D0036F8  8F828008   LW V0, -32760(GP)
9D0036FC  24430004   ADDIU V1, V0, 4
9D003700  AF838008   SW V1, -32760(GP)
9D003704  0F402C7C   JAL executew
9D003708  AC520004   SW S2, 4(V0)
9D00370C  26100001   ADDIU S0, S0, 1
9D003710  1630FFFA   BNE S1, S0, 0x9D0036FC
9D003714  8F828008   LW V0, -32760(GP)
848:                 }
9D003718  8FBF001C   LW RA, 28(SP)
9D00371C  8FB20018   LW S2, 24(SP)
9D003720  8FB10014   LW S1, 20(SP)
9D003724  8FB00010   LW S0, 16(SP)
9D003728  03E00008   JR RA
9D00372C  27BD0020   ADDIU SP, SP, 32
849:                 
850:                 
851:                 // abort ( -- )
852:                 void abortf(void) {pDS=pDSzero; pRS=pRSzero; vIN=0; vSharpTib=0; vState=0;}
9D000D80  8F828004   LW V0, -32764(GP)
9D000D84  AF828008   SW V0, -32760(GP)
9D000D88  8F82800C   LW V0, -32756(GP)
9D000D8C  AF828010   SW V0, -32752(GP)
9D000D90  A380806C   SB ZERO, -32660(GP)
9D000D94  A380806D   SB ZERO, -32659(GP)
9D000D98  03E00008   JR RA
9D000D9C  A380806E   SB ZERO, -32658(GP)
853:                 const void *xt_abort=abortf;
854:                 
855:                 
856:                 // abort" ( x -- )
857:                 void aborts(void) {iff(); dotstring(); CompileCcon(&xt_abort); thenf();}
9D00368C  27BDFFE8   ADDIU SP, SP, -24
9D003690  AFBF0014   SW RA, 20(SP)
9D003694  0F400C95   JAL iff
9D003698  00000000   NOP
9D00369C  0F400D59   JAL dotstring
9D0036A0  00000000   NOP
9D0036A4  0F400D4F   JAL CompileCcon
9D0036A8  27848030   ADDIU A0, GP, -32720
9D0036AC  0F400341   JAL thenf
9D0036B0  00000000   NOP
9D0036B4  8FBF0014   LW RA, 20(SP)
9D0036B8  03E00008   JR RA
9D0036BC  27BD0018   ADDIU SP, SP, 24
858:                 
859:                 
860:                 // bye ( -- )
861:                 void bye(void) {
9D001CCC  27BDFFE8   ADDIU SP, SP, -24
9D001CD0  AFBF0014   SW RA, 20(SP)
862:                 #ifdef VPC_32
863:                     free(vPad);
9D001CD4  0F40403F   JAL free
9D001CD8  8F848060   LW A0, -32672(GP)
864:                     vPad=NULL;
9D001CDC  AF808060   SW ZERO, -32672(GP)
865:                     free(vTib);
9D001CE0  0F40403F   JAL free
9D001CE4  8F84805C   LW A0, -32676(GP)
866:                     vTib=NULL;
9D001CE8  AF80805C   SW ZERO, -32676(GP)
867:                     free(vDict);
9D001CEC  0F40403F   JAL free
9D001CF0  8F848064   LW A0, -32668(GP)
868:                     vDict=NULL;
9D001CF4  AF808064   SW ZERO, -32668(GP)
869:                     free(vMem);
9D001CF8  0F40403F   JAL free
9D001CFC  8F848068   LW A0, -32664(GP)
870:                     vMem=NULL;
9D001D00  AF808068   SW ZERO, -32664(GP)
871:                 #endif
872:                     vState=EndState;
9D001D04  2402FFEE   ADDIU V0, ZERO, -18
9D001D08  A382806E   SB V0, -32658(GP)
873:                 
874:                 }
9D001D0C  8FBF0014   LW RA, 20(SP)
9D001D10  03E00008   JR RA
9D001D14  27BD0018   ADDIU SP, SP, 24
875:                 
876:                 
877:                 // ********** Interpreter **********
878:                 
879:                 
880:                 // [ ( -- )
881:                 void lbracket(void) {vState=0;}  // Interprete
9D0013A8  03E00008   JR RA
9D0013AC  A380806E   SB ZERO, -32658(GP)
882:                 
883:                 
884:                 // ] ( -- )
885:                 void rbracket(void) {vState=1;}  // Compile
9D0013B0  24020001   ADDIU V0, ZERO, 1
9D0013B4  03E00008   JR RA
9D0013B8  A382806E   SB V0, -32658(GP)
886:                 
887:                 
888:                 // bin ( -- )
889:                 void binf(void) {vBase=2;}
9D0013BC  24020002   ADDIU V0, ZERO, 2
9D0013C0  03E00008   JR RA
9D0013C4  A3828014   SB V0, -32748(GP)
890:                 
891:                 
892:                 // decimal ( -- )
893:                 void decimal(void) {vBase=10;}
9D0013C8  2402000A   ADDIU V0, ZERO, 10
9D0013CC  03E00008   JR RA
9D0013D0  A3828014   SB V0, -32748(GP)
894:                 
895:                 
896:                 // hex ( -- )
897:                 void hexf(void) {vBase=16;}
9D0013D4  24020010   ADDIU V0, ZERO, 16
9D0013D8  03E00008   JR RA
9D0013DC  A3828014   SB V0, -32748(GP)
898:                 
899:                 
900:                 cell  KeyBak=0;
901:                 
902:                 // accept ( addr n1 -- n2 )
903:                 void accept(void)  // read until A,D,AD,DA
904:                 {
9D002918  27BDFFC8   ADDIU SP, SP, -56
9D00291C  AFBF0034   SW RA, 52(SP)
9D002920  AFBE0030   SW S8, 48(SP)
9D002924  AFB7002C   SW S7, 44(SP)
9D002928  AFB60028   SW S6, 40(SP)
9D00292C  AFB50024   SW S5, 36(SP)
9D002930  AFB40020   SW S4, 32(SP)
9D002934  AFB3001C   SW S3, 28(SP)
9D002938  AFB20018   SW S2, 24(SP)
9D00293C  AFB10014   SW S1, 20(SP)
9D002940  AFB00010   SW S0, 16(SP)
905:                 	char fRun=1, k, *pTib, maxnum, num=0;
9D002960  00008821   ADDU S1, ZERO, ZERO
9D002964  24160001   ADDIU S6, ZERO, 1
906:                 	
907:                 	maxnum=POP; pTib=(char *)POP;
9D002944  8F828008   LW V0, -32760(GP)
9D002948  80520000   LB S2, 0(V0)
9D00294C  2443FFFC   ADDIU V1, V0, -4
9D002950  AF838008   SW V1, -32760(GP)
9D002954  8C57FFFC   LW S7, -4(V0)
9D002958  2442FFF8   ADDIU V0, V0, -8
9D00295C  AF828008   SW V0, -32760(GP)
908:                 	while (fRun)
9D002A74  16C0FFC0   BNE S6, ZERO, 0x9D002978
9D002A78  00000000   NOP
909:                 	{
910:                 	  key(); k=POP;
9D002978  0F4008C1   JAL key
9D00297C  00000000   NOP
9D002980  8F828008   LW V0, -32760(GP)
9D002984  80500000   LB S0, 0(V0)
9D002988  2442FFFC   ADDIU V0, V0, -4
911:                 	  if ((k==BackSpc)&&(num>0))  {num--; *--pTib=Spc; PUSH(k); emit();PUSH(Spc); emit();PUSH(k); emit();}
9D002968  24140008   ADDIU S4, ZERO, 8
9D002974  241E0020   ADDIU S8, ZERO, 32
9D00298C  16140019   BNE S0, S4, 0x9D0029F4
9D002990  AF828008   SW V0, -32760(GP)
9D002994  1A200018   BLEZ S1, 0x9D0029F8
9D002998  2A020020   SLTI V0, S0, 32
9D00299C  2631FFFF   ADDIU S1, S1, -1
9D0029A0  7C118C20   SEB S1, S1
9D0029A4  26F7FFFF   ADDIU S7, S7, -1
9D0029A8  A2FE0000   SB S8, 0(S7)
9D0029AC  8F828008   LW V0, -32760(GP)
9D0029B0  24430004   ADDIU V1, V0, 4
9D0029B4  AF838008   SW V1, -32760(GP)
9D0029B8  0F4008CE   JAL emit
9D0029BC  AC540004   SW S4, 4(V0)
9D0029C0  8F828008   LW V0, -32760(GP)
9D0029C4  24430004   ADDIU V1, V0, 4
9D0029C8  AF838008   SW V1, -32760(GP)
9D0029CC  24030020   ADDIU V1, ZERO, 32
9D0029D0  0F4008CE   JAL emit
9D0029D4  AC430004   SW V1, 4(V0)
9D0029D8  8F828008   LW V0, -32760(GP)
9D0029DC  24430004   ADDIU V1, V0, 4
9D0029E0  AF838008   SW V1, -32760(GP)
9D0029E4  0F4008CE   JAL emit
9D0029E8  AC540004   SW S4, 4(V0)
9D0029EC  0B400A93   J 0x9D002A4C
9D0029F0  00000000   NOP
912:                 	  if ((k>=Spc)&&(num<maxnum)) {num++; *pTib++=k; PUSH(k); emit();}
9D0029F4  2A020020   SLTI V0, S0, 32
9D0029F8  1440000C   BNE V0, ZERO, 0x9D002A2C
9D0029FC  0232102A   SLT V0, S1, S2
9D002A00  1040000A   BEQ V0, ZERO, 0x9D002A2C
9D002A04  00000000   NOP
9D002A08  26310001   ADDIU S1, S1, 1
9D002A0C  7C118C20   SEB S1, S1
9D002A10  A2F00000   SB S0, 0(S7)
9D002A14  26F70001   ADDIU S7, S7, 1
9D002A18  8F828008   LW V0, -32760(GP)
9D002A1C  24430004   ADDIU V1, V0, 4
9D002A20  AF838008   SW V1, -32760(GP)
9D002A24  0F4008CE   JAL emit
9D002A28  AC500004   SW S0, 4(V0)
913:                 	  if ((k==CRA)&&(KeyBak==CRD)) {k=0;}
9D002A2C  16130007   BNE S0, S3, 0x9D002A4C
9D002A30  8F828074   LW V0, -32652(GP)
9D002A34  00551026   XOR V0, V0, S5
9D002A38  0002800A   MOVZ S0, ZERO, V0
914:                 	  if ((k==CRD)&&(KeyBak==CRA)) {k=0;}
9D00296C  2415000D   ADDIU S5, ZERO, 13
9D002970  2413000A   ADDIU S3, ZERO, 10
9D002A4C  16150007   BNE S0, S5, 0x9D002A6C
9D002A50  0232102A   SLT V0, S1, S2
9D002A54  8F828074   LW V0, -32652(GP)
9D002A58  50530003   BEQL V0, S3, 0x9D002A68
9D002A5C  00008021   ADDU S0, ZERO, ZERO
915:                 	  if ((k==CRD)||(k==CRA)) {fRun=0; crf();}
9D002A3C  12130008   BEQ S0, S3, 0x9D002A60
9D002A40  0232102A   SLT V0, S1, S2
9D002A44  0B400A9B   J 0x9D002A6C
9D002A48  00000000   NOP
9D002A60  0F40097A   JAL crf
9D002A64  0000B021   ADDU S6, ZERO, ZERO
916:                 	  if (num>=maxnum) {fRun=0;}
9D002A68  0232102A   SLT V0, S1, S2
9D002A6C  10400003   BEQ V0, ZERO, 0x9D002A7C
9D002A70  AF908074   SW S0, -32652(GP)
917:                 	  KeyBak=k;
918:                 	}
919:                 	PUSH(num); 
9D002A7C  8F828008   LW V0, -32760(GP)
9D002A80  24430004   ADDIU V1, V0, 4
9D002A84  AF838008   SW V1, -32760(GP)
9D002A88  AC510004   SW S1, 4(V0)
920:                 }
9D002A8C  8FBF0034   LW RA, 52(SP)
9D002A90  8FBE0030   LW S8, 48(SP)
9D002A94  8FB7002C   LW S7, 44(SP)
9D002A98  8FB60028   LW S6, 40(SP)
9D002A9C  8FB50024   LW S5, 36(SP)
9D002AA0  8FB40020   LW S4, 32(SP)
9D002AA4  8FB3001C   LW S3, 28(SP)
9D002AA8  8FB20018   LW S2, 24(SP)
9D002AAC  8FB10014   LW S1, 20(SP)
9D002AB0  8FB00010   LW S0, 16(SP)
9D002AB4  03E00008   JR RA
9D002AB8  27BD0038   ADDIU SP, SP, 56
921:                 
922:                 
923:                 // refill ( -- f )
924:                 void refill(void) {tib(); PUSH(tibsize); accept(); vSharpTib=POP; vIN=0; PUSH(-1);}
9D002ABC  27BDFFE8   ADDIU SP, SP, -24
9D002AC0  AFBF0014   SW RA, 20(SP)
9D002AC4  0F4002E9   JAL tib
9D002AC8  00000000   NOP
9D002ACC  8F828008   LW V0, -32760(GP)
9D002AD0  24430004   ADDIU V1, V0, 4
9D002AD4  AF838008   SW V1, -32760(GP)
9D002AD8  24030050   ADDIU V1, ZERO, 80
9D002ADC  0F400A46   JAL accept
9D002AE0  AC430004   SW V1, 4(V0)
9D002AE4  8F828008   LW V0, -32760(GP)
9D002AE8  8C430000   LW V1, 0(V0)
9D002AEC  A383806D   SB V1, -32659(GP)
9D002AF0  A380806C   SB ZERO, -32660(GP)
9D002AF4  2403FFFF   ADDIU V1, ZERO, -1
9D002AF8  AC430000   SW V1, 0(V0)
9D002AFC  8FBF0014   LW RA, 20(SP)
9D002B00  03E00008   JR RA
9D002B04  27BD0018   ADDIU SP, SP, 24
925:                 
926:                 
927:                 // source ( -- addr u )
928:                 void source(void) {tib(); PUSH(vSharpTib);}
9D0013E0  27BDFFE8   ADDIU SP, SP, -24
9D0013E4  AFBF0014   SW RA, 20(SP)
9D0013E8  0F4002E9   JAL tib
9D0013EC  00000000   NOP
9D0013F0  8F828008   LW V0, -32760(GP)
9D0013F4  24430004   ADDIU V1, V0, 4
9D0013F8  AF838008   SW V1, -32760(GP)
9D0013FC  9383806D   LBU V1, -32659(GP)
9D001400  AC430004   SW V1, 4(V0)
9D001404  8FBF0014   LW RA, 20(SP)
9D001408  03E00008   JR RA
9D00140C  27BD0018   ADDIU SP, SP, 24
929:                 
930:                 
931:                 // count ( addr -- addr+1 u )
932:                 void count(void) {dup(); cfetch(); TOSi(1)++;}
9D001410  27BDFFE8   ADDIU SP, SP, -24
9D001414  AFBF0014   SW RA, 20(SP)
9D001418  0F400010   JAL dup
9D00141C  00000000   NOP
9D001420  0F4000CA   JAL cfetch
9D001424  00000000   NOP
9D001428  8F828008   LW V0, -32760(GP)
9D00142C  8C43FFFC   LW V1, -4(V0)
9D001430  24630001   ADDIU V1, V1, 1
9D001434  AC43FFFC   SW V1, -4(V0)
9D001438  8FBF0014   LW RA, 20(SP)
9D00143C  03E00008   JR RA
9D001440  27BD0018   ADDIU SP, SP, 24
933:                 
934:                 
935:                 // word ( c -- addr )
936:                 void wordf(void)
937:                 {
938:                 	BYTE c=POP, i=1;
9D001444  8F828008   LW V0, -32760(GP)
9D001448  8C470000   LW A3, 0(V0)
9D00144C  2442FFFC   ADDIU V0, V0, -4
9D001450  AF828008   SW V0, -32760(GP)
939:                 
940:                 	if (vSharpTib)
9D001454  9386806D   LBU A2, -32659(GP)
9D001458  10C00038   BEQ A2, ZERO, 0x9D00153C
9D00145C  24030001   ADDIU V1, ZERO, 1
941:                 	{
942:                 	  while((vTib[vIN]==c)&&(vIN<vSharpTib)) {vIN++;}  // Skip spaces
9D001460  8F84805C   LW A0, -32676(GP)
9D001464  9382806C   LBU V0, -32660(GP)
9D001468  00821821   ADDU V1, A0, V0
9D00146C  80650000   LB A1, 0(V1)
9D001470  30E700FF   ANDI A3, A3, 255
9D001474  54A7000D   BNEL A1, A3, 0x9D0014AC
9D001478  00E02821   ADDU A1, A3, ZERO
9D00147C  0046182B   SLTU V1, V0, A2
9D001480  10600029   BEQ V1, ZERO, 0x9D001528
9D001484  24030001   ADDIU V1, ZERO, 1
9D001488  24420001   ADDIU V0, V0, 1
9D00148C  304200FF   ANDI V0, V0, 255
9D001490  A382806C   SB V0, -32660(GP)
9D001494  00821821   ADDU V1, A0, V0
9D001498  80630000   LB V1, 0(V1)
9D00149C  1065000B   BEQ V1, A1, 0x9D0014CC
9D0014A0  00000000   NOP
9D0014CC  5446FFEF   BNEL V0, A2, 0x9D00148C
9D0014D0  24420001   ADDIU V0, V0, 1
943:                 	  while((vTib[vIN]!=c)&&(vIN<vSharpTib))           // Until c
9D0014A4  0B40052C   J 0x9D0014B0
9D0014A8  9382806C   LBU V0, -32660(GP)
9D0014AC  9382806C   LBU V0, -32660(GP)
9D0014B0  00822021   ADDU A0, A0, V0
9D0014B4  80840000   LB A0, 0(A0)
9D0014B8  0046302B   SLTU A2, V0, A2
9D0014BC  14C00007   BNE A2, ZERO, 0x9D0014DC
9D0014C0  24030001   ADDIU V1, ZERO, 1
9D0014D4  0B400558   J 0x9D001560
9D0014D8  9382806C   LBU V0, -32660(GP)
9D0014FC  8F84805C   LW A0, -32676(GP)
9D001500  00822021   ADDU A0, A0, V0
9D001504  80840000   LB A0, 0(A0)
9D001508  10A40007   BEQ A1, A0, 0x9D001528
9D00150C  306300FF   ANDI V1, V1, 255
9D001510  9386806D   LBU A2, -32659(GP)
9D001514  0046102B   SLTU V0, V0, A2
9D001518  1440FFF1   BNE V0, ZERO, 0x9D0014E0
9D00151C  8F828060   LW V0, -32672(GP)
9D001560  0B40054A   J 0x9D001528
9D001564  24030001   ADDIU V1, ZERO, 1
944:                 	  {
945:                 		vPad[i]=vTib[vIN]; i++; vIN++;  // Copy to PAD
9D0014DC  8F828060   LW V0, -32672(GP)
9D0014E0  00431021   ADDU V0, V0, V1
9D0014E4  A0440000   SB A0, 0(V0)
9D0014E8  24630001   ADDIU V1, V1, 1
9D0014EC  9382806C   LBU V0, -32660(GP)
9D0014F0  24420001   ADDIU V0, V0, 1
9D0014F4  304200FF   ANDI V0, V0, 255
9D0014F8  A382806C   SB V0, -32660(GP)
946:                 	  }
947:                 	  if((vTib[vIN]==c)&&(vIN<vSharpTib)) {vIN++;}  // Behind c delimiter 
9D001528  9384806D   LBU A0, -32659(GP)
9D00152C  0044202B   SLTU A0, V0, A0
9D001530  10800002   BEQ A0, ZERO, 0x9D00153C
9D001534  24420001   ADDIU V0, V0, 1
9D001538  A382806C   SB V0, -32660(GP)
948:                 	}
949:                 	vPad[0]=--i;  // Length
9D0014C4  0B400550   J 0x9D001540
9D0014C8  2463FFFF   ADDIU V1, V1, -1
9D001520  0B400551   J 0x9D001544
9D001524  2463FFFF   ADDIU V1, V1, -1
9D00153C  2463FFFF   ADDIU V1, V1, -1
9D001540  8F828060   LW V0, -32672(GP)
9D001544  A0430000   SB V1, 0(V0)
950:                 	PUSH((ucell)vPad);
9D001548  8F828008   LW V0, -32760(GP)
9D00154C  24430004   ADDIU V1, V0, 4
9D001550  AF838008   SW V1, -32760(GP)
9D001554  8F838060   LW V1, -32672(GP)
951:                 }
9D001558  03E00008   JR RA
9D00155C  AC430004   SW V1, 4(V0)
952:                 
953:                 
954:                 // parse ( c -- addr u )
955:                 void parse(void)
9D0015C0  00E43823   SUBU A3, A3, A0
9D0015C4  30E700FF   ANDI A3, A3, 255
956:                 {
957:                 	BYTE c=POP, i=0;
9D001568  8F828008   LW V0, -32760(GP)
9D00156C  8C450000   LW A1, 0(V0)
9D001570  2443FFFC   ADDIU V1, V0, -4
9D001574  AF838008   SW V1, -32760(GP)
958:                 
959:                 	if (vSharpTib)
9D001578  9383806D   LBU V1, -32659(GP)
9D00157C  1060002B   BEQ V1, ZERO, 0x9D00162C
9D001580  30A500FF   ANDI A1, A1, 255
960:                 	{
961:                 	  PUSH((ucell)&vTib[vIN]);         // Addr
9D001584  AF828008   SW V0, -32760(GP)
9D001588  9383806C   LBU V1, -32660(GP)
9D00158C  8F84805C   LW A0, -32676(GP)
9D001590  00831821   ADDU V1, A0, V1
9D001594  AC430000   SW V1, 0(V0)
962:                 	  while((vTib[vIN]!=c)&&(vIN<vSharpTib)) {i++; vIN++;}  // Until c
9D001598  8F86805C   LW A2, -32676(GP)
9D00159C  9384806C   LBU A0, -32660(GP)
9D0015A0  00C41021   ADDU V0, A2, A0
9D0015A4  80430000   LB V1, 0(V0)
9D0015A8  10650012   BEQ V1, A1, 0x9D0015F4
9D0015AC  00001021   ADDU V0, ZERO, ZERO
9D0015B0  9387806D   LBU A3, -32659(GP)
9D0015B4  0087182B   SLTU V1, A0, A3
9D0015B8  1060000F   BEQ V1, ZERO, 0x9D0015F8
9D0015BC  8F838008   LW V1, -32760(GP)
9D0015C8  24420001   ADDIU V0, V0, 1
9D0015CC  304200FF   ANDI V0, V0, 255
9D0015D0  00441821   ADDU V1, V0, A0
9D0015D4  306300FF   ANDI V1, V1, 255
9D0015D8  A383806C   SB V1, -32660(GP)
9D0015DC  00C31821   ADDU V1, A2, V1
9D0015E0  80630000   LB V1, 0(V1)
9D0015E4  10650004   BEQ V1, A1, 0x9D0015F8
9D0015E8  8F838008   LW V1, -32760(GP)
9D0015EC  5447FFF7   BNEL V0, A3, 0x9D0015CC
9D0015F0  24420001   ADDIU V0, V0, 1
963:                 	  PUSH((ucell)i);                  // Length
9D0015F4  8F838008   LW V1, -32760(GP)
9D0015F8  24640004   ADDIU A0, V1, 4
9D0015FC  AF848008   SW A0, -32760(GP)
9D001600  AC620004   SW V0, 4(V1)
964:                 	  if ((vTib[vIN]==c)&&(vIN<vSharpTib)) {vIN++;}         // Behind c delimiter
9D001604  9382806C   LBU V0, -32660(GP)
9D001608  8F83805C   LW V1, -32676(GP)
9D00160C  00621821   ADDU V1, V1, V0
9D001610  80630000   LB V1, 0(V1)
9D001614  14650005   BNE V1, A1, 0x9D00162C
9D001618  9383806D   LBU V1, -32659(GP)
9D00161C  0043182B   SLTU V1, V0, V1
9D001620  10600002   BEQ V1, ZERO, 0x9D00162C
9D001624  24420001   ADDIU V0, V0, 1
9D001628  A382806C   SB V0, -32660(GP)
9D00162C  03E00008   JR RA
9D001630  00000000   NOP
965:                 	}
966:                 }
967:                 
968:                 
969:                 // number ( addr -- n )
970:                 void number(void)
971:                 {
9D002134  27BDFFD8   ADDIU SP, SP, -40
9D002138  AFBF0024   SW RA, 36(SP)
9D00213C  AFB20020   SW S2, 32(SP)
9D002140  AFB1001C   SW S1, 28(SP)
972:                 	char *pStart, *pEnd;
973:                 	ucell x, y=0, len;
974:                 
975:                 	count(); len=POP; pStart=(char *)POP;
9D002144  0F400504   JAL count
9D002148  AFB00018   SW S0, 24(SP)
9D00214C  8F828008   LW V0, -32760(GP)
9D002150  8C510000   LW S1, 0(V0)
9D002154  2443FFFC   ADDIU V1, V0, -4
9D002158  AF838008   SW V1, -32760(GP)
9D00215C  8C50FFFC   LW S0, -4(V0)
9D002160  2442FFF8   ADDIU V0, V0, -8
9D002164  AF828008   SW V0, -32760(GP)
976:                 	*(pStart+len)=0;  // Write end of number!
9D002168  02111021   ADDU V0, S0, S1
9D00216C  A0400000   SB ZERO, 0(V0)
977:                 	if (*pStart=='-') {pStart++; len--; y=1;}
9D002170  82030000   LB V1, 0(S0)
9D002174  2402002D   ADDIU V0, ZERO, 45
9D002178  14620004   BNE V1, V0, 0x9D00218C
9D00217C  00009021   ADDU S2, ZERO, ZERO
9D002180  26100001   ADDIU S0, S0, 1
9D002184  2631FFFF   ADDIU S1, S1, -1
9D002188  24120001   ADDIU S2, ZERO, 1
978:                 
979:                 	base(); drop();
9D00218C  0F4002FB   JAL base
9D002190  00000000   NOP
9D002194  0F400008   JAL drop
9D002198  00000000   NOP
980:                 	if (len)
9D00219C  12200015   BEQ S1, ZERO, 0x9D0021F4
9D0021A0  9382806F   LBU V0, -32657(GP)
981:                 	{
982:                 	  x=strtoul(pStart, &pEnd, vBase);
9D0021A4  02002021   ADDU A0, S0, ZERO
9D0021A8  27A50010   ADDIU A1, SP, 16
9D0021AC  0F403997   JAL strtoul
9D0021B0  93868014   LBU A2, -32748(GP)
983:                 	  if (y) {x=-x;};
9D0021B4  00021823   SUBU V1, ZERO, V0
9D0021B8  0072100B   MOVN V0, V1, S2
984:                 	  if (((ucell)pStart+len)==(ucell)pEnd) {PUSH(x);} else {vErrors|=2; abortf();}
9D0021BC  02118021   ADDU S0, S0, S1
9D0021C0  8FA30010   LW V1, 16(SP)
9D0021C4  54700006   BNEL V1, S0, 0x9D0021E0
9D0021C8  9382806F   LBU V0, -32657(GP)
9D0021CC  8F838008   LW V1, -32760(GP)
9D0021D0  24640004   ADDIU A0, V1, 4
9D0021D4  AF848008   SW A0, -32760(GP)
9D0021D8  0B40087F   J 0x9D0021FC
9D0021DC  AC620004   SW V0, 4(V1)
9D0021E0  34420002   ORI V0, V0, 2
9D0021E4  0F400360   JAL abortf
9D0021E8  A382806F   SB V0, -32657(GP)
985:                 	} else {vErrors|=1;}
9D0021F4  34420001   ORI V0, V0, 1
9D0021F8  A382806F   SB V0, -32657(GP)
986:                 }
9D0021EC  0B400880   J 0x9D002200
9D0021F0  8FBF0024   LW RA, 36(SP)
9D0021FC  8FBF0024   LW RA, 36(SP)
9D002200  8FB20020   LW S2, 32(SP)
9D002204  8FB1001C   LW S1, 28(SP)
9D002208  8FB00018   LW S0, 24(SP)
9D00220C  03E00008   JR RA
9D002210  27BD0028   ADDIU SP, SP, 40
987:                 
988:                 
989:                 // find ( addr -- addr 0 | xt +-1 )
990:                 void find(void)
991:                 {
9D001634  27BDFFF8   ADDIU SP, SP, -8
9D001638  AFB00004   SW S0, 4(SP)
992:                 	short int i=PrimLast, j, len;
9D00163C  87878070   LH A3, -32656(GP)
993:                 	char *p1=(char *)POP, *pbak=p1, *p2;
9D001640  8F908008   LW S0, -32760(GP)
9D001644  8E0C0000   LW T4, 0(S0)
9D001648  01806821   ADDU T5, T4, ZERO
9D00164C  2602FFFC   ADDIU V0, S0, -4
9D001650  AF828008   SW V0, -32760(GP)
994:                 	ucell *Link, Linkbak, k=0;
995:                 
996:                 	len=*p1 & 0x1F;
9D001654  91890000   LBU T1, 0(T4)
997:                 	if (vHead) {Link=(ucell *)vHead; k=1;}  // Link to new word
9D001658  8F8A80D8   LW T2, -32552(GP)
9D00165C  1140003B   BEQ T2, ZERO, 0x9D00174C
9D001660  3129001F   ANDI T1, T1, 31
998:                 	while (k)  // Forth words
999:                 	{
1000:                	  if (((*Link>>24)&0x1F)==len)   // Compare length
9D001678  8D480000   LW T0, 0(T2)
9D00167C  7D0B2600   EXT T3, T0, 24, 5
9D001680  1569002B   BNE T3, T1, 0x9D001730
9D001684  7D02B000   EXT V0, T0, 0, 23
1001:                	  {
1002:                		  Linkbak=(ucell)Link+cellsize;        // Begin of name
1003:                		  j=len; p1=pbak; p2=(char *)Linkbak;
9D0016A4  01201021   ADDU V0, T1, ZERO
1004:                		  while((j>0)&&(*++p1==*p2++)) {j--;}  // Compare text
9D001688  19200011   BLEZ T1, 0x9D0016D0
9D00168C  254E0004   ADDIU T6, T2, 4
9D001690  81A40001   LB A0, 1(T5)
9D001694  81420004   LB V0, 4(T2)
9D001698  1482000D   BNE A0, V0, 0x9D0016D0
9D00169C  25A30001   ADDIU V1, T5, 1
9D0016A0  25C40001   ADDIU A0, T6, 1
9D0016A8  2442FFFF   ADDIU V0, V0, -1
9D0016AC  7C021620   SEH V0, V0
9D0016B0  10400009   BEQ V0, ZERO, 0x9D0016D8
9D0016B4  24630001   ADDIU V1, V1, 1
9D0016B8  80660000   LB A2, 0(V1)
9D0016BC  80850000   LB A1, 0(A0)
9D0016C0  14C5001A   BNE A2, A1, 0x9D00172C
9D0016C4  24840001   ADDIU A0, A0, 1
9D0016C8  0B4005AB   J 0x9D0016AC
9D0016CC  2442FFFF   ADDIU V0, V0, -1
1005:                		  if (!j)
9D0016D0  15200017   BNE T1, ZERO, 0x9D001730
9D0016D4  7D02B000   EXT V0, T0, 0, 23
1006:                		  {
1007:                			Linkbak+=len;
9D0016D8  016E5821   ADDU T3, T3, T6
1008:                			if (Linkbak&3) {Linkbak=(Linkbak&~3)+cellsize;}		// Align
9D0016DC  31620003   ANDI V0, T3, 3
9D0016E0  10400004   BEQ V0, ZERO, 0x9D0016F4
9D0016E4  AF908008   SW S0, -32760(GP)
9D0016E8  2402FFFC   ADDIU V0, ZERO, -4
9D0016EC  01625824   AND T3, T3, V0
9D0016F0  256B0004   ADDIU T3, T3, 4
1009:                			PUSH(Linkbak);										// XT
9D0016F4  AE0B0000   SW T3, 0(S0)
1010:                			if ((*Link>>24)&im) {PUSH(1);} else {PUSH(-1);}		// 1 Immed
9D0016F8  8D420000   LW V0, 0(T2)
9D0016FC  04410006   BGEZ V0, 0x9D001718
9D001700  8F828008   LW V0, -32760(GP)
9D001704  24430004   ADDIU V1, V0, 4
9D001708  AF838008   SW V1, -32760(GP)
9D00170C  24030001   ADDIU V1, ZERO, 1
9D001710  0B400619   J 0x9D001864
9D001714  AC430004   SW V1, 4(V0)
9D001718  24430004   ADDIU V1, V0, 4
9D00171C  AF838008   SW V1, -32760(GP)
9D001720  2403FFFF   ADDIU V1, ZERO, -1
9D001724  0B400619   J 0x9D001864
9D001728  AC430004   SW V1, 4(V0)
1011:                			k=0; i=-1;											// True
1012:                		  }
1013:                	  }
1014:                	  if (k) {Linkbak=*Link&0x7FFFFF;} else {Linkbak=0;}		// Last,zero?
9D00172C  7D02B000   EXT V0, T0, 0, 23
1015:                	  if (!Linkbak) {k=0;}
9D001730  10400006   BEQ V0, ZERO, 0x9D00174C
9D001734  010F4024   AND T0, T0, T7
1016:                	  if (k)
1017:                	  {
1018:                		if (*Link&0x800000) {Linkbak+=AddrRAM<<24;} else {Linkbak+=AddrROM<<24;}
9D001664  939980C8   LBU T9, -32568(GP)
9D001668  0019CE00   SLL T9, T9, 24
9D00166C  939880C9   LBU T8, -32567(GP)
9D001670  0018C600   SLL T8, T8, 24
9D001674  3C0F0080   LUI T7, 128
9D001738  00581821   ADDU V1, V0, T8
9D00173C  00591021   ADDU V0, V0, T9
1019:                		Link=(ucell *)Linkbak;
9D001740  00605021   ADDU T2, V1, ZERO
9D001744  0B40059E   J 0x9D001678
9D001748  0048500A   MOVZ T2, V0, T0
1020:                	  }
1021:                	}
1022:                
1023:                //	if (primwords[i].wlen&0x20)  // Primitives?
1024:                //	{
1025:                	  while(i>=0)
9D00174C  04E00047   BLTZ A3, 0x9D00186C
9D001750  240A000C   ADDIU T2, ZERO, 12
9D001854  04E1FFC2   BGEZ A3, 0x9D001760
9D001858  70EA1002   MUL V0, A3, T2
1026:                	  {
1027:                		if ((primwords[i].wlen&0x1F)==len)     // Compare length
9D001754  3C029D00   LUI V0, -25344
9D001758  244E707C   ADDIU T6, V0, 28796
9D00175C  70EA1002   MUL V0, A3, T2
9D001760  004E1821   ADDU V1, V0, T6
9D001764  94680002   LHU T0, 2(V1)
9D001768  3102001F   ANDI V0, T0, 31
9D00176C  1449002D   BNE V0, T1, 0x9D001824
9D001770  00E05821   ADDU T3, A3, ZERO
1028:                		{
1029:                		  j=len; p1=pbak; p2=primwords[i].wname;
9D001790  01201021   ADDU V0, T1, ZERO
9D001864  0B4005D3   J 0x9D00174C
9D001868  2407FFFF   ADDIU A3, ZERO, -1
1030:                		  while((j>0)&&(*++p1==*p2++)) {j--;}  // Compare text
9D001774  19200011   BLEZ T1, 0x9D0017BC
9D001778  8C640004   LW A0, 4(V1)
9D00177C  81A60001   LB A2, 1(T5)
9D001780  80850000   LB A1, 0(A0)
9D001784  14C5000D   BNE A2, A1, 0x9D0017BC
9D001788  25A30001   ADDIU V1, T5, 1
9D00178C  24840001   ADDIU A0, A0, 1
9D001794  2442FFFF   ADDIU V0, V0, -1
9D001798  7C021620   SEH V0, V0
9D00179C  10400009   BEQ V0, ZERO, 0x9D0017C4
9D0017A0  24630001   ADDIU V1, V1, 1
9D0017A4  80660000   LB A2, 0(V1)
9D0017A8  80850000   LB A1, 0(A0)
9D0017AC  14C5001D   BNE A2, A1, 0x9D001824
9D0017B0  24840001   ADDIU A0, A0, 1
9D0017B4  0B4005E6   J 0x9D001798
9D0017B8  2442FFFF   ADDIU V0, V0, -1
1031:                		  if (!j)
9D0017BC  15200019   BNE T1, ZERO, 0x9D001824
9D0017C0  00000000   NOP
1032:                		  {
1033:                			PUSH((ucell)&primwords[i].wcall);  // XT
9D0017C4  8F828008   LW V0, -32760(GP)
9D0017C8  24430004   ADDIU V1, V0, 4
9D0017CC  AF838008   SW V1, -32760(GP)
9D0017D0  2403000C   ADDIU V1, ZERO, 12
9D0017D4  71631802   MUL V1, T3, V1
9D0017D8  24630008   ADDIU V1, V1, 8
9D0017DC  3C0B9D00   LUI T3, -25344
9D0017E0  256B707C   ADDIU T3, T3, 28796
9D0017E4  01635821   ADDU T3, T3, V1
1034:                			if (primwords[i].wlen&im) {PUSH(1);} else {PUSH(-1);}
9D0017E8  31080080   ANDI T0, T0, 128
9D0017EC  11000007   BEQ T0, ZERO, 0x9D00180C
9D0017F0  AC4B0004   SW T3, 4(V0)
9D0017F4  8F828008   LW V0, -32760(GP)
9D0017F8  24430004   ADDIU V1, V0, 4
9D0017FC  AF838008   SW V1, -32760(GP)
9D001800  24030001   ADDIU V1, ZERO, 1
9D001804  0B40061B   J 0x9D00186C
9D001808  AC430004   SW V1, 4(V0)
9D00180C  8F828008   LW V0, -32760(GP)
9D001810  24430004   ADDIU V1, V0, 4
9D001814  AF838008   SW V1, -32760(GP)
9D001818  2403FFFF   ADDIU V1, ZERO, -1
9D00181C  0B40061B   J 0x9D00186C
9D001820  AC430004   SW V1, 4(V0)
1035:                			i=-1;
1036:                		  }
1037:                		}
1038:                		if (i==0) {PUSH((ucell)pbak); PUSH(0);} // False
9D001824  14E00009   BNE A3, ZERO, 0x9D00184C
9D001828  8F828008   LW V0, -32760(GP)
9D00182C  24430004   ADDIU V1, V0, 4
9D001830  AF838008   SW V1, -32760(GP)
9D001834  AC4C0004   SW T4, 4(V0)
9D001838  8F828008   LW V0, -32760(GP)
9D00183C  24430004   ADDIU V1, V0, 4
9D001840  AF838008   SW V1, -32760(GP)
9D001844  0B40061B   J 0x9D00186C
9D001848  AC400004   SW ZERO, 4(V0)
1039:                		i--; 
9D00184C  24E7FFFF   ADDIU A3, A3, -1
9D001850  7C073E20   SEH A3, A3
1040:                	  }
1041:                //	}
1042:                }
9D00185C  0B40061C   J 0x9D001870
9D001860  8FB00004   LW S0, 4(SP)
9D00186C  8FB00004   LW S0, 4(SP)
9D001870  03E00008   JR RA
9D001874  27BD0008   ADDIU SP, SP, 8
1043:                
1044:                
1045:                // ********** Compiler **********
1046:                
1047:                
1048:                // link> ( -- xt )
1049:                void linkg(void)
1050:                {
1051:                	ucell Linkbak=cellsize+(ucell)vHead;
9D001878  8F8380D8   LW V1, -32552(GP)
9D00187C  24640004   ADDIU A0, V1, 4
1052:                	Linkbak+=(*(ucell *)vHead>>24)&0x1F;			// Head+len
9D001880  90620003   LBU V0, 3(V1)
9D001884  3042001F   ANDI V0, V0, 31
9D001888  00821021   ADDU V0, A0, V0
1053:                	if (Linkbak&3) {Linkbak=(Linkbak&~3)+cellsize;}	// Align
9D00188C  30430003   ANDI V1, V0, 3
9D001890  10600003   BEQ V1, ZERO, 0x9D0018A0
9D001894  2403FFFC   ADDIU V1, ZERO, -4
9D001898  00431024   AND V0, V0, V1
9D00189C  24420004   ADDIU V0, V0, 4
1054:                	PUSH(Linkbak);  // lfa->cfa
9D0018A0  8F838008   LW V1, -32760(GP)
9D0018A4  24640004   ADDIU A0, V1, 4
9D0018A8  AF848008   SW A0, -32760(GP)
1055:                }
9D0018AC  03E00008   JR RA
9D0018B0  AC620004   SW V0, 4(V1)
1056:                
1057:                
1058:                // >body ( xt -- addr )
1059:                void gbody(void) {TOS+=cellsize;}
9D0018B4  8F828008   LW V0, -32760(GP)
9D0018B8  8C430000   LW V1, 0(V0)
9D0018BC  24630004   ADDIU V1, V1, 4
9D0018C0  03E00008   JR RA
9D0018C4  AC430000   SW V1, 0(V0)
1060:                
1061:                
1062:                // ascii ( -- c )
1063:                void ascii(void)
1064:                {
9D003120  27BDFFE8   ADDIU SP, SP, -24
9D003124  AFBF0014   SW RA, 20(SP)
1065:                	blf(); wordf(); TOS++; TOS=*(BYTE *)TOS;	// c to stack
9D003128  0F400318   JAL blf
9D00312C  00000000   NOP
9D003130  0F400511   JAL wordf
9D003134  00000000   NOP
9D003138  8F828008   LW V0, -32760(GP)
9D00313C  8C430000   LW V1, 0(V0)
9D003140  24630001   ADDIU V1, V1, 1
9D003144  AC430000   SW V1, 0(V0)
9D003148  8F828008   LW V0, -32760(GP)
9D00314C  8C430000   LW V1, 0(V0)
9D003150  90630000   LBU V1, 0(V1)
9D003154  AC430000   SW V1, 0(V0)
1066:                	if (vState) {CompileCxt(iDOLIT); comma();}	// c to Here
9D003158  9382806E   LBU V0, -32658(GP)
9D00315C  10400006   BEQ V0, ZERO, 0x9D003178
9D003160  8FBF0014   LW RA, 20(SP)
9D003164  0F400B14   JAL CompileCxt
9D003168  24040004   ADDIU A0, ZERO, 4
9D00316C  0F4007DD   JAL comma
9D003170  00000000   NOP
1067:                }
9D003174  8FBF0014   LW RA, 20(SP)
9D003178  03E00008   JR RA
9D00317C  27BD0018   ADDIU SP, SP, 24
1068:                
1069:                
1070:                // align ( -- )
1071:                void align(void)
1072:                {
1073:                	if ((ucell)vHere&3)	{vHere=(char *)(((ucell)vHere&~3)+cellsize);}
9D0018C8  8F8280D0   LW V0, -32560(GP)
9D0018CC  30430003   ANDI V1, V0, 3
9D0018D0  10600004   BEQ V1, ZERO, 0x9D0018E4
9D0018D4  2403FFFC   ADDIU V1, ZERO, -4
9D0018D8  00431024   AND V0, V0, V1
9D0018DC  24420004   ADDIU V0, V0, 4
9D0018E0  AF8280D0   SW V0, -32560(GP)
9D0018E4  03E00008   JR RA
9D0018E8  00000000   NOP
1074:                }
1075:                
1076:                
1077:                // allot ( n -- )
1078:                void allot(void) {vHeap+=POP;}
9D0018EC  8F828008   LW V0, -32760(GP)
9D0018F0  8C430000   LW V1, 0(V0)
9D0018F4  8F8480E0   LW A0, -32544(GP)
9D0018F8  00831821   ADDU V1, A0, V1
9D0018FC  AF8380E0   SW V1, -32544(GP)
9D001900  2442FFFC   ADDIU V0, V0, -4
9D001904  03E00008   JR RA
9D001908  AF828008   SW V0, -32760(GP)
1079:                
1080:                
1081:                // , ( x -- )
1082:                void comma(void)
1083:                {
9D001F74  27BDFFE8   ADDIU SP, SP, -24
9D001F78  AFBF0014   SW RA, 20(SP)
1084:                //	*(ucell *)vHere=POP; vHere+=cellsize;
1085:                	ucell x=POP;
9D001F7C  8F828008   LW V0, -32760(GP)
9D001F80  8C440000   LW A0, 0(V0)
9D001F84  2442FFFC   ADDIU V0, V0, -4
9D001F88  AF828008   SW V0, -32760(GP)
1086:                	if ((ucell)vHere>>24==AddrRAM) {*(ucell *)vHere=x; vHere+=cellsize;}
9D001F8C  8F8280D0   LW V0, -32560(GP)
9D001F90  00022E02   SRL A1, V0, 24
9D001F94  938380C9   LBU V1, -32567(GP)
9D001F98  14A30006   BNE A1, V1, 0x9D001FB4
9D001F9C  00000000   NOP
9D001FA0  AC440000   SW A0, 0(V0)
9D001FA4  8F8280D0   LW V0, -32560(GP)
9D001FA8  24420004   ADDIU V0, V0, 4
9D001FAC  0B4007F8   J 0x9D001FE0
9D001FB0  AF8280D0   SW V0, -32560(GP)
1087:                	else {
1088:                	  if (NVMwriteBuf(x)) {vHere+=cellsize;}
9D001FB4  0F403264   JAL NVMwriteBuf
9D001FB8  00000000   NOP
9D001FBC  10400004   BEQ V0, ZERO, 0x9D001FD0
9D001FC0  8F8280D0   LW V0, -32560(GP)
9D001FC4  24420004   ADDIU V0, V0, 4
9D001FC8  0B4007F8   J 0x9D001FE0
9D001FCC  AF8280D0   SW V0, -32560(GP)
1089:                	  else {vErrors|=0x10; abortf();}
9D001FD0  9382806F   LBU V0, -32657(GP)
9D001FD4  34420010   ORI V0, V0, 16
9D001FD8  0F400360   JAL abortf
9D001FDC  A382806F   SB V0, -32657(GP)
1090:                	}
1091:                }
9D001FE0  8FBF0014   LW RA, 20(SP)
9D001FE4  03E00008   JR RA
9D001FE8  27BD0018   ADDIU SP, SP, 24
1092:                
1093:                
1094:                // c, ( c -- )
1095:                void ccomma(void)
1096:                {
9D001D90  27BDFFE8   ADDIU SP, SP, -24
9D001D94  AFBF0014   SW RA, 20(SP)
1097:                //	*vHere++=POP;
1098:                	char c=POP;
9D001D98  8F828008   LW V0, -32760(GP)
9D001D9C  80440000   LB A0, 0(V0)
9D001DA0  2442FFFC   ADDIU V0, V0, -4
9D001DA4  AF828008   SW V0, -32760(GP)
1099:                	if ((ucell)vHere>>24==AddrRAM) {*vHere++=c;}
9D001DA8  8F8280D0   LW V0, -32560(GP)
9D001DAC  00022E02   SRL A1, V0, 24
9D001DB0  938380C9   LBU V1, -32567(GP)
9D001DB4  14A30005   BNE A1, V1, 0x9D001DCC
9D001DB8  00000000   NOP
9D001DBC  A0440000   SB A0, 0(V0)
9D001DC0  24420001   ADDIU V0, V0, 1
9D001DC4  0B40077E   J 0x9D001DF8
9D001DC8  AF8280D0   SW V0, -32560(GP)
1100:                	else { 
1101:                	  if (NVMwriteBufc(c)) {vHere++;}
9D001DCC  0F403273   JAL NVMwriteBufc
9D001DD0  00000000   NOP
9D001DD4  10400004   BEQ V0, ZERO, 0x9D001DE8
9D001DD8  8F8280D0   LW V0, -32560(GP)
9D001DDC  24420001   ADDIU V0, V0, 1
9D001DE0  0B40077E   J 0x9D001DF8
9D001DE4  AF8280D0   SW V0, -32560(GP)
1102:                	  else {vErrors|=0x10; abortf();}
9D001DE8  9382806F   LBU V0, -32657(GP)
9D001DEC  34420010   ORI V0, V0, 16
9D001DF0  0F400360   JAL abortf
9D001DF4  A382806F   SB V0, -32657(GP)
1103:                	}
1104:                }
9D001DF8  8FBF0014   LW RA, 20(SP)
9D001DFC  03E00008   JR RA
9D001E00  27BD0018   ADDIU SP, SP, 24
1105:                
1106:                
1107:                // w, ( x -- )
1108:                void wcomma(void)
1109:                {
9D001D18  27BDFFE8   ADDIU SP, SP, -24
9D001D1C  AFBF0014   SW RA, 20(SP)
1110:                //	*(WORD *)vHere=POP; vHere+=2;
1111:                	WORD w=POP;
9D001D20  8F828008   LW V0, -32760(GP)
9D001D24  94440000   LHU A0, 0(V0)
9D001D28  2442FFFC   ADDIU V0, V0, -4
9D001D2C  AF828008   SW V0, -32760(GP)
1112:                	if ((ucell)vHere>>24==AddrRAM) {*(WORD *)vHere=w; vHere+=2;}
9D001D30  8F8280D0   LW V0, -32560(GP)
9D001D34  00022E02   SRL A1, V0, 24
9D001D38  938380C9   LBU V1, -32567(GP)
9D001D3C  14A30006   BNE A1, V1, 0x9D001D58
9D001D40  00000000   NOP
9D001D44  A4440000   SH A0, 0(V0)
9D001D48  8F8280D0   LW V0, -32560(GP)
9D001D4C  24420002   ADDIU V0, V0, 2
9D001D50  0B400761   J 0x9D001D84
9D001D54  AF8280D0   SW V0, -32560(GP)
1113:                	else {
1114:                	  if (NVMwriteBufw(w)) {vHere+=2;}
9D001D58  0F403289   JAL NVMwriteBufw
9D001D5C  00000000   NOP
9D001D60  10400004   BEQ V0, ZERO, 0x9D001D74
9D001D64  8F8280D0   LW V0, -32560(GP)
9D001D68  24420002   ADDIU V0, V0, 2
9D001D6C  0B400761   J 0x9D001D84
9D001D70  AF8280D0   SW V0, -32560(GP)
1115:                	  else {vErrors|=0x10; abortf();}
9D001D74  9382806F   LBU V0, -32657(GP)
9D001D78  34420010   ORI V0, V0, 16
9D001D7C  0F400360   JAL abortf
9D001D80  A382806F   SB V0, -32657(GP)
1116:                	}
1117:                }
9D001D84  8FBF0014   LW RA, 20(SP)
9D001D88  03E00008   JR RA
9D001D8C  27BD0018   ADDIU SP, SP, 24
1118:                
1119:                
1120:                // s, ( addr u -- )
1121:                void scomma(void)
9D001E3C  26310001   ADDIU S1, S1, 1
9D001E40  2652FFFF   ADDIU S2, S2, -1
9D001E44  325200FF   ANDI S2, S2, 255
9D001E48  02328821   ADDU S1, S1, S2
1122:                {
9D001E04  27BDFFE0   ADDIU SP, SP, -32
9D001E08  AFBF001C   SW RA, 28(SP)
9D001E0C  AFB20018   SW S2, 24(SP)
9D001E10  AFB10014   SW S1, 20(SP)
9D001E14  AFB00010   SW S0, 16(SP)
1123:                	BYTE len=POP;
9D001E18  8F828008   LW V0, -32760(GP)
9D001E1C  90520000   LBU S2, 0(V0)
9D001E20  2443FFFC   ADDIU V1, V0, -4
9D001E24  AF838008   SW V1, -32760(GP)
1124:                	char *addr1=(char *)POP;
9D001E28  8C51FFFC   LW S1, -4(V0)
1125:                	PUSH(len); ccomma();
9D001E2C  0F400764   JAL ccomma
9D001E30  AC52FFFC   SW S2, -4(V0)
1126:                	while (len>0) {PUSH(*addr1++); ccomma(); len--;}
9D001E34  1240000E   BEQ S2, ZERO, 0x9D001E70
9D001E38  02208021   ADDU S0, S1, ZERO
9D001E4C  8F828008   LW V0, -32760(GP)
9D001E50  24430004   ADDIU V1, V0, 4
9D001E54  AF838008   SW V1, -32760(GP)
9D001E58  82030000   LB V1, 0(S0)
9D001E5C  AC430004   SW V1, 4(V0)
9D001E60  0F400764   JAL ccomma
9D001E64  26100001   ADDIU S0, S0, 1
9D001E68  1611FFF9   BNE S0, S1, 0x9D001E50
9D001E6C  8F828008   LW V0, -32760(GP)
1127:                }
9D001E70  8FBF001C   LW RA, 28(SP)
9D001E74  8FB20018   LW S2, 24(SP)
9D001E78  8FB10014   LW S1, 20(SP)
9D001E7C  8FB00010   LW S0, 16(SP)
9D001E80  03E00008   JR RA
9D001E84  27BD0020   ADDIU SP, SP, 32
1128:                
1129:                
1130:                // compile ( -- )
1131:                void compile(void)
1132:                {
9D0020B8  27BDFFE8   ADDIU SP, SP, -24
9D0020BC  AFBF0014   SW RA, 20(SP)
1133:                	PC+=cellsize; PUSH(PC); fetch(); comma(); 
9D0020C0  8F8380BC   LW V1, -32580(GP)
9D0020C4  24630004   ADDIU V1, V1, 4
9D0020C8  AF8380BC   SW V1, -32580(GP)
9D0020CC  8F828008   LW V0, -32760(GP)
9D0020D0  24440004   ADDIU A0, V0, 4
9D0020D4  AF848008   SW A0, -32760(GP)
9D0020D8  0F4000C5   JAL fetch
9D0020DC  AC430004   SW V1, 4(V0)
9D0020E0  0F4007DD   JAL comma
9D0020E4  00000000   NOP
1134:                }
9D0020E8  8FBF0014   LW RA, 20(SP)
9D0020EC  03E00008   JR RA
9D0020F0  27BD0018   ADDIU SP, SP, 24
1135:                const void *xt_compile=compile;
1136:                
1137:                
1138:                // [compile] ( -- )
1139:                void bracketcompile(void)
1140:                {
9D002094  27BDFFE8   ADDIU SP, SP, -24
9D002098  AFBF0014   SW RA, 20(SP)
1141:                	tick(); comma();
9D00209C  0F400643   JAL tick
9D0020A0  00000000   NOP
9D0020A4  0F4007DD   JAL comma
9D0020A8  00000000   NOP
1142:                }
9D0020AC  8FBF0014   LW RA, 20(SP)
9D0020B0  03E00008   JR RA
9D0020B4  27BD0018   ADDIU SP, SP, 24
1143:                
1144:                
1145:                // ' ( -- xt )
1146:                void tick(void)
1147:                {
9D00190C  27BDFFE8   ADDIU SP, SP, -24
9D001910  AFBF0014   SW RA, 20(SP)
1148:                	blf(); wordf(); find();
9D001914  0F400318   JAL blf
9D001918  00000000   NOP
9D00191C  0F400511   JAL wordf
9D001920  00000000   NOP
9D001924  0F40058D   JAL find
9D001928  00000000   NOP
1149:                	if (!POP) {vErrors|=0x20; abortf();}
9D00192C  8F828008   LW V0, -32760(GP)
9D001930  8C430000   LW V1, 0(V0)
9D001934  2442FFFC   ADDIU V0, V0, -4
9D001938  14600005   BNE V1, ZERO, 0x9D001950
9D00193C  AF828008   SW V0, -32760(GP)
9D001940  9382806F   LBU V0, -32657(GP)
9D001944  34420020   ORI V0, V0, 32
9D001948  0F400360   JAL abortf
9D00194C  A382806F   SB V0, -32657(GP)
1150:                }
9D001950  8FBF0014   LW RA, 20(SP)
9D001954  03E00008   JR RA
9D001958  27BD0018   ADDIU SP, SP, 24
1151:                
1152:                
1153:                // ['] ( -- )
1154:                void brackettick(void)
1155:                {
9D0030F4  27BDFFE8   ADDIU SP, SP, -24
9D0030F8  AFBF0014   SW RA, 20(SP)
1156:                	CompileCxt(iDOLIT); tick(); comma();
9D0030FC  0F400B14   JAL CompileCxt
9D003100  24040004   ADDIU A0, ZERO, 4
9D003104  0F400643   JAL tick
9D003108  00000000   NOP
9D00310C  0F4007DD   JAL comma
9D003110  00000000   NOP
1157:                }
9D003114  8FBF0014   LW RA, 20(SP)
9D003118  03E00008   JR RA
9D00311C  27BD0018   ADDIU SP, SP, 24
1158:                
1159:                
1160:                // postpone ( -- )
1161:                void postpone(void)
1162:                {
9D003600  27BDFFE8   ADDIU SP, SP, -24
9D003604  AFBF0014   SW RA, 20(SP)
1163:                	blf(); wordf(); find(); 
9D003608  0F400318   JAL blf
9D00360C  00000000   NOP
9D003610  0F400511   JAL wordf
9D003614  00000000   NOP
9D003618  0F40058D   JAL find
9D00361C  00000000   NOP
1164:                	if ((cell)TOS<0) {pDS--; CompileCcon(&xt_compile); comma(); return;} // noimmed
9D003620  8F828008   LW V0, -32760(GP)
9D003624  8C430000   LW V1, 0(V0)
9D003628  04610009   BGEZ V1, 0x9D003650
9D00362C  00000000   NOP
9D003630  2442FFFC   ADDIU V0, V0, -4
9D003634  AF828008   SW V0, -32760(GP)
9D003638  0F400D4F   JAL CompileCcon
9D00363C  27848034   ADDIU A0, GP, -32716
9D003640  0F4007DD   JAL comma
9D003644  00000000   NOP
9D003648  0B400DA1   J 0x9D003684
9D00364C  8FBF0014   LW RA, 20(SP)
1165:                	if ((cell)TOS)   {pDS--; comma(); return;}  // [compile] immed
9D003650  50600006   BEQL V1, ZERO, 0x9D00366C
9D003654  2442FFF8   ADDIU V0, V0, -8
9D003658  2442FFFC   ADDIU V0, V0, -4
9D00365C  0F4007DD   JAL comma
9D003660  AF828008   SW V0, -32760(GP)
9D003664  0B400DA1   J 0x9D003684
9D003668  8FBF0014   LW RA, 20(SP)
1166:                	pDS-=2; vErrors|=0x20; abortf();
9D00366C  AF828008   SW V0, -32760(GP)
9D003670  9382806F   LBU V0, -32657(GP)
9D003674  34420020   ORI V0, V0, 32
9D003678  0F400360   JAL abortf
9D00367C  A382806F   SB V0, -32657(GP)
1167:                }
9D003680  8FBF0014   LW RA, 20(SP)
9D003684  03E00008   JR RA
9D003688  27BD0018   ADDIU SP, SP, 24
1168:                
1169:                
1170:                // (create) ( name -- )
1171:                void docreate(void)						// |Flg+Len|Link|Name Align|
1172:                {
9D001E88  27BDFFE8   ADDIU SP, SP, -24
9D001E8C  AFBF0014   SW RA, 20(SP)
1173:                	char *bakH;
1174:                	BYTE Len;
1175:                	ucell Link;
1176:                
1177:                	blf(); wordf(); count(); Len=TOS;  // ( -- addr n )
9D001E90  0F400318   JAL blf
9D001E94  AFB00010   SW S0, 16(SP)
9D001E98  0F400511   JAL wordf
9D001E9C  00000000   NOP
9D001EA0  0F400504   JAL count
9D001EA4  00000000   NOP
9D001EA8  8F828008   LW V0, -32760(GP)
1178:                	if (Len>0)
9D001EAC  90430000   LBU V1, 0(V0)
9D001EB0  10600020   BEQ V1, ZERO, 0x9D001F34
9D001EB4  8F9080D8   LW S0, -32552(GP)
1179:                	{
1180:                	  bakH=vHead; vHead=vHere;			// Update Head
9D001EB8  8F8380D0   LW V1, -32560(GP)
9D001EBC  AF8380D8   SW V1, -32552(GP)
1181:                	  PUSH((ucell)bakH); wcomma();		// Link low 16b
9D001EC0  24430004   ADDIU V1, V0, 4
9D001EC4  AF838008   SW V1, -32760(GP)
9D001EC8  0F400746   JAL wcomma
9D001ECC  AC500004   SW S0, 4(V0)
1182:                	  Link=((ucell)bakH>>16)&0x7F;		// Link hi 23b 
9D001ED0  7E033400   EXT V1, S0, 16, 7
1183:                	  Link|=(((ucell)bakH>>24)==AddrROM) ? 0:0x80;  // ROM/RAM
9D001ED4  00108602   SRL S0, S0, 24
9D001ED8  938280C8   LBU V0, -32568(GP)
9D001EDC  02028026   XOR S0, S0, V0
9D001EE0  24020080   ADDIU V0, ZERO, 128
9D001EE4  0010100A   MOVZ V0, ZERO, S0
9D001EE8  00408021   ADDU S0, V0, ZERO
9D001EF8  02038025   OR S0, S0, V1
1184:                	  PUSH(Link); ccomma(); scomma();	// Link hi, Length+Name
9D001EEC  8F828008   LW V0, -32760(GP)
9D001EF0  24440004   ADDIU A0, V0, 4
9D001EF4  AF848008   SW A0, -32760(GP)
9D001EFC  0F400764   JAL ccomma
9D001F00  AC500004   SW S0, 4(V0)
9D001F04  0F400781   JAL scomma
9D001F08  00000000   NOP
1185:                	  align();							// 4B align
9D001F0C  0F400632   JAL align
9D001F10  00000000   NOP
1186:                	  if ((ucell)vHere>>24==AddrROM) {toflash();}  // Write to flash
9D001F14  938380D3   LBU V1, -32557(GP)
9D001F18  938280C8   LBU V0, -32568(GP)
9D001F1C  54620008   BNEL V1, V0, 0x9D001F40
9D001F20  8FBF0014   LW RA, 20(SP)
9D001F24  0F4006FF   JAL toflash
9D001F28  00000000   NOP
1187:                	} else {twodrop();}
9D001F34  0F40000C   JAL twodrop
9D001F38  00000000   NOP
1188:                }
9D001F2C  0B4007D0   J 0x9D001F40
9D001F30  8FBF0014   LW RA, 20(SP)
9D001F3C  8FBF0014   LW RA, 20(SP)
9D001F40  8FB00010   LW S0, 16(SP)
9D001F44  03E00008   JR RA
9D001F48  27BD0018   ADDIU SP, SP, 24
1189:                
1190:                
1191:                // create ( name -- )
1192:                void createf(void)						// |Flg+Len|Link|Name Align|(con)|PFA|
1193:                {
9D0034FC  27BDFFE8   ADDIU SP, SP, -24
9D003500  AFBF0014   SW RA, 20(SP)
1194:                	docreate(); CompileCpfa(iDOCON);	// comma PFA docon
9D003504  0F4007A2   JAL docreate
9D003508  00000000   NOP
9D00350C  0F400CCA   JAL CompileCpfa
9D003510  24040006   ADDIU A0, ZERO, 6
1195:                	PUSH((ucell)vHere+cellsize); comma(); // comma PFA new word
9D003514  8F828008   LW V0, -32760(GP)
9D003518  24430004   ADDIU V1, V0, 4
9D00351C  AF838008   SW V1, -32760(GP)
9D003520  8F8380D0   LW V1, -32560(GP)
9D003524  24630004   ADDIU V1, V1, 4
9D003528  0F4007DD   JAL comma
9D00352C  AC430004   SW V1, 4(V0)
1196:                }
9D003530  8FBF0014   LW RA, 20(SP)
9D003534  03E00008   JR RA
9D003538  27BD0018   ADDIU SP, SP, 24
1197:                
1198:                
1199:                // <builds ( name -- )
1200:                void builds(void)						// |Flg+Len|Link|Name Align|-1|-1|
1201:                {
9D001F4C  27BDFFE8   ADDIU SP, SP, -24
9D001F50  AFBF0014   SW RA, 20(SP)
1202:                	docreate();
9D001F54  0F4007A2   JAL docreate
9D001F58  00000000   NOP
1203:                	vHere+=cellsize; vHere+=cellsize;	// Cells for Flash overwrite
9D001F5C  8F8280D0   LW V0, -32560(GP)
9D001F60  24420008   ADDIU V0, V0, 8
9D001F64  AF8280D0   SW V0, -32560(GP)
1204:                }
9D001F68  8FBF0014   LW RA, 20(SP)
9D001F6C  03E00008   JR RA
9D001F70  27BD0018   ADDIU SP, SP, 24
1205:                
1206:                
1207:                // does> ( -- )
1208:                void does(void)
1209:                {
9D003498  27BDFFE8   ADDIU SP, SP, -24
9D00349C  AFBF0014   SW RA, 20(SP)
9D0034A0  AFB00010   SW S0, 16(SP)
1210:                	char *bak=vHere;
1211:                	linkg(); herewrite(); CompileCpfa(iDODOES);	// Overwrite xt by dodoes
9D0034A4  0F40061E   JAL linkg
9D0034A8  8F9080D0   LW S0, -32560(GP)
9D0034AC  0F400100   JAL herewrite
9D0034B0  00000000   NOP
9D0034B4  0F400CCA   JAL CompileCpfa
9D0034B8  24040008   ADDIU A0, ZERO, 8
1212:                	PUSH(PC); comma();							// Overwrite xt+1 by PC does>
9D0034BC  8F828008   LW V0, -32760(GP)
9D0034C0  24430004   ADDIU V1, V0, 4
9D0034C4  AF838008   SW V1, -32760(GP)
9D0034C8  8F8380BC   LW V1, -32580(GP)
9D0034CC  0F4007DD   JAL comma
9D0034D0  AC430004   SW V1, 4(V0)
1213:                	vHere=bak; EXIT
9D0034D4  AF9080D0   SW S0, -32560(GP)
9D0034D8  8F828010   LW V0, -32752(GP)
9D0034DC  8C430000   LW V1, 0(V0)
9D0034E0  AF8380BC   SW V1, -32580(GP)
9D0034E4  2442FFFC   ADDIU V0, V0, -4
9D0034E8  AF828010   SW V0, -32752(GP)
1214:                }
9D0034EC  8FBF0014   LW RA, 20(SP)
9D0034F0  8FB00010   LW S0, 16(SP)
9D0034F4  03E00008   JR RA
9D0034F8  27BD0018   ADDIU SP, SP, 24
1215:                
1216:                
1217:                // : ( -- )
1218:                void colon(void)
1219:                {
9D00346C  27BDFFE8   ADDIU SP, SP, -24
9D003470  AFBF0014   SW RA, 20(SP)
1220:                	docreate(); CompileCpfa(iENTER); /* PFA docolon */ rbracket();
9D003474  0F4007A2   JAL docreate
9D003478  00000000   NOP
9D00347C  0F400CCA   JAL CompileCpfa
9D003480  24040003   ADDIU A0, ZERO, 3
9D003484  0F4004EC   JAL rbracket
9D003488  00000000   NOP
1221:                }
9D00348C  8FBF0014   LW RA, 20(SP)
9D003490  03E00008   JR RA
9D003494  27BD0018   ADDIU SP, SP, 24
1222:                
1223:                
1224:                // ; ( -- )
1225:                void semicolon(void)
1226:                {
9D0030D0  27BDFFE8   ADDIU SP, SP, -24
9D0030D4  AFBF0014   SW RA, 20(SP)
1227:                	CompileCxt(iEXIT); /* doexit */ lbracket();
9D0030D8  0F400B14   JAL CompileCxt
9D0030DC  00002021   ADDU A0, ZERO, ZERO
9D0030E0  0F4004EA   JAL lbracket
9D0030E4  00000000   NOP
1228:                }
9D0030E8  8FBF0014   LW RA, 20(SP)
9D0030EC  03E00008   JR RA
9D0030F0  27BD0018   ADDIU SP, SP, 24
1229:                
1230:                
1231:                // immediate ( -- )
1232:                void immediate(void)
1233:                {
1234:                	char *pLen=vHead+3;
9D00195C  8F8280D8   LW V0, -32552(GP)
1235:                	*pLen|=im;
9D001960  90440003   LBU A0, 3(V0)
9D001964  2403FF80   ADDIU V1, ZERO, -128
9D001968  00831825   OR V1, A0, V1
1236:                }
9D00196C  03E00008   JR RA
9D001970  A0430003   SB V1, 3(V0)
1237:                
1238:                
1239:                // s" ( -- addr n)
1240:                void squote(void)
1241:                {
9D003080  27BDFFE8   ADDIU SP, SP, -24
9D003084  AFBF0014   SW RA, 20(SP)
1242:                	PUSH('"'); parse();
9D003088  8F828008   LW V0, -32760(GP)
9D00308C  24430004   ADDIU V1, V0, 4
9D003090  AF838008   SW V1, -32760(GP)
9D003094  24030022   ADDIU V1, ZERO, 34
9D003098  0F40055A   JAL parse
9D00309C  AC430004   SW V1, 4(V0)
1243:                	if (vState) {CompileCxt(iDOSLIT); scomma(); align();}
9D0030A0  9382806E   LBU V0, -32658(GP)
9D0030A4  10400008   BEQ V0, ZERO, 0x9D0030C8
9D0030A8  8FBF0014   LW RA, 20(SP)
9D0030AC  0F400B14   JAL CompileCxt
9D0030B0  24040005   ADDIU A0, ZERO, 5
9D0030B4  0F400781   JAL scomma
9D0030B8  00000000   NOP
9D0030BC  0F400632   JAL align
9D0030C0  00000000   NOP
1244:                }
9D0030C4  8FBF0014   LW RA, 20(SP)
9D0030C8  03E00008   JR RA
9D0030CC  27BD0018   ADDIU SP, SP, 24
1245:                
1246:                
1247:                // literal ( x -- )
1248:                void literal(void)
1249:                {
9D00305C  27BDFFE8   ADDIU SP, SP, -24
9D003060  AFBF0014   SW RA, 20(SP)
1250:                	CompileCxt(iDOLIT); /* doliteral */ comma();
9D003064  0F400B14   JAL CompileCxt
9D003068  24040004   ADDIU A0, ZERO, 4
9D00306C  0F4007DD   JAL comma
9D003070  00000000   NOP
1251:                }
9D003074  8FBF0014   LW RA, 20(SP)
9D003078  03E00008   JR RA
9D00307C  27BD0018   ADDIU SP, SP, 24
1252:                
1253:                
1254:                // constant ( x -- )
1255:                void constant(void)
1256:                {
9D003440  27BDFFE8   ADDIU SP, SP, -24
9D003444  AFBF0014   SW RA, 20(SP)
1257:                	docreate(); CompileCpfa(iDOCON); /* PFA doconstant */ comma();
9D003448  0F4007A2   JAL docreate
9D00344C  00000000   NOP
9D003450  0F400CCA   JAL CompileCpfa
9D003454  24040006   ADDIU A0, ZERO, 6
9D003458  0F4007DD   JAL comma
9D00345C  00000000   NOP
1258:                }
9D003460  8FBF0014   LW RA, 20(SP)
9D003464  03E00008   JR RA
9D003468  27BD0018   ADDIU SP, SP, 24
1259:                
1260:                
1261:                // variable ( -- ) 
1262:                void variable(void)
1263:                {
9D003400  27BDFFE8   ADDIU SP, SP, -24
9D003404  AFBF0014   SW RA, 20(SP)
1264:                	docreate(); CompileCpfa(iDOVAR); /* PFA dovariable */
9D003408  0F4007A2   JAL docreate
9D00340C  00000000   NOP
9D003410  0F400CCA   JAL CompileCpfa
9D003414  24040007   ADDIU A0, ZERO, 7
1265:                	heap(); comma(); vHeap+=cellsize;
9D003418  0F400112   JAL heap
9D00341C  00000000   NOP
9D003420  0F4007DD   JAL comma
9D003424  00000000   NOP
9D003428  8F8280E0   LW V0, -32544(GP)
9D00342C  24420004   ADDIU V0, V0, 4
9D003430  AF8280E0   SW V0, -32544(GP)
1266:                }
9D003434  8FBF0014   LW RA, 20(SP)
9D003438  03E00008   JR RA
9D00343C  27BD0018   ADDIU SP, SP, 24
1267:                
1268:                
1269:                // value ( x name -- ) 
1270:                void value(void)
1271:                {
9D0033AC  27BDFFE8   ADDIU SP, SP, -24
9D0033B0  AFBF0014   SW RA, 20(SP)
1272:                	docreate(); CompileCpfa(iDOVAL); /* PFA dovalue */
9D0033B4  0F4007A2   JAL docreate
9D0033B8  00000000   NOP
9D0033BC  0F400CCA   JAL CompileCpfa
9D0033C0  24040010   ADDIU A0, ZERO, 16
1273:                	pDATA vHeap=POP;  // value x
9D0033C4  8F828008   LW V0, -32760(GP)
9D0033C8  8C440000   LW A0, 0(V0)
9D0033CC  8F8380E0   LW V1, -32544(GP)
9D0033D0  AC640000   SW A0, 0(V1)
9D0033D4  2442FFFC   ADDIU V0, V0, -4
1274:                	heap(); comma(); vHeap+=cellsize;
9D0033D8  0F400112   JAL heap
9D0033DC  AF828008   SW V0, -32760(GP)
9D0033E0  0F4007DD   JAL comma
9D0033E4  00000000   NOP
9D0033E8  8F8280E0   LW V0, -32544(GP)
9D0033EC  24420004   ADDIU V0, V0, 4
9D0033F0  AF8280E0   SW V0, -32544(GP)
1275:                }
9D0033F4  8FBF0014   LW RA, 20(SP)
9D0033F8  03E00008   JR RA
9D0033FC  27BD0018   ADDIU SP, SP, 24
1276:                
1277:                
1278:                // (to) ( x -- )
1279:                void dotof(void)
1280:                {
1281:                	PC+=cellsize; pDATA PC=POP;
9D001974  8F8380BC   LW V1, -32580(GP)
9D001978  24620004   ADDIU V0, V1, 4
9D00197C  AF8280BC   SW V0, -32580(GP)
9D001980  8F828008   LW V0, -32760(GP)
9D001984  8C440000   LW A0, 0(V0)
9D001988  AC640004   SW A0, 4(V1)
9D00198C  2442FFFC   ADDIU V0, V0, -4
1282:                }
9D001990  03E00008   JR RA
9D001994  AF828008   SW V0, -32760(GP)
1283:                const void *xt_doto=dotof;
1284:                
1285:                
1286:                // to ( x name -- ) 
1287:                void tof(void)
1288:                {
9D0035A4  27BDFFE8   ADDIU SP, SP, -24
9D0035A8  AFBF0014   SW RA, 20(SP)
1289:                	tick(); TOS+=cellsize; fetch();
9D0035AC  0F400643   JAL tick
9D0035B0  00000000   NOP
9D0035B4  8F828008   LW V0, -32760(GP)
9D0035B8  8C430000   LW V1, 0(V0)
9D0035BC  24630004   ADDIU V1, V1, 4
9D0035C0  0F4000C5   JAL fetch
9D0035C4  AC430000   SW V1, 0(V0)
1290:                	if(vState) {CompileCcon(&xt_doto); comma();} else {store();}
9D0035C8  9382806E   LBU V0, -32658(GP)
9D0035CC  10400007   BEQ V0, ZERO, 0x9D0035EC
9D0035D0  00000000   NOP
9D0035D4  0F400D4F   JAL CompileCcon
9D0035D8  27848038   ADDIU A0, GP, -32712
9D0035DC  0F4007DD   JAL comma
9D0035E0  00000000   NOP
9D0035EC  0F4000D4   JAL store
9D0035F0  00000000   NOP
1291:                }
9D0035E4  0B400D7E   J 0x9D0035F8
9D0035E8  8FBF0014   LW RA, 20(SP)
9D0035F4  8FBF0014   LW RA, 20(SP)
9D0035F8  03E00008   JR RA
9D0035FC  27BD0018   ADDIU SP, SP, 24
1292:                
1293:                
1294:                // defer ( name -- )
1295:                void defer(void)
1296:                {
9D00336C  27BDFFE8   ADDIU SP, SP, -24
9D003370  AFBF0014   SW RA, 20(SP)
1297:                	docreate(); CompileCpfa(iDODEF); /* PFA dodefer */
9D003374  0F4007A2   JAL docreate
9D003378  00000000   NOP
9D00337C  0F400CCA   JAL CompileCpfa
9D003380  24040009   ADDIU A0, ZERO, 9
1298:                	heap(); comma(); vHeap+=cellsize;
9D003384  0F400112   JAL heap
9D003388  00000000   NOP
9D00338C  0F4007DD   JAL comma
9D003390  00000000   NOP
9D003394  8F8280E0   LW V0, -32544(GP)
9D003398  24420004   ADDIU V0, V0, 4
9D00339C  AF8280E0   SW V0, -32544(GP)
1299:                }
9D0033A0  8FBF0014   LW RA, 20(SP)
9D0033A4  03E00008   JR RA
9D0033A8  27BD0018   ADDIU SP, SP, 24
1300:                
1301:                
1302:                // defer@ ( xt1 -- xt2 )
1303:                void deferfetch(void)
1304:                {
1305:                	TOS+=cellsize; TOS=pDATA(pDATA(TOS));
9D001998  8F828008   LW V0, -32760(GP)
9D00199C  8C430000   LW V1, 0(V0)
9D0019A0  24630004   ADDIU V1, V1, 4
9D0019A4  AC430000   SW V1, 0(V0)
9D0019A8  8F828008   LW V0, -32760(GP)
9D0019AC  8C430000   LW V1, 0(V0)
9D0019B0  8C630000   LW V1, 0(V1)
9D0019B4  8C630000   LW V1, 0(V1)
1306:                }
9D0019B8  03E00008   JR RA
9D0019BC  AC430000   SW V1, 0(V0)
1307:                
1308:                
1309:                // defer! ( xt2 xt1 -- )
1310:                void deferstore(void)
1311:                {
1312:                	ucell x1=POP+cellsize;
9D0019C0  8F828008   LW V0, -32760(GP)
9D0019C4  8C430000   LW V1, 0(V0)
9D0019C8  2444FFFC   ADDIU A0, V0, -4
9D0019CC  AF848008   SW A0, -32760(GP)
1313:                	pDATA(pDATA(x1))=POP;
9D0019D0  8C630004   LW V1, 4(V1)
9D0019D4  8C44FFFC   LW A0, -4(V0)
9D0019D8  AC640000   SW A0, 0(V1)
9D0019DC  2442FFF8   ADDIU V0, V0, -8
1314:                }
9D0019E0  03E00008   JR RA
9D0019E4  AF828008   SW V0, -32760(GP)
1315:                
1316:                
1317:                // interpret ( ? -- ? )
1318:                void interpret(void)
1319:                {
9D002C94  27BDFFE0   ADDIU SP, SP, -32
9D002C98  AFBF001C   SW RA, 28(SP)
9D002C9C  AFB10018   SW S1, 24(SP)
9D002CA0  AFB00014   SW S0, 20(SP)
1320:                	char fRun=1;
9D002CA8  24100001   ADDIU S0, ZERO, 1
1321:                	
1322:                	vErrors=0;
9D002CA4  A380806F   SB ZERO, -32657(GP)
1323:                	while (fRun)
9D002DB8  1600FFBD   BNE S0, ZERO, 0x9D002CB0
9D002DBC  00000000   NOP
1324:                	{	
1325:                	  blf(); wordf(); dup();
9D002CB0  0F400318   JAL blf
9D002CB4  00000000   NOP
9D002CB8  0F400511   JAL wordf
9D002CBC  00000000   NOP
9D002CC0  0F400010   JAL dup
9D002CC4  00000000   NOP
1326:                	  cfetch();
9D002CC8  0F4000CA   JAL cfetch
9D002CCC  00000000   NOP
1327:                	  if (!POP) {drop(); vErrors|=1;}  // Empty TIB
9D002CD0  8F828008   LW V0, -32760(GP)
9D002CD4  8C430000   LW V1, 0(V0)
9D002CD8  2442FFFC   ADDIU V0, V0, -4
9D002CDC  14600007   BNE V1, ZERO, 0x9D002CFC
9D002CE0  AF828008   SW V0, -32760(GP)
9D002CE4  0F400008   JAL drop
9D002CE8  00000000   NOP
9D002CEC  9382806F   LBU V0, -32657(GP)
9D002CF0  34420001   ORI V0, V0, 1
9D002CF4  0B400B69   J 0x9D002DA4
9D002CF8  A382806F   SB V0, -32657(GP)
1328:                	  else
1329:                	  {
1330:                		find();	isdup();
9D002CFC  0F40058D   JAL find
9D002D00  00000000   NOP
9D002D04  0F400021   JAL isdup
9D002D08  00000000   NOP
1331:                		zeroequals();
9D002D0C  0F400240   JAL zeroequals
9D002D10  00000000   NOP
1332:                		if (POP) {number(); if (vState) {CompileCxt(iDOLIT); comma();}}  // compile number
9D002D14  8F828008   LW V0, -32760(GP)
9D002D18  8C430000   LW V1, 0(V0)
9D002D1C  2442FFFC   ADDIU V0, V0, -4
9D002D20  1060000C   BEQ V1, ZERO, 0x9D002D54
9D002D24  AF828008   SW V0, -32760(GP)
9D002D28  0F40084D   JAL number
9D002D2C  00000000   NOP
9D002D30  9382806E   LBU V0, -32658(GP)
9D002D34  5040001C   BEQL V0, ZERO, 0x9D002DA8
9D002D38  9382806F   LBU V0, -32657(GP)
9D002D3C  0F400B14   JAL CompileCxt
9D002D40  24040004   ADDIU A0, ZERO, 4
9D002D44  0F4007DD   JAL comma
9D002D48  00000000   NOP
1333:                		else
1334:                		{
1335:                		  zerogreater();
9D002D54  0F40024D   JAL zerogreater
9D002D58  00000000   NOP
1336:                		  if (POP) {executew();}  // immediate
9D002D5C  8F828008   LW V0, -32760(GP)
9D002D60  8C430000   LW V1, 0(V0)
9D002D64  2442FFFC   ADDIU V0, V0, -4
9D002D68  10600005   BEQ V1, ZERO, 0x9D002D80
9D002D6C  AF828008   SW V0, -32760(GP)
9D002D70  0F402C7C   JAL executew
9D002D74  00000000   NOP
1337:                		  else
1338:                		  {
1339:                			if (vState) {comma();} else {executew();}  // compile/interpreter
9D002D80  9382806E   LBU V0, -32658(GP)
9D002D84  10400005   BEQ V0, ZERO, 0x9D002D9C
9D002D88  00000000   NOP
9D002D8C  0F4007DD   JAL comma
9D002D90  00000000   NOP
9D002D9C  0F402C7C   JAL executew
9D002DA0  00000000   NOP
1340:                		  }
1341:                		}
1342:                	  }
1343:                	  if (vErrors) {fRun=0;}
9D002D4C  0B400B6A   J 0x9D002DA8
9D002D50  9382806F   LBU V0, -32657(GP)
9D002D78  0B400B6A   J 0x9D002DA8
9D002D7C  9382806F   LBU V0, -32657(GP)
9D002D94  0B400B6A   J 0x9D002DA8
9D002D98  9382806F   LBU V0, -32657(GP)
9D002DA4  9382806F   LBU V0, -32657(GP)
9D002DA8  0002800B   MOVN S0, ZERO, V0
1344:                	  if (vState==EndState) {fRun=0;}
9D002CAC  241100EE   ADDIU S1, ZERO, 238
9D002DAC  9382806E   LBU V0, -32658(GP)
9D002DB0  10510003   BEQ V0, S1, 0x9D002DC0
9D002DB4  8FBF001C   LW RA, 28(SP)
1345:                	}
1346:                }
9D002DC0  8FB10018   LW S1, 24(SP)
9D002DC4  8FB00014   LW S0, 20(SP)
9D002DC8  03E00008   JR RA
9D002DCC  27BD0020   ADDIU SP, SP, 32
1347:                
1348:                
1349:                // quit ( -- )
1350:                void quit(void)
1351:                {
9D002DD0  27BDFFD8   ADDIU SP, SP, -40
9D002DD4  AFBF0024   SW RA, 36(SP)
9D002DD8  AFB40020   SW S4, 32(SP)
9D002DDC  AFB3001C   SW S3, 28(SP)
9D002DE0  AFB20018   SW S2, 24(SP)
9D002DE4  AFB10014   SW S1, 20(SP)
9D002DE8  AFB00010   SW S0, 16(SP)
1352:                	pDS=pDSzero; pRS=pRSzero; lbracket();
9D002DEC  8F828004   LW V0, -32764(GP)
9D002DF0  AF828008   SW V0, -32760(GP)
9D002DF4  8F82800C   LW V0, -32756(GP)
9D002DF8  0F4004EA   JAL lbracket
9D002DFC  AF828010   SW V0, -32752(GP)
1353:                	do {
1354:                	  if (!vState) {crf(); PUSH('>'); emit(); blf(); emit();}
9D002E00  2412003E   ADDIU S2, ZERO, 62
9D002E14  9382806E   LBU V0, -32658(GP)
9D002E18  1440000C   BNE V0, ZERO, 0x9D002E4C
9D002E1C  00000000   NOP
9D002E20  0F40097A   JAL crf
9D002E24  00000000   NOP
9D002E28  8F828008   LW V0, -32760(GP)
9D002E2C  24430004   ADDIU V1, V0, 4
9D002E30  AF838008   SW V1, -32760(GP)
9D002E34  0F4008CE   JAL emit
9D002E38  AC520004   SW S2, 4(V0)
9D002E3C  0F400318   JAL blf
9D002E40  00000000   NOP
9D002E44  0F4008CE   JAL emit
9D002E48  00000000   NOP
1355:                	  refill(); POP;
9D002E4C  0F400AAF   JAL refill
9D002E50  00000000   NOP
9D002E54  8F828008   LW V0, -32760(GP)
9D002E58  2442FFFC   ADDIU V0, V0, -4
9D002E5C  AF828008   SW V0, -32760(GP)
1356:                	  vErrors=0; interpret();
9D002E60  0F400B25   JAL interpret
9D002E64  A380806F   SB ZERO, -32657(GP)
1357:                	  if (vErrors<=1) {blf(); emit(); PUSH('o'); emit(); PUSH('k'); emit();}
9D002E08  2413006F   ADDIU S3, ZERO, 111
9D002E0C  2414006B   ADDIU S4, ZERO, 107
9D002E68  9382806F   LBU V0, -32657(GP)
9D002E6C  2C420002   SLTIU V0, V0, 2
9D002E70  10400011   BEQ V0, ZERO, 0x9D002EB8
9D002E74  00000000   NOP
9D002E78  0F400318   JAL blf
9D002E7C  00000000   NOP
9D002E80  0F4008CE   JAL emit
9D002E84  00000000   NOP
9D002E88  8F828008   LW V0, -32760(GP)
9D002E8C  24430004   ADDIU V1, V0, 4
9D002E90  AF838008   SW V1, -32760(GP)
9D002E94  0F4008CE   JAL emit
9D002E98  AC530004   SW S3, 4(V0)
9D002E9C  8F828008   LW V0, -32760(GP)
9D002EA0  24430004   ADDIU V1, V0, 4
9D002EA4  AF838008   SW V1, -32760(GP)
9D002EA8  0F4008CE   JAL emit
9D002EAC  AC540004   SW S4, 4(V0)
1358:                	  else {blf(); emit(); PUSH('?'); emit(); PUSH('?'); emit(); PUSH(vErrors); udot();}
9D002E04  2410003F   ADDIU S0, ZERO, 63
9D002EB8  0F400318   JAL blf
9D002EBC  00000000   NOP
9D002EC0  0F4008CE   JAL emit
9D002EC4  00000000   NOP
9D002EC8  8F828008   LW V0, -32760(GP)
9D002ECC  24430004   ADDIU V1, V0, 4
9D002ED0  AF838008   SW V1, -32760(GP)
9D002ED4  0F4008CE   JAL emit
9D002ED8  AC500004   SW S0, 4(V0)
9D002EDC  8F828008   LW V0, -32760(GP)
9D002EE0  24430004   ADDIU V1, V0, 4
9D002EE4  AF838008   SW V1, -32760(GP)
9D002EE8  0F4008CE   JAL emit
9D002EEC  AC500004   SW S0, 4(V0)
9D002EF0  8F828008   LW V0, -32760(GP)
9D002EF4  24430004   ADDIU V1, V0, 4
9D002EF8  AF838008   SW V1, -32760(GP)
9D002EFC  9383806F   LBU V1, -32657(GP)
9D002F00  0F400963   JAL udot
9D002F04  AC430004   SW V1, 4(V0)
1359:                	} while (vState!=EndState);
9D002E10  241100EE   ADDIU S1, ZERO, 238
9D002EB0  0B400BC3   J 0x9D002F0C
9D002EB4  9382806E   LBU V0, -32658(GP)
9D002F08  9382806E   LBU V0, -32658(GP)
9D002F0C  5451FFC2   BNEL V0, S1, 0x9D002E18
9D002F10  9382806E   LBU V0, -32658(GP)
1360:                }
9D002F14  8FBF0024   LW RA, 36(SP)
9D002F18  8FB40020   LW S4, 32(SP)
9D002F1C  8FB3001C   LW S3, 28(SP)
9D002F20  8FB20018   LW S2, 24(SP)
9D002F24  8FB10014   LW S1, 20(SP)
9D002F28  8FB00010   LW S0, 16(SP)
9D002F2C  03E00008   JR RA
9D002F30  27BD0028   ADDIU SP, SP, 40
1361:                
1362:                
1363:                // cold ( -- )
1364:                void cold(void)
1365:                {
9D002F34  27BDFFE8   ADDIU SP, SP, -24
9D002F38  AFBF0014   SW RA, 20(SP)
9D002F3C  AFB00010   SW S0, 16(SP)
1366:                
1367:                      // Default init
1368:                #ifdef VPC_32
1369:                    char error=0;
9D002F58  2C500001   SLTIU S0, V0, 1
1370:                    if (vPad==NULL){
9D002F40  8F828060   LW V0, -32672(GP)
9D002F44  14400005   BNE V0, ZERO, 0x9D002F5C
9D002F48  00008021   ADDU S0, ZERO, ZERO
1371:                        vPad=malloc(padsize*sizeof(char));
9D002F4C  0F403875   JAL malloc
9D002F50  24040050   ADDIU A0, ZERO, 80
9D002F54  AF828060   SW V0, -32672(GP)
1372:                        if (!vPad) error=1;
1373:                    }
1374:                    if (vTib==NULL){
9D002F5C  8F82805C   LW V0, -32676(GP)
9D002F60  14400007   BNE V0, ZERO, 0x9D002F80
9D002F64  8F848064   LW A0, -32668(GP)
1375:                        vTib=malloc(padsize*sizeof(char));
9D002F68  0F403875   JAL malloc
9D002F6C  24040050   ADDIU A0, ZERO, 80
9D002F70  AF82805C   SW V0, -32676(GP)
1376:                        if (!vTib) error=1;
9D002F74  24030001   ADDIU V1, ZERO, 1
9D002F78  0062800A   MOVZ S0, V1, V0
1377:                    }
1378:                    if (vDict!=NULL){free(vDict);}
9D002F7C  8F848064   LW A0, -32668(GP)
9D002F80  10800003   BEQ A0, ZERO, 0x9D002F90
9D002F84  00000000   NOP
9D002F88  0F40403F   JAL free
9D002F8C  00000000   NOP
1379:                    vDict=malloc(dictsize*sizeof(char));
9D002F90  0F403875   JAL malloc
9D002F94  24040400   ADDIU A0, ZERO, 1024
9D002F98  AF828064   SW V0, -32668(GP)
1380:                    if (!vDict) error=1;
9D002F9C  24030001   ADDIU V1, ZERO, 1
1381:                    if (vMem!=NULL){free(vMem);}
9D002FA0  8F848068   LW A0, -32664(GP)
9D002FA4  10800003   BEQ A0, ZERO, 0x9D002FB4
9D002FA8  0062800A   MOVZ S0, V1, V0
9D002FAC  0F40403F   JAL free
9D002FB0  00000000   NOP
1382:                    vMem=malloc(memsize*sizeof(char));
9D002FB4  0F403875   JAL malloc
9D002FB8  24041000   ADDIU A0, ZERO, 4096
1383:                    if (!vMem) error=1;
9D002FBC  10400003   BEQ V0, ZERO, 0x9D002FCC
9D002FC0  AF828068   SW V0, -32664(GP)
1384:                    if (error){
9D002FC4  12000007   BEQ S0, ZERO, 0x9D002FE4
9D002FC8  93828067   LBU V0, -32665(GP)
1385:                        print(comm_channel,"not enough memory\r");
9D002FCC  83848088   LB A0, -32632(GP)
9D002FD0  3C059D00   LUI A1, -25344
9D002FD4  0F402624   JAL print
9D002FD8  24A56A84   ADDIU A1, A1, 27268
1386:                        return;
9D002FDC  0B400C14   J 0x9D003050
9D002FE0  8FBF0014   LW RA, 20(SP)
1387:                    }
1388:                #endif
1389:                	AddrRAM=(ucell)vDict>>24; AddrROM=(ucell)primwords>>24;
9D002FE4  A38280C9   SB V0, -32567(GP)
9D002FE8  3C029D00   LUI V0, -25344
9D002FEC  2442707C   ADDIU V0, V0, 28796
9D002FF0  00021602   SRL V0, V0, 24
9D002FF4  A38280C8   SB V0, -32568(GP)
1390:                	pDS=pDSzero; pRS=pRSzero; 
9D002FF8  8F828004   LW V0, -32764(GP)
9D002FFC  AF828008   SW V0, -32760(GP)
9D003000  8F82800C   LW V0, -32756(GP)
9D003004  AF828010   SW V0, -32752(GP)
1391:                	vIN=0; vSharpTib=0;
9D003008  A380806C   SB ZERO, -32660(GP)
9D00300C  A380806D   SB ZERO, -32659(GP)
1392:                #ifdef VPC_32
1393:                        vBase=10;
9D003010  2402000A   ADDIU V0, ZERO, 10
9D003014  A3828014   SB V0, -32748(GP)
1394:                #else
1395:                        vBase=16;
1396:                #endif
1397:                        vState=0; vErrors=0;
9D003018  A380806E   SB ZERO, -32658(GP)
1398:                	FindLastC(); vHead=0; vHere=vDict; vHeap=vMem;
9D00301C  0F400AC2   JAL FindLastC
9D003020  A380806F   SB ZERO, -32657(GP)
9D003024  AF8080D8   SW ZERO, -32552(GP)
9D003028  8F828064   LW V0, -32668(GP)
9D00302C  AF8280D0   SW V0, -32560(GP)
9D003030  8F828068   LW V0, -32664(GP)
1399:                	// From flash init
1400:                	EEcold();
9D003034  0F400AD0   JAL EEcold
9D003038  AF8280E0   SW V0, -32544(GP)
1401:                	ver();
9D00303C  0F40098B   JAL ver
9D003040  00000000   NOP
1402:                	quit();
9D003044  0F400B74   JAL quit
9D003048  00000000   NOP
1403:                }
9D00304C  8FBF0014   LW RA, 20(SP)
9D003050  8FB00010   LW S0, 16(SP)
9D003054  03E00008   JR RA
9D003058  27BD0018   ADDIU SP, SP, 24
1404:                
1405:                
1406:                // ********** EMIT **********
1407:                
1408:                
1409:                // cr ( -- )
1410:                void crf(void) {PUSH(CRD); emit(); PUSH(CRA); emit();}
9D0025E8  27BDFFE8   ADDIU SP, SP, -24
9D0025EC  AFBF0014   SW RA, 20(SP)
9D0025F0  8F828008   LW V0, -32760(GP)
9D0025F4  24430004   ADDIU V1, V0, 4
9D0025F8  AF838008   SW V1, -32760(GP)
9D0025FC  2403000D   ADDIU V1, ZERO, 13
9D002600  0F4008CE   JAL emit
9D002604  AC430004   SW V1, 4(V0)
9D002608  8F828008   LW V0, -32760(GP)
9D00260C  24430004   ADDIU V1, V0, 4
9D002610  AF838008   SW V1, -32760(GP)
9D002614  2403000A   ADDIU V1, ZERO, 10
9D002618  0F4008CE   JAL emit
9D00261C  AC430004   SW V1, 4(V0)
9D002620  8FBF0014   LW RA, 20(SP)
9D002624  03E00008   JR RA
9D002628  27BD0018   ADDIU SP, SP, 24
1411:                
1412:                
1413:                // space ( -- )
1414:                void spacef(void) {blf(); emit();}
9D0025C4  27BDFFE8   ADDIU SP, SP, -24
9D0025C8  AFBF0014   SW RA, 20(SP)
9D0025CC  0F400318   JAL blf
9D0025D0  00000000   NOP
9D0025D4  0F4008CE   JAL emit
9D0025D8  00000000   NOP
9D0025DC  8FBF0014   LW RA, 20(SP)
9D0025E0  03E00008   JR RA
9D0025E4  27BD0018   ADDIU SP, SP, 24
1415:                
1416:                
1417:                // spaces ( n -- )
1418:                void spaces(void) {cell i, n=POP; if (n>0) {for(i=0; i<n; i++) {blf(); emit();}}}
9D002408  27BDFFE0   ADDIU SP, SP, -32
9D00240C  AFBF001C   SW RA, 28(SP)
9D002410  AFB10018   SW S1, 24(SP)
9D002414  AFB00014   SW S0, 20(SP)
9D002418  8F828008   LW V0, -32760(GP)
9D00241C  8C510000   LW S1, 0(V0)
9D002420  2442FFFC   ADDIU V0, V0, -4
9D002424  1A200008   BLEZ S1, 0x9D002448
9D002428  AF828008   SW V0, -32760(GP)
9D00242C  00008021   ADDU S0, ZERO, ZERO
9D002430  0F400318   JAL blf
9D002434  26100001   ADDIU S0, S0, 1
9D002438  0F4008CE   JAL emit
9D00243C  00000000   NOP
9D002440  1611FFFB   BNE S0, S1, 0x9D002430
9D002444  00000000   NOP
9D002448  8FBF001C   LW RA, 28(SP)
9D00244C  8FB10018   LW S1, 24(SP)
9D002450  8FB00014   LW S0, 20(SP)
9D002454  03E00008   JR RA
9D002458  27BD0020   ADDIU SP, SP, 32
1419:                
1420:                
1421:                // type ( addr u -- )
1422:                void typef(void)
9D002398  00718821   ADDU S1, V1, S1
1423:                {
9D002364  27BDFFE0   ADDIU SP, SP, -32
9D002368  AFBF001C   SW RA, 28(SP)
9D00236C  AFB10018   SW S1, 24(SP)
9D002370  AFB00014   SW S0, 20(SP)
1424:                	ucell i, u=POP;
9D002374  8F828008   LW V0, -32760(GP)
9D002378  8C430000   LW V1, 0(V0)
9D00237C  2444FFFC   ADDIU A0, V0, -4
9D002380  AF848008   SW A0, -32760(GP)
1425:                	char *p=(char *)(ucell)POP;
9D002384  8C51FFFC   LW S1, -4(V0)
9D002388  2442FFF8   ADDIU V0, V0, -8
9D002394  02208021   ADDU S0, S1, ZERO
1426:                
1427:                	if (u>0) {for(i=0; i<u; i++) {PUSH(*p++); emit();}}
9D00238C  1060000C   BEQ V1, ZERO, 0x9D0023C0
9D002390  AF828008   SW V0, -32760(GP)
9D00239C  8F828008   LW V0, -32760(GP)
9D0023A0  24430004   ADDIU V1, V0, 4
9D0023A4  AF838008   SW V1, -32760(GP)
9D0023A8  82030000   LB V1, 0(S0)
9D0023AC  AC430004   SW V1, 4(V0)
9D0023B0  0F4008CE   JAL emit
9D0023B4  26100001   ADDIU S0, S0, 1
9D0023B8  1611FFF9   BNE S0, S1, 0x9D0023A0
9D0023BC  8F828008   LW V0, -32760(GP)
1428:                }
9D0023C0  8FBF001C   LW RA, 28(SP)
9D0023C4  8FB10018   LW S1, 24(SP)
9D0023C8  8FB00014   LW S0, 20(SP)
9D0023CC  03E00008   JR RA
9D0023D0  27BD0020   ADDIU SP, SP, 32
1429:                const void *xt_type=typef;
1430:                
1431:                
1432:                // ." ( -- )
1433:                void dotstring(void) {squote(); if (vState) {CompileCcon(&xt_type);} else {typef();}}
9D003564  27BDFFE8   ADDIU SP, SP, -24
9D003568  AFBF0014   SW RA, 20(SP)
9D00356C  0F400C20   JAL squote
9D003570  00000000   NOP
9D003574  9382806E   LBU V0, -32658(GP)
9D003578  10400005   BEQ V0, ZERO, 0x9D003590
9D00357C  00000000   NOP
9D003580  0F400D4F   JAL CompileCcon
9D003584  2784803C   ADDIU A0, GP, -32708
9D003588  0B400D67   J 0x9D00359C
9D00358C  8FBF0014   LW RA, 20(SP)
9D003590  0F4008D9   JAL typef
9D003594  00000000   NOP
9D003598  8FBF0014   LW RA, 20(SP)
9D00359C  03E00008   JR RA
9D0035A0  27BD0018   ADDIU SP, SP, 24
1434:                
1435:                
1436:                // .( ( -- )
1437:                void dotlparen(void) {PUSH(')'); parse(); typef();}
9D0023D4  27BDFFE8   ADDIU SP, SP, -24
9D0023D8  AFBF0014   SW RA, 20(SP)
9D0023DC  8F828008   LW V0, -32760(GP)
9D0023E0  24430004   ADDIU V1, V0, 4
9D0023E4  AF838008   SW V1, -32760(GP)
9D0023E8  24030029   ADDIU V1, ZERO, 41
9D0023EC  0F40055A   JAL parse
9D0023F0  AC430004   SW V1, 4(V0)
9D0023F4  0F4008D9   JAL typef
9D0023F8  00000000   NOP
9D0023FC  8FBF0014   LW RA, 20(SP)
9D002400  03E00008   JR RA
9D002404  27BD0018   ADDIU SP, SP, 24
1438:                
1439:                
1440:                // ( ( -- )
1441:                void lparen(void) {PUSH(')'); parse(); twodrop();}
9D0019E8  27BDFFE8   ADDIU SP, SP, -24
9D0019EC  AFBF0014   SW RA, 20(SP)
9D0019F0  8F828008   LW V0, -32760(GP)
9D0019F4  24430004   ADDIU V1, V0, 4
9D0019F8  AF838008   SW V1, -32760(GP)
9D0019FC  24030029   ADDIU V1, ZERO, 41
9D001A00  0F40055A   JAL parse
9D001A04  AC430004   SW V1, 4(V0)
9D001A08  0F40000C   JAL twodrop
9D001A0C  00000000   NOP
9D001A10  8FBF0014   LW RA, 20(SP)
9D001A14  03E00008   JR RA
9D001A18  27BD0018   ADDIU SP, SP, 24
1442:                
1443:                
1444:                // hold ( c -- )
1445:                void hold(void)
9D001A50  00042027   NOR A0, ZERO, A0
9D001A54  00442021   ADDU A0, V0, A0
1446:                {
1447:                	cell c=POP, len=vPad[0], i;
9D001A1C  8F828008   LW V0, -32760(GP)
9D001A20  8C450000   LW A1, 0(V0)
9D001A24  2442FFFC   ADDIU V0, V0, -4
9D001A28  AF828008   SW V0, -32760(GP)
9D001A2C  8F838060   LW V1, -32672(GP)
9D001A30  80640000   LB A0, 0(V1)
1448:                	char *p1, *p2;
1449:                
1450:                	if (len<padsize-1)
9D001A34  2882004F   SLTI V0, A0, 79
9D001A38  1040000C   BEQ V0, ZERO, 0x9D001A6C
9D001A3C  24820001   ADDIU V0, A0, 1
1451:                	{
1452:                	  len++; vPad[0]=len; p1=vPad+len; p2=p1++;
9D001A40  A0620000   SB V0, 0(V1)
9D001A4C  00621021   ADDU V0, V1, V0
1453:                	  for (i=0; i<len; i++) {*p1--=*p2--;}
9D001A44  18400009   BLEZ V0, 0x9D001A6C
9D001A48  8F838060   LW V1, -32672(GP)
9D001A58  90430000   LBU V1, 0(V0)
9D001A5C  A0430001   SB V1, 1(V0)
9D001A60  2442FFFF   ADDIU V0, V0, -1
9D001A64  5444FFFD   BNEL V0, A0, 0x9D001A5C
9D001A68  90430000   LBU V1, 0(V0)
1454:                	  //memmove(&vPad[1], &vPad[2], vPad[0]);
1455:                	}
1456:                	vPad[1]=c;
9D001A6C  8F828060   LW V0, -32672(GP)
1457:                }
9D001A70  03E00008   JR RA
9D001A74  A0450001   SB A1, 1(V0)
1458:                
1459:                
1460:                // <# ( -- )
1461:                void sharpl(void) {vPad[0]=0;}
9D001A78  8F828060   LW V0, -32672(GP)
9D001A7C  03E00008   JR RA
9D001A80  A0400000   SB ZERO, 0(V0)
1462:                
1463:                
1464:                // # ( x1 -- x2 )
1465:                void sharp(void)
1466:                {
9D001A84  27BDFFE8   ADDIU SP, SP, -24
9D001A88  AFBF0014   SW RA, 20(SP)
1467:                	cell x;
1468:                	base(); cfetch(); udivmod(); swap(); x=POP;
9D001A8C  0F4002FB   JAL base
9D001A90  00000000   NOP
9D001A94  0F4000CA   JAL cfetch
9D001A98  00000000   NOP
9D001A9C  0F4003F6   JAL udivmod
9D001AA0  00000000   NOP
9D001AA4  0F400055   JAL swap
9D001AA8  00000000   NOP
9D001AAC  8F838008   LW V1, -32760(GP)
9D001AB0  8C620000   LW V0, 0(V1)
1469:                	if (x>9) {x+=7;}
9D001AB4  2845000A   SLTI A1, V0, 10
9D001AB8  24440007   ADDIU A0, V0, 7
9D001ABC  0085100A   MOVZ V0, A0, A1
1470:                	PUSH(x+0x30); hold();
9D001AC0  24420030   ADDIU V0, V0, 48
9D001AC4  0F400687   JAL hold
9D001AC8  AC620000   SW V0, 0(V1)
1471:                }
9D001ACC  8FBF0014   LW RA, 20(SP)
9D001AD0  03E00008   JR RA
9D001AD4  27BD0018   ADDIU SP, SP, 24
1472:                
1473:                
1474:                // #s ( x -- 0 )
1475:                void sharps(void) {do{sharp();} while (TOS!=0);}
9D001AD8  27BDFFE8   ADDIU SP, SP, -24
9D001ADC  AFBF0014   SW RA, 20(SP)
9D001AE0  0F4006A1   JAL sharp
9D001AE4  00000000   NOP
9D001AE8  8F828008   LW V0, -32760(GP)
9D001AEC  8C420000   LW V0, 0(V0)
9D001AF0  1440FFFB   BNE V0, ZERO, 0x9D001AE0
9D001AF4  8FBF0014   LW RA, 20(SP)
9D001AF8  03E00008   JR RA
9D001AFC  27BD0018   ADDIU SP, SP, 24
1476:                
1477:                
1478:                // #> ( x -- addr len )
1479:                void sharpg(void) {TOS=(ucell)vPad; count();}
9D001B00  27BDFFE8   ADDIU SP, SP, -24
9D001B04  AFBF0014   SW RA, 20(SP)
9D001B08  8F838060   LW V1, -32672(GP)
9D001B0C  8F828008   LW V0, -32760(GP)
9D001B10  0F400504   JAL count
9D001B14  AC430000   SW V1, 0(V0)
9D001B18  8FBF0014   LW RA, 20(SP)
9D001B1C  03E00008   JR RA
9D001B20  27BD0018   ADDIU SP, SP, 24
1480:                
1481:                
1482:                // u.r ( u n -- )
1483:                void udotr(void)
1484:                {
9D0024F0  27BDFFE8   ADDIU SP, SP, -24
9D0024F4  AFBF0014   SW RA, 20(SP)
9D0024F8  AFB00010   SW S0, 16(SP)
1485:                	cell n=POP, len;
9D0024FC  8F828008   LW V0, -32760(GP)
9D002500  8C500000   LW S0, 0(V0)
9D002504  2442FFFC   ADDIU V0, V0, -4
1486:                	sharpl(); sharps(); sharpg(); len=TOS; // ( u -- addr len )
9D002508  0F40069E   JAL sharpl
9D00250C  AF828008   SW V0, -32760(GP)
9D002510  0F4006B6   JAL sharps
9D002514  00000000   NOP
9D002518  0F4006C0   JAL sharpg
9D00251C  00000000   NOP
9D002520  8F828008   LW V0, -32760(GP)
9D002524  8C430000   LW V1, 0(V0)
1487:                	PUSH(n-len); spaces(); typef();
9D002528  24440004   ADDIU A0, V0, 4
9D00252C  AF848008   SW A0, -32760(GP)
9D002530  02038023   SUBU S0, S0, V1
9D002534  0F400902   JAL spaces
9D002538  AC500004   SW S0, 4(V0)
9D00253C  0F4008D9   JAL typef
9D002540  00000000   NOP
1488:                }
9D002544  8FBF0014   LW RA, 20(SP)
9D002548  8FB00010   LW S0, 16(SP)
9D00254C  03E00008   JR RA
9D002550  27BD0018   ADDIU SP, SP, 24
1489:                
1490:                
1491:                // u. ( u -- )
1492:                void udot(void) {PUSH(0); udotr(); blf(); emit();}
9D00258C  27BDFFE8   ADDIU SP, SP, -24
9D002590  AFBF0014   SW RA, 20(SP)
9D002594  8F828008   LW V0, -32760(GP)
9D002598  24430004   ADDIU V1, V0, 4
9D00259C  AF838008   SW V1, -32760(GP)
9D0025A0  0F40093C   JAL udotr
9D0025A4  AC400004   SW ZERO, 4(V0)
9D0025A8  0F400318   JAL blf
9D0025AC  00000000   NOP
9D0025B0  0F4008CE   JAL emit
9D0025B4  00000000   NOP
9D0025B8  8FBF0014   LW RA, 20(SP)
9D0025BC  03E00008   JR RA
9D0025C0  27BD0018   ADDIU SP, SP, 24
1493:                
1494:                
1495:                // .r ( n1 n2 -- )
1496:                void dotr(void)
1497:                {
9D00245C  27BDFFE0   ADDIU SP, SP, -32
9D002460  AFBF001C   SW RA, 28(SP)
9D002464  AFB10018   SW S1, 24(SP)
9D002468  AFB00014   SW S0, 20(SP)
1498:                	cell n2=POP, n1=TOS, len;
9D00246C  8F828008   LW V0, -32760(GP)
9D002470  8C510000   LW S1, 0(V0)
9D002474  2443FFFC   ADDIU V1, V0, -4
9D002478  AF838008   SW V1, -32760(GP)
1499:                	absf(); sharpl(); sharps(); if (n1<0) {PUSH('-'); hold();}
9D00247C  0F4001B6   JAL absf
9D002480  8C50FFFC   LW S0, -4(V0)
9D002484  0F40069E   JAL sharpl
9D002488  00000000   NOP
9D00248C  0F4006B6   JAL sharps
9D002490  00000000   NOP
9D002494  06010006   BGEZ S0, 0x9D0024B0
9D002498  8F828008   LW V0, -32760(GP)
9D00249C  24430004   ADDIU V1, V0, 4
9D0024A0  AF838008   SW V1, -32760(GP)
9D0024A4  2403002D   ADDIU V1, ZERO, 45
9D0024A8  0F400687   JAL hold
9D0024AC  AC430004   SW V1, 4(V0)
1500:                	sharpg(); len=TOS; // ( u -- addr len )
9D0024B0  0F4006C0   JAL sharpg
9D0024B4  00000000   NOP
9D0024B8  8F828008   LW V0, -32760(GP)
9D0024BC  8C430000   LW V1, 0(V0)
1501:                	PUSH(n2-len); spaces(); typef();
9D0024C0  24440004   ADDIU A0, V0, 4
9D0024C4  AF848008   SW A0, -32760(GP)
9D0024C8  02238823   SUBU S1, S1, V1
9D0024CC  0F400902   JAL spaces
9D0024D0  AC510004   SW S1, 4(V0)
9D0024D4  0F4008D9   JAL typef
9D0024D8  00000000   NOP
1502:                }
9D0024DC  8FBF001C   LW RA, 28(SP)
9D0024E0  8FB10018   LW S1, 24(SP)
9D0024E4  8FB00014   LW S0, 20(SP)
9D0024E8  03E00008   JR RA
9D0024EC  27BD0020   ADDIU SP, SP, 32
1503:                
1504:                
1505:                // . ( n -- )
1506:                void dot(void) {PUSH(0); dotr(); blf(); emit();}
9D002554  27BDFFE8   ADDIU SP, SP, -24
9D002558  AFBF0014   SW RA, 20(SP)
9D00255C  8F828008   LW V0, -32760(GP)
9D002560  24430004   ADDIU V1, V0, 4
9D002564  AF838008   SW V1, -32760(GP)
9D002568  0F400917   JAL dotr
9D00256C  AC400004   SW ZERO, 4(V0)
9D002570  0F400318   JAL blf
9D002574  00000000   NOP
9D002578  0F4008CE   JAL emit
9D00257C  00000000   NOP
9D002580  8FBF0014   LW RA, 20(SP)
9D002584  03E00008   JR RA
9D002588  27BD0018   ADDIU SP, SP, 24
1507:                
1508:                
1509:                // \ ( -- )
1510:                void backslash(void) {vIN=vSharpTib;}
9D001B24  9382806D   LBU V0, -32659(GP)
9D001B28  03E00008   JR RA
9D001B2C  A382806C   SB V0, -32660(GP)
1511:                
1512:                
1513:                // dump ( addr u -- )
1514:                void dump(void)
1515:                {
9D002864  27BDFFD8   ADDIU SP, SP, -40
9D002868  AFBF0024   SW RA, 36(SP)
9D00286C  AFB30020   SW S3, 32(SP)
9D002870  AFB2001C   SW S2, 28(SP)
9D002874  AFB10018   SW S1, 24(SP)
9D002878  AFB00014   SW S0, 20(SP)
1516:                	ucell i, u=POP;
9D00287C  8F828008   LW V0, -32760(GP)
9D002880  8C520000   LW S2, 0(V0)
9D002884  2443FFFC   ADDIU V1, V0, -4
9D002888  AF838008   SW V1, -32760(GP)
1517:                	ucell *p=(ucell *)POP;
9D00288C  8C50FFFC   LW S0, -4(V0)
9D002890  2442FFF8   ADDIU V0, V0, -8
9D00289C  00008821   ADDU S1, ZERO, ZERO
1518:                
1519:                	if (u>0) {for(i=0; i<u; i++)
9D002894  12400017   BEQ S2, ZERO, 0x9D0028F4
9D002898  AF828008   SW V0, -32760(GP)
9D0028EC  1651FFEE   BNE S2, S1, 0x9D0028A8
9D0028F0  8F828008   LW V0, -32760(GP)
1520:                	{
1521:                	  PUSH(*p++);
9D0028A4  8F828008   LW V0, -32760(GP)
9D0028A8  24430004   ADDIU V1, V0, 4
9D0028AC  AF838008   SW V1, -32760(GP)
9D0028B0  8E030000   LW V1, 0(S0)
9D0028B4  AC430004   SW V1, 4(V0)
1522:                	  if (vBase==10) {dot();} else {udot();}
9D0028A0  2413000A   ADDIU S3, ZERO, 10
9D0028B8  93828014   LBU V0, -32748(GP)
9D0028BC  14530005   BNE V0, S3, 0x9D0028D4
9D0028C0  26100004   ADDIU S0, S0, 4
9D0028C4  0F400955   JAL dot
9D0028C8  00000000   NOP
9D0028CC  0B400A37   J 0x9D0028DC
9D0028D0  00000000   NOP
9D0028D4  0F400963   JAL udot
9D0028D8  00000000   NOP
1523:                	  blf(); emit();
9D0028DC  0F400318   JAL blf
9D0028E0  26310001   ADDIU S1, S1, 1
9D0028E4  0F4008CE   JAL emit
9D0028E8  00000000   NOP
1524:                	}}
1525:                	crf();
9D0028F4  0F40097A   JAL crf
9D0028F8  00000000   NOP
1526:                }
9D0028FC  8FBF0024   LW RA, 36(SP)
9D002900  8FB30020   LW S3, 32(SP)
9D002904  8FB2001C   LW S2, 28(SP)
9D002908  8FB10018   LW S1, 24(SP)
9D00290C  8FB00014   LW S0, 20(SP)
9D002910  03E00008   JR RA
9D002914  27BD0028   ADDIU SP, SP, 40
1527:                
1528:                
1529:                // .s ( -- )
1530:                void dots(void)
1531:                {
9D0027B8  27BDFFD8   ADDIU SP, SP, -40
9D0027BC  AFBF0024   SW RA, 36(SP)
9D0027C0  AFB30020   SW S3, 32(SP)
9D0027C4  AFB2001C   SW S2, 28(SP)
9D0027C8  AFB10018   SW S1, 24(SP)
9D0027CC  AFB00014   SW S0, 20(SP)
1532:                	cell i, n=DScnt;
9D0027D0  8F908004   LW S0, -32764(GP)
9D0027D4  8F928008   LW S2, -32760(GP)
9D0027D8  02509023   SUBU S2, S2, S0
9D0027DC  00129083   SRA S2, S2, 2
1533:                	ucell *p=(ucell *)pDSzero;
1534:                
1535:                	if (n>0) {for(i=0; i<n; i++)
9D0027E0  1A400017   BLEZ S2, 0x9D002840
9D0027E4  00008821   ADDU S1, ZERO, ZERO
9D002838  1632FFED   BNE S1, S2, 0x9D0027F0
9D00283C  8F828008   LW V0, -32760(GP)
1536:                	{
1537:                	  PUSH(*++p);
9D0027EC  8F828008   LW V0, -32760(GP)
9D0027F0  24430004   ADDIU V1, V0, 4
9D0027F4  AF838008   SW V1, -32760(GP)
9D0027F8  26100004   ADDIU S0, S0, 4
9D0027FC  8E030000   LW V1, 0(S0)
9D002800  AC430004   SW V1, 4(V0)
1538:                	  if (vBase==10) {dot();} else {udot();}
9D0027E8  2413000A   ADDIU S3, ZERO, 10
9D002804  93828014   LBU V0, -32748(GP)
9D002808  14530005   BNE V0, S3, 0x9D002820
9D00280C  00000000   NOP
9D002810  0F400955   JAL dot
9D002814  00000000   NOP
9D002818  0B400A0A   J 0x9D002828
9D00281C  00000000   NOP
9D002820  0F400963   JAL udot
9D002824  00000000   NOP
1539:                	  blf(); emit();
9D002828  0F400318   JAL blf
9D00282C  26310001   ADDIU S1, S1, 1
9D002830  0F4008CE   JAL emit
9D002834  00000000   NOP
1540:                	}}
1541:                	crf();
9D002840  0F40097A   JAL crf
9D002844  00000000   NOP
1542:                }
9D002848  8FBF0024   LW RA, 36(SP)
9D00284C  8FB30020   LW S3, 32(SP)
9D002850  8FB2001C   LW S2, 28(SP)
9D002854  8FB10018   LW S1, 24(SP)
9D002858  8FB00014   LW S0, 20(SP)
9D00285C  03E00008   JR RA
9D002860  27BD0028   ADDIU SP, SP, 40
1543:                
1544:                
1545:                // ver ( -- )
1546:                void ver(void) {
9D00262C  27BDFFE8   ADDIU SP, SP, -24
9D002630  AFBF0014   SW RA, 20(SP)
1547:                #ifdef VPC_32
1548:                    print(comm_channel,StrVer);
9D002634  83848088   LB A0, -32632(GP)
9D002638  3C059D00   LUI A1, -25344
9D00263C  0F402624   JAL print
9D002640  24A56A98   ADDIU A1, A1, 27288
1549:                    crf();
9D002644  0F40097A   JAL crf
9D002648  00000000   NOP
1550:                #else
1551:                    UARTwriteS(UARTcon,StrVer); crf();
1552:                #endif
1553:                }
9D00264C  8FBF0014   LW RA, 20(SP)
9D002650  03E00008   JR RA
9D002654  27BD0018   ADDIU SP, SP, 24
1554:                
1555:                
1556:                // ********** VOCABULARY **********
1557:                
1558:                
1559:                // words ( -- )
1560:                void wordsf(void)
9D0026A0  26510005   ADDIU S1, S2, 5
9D0026A4  3042FFFF   ANDI V0, V0, -1
9D0026A8  02228821   ADDU S1, S1, V0
1561:                {
9D002658  27BDFFD8   ADDIU SP, SP, -40
9D00265C  AFBF0024   SW RA, 36(SP)
9D002660  AFB40020   SW S4, 32(SP)
9D002664  AFB3001C   SW S3, 28(SP)
9D002668  AFB20018   SW S2, 24(SP)
9D00266C  AFB10014   SW S1, 20(SP)
9D002670  AFB00010   SW S0, 16(SP)
1562:                	short int i=PrimLast, j, len;
1563:                	char  *p;
1564:                	ucell *Link, Linkbak, k=0;
1565:                
1566:                	if (vHead) {Link=(ucell *)vHead; k=1;}	// Link to last word
9D002674  8F9280D8   LW S2, -32552(GP)
9D002678  12400026   BEQ S2, ZERO, 0x9D002714
9D00267C  87938070   LH S3, -32656(GP)
1567:                	while (k)								// Forth words
1568:                	{
1569:                	  len=(short int)(*Link>>24)&0x1F ;
9D002684  92420003   LBU V0, 3(S2)
9D002688  3042001F   ANDI V0, V0, 31
1570:                	  if (len)								// Length?
9D00268C  50400015   BEQL V0, ZERO, 0x9D0026E4
9D002690  8E430000   LW V1, 0(S2)
1571:                	  {
1572:                		  Linkbak=(ucell)Link+cellsize;		// Begin of name
9D00269C  26500004   ADDIU S0, S2, 4
1573:                		  j=len; p=(char *)Linkbak;
1574:                		  for(j=0; j<len; j++) {PUSH(*p++); emit();}
9D002694  1840000E   BLEZ V0, 0x9D0026D0
9D002698  2442FFFF   ADDIU V0, V0, -1
9D0026AC  8F828008   LW V0, -32760(GP)
9D0026B0  24430004   ADDIU V1, V0, 4
9D0026B4  AF838008   SW V1, -32760(GP)
9D0026B8  82030000   LB V1, 0(S0)
9D0026BC  AC430004   SW V1, 4(V0)
9D0026C0  0F4008CE   JAL emit
9D0026C4  26100001   ADDIU S0, S0, 1
9D0026C8  1611FFF9   BNE S0, S1, 0x9D0026B0
9D0026CC  8F828008   LW V0, -32760(GP)
1575:                		  blf(); emit();
9D0026D0  0F400318   JAL blf
9D0026D4  00000000   NOP
9D0026D8  0F4008CE   JAL emit
9D0026DC  00000000   NOP
1576:                	  }
1577:                	  if (k) {Linkbak=*Link&0x7FFFFF;} else {Linkbak=0;}	// Last,zero?
9D0026E0  8E430000   LW V1, 0(S2)
9D0026E4  7C62B000   EXT V0, V1, 0, 23
1578:                	  if (!Linkbak) {k=0;}
9D0026E8  1040000A   BEQ V0, ZERO, 0x9D002714
9D0026EC  00741824   AND V1, V1, S4
1579:                	  if (k)
1580:                	  {
1581:                		if (*Link&0x800000) {Linkbak+=AddrRAM<<24;} else {Linkbak+=AddrROM<<24;}
9D002680  3C140080   LUI S4, 128
9D0026F0  50600005   BEQL V1, ZERO, 0x9D002708
9D0026F4  939280C8   LBU S2, -32568(GP)
9D0026F8  939280C9   LBU S2, -32567(GP)
9D0026FC  00129600   SLL S2, S2, 24
9D002700  0B4009A1   J 0x9D002684
9D002704  00529021   ADDU S2, V0, S2
9D002708  00129600   SLL S2, S2, 24
9D00270C  0B4009A1   J 0x9D002684
9D002710  00529021   ADDU S2, V0, S2
1582:                		Link=(ucell *)Linkbak;
1583:                	  }
1584:                	}
1585:                
1586:                	if (primwords[i].wlen&pr)  // Primitives?
9D002714  3C029D00   LUI V0, -25344
9D002718  2443707C   ADDIU V1, V0, 28796
9D00271C  2402000C   ADDIU V0, ZERO, 12
9D002720  72622002   MUL A0, S3, V0
9D002724  00831021   ADDU V0, A0, V1
9D002728  94420002   LHU V0, 2(V0)
9D00272C  30420020   ANDI V0, V0, 32
9D002730  10400017   BEQ V0, ZERO, 0x9D002790
9D002734  00000000   NOP
1587:                	{
1588:                	 while(i>=0)
9D002738  06600015   BLTZ S3, 0x9D002790
9D00273C  2410000C   ADDIU S0, ZERO, 12
9D002744  2412FFFF   ADDIU S2, ZERO, -1
9D002788  1672FFF0   BNE S3, S2, 0x9D00274C
9D00278C  72701802   MUL V1, S3, S0
1589:                	 {
1590:                	  if (primwords[i].wlen&0x1F)  // Length?
9D002740  00608821   ADDU S1, V1, ZERO
9D002748  72701802   MUL V1, S3, S0
9D00274C  00711021   ADDU V0, V1, S1
9D002750  94420002   LHU V0, 2(V0)
9D002754  3042001F   ANDI V0, V0, 31
9D002758  5040000A   BEQL V0, ZERO, 0x9D002784
9D00275C  2673FFFF   ADDIU S3, S3, -1
1591:                	  {
1592:                #ifdef VPC_32
1593:                                print(comm_channel,primwords[i].wname);
9D002760  72701802   MUL V1, S3, S0
9D002764  00711021   ADDU V0, V1, S1
9D002768  83848088   LB A0, -32632(GP)
9D00276C  0F402624   JAL print
9D002770  8C450004   LW A1, 4(V0)
1594:                #else
1595:                		UARTwriteS(UARTcon,primwords[i].wname);
1596:                #endif
1597:                		blf(); emit();
9D002774  0F400318   JAL blf
9D002778  2673FFFF   ADDIU S3, S3, -1
9D00277C  0F4008CE   JAL emit
9D002780  00000000   NOP
1598:                	  }
1599:                	 i--;
9D002784  7C139E20   SEH S3, S3
1600:                	 }
1601:                	} crf();
9D002790  0F40097A   JAL crf
9D002794  00000000   NOP
1602:                }
9D002798  8FBF0024   LW RA, 36(SP)
9D00279C  8FB40020   LW S4, 32(SP)
9D0027A0  8FB3001C   LW S3, 28(SP)
9D0027A4  8FB20018   LW S2, 24(SP)
9D0027A8  8FB10014   LW S1, 20(SP)
9D0027AC  8FB00010   LW S0, 16(SP)
9D0027B0  03E00008   JR RA
9D0027B4  27BD0028   ADDIU SP, SP, 40
1603:                
1604:                
1605:                // ********** DEVICE **********
1606:                
1607:                
1608:                // coretim ( -- u )
1609:                void coretim(void) {PUSH(ReadCoreTimer());}
9D001C9C  27BDFFE8   ADDIU SP, SP, -24
9D001CA0  AFBF0014   SW RA, 20(SP)
9D001CA4  AFB00010   SW S0, 16(SP)
9D001CA8  8F908008   LW S0, -32760(GP)
9D001CAC  26020004   ADDIU V0, S0, 4
9D001CB0  0F4040A0   JAL ReadCoreTimer
9D001CB4  AF828008   SW V0, -32760(GP)
9D001CB8  AE020004   SW V0, 4(S0)
9D001CBC  8FBF0014   LW RA, 20(SP)
9D001CC0  8FB00010   LW S0, 16(SP)
9D001CC4  03E00008   JR RA
9D001CC8  27BD0018   ADDIU SP, SP, 24
1610:                
1611:                
1612:                // ms ( u -- )
1613:                void msec(void) {delay_us(POP*1000);}
9D001C6C  27BDFFE8   ADDIU SP, SP, -24
9D001C70  AFBF0014   SW RA, 20(SP)
9D001C74  8F828008   LW V0, -32760(GP)
9D001C78  8C440000   LW A0, 0(V0)
9D001C7C  2442FFFC   ADDIU V0, V0, -4
9D001C80  AF828008   SW V0, -32760(GP)
9D001C84  240203E8   ADDIU V0, ZERO, 1000
9D001C88  0F40363C   JAL delay_us
9D001C8C  70822002   MUL A0, A0, V0
9D001C90  8FBF0014   LW RA, 20(SP)
9D001C94  03E00008   JR RA
9D001C98  27BD0018   ADDIU SP, SP, 24
1614:                
1615:                
1616:                // flash ( -- )
1617:                void flash(void)
1618:                {
9D001C30  27BDFFE8   ADDIU SP, SP, -24
9D001C34  AFBF0014   SW RA, 20(SP)
1619:                	NVMopen(vFHere);
9D001C38  0F4031D5   JAL NVMopen
9D001C3C  8F8480E8   LW A0, -32536(GP)
1620:                	vHereBak=vHere; vHere=(char*)vFHere;	// Swap RAM/ROM
9D001C40  8F8280D0   LW V0, -32560(GP)
9D001C44  AF8280CC   SW V0, -32564(GP)
9D001C48  8F8280E8   LW V0, -32536(GP)
9D001C4C  AF8280D0   SW V0, -32560(GP)
1621:                	vHeadBak=vHead; vHead=(char*)vFHead;
9D001C50  8F8280D8   LW V0, -32552(GP)
9D001C54  AF8280C4   SW V0, -32572(GP)
9D001C58  8F8280EC   LW V0, -32532(GP)
9D001C5C  AF8280D8   SW V0, -32552(GP)
1622:                }
9D001C60  8FBF0014   LW RA, 20(SP)
9D001C64  03E00008   JR RA
9D001C68  27BD0018   ADDIU SP, SP, 24
1623:                
1624:                
1625:                // >flash ( -- )
1626:                void toflash(void)
1627:                {
9D001BFC  27BDFFE8   ADDIU SP, SP, -24
9D001C00  AFBF0014   SW RA, 20(SP)
1628:                	if (!NVMflushBuf()) {vErrors|=0x10; abortf();}	// Copy Buf to flash
9D001C04  0F403221   JAL NVMflushBuf
9D001C08  00000000   NOP
9D001C0C  14400006   BNE V0, ZERO, 0x9D001C28
9D001C10  8FBF0014   LW RA, 20(SP)
9D001C14  9382806F   LBU V0, -32657(GP)
9D001C18  34420010   ORI V0, V0, 16
9D001C1C  0F400360   JAL abortf
9D001C20  A382806F   SB V0, -32657(GP)
1629:                }
9D001C24  8FBF0014   LW RA, 20(SP)
9D001C28  03E00008   JR RA
9D001C2C  27BD0018   ADDIU SP, SP, 24
1630:                
1631:                
1632:                // ;flash ( -- )
1633:                void endflash(void)
1634:                {
9D001FEC  27BDFFE8   ADDIU SP, SP, -24
9D001FF0  AFBF0014   SW RA, 20(SP)
1635:                	ucell Bak;
1636:                
1637:                	PUSH((ucell)vHeap); comma();
9D001FF4  8F828008   LW V0, -32760(GP)
9D001FF8  24430004   ADDIU V1, V0, 4
9D001FFC  AF838008   SW V1, -32760(GP)
9D002000  8F8380E0   LW V1, -32544(GP)
9D002004  0F4007DD   JAL comma
9D002008  AC430004   SW V1, 4(V0)
1638:                	PUSH((ucell)vHead); comma();
9D00200C  8F828008   LW V0, -32760(GP)
9D002010  24430004   ADDIU V1, V0, 4
9D002014  AF838008   SW V1, -32760(GP)
9D002018  8F8380D8   LW V1, -32552(GP)
9D00201C  0F4007DD   JAL comma
9D002020  AC430004   SW V1, 4(V0)
1639:                	PUSH((ucell)vHere); comma();
9D002024  8F828008   LW V0, -32760(GP)
9D002028  24430004   ADDIU V1, V0, 4
9D00202C  AF838008   SW V1, -32760(GP)
9D002030  8F8380D0   LW V1, -32560(GP)
9D002034  0F4007DD   JAL comma
9D002038  AC430004   SW V1, 4(V0)
1640:                	vFHead=(ucell*)vHead; vHead=vHeadBak;		// Swap RAM/ROM
9D00203C  8F8380D8   LW V1, -32552(GP)
9D002040  AF8380EC   SW V1, -32532(GP)
9D002044  8F8280C4   LW V0, -32572(GP)
9D002048  AF8280D8   SW V0, -32552(GP)
1641:                	vHere=vHereBak;	
9D00204C  8F8280CC   LW V0, -32564(GP)
9D002050  AF8280D0   SW V0, -32560(GP)
1642:                	
1643:                	Bak=*(ucell *)vDict&0xFF000000;				// Update link RAM to FHead
9D002054  8F828064   LW V0, -32668(GP)
9D002058  8C450000   LW A1, 0(V0)
9D00205C  3C04FF00   LUI A0, -256
9D002060  00A42024   AND A0, A1, A0
1644:                	Bak|=((ucell)vFHead&0x7FFFFF); *(ucell *)vDict=Bak;
9D002064  7C63B000   EXT V1, V1, 0, 23
9D002068  00641825   OR V1, V1, A0
9D00206C  AC430000   SW V1, 0(V0)
1645:                	if (!(ucell)vHead) {vHead=(char*)vFHead;};	// Head=0?, Head=FHead;
9D002070  8F8280D8   LW V0, -32552(GP)
9D002074  14400002   BNE V0, ZERO, 0x9D002080
9D002078  8F8280EC   LW V0, -32532(GP)
9D00207C  AF8280D8   SW V0, -32552(GP)
1646:                
1647:                	NVMclose();
9D002080  0F403230   JAL NVMclose
9D002084  00000000   NOP
1648:                }
9D002088  8FBF0014   LW RA, 20(SP)
9D00208C  03E00008   JR RA
9D002090  27BD0018   ADDIU SP, SP, 24
1649:                
1650:                #ifndef VPC_32
1651:                // devhead (  -- u )
1652:                void devhead(void) {PUSH((ucell)DevHead);}
1653:                
1654:                
1655:                // devcall ( u1 u2 -- )		// u1-ptr DevTabxxx, u2-index fce
1656:                void devcall(void)			// 0 ADC 4 devcall (readADC)
1657:                {
1658:                	ucell index=POP;
1659:                	void (*pFce)(void *)=(void *)*(ucell *)((index<<2)+POP);
1660:                	(*pFce)((void *)pDS);
1661:                }
1662:                #endif
1663:                
1664:                // c call ( u1 u2 -- )  	// u1-ptr data, u2-ptr C function
1665:                void ccall(void)			// 0 sp@ ADC 10 + @ ccall (readADC)
1666:                {
9D001B30  27BDFFE8   ADDIU SP, SP, -24
9D001B34  AFBF0014   SW RA, 20(SP)
1667:                	void (*pFce)(void *)=(void *)POP;
9D001B38  8F838008   LW V1, -32760(GP)
9D001B3C  8C620000   LW V0, 0(V1)
9D001B40  2464FFFC   ADDIU A0, V1, -4
9D001B44  AF848008   SW A0, -32760(GP)
1668:                	(*pFce)((void *)POP);
9D001B48  8C64FFFC   LW A0, -4(V1)
9D001B4C  2463FFF8   ADDIU V1, V1, -8
9D001B50  0040F809   JALR V0
9D001B54  AF838008   SW V1, -32760(GP)
1669:                }
9D001B58  8FBF0014   LW RA, 20(SP)
9D001B5C  03E00008   JR RA
9D001B60  27BD0018   ADDIU SP, SP, 24
1670:                #ifdef VPC_32
1671:                // sound tone ( duration freq -- )
1672:                void beep(void){
9D001BC8  27BDFFE8   ADDIU SP, SP, -24
9D001BCC  AFBF0014   SW RA, 20(SP)
1673:                    tone(POP,POP);
9D001BD0  8F828008   LW V0, -32760(GP)
9D001BD4  8C440000   LW A0, 0(V0)
9D001BD8  2443FFFC   ADDIU V1, V0, -4
9D001BDC  AF838008   SW V1, -32760(GP)
9D001BE0  8C45FFFC   LW A1, -4(V0)
9D001BE4  2442FFF8   ADDIU V0, V0, -8
9D001BE8  0F403453   JAL tone
9D001BEC  AF828008   SW V0, -32760(GP)
1674:                } //tone()
9D001BF0  8FBF0014   LW RA, 20(SP)
9D001BF4  03E00008   JR RA
9D001BF8  27BD0018   ADDIU SP, SP, 24
1675:                
1676:                // joue une mélodie
1677:                void play_tune(void){
9D001BA0  27BDFFE8   ADDIU SP, SP, -24
9D001BA4  AFBF0014   SW RA, 20(SP)
1678:                    tune((const unsigned int *)POP);
9D001BA8  8F828008   LW V0, -32760(GP)
9D001BAC  8C440000   LW A0, 0(V0)
9D001BB0  2442FFFC   ADDIU V0, V0, -4
9D001BB4  0F403481   JAL tune
9D001BB8  AF828008   SW V0, -32760(GP)
1679:                }//play_tune
9D001BBC  8FBF0014   LW RA, 20(SP)
9D001BC0  03E00008   JR RA
9D001BC4  27BD0018   ADDIU SP, SP, 24
1680:                
1681:                
1682:                #endif
1683:                
1684:                #ifndef VPC_32
1685:                // device TIM1 ( -- addr )
1686:                void devTIM1(void) {PUSH((ucell)DevTab[0].dcall);}
1687:                
1688:                // device COM ( -- addr )
1689:                void devCOM(void) {PUSH((ucell)DevTab[1].dcall);}
1690:                
1691:                // device PIN ( -- addr )
1692:                void devPIN(void) {PUSH((ucell)DevTab[2].dcall);}
1693:                
1694:                // device ADC ( -- addr )
1695:                void devADC(void) {PUSH((ucell)DevTab[3].dcall);}
1696:                
1697:                // device PWM ( -- addr )
1698:                void devPWM(void) {PUSH((ucell)DevTab[4].dcall);}
1699:                #endif
1700:                
1701:                // ********** DICTIONARY **********
1702:                
1703:                const PRIMWORD primwords[] =
1704:                {	// VMcore
1705:                	{0,pr|6,"(exit)",exitw}, {1,pr|7,"execute",executew}, {2,pr|0,"",nextw}, {3,pr|7,"(colon)",enterw},
1706:                	{4,pr|5,"(lit)",dolitw}, {5,pr|6,"(slit)",doslitw}, {6,pr|5,"(con)",doconw}, {7,pr|5,"(var)",dovarw},
1707:                	{8,pr|6,"(does)",dodoes}, {9,pr|7,"(defer)",dodefer}, {10,pr|4,"(do)",dodo}, {11,pr|5,"(?do)",doisdo},
1708:                	{12,pr|6,"(loop)",doloop}, {13,pr|7,"(+loop)",doplusloop}, {14,pr|8,"(branch)",dobranch}, {15,pr|9,"(?branch)",docbranch},
1709:                	{16,pr|5,"(val)",dovalw},
1710:                	// Stack
1711:                	{1,pr|4,"drop",drop}, {2,pr|5,"2drop",twodrop}, {3,pr|3,"dup",dup}, {4,pr|4,"2dup",twodup},
1712:                	{5,pr|4,"?dup",isdup}, {6,pr|3,"nip",nip}, {7,pr|4,"over",over}, {8,pr|5,"2over",twoover},
1713:                	{9,pr|4,"pick",pick}, {10,pr|5,"stick",stick}, {11,pr|4,"roll",roll}, {12,pr|5,"-roll",minusroll},
1714:                	{13,pr|3,"rot",rot}, {14,pr|4,"-rot",minusrot}, {15,pr|4,"swap",swap}, {16,pr|5,"2swap",twoswap},
1715:                	{17,pr|2,">r",tor}, {18,pr|2,"r>",rfrom}, {19,pr|2,"r@",rfetch}, {20,pr|5,"depth",depth},
1716:                	{21,pr|6,"depth!",depthwrite}, {22,pr|6,"rdepth",rdepth}, {23,pr|7,"rdepth!",rdepthwrite},
1717:                	{24,pr|3,"sp@",spfetch}, {25,pr|3,"rp@",rpfetch},
1718:                	// Other
1719:                	{1,pr|4,"emit",emit},
1720:                #ifndef VPC_32
1721:                        {2,pr|5,"?emit",isemit},
1722:                #endif
1723:                        {3,pr|3,"key",key}, {4,pr|4,"?key",iskey},
1724:                	{5,pr|1,"i",loop_i}, {6,pr|1,"j",loop_j},  {7,pr|1,"k",loop_k}, {8,pr|3,"nop",nop},
1725:                 	// Memory
1726:                	{1,pr|1,"@",fetch}, {2,pr|2,"c@",cfetch}, {3,pr|2,"w@",wfetch}, {4,pr|1,"!",store},
1727:                	{5,pr|2,"c!",cstore}, {6,pr|2,"w!",wstore}, {7,pr|2,"+!",plusstore},
1728:                	{8,pr|4,"fill",fillf}, {9,pr|4,"move",movef}, {10,pr|4,"here",here}, {11,pr|5,"here!",herewrite},
1729:                	{12,pr|4,"head",head}, {13,pr|5,"head!",headwrite}, {14,pr|4,"heap",heap}, {15,pr|5,"heap!",heapwrite},
1730:                	// Arithmetic
1731:                	{1,pr|1,"+",plus}, {2,pr|1,"-",minus}, {3,pr|2,"d+",dplus}, {4,pr|2,"d-",dminus},
1732:                	{5,pr|1,"*",mult}, {6,pr|2,"m*",mmult}, {7,pr|3,"um*",ummult}, {8,pr|4,"sqrt",sqrtu},
1733:                	{9,pr|6,"um/mod",umdivmod}, {10,pr|5,"m/mod",mdivmod}, {11,pr|5,"u/mod",udivmod}, {12,pr|4,"/mod",divmod},
1734:                	{13,pr|1,"/",divf}, {14,pr|3,"mod",modn}, {15,pr|3,"u*/",umuldiv}, {16,pr|2,"*/",muldiv},
1735:                	{17,pr|3,">>a",arshift}, {18,pr|2,">>",rshift}, {19,pr|2,"<<",lshift}, {20,pr|2,"2*",twomul},
1736:                	{21,pr|2,"2/",twodiv}, {22,pr|3,"min",minf}, {23,pr|3,"max",maxf}, {24,pr|3,"abs",absf},
1737:                	{25,pr|2,"1+",incf}, {26,pr|2,"1-",decf}, {27,pr|6,"negate",negate}, {28,pr|6,"invert",invert},
1738:                	{29,pr|3,"and",andf}, {30,pr|2,"or",orf}, {31,pr|3,"xor",xorf},
1739:                	// Logic
1740:                	{1,pr|4,"andl",andl}, {2,pr|3,"orl",orl}, {3,pr|3,"not",notl}, {4,pr|1,"=",equals},
1741:                	{5,pr|2,"<>",notequals}, {6,pr|1,">",greater}, {7,pr|1,"<",less}, {8,pr|2,">=",greaterequals},
1742:                	{9,pr|2,"<=",lessequals}, {10,pr|2,"0=",zeroequals}, {11,pr|2,"0<",zeroless}, {12,pr|2,"0>",zerogreater},
1743:                	{13,pr|2,"u>",ugreater}, {14,pr|2,"u<",uless}, {15,pr|3,"u>=",ugreaterequals}, {16,pr|3,"u<=",ulessequals},
1744:                	{17,pr|2,"d=",dequals}, {18,pr|3,"d<>",dnotequals}, {19,pr|2,"d>",dgreater}, {20,pr|2,"d<",dless},
1745:                	{21,pr|6,"within",within},
1746:                
1747:                	// High FORTH
1748:                	// Variable
1749:                	{1,pr|2,"bl",blf}, {2,pr|4,"base",base}, {3,pr|3,">in",gin}, {4,pr|3,"pad",pad},
1750:                	{5,pr|5,"state",state}, {6,pr|3,"tib",tib}, {7,pr|4,"#tib",sharptib},
1751:                //	{8,pr|7,"current",current}, {9,pr|7,"context",context},
1752:                	// CtrlFlow
1753:                	{1,pr|5,"<mark",lmark}, {2,pr|8,"<resolve",lresolve}, {3,pr|5,">mark",gmark}, {4,pr|8,">resolve",gresolve},
1754:                	{5,pr|im|2,"do",dof}, {6,pr|im|3,"?do",isdof}, {7,pr|im|4,"loop",loop}, {8,pr|im|5,"+loop",plusloop},
1755:                	{9,pr|im|2,"if",iff}, {10,pr|im|4,"then",thenf}, {11,pr|im|4,"else",elsef}, {12,pr|im|5,"begin",beginf},
1756:                	{13,pr|im|5,"while",whilef}, {14,pr|im|5,"until",untilf}, {15,pr|im|6,"repeat",repeatf}, {16,pr|im|5,"again",againf},
1757:                	{17,pr|4,"exit",exitw}, {18,pr|im|7,"recurse",recursef}, {19,pr|5,"leave",leavef}, {20,pr|6,"unloop",unloopf},
1758:                	{21,pr|im|4,"case",casef}, {22,pr|im|2,"of",caseof}, {23,pr|im|5,"endof",endof}, {24,pr|im|7,"endcase",endcase},
1759:                	{25,pr|5,"abort",abortf}, {26,pr|im|6,"abort\"",aborts}, {27,pr|3,"bye",bye},
1760:                	// Interpreter
1761:                	{1,pr|im|1,"[",lbracket}, {2,pr|1,"]",rbracket}, {3,pr|3,"bin",binf}, {4,pr|7,"decimal",decimal},
1762:                	{5,pr|3,"hex",hexf}, {6,pr|6,"accept",accept}, {7,pr|5,"count",count}, {8,pr|4,"find",find},
1763:                	{9,pr|6,"number",number}, {10,pr|5,"parse",parse}, {11,pr|4,"word",wordf}, {12,pr|9,"interpret",interpret},
1764:                	{13,pr|6,"refill",refill}, {14,pr|6,"source",source}, {15,pr|4,"quit",quit}, {16,pr|4,"cold",cold},
1765:                	// Compiler	
1766:                	{1,pr|5,">body",gbody}, {2,pr|5,"link>",linkg}, {3,pr|5,"align",align}, {4,pr|5,"allot",allot},
1767:                	{5,pr|im|5,"ascii",ascii}, {6,pr|1,",",comma}, {7,pr|2,"c,",ccomma}, {8,pr|2,"w,",wcomma},
1768:                	{9,pr|2,"s,",scomma}, {10,pr|1,"'",tick}, {11,pr|im|3,"[']",brackettick}, {12,pr|7,"compile",compile},
1769:                 	{13,pr|im|9,"[compile]",bracketcompile}, {14,pr|8,"(create)",docreate}, {15,pr|6,"create",createf}, {16,pr|7,"<builds",builds},
1770:                	{17,pr|5,"does>",does}, {18,pr|9,"immediate",immediate}, {19,pr|im|8,"postpone",postpone}, {20,pr|1,":",colon},
1771:                	{21,pr|im|1,";",semicolon}, {22,pr|im|2,"s\"",squote}, {23,pr|im|7,"literal",literal}, {24,pr|8,"constant",constant},
1772:                	{25,pr|8,"variable",variable}, {26,pr|5,"value",value}, {27,pr|4,"(to)",tof}, {28,pr|im|2,"to",tof},
1773:                	{29,pr|5,"defer",defer}, {30,pr|6,"defer@",deferfetch}, {31,pr|6,"defer!",deferstore},
1774:                 	// Emit
1775:                	{1,pr|2,"cr",crf}, {2,pr|5,"space",spacef}, {3,pr|6,"spaces",spaces}, {4,pr|4,"type",typef},
1776:                	{5,pr|1,".",dot}, {6,pr|2,"u.",udot}, {7,pr|2,".r",dotr}, {8,pr|3,"u.r",udotr},
1777:                	{9,pr|im|2,".\"",dotstring}, {10,pr|im|2,".(",dotlparen}, {11,pr|im|1,"(",lparen}, {12,pr|4,"hold",hold},
1778:                	{13,pr|2,"<#",sharpl}, {14,pr|1,"#",sharp}, {15,pr|2,"#s",sharps}, {16,pr|2,"#>",sharpg},
1779:                	{17,pr|im|1,"\\",backslash}, {18,pr|4,"dump",dump}, {19,pr|2,".s",dots}, {20,pr|3,"ver",ver},
1780:                	// Vocabulary
1781:                //	{1,pr|4,"also",nop}, {2,pr|11,"definitions",nop}, {3,pr|6,"forget",nop}, {4,pr|5,"forth",nop},
1782:                //	{5,pr|4,"only",nop}, {6,pr|5,"order",nop}, {7,pr|10,"vocabulary",nop},
1783:                	{8,pr|5,"words",wordsf},
1784:                	// Device
1785:                	{1,pr|7,"coretim",coretim}, {2,pr|2,"ms",msec}, {3,pr|5,"flash",flash}, {4,pr|6,">flash",toflash},
1786:                	{5,pr|6,";flash",endflash}, 
1787:                #ifndef VPC_32    
1788:                        {6,pr|7,"devhead",devhead}, {7,pr|7,"devcall",devcall},
1789:                #endif
1790:                        {8,pr|5,"ccall",ccall},
1791:                #ifndef VPC_32
1792:                	{9,pr|4,"TIM1",devTIM1}, {10,pr|3,"COM",devCOM}, {11,pr|3,"PIN",devPIN}, {12,pr|3,"ADC",devADC},
1793:                	{13,pr|3,"PWM",devPWM},
1794:                #endif
1795:                #ifdef VPC_32
1796:                        {9,pr|4,"beep",beep},
1797:                        {10,pr|4,"tune",play_tune},
1798:                #endif
1799:                	{0xFF,pr,"",nop}
1800:                
1801:                };
1802:                
1803:                
1804:                //		VMCORE
1805:                //	(exit)  execute  ""  (colon)  (lit)  (slit)  (con)  (var)
1806:                //	(does)  (defer)  (do)  (?do)  (loop)  (+loop)  (branch)  (?branch)
1807:                //	(val)
1808:                //		STACK
1809:                //	drop  2drop  dup  2dup  ?dup  nip  over  2over
1810:                //	pick  stick  roll  -roll  rot  -rot  swap  2swap
1811:                //	>r  r>  r@  depth  depth!  rdepth  rdepth!  sp@  rp@
1812:                //		OTHER
1813:                //	emit  ?emit  key  ?key  i  j  k  nop 
1814:                //		MEMORY
1815:                //	@  c@  w@  !  c!  w!  +!
1816:                //	fill  move  here  here!  head  head!  heap  heap! 
1817:                //		ARITHMETIC
1818:                //	+  -  d+  d-  *  m*  um*  sqrt
1819:                //	um/mod   m/mod  u/mod  /mod  /  mod  u*/  */
1820:                //	>>a  >>  <<  2*  2/  min  max  abs
1821:                //	1+  1-  negate  invert  and  or  xor   
1822:                //		LOGIC
1823:                //	andl  orl  not
1824:                //	=  <>  >  <  >=  <=  0=  0<  0>
1825:                //	u>  u<  u>=  u<=  d=  d<>  d>  d<
1826:                //	within
1827:                //
1828:                //		High FORTH
1829:                //		VARIABLE
1830:                //	bl  base  >in  pad  state  tib  #tib
1831:                //	current  context
1832:                //		CTRLFLOW
1833:                //	<mark  <resolve  >mark  >resolve  do  ?do  loop  +loop  
1834:                //	if  then  else  begin  while  until  repeat  again
1835:                //	exit  recurse  leave  unloop  case  of  endof  endcase
1836:                //	abort  abort"  bye
1837:                //		INTERPRETER
1838:                //	[  ]  bin  decimal  hex  accept  count  find
1839:                //	number  parse  word  interpret  refill  source  quit  cold  
1840:                //		COMPILER
1841:                //	>body  link>  align  allot  ascii  ,  c,  w,
1842:                //	s,  '  [']  compile  [compile]  (create)  create  <builds
1843:                //	does>  immediate  postpone  :  ;  s"  literal  constant
1844:                //	variable  value  (to)  to  defer  defer@  defer!
1845:                //		EMIT
1846:                //	cr  space  spaces  type  .  u.  .r  u.r
1847:                //	."  .(  (  hold  <#  #  #s  #>
1848:                //	\  dump  .s  ver
1849:                //		VOCABULARY
1850:                //	also  definitions  forget  forth  only  order  vocabulary  words
1851:                //		DEVICE
1852:                //	coretim  ms  flash  >flash  ;flash  devhead  devcall  ccall
1853:                //	TIM1  COM  PIN  ADC  PWM
1854:                
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/DiosForth.X/source/VM/VMcore.c  -------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  VMcore
4:                    *                  DIOS Forth
5:                    *
6:                    * v.1.0 - 20.12.2012, L.Pekny
7:                    ********************************************************************/
8:                   
9:                   #include <plib.h>
10:                  #include "..\GenericTypeDefs.h"
11:                  #include "../../../hardware/HardwareProfile.h"
12:                  //#include "..\HardwareProfile.h"
13:                  #include "VMcore.h"
14:                  
15:                  
16:                  cell  DS[DSsize];
17:                  ucell RS[RSsize];
18:                  cell  *pDSzero=DS+8, *pDS=DS+8; 
19:                  ucell *pRSzero=RS+8, *pRS=RS+8, *pRSbak;
20:                  //WORD DScnt, RScnt;
21:                  ucell PC, WORK;
22:                  void (*pFce)(void) = NULL;
23:                  
24:                  
25:                  void exitw(void)  {EXIT}
9D00B1D8  8F828010   LW V0, -32752(GP)
9D00B1DC  8C430000   LW V1, 0(V0)
9D00B1E0  AF8380BC   SW V1, -32580(GP)
9D00B1E4  2442FFFC   ADDIU V0, V0, -4
9D00B1E8  03E00008   JR RA
9D00B1EC  AF828010   SW V0, -32752(GP)
26:                  
27:                  void executew(void) {EXECUTE}
9D00B1F0  27BDFFE8   ADDIU SP, SP, -24
9D00B1F4  AFBF0014   SW RA, 20(SP)
9D00B1F8  8F838008   LW V1, -32760(GP)
9D00B1FC  AF8380BC   SW V1, -32580(GP)
9D00B200  8C620000   LW V0, 0(V1)
9D00B204  8C420000   LW V0, 0(V0)
9D00B208  AF828058   SW V0, -32680(GP)
9D00B20C  2463FFFC   ADDIU V1, V1, -4
9D00B210  0040F809   JALR V0
9D00B214  AF838008   SW V1, -32760(GP)
9D00B218  8FBF0014   LW RA, 20(SP)
9D00B21C  03E00008   JR RA
9D00B220  27BD0018   ADDIU SP, SP, 24
28:                  
29:                  void nextw(void)  {NEXT}
9D00B224  27BDFFE8   ADDIU SP, SP, -24
9D00B228  AFBF0014   SW RA, 20(SP)
9D00B22C  8F8280BC   LW V0, -32580(GP)
9D00B230  24430004   ADDIU V1, V0, 4
9D00B234  AF8380BC   SW V1, -32580(GP)
9D00B238  8C420004   LW V0, 4(V0)
9D00B23C  8C420000   LW V0, 0(V0)
9D00B240  0040F809   JALR V0
9D00B244  AF828058   SW V0, -32680(GP)
9D00B248  8FBF0014   LW RA, 20(SP)
9D00B24C  03E00008   JR RA
9D00B250  27BD0018   ADDIU SP, SP, 24
30:                  
31:                  void enterw(void) {ucell *pRSbak; ENTER}
9D00B254  27BDFFE8   ADDIU SP, SP, -24
9D00B258  AFBF0014   SW RA, 20(SP)
9D00B25C  AFB00010   SW S0, 16(SP)
9D00B260  8F908010   LW S0, -32752(GP)
9D00B264  26020004   ADDIU V0, S0, 4
9D00B268  AF828010   SW V0, -32752(GP)
9D00B26C  8F8280BC   LW V0, -32580(GP)
9D00B270  AE020004   SW V0, 4(S0)
9D00B274  8F8280BC   LW V0, -32580(GP)
9D00B278  8C420000   LW V0, 0(V0)
9D00B27C  AF8280BC   SW V0, -32580(GP)
9D00B280  8F828010   LW V0, -32752(GP)
9D00B284  0202102B   SLTU V0, S0, V0
9D00B288  1040000D   BEQ V0, ZERO, 0x9D00B2C0
9D00B28C  8FBF0014   LW RA, 20(SP)
9D00B290  8F8280BC   LW V0, -32580(GP)
9D00B294  24430004   ADDIU V1, V0, 4
9D00B298  AF8380BC   SW V1, -32580(GP)
9D00B29C  8C420004   LW V0, 4(V0)
9D00B2A0  8C420000   LW V0, 0(V0)
9D00B2A4  0040F809   JALR V0
9D00B2A8  AF828058   SW V0, -32680(GP)
9D00B2AC  8F828010   LW V0, -32752(GP)
9D00B2B0  0202102B   SLTU V0, S0, V0
9D00B2B4  1440FFF7   BNE V0, ZERO, 0x9D00B294
9D00B2B8  8F8280BC   LW V0, -32580(GP)
9D00B2BC  8FBF0014   LW RA, 20(SP)
9D00B2C0  8FB00010   LW S0, 16(SP)
9D00B2C4  03E00008   JR RA
9D00B2C8  27BD0018   ADDIU SP, SP, 24
32:                  
33:                  void dolitw(void) {DOLIT}
9D00B2CC  8F8380BC   LW V1, -32580(GP)
9D00B2D0  24620004   ADDIU V0, V1, 4
9D00B2D4  AF8280BC   SW V0, -32580(GP)
9D00B2D8  8F828008   LW V0, -32760(GP)
9D00B2DC  24440004   ADDIU A0, V0, 4
9D00B2E0  AF848008   SW A0, -32760(GP)
9D00B2E4  8C630004   LW V1, 4(V1)
9D00B2E8  03E00008   JR RA
9D00B2EC  AC430004   SW V1, 4(V0)
34:                  
35:                  void doslitw(void){DOSLIT  PC&=~3;}  // align (PC-cellsize)
9D00B2F0  8F8380BC   LW V1, -32580(GP)
9D00B2F4  24620004   ADDIU V0, V1, 4
9D00B2F8  AF8280BC   SW V0, -32580(GP)
9D00B2FC  8F828008   LW V0, -32760(GP)
9D00B300  24440004   ADDIU A0, V0, 4
9D00B304  AF848008   SW A0, -32760(GP)
9D00B308  24630005   ADDIU V1, V1, 5
9D00B30C  AC430004   SW V1, 4(V0)
9D00B310  8F828008   LW V0, -32760(GP)
9D00B314  24430004   ADDIU V1, V0, 4
9D00B318  AF838008   SW V1, -32760(GP)
9D00B31C  8F8380BC   LW V1, -32580(GP)
9D00B320  90630000   LBU V1, 0(V1)
9D00B324  AC430004   SW V1, 4(V0)
9D00B328  8F828008   LW V0, -32760(GP)
9D00B32C  8C430000   LW V1, 0(V0)
9D00B330  8F8280BC   LW V0, -32580(GP)
9D00B334  00621021   ADDU V0, V1, V0
9D00B338  2403FFFC   ADDIU V1, ZERO, -4
9D00B33C  00431024   AND V0, V0, V1
9D00B340  03E00008   JR RA
9D00B344  AF8280BC   SW V0, -32580(GP)
36:                  
37:                  void doconw(void) {DOCON}
9D00B348  8F828008   LW V0, -32760(GP)
9D00B34C  24430004   ADDIU V1, V0, 4
9D00B350  AF838008   SW V1, -32760(GP)
9D00B354  8F8380BC   LW V1, -32580(GP)
9D00B358  8C630000   LW V1, 0(V1)
9D00B35C  8C630004   LW V1, 4(V1)
9D00B360  03E00008   JR RA
9D00B364  AC430004   SW V1, 4(V0)
38:                  
39:                  void dovarw(void) {DOVAR}
9D00B368  8F828008   LW V0, -32760(GP)
9D00B36C  24430004   ADDIU V1, V0, 4
9D00B370  AF838008   SW V1, -32760(GP)
9D00B374  8F8380BC   LW V1, -32580(GP)
9D00B378  8C630000   LW V1, 0(V1)
9D00B37C  8C630004   LW V1, 4(V1)
9D00B380  03E00008   JR RA
9D00B384  AC430004   SW V1, 4(V0)
40:                  
41:                  void dovalw(void) {DOVAL}
9D00B388  8F828008   LW V0, -32760(GP)
9D00B38C  24430004   ADDIU V1, V0, 4
9D00B390  AF838008   SW V1, -32760(GP)
9D00B394  8F8380BC   LW V1, -32580(GP)
9D00B398  8C630000   LW V1, 0(V1)
9D00B39C  8C630004   LW V1, 4(V1)
9D00B3A0  8C630000   LW V1, 0(V1)
9D00B3A4  03E00008   JR RA
9D00B3A8  AC430004   SW V1, 4(V0)
42:                  
43:                  
44:                  void dodoes(void)
45:                  {
9D00B3AC  27BDFFE8   ADDIU SP, SP, -24
9D00B3B0  AFBF0014   SW RA, 20(SP)
9D00B3B4  AFB00010   SW S0, 16(SP)
46:                  	WORK=pDATA(PC);	PUSH(WORK+dcellsize);	// PFA
9D00B3B8  8F8280BC   LW V0, -32580(GP)
9D00B3BC  8C430000   LW V1, 0(V0)
9D00B3C0  AF8380B8   SW V1, -32584(GP)
9D00B3C4  8F828008   LW V0, -32760(GP)
9D00B3C8  24440004   ADDIU A0, V0, 4
9D00B3CC  AF848008   SW A0, -32760(GP)
9D00B3D0  24630008   ADDIU V1, V1, 8
9D00B3D4  AC430004   SW V1, 4(V0)
47:                  	WORK+=cellsize;				// Must be used WORK
9D00B3D8  8F8280B8   LW V0, -32584(GP)
9D00B3DC  24420004   ADDIU V0, V0, 4
9D00B3E0  AF8280B8   SW V0, -32584(GP)
48:                  	ucell *pRSbak; ENTERDOES	// Words behind does>
9D00B3E4  8F908010   LW S0, -32752(GP)
9D00B3E8  26020004   ADDIU V0, S0, 4
9D00B3EC  AF828010   SW V0, -32752(GP)
9D00B3F0  8F8280BC   LW V0, -32580(GP)
9D00B3F4  AE020004   SW V0, 4(S0)
9D00B3F8  8F8280B8   LW V0, -32584(GP)
9D00B3FC  8C420000   LW V0, 0(V0)
9D00B400  AF8280BC   SW V0, -32580(GP)
9D00B404  8F828010   LW V0, -32752(GP)
9D00B408  0202102B   SLTU V0, S0, V0
9D00B40C  1040000D   BEQ V0, ZERO, 0x9D00B444
9D00B410  8FBF0014   LW RA, 20(SP)
9D00B414  8F8280BC   LW V0, -32580(GP)
9D00B418  24430004   ADDIU V1, V0, 4
9D00B41C  AF8380BC   SW V1, -32580(GP)
9D00B420  8C420004   LW V0, 4(V0)
9D00B424  8C420000   LW V0, 0(V0)
9D00B428  0040F809   JALR V0
9D00B42C  AF828058   SW V0, -32680(GP)
9D00B430  8F828010   LW V0, -32752(GP)
9D00B434  0202102B   SLTU V0, S0, V0
9D00B438  1440FFF7   BNE V0, ZERO, 0x9D00B418
9D00B43C  8F8280BC   LW V0, -32580(GP)
49:                  }
9D00B440  8FBF0014   LW RA, 20(SP)
9D00B444  8FB00010   LW S0, 16(SP)
9D00B448  03E00008   JR RA
9D00B44C  27BD0018   ADDIU SP, SP, 24
50:                  
51:                  
52:                  void dodefer(void)
53:                  {
9D00B450  27BDFFE8   ADDIU SP, SP, -24
9D00B454  AFBF0014   SW RA, 20(SP)
54:                  	DOVAL EXECUTE
9D00B458  8F828008   LW V0, -32760(GP)
9D00B45C  24430004   ADDIU V1, V0, 4
9D00B460  AF838008   SW V1, -32760(GP)
9D00B464  8F8380BC   LW V1, -32580(GP)
9D00B468  8C630000   LW V1, 0(V1)
9D00B46C  8C630004   LW V1, 4(V1)
9D00B470  8C630000   LW V1, 0(V1)
9D00B474  AC430004   SW V1, 4(V0)
9D00B478  8F838008   LW V1, -32760(GP)
9D00B47C  AF8380BC   SW V1, -32580(GP)
9D00B480  8C620000   LW V0, 0(V1)
9D00B484  8C420000   LW V0, 0(V0)
9D00B488  AF828058   SW V0, -32680(GP)
9D00B48C  2463FFFC   ADDIU V1, V1, -4
9D00B490  0040F809   JALR V0
9D00B494  AF838008   SW V1, -32760(GP)
55:                  }
9D00B498  8FBF0014   LW RA, 20(SP)
9D00B49C  03E00008   JR RA
9D00B4A0  27BD0018   ADDIU SP, SP, 24
56:                  
57:                  
58:                  void dodo(void)
59:                  {
60:                  	cell vStart=POP, vEnd=POP;
9D00B4A4  8F828008   LW V0, -32760(GP)
9D00B4A8  8C440000   LW A0, 0(V0)
9D00B4AC  2443FFFC   ADDIU V1, V0, -4
9D00B4B0  AF838008   SW V1, -32760(GP)
9D00B4B4  8C45FFFC   LW A1, -4(V0)
9D00B4B8  2442FFF8   ADDIU V0, V0, -8
9D00B4BC  AF828008   SW V0, -32760(GP)
61:                  	PC+=cellsize;
9D00B4C0  8F8380BC   LW V1, -32580(GP)
9D00B4C4  24620004   ADDIU V0, V1, 4
9D00B4C8  AF8280BC   SW V0, -32580(GP)
62:                  	PUSHR(pDATA PC);  // For leave
9D00B4CC  8F828010   LW V0, -32752(GP)
9D00B4D0  24460004   ADDIU A2, V0, 4
9D00B4D4  AF868010   SW A2, -32752(GP)
9D00B4D8  8C630004   LW V1, 4(V1)
9D00B4DC  AC430004   SW V1, 4(V0)
63:                  	PUSHR(vEnd); PUSHR(vStart);
9D00B4E0  8F828010   LW V0, -32752(GP)
9D00B4E4  24430004   ADDIU V1, V0, 4
9D00B4E8  AF838010   SW V1, -32752(GP)
9D00B4EC  AC450004   SW A1, 4(V0)
9D00B4F0  8F828010   LW V0, -32752(GP)
9D00B4F4  24430004   ADDIU V1, V0, 4
9D00B4F8  AF838010   SW V1, -32752(GP)
64:                  }
9D00B4FC  03E00008   JR RA
9D00B500  AC440004   SW A0, 4(V0)
65:                  
66:                  
67:                  void doisdo(void)
68:                  {
69:                  	cell vStart=POP, vEnd=POP;
9D00B504  8F828008   LW V0, -32760(GP)
9D00B508  8C430000   LW V1, 0(V0)
9D00B50C  2444FFFC   ADDIU A0, V0, -4
9D00B510  AF848008   SW A0, -32760(GP)
9D00B514  8C44FFFC   LW A0, -4(V0)
9D00B518  2442FFF8   ADDIU V0, V0, -8
9D00B51C  AF828008   SW V0, -32760(GP)
70:                  	PC+=cellsize;
9D00B520  8F8280BC   LW V0, -32580(GP)
9D00B524  24450004   ADDIU A1, V0, 4
71:                  	if (vStart==vEnd) {PC=pDATA PC;}
9D00B528  14640004   BNE V1, A0, 0x9D00B53C
9D00B52C  AF8580BC   SW A1, -32580(GP)
9D00B530  8C420004   LW V0, 4(V0)
9D00B534  03E00008   JR RA
9D00B538  AF8280BC   SW V0, -32580(GP)
72:                  	 else {PUSHR(pDATA PC); PUSHR(vEnd); PUSHR(vStart);}
9D00B53C  8F858010   LW A1, -32752(GP)
9D00B540  24A60004   ADDIU A2, A1, 4
9D00B544  AF868010   SW A2, -32752(GP)
9D00B548  8C420004   LW V0, 4(V0)
9D00B54C  ACA20004   SW V0, 4(A1)
9D00B550  8F828010   LW V0, -32752(GP)
9D00B554  24450004   ADDIU A1, V0, 4
9D00B558  AF858010   SW A1, -32752(GP)
9D00B55C  AC440004   SW A0, 4(V0)
9D00B560  8F828010   LW V0, -32752(GP)
9D00B564  24440004   ADDIU A0, V0, 4
9D00B568  AF848010   SW A0, -32752(GP)
9D00B56C  03E00008   JR RA
9D00B570  AC430004   SW V1, 4(V0)
73:                  }
74:                  
75:                  
76:                  void doloop(void)
77:                  {
78:                  	cell vStart=POPR, vEnd=POPR; 
9D00B574  8F828010   LW V0, -32752(GP)
9D00B578  8C430000   LW V1, 0(V0)
9D00B57C  2444FFFC   ADDIU A0, V0, -4
9D00B580  AF848010   SW A0, -32752(GP)
9D00B584  8C44FFFC   LW A0, -4(V0)
9D00B588  2442FFF8   ADDIU V0, V0, -8
9D00B58C  AF828010   SW V0, -32752(GP)
79:                  	PC+=cellsize; vStart++;
9D00B590  8F8580BC   LW A1, -32580(GP)
9D00B594  24A60004   ADDIU A2, A1, 4
9D00B598  AF8680BC   SW A2, -32580(GP)
9D00B59C  24630001   ADDIU V1, V1, 1
80:                  
81:                  	if (vStart<vEnd)
9D00B5A0  0064302A   SLT A2, V1, A0
9D00B5A4  50C0000B   BEQL A2, ZERO, 0x9D00B5D4
9D00B5A8  2442FFFC   ADDIU V0, V0, -4
82:                  	{
83:                  		PC=pDATA PC;
9D00B5AC  8CA50004   LW A1, 4(A1)
9D00B5B0  AF8580BC   SW A1, -32580(GP)
84:                  		PUSHR(vEnd); PUSHR(vStart);
9D00B5B4  24450004   ADDIU A1, V0, 4
9D00B5B8  AF858010   SW A1, -32752(GP)
9D00B5BC  AC440004   SW A0, 4(V0)
9D00B5C0  8F828010   LW V0, -32752(GP)
9D00B5C4  24440004   ADDIU A0, V0, 4
9D00B5C8  AF848010   SW A0, -32752(GP)
9D00B5CC  03E00008   JR RA
9D00B5D0  AC430004   SW V1, 4(V0)
85:                  	}
86:                  	else {pRS--;}  // POPR or leave
9D00B5D4  03E00008   JR RA
9D00B5D8  AF828010   SW V0, -32752(GP)
87:                  }
88:                  
89:                  
90:                  void doplusloop(void)
91:                  {
92:                  	cell vInc=POP, vStart=POPR, vEnd=POPR;
9D00B5DC  8F828008   LW V0, -32760(GP)
9D00B5E0  8C450000   LW A1, 0(V0)
9D00B5E4  2442FFFC   ADDIU V0, V0, -4
9D00B5E8  AF828008   SW V0, -32760(GP)
9D00B5EC  8F828010   LW V0, -32752(GP)
9D00B5F0  8C430000   LW V1, 0(V0)
9D00B5F4  2444FFFC   ADDIU A0, V0, -4
9D00B5F8  AF848010   SW A0, -32752(GP)
9D00B5FC  8C44FFFC   LW A0, -4(V0)
9D00B600  2442FFF8   ADDIU V0, V0, -8
9D00B604  AF828010   SW V0, -32752(GP)
93:                  	char k; 
94:                  
95:                  	PC+=cellsize; vStart+=vInc;
9D00B608  8F8680BC   LW A2, -32580(GP)
9D00B60C  24C70004   ADDIU A3, A2, 4
9D00B610  AF8780BC   SW A3, -32580(GP)
9D00B614  00651821   ADDU V1, V1, A1
96:                  	if (vInc>=0) {k=(char)(vStart<vEnd);} else {k=(char)(vStart>vEnd);}
9D00B618  0064382A   SLT A3, V1, A0
9D00B61C  0083402A   SLT T0, A0, V1
9D00B620  28A50000   SLTI A1, A1, 0
9D00B624  0105380B   MOVN A3, T0, A1
97:                  	if (k)
9D00B628  50E0000B   BEQL A3, ZERO, 0x9D00B658
9D00B62C  2442FFFC   ADDIU V0, V0, -4
98:                  	{
99:                  		PC=pDATA PC;
9D00B630  8CC50004   LW A1, 4(A2)
9D00B634  AF8580BC   SW A1, -32580(GP)
100:                 		PUSHR(vEnd); PUSHR(vStart);
9D00B638  24450004   ADDIU A1, V0, 4
9D00B63C  AF858010   SW A1, -32752(GP)
9D00B640  AC440004   SW A0, 4(V0)
9D00B644  8F828010   LW V0, -32752(GP)
9D00B648  24440004   ADDIU A0, V0, 4
9D00B64C  AF848010   SW A0, -32752(GP)
9D00B650  03E00008   JR RA
9D00B654  AC430004   SW V1, 4(V0)
101:                 	}
102:                 	else {pRS--;}  // POPR or leave
9D00B658  03E00008   JR RA
9D00B65C  AF828010   SW V0, -32752(GP)
103:                 }
104:                 
105:                 
106:                 void dobranch(void)
107:                 {
108:                 	PC+=cellsize;
9D00B660  8F8280BC   LW V0, -32580(GP)
9D00B664  24430004   ADDIU V1, V0, 4
9D00B668  AF8380BC   SW V1, -32580(GP)
109:                 	PC=pDATA PC;
9D00B66C  8C420004   LW V0, 4(V0)
110:                 }
9D00B670  03E00008   JR RA
9D00B674  AF8280BC   SW V0, -32580(GP)
111:                 
112:                 
113:                 void docbranch(void)
114:                 {
115:                 	PC+=cellsize;
9D00B678  8F8380BC   LW V1, -32580(GP)
9D00B67C  24620004   ADDIU V0, V1, 4
9D00B680  AF8280BC   SW V0, -32580(GP)
116:                 	if (!POP) {PC=pDATA PC;}
9D00B684  8F828008   LW V0, -32760(GP)
9D00B688  8C440000   LW A0, 0(V0)
9D00B68C  2442FFFC   ADDIU V0, V0, -4
9D00B690  14800003   BNE A0, ZERO, 0x9D00B6A0
9D00B694  AF828008   SW V0, -32760(GP)
9D00B698  8C620004   LW V0, 4(V1)
9D00B69C  AF8280BC   SW V0, -32580(GP)
9D00B6A0  03E00008   JR RA
9D00B6A4  00000000   NOP
117:                 }
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/DiosForth.X/source/NVMem/NVMem.c  -----------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  NVMem
4:                    *                  DIOS Forth
5:                    *
6:                    * v.1.0 - 10.12.2012, Prog flash memory, L.Pekny
7:                    ********************************************************************/
8:                   
9:                   #include <plib.h>
10:                  #include "..\GenericTypeDefs.h"
11:                  #include "../../../hardware/HardwareProfile.h"
12:                  //#include "..\HardwareProfile.h"
13:                  #include "NVMem.h"
14:                  
15:                  
16:                  UINT FBuf, FBufCnt=0;
17:                  char *pFBuf=(char*)&FBuf;
18:                  UINT *vFHere, *vFHead;
19:                  
20:                  
21:                  void NVMopen(UINT *pFHere)							// Start addr for write
22:                  {
23:                  	FBufCnt=0; vFHere=pFHere;
9D00C754  AF808078   SW ZERO, -32648(GP)
24:                  }
9D00C758  03E00008   JR RA
9D00C75C  AF8480E8   SW A0, -32536(GP)
25:                  
26:                  
27:                  char NVMclose(void)
28:                  {
9D00C8C0  27BDFFE8   ADDIU SP, SP, -24
9D00C8C4  AFBF0014   SW RA, 20(SP)
29:                  	UINT i;
30:                  	if (!NVMflushBuf()) {return 0;}					// Copy Buf to flash
9D00C8C8  0F403221   JAL NVMflushBuf
9D00C8CC  00000000   NOP
9D00C8D0  1040002B   BEQ V0, ZERO, 0x9D00C980
9D00C8D4  00001821   ADDU V1, ZERO, ZERO
31:                  
32:                  	for (i=EETAB; i<EETAB+FLASH_PAGE_SIZE; i+=4) {if (*(int *)i==-1) {break;}}
9D00C8D8  3C02BF88   LUI V0, -16504
9D00C8DC  8C432060   LW V1, 8288(V0)
9D00C8E0  3C049CFF   LUI A0, -25345
9D00C8E4  3484F000   ORI A0, A0, -4096
9D00C8E8  00642021   ADDU A0, V1, A0
9D00C8EC  8C432060   LW V1, 8288(V0)
9D00C8F0  3C029D00   LUI V0, -25344
9D00C8F4  00621021   ADDU V0, V1, V0
9D00C8F8  0082102B   SLTU V0, A0, V0
9D00C8FC  10400012   BEQ V0, ZERO, 0x9D00C948
9D00C900  2402FFFF   ADDIU V0, ZERO, -1
9D00C904  8C830000   LW V1, 0(A0)
9D00C908  14620007   BNE V1, V0, 0x9D00C928
9D00C90C  3C05BF88   LUI A1, -16504
9D00C918  54460006   BNEL V0, A2, 0x9D00C934
9D00C91C  24840004   ADDIU A0, A0, 4
9D00C928  3C039D00   LUI V1, -25344
9D00C92C  2406FFFF   ADDIU A2, ZERO, -1
9D00C930  24840004   ADDIU A0, A0, 4
9D00C934  8CA22060   LW V0, 8288(A1)
9D00C938  00431021   ADDU V0, V0, V1
9D00C93C  0082102B   SLTU V0, A0, V0
9D00C940  5440FFF5   BNEL V0, ZERO, 0x9D00C918
9D00C944  8C820000   LW V0, 0(A0)
33:                  	if (i>=EETAB+FLASH_PAGE_SIZE) {i=EETAB;}		// Empty place or erase page
9D00C910  0B403253   J 0x9D00C94C
9D00C914  3C02BF88   LUI V0, -16504
9D00C920  0B403253   J 0x9D00C94C
9D00C924  3C02BF88   LUI V0, -16504
9D00C948  3C02BF88   LUI V0, -16504
9D00C94C  8C432060   LW V1, 8288(V0)
9D00C950  3C029D00   LUI V0, -25344
9D00C954  00621021   ADDU V0, V1, V0
9D00C958  0082102B   SLTU V0, A0, V0
9D00C95C  14400005   BNE V0, ZERO, 0x9D00C974
9D00C960  3C02BF88   LUI V0, -16504
9D00C964  8C422060   LW V0, 8288(V0)
9D00C968  3C049CFF   LUI A0, -25345
9D00C96C  3484F000   ORI A0, A0, -4096
9D00C970  00442021   ADDU A0, V0, A0
34:                  	return NVMwrite((UINT*)i,(UINT)vFHere); 		// Write vFHere to EETAB
9D00C974  0F4031FB   JAL NVMwrite
9D00C978  8F8580E8   LW A1, -32536(GP)
9D00C97C  00401821   ADDU V1, V0, ZERO
35:                  }
9D00C980  00601021   ADDU V0, V1, ZERO
9D00C984  8FBF0014   LW RA, 20(SP)
9D00C988  03E00008   JR RA
9D00C98C  27BD0018   ADDIU SP, SP, 24
36:                  
37:                  
38:                  char NVMerase(UINT *pAddr)
9D00C7B8  00501821   ADDU V1, V0, S0
39:                  {
9D00C760  27BDFFE8   ADDIU SP, SP, -24
9D00C764  AFBF0014   SW RA, 20(SP)
9D00C768  AFB00010   SW S0, 16(SP)
40:                  	UINT i, Ad=(UINT)pAddr&~0xFFF;
9D00C76C  2410F000   ADDIU S0, ZERO, -4096
9D00C770  00908024   AND S0, A0, S0
41:                  
42:                  	if (Ad>FLASH_END) {return 0;}
9D00C774  3C02BF88   LUI V0, -16504
9D00C778  8C422060   LW V0, 8288(V0)
9D00C77C  3C039CFF   LUI V1, -25345
9D00C780  3463FFFF   ORI V1, V1, -1
9D00C784  00431821   ADDU V1, V0, V1
9D00C788  0070182B   SLTU V1, V1, S0
9D00C78C  14600013   BNE V1, ZERO, 0x9D00C7DC
9D00C790  00001021   ADDU V0, ZERO, ZERO
43:                  
44:                  	NVMErasePage((void *)Ad);
9D00C794  0F403FA8   JAL NVMErasePage
9D00C798  02002021   ADDU A0, S0, ZERO
45:                  
46:                  	for(i=0; i<FLASH_PAGE_SIZE; i+=4) {if (*(int *)(Ad+i)!=-1) {return 0;}}
9D00C79C  8E040000   LW A0, 0(S0)
9D00C7A0  2403FFFF   ADDIU V1, ZERO, -1
9D00C7A4  1483000D   BNE A0, V1, 0x9D00C7DC
9D00C7A8  00001021   ADDU V0, ZERO, ZERO
9D00C7AC  24020004   ADDIU V0, ZERO, 4
9D00C7B0  2404FFFF   ADDIU A0, ZERO, -1
9D00C7B4  24051000   ADDIU A1, ZERO, 4096
9D00C7BC  8C630000   LW V1, 0(V1)
9D00C7C0  14640005   BNE V1, A0, 0x9D00C7D8
9D00C7C4  24420004   ADDIU V0, V0, 4
9D00C7C8  1445FFFC   BNE V0, A1, 0x9D00C7BC
9D00C7CC  00501821   ADDU V1, V0, S0
9D00C7D8  00001021   ADDU V0, ZERO, ZERO
47:                  	return -1;
9D00C7D0  0B4031F7   J 0x9D00C7DC
9D00C7D4  2402FFFF   ADDIU V0, ZERO, -1
48:                  }
9D00C7DC  8FBF0014   LW RA, 20(SP)
9D00C7E0  8FB00010   LW S0, 16(SP)
9D00C7E4  03E00008   JR RA
9D00C7E8  27BD0018   ADDIU SP, SP, 24
49:                  
50:                  
51:                  char NVMwrite(UINT *pAddr, UINT Data)
52:                  {
9D00C7EC  27BDFFE0   ADDIU SP, SP, -32
9D00C7F0  AFBF001C   SW RA, 28(SP)
9D00C7F4  AFB10018   SW S1, 24(SP)
9D00C7F8  AFB00014   SW S0, 20(SP)
9D00C7FC  00808021   ADDU S0, A0, ZERO
9D00C800  00A08821   ADDU S1, A1, ZERO
53:                  	UINT Addr=(UINT)pAddr;
54:                  
55:                  	if (Addr>FLASH_END) {return 0;}
9D00C804  3C02BF88   LUI V0, -16504
9D00C808  8C432060   LW V1, 8288(V0)
9D00C80C  3C029CFF   LUI V0, -25345
9D00C810  3442FFFF   ORI V0, V0, -1
9D00C814  00621021   ADDU V0, V1, V0
9D00C818  0044102B   SLTU V0, V0, A0
9D00C81C  14400013   BNE V0, ZERO, 0x9D00C86C
9D00C820  00001821   ADDU V1, ZERO, ZERO
56:                  	if (!(Addr&0xFFF)&&(pAddr>=vFHere)) {if (!NVMerase(pAddr)) {return 0;}}  // Erase new page
9D00C824  30820FFF   ANDI V0, A0, 4095
9D00C828  14400008   BNE V0, ZERO, 0x9D00C84C
9D00C82C  8F8280E8   LW V0, -32536(GP)
9D00C830  0082102B   SLTU V0, A0, V0
9D00C834  54400006   BNEL V0, ZERO, 0x9D00C850
9D00C838  02002021   ADDU A0, S0, ZERO
9D00C83C  0F4031D8   JAL NVMerase
9D00C840  00000000   NOP
9D00C844  10400009   BEQ V0, ZERO, 0x9D00C86C
9D00C848  00001821   ADDU V1, ZERO, ZERO
57:                  	NVMWriteWord(pAddr, Data); if (*pAddr!=Data) {return 0;}  // Write and compare
9D00C84C  02002021   ADDU A0, S0, ZERO
9D00C850  0F403F8F   JAL NVMWriteWord
9D00C854  02202821   ADDU A1, S1, ZERO
9D00C858  8E030000   LW V1, 0(S0)
9D00C85C  00718826   XOR S1, V1, S1
9D00C860  2402FFFF   ADDIU V0, ZERO, -1
9D00C864  00001821   ADDU V1, ZERO, ZERO
9D00C868  0051180A   MOVZ V1, V0, S1
58:                  	return -1;
59:                  }
9D00C86C  00601021   ADDU V0, V1, ZERO
9D00C870  8FBF001C   LW RA, 28(SP)
9D00C874  8FB10018   LW S1, 24(SP)
9D00C878  8FB00014   LW S0, 20(SP)
9D00C87C  03E00008   JR RA
9D00C880  27BD0020   ADDIU SP, SP, 32
60:                  
61:                  
62:                  char NVMflushBuf(void)
63:                  {
9D00C884  27BDFFE8   ADDIU SP, SP, -24
9D00C888  AFBF0014   SW RA, 20(SP)
64:                  	int r;
65:                  	if (FBufCnt)
9D00C88C  8F838078   LW V1, -32648(GP)
9D00C890  10600008   BEQ V1, ZERO, 0x9D00C8B4
9D00C894  24020001   ADDIU V0, ZERO, 1
66:                  	{	
67:                  	  FBufCnt=0;
9D00C898  AF808078   SW ZERO, -32648(GP)
68:                  	  r=NVMwrite(vFHere,FBuf); vFHere++;			// 0-err, -1-NVM
9D00C89C  8F8480E8   LW A0, -32536(GP)
9D00C8A0  0F4031FB   JAL NVMwrite
9D00C8A4  8F8580E4   LW A1, -32540(GP)
9D00C8A8  8F8380E8   LW V1, -32536(GP)
9D00C8AC  24630004   ADDIU V1, V1, 4
9D00C8B0  AF8380E8   SW V1, -32536(GP)
69:                  	  return r;
70:                  	} else return 1;								// 1-Buf
71:                  }
9D00C8B4  8FBF0014   LW RA, 20(SP)
9D00C8B8  03E00008   JR RA
9D00C8BC  27BD0018   ADDIU SP, SP, 24
72:                  
73:                  
74:                  char NVMwriteBuf(UINT Data)							// Write UINT to NVM
75:                  {
9D00C990  27BDFFE8   ADDIU SP, SP, -24
9D00C994  AFBF0014   SW RA, 20(SP)
9D00C998  AFB00010   SW S0, 16(SP)
76:                  	int r;
77:                  	NVMflushBuf();									// Align 32b
9D00C99C  0F403221   JAL NVMflushBuf
9D00C9A0  00808021   ADDU S0, A0, ZERO
78:                  	r=NVMwrite(vFHere,Data); vFHere++;				// 0-err, -1-NVM
9D00C9A4  8F8480E8   LW A0, -32536(GP)
9D00C9A8  0F4031FB   JAL NVMwrite
9D00C9AC  02002821   ADDU A1, S0, ZERO
9D00C9B0  8F8380E8   LW V1, -32536(GP)
9D00C9B4  24630004   ADDIU V1, V1, 4
9D00C9B8  AF8380E8   SW V1, -32536(GP)
79:                  	return r;
80:                  }
9D00C9BC  8FBF0014   LW RA, 20(SP)
9D00C9C0  8FB00010   LW S0, 16(SP)
9D00C9C4  03E00008   JR RA
9D00C9C8  27BD0018   ADDIU SP, SP, 24
81:                  
82:                  
83:                  char NVMwriteBufc(char Data)						// Delayed write to NVM
84:                  {
9D00C9CC  27BDFFE8   ADDIU SP, SP, -24
9D00C9D0  AFBF0014   SW RA, 20(SP)
85:                  	int r;
86:                  	*(char*)(pFBuf+FBufCnt)=Data; FBufCnt++;		// Write byte to FBuf
9D00C9D4  8F828078   LW V0, -32648(GP)
9D00C9D8  8F838040   LW V1, -32704(GP)
9D00C9DC  00621021   ADDU V0, V1, V0
9D00C9E0  A0440000   SB A0, 0(V0)
9D00C9E4  8F828078   LW V0, -32648(GP)
9D00C9E8  24420001   ADDIU V0, V0, 1
9D00C9EC  AF828078   SW V0, -32648(GP)
87:                  
88:                  	if (FBufCnt>3)									// Full? Write to Flash
9D00C9F0  2C430004   SLTIU V1, V0, 4
9D00C9F4  14600008   BNE V1, ZERO, 0x9D00CA18
9D00C9F8  24020001   ADDIU V0, ZERO, 1
89:                  	{
90:                  	  FBufCnt=0; 
9D00C9FC  AF808078   SW ZERO, -32648(GP)
91:                  	  r=NVMwrite(vFHere,FBuf); vFHere++;			// 0-err, -1-NVM
9D00CA00  8F8480E8   LW A0, -32536(GP)
9D00CA04  0F4031FB   JAL NVMwrite
9D00CA08  8F8580E4   LW A1, -32540(GP)
9D00CA0C  8F8380E8   LW V1, -32536(GP)
9D00CA10  24630004   ADDIU V1, V1, 4
9D00CA14  AF8380E8   SW V1, -32536(GP)
92:                  	  return r;
93:                  	} else return 1;								// 1-Buf
94:                  }
9D00CA18  8FBF0014   LW RA, 20(SP)
9D00CA1C  03E00008   JR RA
9D00CA20  27BD0018   ADDIU SP, SP, 24
95:                  
96:                  
97:                  char NVMwriteBufw(WORD Data)						// Delayed write to NVM
98:                  {
9D00CA24  27BDFFE8   ADDIU SP, SP, -24
9D00CA28  AFBF0014   SW RA, 20(SP)
9D00CA2C  AFB00010   SW S0, 16(SP)
99:                  	int r;
100:                 	if (FBufCnt==1) {FBufCnt++;}					// Align 16b
9D00CA30  8F828078   LW V0, -32648(GP)
9D00CA34  24030001   ADDIU V1, ZERO, 1
9D00CA38  14430004   BNE V0, V1, 0x9D00CA4C
9D00CA3C  3090FFFF   ANDI S0, A0, -1
9D00CA40  24020002   ADDIU V0, ZERO, 2
9D00CA44  0B403298   J 0x9D00CA60
9D00CA48  AF828078   SW V0, -32648(GP)
101:                 	if (FBufCnt==3) {NVMflushBuf();}				// Align 32b
9D00CA4C  24030003   ADDIU V1, ZERO, 3
9D00CA50  54430004   BNEL V0, V1, 0x9D00CA64
9D00CA54  8F828078   LW V0, -32648(GP)
9D00CA58  0F403221   JAL NVMflushBuf
9D00CA5C  00000000   NOP
102:                 	*(WORD*)(pFBuf+FBufCnt)=Data; FBufCnt+=2;		// Write word to FBuf
9D00CA60  8F828078   LW V0, -32648(GP)
9D00CA64  8F838040   LW V1, -32704(GP)
9D00CA68  00621021   ADDU V0, V1, V0
9D00CA6C  A4500000   SH S0, 0(V0)
9D00CA70  8F828078   LW V0, -32648(GP)
9D00CA74  24420002   ADDIU V0, V0, 2
9D00CA78  AF828078   SW V0, -32648(GP)
103:                 
104:                 	if (FBufCnt>3)									// Full? Write to Flash
9D00CA7C  2C430004   SLTIU V1, V0, 4
9D00CA80  14600008   BNE V1, ZERO, 0x9D00CAA4
9D00CA84  24020001   ADDIU V0, ZERO, 1
105:                 	{
106:                 	  FBufCnt=0; 
9D00CA88  AF808078   SW ZERO, -32648(GP)
107:                 	  r=NVMwrite(vFHere,FBuf); vFHere++;			// 0-err, -1-NVM
9D00CA8C  8F8480E8   LW A0, -32536(GP)
9D00CA90  0F4031FB   JAL NVMwrite
9D00CA94  8F8580E4   LW A1, -32540(GP)
9D00CA98  8F8380E8   LW V1, -32536(GP)
9D00CA9C  24630004   ADDIU V1, V1, 4
9D00CAA0  AF8380E8   SW V1, -32536(GP)
108:                 	  return r;
109:                 	} else return 1;								// 1-Buf
110:                 }
9D00CAA4  8FBF0014   LW RA, 20(SP)
9D00CAA8  8FB00010   LW S0, 16(SP)
9D00CAAC  03E00008   JR RA
9D00CAB0  27BD0018   ADDIU SP, SP, 24
111:                 
---  /Volumes/home/c11067/xc32/build/gcc/libgcc2.c  -----------------------------------------------------
9D00AD14  00C01021   ADDU V0, A2, ZERO
9D00B6B8  00C01021   ADDU V0, A2, ZERO
9D00BB50  00C04021   ADDU T0, A2, ZERO
9D00BFB0  00C01021   ADDU V0, A2, ZERO
9D00AD18  00804821   ADDU T1, A0, ZERO
9D00B6BC  00804821   ADDU T1, A0, ZERO
9D00BB54  00804821   ADDU T1, A0, ZERO
9D00BFB4  00804021   ADDU T0, A0, ZERO
9D00AD1C  14E00045   BNE A3, ZERO, 0x9D00AE34
9D00AD20  00A01821   ADDU V1, A1, ZERO
9D00B6C0  14E00041   BNE A3, ZERO, 0x9D00B7C8
9D00B6C4  00A01821   ADDU V1, A1, ZERO
9D00BB58  14E0003B   BNE A3, ZERO, 0x9D00BC48
9D00BB5C  00A01821   ADDU V1, A1, ZERO
9D00BFB8  14E0003D   BNE A3, ZERO, 0x9D00C0B0
9D00BFBC  00A01821   ADDU V1, A1, ZERO
9D00AD24  00A6302B   SLTU A2, A1, A2
9D00AD28  10C00066   BEQ A2, ZERO, 0x9D00AEC4
9D00AD2C  70463020   CLZ A2, V0
9D00B6C8  00A6302B   SLTU A2, A1, A2
9D00B6CC  10C0005F   BEQ A2, ZERO, 0x9D00B84C
9D00B6D0  00000000   NOP
9D00BB60  00A6102B   SLTU V0, A1, A2
9D00BB64  10400048   BEQ V0, ZERO, 0x9D00BC88
9D00BB68  70C21020   CLZ V0, A2
9D00BFC0  00A6302B   SLTU A2, A1, A2
9D00BFC4  10C00046   BEQ A2, ZERO, 0x9D00C0E0
9D00BFC8  00000000   NOP
9D00B6D4  70442020   CLZ A0, V0
9D00BFCC  70442020   CLZ A0, V0
9D00AD30  10C00008   BEQ A2, ZERO, 0x9D00AD54
9D00AD34  00025C02   SRL T3, V0, 16
9D00B6D8  10800008   BEQ A0, ZERO, 0x9D00B6FC
9D00B6DC  00022C02   SRL A1, V0, 16
9D00BB6C  50400008   BEQL V0, ZERO, 0x9D00BB90
9D00BB70  00083402   SRL A2, T0, 16
9D00BFD0  10800008   BEQ A0, ZERO, 0x9D00BFF4
9D00BFD4  00022C02   SRL A1, V0, 16
9D00AD44  00C21004   SLLV V0, V0, A2
9D00B6EC  00821004   SLLV V0, V0, A0
9D00BB80  00464004   SLLV T0, A2, V0
9D00BFE4  00821004   SLLV V0, V0, A0
9D00AD38  00062023   SUBU A0, ZERO, A2
9D00AD3C  00892006   SRLV A0, T1, A0
9D00AD40  00C51804   SLLV V1, A1, A2
9D00AD48  00831825   OR V1, A0, V1
9D00B6E0  00042823   SUBU A1, ZERO, A0
9D00B6E4  00A92806   SRLV A1, T1, A1
9D00B6E8  00831804   SLLV V1, V1, A0
9D00B6F0  00A31825   OR V1, A1, V1
9D00BB74  00022023   SUBU A0, ZERO, V0
9D00BB78  00892006   SRLV A0, T1, A0
9D00BB7C  00451804   SLLV V1, A1, V0
9D00BB84  00831825   OR V1, A0, V1
9D00BFD8  00042823   SUBU A1, ZERO, A0
9D00BFDC  00A82806   SRLV A1, T0, A1
9D00BFE0  00831804   SLLV V1, V1, A0
9D00BFE8  00A31825   OR V1, A1, V1
9D00AD4C  00C94804   SLLV T1, T1, A2
9D00B6F4  00894804   SLLV T1, T1, A0
9D00BB88  00494804   SLLV T1, T1, V0
9D00BFEC  00884004   SLLV T0, T0, A0
9D00AD50  00025C02   SRL T3, V0, 16
9D00AD54  006B001B   DIVU V1, T3
9D00AD58  016001F4   TEQ T3, ZERO
9D00AD5C  304EFFFF   ANDI T6, V0, -1
9D00AD60  00092402   SRL A0, T1, 16
9D00AD64  00006812   MFLO T5, 0
9D00AD68  00006010   MFHI T4, 0
9D00AD6C  000C6400   SLL T4, T4, 16
9D00AD70  01846025   OR T4, T4, A0
9D00AD74  71AE6802   MUL T5, T5, T6
9D00AD78  018D782B   SLTU T7, T4, T5
9D00AD7C  006B001B   DIVU V1, T3
9D00AD80  016001F4   TEQ T3, ZERO
9D00AD84  51E00009   BEQL T7, ZERO, 0x9D00ADAC
9D00AD88  018D6023   SUBU T4, T4, T5
9D00AD8C  01826021   ADDU T4, T4, V0
9D00AD90  0182182B   SLTU V1, T4, V0
9D00AD94  54600005   BNEL V1, ZERO, 0x9D00ADAC
9D00AD98  018D6023   SUBU T4, T4, T5
9D00AD9C  018D182B   SLTU V1, T4, T5
9D00ADA0  70622002   MUL A0, V1, V0
9D00ADA4  008C6021   ADDU T4, A0, T4
9D00ADA8  018D6023   SUBU T4, T4, T5
9D00ADAC  018B001B   DIVU T4, T3
9D00ADB0  016001F4   TEQ T3, ZERO
9D00ADB4  3129FFFF   ANDI T1, T1, -1
9D00ADB8  00001812   MFLO V1, 0
9D00ADBC  00002010   MFHI A0, 0
9D00ADC0  00042400   SLL A0, A0, 16
9D00ADC4  00894825   OR T1, A0, T1
9D00ADC8  706E1802   MUL V1, V1, T6
9D00ADCC  0123202B   SLTU A0, T1, V1
9D00ADD0  018B001B   DIVU T4, T3
9D00ADD4  016001F4   TEQ T3, ZERO
9D00ADD8  50800009   BEQL A0, ZERO, 0x9D00AE00
9D00ADDC  01234823   SUBU T1, T1, V1
9D00ADE0  01224821   ADDU T1, T1, V0
9D00ADE4  0122202B   SLTU A0, T1, V0
9D00ADE8  54800005   BNEL A0, ZERO, 0x9D00AE00
9D00ADEC  01234823   SUBU T1, T1, V1
9D00ADF0  0123202B   SLTU A0, T1, V1
9D00ADF4  70822802   MUL A1, A0, V0
9D00ADF8  00A94821   ADDU T1, A1, T1
9D00ADFC  01234823   SUBU T1, T1, V1
9D00B6F8  00022C02   SRL A1, V0, 16
9D00B6FC  0065001B   DIVU V1, A1
9D00B700  00A001F4   TEQ A1, ZERO
9D00B704  304BFFFF   ANDI T3, V0, -1
9D00B708  00096402   SRL T4, T1, 16
9D00B70C  00005012   MFLO T2, 0
9D00B710  00003810   MFHI A3, 0
9D00B714  00073C00   SLL A3, A3, 16
9D00B718  00EC3825   OR A3, A3, T4
9D00B71C  714B2002   MUL A0, T2, T3
9D00B720  00E4302B   SLTU A2, A3, A0
9D00B724  0065001B   DIVU V1, A1
9D00B728  00A001F4   TEQ A1, ZERO
9D00B72C  10C0000B   BEQ A2, ZERO, 0x9D00B75C
9D00B730  00E41823   SUBU V1, A3, A0
9D00B734  00E23821   ADDU A3, A3, V0
9D00B738  00E2182B   SLTU V1, A3, V0
9D00B73C  14600006   BNE V1, ZERO, 0x9D00B758
9D00B740  254AFFFF   ADDIU T2, T2, -1
9D00B744  00E4182B   SLTU V1, A3, A0
9D00B748  10600004   BEQ V1, ZERO, 0x9D00B75C
9D00B74C  00E41823   SUBU V1, A3, A0
9D00B750  254AFFFF   ADDIU T2, T2, -1
9D00B754  00E23821   ADDU A3, A3, V0
9D00B758  00E41823   SUBU V1, A3, A0
9D00B75C  0065001B   DIVU V1, A1
9D00B760  00A001F4   TEQ A1, ZERO
9D00B764  3129FFFF   ANDI T1, T1, -1
9D00B768  00002012   MFLO A0, 0
9D00B76C  00003010   MFHI A2, 0
9D00B770  00063400   SLL A2, A2, 16
9D00B774  00C94825   OR T1, A2, T1
9D00B778  708B5802   MUL T3, A0, T3
9D00B77C  012B302B   SLTU A2, T1, T3
9D00B780  0065001B   DIVU V1, A1
9D00B784  00A001F4   TEQ A1, ZERO
9D00B788  50C00008   BEQL A2, ZERO, 0x9D00B7AC
9D00B78C  000A5400   SLL T2, T2, 16
9D00B790  01224821   ADDU T1, T1, V0
9D00B794  0122102B   SLTU V0, T1, V0
9D00B798  14400003   BNE V0, ZERO, 0x9D00B7A8
9D00B79C  2484FFFF   ADDIU A0, A0, -1
9D00B7A0  012B582B   SLTU T3, T1, T3
9D00B7A4  008B2023   SUBU A0, A0, T3
9D00B7A8  000A5400   SLL T2, T2, 16
9D00B7AC  008A2025   OR A0, A0, T2
9D00B7B0  00002821   ADDU A1, ZERO, ZERO
9D00BB8C  00083402   SRL A2, T0, 16
9D00BB90  0066001B   DIVU V1, A2
9D00BB94  00C001F4   TEQ A2, ZERO
9D00BB98  310CFFFF   ANDI T4, T0, -1
9D00BB9C  00092402   SRL A0, T1, 16
9D00BBA0  00005812   MFLO T3, 0
9D00BBA4  00005010   MFHI T2, 0
9D00BBA8  000A5400   SLL T2, T2, 16
9D00BBAC  01445025   OR T2, T2, A0
9D00BBB0  716C5802   MUL T3, T3, T4
9D00BBB4  014B682B   SLTU T5, T2, T3
9D00BBB8  0066001B   DIVU V1, A2
9D00BBBC  00C001F4   TEQ A2, ZERO
9D00BBC0  51A00009   BEQL T5, ZERO, 0x9D00BBE8
9D00BBC4  014B5023   SUBU T2, T2, T3
9D00BBC8  01485021   ADDU T2, T2, T0
9D00BBCC  0148182B   SLTU V1, T2, T0
9D00BBD0  54600005   BNEL V1, ZERO, 0x9D00BBE8
9D00BBD4  014B5023   SUBU T2, T2, T3
9D00BBD8  014B182B   SLTU V1, T2, T3
9D00BBDC  70682002   MUL A0, V1, T0
9D00BBE0  008A5021   ADDU T2, A0, T2
9D00BBE4  014B5023   SUBU T2, T2, T3
9D00BBE8  0146001B   DIVU T2, A2
9D00BBEC  00C001F4   TEQ A2, ZERO
9D00BBF0  3129FFFF   ANDI T1, T1, -1
9D00BBF4  00002012   MFLO A0, 0
9D00BBF8  00001810   MFHI V1, 0
9D00BBFC  00031C00   SLL V1, V1, 16
9D00BC00  00694825   OR T1, V1, T1
9D00BC04  708C2002   MUL A0, A0, T4
9D00BC08  0124182B   SLTU V1, T1, A0
9D00BC0C  0146001B   DIVU T2, A2
9D00BC10  00C001F4   TEQ A2, ZERO
9D00BC14  50600009   BEQL V1, ZERO, 0x9D00BC3C
9D00BC18  01244823   SUBU T1, T1, A0
9D00BC1C  01284821   ADDU T1, T1, T0
9D00BC20  0128182B   SLTU V1, T1, T0
9D00BC24  54600005   BNEL V1, ZERO, 0x9D00BC3C
9D00BC28  01244823   SUBU T1, T1, A0
9D00BC2C  0124182B   SLTU V1, T1, A0
9D00BC30  70682802   MUL A1, V1, T0
9D00BC34  00A94821   ADDU T1, A1, T1
9D00BC38  01244823   SUBU T1, T1, A0
9D00BFF0  00022C02   SRL A1, V0, 16
9D00BFF4  0065001B   DIVU V1, A1
9D00BFF8  00A001F4   TEQ A1, ZERO
9D00BFFC  304AFFFF   ANDI T2, V0, -1
9D00C000  00085C02   SRL T3, T0, 16
9D00C004  00004812   MFLO T1, 0
9D00C008  00003810   MFHI A3, 0
9D00C00C  00073C00   SLL A3, A3, 16
9D00C010  00EB3825   OR A3, A3, T3
9D00C014  712A2002   MUL A0, T1, T2
9D00C018  00E4302B   SLTU A2, A3, A0
9D00C01C  0065001B   DIVU V1, A1
9D00C020  00A001F4   TEQ A1, ZERO
9D00C024  10C0000B   BEQ A2, ZERO, 0x9D00C054
9D00C028  00E41823   SUBU V1, A3, A0
9D00C02C  00E23821   ADDU A3, A3, V0
9D00C030  00E2182B   SLTU V1, A3, V0
9D00C034  14600006   BNE V1, ZERO, 0x9D00C050
9D00C038  2529FFFF   ADDIU T1, T1, -1
9D00C03C  00E4182B   SLTU V1, A3, A0
9D00C040  10600004   BEQ V1, ZERO, 0x9D00C054
9D00C044  00E41823   SUBU V1, A3, A0
9D00C048  2529FFFF   ADDIU T1, T1, -1
9D00C04C  00E23821   ADDU A3, A3, V0
9D00C050  00E41823   SUBU V1, A3, A0
9D00C054  0065001B   DIVU V1, A1
9D00C058  00A001F4   TEQ A1, ZERO
9D00C05C  3108FFFF   ANDI T0, T0, -1
9D00C060  00002012   MFLO A0, 0
9D00C064  00003010   MFHI A2, 0
9D00C068  00063400   SLL A2, A2, 16
9D00C06C  00C84025   OR T0, A2, T0
9D00C070  708A5002   MUL T2, A0, T2
9D00C074  010A302B   SLTU A2, T0, T2
9D00C078  0065001B   DIVU V1, A1
9D00C07C  00A001F4   TEQ A1, ZERO
9D00C080  10C00006   BEQ A2, ZERO, 0x9D00C09C
9D00C084  01024021   ADDU T0, T0, V0
9D00C088  0102102B   SLTU V0, T0, V0
9D00C08C  14400003   BNE V0, ZERO, 0x9D00C09C
9D00C090  2484FFFF   ADDIU A0, A0, -1
9D00C094  010A502B   SLTU T2, T0, T2
9D00C098  008A2023   SUBU A0, A0, T2
9D00C09C  00094C00   SLL T1, T1, 16
9D00C0A0  00892025   OR A0, A0, T1
9D00C0A4  00001821   ADDU V1, ZERO, ZERO
9D00AEC4  14400006   BNE V0, ZERO, 0x9D00AEE0
9D00AEC8  00000000   NOP
9D00B84C  14400006   BNE V0, ZERO, 0x9D00B868
9D00B850  70463020   CLZ A2, V0
9D00BC88  14C00006   BNE A2, ZERO, 0x9D00BCA4
9D00BC8C  71021020   CLZ V0, T0
9D00C0E0  14400006   BNE V0, ZERO, 0x9D00C0FC
9D00C0E4  70463020   CLZ A2, V0
9D00AECC  24020001   ADDIU V0, ZERO, 1
9D00AED0  0047001B   DIVU V0, A3
9D00AED4  00E001F4   TEQ A3, ZERO
9D00AED8  00001012   MFLO V0, 0
9D00B854  24020001   ADDIU V0, ZERO, 1
9D00B858  0047001B   DIVU V0, A3
9D00B85C  00E001F4   TEQ A3, ZERO
9D00B860  00001012   MFLO V0, 0
9D00BC90  24020001   ADDIU V0, ZERO, 1
9D00BC94  0046001B   DIVU V0, A2
9D00BC98  00C001F4   TEQ A2, ZERO
9D00BC9C  00004012   MFLO T0, 0
9D00C0E8  24030001   ADDIU V1, ZERO, 1
9D00C0EC  0062001B   DIVU V1, V0
9D00C0F0  004001F4   TEQ V0, ZERO
9D00C0F4  00001012   MFLO V0, 0
9D00AEDC  70463020   CLZ A2, V0
9D00B864  70463020   CLZ A2, V0
9D00BCA0  71021020   CLZ V0, T0
9D00C0F8  70463020   CLZ A2, V0
9D00AEE0  54C0002F   BNEL A2, ZERO, 0x9D00AFA0
9D00AEE4  24090020   ADDIU T1, ZERO, 32
9D00B868  54C00030   BNEL A2, ZERO, 0x9D00B92C
9D00B86C  24090020   ADDIU T1, ZERO, 32
9D00BCA4  5440007C   BNEL V0, ZERO, 0x9D00BE98
9D00BCA8  24090020   ADDIU T1, ZERO, 32
9D00C0FC  54C00077   BNEL A2, ZERO, 0x9D00C2DC
9D00C100  24080020   ADDIU T0, ZERO, 32
9D00AEE8  00A22823   SUBU A1, A1, V0
9D00AEEC  00021C02   SRL V1, V0, 16
9D00AEF0  3047FFFF   ANDI A3, V0, -1
9D00B870  00A25823   SUBU T3, A1, V0
9D00B874  00023C02   SRL A3, V0, 16
9D00B878  304DFFFF   ANDI T5, V0, -1
9D00BCAC  00A82823   SUBU A1, A1, T0
9D00BCB0  00081C02   SRL V1, T0, 16
9D00BCB4  3107FFFF   ANDI A3, T0, -1
9D00C104  00A24823   SUBU T1, A1, V0
9D00C108  00023C02   SRL A3, V0, 16
9D00C10C  304CFFFF   ANDI T4, V0, -1
9D00B87C  24050001   ADDIU A1, ZERO, 1
9D00C110  24030001   ADDIU V1, ZERO, 1
9D00AFA0  01264823   SUBU T1, T1, A2
9D00B92C  01264823   SUBU T1, T1, A2
9D00BE98  01224823   SUBU T1, T1, V0
9D00C2E0  01064023   SUBU T0, T0, A2
9D00AFA4  00C21004   SLLV V0, V0, A2
9D00B930  00C21004   SLLV V0, V0, A2
9D00BE9C  00484004   SLLV T0, T0, V0
9D00C2DC  00C21004   SLLV V0, V0, A2
9D00AFA8  01255806   SRLV T3, A1, T1
9D00B934  01255006   SRLV T2, A1, T1
9D00BEA0  01253006   SRLV A2, A1, T1
9D00C2E4  01055006   SRLV T2, A1, T0
9D00AFBC  01246806   SRLV T5, A0, T1
9D00AFC0  00C52804   SLLV A1, A1, A2
9D00AFC4  01A56825   OR T5, T5, A1
9D00B948  00C52804   SLLV A1, A1, A2
9D00B94C  01245806   SRLV T3, A0, T1
9D00B954  01655825   OR T3, T3, A1
9D00BEB4  01245806   SRLV T3, A0, T1
9D00BEB8  00452804   SLLV A1, A1, V0
9D00BEBC  01655825   OR T3, T3, A1
9D00C2F4  01044006   SRLV T0, A0, T0
9D00C2F8  00C52804   SLLV A1, A1, A2
9D00C300  01052825   OR A1, T0, A1
9D00AFCC  00C44804   SLLV T1, A0, A2
9D00B950  00C44804   SLLV T1, A0, A2
9D00BEC4  00444804   SLLV T1, A0, V0
9D00C304  00C44004   SLLV T0, A0, A2
9D00AFAC  00021C02   SRL V1, V0, 16
9D00AFB0  0163001B   DIVU T3, V1
9D00AFB4  006001F4   TEQ V1, ZERO
9D00AFB8  3047FFFF   ANDI A3, V0, -1
9D00AFC8  000D2C02   SRL A1, T5, 16
9D00AFD0  00006012   MFLO T4, 0
9D00AFD4  00007010   MFHI T6, 0
9D00AFD8  000E2400   SLL A0, T6, 16
9D00AFDC  00A42025   OR A0, A1, A0
9D00AFE0  71876002   MUL T4, T4, A3
9D00AFE4  008C282B   SLTU A1, A0, T4
9D00AFE8  0163001B   DIVU T3, V1
9D00AFEC  006001F4   TEQ V1, ZERO
9D00AFF0  50A00006   BEQL A1, ZERO, 0x9D00B00C
9D00AFF4  008C2023   SUBU A0, A0, T4
9D00AFF8  00822021   ADDU A0, A0, V0
9D00AFFC  0082282B   SLTU A1, A0, V0
9D00B000  10A0006D   BEQ A1, ZERO, 0x9D00B1B8
9D00B004  008C282B   SLTU A1, A0, T4
9D00B008  008C2023   SUBU A0, A0, T4
9D00B00C  0083001B   DIVU A0, V1
9D00B010  006001F4   TEQ V1, ZERO
9D00B014  31ADFFFF   ANDI T5, T5, -1
9D00B018  00005812   MFLO T3, 0
9D00B01C  00002810   MFHI A1, 0
9D00B020  00052C00   SLL A1, A1, 16
9D00B024  00AD2825   OR A1, A1, T5
9D00B028  71675802   MUL T3, T3, A3
9D00B02C  00AB602B   SLTU T4, A1, T3
9D00B030  0083001B   DIVU A0, V1
9D00B034  006001F4   TEQ V1, ZERO
9D00B038  5180FFAE   BEQL T4, ZERO, 0x9D00AEF4
9D00B03C  00AB2823   SUBU A1, A1, T3
9D00B040  00A22821   ADDU A1, A1, V0
9D00B044  00A2202B   SLTU A0, A1, V0
9D00B048  5480FFAA   BNEL A0, ZERO, 0x9D00AEF4
9D00B04C  00AB2823   SUBU A1, A1, T3
9D00B050  00AB202B   SLTU A0, A1, T3
9D00B054  70826002   MUL T4, A0, V0
9D00B058  01852821   ADDU A1, T4, A1
9D00B05C  0B402BBD   J 0x9D00AEF4
9D00B060  00AB2823   SUBU A1, A1, T3
9D00B1B8  70A25802   MUL T3, A1, V0
9D00B1BC  0B402C02   J 0x9D00B008
9D00B1C0  01642021   ADDU A0, T3, A0
9D00B938  00023C02   SRL A3, V0, 16
9D00B93C  0147001B   DIVU T2, A3
9D00B940  00E001F4   TEQ A3, ZERO
9D00B944  304DFFFF   ANDI T5, V0, -1
9D00B958  000B6402   SRL T4, T3, 16
9D00B95C  00001812   MFLO V1, 0
9D00B960  00007010   MFHI T6, 0
9D00B964  000E2400   SLL A0, T6, 16
9D00B968  01842025   OR A0, T4, A0
9D00B96C  00003012   MFLO A2, 0
9D00B970  706D1802   MUL V1, V1, T5
9D00B974  0083282B   SLTU A1, A0, V1
9D00B978  0147001B   DIVU T2, A3
9D00B97C  00E001F4   TEQ A3, ZERO
9D00B980  50A0000B   BEQL A1, ZERO, 0x9D00B9B0
9D00B984  00832023   SUBU A0, A0, V1
9D00B988  00822021   ADDU A0, A0, V0
9D00B98C  0082282B   SLTU A1, A0, V0
9D00B990  14A00006   BNE A1, ZERO, 0x9D00B9AC
9D00B994  24C6FFFF   ADDIU A2, A2, -1
9D00B998  0083282B   SLTU A1, A0, V1
9D00B99C  50A00004   BEQL A1, ZERO, 0x9D00B9B0
9D00B9A0  00832023   SUBU A0, A0, V1
9D00B9A4  24C6FFFF   ADDIU A2, A2, -1
9D00B9A8  00822021   ADDU A0, A0, V0
9D00B9AC  00832023   SUBU A0, A0, V1
9D00B9B0  0087001B   DIVU A0, A3
9D00B9B4  00E001F4   TEQ A3, ZERO
9D00B9B8  316BFFFF   ANDI T3, T3, -1
9D00B9BC  00001812   MFLO V1, 0
9D00B9C0  00002810   MFHI A1, 0
9D00B9C4  00052C00   SLL A1, A1, 16
9D00B9C8  00AB5825   OR T3, A1, T3
9D00B9CC  706D5002   MUL T2, V1, T5
9D00B9D0  016A282B   SLTU A1, T3, T2
9D00B9D4  0087001B   DIVU A0, A3
9D00B9D8  00E001F4   TEQ A3, ZERO
9D00B9DC  50A0000B   BEQL A1, ZERO, 0x9D00BA0C
9D00B9E0  00062C00   SLL A1, A2, 16
9D00B9E4  01625821   ADDU T3, T3, V0
9D00B9E8  0162202B   SLTU A0, T3, V0
9D00B9EC  14800006   BNE A0, ZERO, 0x9D00BA08
9D00B9F0  2463FFFF   ADDIU V1, V1, -1
9D00B9F4  016A202B   SLTU A0, T3, T2
9D00B9F8  50800004   BEQL A0, ZERO, 0x9D00BA0C
9D00B9FC  00062C00   SLL A1, A2, 16
9D00BA00  2463FFFF   ADDIU V1, V1, -1
9D00BA04  01625821   ADDU T3, T3, V0
9D00BA08  00062C00   SLL A1, A2, 16
9D00BA0C  016A5823   SUBU T3, T3, T2
9D00BA10  0B402E20   J 0x9D00B880
9D00BA14  00652825   OR A1, V1, A1
9D00BEA4  00081C02   SRL V1, T0, 16
9D00BEA8  00C3001B   DIVU A2, V1
9D00BEAC  006001F4   TEQ V1, ZERO
9D00BEB0  3107FFFF   ANDI A3, T0, -1
9D00BEC0  000B2C02   SRL A1, T3, 16
9D00BEC8  00005012   MFLO T2, 0
9D00BECC  00006010   MFHI T4, 0
9D00BED0  000C2400   SLL A0, T4, 16
9D00BED4  00A42025   OR A0, A1, A0
9D00BED8  71475002   MUL T2, T2, A3
9D00BEDC  008A282B   SLTU A1, A0, T2
9D00BEE0  00C3001B   DIVU A2, V1
9D00BEE4  006001F4   TEQ V1, ZERO
9D00BEE8  50A00006   BEQL A1, ZERO, 0x9D00BF04
9D00BEEC  008A2023   SUBU A0, A0, T2
9D00BEF0  00882021   ADDU A0, A0, T0
9D00BEF4  0088282B   SLTU A1, A0, T0
9D00BEF8  10A00024   BEQ A1, ZERO, 0x9D00BF8C
9D00BEFC  008A282B   SLTU A1, A0, T2
9D00BF00  008A2023   SUBU A0, A0, T2
9D00BF04  0083001B   DIVU A0, V1
9D00BF08  006001F4   TEQ V1, ZERO
9D00BF0C  316BFFFF   ANDI T3, T3, -1
9D00BF10  00003012   MFLO A2, 0
9D00BF14  00002810   MFHI A1, 0
9D00BF18  00052C00   SLL A1, A1, 16
9D00BF1C  00AB2825   OR A1, A1, T3
9D00BF20  70C73002   MUL A2, A2, A3
9D00BF24  00A6502B   SLTU T2, A1, A2
9D00BF28  0083001B   DIVU A0, V1
9D00BF2C  006001F4   TEQ V1, ZERO
9D00BF30  5140FF61   BEQL T2, ZERO, 0x9D00BCB8
9D00BF34  00A62823   SUBU A1, A1, A2
9D00BF38  00A82821   ADDU A1, A1, T0
9D00BF3C  00A8202B   SLTU A0, A1, T0
9D00BF40  5480FF5D   BNEL A0, ZERO, 0x9D00BCB8
9D00BF44  00A62823   SUBU A1, A1, A2
9D00BF48  00A6202B   SLTU A0, A1, A2
9D00BF4C  70885002   MUL T2, A0, T0
9D00BF50  01452821   ADDU A1, T2, A1
9D00BF54  0B402F2E   J 0x9D00BCB8
9D00BF58  00A62823   SUBU A1, A1, A2
9D00BF8C  70A83002   MUL A2, A1, T0
9D00BF90  0B402FC0   J 0x9D00BF00
9D00BF94  00C42021   ADDU A0, A2, A0
9D00C2E8  00023C02   SRL A3, V0, 16
9D00C2EC  0147001B   DIVU T2, A3
9D00C2F0  00E001F4   TEQ A3, ZERO
9D00C2FC  304CFFFF   ANDI T4, V0, -1
9D00C308  00054C02   SRL T1, A1, 16
9D00C30C  00001812   MFLO V1, 0
9D00C310  00005810   MFHI T3, 0
9D00C314  000B2400   SLL A0, T3, 16
9D00C318  01242025   OR A0, T1, A0
9D00C31C  00003012   MFLO A2, 0
9D00C320  706C1802   MUL V1, V1, T4
9D00C324  0083482B   SLTU T1, A0, V1
9D00C328  0147001B   DIVU T2, A3
9D00C32C  00E001F4   TEQ A3, ZERO
9D00C330  5120000B   BEQL T1, ZERO, 0x9D00C360
9D00C334  00832023   SUBU A0, A0, V1
9D00C338  00822021   ADDU A0, A0, V0
9D00C33C  0082482B   SLTU T1, A0, V0
9D00C340  15200006   BNE T1, ZERO, 0x9D00C35C
9D00C344  24C6FFFF   ADDIU A2, A2, -1
9D00C348  0083482B   SLTU T1, A0, V1
9D00C34C  51200004   BEQL T1, ZERO, 0x9D00C360
9D00C350  00832023   SUBU A0, A0, V1
9D00C354  24C6FFFF   ADDIU A2, A2, -1
9D00C358  00822021   ADDU A0, A0, V0
9D00C35C  00832023   SUBU A0, A0, V1
9D00C360  0087001B   DIVU A0, A3
9D00C364  00E001F4   TEQ A3, ZERO
9D00C368  30AAFFFF   ANDI T2, A1, -1
9D00C36C  00001812   MFLO V1, 0
9D00C370  00004810   MFHI T1, 0
9D00C374  00094C00   SLL T1, T1, 16
9D00C378  012A4825   OR T1, T1, T2
9D00C37C  706C2802   MUL A1, V1, T4
9D00C380  0125502B   SLTU T2, T1, A1
9D00C384  0087001B   DIVU A0, A3
9D00C388  00E001F4   TEQ A3, ZERO
9D00C38C  5140000B   BEQL T2, ZERO, 0x9D00C3BC
9D00C390  00063400   SLL A2, A2, 16
9D00C394  01224821   ADDU T1, T1, V0
9D00C398  0122202B   SLTU A0, T1, V0
9D00C39C  14800006   BNE A0, ZERO, 0x9D00C3B8
9D00C3A0  2463FFFF   ADDIU V1, V1, -1
9D00C3A4  0125202B   SLTU A0, T1, A1
9D00C3A8  50800004   BEQL A0, ZERO, 0x9D00C3BC
9D00C3AC  00063400   SLL A2, A2, 16
9D00C3B0  2463FFFF   ADDIU V1, V1, -1
9D00C3B4  01224821   ADDU T1, T1, V0
9D00C3B8  00063400   SLL A2, A2, 16
9D00C3BC  01254823   SUBU T1, T1, A1
9D00C3C0  0B403045   J 0x9D00C114
9D00C3C4  00661825   OR V1, V1, A2
9D00AEF4  00A3001B   DIVU A1, V1
9D00AEF8  006001F4   TEQ V1, ZERO
9D00AEFC  00096402   SRL T4, T1, 16
9D00AF00  00005812   MFLO T3, 0
9D00AF04  00002010   MFHI A0, 0
9D00AF08  00042400   SLL A0, A0, 16
9D00AF0C  008C2025   OR A0, A0, T4
9D00AF10  71675802   MUL T3, T3, A3
9D00AF14  008B602B   SLTU T4, A0, T3
9D00AF18  00A3001B   DIVU A1, V1
9D00AF1C  006001F4   TEQ V1, ZERO
9D00AF20  51800009   BEQL T4, ZERO, 0x9D00AF48
9D00AF24  008B2023   SUBU A0, A0, T3
9D00AF28  00822021   ADDU A0, A0, V0
9D00AF2C  0082282B   SLTU A1, A0, V0
9D00AF30  54A00005   BNEL A1, ZERO, 0x9D00AF48
9D00AF34  008B2023   SUBU A0, A0, T3
9D00AF38  008B282B   SLTU A1, A0, T3
9D00AF3C  70A26002   MUL T4, A1, V0
9D00AF40  01842021   ADDU A0, T4, A0
9D00AF44  008B2023   SUBU A0, A0, T3
9D00AF48  0083001B   DIVU A0, V1
9D00AF4C  006001F4   TEQ V1, ZERO
9D00AF50  3129FFFF   ANDI T1, T1, -1
9D00AF54  00006012   MFLO T4, 0
9D00AF58  00002810   MFHI A1, 0
9D00AF5C  00052C00   SLL A1, A1, 16
9D00AF60  00A94825   OR T1, A1, T1
9D00AF64  71873802   MUL A3, T4, A3
9D00AF68  0127282B   SLTU A1, T1, A3
9D00AF6C  0083001B   DIVU A0, V1
9D00AF70  006001F4   TEQ V1, ZERO
9D00AF74  50A0FFA2   BEQL A1, ZERO, 0x9D00AE00
9D00AF78  01274823   SUBU T1, T1, A3
9D00AF7C  01224821   ADDU T1, T1, V0
9D00AF80  0122182B   SLTU V1, T1, V0
9D00AF84  5460FF9E   BNEL V1, ZERO, 0x9D00AE00
9D00AF88  01274823   SUBU T1, T1, A3
9D00AF8C  0127182B   SLTU V1, T1, A3
9D00AF90  70622002   MUL A0, V1, V0
9D00AF94  00894821   ADDU T1, A0, T1
9D00AF98  0B402B80   J 0x9D00AE00
9D00AF9C  01274823   SUBU T1, T1, A3
9D00B880  0167001B   DIVU T3, A3
9D00B884  00E001F4   TEQ A3, ZERO
9D00B888  00091C02   SRL V1, T1, 16
9D00B88C  00006012   MFLO T4, 0
9D00B890  00005010   MFHI T2, 0
9D00B894  000A5400   SLL T2, T2, 16
9D00B898  01435025   OR T2, T2, V1
9D00B89C  718D2002   MUL A0, T4, T5
9D00B8A0  0144182B   SLTU V1, T2, A0
9D00B8A4  0167001B   DIVU T3, A3
9D00B8A8  00E001F4   TEQ A3, ZERO
9D00B8AC  50600009   BEQL V1, ZERO, 0x9D00B8D4
9D00B8B0  01445023   SUBU T2, T2, A0
9D00B8B4  01425021   ADDU T2, T2, V0
9D00B8B8  0142182B   SLTU V1, T2, V0
9D00B8BC  14600004   BNE V1, ZERO, 0x9D00B8D0
9D00B8C0  258CFFFF   ADDIU T4, T4, -1
9D00B8C4  0144182B   SLTU V1, T2, A0
9D00B8C8  5460009F   BNEL V1, ZERO, 0x9D00BB48
9D00B8CC  258CFFFF   ADDIU T4, T4, -1
9D00B8D0  01445023   SUBU T2, T2, A0
9D00B8D4  0147001B   DIVU T2, A3
9D00B8D8  00E001F4   TEQ A3, ZERO
9D00B8DC  3129FFFF   ANDI T1, T1, -1
9D00B8E0  00002012   MFLO A0, 0
9D00B8E4  00001810   MFHI V1, 0
9D00B8E8  00031C00   SLL V1, V1, 16
9D00B8EC  00694825   OR T1, V1, T1
9D00B8F0  708D6802   MUL T5, A0, T5
9D00B8F4  012D182B   SLTU V1, T1, T5
9D00B8F8  0147001B   DIVU T2, A3
9D00B8FC  00E001F4   TEQ A3, ZERO
9D00B900  50600008   BEQL V1, ZERO, 0x9D00B924
9D00B904  000C6400   SLL T4, T4, 16
9D00B908  01224821   ADDU T1, T1, V0
9D00B90C  0122102B   SLTU V0, T1, V0
9D00B910  14400003   BNE V0, ZERO, 0x9D00B920
9D00B914  2484FFFF   ADDIU A0, A0, -1
9D00B918  012D682B   SLTU T5, T1, T5
9D00B91C  008D2023   SUBU A0, A0, T5
9D00B920  000C6400   SLL T4, T4, 16
9D00B924  0B402DF7   J 0x9D00B7DC
9D00B928  008C2025   OR A0, A0, T4
9D00BB48  0B402E34   J 0x9D00B8D0
9D00BB4C  01425021   ADDU T2, T2, V0
9D00BCB8  00A3001B   DIVU A1, V1
9D00BCBC  006001F4   TEQ V1, ZERO
9D00BCC0  00095402   SRL T2, T1, 16
9D00BCC4  00002012   MFLO A0, 0
9D00BCC8  00003010   MFHI A2, 0
9D00BCCC  00063400   SLL A2, A2, 16
9D00BCD0  00CA3025   OR A2, A2, T2
9D00BCD4  70872002   MUL A0, A0, A3
9D00BCD8  00C4502B   SLTU T2, A2, A0
9D00BCDC  00A3001B   DIVU A1, V1
9D00BCE0  006001F4   TEQ V1, ZERO
9D00BCE4  51400009   BEQL T2, ZERO, 0x9D00BD0C
9D00BCE8  00C43023   SUBU A2, A2, A0
9D00BCEC  00C83021   ADDU A2, A2, T0
9D00BCF0  00C8282B   SLTU A1, A2, T0
9D00BCF4  54A00005   BNEL A1, ZERO, 0x9D00BD0C
9D00BCF8  00C43023   SUBU A2, A2, A0
9D00BCFC  00C4282B   SLTU A1, A2, A0
9D00BD00  70A85002   MUL T2, A1, T0
9D00BD04  01463021   ADDU A2, T2, A2
9D00BD08  00C43023   SUBU A2, A2, A0
9D00BD0C  00C3001B   DIVU A2, V1
9D00BD10  006001F4   TEQ V1, ZERO
9D00BD14  3129FFFF   ANDI T1, T1, -1
9D00BD18  00005012   MFLO T2, 0
9D00BD1C  00002010   MFHI A0, 0
9D00BD20  00042400   SLL A0, A0, 16
9D00BD24  00894825   OR T1, A0, T1
9D00BD28  71473802   MUL A3, T2, A3
9D00BD2C  0127202B   SLTU A0, T1, A3
9D00BD30  00C3001B   DIVU A2, V1
9D00BD34  006001F4   TEQ V1, ZERO
9D00BD38  50800009   BEQL A0, ZERO, 0x9D00BD60
9D00BD3C  01274823   SUBU T1, T1, A3
9D00BD40  01284821   ADDU T1, T1, T0
9D00BD44  0128182B   SLTU V1, T1, T0
9D00BD48  54600005   BNEL V1, ZERO, 0x9D00BD60
9D00BD4C  01274823   SUBU T1, T1, A3
9D00BD50  0127182B   SLTU V1, T1, A3
9D00BD54  70682002   MUL A0, V1, T0
9D00BD58  00894821   ADDU T1, A0, T1
9D00BD5C  01274823   SUBU T1, T1, A3
9D00C114  0127001B   DIVU T1, A3
9D00C118  00E001F4   TEQ A3, ZERO
9D00C11C  00086C02   SRL T5, T0, 16
9D00C120  00005812   MFLO T3, 0
9D00C124  00005010   MFHI T2, 0
9D00C128  000A5400   SLL T2, T2, 16
9D00C12C  014D5025   OR T2, T2, T5
9D00C130  716C2002   MUL A0, T3, T4
9D00C134  0144302B   SLTU A2, T2, A0
9D00C138  0127001B   DIVU T1, A3
9D00C13C  00E001F4   TEQ A3, ZERO
9D00C140  10C00009   BEQ A2, ZERO, 0x9D00C168
9D00C144  01442823   SUBU A1, T2, A0
9D00C148  01425021   ADDU T2, T2, V0
9D00C14C  0142282B   SLTU A1, T2, V0
9D00C150  14A00004   BNE A1, ZERO, 0x9D00C164
9D00C154  256BFFFF   ADDIU T3, T3, -1
9D00C158  0144282B   SLTU A1, T2, A0
9D00C15C  54A000A2   BNEL A1, ZERO, 0x9D00C3E8
9D00C160  256BFFFF   ADDIU T3, T3, -1
9D00C164  01442823   SUBU A1, T2, A0
9D00C168  00A7001B   DIVU A1, A3
9D00C16C  00E001F4   TEQ A3, ZERO
9D00C170  3108FFFF   ANDI T0, T0, -1
9D00C174  00002012   MFLO A0, 0
9D00C178  00003010   MFHI A2, 0
9D00C17C  00063400   SLL A2, A2, 16
9D00C180  00C84025   OR T0, A2, T0
9D00C184  708C6002   MUL T4, A0, T4
9D00C188  010C302B   SLTU A2, T0, T4
9D00C18C  00A7001B   DIVU A1, A3
9D00C190  00E001F4   TEQ A3, ZERO
9D00C194  10C00006   BEQ A2, ZERO, 0x9D00C1B0
9D00C198  01024021   ADDU T0, T0, V0
9D00C19C  0102102B   SLTU V0, T0, V0
9D00C1A0  14400003   BNE V0, ZERO, 0x9D00C1B0
9D00C1A4  2484FFFF   ADDIU A0, A0, -1
9D00C1A8  010C602B   SLTU T4, T0, T4
9D00C1AC  008C2023   SUBU A0, A0, T4
9D00C1B0  000B5C00   SLL T3, T3, 16
9D00C1B4  008B2025   OR A0, A0, T3
9D00C3E8  0B403059   J 0x9D00C164
9D00C3EC  01425021   ADDU T2, T2, V0
9D00AE00  00C93006   SRLV A2, T1, A2
9D00BC3C  00491006   SRLV V0, T1, V0
9D00BD60  00491006   SRLV V0, T1, V0
9D00AE04  AD060000   SW A2, 0(T0)
9D00AE08  AD000004   SW ZERO, 4(T0)
9D00BC40  03E00008   JR RA
9D00BC44  00001821   ADDU V1, ZERO, ZERO
9D00BD64  03E00008   JR RA
9D00BD68  00001821   ADDU V1, ZERO, ZERO
9D00AE34  00A7102B   SLTU V0, A1, A3
9D00AE38  10400013   BEQ V0, ZERO, 0x9D00AE88
9D00AE3C  70E94820   CLZ T1, A3
9D00B7C8  00A7102B   SLTU V0, A1, A3
9D00B7CC  50400017   BEQL V0, ZERO, 0x9D00B82C
9D00B7D0  70E31820   CLZ V1, A3
9D00B7D4  00002821   ADDU A1, ZERO, ZERO
9D00B7D8  00002021   ADDU A0, ZERO, ZERO
9D00BC48  00A7102B   SLTU V0, A1, A3
9D00BC4C  14400047   BNE V0, ZERO, 0x9D00BD6C
9D00BC50  70E84020   CLZ T0, A3
9D00C0B0  00A7102B   SLTU V0, A1, A3
9D00C0B4  54400042   BNEL V0, ZERO, 0x9D00C1C0
9D00C0B8  00002021   ADDU A0, ZERO, ZERO
9D00C1C0  00001821   ADDU V1, ZERO, ZERO
9D00AE40  AFA40000   SW A0, 0(SP)
9D00BD6C  00801021   ADDU V0, A0, ZERO
9D00BD70  03E00008   JR RA
9D00BD74  00A01821   ADDU V1, A1, ZERO
9D00C0BC  70E31820   CLZ V1, A3
9D00AE88  55200076   BNEL T1, ZERO, 0x9D00B064
9D00AE8C  24030020   ADDIU V1, ZERO, 32
9D00B82C  1460007A   BNE V1, ZERO, 0x9D00BA18
9D00B830  240C0020   ADDIU T4, ZERO, 32
9D00BC54  15000048   BNE T0, ZERO, 0x9D00BD78
9D00BC58  240A0020   ADDIU T2, ZERO, 32
9D00C0C0  14600042   BNE V1, ZERO, 0x9D00C1CC
9D00C0C4  240B0020   ADDIU T3, ZERO, 32
9D00AE90  00E5102B   SLTU V0, A3, A1
9D00AE94  14400005   BNE V0, ZERO, 0x9D00AEAC
9D00AE98  00864823   SUBU T1, A0, A2
9D00AE9C  0086102B   SLTU V0, A0, A2
9D00AEA0  14400005   BNE V0, ZERO, 0x9D00AEB8
9D00AEA4  00804821   ADDU T1, A0, ZERO
9D00B834  00E5282B   SLTU A1, A3, A1
9D00B838  54A000C1   BNEL A1, ZERO, 0x9D00BB40
9D00B83C  00002821   ADDU A1, ZERO, ZERO
9D00B840  0086202B   SLTU A0, A0, A2
9D00B844  0B402DF7   J 0x9D00B7DC
9D00B848  2C840001   SLTIU A0, A0, 1
9D00BB40  0B402DF7   J 0x9D00B7DC
9D00BB44  24040001   ADDIU A0, ZERO, 1
9D00BC5C  00E5102B   SLTU V0, A3, A1
9D00BC60  14400005   BNE V0, ZERO, 0x9D00BC78
9D00BC64  00861023   SUBU V0, A0, A2
9D00BC68  0086402B   SLTU T0, A0, A2
9D00BC6C  15000088   BNE T0, ZERO, 0x9D00BE90
9D00BC70  00801021   ADDU V0, A0, ZERO
9D00C0C8  00E5282B   SLTU A1, A3, A1
9D00C0CC  54A000C4   BNEL A1, ZERO, 0x9D00C3E0
9D00C0D0  00001821   ADDU V1, ZERO, ZERO
9D00C0D4  0086202B   SLTU A0, A0, A2
9D00C0D8  0B40302A   J 0x9D00C0A8
9D00C0DC  2C840001   SLTIU A0, A0, 1
9D00C3E0  0B40302A   J 0x9D00C0A8
9D00C3E4  24040001   ADDIU A0, ZERO, 1
9D00AEA8  00864823   SUBU T1, A0, A2
9D00AEAC  00A72823   SUBU A1, A1, A3
9D00AEB0  0089202B   SLTU A0, A0, T1
9D00AEB4  00A41823   SUBU V1, A1, A0
9D00BC74  00861023   SUBU V0, A0, A2
9D00BC78  00A71823   SUBU V1, A1, A3
9D00BC7C  0082202B   SLTU A0, A0, V0
9D00BC80  03E00008   JR RA
9D00BC84  00641823   SUBU V1, V1, A0
9D00AEB8  AD090000   SW T1, 0(T0)
9D00AEBC  0B402B83   J 0x9D00AE0C
9D00AEC0  AD030004   SW V1, 4(T0)
9D00B064  00691823   SUBU V1, V1, T1
9D00BA18  01836023   SUBU T4, T4, V1
9D00BD78  01485023   SUBU T2, T2, T0
9D00C1CC  01635823   SUBU T3, T3, V1
9D00B068  00661006   SRLV V0, A2, V1
9D00B06C  01273804   SLLV A3, A3, T1
9D00B070  00473825   OR A3, V0, A3
9D00BA1C  01861006   SRLV V0, A2, T4
9D00BA20  00673804   SLLV A3, A3, V1
9D00BA24  00473825   OR A3, V0, A3
9D00BD7C  01461006   SRLV V0, A2, T2
9D00BD80  01073804   SLLV A3, A3, T0
9D00BD84  00473825   OR A3, V0, A3
9D00C1D0  01661006   SRLV V0, A2, T3
9D00C1D4  00673804   SLLV A3, A3, V1
9D00C1D8  00473825   OR A3, V0, A3
9D00B098  0126C004   SLLV T8, A2, T1
9D00BDAC  01063004   SLLV A2, A2, T0
9D00B074  00656006   SRLV T4, A1, V1
9D00BA28  01855006   SRLV T2, A1, T4
9D00BD88  01455806   SRLV T3, A1, T2
9D00C1DC  01654806   SRLV T1, A1, T3
9D00B084  00647806   SRLV T7, A0, V1
9D00B08C  01252804   SLLV A1, A1, T1
9D00B090  01E52825   OR A1, T7, A1
9D00BA3C  01846006   SRLV T4, A0, T4
9D00BA40  00652804   SLLV A1, A1, V1
9D00BA44  01852825   OR A1, T4, A1
9D00BD9C  01441806   SRLV V1, A0, T2
9D00BDA0  01052804   SLLV A1, A1, T0
9D00BDA4  00652825   OR A1, V1, A1
9D00C1F0  01645806   SRLV T3, A0, T3
9D00C1F4  00652804   SLLV A1, A1, V1
9D00C1F8  01652825   OR A1, T3, A1
9D00B078  00071402   SRL V0, A3, 16
9D00B07C  0182001B   DIVU T4, V0
9D00B080  004001F4   TEQ V0, ZERO
9D00B088  30EEFFFF   ANDI T6, A3, -1
9D00B094  0005CC02   SRL T9, A1, 16
9D00B09C  00006812   MFLO T5, 0
9D00B0A0  00005810   MFHI T3, 0
9D00B0A4  000B5C00   SLL T3, T3, 16
9D00B0A8  01795825   OR T3, T3, T9
9D00B0AC  71AE7802   MUL T7, T5, T6
9D00B0B0  016F302B   SLTU A2, T3, T7
9D00B0B4  0182001B   DIVU T4, V0
9D00B0B8  004001F4   TEQ V0, ZERO
9D00B0BC  10C0000A   BEQ A2, ZERO, 0x9D00B0E8
9D00B0C0  01242004   SLLV A0, A0, T1
9D00B0C4  01675821   ADDU T3, T3, A3
9D00B0C8  0167302B   SLTU A2, T3, A3
9D00B0CC  14C00006   BNE A2, ZERO, 0x9D00B0E8
9D00B0D0  25ADFFFF   ADDIU T5, T5, -1
9D00B0D4  016F302B   SLTU A2, T3, T7
9D00B0D8  50C00004   BEQL A2, ZERO, 0x9D00B0EC
9D00B0DC  016F5823   SUBU T3, T3, T7
9D00B0E0  25ADFFFF   ADDIU T5, T5, -1
9D00B0E4  01675821   ADDU T3, T3, A3
9D00B0E8  016F5823   SUBU T3, T3, T7
9D00B0EC  0162001B   DIVU T3, V0
9D00B0F0  004001F4   TEQ V0, ZERO
9D00B0F4  30A5FFFF   ANDI A1, A1, -1
9D00B0F8  00006012   MFLO T4, 0
9D00B0FC  00003010   MFHI A2, 0
9D00B100  00063400   SLL A2, A2, 16
9D00B104  00C52825   OR A1, A2, A1
9D00B108  718E7002   MUL T6, T4, T6
9D00B10C  00AE302B   SLTU A2, A1, T6
9D00B110  0162001B   DIVU T3, V0
9D00B114  004001F4   TEQ V0, ZERO
9D00B118  50C0000B   BEQL A2, ZERO, 0x9D00B148
9D00B11C  000D6C00   SLL T5, T5, 16
9D00B120  00A72821   ADDU A1, A1, A3
9D00B124  00A7102B   SLTU V0, A1, A3
9D00B128  14400006   BNE V0, ZERO, 0x9D00B144
9D00B12C  258CFFFF   ADDIU T4, T4, -1
9D00B130  00AE102B   SLTU V0, A1, T6
9D00B134  50400004   BEQL V0, ZERO, 0x9D00B148
9D00B138  000D6C00   SLL T5, T5, 16
9D00B13C  258CFFFF   ADDIU T4, T4, -1
9D00B140  00A72821   ADDU A1, A1, A3
9D00B144  000D6C00   SLL T5, T5, 16
9D00B148  018D6025   OR T4, T4, T5
9D00B150  00AE2823   SUBU A1, A1, T6
9D00BA2C  00071402   SRL V0, A3, 16
9D00BA30  0142001B   DIVU T2, V0
9D00BA34  004001F4   TEQ V0, ZERO
9D00BA38  30EDFFFF   ANDI T5, A3, -1
9D00BA48  00056402   SRL T4, A1, 16
9D00BA4C  00005812   MFLO T3, 0
9D00BA50  00004810   MFHI T1, 0
9D00BA54  00094C00   SLL T1, T1, 16
9D00BA58  012C4825   OR T1, T1, T4
9D00BA5C  716D7002   MUL T6, T3, T5
9D00BA60  012E602B   SLTU T4, T1, T6
9D00BA64  0142001B   DIVU T2, V0
9D00BA68  004001F4   TEQ V0, ZERO
9D00BA6C  1180000A   BEQ T4, ZERO, 0x9D00BA98
9D00BA70  00663004   SLLV A2, A2, V1
9D00BA74  01274821   ADDU T1, T1, A3
9D00BA78  0127502B   SLTU T2, T1, A3
9D00BA7C  15400006   BNE T2, ZERO, 0x9D00BA98
9D00BA80  256BFFFF   ADDIU T3, T3, -1
9D00BA84  012E502B   SLTU T2, T1, T6
9D00BA88  51400004   BEQL T2, ZERO, 0x9D00BA9C
9D00BA8C  012E4823   SUBU T1, T1, T6
9D00BA90  256BFFFF   ADDIU T3, T3, -1
9D00BA94  01274821   ADDU T1, T1, A3
9D00BA98  012E4823   SUBU T1, T1, T6
9D00BA9C  0122001B   DIVU T1, V0
9D00BAA0  004001F4   TEQ V0, ZERO
9D00BAA4  30A5FFFF   ANDI A1, A1, -1
9D00BAA8  00005012   MFLO T2, 0
9D00BAAC  00006010   MFHI T4, 0
9D00BAB0  000C6400   SLL T4, T4, 16
9D00BAB4  01852825   OR A1, T4, A1
9D00BAB8  714D6802   MUL T5, T2, T5
9D00BABC  00AD602B   SLTU T4, A1, T5
9D00BAC0  0122001B   DIVU T1, V0
9D00BAC4  004001F4   TEQ V0, ZERO
9D00BAC8  5180000B   BEQL T4, ZERO, 0x9D00BAF8
9D00BACC  000B5C00   SLL T3, T3, 16
9D00BAD0  00A72821   ADDU A1, A1, A3
9D00BAD4  00A7102B   SLTU V0, A1, A3
9D00BAD8  14400006   BNE V0, ZERO, 0x9D00BAF4
9D00BADC  254AFFFF   ADDIU T2, T2, -1
9D00BAE0  00AD102B   SLTU V0, A1, T5
9D00BAE4  50400004   BEQL V0, ZERO, 0x9D00BAF8
9D00BAE8  000B5C00   SLL T3, T3, 16
9D00BAEC  254AFFFF   ADDIU T2, T2, -1
9D00BAF0  00A72821   ADDU A1, A1, A3
9D00BAF4  000B5C00   SLL T3, T3, 16
9D00BAF8  014B5025   OR T2, T2, T3
9D00BB00  00AD2823   SUBU A1, A1, T5
9D00BD8C  00074C02   SRL T1, A3, 16
9D00BD90  0169001B   DIVU T3, T1
9D00BD94  012001F4   TEQ T1, ZERO
9D00BD98  30EDFFFF   ANDI T5, A3, -1
9D00BDA8  00051C02   SRL V1, A1, 16
9D00BDB0  00006012   MFLO T4, 0
9D00BDB4  00001010   MFHI V0, 0
9D00BDB8  00021400   SLL V0, V0, 16
9D00BDBC  00431025   OR V0, V0, V1
9D00BDC0  718D7002   MUL T6, T4, T5
9D00BDC4  004E182B   SLTU V1, V0, T6
9D00BDC8  0169001B   DIVU T3, T1
9D00BDCC  012001F4   TEQ T1, ZERO
9D00BDD0  1060000A   BEQ V1, ZERO, 0x9D00BDFC
9D00BDD4  01042004   SLLV A0, A0, T0
9D00BDD8  00471021   ADDU V0, V0, A3
9D00BDDC  0047182B   SLTU V1, V0, A3
9D00BDE0  14600006   BNE V1, ZERO, 0x9D00BDFC
9D00BDE4  258CFFFF   ADDIU T4, T4, -1
9D00BDE8  004E182B   SLTU V1, V0, T6
9D00BDEC  50600004   BEQL V1, ZERO, 0x9D00BE00
9D00BDF0  004E1023   SUBU V0, V0, T6
9D00BDF4  258CFFFF   ADDIU T4, T4, -1
9D00BDF8  00471021   ADDU V0, V0, A3
9D00BDFC  004E1023   SUBU V0, V0, T6
9D00BE00  0049001B   DIVU V0, T1
9D00BE04  012001F4   TEQ T1, ZERO
9D00BE08  30A5FFFF   ANDI A1, A1, -1
9D00BE0C  00005812   MFLO T3, 0
9D00BE10  00001810   MFHI V1, 0
9D00BE14  00031C00   SLL V1, V1, 16
9D00BE18  00652825   OR A1, V1, A1
9D00BE1C  716D6802   MUL T5, T3, T5
9D00BE20  00AD182B   SLTU V1, A1, T5
9D00BE24  0049001B   DIVU V0, T1
9D00BE28  012001F4   TEQ T1, ZERO
9D00BE2C  50600006   BEQL V1, ZERO, 0x9D00BE48
9D00BE30  000C6400   SLL T4, T4, 16
9D00BE34  00A72821   ADDU A1, A1, A3
9D00BE38  00A7102B   SLTU V0, A1, A3
9D00BE3C  1040004D   BEQ V0, ZERO, 0x9D00BF74
9D00BE40  256BFFFF   ADDIU T3, T3, -1
9D00BE44  000C6400   SLL T4, T4, 16
9D00BE48  016C5825   OR T3, T3, T4
9D00BE50  00AD2823   SUBU A1, A1, T5
9D00BF74  00AD102B   SLTU V0, A1, T5
9D00BF78  5040FFB3   BEQL V0, ZERO, 0x9D00BE48
9D00BF7C  000C6400   SLL T4, T4, 16
9D00BF80  256BFFFF   ADDIU T3, T3, -1
9D00BF84  0B402F91   J 0x9D00BE44
9D00BF88  00A72821   ADDU A1, A1, A3
9D00C1E0  00071402   SRL V0, A3, 16
9D00C1E4  0122001B   DIVU T1, V0
9D00C1E8  004001F4   TEQ V0, ZERO
9D00C1EC  30ECFFFF   ANDI T4, A3, -1
9D00C1FC  00055C02   SRL T3, A1, 16
9D00C200  00005012   MFLO T2, 0
9D00C204  00004010   MFHI T0, 0
9D00C208  00084400   SLL T0, T0, 16
9D00C20C  010B4025   OR T0, T0, T3
9D00C210  714C6802   MUL T5, T2, T4
9D00C214  010D582B   SLTU T3, T0, T5
9D00C218  0122001B   DIVU T1, V0
9D00C21C  004001F4   TEQ V0, ZERO
9D00C220  1160000A   BEQ T3, ZERO, 0x9D00C24C
9D00C224  00663004   SLLV A2, A2, V1
9D00C228  01074021   ADDU T0, T0, A3
9D00C22C  0107482B   SLTU T1, T0, A3
9D00C230  15200006   BNE T1, ZERO, 0x9D00C24C
9D00C234  254AFFFF   ADDIU T2, T2, -1
9D00C238  010D482B   SLTU T1, T0, T5
9D00C23C  51200004   BEQL T1, ZERO, 0x9D00C250
9D00C240  010D4023   SUBU T0, T0, T5
9D00C244  254AFFFF   ADDIU T2, T2, -1
9D00C248  01074021   ADDU T0, T0, A3
9D00C24C  010D4023   SUBU T0, T0, T5
9D00C250  0102001B   DIVU T0, V0
9D00C254  004001F4   TEQ V0, ZERO
9D00C258  30A5FFFF   ANDI A1, A1, -1
9D00C25C  00004812   MFLO T1, 0
9D00C260  00005810   MFHI T3, 0
9D00C264  000B5C00   SLL T3, T3, 16
9D00C268  01652825   OR A1, T3, A1
9D00C26C  712C6002   MUL T4, T1, T4
9D00C270  00AC582B   SLTU T3, A1, T4
9D00C274  0102001B   DIVU T0, V0
9D00C278  004001F4   TEQ V0, ZERO
9D00C27C  5160000B   BEQL T3, ZERO, 0x9D00C2AC
9D00C280  000A5400   SLL T2, T2, 16
9D00C284  00A72821   ADDU A1, A1, A3
9D00C288  00A7102B   SLTU V0, A1, A3
9D00C28C  14400006   BNE V0, ZERO, 0x9D00C2A8
9D00C290  2529FFFF   ADDIU T1, T1, -1
9D00C294  00AC102B   SLTU V0, A1, T4
9D00C298  50400004   BEQL V0, ZERO, 0x9D00C2AC
9D00C29C  000A5400   SLL T2, T2, 16
9D00C2A0  2529FFFF   ADDIU T1, T1, -1
9D00C2A4  00A72821   ADDU A1, A1, A3
9D00C2A8  000A5400   SLL T2, T2, 16
9D00C2AC  012A4825   OR T1, T1, T2
9D00C2B4  00AC2823   SUBU A1, A1, T4
9D00B14C  01980019   MULTU 0, T4, T8
9D00B154  00006810   MFHI T5, 0
9D00B15C  01A07821   ADDU T7, T5, ZERO
9D00B174  0B402C64   J 0x9D00B190
9D00B178  0000C012   MFLO T8, 0
9D00BAFC  01460019   MULTU 0, T2, A2
9D00BB04  00007810   MFHI T7, 0
9D00BE4C  01660019   MULTU 0, T3, A2
9D00BE54  0000C810   MFHI T9, 0
9D00BE5C  03207021   ADDU T6, T9, ZERO
9D00BE70  00001012   MFLO V0, 0
9D00C2B0  01260019   MULTU 0, T1, A2
9D00C2B8  00005810   MFHI T3, 0
9D00B158  00AD702B   SLTU T6, A1, T5
9D00B160  15C00006   BNE T6, ZERO, 0x9D00B17C
9D00B164  00005812   MFLO T3, 0
9D00B168  10AD0016   BEQ A1, T5, 0x9D00B1C4
9D00B16C  008B102B   SLTU V0, A0, T3
9D00B170  00AD2823   SUBU A1, A1, T5
9D00B1C4  5440FFEE   BNEL V0, ZERO, 0x9D00B180
9D00B1C8  0178C023   SUBU T8, T3, T8
9D00B1CC  0000C012   MFLO T8, 0
9D00B1D0  0B402C64   J 0x9D00B190
9D00B1D4  00002821   ADDU A1, ZERO, ZERO
9D00BB08  00AF382B   SLTU A3, A1, T7
9D00BB0C  14E00009   BNE A3, ZERO, 0x9D00BB34
9D00BB10  00007012   MFLO T6, 0
9D00BB14  50AF0004   BEQL A1, T7, 0x9D00BB28
9D00BB18  00641804   SLLV V1, A0, V1
9D00BB1C  01402021   ADDU A0, T2, ZERO
9D00BB20  0B402DF7   J 0x9D00B7DC
9D00BB24  00002821   ADDU A1, ZERO, ZERO
9D00BB28  006E182B   SLTU V1, V1, T6
9D00BB2C  5060FFFC   BEQL V1, ZERO, 0x9D00BB20
9D00BB30  01402021   ADDU A0, T2, ZERO
9D00BE58  00B9682B   SLTU T5, A1, T9
9D00BE60  15A0003E   BNE T5, ZERO, 0x9D00BF5C
9D00BE64  00004812   MFLO T1, 0
9D00BE68  10B9004B   BEQ A1, T9, 0x9D00BF98
9D00BE6C  00B91823   SUBU V1, A1, T9
9D00BF98  0089182B   SLTU V1, A0, T1
9D00BF9C  5460FFF0   BNEL V1, ZERO, 0x9D00BF60
9D00BFA0  01261023   SUBU V0, T1, A2
9D00BFA4  00001012   MFLO V0, 0
9D00BFA8  0B402F9D   J 0x9D00BE74
9D00BFAC  00001821   ADDU V1, ZERO, ZERO
9D00C2BC  00AB382B   SLTU A3, A1, T3
9D00C2C0  14E00044   BNE A3, ZERO, 0x9D00C3D4
9D00C2C4  00005012   MFLO T2, 0
9D00C2C8  50AB003F   BEQL A1, T3, 0x9D00C3C8
9D00C2CC  00641804   SLLV V1, A0, V1
9D00C2D0  01202021   ADDU A0, T1, ZERO
9D00C2D4  0B40302A   J 0x9D00C0A8
9D00C2D8  00001821   ADDU V1, ZERO, ZERO
9D00C3C8  006A182B   SLTU V1, V1, T2
9D00C3CC  1060FF36   BEQ V1, ZERO, 0x9D00C0A8
9D00C3D0  01202021   ADDU A0, T1, ZERO
9D00BB34  2544FFFF   ADDIU A0, T2, -1
9D00BB38  0B402DF7   J 0x9D00B7DC
9D00BB3C  00002821   ADDU A1, ZERO, ZERO
9D00C3D4  2524FFFF   ADDIU A0, T1, -1
9D00C3D8  0B40302A   J 0x9D00C0A8
9D00C3DC  00001821   ADDU V1, ZERO, ZERO
9D00B17C  0178C023   SUBU T8, T3, T8
9D00B180  01E73823   SUBU A3, T7, A3
9D00B184  0178582B   SLTU T3, T3, T8
9D00B188  00EB1023   SUBU V0, A3, T3
9D00B18C  00A22823   SUBU A1, A1, V0
9D00BF5C  01261023   SUBU V0, T1, A2
9D00BF60  01C71823   SUBU V1, T6, A3
9D00BF64  0122482B   SLTU T1, T1, V0
9D00BF68  00691823   SUBU V1, V1, T1
9D00BF6C  0B402F9D   J 0x9D00BE74
9D00BF70  00A31823   SUBU V1, A1, V1
9D00B190  00983023   SUBU A2, A0, T8
9D00B194  0086202B   SLTU A0, A0, A2
9D00B198  00A42023   SUBU A0, A1, A0
9D00BE74  00821023   SUBU V0, A0, V0
9D00BE78  0082202B   SLTU A0, A0, V0
9D00BE7C  00641823   SUBU V1, V1, A0
9D00B19C  00641804   SLLV V1, A0, V1
9D00B1A0  01263006   SRLV A2, A2, T1
9D00B1A4  00C31825   OR V1, A2, V1
9D00BE80  01435004   SLLV T2, V1, T2
9D00BE84  01021006   SRLV V0, V0, T0
9D00B1A8  01242006   SRLV A0, A0, T1
9D00B1AC  AD030000   SW V1, 0(T0)
9D00B1B0  0B402B83   J 0x9D00AE0C
9D00B1B4  AD040004   SW A0, 4(T0)
9D00BE88  004A1025   OR V0, V0, T2
9D00BE8C  01031806   SRLV V1, V1, T0
9D00B7B4  00801021   ADDU V0, A0, ZERO
9D00B7DC  00801021   ADDU V0, A0, ZERO
9D00B6A8  04A00054   BLTZ A1, 0x9D00B7FC
9D00B6AC  00004021   ADDU T0, ZERO, ZERO
9D00B7FC  00042023   SUBU A0, ZERO, A0
9D00B800  0004102B   SLTU V0, ZERO, A0
9D00B804  00052823   SUBU A1, ZERO, A1
9D00B808  00A22823   SUBU A1, A1, V0
9D00B6B0  04E20059   BLTZL A3, 0x9D00B818
9D00B6B4  00063023   SUBU A2, ZERO, A2
9D00B80C  04E1FFAA   BGEZ A3, 0x9D00B6B8
9D00B810  2408FFFF   ADDIU T0, ZERO, -1
9D00B820  00084027   NOR T0, ZERO, T0
9D00B814  00063023   SUBU A2, ZERO, A2
9D00B818  0006182B   SLTU V1, ZERO, A2
9D00B81C  00073823   SUBU A3, ZERO, A3
9D00B824  0B402DAE   J 0x9D00B6B8
9D00B828  00E33823   SUBU A3, A3, V1
9D00B7B8  1500000B   BNE T0, ZERO, 0x9D00B7E8
9D00B7BC  00A01821   ADDU V1, A1, ZERO
9D00B7E0  1100FFF7   BEQ T0, ZERO, 0x9D00B7C0
9D00B7E4  00A01821   ADDU V1, A1, ZERO
9D00B7E8  00041023   SUBU V0, ZERO, A0
9D00B7EC  0002202B   SLTU A0, ZERO, V0
9D00B7F0  00051823   SUBU V1, ZERO, A1
9D00B7C0  03E00008   JR RA
9D00B7C4  00000000   NOP
9D00B7F4  03E00008   JR RA
9D00B7F8  00641823   SUBU V1, V1, A0
9D00ACFC  27BDFFF8   ADDIU SP, SP, -8
9D00AD00  04A00056   BLTZ A1, 0x9D00AE5C
9D00AD04  00005021   ADDU T2, ZERO, ZERO
9D00AE5C  00042023   SUBU A0, ZERO, A0
9D00AE60  0004102B   SLTU V0, ZERO, A0
9D00AE64  00052823   SUBU A1, ZERO, A1
9D00AE68  00A22823   SUBU A1, A1, V0
9D00AD08  04E2005B   BLTZL A3, 0x9D00AE78
9D00AD0C  00063023   SUBU A2, ZERO, A2
9D00AE6C  04E1FFA8   BGEZ A3, 0x9D00AD10
9D00AE70  240AFFFF   ADDIU T2, ZERO, -1
9D00AE74  00063023   SUBU A2, ZERO, A2
9D00AE78  0006182B   SLTU V1, ZERO, A2
9D00AE7C  00073823   SUBU A3, ZERO, A3
9D00AE80  0B402B44   J 0x9D00AD10
9D00AE84  00E33823   SUBU A3, A3, V1
9D00AD10  03A04021   ADDU T0, SP, ZERO
9D00AE0C  11400010   BEQ T2, ZERO, 0x9D00AE50
9D00AE10  8FA20000   LW V0, 0(SP)
9D00AE44  1540FFF3   BNE T2, ZERO, 0x9D00AE14
9D00AE48  AFA50004   SW A1, 4(SP)
9D00AE4C  8FA20000   LW V0, 0(SP)
9D00AE50  8FA30004   LW V1, 4(SP)
9D00AE14  8FA20000   LW V0, 0(SP)
9D00AE18  8FA30004   LW V1, 4(SP)
9D00AE20  00021023   SUBU V0, ZERO, V0
9D00AE24  0002202B   SLTU A0, ZERO, V0
9D00AE28  00031823   SUBU V1, ZERO, V1
9D00AE1C  27BD0008   ADDIU SP, SP, 8
9D00AE2C  03E00008   JR RA
9D00AE30  00641823   SUBU V1, V1, A0
9D00AE54  03E00008   JR RA
9D00AE58  27BD0008   ADDIU SP, SP, 8
9D00BE90  03E00008   JR RA
9D00BE94  00000000   NOP
9D00C0A8  03E00008   JR RA
9D00C0AC  00801021   ADDU V0, A0, ZERO
9D00C1B8  03E00008   JR RA
9D00C1BC  00801021   ADDU V0, A0, ZERO
9D00C1C4  03E00008   JR RA
9D00C1C8  00801021   ADDU V0, A0, ZERO
---  /Volumes/home/c11067/xc32/build/gcc/config/floatunsisf.c  ------------------------------------------
9D00FB28  27BDFFE8   ADDIU SP, SP, -24
9D00FB2C  AFBF0014   SW RA, 20(SP)
9D00FB30  04800006   BLTZ A0, 0x9D00FB4C
9D00FB34  00801021   ADDU V0, A0, ZERO
9D00FB4C  30420001   ANDI V0, V0, 1
9D00FB50  00042042   SRL A0, A0, 1
9D00FB54  0F402944   JAL sitofp
9D00FB58  00822025   OR A0, A0, V0
9D00FB5C  00402021   ADDU A0, V0, ZERO
9D00FB60  0F4027B0   JAL fpadd
9D00FB64  00402821   ADDU A1, V0, ZERO
9D00FB38  0F402944   JAL sitofp
9D00FB3C  00000000   NOP
9D00FB40  8FBF0014   LW RA, 20(SP)
9D00FB44  03E00008   JR RA
9D00FB48  27BD0018   ADDIU SP, SP, 24
9D00FB68  8FBF0014   LW RA, 20(SP)
9D00FB6C  03E00008   JR RA
9D00FB70  27BD0018   ADDIU SP, SP, 24
