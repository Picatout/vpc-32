Disassembly Listing for vpc-32
Generated From:
C:/Users/Jacques/Documents/GitHub/VPC-32.X/dist/default/production/VPC-32.X.production.elf
2013-09-22 22:43:43

---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/uart.h  ---------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: Constants & Data Types
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  //DOM-IGNORE-BEGIN
74:                  /****
75:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
76:                         the device file.  Also the UART register set could also be placed there
77:                  *****/
78:                  typedef struct
79:                  {
80:                  	volatile UINT	reg;
81:                  	volatile UINT	clr;
82:                  	volatile UINT	set;
83:                  	volatile UINT	inv;
84:                  }REG_SET;
85:                  
86:                  typedef struct
87:                  {
88:                  	volatile REG_SET	mode;
89:                  	volatile REG_SET	sta;
90:                  	volatile REG_SET    tx;
91:                  	volatile REG_SET	rx;
92:                  	volatile REG_SET	brg;
93:                  }UART_REGS;
94:                  
95:                  extern UART_REGS * const uartReg[];
96:                  //DOM-IGNORE-END
97:                  
98:                  // *****************************************************************************
99:                  /* UART Module
100:                 
101:                   Summary:
102:                     UART modules supported.
103:                 
104:                   Description:
105:                     This enumeration identifies the available UART modules.
106:                 */
107:                 
108:                 typedef enum
109:                 {
110:                 #if defined _UART1
111:                     // UART1 Module ID.
112:                     UART1 = 0,
113:                 #endif
114:                 #if defined _UART2
115:                     // UART2 Module ID.
116:                     UART2,
117:                 #endif
118:                 #ifdef _UART3
119:                     // UART3 Module ID.
120:                     UART3,
121:                 #endif
122:                 #ifdef _UART4
123:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
124:                     UART4,
125:                 #endif
126:                 #ifdef _UART5
127:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
128:                     UART5,
129:                 #endif
130:                 #ifdef _UART6
131:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
132:                     UART6,
133:                 #endif
134:                     // Number of available UART modules.
135:                     UART_NUMBER_OF_MODULES
136:                 
137:                 } UART_MODULE;
138:                 
139:                 
140:                 // *****************************************************************************
141:                 /* UART Enable Modes
142:                 
143:                   Summary:
144:                     Operating modes of UART.
145:                 
146:                   Description:
147:                     This enumeration defines the supported modes in which the UART may be
148:                     enabled or disbled.
149:                 
150:                   Remarks:
151:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
152:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
153:                     has been pre-loaded with data.
154:                 
155:                     The caller should not rely on the specific numbers assigned to any of these
156:                     values as they may change from one processor to the next.
157:                 */
158:                 
159:                 typedef enum
160:                 {
161:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
162:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
163:                 
164:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
165:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
166:                 
167:                 
168:                     // UART Module, receiver and transmitter functionality is not.
169:                     // enabled or disabled
170:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
171:                 
172:                     // UART Module receiver.
173:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
174:                 
175:                     // UART Module transmitter.
176:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
177:                 
178:                 
179:                 } UART_ENABLE_MODE;
180:                 
181:                 // *****************************************************************************
182:                 /* UART Enable Helper Macro
183:                 
184:                   Summary:
185:                     Macro for enabling module operating modes.
186:                 
187:                   Description:
188:                     This macro creates the proper flags for enabling operating modes of the UART module.
189:                 
190:                   Example:
191:                     <code>
192:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
193:                     </code>
194:                 
195:                   Remarks:
196:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
197:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
198:                     has been pre-loaded with data.
199:                 */
200:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
201:                 
202:                 // *****************************************************************************
203:                 /* UART Disable Helper Macro
204:                 
205:                   Summary:
206:                     Macro for disabling module operating modes.
207:                 
208:                   Description:
209:                     This macro creates the proper flags for disabling operating modes of the UART module.
210:                 
211:                   Example:
212:                     <code>
213:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
214:                     </code>
215:                 
216:                 */
217:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
218:                 
219:                 // *****************************************************************************
220:                 /* UART Configuration Settings
221:                 
222:                   Summary:
223:                     Supported configuration flags for the UART module.
224:                 
225:                   Description:
226:                     This enumeration defines the various configuration options for the UART
227:                     module.  These values can be OR'd together to create a configuration mask
228:                     passed to the UARTConfigure routine.
229:                 
230:                   Remarks:
231:                     Several of the configuration options are mutually exclusive:
232:                     * Only one of the "ENABLE_PINS" modes can be used at a time
233:                     * Only one of the "RTS_WHEN" modes can be used at a time
234:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
235:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
236:                 
237:                     The caller should not rely on the specific numbers assigned to any of these
238:                     values as they may change from one processor ot the next.
239:                 */
240:                 
241:                 typedef enum
242:                 {
243:                     // Enables high-speed range of the UART (see UARTSetBitRate).
244:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
245:                 
246:                     // Inverts polarity of data interpretation the received (RX) pin.
247:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
248:                 
249:                     // Enables UART TX-to-RX Loop-back mode.
250:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
251:                 
252:                     // Enables Wake-up of the part when a start bit is received.
253:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
254:                 
255:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
256:                     // cannot be used in bit-clock/IrDA mode).
257:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
258:                 
259:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
260:                     // cannot be used in CTS/RTS mode).
261:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
262:                 
263:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
264:                     // be used in RTS-Only mode).
265:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
266:                 
267:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
268:                     // the default mode and this parameter can be left out if it is desired).
269:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
270:                 
271:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
272:                     // is not full (i.e., the UART is ready to receive data).  This is also known
273:                     // as "RTS Flow-Control Mode".
274:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
275:                 
276:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
277:                     // is not empty (i.e., when the UART has data ready to send).  This is also
278:                     // known as "RTS Simplex Mode".
279:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
280:                 
281:                     // Enable the IrDA encoder/decoder.
282:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
283:                 
284:                     // Enables stopping of the UART operation to save power when the core has
285:                     // been put in idle mode.
286:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
287:                 
288:                     // Inverts the polarity of data sent on the transmit (TX) pin.
289:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
290:                 
291:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
292:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
293:                     // Note:  The address must still be set using UARTEnableAddressDetect
294:                     // to support IEEE-485 protocol.
295:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
296:                 
297:                 } UART_CONFIGURATION;
298:                 
299:                 
300:                 // *****************************************************************************
301:                 /* UART FIFO Modes
302:                 
303:                   Summary:
304:                     Supported FIFO modes for the UART module.
305:                 
306:                   Description:
307:                     This enumeration defines supported FIFO modes that determine when the Tx
308:                     and Rx interrupts will occur.
309:                 
310:                   Remarks:
311:                     These modes consist of two sets of mutially exclusive modes:
312:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
313:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
314:                 
315:                     The caller should not rely on the specific numbers assigned to any of these
316:                     values as they may change from one processor ot the next.
317:                 
318:                 */
319:                 
320:                 typedef enum
321:                 {
322:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
323:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
324:                 
325:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
326:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
327:                 
328:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
329:                     // full (i.e. there is space available for more data)  This is the default.
330:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
331:                 
332:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
333:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
334:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
337:                     // (three-quarter) full.
338:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
339:                 
340:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
341:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
342:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
343:                 
344:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
345:                     // data.
346:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
347:                 
348:                 } UART_FIFO_MODE;
349:                 
350:                 
351:                 // *****************************************************************************
352:                 /* UART Line Control Mode
353:                 
354:                   Summary:
355:                     UART line control mode.
356:                 
357:                   Description:
358:                     This data type defines the supported line control modes for the UART.
359:                 
360:                   Remarks:
361:                     Some of the line-control options are mutually exclusive:
362:                     * Only one of the "DATA_SIZE" options can be used at a time
363:                     * Only one of the "PARITY" options can be used at a time
364:                     * Only one of the "STOP_BITS" options can be used at a time
365:                 
366:                     The caller should not rely on the specific numbers assigned to any of these
367:                     values as they may change from one processor ot the next.
368:                 */
369:                 
370:                 typedef enum
371:                 {
372:                     // Sets the data transfer size to 8-bits per frame.
373:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
374:                 
375:                     // Sets the data transfer size to 9-bits per frame.
376:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
377:                 
378:                     // Enables parity bit generation for odd parity.
379:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
380:                 
381:                     // Enables parity bit generation for even parity.
382:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
383:                 
384:                     // Disables parity bit generation.
385:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
386:                 
387:                     // Enables generation of 2 stop bits per frame.
388:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
389:                 
390:                     // Enables generation of 1 stop bit per frame (default).
391:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
392:                 
393:                 } UART_LINE_CONTROL_MODE;
394:                 
395:                 
396:                 // *****************************************************************************
397:                 /* UART Line Status Flags
398:                 
399:                   Summary:
400:                     UART line-status bitmask flags.
401:                 
402:                   Description:
403:                     This enumeration defines the UART line-status bits.  These values are
404:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
405:                 
406:                   Remarks:
407:                     The caller should not rely on the specific numbers assigned to any of these
408:                     values as they may change from one processor ot the next.
409:                 */
410:                 
411:                 typedef enum
412:                 {
413:                     // The transmitter is able to accept data to transmit.
414:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
415:                 
416:                     // The transmitter is empty (no data is available to transmit).
417:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
418:                 
419:                     // The receiver is currently idle.
420:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
421:                 
422:                     // A received data parity error was detected.
423:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
424:                 
425:                     // Data was received that violated the framing protocol (the data word did
426:                     // not start or stop at the appropriate place).  Note:  A break condition
427:                     // will always indicate a framing error.
428:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
429:                 
430:                     // The UART has received more data than it can buffer.  Data has been lost.
431:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
432:                 
433:                     // UART data has been received and is avaiable in the FIFO.
434:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
435:                 
436:                 } UART_LINE_STATUS;
437:                 
438:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
439:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
440:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
441:                 
442:                 
443:                 
444:                 // *****************************************************************************
445:                 /* UART Data
446:                 
447:                   Summary:
448:                     UART data.
449:                 
450:                   Description:
451:                     This data type defines the supported data sizes for the UART.
452:                 */
453:                 
454:                 typedef union
455:                 {
456:                     // 8-bit data
457:                     struct
458:                     {
459:                         UINT16  data8bit    : 8;
460:                     };
461:                 
462:                     // 9-bit data
463:                     struct
464:                     {
465:                         UINT16  data9bit    : 9;
466:                     };
467:                 
468:                     UINT16 __data;
469:                 } UART_DATA;
470:                 
471:                 
472:                 // *****************************************************************************
473:                 // *****************************************************************************
474:                 // Section: UART Peripheral Library Interface Routines
475:                 // *****************************************************************************
476:                 // *****************************************************************************
477:                 
478:                 
479:                 /*******************************************************************************
480:                   Function:
481:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
482:                 
483:                   Summary:
484:                     Enables or disables the given UART module in the desired mode.
485:                 
486:                   Description:
487:                     This routine enables or disables the given UART module in the desired mode.
488:                 
489:                   Precondition:
490:                     The UART module should be appropriately configured before being enabled.
491:                 
492:                   Parameters:
493:                     id    - Identifies the desired UART module.
494:                 
495:                     mode  - Identifies the desired mode of UART operation.
496:                 
497:                   Returns:
498:                     None
499:                 
500:                   Example:
501:                     <code>
502:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
503:                     </code>
504:                 
505:                   Remarks:
506:                     Enabling UART transmissions will immediately cause a TX interrupt to
507:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
508:                     was pre-loaded with data.
509:                   *****************************************************************************/
510:                 
511:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
512:                 
513:                 
514:                 /*******************************************************************************
515:                   Function:
516:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
517:                 
518:                   Summary:
519:                     UART module configuration routine.
520:                 
521:                   Description:
522:                     This routine allows the caller to configure various features of the UART
523:                     module for desired operation.
524:                 
525:                   Precondition:
526:                     None
527:                 
528:                   Parameters:
529:                     id      - Identifies the desired UART module.
530:                 
531:                     flags   - Bit-wise OR of the desired module configuration settings.
532:                 
533:                   Returns:
534:                     None
535:                 
536:                   Example:
537:                     <code>
538:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
539:                     </code>
540:                 
541:                   Remarks:
542:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
543:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
544:                     of these values will result in a value that is not explicitly defined in
545:                     the enumeration.
546:                   *****************************************************************************/
547:                 
548:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
549:                 
550:                 
551:                 /*******************************************************************************
552:                   Function:
553:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
554:                 
555:                   Summary:
556:                     Controls UART module TX and RX FIFO operation.
557:                 
558:                   Description:
559:                     This routine allows the caller to configure when interrupts occur relative
560:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
561:                     or empty the FIFOs are).
562:                 
563:                   Precondition:
564:                     None
565:                 
566:                   Parameters:
567:                     id      - Identifies the desired UART module.
568:                 
569:                     mode    - Bit-wise OR of the desired FIFO mode values.
570:                 
571:                   Returns:
572:                     None
573:                 
574:                   Example:
575:                     <code>
576:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
577:                     </code>
578:                 
579:                   Remarks:
580:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
581:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
582:                     of these values will result in a value that is not explicitly defined in
583:                     the enumeration.
584:                   *****************************************************************************/
585:                 
586:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
587:                 
588:                 
589:                 /*******************************************************************************
590:                   Function:
591:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
592:                 
593:                   Summary:
594:                     Routine to set the UART module's desired data data rate.
595:                 
596:                   Description:
597:                     This routine allows the caller to set the desired data rate for the UART.
598:                 
599:                   Precondition:
600:                     The source clock's frequency must be operating at the frequency passed in the
601:                     "sourceClock" parameter.
602:                 
603:                   Parameters:
604:                     id          - Identifies the desired UART module.
605:                 
606:                     sourceClock - Frequency (Hz) of the source clock being provided to the
607:                                   UART module.
608:                 
609:                     dataRate     - Desired data rate (bits per second).
610:                 
611:                   Returns:
612:                     Actual bit rate selected
613:                 
614:                   Example:
615:                     <code>
616:                 	#define PERIPHERAL_CLOCK    10000000
617:                 	#define DESIRED_DATA_RATE   19200
618:                 	
619:                 	UINT32    actualDataRate;
620:                 
621:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
622:                     </code>
623:                 
624:                   Remarks:
625:                     Actual data rate selected may be slightly different than the data rate
626:                     requested due to truncation error.
627:                 
628:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
629:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
630:                     the maximum data rate is sourceClock/4.
631:                   *****************************************************************************/
632:                 
633:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
634:                 
635:                 
636:                 /*******************************************************************************
637:                   Function:
638:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
639:                 
640:                   Summary:
641:                     Routine to get the UART module's current data data rate.
642:                 
643:                   Description:
644:                     This routine allows the caller to get the current data rate for the UART module.
645:                 
646:                   Precondition:
647:                     The source clock's frequency must be operating at the frequency passed in the
648:                     "sourceClock" parameter.
649:                 
650:                   Parameters:
651:                     id          - Identifies the desired UART module.
652:                 
653:                     sourceClock - Frequency (Hz) of the source clock being provided to the
654:                                   UART module.
655:                 
656:                   Returns:
657:                     The UART's current data rate (bits per second).
658:                 
659:                   Example:
660:                     <code>
661:                 	#define PERIPHERAL_CLOCK    10000000
662:                 	
663:                 	UINT32    currentDataRate;
664:                 
665:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
666:                     </code>
667:                 
668:                   Remarks:
669:                     The current (actual) data rate returned may be slightly different than bit
670:                     rate requested due to truncation error.
671:                   *****************************************************************************/
672:                 
673:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
674:                 
675:                 
676:                 /*******************************************************************************
677:                   Function:
678:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
679:                 
680:                   Summary:
681:                     Routine to set the UART module's desired line control parameters.
682:                 
683:                   Description:
684:                     This routine allows the caller to select the desired size of the UART data
685:                     frame, the generation of parity and framing parameters (collectively
686:                     referred to as the "line control" mode).
687:                 
688:                   Precondition:
689:                 
690:                   Parameters:
691:                     id      - Identifies the desired UART module.
692:                 
693:                     mode    - This is a bit-wise OR of the desired line control mode flags.
694:                 
695:                   Returns:
696:                     None
697:                 
698:                   Example:
699:                     <code>
700:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
701:                     </code>
702:                 
703:                   Remarks:
704:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
705:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
706:                     of these values will result in a value that is not explicitly defined in
707:                     the enumeration.
708:                   *****************************************************************************/
709:                 
710:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
711:                 
712:                 
713:                 /*******************************************************************************
714:                   Function:
715:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
716:                 
717:                   Summary:
718:                     Provides current UART line status.
719:                 
720:                   Description:
721:                     This routine allows the caller to get the current line status of the UART,
722:                     indicating the current state of the transmitter and receiver buffers, and
723:                     if any errors have occurred.
724:                 
725:                   Precondition:
726:                     None
727:                 
728:                   Parameters:
729:                     id      - Identifies the desired UART module.
730:                 
731:                   Returns:
732:                     A bit-wise OR of the current line status flags.
733:                 
734:                   Example:
735:                     <code>
736:                     UART_LINE_STATUS lineStatus;
737:                 	
738:                 	lineStatus = UARTGetLineStatus(UART1);
739:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
740:                     {
741:                         // Handle receiver error
742:                     }
743:                     </code>
744:                 
745:                   Remarks:
746:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
747:                     status flag.
748:                 
749:                     The receiver line status flags are only valid when data has been received
750:                     and for the data at the top of the RX FIFO.
751:                 
752:                     Note that the bitmask resulting from the bit-wise OR of these values will
753:                     result in a value that is not explicitly defined in the enumeration.
754:                   *****************************************************************************/
755:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
756:                 {
757:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
758:                 }
759:                 
760:                 
761:                 /*******************************************************************************
762:                   Function:
763:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
764:                 
765:                   Summary:
766:                     Routine to detect if the transmitter is ready to accept data to transmit.
767:                 
768:                   Description:
769:                     This routine determines if the transmitter is ready to accept more data to
770:                     be transmitted.
771:                 
772:                   Precondition:
773:                     The UART module should have been appropriately configured and enabled.
774:                 
775:                   Parameters:
776:                     id      - Identifies the desired UART module.
777:                 
778:                   Returns:
779:                     Boolean identifying whether or not the transmitter is ready:
780:                     * TRUE    - If the transmitter is ready to accept more data
781:                     * FALSE   - If the transmitter is not ready to accept more data
782:                 
783:                   Example:
784:                     <code>
785:                     unsigned char data;
786:                 	
787:                 	data = 'a';
788:                 	
789:                 	if (UARTTransmitterIsReady(UART1))
790:                     {
791:                         UARTSendDataByte(UART1, data);
792:                     }
793:                     </code>
794:                 
795:                   Remarks:
796:                   *****************************************************************************/
797:                 
798:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
799:                 {
800:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D00CAD4  00042080   SLL A0, A0, 2
9D00CAD8  3C029D01   LUI V0, -25343
9D00CADC  2442003C   ADDIU V0, V0, 60
9D00CAE0  00822021   ADDU A0, A0, V0
9D00CAE4  8C830000   LW V1, 0(A0)
9D00CAE8  8C620010   LW V0, 16(V1)
9D00CAEC  30420200   ANDI V0, V0, 512
9D00CBBC  3C029D01   LUI V0, -25343
9D00CBC0  2442003C   ADDIU V0, V0, 60
9D00CBC4  00621021   ADDU V0, V1, V0
9D00CBC8  8C430000   LW V1, 0(V0)
9D00CBCC  8C620010   LW V0, 16(V1)
9D00CBD0  30420200   ANDI V0, V0, 512
801:                 }
802:                 
803:                 
804:                 /*******************************************************************************
805:                   Function:
806:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
807:                 
808:                   Summary:
809:                     Routine to send a byte of data.
810:                 
811:                   Description:
812:                     This routine allows the caller to send a byte of data.
813:                 
814:                   Precondition:
815:                     The UART should have been appropriately configured.  The configuration must
816:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
817:                     have been ready, although not necessarily enabled yet.
818:                 
819:                   Parameters:
820:                     id      - Identifies the desired UART module.
821:                 
822:                     data    - Data byte to be sent.
823:                 
824:                   Returns:
825:                     None
826:                 
827:                   Example:
828:                     <code>
829:                 	unsigned char data;
830:                 	
831:                 	data = 'a';
832:                 	
833:                     if (UARTTransmitterIsReady(UART1))
834:                     {
835:                         UARTSendDataByte(UART1, data);
836:                     }
837:                     </code>
838:                 
839:                   Remarks:
840:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
841:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
842:                     data.
843:                   *****************************************************************************/
844:                 
845:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
846:                 {
847:                     uartReg[id]->tx.reg = data;
9D00CAF8  30A500FF   ANDI A1, A1, 255
9D00CAFC  AC650020   SW A1, 32(V1)
9D00CBE0  30C600FF   ANDI A2, A2, 255
9D00CBE4  AC660020   SW A2, 32(V1)
848:                 }
849:                 
850:                 
851:                 /*******************************************************************************
852:                   Function:
853:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
854:                 
855:                   Summary:
856:                     Routine to send data through the UART.
857:                 
858:                   Description:
859:                     This routine allows the caller to send data of any permitted size through
860:                     the UART.
861:                 
862:                   Precondition:
863:                     The UART module should have been appropriately configured.  The configuration must
864:                     have been for desired data size.  The transmitter must have been ready,
865:                     although not necessarily enabled yet.
866:                 
867:                   Parameters:
868:                     id      - Identifies the desired UART module.
869:                 
870:                     data    - Data to be sent.
871:                 
872:                   Returns:
873:                     None
874:                 
875:                   Example:
876:                     <code>
877:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
878:                 	
879:                 	if (UARTTransmitterIsReady(UART1))
880:                     {
881:                         UARTSendData(UART1, data);
882:                     }
883:                     </code>
884:                 
885:                   Remarks:
886:                     Size of the data word size depends on the current configuration (see
887:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
888:                   *****************************************************************************/
889:                 
890:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
891:                 {
892:                     uartReg[id]->tx.reg = data.__data;
893:                 }
894:                 
895:                 /*******************************************************************************
896:                   Function:
897:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
898:                 
899:                   Summary:
900:                     Routine to detect if the UART module has finshed transmitting the most recent
901:                     data.
902:                 
903:                   Description:
904:                     This routine determines if the transmitter has finished sending all
905:                     available data.
906:                 
907:                   Preconditions:
908:                     The UART module should have been appropriately configured and enabled and data
909:                     sent to the UART TX buffer.
910:                 
911:                   Parameters:
912:                     id      - Identifies the desired UART module.
913:                 
914:                   Returns:
915:                     Boolean identifying if the transmission has completed:
916:                     * TRUE    - If the transmitter has completed sending the data
917:                     * FALSE   - If the transmitter is still busy sending the data
918:                 
919:                   Example:
920:                     <code>
921:                 	if (UARTTransmissionHasCompleted(UART1))
922:                     {
923:                         // Perform any tasks necessary when all data has been sent
924:                     }
925:                     </code>
926:                 
927:                   Remarks:
928:                   *****************************************************************************/
929:                 
930:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
931:                 {
932:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
9D00CBF4  00042080   SLL A0, A0, 2
9D00CBF8  3C029D01   LUI V0, -25343
9D00CBFC  2442003C   ADDIU V0, V0, 60
9D00CC00  00822021   ADDU A0, A0, V0
9D00CC04  8C830000   LW V1, 0(A0)
9D00CC08  8C620010   LW V0, 16(V1)
9D00CC0C  30420100   ANDI V0, V0, 256
933:                 }
934:                 
935:                 
936:                 /*******************************************************************************
937:                   Function:
938:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
939:                 
940:                   Summary:
941:                     Routine to detect if the receiver has data available.
942:                 
943:                   Description:
944:                     This routine determines if the receiver has data available to be read.
945:                 
946:                   Precondition:
947:                     The UART module must have been configured appropriately and enabled. A complete
948:                     data frame must have been sent to the UART before it will return a TRUE.
949:                 
950:                   Parameters:
951:                     id      - Identifies the desired UART module.
952:                 
953:                   Returns:
954:                     Boolean identifying whether or not data is available:
955:                     * TRUE    - If the receiver has data available
956:                     * FALSE   - If the receiver does not have data availble
957:                 
958:                   Example:
959:                     <code>
960:                     UART_DATA data;
961:                 	
962:                 	if (UARTReceivedDataIsAvailable(UART1))
963:                     {
964:                         data = UARTGetData(UART1);
965:                     }
966:                     </code>
967:                 
968:                   Remarks:
969:                     This routine provides the same information as the UART_DATA_READY line
970:                     status flag.
971:                   *****************************************************************************/
972:                 
973:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
974:                 {
975:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
9D00CA9C  00042080   SLL A0, A0, 2
9D00CAA0  3C029D01   LUI V0, -25343
9D00CAA4  2442003C   ADDIU V0, V0, 60
9D00CAA8  00822021   ADDU A0, A0, V0
9D00CAAC  8C830000   LW V1, 0(A0)
9D00CAB0  8C640010   LW A0, 16(V1)
9D00CAB4  30840001   ANDI A0, A0, 1
9D00CB24  00048080   SLL S0, A0, 2
9D00CB28  3C029D01   LUI V0, -25343
9D00CB2C  2442003C   ADDIU V0, V0, 60
9D00CB30  02028021   ADDU S0, S0, V0
9D00CB34  8E030000   LW V1, 0(S0)
9D00CB38  8C620010   LW V0, 16(V1)
9D00CB3C  30420001   ANDI V0, V0, 1
9D00CB5C  3C029D01   LUI V0, -25343
9D00CB60  2442003C   ADDIU V0, V0, 60
9D00CB6C  8C430010   LW V1, 16(V0)
9D00CB70  30630001   ANDI V1, V1, 1
9D00CC50  00041080   SLL V0, A0, 2
9D00CC54  3C129D01   LUI S2, -25343
9D00CC58  2652003C   ADDIU S2, S2, 60
9D00CC5C  00529021   ADDU S2, V0, S2
9D00CC68  8C430010   LW V1, 16(V0)
9D00CC6C  30630001   ANDI V1, V1, 1
9D00CD38  00042080   SLL A0, A0, 2
9D00CD3C  3C029D01   LUI V0, -25343
9D00CD40  2442003C   ADDIU V0, V0, 60
9D00CD44  00822021   ADDU A0, A0, V0
9D00CD48  8C830000   LW V1, 0(A0)
9D00CD4C  8C640010   LW A0, 16(V1)
9D00CD50  30840001   ANDI A0, A0, 1
976:                 }
977:                 
978:                 
979:                 /*******************************************************************************
980:                   Function:
981:                     BYTE UARTGetDataByte ( UART_MODULE id )
982:                 
983:                   Summary:
984:                     Routine to get a byte of data received by the UART.
985:                 
986:                   Description:
987:                     This routine allows the caller to read a byte of data received by the UART.
988:                 
989:                   Precondition:
990:                     The UART module must have been appropriately configured, the configuration must
991:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
992:                     been enabled.  Also, a complete data frame must have been received by the UART.
993:                 
994:                   Parameters:
995:                     id      - Identifies the desired UART module.
996:                 
997:                   Returns:
998:                     A byte of data received by the UART.
999:                 
1000:                  Example:
1001:                    <code>
1002:                    unsigned char data;
1003:                	
1004:                	if (UARTReceivedDataIsAvailable(UART1))
1005:                    {
1006:                        data = UARTGetDataByte(UART1);
1007:                    }
1008:                    </code>
1009:                
1010:                  Remarks:
1011:                    This routine is optimized for receiving 8-bit data through the UART.
1012:                  *****************************************************************************/
1013:                
1014:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1015:                {
1016:                    return (BYTE)uartReg[id]->rx.reg;
9D00CAC0  8C620030   LW V0, 48(V1)
9D00CB48  8C620030   LW V0, 48(V1)
9D00CB7C  8C420030   LW V0, 48(V0)
9D00CC78  8C450030   LW A1, 48(V0)
9D00CD5C  8C630030   LW V1, 48(V1)
1017:                }
1018:                
1019:                
1020:                /*******************************************************************************
1021:                  Function:
1022:                    UART_DATA UARTGetData ( UART_MODULE id )
1023:                
1024:                  Summary:
1025:                    Routine to get data received by the UART.
1026:                
1027:                  Description:
1028:                    This routine allows the caller to read a data word received by the UART.
1029:                
1030:                  Precondition:
1031:                    The module must have been appropriately configured, the UART module must have been
1032:                    enabled, and a complete data frame must have been received by the UART.
1033:                
1034:                  Parameters:
1035:                    id      - Identifies the desired UART module.
1036:                
1037:                  Returns:
1038:                    Data received by the UART.
1039:                
1040:                  Example:
1041:                    <code>
1042:                    UART_DATA data;
1043:                	
1044:                	if (UARTReceivedDataIsAvailable(UART1))
1045:                    {
1046:                        data = UARTGetData(UART1);
1047:                    }
1048:                    </code>
1049:                
1050:                  Remarks:
1051:                    Size of the data word depends on the current configuration (see
1052:                    UARTSetLineControl).
1053:                  *****************************************************************************/
1054:                
1055:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1056:                {
1057:                    UART_DATA data;
1058:                
1059:                    data.__data = uartReg[id]->rx.reg;
1060:                
1061:                    return data;
1062:                }
1063:                
1064:                
1065:                /*******************************************************************************
1066:                  Function:
1067:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1068:                
1069:                  Summary:
1070:                    Routine to program the address for which the UART module may watch.
1071:                
1072:                  Description:
1073:                    This routine programs the 8-bit address for which the module may watch.
1074:                
1075:                  Precondition:
1076:                    None
1077:                
1078:                  Parameters:
1079:                    id      - Identifies the desired UART module.
1080:                
1081:                    address - 8-bit address for which the module will watch.
1082:                
1083:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1084:                              * TRUE - Enable address watch mode
1085:                              * FALSE - Disable address watch mode
1086:                
1087:                  Returns:
1088:                    None.
1089:                
1090:                  Example:
1091:                    <code>
1092:                    #define SLAVE_ADDRESS  0x42
1093:                	
1094:                	UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1095:                    </code>
1096:                
1097:                  Remarks:
1098:                    The module can be placed into a mode where it will ignore all data received
1099:                    until it identifies the programmed adress.  After the programmed address
1100:                    has been identified, it will begin receiving data normally.  This mode is
1101:                    particularly useful for supporting the IEEE-485 protocol.
1102:                  *****************************************************************************/
1103:                
1104:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1105:                
1106:                
1107:                /*******************************************************************************
1108:                  Function:
1109:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1110:                
1111:                  Summary:
1112:                    Routine to enable or disable recognition of the programmed address byte.
1113:                
1114:                  Description:
1115:                    This routine can enable or disable the "address watch" mode.  In this mode,
1116:                    the UART module will ignore all data until it recognizes the programmed address.
1117:                
1118:                  Precondition:
1119:                    UART should have already been enabled and set with watch address.
1120:                
1121:                  Parameters:
1122:                    id      - Identifies the desired UART module.
1123:                
1124:                    watch   - Determines if the "address watch" mode will be enabled or
1125:                              disabled.
1126:                              * TRUE - Enable address watch mode
1127:                              * FALSE - Disable address watch mode
1128:                
1129:                  Returns:
1130:                    None.
1131:                
1132:                  Example:
1133:                    <code>
1134:                    #define SLAVE_ADDRESS 0x42
1135:                	
1136:                	// Set the address, but don't enable the watch until later,
1137:                	// UART continues to receive data normally
1138:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1139:                
1140:                    // ...
1141:                
1142:                    // Now begin to ignore all UART traffic until we are addressed
1143:                    UARTWatchForAddress(UART1, TRUE);
1144:                    </code>
1145:                
1146:                  Remarks:
1147:                    The UART module can be placed into a mode where it will ignore all data received
1148:                    until it identifies the programmed address.  After the programmed address
1149:                    has been identified, it will begin receiving data normally.  This mode is
1150:                    particularly useful for supporting the IEEE-485 protocol.
1151:                  *****************************************************************************/
1152:                
1153:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1154:                
1155:                
1156:                /*******************************************************************************
1157:                  Function:
1158:                    void UARTSendBreak ( UART_MODULE id )
1159:                
1160:                  Summary:
1161:                    Routine to send a break signal from the UART.
1162:                
1163:                  Description:
1164:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1165:                
1166:                  Precondition:
1167:                    The UART should have been appropriately configured.  The transmitter should
1168:                    be idle, although not necessarily enabled yet.
1169:                
1170:                  Parameters:
1171:                    id      - Identifies the desired UART module.
1172:                
1173:                  Returns:
1174:                    None
1175:                
1176:                  Example:
1177:                    <code>
1178:                    if (UARTTransmissionHasCompleted(UART1))
1179:                    {
1180:                        UARTSendBreak(UART1);
1181:                    }
1182:                    </code>
1183:                
1184:                  Remarks:
1185:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1186:                    data may be pre-loaded into the FIFO and it will be send immediately
1187:                    following the break signal.
1188:                  *****************************************************************************/
1189:                
1190:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1191:                {
1192:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1193:                }
1194:                
1195:                
1196:                /*******************************************************************************
1197:                  Function:
1198:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1199:                
1200:                  Summary:
1201:                    Routine to automatically determine the data rate (bits-per-second) of an
1202:                    external transmitter to the UART.
1203:                
1204:                  Description:
1205:                    This routine initiates the process of automatically determining the data
1206:                    rate (bits-per-second) of an external transmitter to the UART.
1207:                
1208:                  Precondition:
1209:                    The UART should have been appropriately configured.  The transmitter should
1210:                    be idle, although not necessarily enabled yet.
1211:                
1212:                  Parameters:
1213:                    id      - Identifies the desired UART module.
1214:                
1215:                  Returns:
1216:                    None
1217:                
1218:                  Example:
1219:                    <code>
1220:                	// See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1221:                	// methods to detect a Break.
1222:                	
1223:                    if (breakDetected && useAutoRateDetect) 
1224:                    {
1225:                        UARTStartAutoDataRateDetect (UART1);
1226:                    }
1227:                    </code>
1228:                
1229:                  Remarks:
1230:                    The UART module begins measuring the data rate beginning at the next start
1231:                    bit.  The external transmitter should send an alternating pattern (0x55)
1232:                    for the byte to be measured for an effective rate detection.  To ensure
1233:                    an effective measurement sequence, this can be done immediately following
1234:                    a break reception. It is important that this UART module is not
1235:                	transmitting data while it is trying to detect RX baud rate, see the 
1236:                	"PIC32 Family Reference Manual, Sect. 21 UART".
1237:                  *****************************************************************************/
1238:                
1239:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1240:                {
1241:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1242:                }
1243:                
1244:                
1245:                
1246:                /*******************************************************************************
1247:                  Function:
1248:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1249:                
1250:                  Summary:
1251:                    Routine to identify when automatic data rate detection has completed.
1252:                
1253:                  Description:
1254:                    This routine checks to see if automatic data rate detection has completed.
1255:                
1256:                  Precondition:
1257:                    Automatic rate detection should have been previously started.
1258:                
1259:                  Parameters:
1260:                    id      - Identifies the desired UART module.
1261:                
1262:                  Returns:
1263:                    * TRUE    - Indicates that automatic rate detection has completed.
1264:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1265:                
1266:                  Example:
1267:                    <code>
1268:                    #define PERIPHERAL_CLOCK    10000000
1269:                	
1270:                	UINT32 currentRate;
1271:                	
1272:                	if (UARTDataRateDetected(UART1))
1273:                    {
1274:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1275:                    }
1276:                    </code>
1277:                
1278:                  Remarks:
1279:                    This routine returns FALSE after automatic rate detection
1280:                    has been started but before rate is detectdd, it will return TRUE
1281:                	at any other time.
1282:                  *****************************************************************************/
1283:                
1284:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1285:                {
1286:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1287:                }
1288:                
1289:                #ifdef __cplusplus
1290:                  }
1291:                #endif
1292:                
1293:                #endif // _UART_h_
1294:                
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
118:                         pb_clock >>= 1;
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
170:                     {
171:                         wait_states++;
172:                         sys_clock -= FLASH_SPEED_HZ;
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
176:                     mCheConfigure(wait_states);
177:                     INTRestoreInterrupts(int_status);
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
227:                     {
228:                         wait_states++;
229:                         sys_clock -= FLASH_SPEED_HZ;
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
233:                     mCheConfigure(wait_states);
234:                     INTRestoreInterrupts(int_status);
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
279:                 
280:                     int_status=INTDisableInterrupts();
281:                 
282:                     mBMXDisableDRMWaitState();
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
286:                     cache_status |= CHE_CONF_PF_ALL;
287:                     mCheConfigure(cache_status);
288:                     CheKseg0CacheOn();
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
9D00D3D0  0F40400D   JAL INTDisableInterrupts
9D00D3D4  00000000   NOP
342:                 
343:                     mBMXDisableDRMWaitState();
9D00D3D8  24040040   ADDIU A0, ZERO, 64
9D00D3DC  3C03BF88   LUI V1, -16504
9D00D3E0  AC642004   SW A0, 8196(V1)
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
358:                     {
359:                         cache_status = mCheGetCon();
360:                         cache_status |= CHE_CONF_PF_ALL;
361:                         mCheConfigure(cache_status);
362:                         CheKseg0CacheOn();
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
367:                     pb_clk >>= OSCCONbits.PBDIV;
9D00D3E4  3C03BF81   LUI V1, -16511
9D00D3E8  8C63F000   LW V1, -4096(V1)
368:                 
369:                     INTRestoreInterrupts(int_status);
9D00D3EC  0F403FA3   JAL INTRestoreInterrupts
9D00D3F0  00402021   ADDU A0, V0, ZERO
370:                 
371:                     return pb_clk;
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/vpc-32.c  -----------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /* 
20:                   * File:   vpc-32.c
21:                   * Author: Jacques Deschênes
22:                   *
23:                   * Created on 26 août 2013, 07:38
24:                   */
25:                  
26:                  #include <stdio.h>
27:                  #include <stdlib.h>
28:                  #include <plib.h>
29:                  
30:                  
31:                  #include "hardware/HardwareProfile.h"
32:                  #include "hardware/ntsc.h"
33:                  #include "hardware/serial_comm.h"
34:                  #include "hardware/keyboard.h"
35:                  #include "hardware/Pinguino/diskio.h"
36:                  #include "console.h"
37:                  #include "hardware/Pinguino/ff.h"
38:                  #include "vpForth/opcodes.h"
39:                  #include "vpForth/vpForth.h"
40:                  
41:                  // PIC32MX150F128B Configuration Bit Settings
42:                  #include <xc.h>
43:                  
44:                  // DEVCFG3
45:                  // USERID = No Setting
46:                  #pragma config PMDL1WAY = OFF           // permet plusieurs configurations des périphériques.
47:                  #pragma config IOL1WAY = OFF            // permet plusieurs configuration des broches.
48:                  
49:                  // DEVCFG2
50:                  #pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
51:                  #if SYSCLK==40000000L
52:                  #pragma config FPLLMUL = MUL_16         // SYSCLK=40Mhz
53:                  #else
54:                  #pragma config FPLLMUL = MUL_15          // PLL Multiplier (15x Multiplier) SYSCLK=37,5Mhz
55:                  #endif
56:                  #pragma config FPLLODIV = DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)
57:                  
58:                  // DEVCFG1
59:                  #pragma config FNOSC = PRIPLL           // Oscillator Selection Bits (Primary Osc w/PLL (XT+,HS+,EC+PLL))
60:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
61:                  #pragma config IESO = OFF               // Internal/External Switch Over (Disabled)
62:                  #pragma config POSCMOD = HS             // Primary Oscillator Configuration (XT osc mode)
63:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
64:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
65:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
66:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
67:                  
68:                  // DEVCFG0
69:                  #pragma config JTAGEN = OFF             // JTAG Enable (JTAG Disabled)
70:                  #pragma config ICESEL = ICS_PGx1        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
71:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
72:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
73:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
74:                  
75:                  
76:                  
77:                  const char *msg1=" test video ntsc\r";
78:                  const char *msg2="01234567890123456789012345678901234567890123456789012"; // 53 caractères par ligne
79:                  
80:                  
81:                  void test_pattern(void){
9D00E4F0  27BDFFE8   ADDIU SP, SP, -24
9D00E4F4  AFBF0014   SW RA, 20(SP)
9D00E4F8  3C06A000   LUI A2, -24576
9D00E4FC  24C6016C   ADDIU A2, A2, 364
9D00E500  00C03821   ADDU A3, A2, ZERO
9D00E504  24C523F0   ADDIU A1, A2, 9200
9D00E508  00C01021   ADDU V0, A2, ZERO
9D00E528  24E30028   ADDIU V1, A3, 40
9D00E54C  24E71AE8   ADDIU A3, A3, 6888
82:                      int i,j;
83:                      for (i=0;i<VRES;i++){
9D00E520  5445FFFD   BNEL V0, A1, 0x9D00E518
9D00E524  AC440000   SW A0, 0(V0)
84:                          video_bmp[i][0]=0x80000000;
9D00E50C  3C048000   LUI A0, -32768
9D00E514  AC440000   SW A0, 0(V0)
85:                          video_bmp[i][HRES/32-1]=1;
9D00E510  24030001   ADDIU V1, ZERO, 1
9D00E518  AC430024   SW V1, 36(V0)
9D00E51C  24420028   ADDIU V0, V0, 40
86:                      }
87:                      for (i=0;i<HRES/32;i++){
9D00E53C  54C3FFFD   BNEL A2, V1, 0x9D00E534
9D00E540  ACC20000   SW V0, 0(A2)
9D00E544  3C02A000   LUI V0, -24576
9D00E548  24420A5C   ADDIU V0, V0, 2652
88:                          video_bmp[0][i]=0xffffffff;
9D00E52C  2402FFFF   ADDIU V0, ZERO, -1
9D00E530  ACC20000   SW V0, 0(A2)
89:                          video_bmp[VRES-1][i]=0xffffffff;
9D00E534  ACC223C8   SW V0, 9160(A2)
9D00E538  24C60004   ADDIU A2, A2, 4
90:                      }
91:                      for (i=VRES/4;i<VRES/2+VRES/4;i++){
9D00E584  5447FFFB   BNEL V0, A3, 0x9D00E574
9D00E588  AC460000   SW A2, 0(V0)
92:                          video_bmp[i][2]=0xFF00FF00;
9D00E550  3C06FF00   LUI A2, -256
9D00E554  34C6FF00   ORI A2, A2, -256
9D00E570  AC460000   SW A2, 0(V0)
93:                          video_bmp[i][3]=0xF0F0F0F0;
9D00E558  3C05F0F0   LUI A1, -3856
9D00E55C  34A5F0F0   ORI A1, A1, -3856
9D00E574  AC450004   SW A1, 4(V0)
94:                          video_bmp[i][4]=0xcccccccc;
9D00E560  3C04CCCC   LUI A0, -13108
9D00E564  3484CCCC   ORI A0, A0, -13108
9D00E578  AC440008   SW A0, 8(V0)
95:                          video_bmp[i][5]=0xaaaaaaaa;
9D00E568  3C03AAAA   LUI V1, -21846
9D00E56C  3463AAAA   ORI V1, V1, -21846
9D00E57C  AC43000C   SW V1, 12(V0)
9D00E580  24420028   ADDIU V0, V0, 40
96:                      }//i
97:                      print(LOCAL_CON,msg1);
9D00E58C  00002021   ADDU A0, ZERO, ZERO
9D00E590  0F402601   JAL print
9D00E594  8F85804C   LW A1, -32692(GP)
98:                      print(LOCAL_CON,msg2);
9D00E598  00002021   ADDU A0, ZERO, ZERO
9D00E59C  0F402601   JAL print
9D00E5A0  8F858050   LW A1, -32688(GP)
99:                  }//test_pattern()
9D00E5A4  8FBF0014   LW RA, 20(SP)
9D00E5A8  03E00008   JR RA
9D00E5AC  27BD0018   ADDIU SP, SP, 24
100:                 
101:                 
102:                 void main(void) {
9D00E5B0  27BDFFE8   ADDIU SP, SP, -24
9D00E5B4  AFBF0014   SW RA, 20(SP)
103:                     int code;
104:                     short key;
105:                     unsigned char buff[BLK_SIZE];
106:                     int i;
107:                     unsigned int size;
108:                 
109:                     HardwareInit();
9D00E5B8  0F4034F2   JAL HardwareInit
9D00E5BC  00000000   NOP
110:                     UartInit(STDIO,115200,DEFAULT_LINE_CTRL);
9D00E5C0  24040001   ADDIU A0, ZERO, 1
9D00E5C4  3C050001   LUI A1, 1
9D00E5C8  34A5C200   ORI A1, A1, -15872
9D00E5CC  0F40328A   JAL UartInit
9D00E5D0  00003021   ADDU A2, ZERO, ZERO
111:                     ln_cnt=0;
9D00E5D4  AF8080C0   SW ZERO, -32576(GP)
112:                     video=0;
9D00E5D8  AF8080BC   SW ZERO, -32580(GP)
113:                     test_pattern();
9D00E5DC  0F40393C   JAL test_pattern
9D00E5E0  00000000   NOP
114:                     UartPrint(STDOUT,"initialisation video\r");
9D00E5E4  24040001   ADDIU A0, ZERO, 1
9D00E5E8  3C059D01   LUI A1, -25343
9D00E5EC  0F4032EC   JAL UartPrint
9D00E5F0  24A5ED84   ADDIU A1, A1, -4732
115:                     VideoInit();
9D00E5F4  0F403360   JAL VideoInit
9D00E5F8  00000000   NOP
116:                     delay_ms(500);
9D00E5FC  0F403567   JAL delay_ms
9D00E600  240401F4   ADDIU A0, ZERO, 500
117:                     UartPrint(STDOUT,"initialisation clavier: ");
9D00E604  24040001   ADDIU A0, ZERO, 1
9D00E608  3C059D01   LUI A1, -25343
9D00E60C  0F4032EC   JAL UartPrint
9D00E610  24A5ED9C   ADDIU A1, A1, -4708
118:                     if (KeyboardInit()){
9D00E614  0F40213E   JAL KeyboardInit
9D00E618  00000000   NOP
9D00E61C  10400006   BEQ V0, ZERO, 0x9D00E638
9D00E620  24040001   ADDIU A0, ZERO, 1
119:                         UartPrint(STDOUT,"OK\r");
9D00E624  3C059D01   LUI A1, -25343
9D00E628  0F4032EC   JAL UartPrint
9D00E62C  24A5EDB8   ADDIU A1, A1, -4680
120:                         comm_channel=LOCAL_CON;
9D00E630  0B403997   J 0x9D00E65C
9D00E634  A3808064   SB ZERO, -32668(GP)
121:                     }else{
122:                         UartPrint(STDOUT,"erreur clavier\r");
9D00E638  3C059D01   LUI A1, -25343
9D00E63C  0F4032EC   JAL UartPrint
9D00E640  24A5EDBC   ADDIU A1, A1, -4676
123:                         UartPrint(STDOUT,"Utilisation du lien sériel.\r");
9D00E644  24040001   ADDIU A0, ZERO, 1
9D00E648  3C059D01   LUI A1, -25343
9D00E64C  0F4032EC   JAL UartPrint
9D00E650  24A5EDCC   ADDIU A1, A1, -4660
124:                         comm_channel=SERIAL_CON;
9D00E654  24020001   ADDIU V0, ZERO, 1
9D00E658  A3828064   SB V0, -32668(GP)
125:                     }
126:                     text_coord_t cpos;
127:                     UartPrint(STDOUT,"initialisation peripherique carte SD.\r");
9D00E65C  24040001   ADDIU A0, ZERO, 1
9D00E660  3C059D01   LUI A1, -25343
9D00E664  0F4032EC   JAL UartPrint
9D00E668  24A5EDEC   ADDIU A1, A1, -4628
128:                     UartPrint(STDOUT,"initialisation carte SD: ");
9D00E66C  24040001   ADDIU A0, ZERO, 1
9D00E670  3C059D01   LUI A1, -25343
9D00E674  0F4032EC   JAL UartPrint
9D00E678  24A5EE14   ADDIU A1, A1, -4588
129:                     if (!mount(0)){
9D00E67C  0F40343B   JAL mount
9D00E680  00002021   ADDU A0, ZERO, ZERO
9D00E684  14400005   BNE V0, ZERO, 0x9D00E69C
9D00E688  24040001   ADDIU A0, ZERO, 1
130:                         UartPrint(STDOUT,"Echec\r");
9D00E68C  3C059D01   LUI A1, -25343
9D00E690  0F4032EC   JAL UartPrint
9D00E694  24A5EE30   ADDIU A1, A1, -4560
131:                     }
132:                     UartPrint(STDOUT, "OK\r");
9D00E698  24040001   ADDIU A0, ZERO, 1
9D00E69C  3C059D01   LUI A1, -25343
9D00E6A0  0F4032EC   JAL UartPrint
9D00E6A4  24A5EDB8   ADDIU A1, A1, -4680
133:                 //    FIL *fp;
134:                 //    FILINFO *fo;
135:                 //    fp=malloc(sizeof(FIL));
136:                 //    fo=malloc(sizeof(FILINFO));
137:                 //    if (!f_open(fp,"readme.txt",FA_READ)){
138:                 //        f_stat("readme.txt",fo);
139:                 //        if (!f_read(fp,buff,fo->fsize,(UINT*)&i)){
140:                 //            clear_screen();
141:                 //            buff[fo->fsize]=0;
142:                 //            print("file size: ");
143:                 //            print_int(i,10);
144:                 //            put_char('\r');
145:                 //            print(buff);
146:                 //            f_close(fp);
147:                 //            if (i==40){
148:                 //                f_open(fp,"readme.txt",FA_WRITE);
149:                 //                f_lseek(fp,i);
150:                 //                f_write(fp,"test ecriture\r",14,(UINT*)&i);
151:                 //                f_stat("readme.txt",fo);
152:                 //                print("grandeur apres ecriture: ");
153:                 //                print_int(fo->fsize,10);
154:                 //                f_close(fp);
155:                 //            }
156:                 //            free(fp);
157:                 //            free(fo);
158:                 //        }
159:                 //    }
160:                 //    UartPrint(STDOUT,"lecture du registre CSD\r");
161:                 //    clear_screen();
162:                 //    size=disk_ioctl(0,GET_SECTOR_SIZE,buff);
163:                 //    print_int(*(unsigned short *)buff,10);
164:                 //    put_char('\r');
165:                 //    size=disk_ioctl(0,GET_SECTOR_COUNT,buff);
166:                 //    print_int(*(int*)buff,10);
167:                 //    put_char('\r');
168:                 //    size=disk_ioctl(0,GET_BLOCK_SIZE,buff);
169:                 //    print_int(*(int*)buff,10);
170:                 //    put_char('\r');
171:                 //    for (i=511;i;i--){
172:                 //        buff[i]=255;
173:                 //    }
174:                 //    while (1);
175:                 //    delay_ms(2000);
176:                     tone(400,1000);
9D00E6A8  24040190   ADDIU A0, ZERO, 400
9D00E6AC  0F403D09   JAL tone
9D00E6B0  240503E8   ADDIU A1, ZERO, 1000
177:                     UartPrint(STDOUT,"initialisation completee.\r");
9D00E6B4  24040001   ADDIU A0, ZERO, 1
9D00E6B8  3C059D01   LUI A1, -25343
9D00E6BC  0F4032EC   JAL UartPrint
9D00E6C0  24A5EE38   ADDIU A1, A1, -4552
178:                     set_cursor(CR_BLOCK);
9D00E6C4  0F4026FA   JAL set_cursor
9D00E6C8  24040001   ADDIU A0, ZERO, 1
179:                     clear_screen();
9D00E6CC  0F4025F3   JAL clear_screen
9D00E6D0  00000000   NOP
180:                     shell();
9D00E6D4  0F40389F   JAL shell
9D00E6D8  00000000   NOP
181:                 } // main()
9D00E6DC  8FBF0014   LW RA, 20(SP)
9D00E6E0  03E00008   JR RA
9D00E6E4  27BD0018   ADDIU SP, SP, 24
182:                 
183:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/sound.c  ------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   sound.c
20:                   * Author: Jacques Deschênes
21:                   *
22:                   * Created on 13 septembre 2013, 20:42
23:                   */
24:                  
25:                  #include "hardware/HardwareProfile.h"
26:                  
27:                  volatile unsigned char tone_on=0;
28:                  volatile unsigned int duration;
29:                  
30:                  void tone(unsigned int freq, // fréquence en hertz
31:                            unsigned int msec){ // durée en  millisecondes
32:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
33:                      OC3CONbits.OCM = 5; //mode pwm
9D00F424  3C02BF80   LUI V0, -16512
9D00F428  8C433400   LW V1, 13312(V0)
9D00F42C  24060005   ADDIU A2, ZERO, 5
9D00F430  7CC31004   INS V1, A2, 0, 3
9D00F434  AC433400   SW V1, 13312(V0)
34:                      OC3CONbits.OCTSEL=1; // timer 3
9D00F438  8C463400   LW A2, 13312(V0)
9D00F43C  24030001   ADDIU V1, ZERO, 1
9D00F440  7C6618C4   INS A2, V1, 3, 1
9D00F444  AC463400   SW A2, 13312(V0)
35:                      T3CON=0;
9D00F448  3C06BF80   LUI A2, -16512
9D00F44C  ACC00A00   SW ZERO, 2560(A2)
36:                      PR3=(SYSCLK/8/freq)-1; // rapport cyclique 50%
9D00F450  3C060047   LUI A2, 71
9D00F454  34C6868C   ORI A2, A2, -31092
9D00F458  00C4001B   DIVU A2, A0
9D00F45C  008001F4   TEQ A0, ZERO
9D00F460  00003012   MFLO A2, 0
9D00F464  24C6FFFF   ADDIU A2, A2, -1
9D00F468  3C07BF80   LUI A3, -16512
9D00F46C  ACE60A20   SW A2, 2592(A3)
37:                      OC3RS=0;
9D00F470  3C06BF80   LUI A2, -16512
9D00F474  ACC03420   SW ZERO, 13344(A2)
38:                      OC3R=SYSCLK/16/freq;
9D00F478  3C060023   LUI A2, 35
9D00F47C  34C6C346   ORI A2, A2, -15546
9D00F480  00C4001B   DIVU A2, A0
9D00F484  008001F4   TEQ A0, ZERO
9D00F488  00003012   MFLO A2, 0
9D00F48C  3C07BF80   LUI A3, -16512
9D00F490  ACE63410   SW A2, 13328(A3)
39:                      OC3CONbits.ON=1;
9D00F494  8C443400   LW A0, 13312(V0)
9D00F498  7C647BC4   INS A0, V1, 15, 1
9D00F49C  AC443400   SW A0, 13312(V0)
40:                      duration=msec;
9D00F4A0  AF8580E0   SW A1, -32544(GP)
41:                      tone_on=1;
9D00F4A4  A3838074   SB V1, -32652(GP)
42:                      T3CONbits.TCKPS=3;
9D00F4A8  3C02BF80   LUI V0, -16512
9D00F4AC  8C440A00   LW A0, 2560(V0)
9D00F4B0  24050003   ADDIU A1, ZERO, 3
9D00F4B4  7CA43104   INS A0, A1, 4, 3
9D00F4B8  AC440A00   SW A0, 2560(V0)
43:                      T3CONbits.ON=1;
9D00F4BC  8C440A00   LW A0, 2560(V0)
9D00F4C0  7C647BC4   INS A0, V1, 15, 1
9D00F4C4  AC440A00   SW A0, 2560(V0)
44:                  } //tone();
9D00F4C8  03E00008   JR RA
9D00F4CC  00000000   NOP
45:                  
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/shell.c  ------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  
20:                  /*
21:                   * File:   shell.h
22:                   * Author: Jacques Deschênes
23:                   *
24:                   * Created on 18 septembre 2013, 07:29
25:                   * Description: un environnement de commande simple pour le VPC-32.
26:                   *   liste des commandes:
27:                   *      ls     liste des fichiers sur la carte SD
28:                   *      rm     efface un fichier.
29:                   *      mv     renomme un fichier.
30:                   *      ed     ouvre l'éditeur
31:                   *      as     assemble un fichier écris en assembleur pour la machine virtuelle.
32:                   *      run    execute un programme compilé pour la machine virtuelle.
33:                   *      cp     copie un fichier
34:                   *      snd    envoie un fichier vers le port sériel
35:                   *      rcv    reçois un fichier par le port sériel
36:                   *      forth  lance l'environnement vpForth
37:                   */
38:                  
39:                  #include <string.h>
40:                  #include "hardware/HardwareProfile.h"
41:                  #include "hardware/keyboard.h"
42:                  #include "console.h"
43:                  #include "hardware/Pinguino/ff.h"
44:                  #include <plib.h>
45:                  
46:                  #define MAX_LINE_LEN 80
47:                  typedef struct{
48:                      char buff[MAX_LINE_LEN]; // chaîne saisie par l'utilisateur.
49:                      unsigned char len;  // longueur de la chaîne.
50:                      unsigned char first; // position du premier caractère du mot
51:                      unsigned char next; // position du du curseur de l'analyseur.
52:                  } input_buff_t;
53:                  
54:                  static input_buff_t cmd_line;
55:                  
56:                  typedef enum CMDS {CMD_LS,CMD_RM,CMD_MV,CMD_ED,CMD_AS,CMD_RUN,
57:                                     CMD_CP,CMD_SND,CMD_RCV,CMD_FORTH} cmds_t;
58:                  
59:                  #define CMD_LEN 10
60:                  const char *commands[CMD_LEN]={
61:                      "ls","rm","mv","ed","as","run","cp","snd","rcv","forth"};
62:                  
63:                  int cmd_search(char *target){
9D00E0AC  27BDFFD8   ADDIU SP, SP, -40
9D00E0B0  AFBF0024   SW RA, 36(SP)
9D00E0B4  AFB30020   SW S3, 32(SP)
9D00E0B8  AFB2001C   SW S2, 28(SP)
9D00E0BC  AFB10018   SW S1, 24(SP)
9D00E0C0  AFB00014   SW S0, 20(SP)
9D00E0C4  00809021   ADDU S2, A0, ZERO
64:                      int i;
65:                      for (i=CMD_LEN-1;i>=0;i--){
9D00E0C8  3C11A000   LUI S1, -24576
9D00E0CC  26312A1C   ADDIU S1, S1, 10780
9D00E0D0  24100009   ADDIU S0, ZERO, 9
9D00E0D4  2413FFFF   ADDIU S3, ZERO, -1
9D00E0EC  2610FFFF   ADDIU S0, S0, -1
9D00E0F0  1613FFF9   BNE S0, S3, 0x9D00E0D8
9D00E0F4  2631FFFC   ADDIU S1, S1, -4
66:                          if (!strcmp(target,commands[i])){
9D00E0D8  02402021   ADDU A0, S2, ZERO
9D00E0DC  0F403B19   JAL 0x9D00EC64
9D00E0E0  8E250000   LW A1, 0(S1)
9D00E0E4  10400005   BEQ V0, ZERO, 0x9D00E0FC
9D00E0E8  02001021   ADDU V0, S0, ZERO
67:                              break;
68:                          }
69:                      }
70:                      return i;
71:                  }//cmd_search()
9D00E0F8  02001021   ADDU V0, S0, ZERO
9D00E0FC  8FBF0024   LW RA, 36(SP)
9D00E100  8FB30020   LW S3, 32(SP)
9D00E104  8FB2001C   LW S2, 28(SP)
9D00E108  8FB10018   LW S1, 24(SP)
9D00E10C  8FB00014   LW S0, 20(SP)
9D00E110  03E00008   JR RA
9D00E114  27BD0028   ADDIU SP, SP, 40
72:                  
73:                  int next_token(void){
74:                      cmd_line.first=cmd_line.next;
9D00E118  3C03A000   LUI V1, -24576
9D00E11C  246329A4   ADDIU V1, V1, 10660
9D00E120  90620052   LBU V0, 82(V1)
9D00E124  A0620051   SB V0, 81(V1)
75:                      while (cmd_line.first<cmd_line.len && cmd_line.buff[cmd_line.first]==' '){cmd_line.first++;}
9D00E128  90640050   LBU A0, 80(V1)
9D00E12C  0044182B   SLTU V1, V0, A0
9D00E130  10600016   BEQ V1, ZERO, 0x9D00E18C
9D00E134  3C03A000   LUI V1, -24576
9D00E138  246329A4   ADDIU V1, V1, 10660
9D00E13C  00431821   ADDU V1, V0, V1
9D00E140  80650000   LB A1, 0(V1)
9D00E144  24030020   ADDIU V1, ZERO, 32
9D00E148  14A30026   BNE A1, V1, 0x9D00E1E4
9D00E14C  3C06A000   LUI A2, -24576
9D00E150  24C629A4   ADDIU A2, A2, 10660
9D00E154  24050020   ADDIU A1, ZERO, 32
9D00E158  24420001   ADDIU V0, V0, 1
9D00E15C  304200FF   ANDI V0, V0, 255
9D00E160  14440004   BNE V0, A0, 0x9D00E174
9D00E164  00461821   ADDU V1, V0, A2
9D00E168  3C03A000   LUI V1, -24576
9D00E16C  0B403863   J 0x9D00E18C
9D00E170  A06229F5   SB V0, 10741(V1)
9D00E174  80630000   LB V1, 0(V1)
9D00E178  5065FFF8   BEQL V1, A1, 0x9D00E15C
9D00E17C  24420001   ADDIU V0, V0, 1
9D00E180  3C03A000   LUI V1, -24576
9D00E184  0B403879   J 0x9D00E1E4
9D00E188  A06229F5   SB V0, 10741(V1)
76:                      cmd_line.next=cmd_line.first;
9D00E18C  3C03A000   LUI V1, -24576
9D00E190  0B403876   J 0x9D00E1D8
9D00E194  A06229F6   SB V0, 10742(V1)
9D00E1E4  3C03A000   LUI V1, -24576
9D00E1E8  246329A4   ADDIU V1, V1, 10660
9D00E1EC  A0620052   SB V0, 82(V1)
77:                      while (cmd_line.next<cmd_line.len && cmd_line.buff[cmd_line.next]!=' '){cmd_line.next++;}
9D00E198  3C07A000   LUI A3, -24576
9D00E19C  24E729A4   ADDIU A3, A3, 10660
9D00E1A0  24060020   ADDIU A2, ZERO, 32
9D00E1A4  24630001   ADDIU V1, V1, 1
9D00E1A8  306300FF   ANDI V1, V1, 255
9D00E1AC  0064282B   SLTU A1, V1, A0
9D00E1B0  10A00006   BEQ A1, ZERO, 0x9D00E1CC
9D00E1B4  00672821   ADDU A1, V1, A3
9D00E1B8  80A50000   LB A1, 0(A1)
9D00E1BC  54A6FFFA   BNEL A1, A2, 0x9D00E1A8
9D00E1C0  24630001   ADDIU V1, V1, 1
9D00E1CC  3C04A000   LUI A0, -24576
9D00E1D0  A08329F6   SB V1, 10742(A0)
9D00E1F0  00431821   ADDU V1, V0, V1
9D00E1F4  80660000   LB A2, 0(V1)
9D00E1F8  24050020   ADDIU A1, ZERO, 32
9D00E1FC  14C5FFE6   BNE A2, A1, 0x9D00E198
9D00E200  00401821   ADDU V1, V0, ZERO
78:                      if (cmd_line.next<(cmd_line.len)){
79:                          cmd_line.buff[cmd_line.next++]=(char)(0);
9D00E1C4  0B403882   J 0x9D00E208
9D00E1C8  3C04A000   LUI A0, -24576
9D00E204  3C04A000   LUI A0, -24576
9D00E208  248429A4   ADDIU A0, A0, 10660
9D00E20C  00642821   ADDU A1, V1, A0
9D00E210  A0A00000   SB ZERO, 0(A1)
9D00E214  24630001   ADDIU V1, V1, 1
9D00E218  0B403875   J 0x9D00E1D4
9D00E21C  A0830052   SB V1, 82(A0)
80:                      }
81:                      if (cmd_line.next>cmd_line.first)
9D00E1D4  3C03A000   LUI V1, -24576
82:                          return 1;
9D00E1D8  906329F6   LBU V1, 10742(V1)
83:                      else
84:                          return 0;
85:                  }//next_token()
9D00E1DC  03E00008   JR RA
9D00E1E0  0043102B   SLTU V0, V0, V1
86:                  
87:                  void parse_execute(void){
9D00E220  27BDFFE0   ADDIU SP, SP, -32
9D00E224  AFBF001C   SW RA, 28(SP)
9D00E228  AFB10018   SW S1, 24(SP)
9D00E22C  AFB00014   SW S0, 20(SP)
88:                      while (next_token()){
9D00E238  0B403896   J 0x9D00E258
9D00E23C  24110009   ADDIU S1, ZERO, 9
9D00E258  0F403846   JAL next_token
9D00E25C  00000000   NOP
9D00E260  5440FFF7   BNEL V0, ZERO, 0x9D00E240
9D00E264  92040051   LBU A0, 81(S0)
89:                          switch (cmd_search(&cmd_line.buff[cmd_line.first])){
9D00E230  3C10A000   LUI S0, -24576
9D00E234  261029A4   ADDIU S0, S0, 10660
9D00E240  0F40382B   JAL cmd_search
9D00E244  02042021   ADDU A0, S0, A0
9D00E248  14510003   BNE V0, S1, 0x9D00E258
9D00E24C  00000000   NOP
90:                              case CMD_LS:
91:                                  break;
92:                              case CMD_RM:
93:                                  break;
94:                              case CMD_MV:
95:                                  break;
96:                              case CMD_ED:
97:                                  break;
98:                              case CMD_AS:
99:                                  break;
100:                             case CMD_FORTH:
101:                                 cold();
9D00E250  0F400BB2   JAL cold
9D00E254  00000000   NOP
102:                                 break;
103:                             case CMD_RUN:
104:                                 break;
105:                             case CMD_SND:
106:                                 break;
107:                             case CMD_RCV:
108:                                 break;
109:                             case CMD_CP:
110:                                 break;
111:                         }
112:                     }
113:                 }// parse_execute()
9D00E268  8FBF001C   LW RA, 28(SP)
9D00E26C  8FB10018   LW S1, 24(SP)
9D00E270  8FB00014   LW S0, 20(SP)
9D00E274  03E00008   JR RA
9D00E278  27BD0020   ADDIU SP, SP, 32
114:                 
115:                 const char *prompt="\r#";
116:                 
117:                 void shell(void){
9D00E27C  27BDFFE8   ADDIU SP, SP, -24
9D00E280  AFBF0014   SW RA, 20(SP)
9D00E284  AFB00010   SW S0, 16(SP)
118:                     int len;
119:                     print(comm_channel,"VPC-32 shell\r");
9D00E288  83848064   LB A0, -32668(GP)
9D00E28C  3C059D01   LUI A1, -25343
9D00E290  0F402601   JAL print
9D00E294  24A5F968   ADDIU A1, A1, -1688
120:                     while (1){
121:                         print(comm_channel,prompt);
9D00E2A0  83848064   LB A0, -32668(GP)
9D00E2A4  0F402601   JAL print
9D00E2A8  8F85800C   LW A1, -32756(GP)
9D00E2D4  0B4038A9   J 0x9D00E2A4
9D00E2D8  83848064   LB A0, -32668(GP)
122:                         cmd_line.first=0;
9D00E298  3C10A000   LUI S0, -24576
9D00E29C  261029A4   ADDIU S0, S0, 10660
9D00E2AC  A2000051   SB ZERO, 81(S0)
123:                         cmd_line.next=0;
9D00E2B0  A2000052   SB ZERO, 82(S0)
124:                         cmd_line.len=readline(comm_channel,cmd_line.buff,CHAR_PER_LINE);
9D00E2B4  83848064   LB A0, -32668(GP)
9D00E2B8  02002821   ADDU A1, S0, ZERO
9D00E2BC  0F40274D   JAL readline
9D00E2C0  24060035   ADDIU A2, ZERO, 53
125:                         if (cmd_line.len){
9D00E2C4  1040FFF6   BEQ V0, ZERO, 0x9D00E2A0
9D00E2C8  A2020050   SB V0, 80(S0)
126:                             parse_execute();
9D00E2CC  0F403888   JAL parse_execute
9D00E2D0  00000000   NOP
127:                         }
128:                     }//while(1)
129:                 }//shell()
130:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/serial_comm.c  ---------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   uart.h
20:                   * Author: Jacques Deschênes
21:                   * Description: fonctions de bas niveau pour communication UART avec le PC
22:                   * Created on 17 avril 2013, 14:48
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "serial_comm.h"
27:                  #include "HardwareProfile.h"
28:                  
29:                  static char unget;
30:                  
31:                  void UartInit(UART_MODULE channel, int baudrate, UART_LINE_CONTROL_MODE LineCtrl){
9D00CA28  27BDFFE0   ADDIU SP, SP, -32
9D00CA2C  AFBF001C   SW RA, 28(SP)
9D00CA30  AFB20018   SW S2, 24(SP)
9D00CA34  AFB10014   SW S1, 20(SP)
9D00CA38  AFB00010   SW S0, 16(SP)
9D00CA3C  00808021   ADDU S0, A0, ZERO
9D00CA40  00A09021   ADDU S2, A1, ZERO
9D00CA44  00C08821   ADDU S1, A2, ZERO
32:                  /*initialise le périphérique UART*/
33:                     // Configure UART, information dans uart.h
34:                     UARTConfigure(channel, UART_ENABLE_PINS_TX_RX_ONLY); // pas de contrôle de flux matériel.
9D00CA48  0F403E89   JAL UARTConfigure
9D00CA4C  00002821   ADDU A1, ZERO, ZERO
35:                     UARTSetLineControl(channel, LineCtrl);
9D00CA50  02002021   ADDU A0, S0, ZERO
9D00CA54  0F403F5F   JAL UARTSetLineControl
9D00CA58  02202821   ADDU A1, S1, ZERO
36:                     UARTSetDataRate(channel, mGetPeripheralClock(), baudrate);
9D00CA5C  02002021   ADDU A0, S0, ZERO
9D00CA60  3C05023C   LUI A1, 572
9D00CA64  24A53460   ADDIU A1, A1, 13408
9D00CA68  0F403DBD   JAL UARTSetDataRate
9D00CA6C  02403021   ADDU A2, S2, ZERO
37:                     // activation du périphérique
38:                     UARTEnable(channel, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D00CA70  02002021   ADDU A0, S0, ZERO
9D00CA74  0F403D84   JAL UARTEnable
9D00CA78  24050087   ADDIU A1, ZERO, 135
39:                     unget=-1;
9D00CA7C  2402FFFF   ADDIU V0, ZERO, -1
9D00CA80  A3828058   SB V0, -32680(GP)
40:                  };
9D00CA84  8FBF001C   LW RA, 28(SP)
9D00CA88  8FB20018   LW S2, 24(SP)
9D00CA8C  8FB10014   LW S1, 20(SP)
9D00CA90  8FB00010   LW S0, 16(SP)
9D00CA94  03E00008   JR RA
9D00CA98  27BD0020   ADDIU SP, SP, 32
41:                  
42:                  char UartGetch(UART_MODULE channel){
43:                  /*lecture d'un caractère retourne 0 si aucun disponible*/
44:                      char ch;
45:                      if (!unget==-1) {
46:                          ch=unget;
47:                          unget=-1;
48:                          return ch;
49:                      }else{
50:                          if (UARTReceivedDataIsAvailable (channel)){
9D00CAB8  10800003   BEQ A0, ZERO, 0x9D00CAC8
9D00CABC  00001021   ADDU V0, ZERO, ZERO
51:                                 return UARTGetDataByte(channel);
9D00CAC4  7C021420   SEB V0, V0
52:                          }else{
53:                              return 0;
54:                          }
55:                      }
56:                  };
9D00CAC8  03E00008   JR RA
9D00CACC  00000000   NOP
57:                  
58:                  void UartPutch(UART_MODULE channel, char c){
9D00CAD0  7C052C20   SEB A1, A1
59:                  /*Envoie d'un caractère*/
60:                      while(!UARTTransmitterIsReady(channel));
9D00CAF0  1440FFFD   BNE V0, ZERO, 0x9D00CAE8
9D00CAF4  00000000   NOP
61:                        UARTSendDataByte(channel, c);
62:                  };
9D00CB00  03E00008   JR RA
9D00CB04  00000000   NOP
63:                  
64:                  char UartWaitch(UART_MODULE channel, int delay){
9D00CB08  27BDFFE0   ADDIU SP, SP, -32
9D00CB0C  AFBF001C   SW RA, 28(SP)
9D00CB10  AFB10018   SW S1, 24(SP)
9D00CB14  AFB00014   SW S0, 20(SP)
9D00CB18  00808021   ADDU S0, A0, ZERO
65:                  /*attend un caractère pour un temps spécifié par delay
66:                  *retourne 0 si aucun reçu avant expiration du délais
67:                  */
68:                      int t;
69:                      char ch;
70:                      if (!unget==-1){
71:                          ch=unget;
72:                          unget=-1;
73:                          return unget;
74:                      }
75:                      if (!delay) while (1) if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D00CB1C  14A0000D   BNE A1, ZERO, 0x9D00CB54
9D00CB20  00A08821   ADDU S1, A1, ZERO
9D00CB40  1040FFFD   BEQ V0, ZERO, 0x9D00CB38
9D00CB44  00000000   NOP
9D00CB4C  0B4032E7   J 0x9D00CB9C
9D00CB50  7C021420   SEB V0, V0
76:                      t=ticks()+delay;
9D00CB54  0F40355C   JAL ticks
9D00CB58  00108080   SLL S0, S0, 2
77:                      while (ticks()<delay){
9D00CB64  0B4032E2   J 0x9D00CB88
9D00CB68  02028021   ADDU S0, S0, V0
9D00CB88  0F40355C   JAL ticks
9D00CB8C  00000000   NOP
9D00CB90  0051102B   SLTU V0, V0, S1
9D00CB94  5440FFF5   BNEL V0, ZERO, 0x9D00CB6C
9D00CB98  8E020000   LW V0, 0(S0)
78:                         if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D00CB74  10600004   BEQ V1, ZERO, 0x9D00CB88
9D00CB78  00000000   NOP
9D00CB80  0B4032E7   J 0x9D00CB9C
9D00CB84  7C021420   SEB V0, V0
79:                      }
80:                      return 0;
81:                  }
9D00CB9C  8FBF001C   LW RA, 28(SP)
9D00CBA0  8FB10018   LW S1, 24(SP)
9D00CBA4  8FB00014   LW S0, 20(SP)
9D00CBA8  03E00008   JR RA
9D00CBAC  27BD0020   ADDIU SP, SP, 32
82:                  
83:                  void UartPrint(UART_MODULE channel, const char* str){
84:                  /* envoie la chaine de caractère str via le UART */
85:                     while(*str != (char)0)
9D00CBB0  80A60000   LB A2, 0(A1)
9D00CBB4  10C0000F   BEQ A2, ZERO, 0x9D00CBF4
9D00CBB8  00041880   SLL V1, A0, 2
9D00CBE8  80A60000   LB A2, 0(A1)
9D00CBEC  14C0FFF7   BNE A2, ZERO, 0x9D00CBCC
9D00CBF0  00000000   NOP
86:                     {
87:                        while(!UARTTransmitterIsReady(channel));
9D00CBD4  1440FFFD   BNE V0, ZERO, 0x9D00CBCC
9D00CBD8  00000000   NOP
88:                        UARTSendDataByte(channel, *str++);
9D00CBDC  24A50001   ADDIU A1, A1, 1
89:                     }
90:                     while(!UARTTransmissionHasCompleted(channel));
9D00CC10  1040FFFD   BEQ V0, ZERO, 0x9D00CC08
9D00CC14  00000000   NOP
91:                  };
9D00CC18  03E00008   JR RA
9D00CC1C  00000000   NOP
92:                  
93:                  int UartReadln(UART_MODULE channel, char *buffer, int buff_len){
9D00CC20  27BDFFD0   ADDIU SP, SP, -48
9D00CC24  AFBF002C   SW RA, 44(SP)
9D00CC28  AFB50028   SW S5, 40(SP)
9D00CC2C  AFB40024   SW S4, 36(SP)
9D00CC30  AFB30020   SW S3, 32(SP)
9D00CC34  AFB2001C   SW S2, 28(SP)
9D00CC38  AFB10018   SW S1, 24(SP)
9D00CC3C  AFB00014   SW S0, 20(SP)
9D00CC40  00809821   ADDU S3, A0, ZERO
9D00CC44  00A0A021   ADDU S4, A1, ZERO
9D00CC48  00C08821   ADDU S1, A2, ZERO
94:                  /* lecture d'une chaine se terminant par '\r'
95:                   *  complète la chaine avec un zéro
96:                   *  retourne le nombre de caractère dans le buffer.
97:                   */
98:                      int count=0;
9D00CC4C  00008021   ADDU S0, ZERO, ZERO
99:                      char c;
100:                     if (!unget==-1){
101:                         c=unget;
102:                         unget=-1;
103:                         *buffer++=c;
104:                         if (c==CR) return;
105:                     }
106:                     while (count < (buff_len-1)){
9D00CC60  0B403337   J 0x9D00CCDC
9D00CC64  3C159D01   LUI S5, -25343
9D00CCC4  0B403338   J 0x9D00CCE0
9D00CCC8  2622FFFF   ADDIU V0, S1, -1
9D00CCDC  2622FFFF   ADDIU V0, S1, -1
9D00CCE0  0202102A   SLT V0, S0, V0
9D00CCE4  5440FFE0   BNEL V0, ZERO, 0x9D00CC68
9D00CCE8  8E420000   LW V0, 0(S2)
107:                         if (UARTReceivedDataIsAvailable(channel)){
9D00CC70  5060001B   BEQL V1, ZERO, 0x9D00CCE0
9D00CC74  2622FFFF   ADDIU V0, S1, -1
108:                             c = UARTGetDataByte(channel);
9D00CC7C  7C052C20   SEB A1, A1
109:                             if (c==CR){UartPutch(channel,'\r'); break;}
9D00CC80  2402000D   ADDIU V0, ZERO, 13
9D00CC84  14A20006   BNE A1, V0, 0x9D00CCA0
9D00CC88  24020008   ADDIU V0, ZERO, 8
9D00CC8C  02602021   ADDU A0, S3, ZERO
9D00CC90  0F4032B4   JAL UartPutch
9D00CC94  2405000D   ADDIU A1, ZERO, 13
9D00CC98  0B40333B   J 0x9D00CCEC
9D00CC9C  00000000   NOP
110:                             if (c==BS){
9D00CCA0  54A2000A   BNEL A1, V0, 0x9D00CCCC
9D00CCA4  A2850000   SB A1, 0(S4)
111:                                 if (count){
9D00CCA8  5200000D   BEQL S0, ZERO, 0x9D00CCE0
9D00CCAC  2622FFFF   ADDIU V0, S1, -1
112:                                     buffer--;
9D00CCB0  2694FFFF   ADDIU S4, S4, -1
113:                                     count--;
9D00CCB4  2610FFFF   ADDIU S0, S0, -1
114:                                     UartPrint(channel,"\b \b");
9D00CCB8  02602021   ADDU A0, S3, ZERO
9D00CCBC  0F4032EC   JAL UartPrint
9D00CCC0  26A50084   ADDIU A1, S5, 132
115:                                 }
116:                             }else{
117:                                 *buffer++=c;
9D00CCCC  26940001   ADDIU S4, S4, 1
118:                                 count++;
9D00CCD0  26100001   ADDIU S0, S0, 1
119:                                 UartPutch(channel,c);
9D00CCD4  0F4032B4   JAL UartPutch
9D00CCD8  02602021   ADDU A0, S3, ZERO
120:                             }
121:                             
122:                         }
123:                     }
124:                     if (count) *buffer = (char)0;
9D00CCEC  56000001   BNEL S0, ZERO, 0x9D00CCF4
9D00CCF0  A2800000   SB ZERO, 0(S4)
125:                     UartPutch(channel,'\r');
9D00CCF4  02602021   ADDU A0, S3, ZERO
9D00CCF8  0F4032B4   JAL UartPutch
9D00CCFC  2405000D   ADDIU A1, ZERO, 13
126:                     return count;
127:                 }
9D00CD00  02001021   ADDU V0, S0, ZERO
9D00CD04  8FBF002C   LW RA, 44(SP)
9D00CD08  8FB50028   LW S5, 40(SP)
9D00CD0C  8FB40024   LW S4, 36(SP)
9D00CD10  8FB30020   LW S3, 32(SP)
9D00CD14  8FB2001C   LW S2, 28(SP)
9D00CD18  8FB10018   LW S1, 24(SP)
9D00CD1C  8FB00014   LW S0, 20(SP)
9D00CD20  03E00008   JR RA
9D00CD24  27BD0030   ADDIU SP, SP, 48
128:                 
129:                 int UartReceivedBreak(UART_MODULE channel){
130:                    char ch;
131:                    if (unget==-1 && UARTReceivedDataIsAvailable(channel)) {
9D00CD28  83858058   LB A1, -32680(GP)
9D00CD2C  2403FFFF   ADDIU V1, ZERO, -1
9D00CD30  14A30011   BNE A1, V1, 0x9D00CD78
9D00CD34  00001021   ADDU V0, ZERO, ZERO
9D00CD54  10800008   BEQ A0, ZERO, 0x9D00CD78
9D00CD58  00001021   ADDU V0, ZERO, ZERO
132:                        ch=UARTGetDataByte(channel);
9D00CD60  7C031C20   SEB V1, V1
133:                        if (ch==ESC) return 1; else unget=ch;
9D00CD64  2404001B   ADDIU A0, ZERO, 27
9D00CD68  10640003   BEQ V1, A0, 0x9D00CD78
9D00CD6C  24020001   ADDIU V0, ZERO, 1
9D00CD70  A3838058   SB V1, -32680(GP)
134:                    }
135:                    return 0;
9D00CD74  00001021   ADDU V0, ZERO, ZERO
136:                 }
9D00CD78  03E00008   JR RA
9D00CD7C  00000000   NOP
137:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/ntsc.c  ----------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /* 
19:                   * File:   test-ntsc.c
20:                   * Author: Jacques Deschênes
21:                   * Description: test génération signal vidéo NTSC sur PIC32MX150F128B.
22:                   * Created on 20 août 2013, 08:48
23:                   */
24:                  
25:                  #include <stdio.h>
26:                  #include <stdlib.h>
27:                  #include <sys/attribs.h>
28:                  #include <plib.h>
29:                  #include "HardwareProfile.h"
30:                  #include "ntsc.h"
31:                  
32:                  /*
33:                   *  la fréqueence PBCLK influence la largeur des pixels vidéo. Comme PBCLK==SYSCLK
34:                   *  on peut allonger les pixels en diminuant la fréquence légèrement.
35:                   *  pour une résolution horizontale de 320 pixels et une fréquence de 40Mhz le
36:                   *  meilleur diviseur pour le générateur BGR du SPI est de 2 ce qui donne
37:                   *  une fréquence de pixel de  40e6/(2*(2+1)=6,67Mhz et la durée total d'une
38:                   *  ligne vidéo est donc de 320/6,67e6= 48µSec.
39:                   *  En principe pour le standard NTSC on dispose de 52µSec par ligne vidéo.
40:                   *  En pratique on est plutôt à 51µSec. Donc ici on a 3µSec inutilisées.
41:                   *  en résuidant SYSCLK à 37,5Mhz on a 51,2µSec par ligne vidéo. Les pixels
42:                   *  sont donc moins compressé horizontalement. Mais sur certains téléviseurs
43:                   *  on peut perdre quelques pixels en bout de ligne.
44:                   *  la constante SPI_DLY doit-être ajustée en fonction de PBCLK pour que les
45:                   *  320 pixels horizontals soient visibles.
46:                   */
47:                  
48:                  #define PWM_PERIOD (SYSCLK/15748)-1
49:                  #define HSYNC  (SYSCLK/212766)  // 4,7µSec
50:                  #define FIRST_LINE 27   //première ligne de scan visible
51:                  #define LAST_LINE  256  // dernière ligne de scan visible
52:                  #define BITCLK HRES * 1000000L/52 // 52µSec c'est le temps que dure 1 ligne vidéo.
53:                  #if SYSCLK==40000000L
54:                  #define SPI_DLY HSYNC+90 // délais en début de ligne avant l'envoie du signal vidéo.
55:                  #else
56:                  #define SPI_DLY HSYNC+30 // délais en début de ligne avant l'envoie du signal vidéo.
57:                  #endif
58:                  #define _enable_video_out()  SPI1CONSET =(1<<15)
59:                  #define _disable_video_out() SPI1CONCLR =(1<<15)
60:                  
61:                  unsigned int video_bmp[VRES][HRES/32]; // video bitmap 7168 octets
62:                  volatile unsigned int ln_cnt;
63:                  volatile unsigned int video;
64:                  volatile int *DmaSrc;
65:                  
66:                  
67:                  
68:                  void VideoInit(void){
9D00CD80  27BDFFD8   ADDIU SP, SP, -40
9D00CD84  AFBF0024   SW RA, 36(SP)
9D00CD88  AFB20020   SW S2, 32(SP)
9D00CD8C  AFB1001C   SW S1, 28(SP)
9D00CD90  AFB00018   SW S0, 24(SP)
69:                      //configuration PWM sur OC2 pour SYNC, utilisation TIMER2
70:                      T2CON = 0;
9D00CD94  3C02BF80   LUI V0, -16512
9D00CD98  AC400800   SW ZERO, 2048(V0)
71:                      PR2=PWM_PERIOD;
9D00CD9C  2403094C   ADDIU V1, ZERO, 2380
9D00CDA0  3C02BF80   LUI V0, -16512
9D00CDA4  AC430820   SW V1, 2080(V0)
72:                      OC2CONbits.OCM = 5; // mode train d'impulsion
9D00CDA8  3C02BF80   LUI V0, -16512
9D00CDAC  8C433200   LW V1, 12800(V0)
9D00CDB0  24120005   ADDIU S2, ZERO, 5
9D00CDB4  7E431004   INS V1, S2, 0, 3
9D00CDB8  AC433200   SW V1, 12800(V0)
73:                      OC2RS = 0; 
9D00CDBC  3C03BF80   LUI V1, -16512
9D00CDC0  AC603220   SW ZERO, 12832(V1)
74:                      OC2R = HSYNC;
9D00CDC4  240400B0   ADDIU A0, ZERO, 176
9D00CDC8  3C03BF80   LUI V1, -16512
9D00CDCC  AC643210   SW A0, 12816(V1)
75:                      IFS0bits.T2IF=0;
9D00CDD0  3C03BF88   LUI V1, -16504
9D00CDD4  8C641030   LW A0, 4144(V1)
9D00CDD8  7C044A44   INS A0, ZERO, 9, 1
9D00CDDC  AC641030   SW A0, 4144(V1)
76:                      IEC0bits.T2IE=1;
9D00CDE0  3C03BF88   LUI V1, -16504
9D00CDE4  8C641060   LW A0, 4192(V1)
9D00CDE8  24110001   ADDIU S1, ZERO, 1
9D00CDEC  7E244A44   INS A0, S1, 9, 1
9D00CDF0  AC641060   SW A0, 4192(V1)
77:                      IPC2bits.T2IP=7;
9D00CDF4  3C03BF88   LUI V1, -16504
9D00CDF8  8C6410B0   LW A0, 4272(V1)
9D00CDFC  24050007   ADDIU A1, ZERO, 7
9D00CE00  7CA42084   INS A0, A1, 2, 3
9D00CE04  AC6410B0   SW A0, 4272(V1)
78:                      IPC2bits.T2IS=3;
9D00CE08  8C6410B0   LW A0, 4272(V1)
9D00CE0C  24050003   ADDIU A1, ZERO, 3
9D00CE10  7CA40804   INS A0, A1, 0, 2
9D00CE14  AC6410B0   SW A0, 4272(V1)
79:                      OC2CONbits.ON =1;  // activation
9D00CE18  8C433200   LW V1, 12800(V0)
9D00CE1C  7E237BC4   INS V1, S1, 15, 1
9D00CE20  AC433200   SW V1, 12800(V0)
80:                      T2CONbits.ON=1;  // activation
9D00CE24  3C02BF80   LUI V0, -16512
9D00CE28  8C430800   LW V1, 2048(V0)
9D00CE2C  7E237BC4   INS V1, S1, 15, 1
9D00CE30  AC430800   SW V1, 2048(V0)
81:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
82:                      OC1CONbits.OCM = 5; //mode train d'impulsion
9D00CE34  3C02BF80   LUI V0, -16512
9D00CE38  8C433000   LW V1, 12288(V0)
9D00CE3C  7E431004   INS V1, S2, 0, 3
9D00CE40  AC433000   SW V1, 12288(V0)
83:                      OC1RS=0;
9D00CE44  3C03BF80   LUI V1, -16512
9D00CE48  AC603020   SW ZERO, 12320(V1)
84:                      OC1R=HSYNC+SPI_DLY;
9D00CE4C  2404017E   ADDIU A0, ZERO, 382
9D00CE50  3C03BF80   LUI V1, -16512
9D00CE54  AC643010   SW A0, 12304(V1)
85:                      OC1CONbits.ON=1;
9D00CE58  8C433000   LW V1, 12288(V0)
9D00CE5C  7E237BC4   INS V1, S1, 15, 1
9D00CE60  AC433000   SW V1, 12288(V0)
86:                      // configuration SPI pour sortie vidéo
87:                      // configure le DMA
88:                      DmaChnOpen(0,0,DMA_OPEN_DEFAULT);
9D00CE64  00002021   ADDU A0, ZERO, ZERO
9D00CE68  00002821   ADDU A1, ZERO, ZERO
9D00CE6C  0F403C69   JAL DmaChnOpen
9D00CE70  00003021   ADDU A2, ZERO, ZERO
89:                      DmaChnSetEventControl(0,DMA_EV_START_IRQ_EN|
9D00CE74  00002021   ADDU A0, ZERO, ZERO
9D00CE78  0F403F1E   JAL DmaChnWriteEventControlFlags
9D00CE7C  24052610   ADDIU A1, ZERO, 9744
90:                                            DMA_EV_START_IRQ(_SPI1_TX_IRQ));
91:                      DmaChnSetTxfer(0,(void *)DmaSrc,(void *)&SPI1BUF,HRES/8,4,4);
9D00CE80  24020004   ADDIU V0, ZERO, 4
9D00CE84  AFA20010   SW V0, 16(SP)
9D00CE88  AFA20014   SW V0, 20(SP)
9D00CE8C  00002021   ADDU A0, ZERO, ZERO
9D00CE90  8F8580B8   LW A1, -32584(GP)
9D00CE94  3C06BF80   LUI A2, -16512
9D00CE98  24C65820   ADDIU A2, A2, 22560
9D00CE9C  0F403D5E   JAL DmaChnSetTxfer
9D00CEA0  24070028   ADDIU A3, ZERO, 40
92:                      // configuration du SPI canal 1
93:                      SPI1CONbits.DISSDI=1; // SDI n'est pas utilisé.
9D00CEA4  3C10BF80   LUI S0, -16512
9D00CEA8  8E025800   LW V0, 22528(S0)
9D00CEAC  7E222104   INS V0, S1, 4, 1
9D00CEB0  AE025800   SW V0, 22528(S0)
94:                      SPI1CONbits.FRMEN=1; // frame mode
9D00CEB4  8E025800   LW V0, 22528(S0)
9D00CEB8  7E22FFC4   INS V0, S1, 31, 1
9D00CEBC  AE025800   SW V0, 22528(S0)
95:                      SPI1CONbits.FRMCNT=5; // 32 octets par frame.
9D00CEC0  8E025800   LW V0, 22528(S0)
9D00CEC4  7E42D604   INS V0, S2, 24, 3
9D00CEC8  AE025800   SW V0, 22528(S0)
96:                      SPI1CONbits.FRMPOL=1; // sync sur transition montante
9D00CECC  8E025800   LW V0, 22528(S0)
9D00CED0  7E22EF44   INS V0, S1, 29, 1
9D00CED4  AE025800   SW V0, 22528(S0)
97:                      SPI1CONbits.FRMSYNC=1; // synchronisation esclave
9D00CED8  8E025800   LW V0, 22528(S0)
9D00CEDC  7E22F784   INS V0, S1, 30, 1
9D00CEE0  AE025800   SW V0, 22528(S0)
98:                      SPI1CONbits.MSTEN=1; // SPI maître
9D00CEE4  8E025800   LW V0, 22528(S0)
9D00CEE8  7E222944   INS V0, S1, 5, 1
9D00CEEC  AE025800   SW V0, 22528(S0)
99:                     // SPI1CONbits.SPIFE=1; // synchronisation sur clock premier bit.
100:                     SPI1CONbits.MODE32=1; // mode 32 bits
9D00CEF0  8E025800   LW V0, 22528(S0)
9D00CEF4  7E225AC4   INS V0, S1, 11, 1
9D00CEF8  AE025800   SW V0, 22528(S0)
101:                     SPI1CONbits.STXISEL=1; // interruption sur TBE
9D00CEFC  8E025800   LW V0, 22528(S0)
9D00CF00  7E221884   INS V0, S1, 2, 2
9D00CF04  AE025800   SW V0, 22528(S0)
102:                     SpiChnSetBitRate(SPI_CHANNEL1, PBCLK, BITCLK);
9D00CF08  24040001   ADDIU A0, ZERO, 1
9D00CF0C  3C05023C   LUI A1, 572
9D00CF10  24A53460   ADDIU A1, A1, 13408
9D00CF14  3C06005D   LUI A2, 93
9D00CF18  0F403E7A   JAL SpiChnSetBitRate
9D00CF1C  34C6E676   ORI A2, A2, -6538
103:                     SPI1CONbits.ON=1;
9D00CF20  8E025800   LW V0, 22528(S0)
9D00CF24  7E227BC4   INS V0, S1, 15, 1
9D00CF28  AE025800   SW V0, 22528(S0)
104:                 }//init_video()
9D00CF2C  8FBF0024   LW RA, 36(SP)
9D00CF30  8FB20020   LW S2, 32(SP)
9D00CF34  8FB1001C   LW S1, 28(SP)
9D00CF38  8FB00018   LW S0, 24(SP)
9D00CF3C  03E00008   JR RA
9D00CF40  27BD0028   ADDIU SP, SP, 40
105:                 
106:                 
107:                 
108:                 void __ISR(_TIMER_2_VECTOR,IPL7AUTO) tmr2_isr(void){
9D00CF44  415DE800   RDPGPR SP, SP
9D00CF48  401B7000   MFC0 K1, EPC
9D00CF4C  401A6002   MFC0 K0, SRSCtl
9D00CF50  27BDFFE0   ADDIU SP, SP, -32
9D00CF54  401B6000   MFC0 K1, Status
9D00CF58  AFBA001C   SW K0, 28(SP)
9D00CF5C  AFBB0018   SW K1, 24(SP)
9D00CF60  7C1B7844   INS K1, ZERO, 1, 15
9D00CF64  377B1C00   ORI K1, K1, 7168
9D00CF68  409B6000   MTC0 K1, Status
9D00CF6C  AFA30008   SW V1, 8(SP)
9D00CF70  AFA20004   SW V0, 4(SP)
9D00CF74  AFA4000C   SW A0, 12(SP)
109:                     _disable_video_out();
9D00CF78  34038000   ORI V1, ZERO, -32768
9D00CF7C  3C02BF80   LUI V0, -16512
9D00CF80  AC435804   SW V1, 22532(V0)
110:                     ln_cnt++;
9D00CF84  8F8280C0   LW V0, -32576(GP)
9D00CF88  24420001   ADDIU V0, V0, 1
9D00CF8C  AF8280C0   SW V0, -32576(GP)
111:                     switch (ln_cnt){
9D00CF90  8F8280C0   LW V0, -32576(GP)
9D00CF94  2403001A   ADDIU V1, ZERO, 26
9D00CF98  1043001C   BEQ V0, V1, 0x9D00D00C
9D00CF9C  2C43001B   SLTIU V1, V0, 27
9D00CFA0  10600009   BEQ V1, ZERO, 0x9D00CFC8
9D00CFA4  24030101   ADDIU V1, ZERO, 257
9D00CFA8  24030001   ADDIU V1, ZERO, 1
9D00CFAC  1043000D   BEQ V0, V1, 0x9D00CFE4
9D00CFB0  2403089C   ADDIU V1, ZERO, 2204
9D00CFB4  24030004   ADDIU V1, ZERO, 4
9D00CFB8  1443001D   BNE V0, V1, 0x9D00D030
9D00CFBC  240300B0   ADDIU V1, ZERO, 176
9D00CFC8  10430016   BEQ V0, V1, 0x9D00D024
9D00CFCC  00000000   NOP
9D00CFD0  24030106   ADDIU V1, ZERO, 262
9D00CFD4  14430016   BNE V0, V1, 0x9D00D030
9D00CFD8  00000000   NOP
9D00CFDC  0B403400   J 0x9D00D000
9D00CFE0  00000000   NOP
112:                         case 1:  // début vsync
113:                             OC2R=PWM_PERIOD-HSYNC;
9D00CFE4  3C02BF80   LUI V0, -16512
9D00CFE8  AC433210   SW V1, 12816(V0)
114:                             break;
9D00CFEC  0B403421   J 0x9D00D084
9D00CFF0  24030200   ADDIU V1, ZERO, 512
115:                         case 4: // fin vsync
116:                             OC2R=HSYNC;
9D00CFC0  0B4033FD   J 0x9D00CFF4
9D00CFC4  3C02BF80   LUI V0, -16512
9D00CFF4  AC433210   SW V1, 12816(V0)
117:                             break;
9D00CFF8  0B403421   J 0x9D00D084
9D00CFFC  24030200   ADDIU V1, ZERO, 512
118:                         case 262:  //fin du frame
119:                             ln_cnt=0;
9D00D000  AF8080C0   SW ZERO, -32576(GP)
120:                             break;
9D00D004  0B403421   J 0x9D00D084
9D00D008  24030200   ADDIU V1, ZERO, 512
121:                   
122:                         case FIRST_LINE-1:
123:                             video=1;
9D00D00C  24020001   ADDIU V0, ZERO, 1
9D00D010  AF8280BC   SW V0, -32580(GP)
124:                             DmaSrc=(void*)&video_bmp[0];
9D00D014  3C02A000   LUI V0, -24576
9D00D018  2442016C   ADDIU V0, V0, 364
125:                             break;
9D00D01C  0B403420   J 0x9D00D080
9D00D020  AF8280B8   SW V0, -32584(GP)
126:                         case LAST_LINE+1:
127:                             video=0;
9D00D024  AF8080BC   SW ZERO, -32580(GP)
128:                             break;
9D00D028  0B403421   J 0x9D00D084
9D00D02C  24030200   ADDIU V1, ZERO, 512
129:                         default:
130:                             if (video){
9D00D030  8F8280BC   LW V0, -32580(GP)
9D00D034  10400012   BEQ V0, ZERO, 0x9D00D080
9D00D038  34038000   ORI V1, ZERO, -32768
131:                                 _enable_video_out();
9D00D03C  3C02BF80   LUI V0, -16512
9D00D040  AC435808   SW V1, 22536(V0)
132:                                 IFS1bits.SPI1TXIF=1;
9D00D044  3C02BF88   LUI V0, -16504
9D00D048  8C431040   LW V1, 4160(V0)
9D00D04C  24040001   ADDIU A0, ZERO, 1
9D00D050  7C833184   INS V1, A0, 6, 1
9D00D054  AC431040   SW V1, 4160(V0)
133:                                 DCH0SSA=KVA_TO_PA((void *)DmaSrc);
9D00D058  8F8280B8   LW V0, -32584(GP)
9D00D05C  7C44E000   EXT A0, V0, 0, 29
9D00D060  3C03BF88   LUI V1, -16504
9D00D064  AC643090   SW A0, 12432(V1)
134:                                 DmaSrc +=HRES/32;
9D00D068  24420028   ADDIU V0, V0, 40
9D00D06C  AF8280B8   SW V0, -32584(GP)
135:                                 DCH0CON |=128; // remplace DmaChnEnable(0); réduit le temps de latence
9D00D070  3C02BF88   LUI V0, -16504
9D00D074  8C433060   LW V1, 12384(V0)
9D00D078  34630080   ORI V1, V1, 128
9D00D07C  AC433060   SW V1, 12384(V0)
136:                             }
137:                     }//switch (ln_cnt)
138:                     mT2ClearIntFlag();
9D00D080  24030200   ADDIU V1, ZERO, 512
9D00D084  3C02BF88   LUI V0, -16504
9D00D088  AC431034   SW V1, 4148(V0)
139:                 }//tmr2_isr()
9D00D08C  8FA2001C   LW V0, 28(SP)
9D00D090  3042000F   ANDI V0, V0, 15
9D00D094  14400004   BNE V0, ZERO, 0x9D00D0A8
9D00D098  8FBB0018   LW K1, 24(SP)
9D00D09C  8FA4000C   LW A0, 12(SP)
9D00D0A0  8FA30008   LW V1, 8(SP)
9D00D0A4  8FA20004   LW V0, 4(SP)
9D00D0A8  8FBA001C   LW K0, 28(SP)
9D00D0AC  27BD0020   ADDIU SP, SP, 32
9D00D0B0  409A6002   MTC0 K0, SRSCtl
9D00D0B4  41DDE800   WRPGPR SP, SP
9D00D0B8  409B6000   MTC0 K1, Status
9D00D0BC  42000018   ERET
140:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/keyboard.c  ------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * Name: keyboard.c
20:                   * Author: Jacques Deschênes
21:                   * Description:  interface avec clavier PS/2
22:                   * Date: 2013-08-26
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "hardwareProfile.h"
27:                  #include "keyboard.h"
28:                  #include "QWERTY.h"
29:                  
30:                  #define KBD_CLK 1  // SET/CLR bit
31:                  #define KBD_DAT 2  // SET/CLR bit
32:                  
33:                  #define _wait_key() while (head==tail)
34:                  
35:                  
36:                  static  unsigned char kbd_queue[32]; // file circulaire pour les codes reçus du clavier.
37:                  volatile  static unsigned char head=0, tail=0; // tête et queue de la file
38:                  volatile  static unsigned char  in_byte=0, bit_cnt=0, parity=0;
39:                  volatile unsigned char rx_flags=0, kbd_leds=0;
40:                  volatile unsigned short key_state; // état des touches d'alteration: shift, ctrl, alt,etc.
41:                  
42:                  #define FN_COUNT 32
43:                  const short fn_keys[FN_COUNT]={CAPS_LOCK,SCROLL_LOCK,NUM_LOCK,LSHIFT,RSHIFT,LCTRL,
44:                  RCTRL,LALT,RALT,F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,PRN,PAUSE,UP_ARROW,DOWN_ARROW,
45:                  LEFT_ARROW,RIGHT_ARROW,INSERT,HOME,PGUP,PGDN,END
46:                  };
47:                  
48:                  static int KbdReset(void);
49:                  
50:                  int KeyboardInit(){ // initialisation E/S et RAZ clavier
9D0084F8  27BDFFE0   ADDIU SP, SP, -32
9D0084FC  AFBF001C   SW RA, 28(SP)
9D008500  AFB20018   SW S2, 24(SP)
9D008504  AFB10014   SW S1, 20(SP)
51:                      unsigned char c;
52:                      unsigned int t0;
53:                      t0=ticks()+750;
9D008508  0F40355C   JAL ticks
9D00850C  AFB00010   SW S0, 16(SP)
9D008510  245002EE   ADDIU S0, V0, 750
54:                      head=0;
9D008514  A380805F   SB ZERO, -32673(GP)
55:                      tail=0;
9D008518  A380805D   SB ZERO, -32675(GP)
56:                      in_byte=0;
9D00851C  A380805E   SB ZERO, -32674(GP)
57:                      bit_cnt=0;
9D008520  A380805B   SB ZERO, -32677(GP)
58:                      parity=0;
9D008524  A380805C   SB ZERO, -32676(GP)
59:                      rx_flags=0;
9D008528  A3808059   SB ZERO, -32679(GP)
60:                      kbd_leds=0;
9D00852C  A380805A   SB ZERO, -32678(GP)
61:                      key_state=0;
9D008530  A78080C8   SH ZERO, -32568(GP)
62:                      TRISASET=KBD_CLK|KBD_DAT;
9D008534  24040003   ADDIU A0, ZERO, 3
9D008538  3C02BF88   LUI V0, -16504
9D00853C  AC446018   SW A0, 24600(V0)
63:                      INTCONbits.INT4EP=0; // interruption sur transition descendante
9D008540  3C02BF88   LUI V0, -16504
9D008544  8C431000   LW V1, 4096(V0)
9D008548  7C032104   INS V1, ZERO, 4, 1
9D00854C  AC431000   SW V1, 4096(V0)
64:                      IPC4bits.INT4IP=6; // priorité 4
9D008550  3C02BF88   LUI V0, -16504
9D008554  8C4310D0   LW V1, 4304(V0)
9D008558  24050006   ADDIU A1, ZERO, 6
9D00855C  7CA3E684   INS V1, A1, 26, 3
9D008560  AC4310D0   SW V1, 4304(V0)
65:                      IPC4bits.INT4IS=3;  // sous-priorité 3.
9D008564  8C4310D0   LW V1, 4304(V0)
9D008568  7C83CE04   INS V1, A0, 24, 2
9D00856C  AC4310D0   SW V1, 4304(V0)
66:                      while (!PORTAbits.RA0);
9D008570  3C03BF88   LUI V1, -16504
9D008574  8C626020   LW V0, 24608(V1)
9D008578  30420001   ANDI V0, V0, 1
9D00857C  1040FFFD   BEQ V0, ZERO, 0x9D008574
9D008580  3C02BF88   LUI V0, -16504
67:                      IFS0bits.INT4IF=0; // RAZ indicateur interruption
9D008584  8C431030   LW V1, 4144(V0)
9D008588  7C03BDC4   INS V1, ZERO, 23, 1
9D00858C  AC431030   SW V1, 4144(V0)
68:                      IEC0SET = _IEC0_INT4IE_MASK; // activation interruption externe 4 (KBD_CLK)
9D008590  3C030080   LUI V1, 128
9D008594  3C02BF88   LUI V0, -16504
9D008598  AC431068   SW V1, 4200(V0)
69:                      while ((ticks()!=t0) && ((rx_flags & F_ERROR)==0)){
9D00859C  0B40216E   J 0x9D0085B8
9D0085A0  241100AA   ADDIU S1, ZERO, 170
9D0085B8  0F40355C   JAL ticks
9D0085BC  00000000   NOP
9D0085C0  10500005   BEQ V0, S0, 0x9D0085D8
9D0085C4  00000000   NOP
9D0085C8  93828059   LBU V0, -32679(GP)
9D0085CC  30420001   ANDI V0, V0, 1
9D0085D0  1040FFF4   BEQ V0, ZERO, 0x9D0085A4
9D0085D4  00000000   NOP
70:                          c=KbdScancode();
9D0085A4  0F401FCC   JAL KbdScancode
9D0085A8  00000000   NOP
71:                          if (c==BAT_OK){
9D0085AC  304200FF   ANDI V0, V0, 255
9D0085B0  10510026   BEQ V0, S1, 0x9D00864C
9D0085B4  24020001   ADDIU V0, ZERO, 1
72:                              return 1;
73:                          }
74:                      }
75:                      if (KbdReset())
76:                          return 1;
77:                      else
78:                          return 0;
79:                  } //KeyboardInit()
9D00864C  8FBF001C   LW RA, 28(SP)
9D008650  8FB20018   LW S2, 24(SP)
9D008654  8FB10014   LW S1, 20(SP)
9D008658  8FB00010   LW S0, 16(SP)
9D00865C  03E00008   JR RA
9D008660  27BD0020   ADDIU SP, SP, 32
80:                  
81:                  static int KbdReset(void){
82:                      unsigned int t0;
83:                      short c;
84:                      rx_flags = 0;
9D0085D8  A3808059   SB ZERO, -32679(GP)
85:                      KbdSend(KBD_RESET);
9D0085DC  0F401F26   JAL KbdSend
9D0085E0  2404FFFF   ADDIU A0, ZERO, -1
86:                      t0=ticks()+750;
9D0085E4  0F40355C   JAL ticks
9D0085E8  00008021   ADDU S0, ZERO, ZERO
9D0085EC  245102EE   ADDIU S1, V0, 750
87:                      c=0;
88:                      while ((ticks()!=t0) && ((rx_flags & F_ERROR)==0) && !c){
9D008608  0F40355C   JAL ticks
9D00860C  00000000   NOP
9D008610  12220007   BEQ S1, V0, 0x9D008630
9D008614  00000000   NOP
9D008618  93828059   LBU V0, -32679(GP)
9D00861C  30420001   ANDI V0, V0, 1
9D008620  14400003   BNE V0, ZERO, 0x9D008630
9D008624  00000000   NOP
9D008628  1200FFF3   BEQ S0, ZERO, 0x9D0085F8
9D00862C  00000000   NOP
89:                              c=KbdScancode();
9D0085F8  0F401FCC   JAL KbdScancode
9D0085FC  00000000   NOP
9D008600  00521826   XOR V1, V0, S2
9D008604  0043800B   MOVN S0, V0, V1
90:                              if (c==KBD_ACK){
9D0085F0  0B402182   J 0x9D008608
9D0085F4  241200FA   ADDIU S2, ZERO, 250
91:                                  c=0;
92:                              }
93:                      }
94:                      if ((rx_flags & F_ERROR) || (c!=BAT_OK))
9D008630  93838059   LBU V1, -32679(GP)
9D008634  30630001   ANDI V1, V1, 1
9D008638  14600003   BNE V1, ZERO, 0x9D008648
9D00863C  00001021   ADDU V0, ZERO, ZERO
95:                          return 0;
9D008640  3A0200AA   XORI V0, S0, 170
9D008644  2C420001   SLTIU V0, V0, 1
9D008648  0002102B   SLTU V0, ZERO, V0
96:                      else
97:                          return 1;
98:                  }//KbdReset()
99:                  
100:                 typedef enum  _STATE {ST0, ST_EXT0, ST_RELEASE, ST_COMPLETED} state_t;
101:                 
102:                 short KbdScancode(){  // obtient le code clavier en tête de la file
9D007F30  27BDFFE8   ADDIU SP, SP, -24
9D007F34  AFBF0014   SW RA, 20(SP)
9D007F38  AFB00010   SW S0, 16(SP)
9D008224  3C079D01   LUI A3, -25343
9D008228  24E7F968   ADDIU A3, A3, -1688
103:                 	unsigned int i, flags;
104:                         state_t state;
105:                 	short code;
106:                         if (head==tail){
9D007F3C  9383805F   LBU V1, -32673(GP)
9D007F40  306300FF   ANDI V1, V1, 255
9D007F44  9382805D   LBU V0, -32675(GP)
9D007F48  304200FF   ANDI V0, V0, 255
9D007F4C  1462001B   BNE V1, V0, 0x9D007FBC
9D007F50  00002021   ADDU A0, ZERO, ZERO
9D007FBC  00003021   ADDU A2, ZERO, ZERO
107:                             if (rx_flags & F_ERROR){
9D007F54  93838059   LBU V1, -32679(GP)
9D007F58  30630001   ANDI V1, V1, 1
9D007F5C  10600162   BEQ V1, ZERO, 0x9D0084E8
9D007F60  00001021   ADDU V0, ZERO, ZERO
108:                                 _status_on();
9D007F64  3C10BF88   LUI S0, -16504
9D007F68  8E026120   LW V0, 24864(S0)
9D007F6C  34420008   ORI V0, V0, 8
9D007F70  AE026120   SW V0, 24864(S0)
109:                                 delay_ms(400);
9D007F74  0F403567   JAL delay_ms
9D007F78  24040190   ADDIU A0, ZERO, 400
110:                                 _status_off();
9D007F7C  8E036120   LW V1, 24864(S0)
9D007F80  2402FFF7   ADDIU V0, ZERO, -9
9D007F84  00621024   AND V0, V1, V0
9D007F88  AE026120   SW V0, 24864(S0)
111:                                 delay_ms(400);
9D007F8C  0F403567   JAL delay_ms
9D007F90  24040190   ADDIU A0, ZERO, 400
112:                                 rx_flags &= ~F_ERROR;
9D007F94  93828059   LBU V0, -32679(GP)
9D007F98  304200FE   ANDI V0, V0, 254
9D007F9C  A3828059   SB V0, -32679(GP)
113:                                 IEC0bits.INT4IE=1;
9D007FA0  3C02BF88   LUI V0, -16504
9D007FA4  8C431060   LW V1, 4192(V0)
9D007FA8  24040001   ADDIU A0, ZERO, 1
9D007FAC  7C83BDC4   INS V1, A0, 23, 1
9D007FB0  AC431060   SW V1, 4192(V0)
114:                             }
115:                             return 0; // tampon vide
9D007FB4  0B40213A   J 0x9D0084E8
9D007FB8  00001021   ADDU V0, ZERO, ZERO
116:                         }
117:                 	code = 0;
118:                 	flags=0;
119:                         state=ST0;
120:                 	while (state!=ST_COMPLETED){
9D007FD0  240A0003   ADDIU T2, ZERO, 3
9D008194  148AFF91   BNE A0, T2, 0x9D007FDC
9D008198  00000000   NOP
121:                             _wait_key();
9D007FDC  9383805F   LBU V1, -32673(GP)
9D007FE0  306300FF   ANDI V1, V1, 255
9D007FE4  9382805D   LBU V0, -32675(GP)
9D007FE8  304200FF   ANDI V0, V0, 255
9D007FEC  1062FFFB   BEQ V1, V0, 0x9D007FDC
9D007FF0  00000000   NOP
122:                             code=kbd_queue[head];
9D007FC0  3C08A000   LUI T0, -24576
9D007FC4  25082A20   ADDIU T0, T0, 10784
9D007FF4  9382805F   LBU V0, -32673(GP)
9D007FF8  304200FF   ANDI V0, V0, 255
9D007FFC  00481021   ADDU V0, V0, T0
9D008000  90430000   LBU V1, 0(V0)
9D008004  7C031620   SEH V0, V1
123:                             head++;
9D008008  9385805F   LBU A1, -32673(GP)
9D00800C  24A50001   ADDIU A1, A1, 1
9D008010  30A500FF   ANDI A1, A1, 255
9D008014  A385805F   SB A1, -32673(GP)
124:                             head &= 31;
9D008018  9385805F   LBU A1, -32673(GP)
9D00801C  30A5001F   ANDI A1, A1, 31
9D008020  A385805F   SB A1, -32673(GP)
125:                             switch (state){
9D007FC8  24070001   ADDIU A3, ZERO, 1
9D008024  10870026   BEQ A0, A3, 0x9D0080C0
9D008028  00000000   NOP
9D00802C  10800006   BEQ A0, ZERO, 0x9D008048
9D008030  00000000   NOP
9D008034  24030002   ADDIU V1, ZERO, 2
9D008038  14830056   BNE A0, V1, 0x9D008194
9D00803C  00C02821   ADDU A1, A2, ZERO
126:                                 case ST0:
127:                                     switch (code){
9D007FD4  240B00E1   ADDIU T3, ZERO, 225
9D007FD8  240C00E0   ADDIU T4, ZERO, 224
9D008048  106B000B   BEQ V1, T3, 0x9D008078
9D00804C  24040007   ADDIU A0, ZERO, 7
9D008050  50690005   BEQL V1, T1, 0x9D008068
9D008054  34C68000   ORI A2, A2, -32768
9D008058  146C004E   BNE V1, T4, 0x9D008194
9D00805C  01402021   ADDU A0, T2, ZERO
128:                                         case KEY_REL:
129:                                             flags |= REL_BIT;
130:                                             state = ST_RELEASE;
131:                                             break;
9D008068  0B401FF7   J 0x9D007FDC
9D00806C  24040002   ADDIU A0, ZERO, 2
132:                                         case XTD_KEY:
133:                                             flags |= XT_BIT;
9D008060  0B40201C   J 0x9D008070
9D008064  34C60100   ORI A2, A2, 256
134:                                             state = ST_EXT0;
135:                                             break;
9D008070  0B401FF7   J 0x9D007FDC
9D008074  00E02021   ADDU A0, A3, ZERO
136:                                         case 0xE1:
137:                                             for (i=7;i;i--){     // touche PAUSE élimine les 7 prochains caractères
9D0080B0  1480FFF1   BNE A0, ZERO, 0x9D008078
9D0080B4  240201E1   ADDIU V0, ZERO, 481
138:                                                     _wait_key();
9D008078  9383805F   LBU V1, -32673(GP)
9D00807C  306300FF   ANDI V1, V1, 255
9D008080  9382805D   LBU V0, -32675(GP)
9D008084  304200FF   ANDI V0, V0, 255
9D008088  1062FFFB   BEQ V1, V0, 0x9D008078
9D00808C  00000000   NOP
139:                                                     head++;
9D008090  9382805F   LBU V0, -32673(GP)
9D008094  24420001   ADDIU V0, V0, 1
9D008098  304200FF   ANDI V0, V0, 255
9D00809C  A382805F   SB V0, -32673(GP)
140:                                                     head &= 31;
9D0080A0  9382805F   LBU V0, -32673(GP)
9D0080A4  3042001F   ANDI V0, V0, 31
9D0080A8  A382805F   SB V0, -32673(GP)
9D0080AC  2484FFFF   ADDIU A0, A0, -1
141:                                             }
142:                                             code = PAUSE;
143:                                         default:
144:                                             state=ST_COMPLETED;
145:                                     }//switch(code)
146:                                     break;
147:                                 case ST_EXT0:
148:                                     if (code==KEY_REL){
9D007FCC  240900F0   ADDIU T1, ZERO, 240
9D0080C0  14490004   BNE V0, T1, 0x9D0080D4
9D0080C4  30C30100   ANDI V1, A2, 256
149:                                         flags |= REL_BIT;
9D0080C8  34C68000   ORI A2, A2, -32768
150:                                         state = ST_RELEASE;
9D0080CC  0B401FF7   J 0x9D007FDC
9D0080D0  24040002   ADDIU A0, ZERO, 2
151:                                     }else{
152:                                         if ((flags & XT_BIT) && (code==0x12)){ // touche PrtSc enfoncée.
9D0080D4  10600031   BEQ V1, ZERO, 0x9D00819C
9D0080D8  00C02821   ADDU A1, A2, ZERO
9D0080DC  24030012   ADDIU V1, ZERO, 18
9D0080E0  1443002F   BNE V0, V1, 0x9D0081A0
9D0080E4  3C03BF88   LUI V1, -16504
9D0080E8  24040002   ADDIU A0, ZERO, 2
153:                                             for (i=2;i;i--){ // élimine les 2 codes suivants
9D008124  1480FFF1   BNE A0, ZERO, 0x9D0080EC
9D008128  24020112   ADDIU V0, ZERO, 274
9D00812C  0B402067   J 0x9D00819C
9D008130  00A03021   ADDU A2, A1, ZERO
154:                                                 _wait_key();
9D0080EC  9383805F   LBU V1, -32673(GP)
9D0080F0  306300FF   ANDI V1, V1, 255
9D0080F4  9382805D   LBU V0, -32675(GP)
9D0080F8  304200FF   ANDI V0, V0, 255
9D0080FC  1062FFFB   BEQ V1, V0, 0x9D0080EC
9D008100  00000000   NOP
155:                                                 head++;
9D008104  9382805F   LBU V0, -32673(GP)
9D008108  24420001   ADDIU V0, V0, 1
9D00810C  304200FF   ANDI V0, V0, 255
9D008110  A382805F   SB V0, -32673(GP)
156:                                                 head &=31;
9D008114  9382805F   LBU V0, -32673(GP)
9D008118  3042001F   ANDI V0, V0, 31
9D00811C  A382805F   SB V0, -32673(GP)
9D008120  2484FFFF   ADDIU A0, A0, -1
157:                                             }
158:                                             code = PRN;
159:                                         }
160:                                         state = ST_COMPLETED;
161:                                     }
162:                                     break;
163:                                 case ST_RELEASE:
164:                                     if ((flags & XT_BIT) && (code==0x7c)){ //touche PrtSc relâchée.
9D008040  0B40204D   J 0x9D008134
9D008044  30C30100   ANDI V1, A2, 256
9D008134  1060001A   BEQ V1, ZERO, 0x9D0081A0
9D008138  3C03BF88   LUI V1, -16504
9D00813C  2403007C   ADDIU V1, ZERO, 124
9D008140  14430017   BNE V0, V1, 0x9D0081A0
9D008144  3C03BF88   LUI V1, -16504
9D008148  24040003   ADDIU A0, ZERO, 3
165:                                         for (i=3;i;i--){ // élimine les 3 codes suivants.
9D008184  1480FFF1   BNE A0, ZERO, 0x9D00814C
9D008188  24020112   ADDIU V0, ZERO, 274
9D00818C  0B402067   J 0x9D00819C
9D008190  00A03021   ADDU A2, A1, ZERO
166:                                             _wait_key();
9D00814C  9383805F   LBU V1, -32673(GP)
9D008150  306300FF   ANDI V1, V1, 255
9D008154  9382805D   LBU V0, -32675(GP)
9D008158  304200FF   ANDI V0, V0, 255
9D00815C  1062FFFB   BEQ V1, V0, 0x9D00814C
9D008160  00000000   NOP
167:                                             head++;
9D008164  9382805F   LBU V0, -32673(GP)
9D008168  24420001   ADDIU V0, V0, 1
9D00816C  304200FF   ANDI V0, V0, 255
9D008170  A382805F   SB V0, -32673(GP)
168:                                             head &= 31;
9D008174  9382805F   LBU V0, -32673(GP)
9D008178  3042001F   ANDI V0, V0, 31
9D00817C  A382805F   SB V0, -32673(GP)
9D008180  2484FFFF   ADDIU A0, A0, -1
169:                                         }
170:                                         code = PRN;
171:                                     }
172:                                     state=ST_COMPLETED;
173:                                     break;
174:                                 default:;
175:                             }//switch(state)
176:                         }//while(state...)
177:                         IEC0bits.INT4IE=0; // section critique désactive interruption
9D0080B8  0B402068   J 0x9D0081A0
9D0080BC  3C03BF88   LUI V1, -16504
9D00819C  3C03BF88   LUI V1, -16504
9D0081A0  8C641060   LW A0, 4192(V1)
9D0081A4  7C04BDC4   INS A0, ZERO, 23, 1
9D0081A8  AC641060   SW A0, 4192(V1)
178:                 	if (head==tail){
9D0081AC  9384805F   LBU A0, -32673(GP)
9D0081B0  308400FF   ANDI A0, A0, 255
9D0081B4  9383805D   LBU V1, -32675(GP)
9D0081B8  306300FF   ANDI V1, V1, 255
9D0081BC  14830005   BNE A0, V1, 0x9D0081D4
9D0081C0  3C03BF88   LUI V1, -16504
179:                 		rx_flags &= ~F_RCVD;
9D0081C4  93838059   LBU V1, -32679(GP)
9D0081C8  306300FD   ANDI V1, V1, 253
9D0081CC  A3838059   SB V1, -32679(GP)
180:                 	}
181:                         IEC0bits.INT4IE=1; // fin section critique réactive interruption
9D0081D0  3C03BF88   LUI V1, -16504
9D0081D4  8C641060   LW A0, 4192(V1)
9D0081D8  24050001   ADDIU A1, ZERO, 1
9D0081DC  7CA4BDC4   INS A0, A1, 23, 1
9D0081E0  AC641060   SW A0, 4192(V1)
182:                         if ((code==KBD_ACK)||(code==KBD_RSND)||(code==BAT_OK)||(code==BAT_ERROR)){
9D0081E4  240300FA   ADDIU V1, ZERO, 250
9D0081E8  104300BF   BEQ V0, V1, 0x9D0084E8
9D0081EC  240300FE   ADDIU V1, ZERO, 254
9D0081F0  104300BD   BEQ V0, V1, 0x9D0084E8
9D0081F4  240300AA   ADDIU V1, ZERO, 170
9D0081F8  104300BB   BEQ V0, V1, 0x9D0084E8
9D0081FC  240300FC   ADDIU V1, ZERO, 252
9D008200  104300B9   BEQ V0, V1, 0x9D0084E8
9D008204  24030058   ADDIU V1, ZERO, 88
183:                             return code;
184:                         }
185:                         code |= flags;
9D008208  00462825   OR A1, V0, A2
9D00820C  30A5FFFF   ANDI A1, A1, -1
9D008210  7C051620   SEH V0, A1
186:                         for (i=0;i<FN_COUNT;i++){
9D0084D4  5467FF56   BNEL V1, A3, 0x9D008230
9D0084D8  84640000   LH A0, 0(V1)
187:                             if ((code&0x1ff)==fn_keys[i]){
9D008214  30A501FF   ANDI A1, A1, 511
9D008218  10A30007   BEQ A1, V1, 0x9D008238
9D00821C  3C039D01   LUI V1, -25343
9D008220  2463F92A   ADDIU V1, V1, -1750
9D00822C  84640000   LH A0, 0(V1)
9D008230  148500A8   BNE A0, A1, 0x9D0084D4
9D008234  24630002   ADDIU V1, V1, 2
188:                                 code |= FN_BIT;
9D008238  34420200   ORI V0, V0, 512
9D00823C  7C021620   SEH V0, V0
189:                                 switch (code&0x1ff){ // les touches d'alteration sont traitées ici.
9D008240  304301FF   ANDI V1, V0, 511
9D008244  24040059   ADDIU A0, ZERO, 89
9D008248  10640030   BEQ V1, A0, 0x9D00830C
9D00824C  2864005A   SLTI A0, V1, 90
9D008250  10800011   BEQ A0, ZERO, 0x9D008298
9D008254  2404007E   ADDIU A0, ZERO, 126
9D008258  24040012   ADDIU A0, ZERO, 18
9D00825C  1064001D   BEQ V1, A0, 0x9D0082D4
9D008260  28640013   SLTI A0, V1, 19
9D008264  10800006   BEQ A0, ZERO, 0x9D008280
9D008268  24040014   ADDIU A0, ZERO, 20
9D00826C  24040011   ADDIU A0, ZERO, 17
9D008270  1464009A   BNE V1, A0, 0x9D0084DC
9D008274  00000000   NOP
9D008280  10640030   BEQ V1, A0, 0x9D008344
9D008284  24040058   ADDIU A0, ZERO, 88
9D008288  14640094   BNE V1, A0, 0x9D0084DC
9D00828C  00000000   NOP
9D008298  1064007E   BEQ V1, A0, 0x9D008494
9D00829C  2864007F   SLTI A0, V1, 127
9D0082A0  10800006   BEQ A0, ZERO, 0x9D0082BC
9D0082A4  24040111   ADDIU A0, ZERO, 273
9D0082A8  24040077   ADDIU A0, ZERO, 119
9D0082AC  1464008B   BNE V1, A0, 0x9D0084DC
9D0082B0  00000000   NOP
9D0082BC  1064003C   BEQ V1, A0, 0x9D0083B0
9D0082C0  24040114   ADDIU A0, ZERO, 276
9D0082C4  14640085   BNE V1, A0, 0x9D0084DC
9D0082C8  00000000   NOP
190:                                     case LSHIFT:
191:                                         if (flags & REL_BIT){
9D0082D4  30C68000   ANDI A2, A2, -32768
9D0082D8  10C00006   BEQ A2, ZERO, 0x9D0082F4
9D0082DC  00000000   NOP
192:                                             key_state &=~F_LSHIFT;
9D0082E0  978280C8   LHU V0, -32568(GP)
9D0082E4  3042FFF7   ANDI V0, V0, -9
9D0082E8  A78280C8   SH V0, -32568(GP)
9D0082EC  0B40213A   J 0x9D0084E8
9D0082F0  00001021   ADDU V0, ZERO, ZERO
193:                                         }else{
194:                                             key_state |= F_LSHIFT;
9D0082F4  978280C8   LHU V0, -32568(GP)
9D0082F8  3042FFFF   ANDI V0, V0, -1
9D0082FC  34420008   ORI V0, V0, 8
9D008300  A78280C8   SH V0, -32568(GP)
9D008304  0B40213A   J 0x9D0084E8
9D008308  00001021   ADDU V0, ZERO, ZERO
195:                                         }
196:                                         code=0;
197:                                         break;
198:                                     case RSHIFT:
199:                                         if (flags & REL_BIT){
9D00830C  30C68000   ANDI A2, A2, -32768
9D008310  10C00006   BEQ A2, ZERO, 0x9D00832C
9D008314  00000000   NOP
200:                                             key_state &=~F_RSHIFT;
9D008318  978280C8   LHU V0, -32568(GP)
9D00831C  3042FFEF   ANDI V0, V0, -17
9D008320  A78280C8   SH V0, -32568(GP)
9D008324  0B40213A   J 0x9D0084E8
9D008328  00001021   ADDU V0, ZERO, ZERO
201:                                         }else{
202:                                             key_state |= F_RSHIFT;
9D00832C  978280C8   LHU V0, -32568(GP)
9D008330  3042FFFF   ANDI V0, V0, -1
9D008334  34420010   ORI V0, V0, 16
9D008338  A78280C8   SH V0, -32568(GP)
9D00833C  0B40213A   J 0x9D0084E8
9D008340  00001021   ADDU V0, ZERO, ZERO
203:                                         }
204:                                         code=0;
205:                                         break;
206:                                     case LCTRL:
207:                                         if (flags & REL_BIT){
9D008344  30C68000   ANDI A2, A2, -32768
9D008348  10C00006   BEQ A2, ZERO, 0x9D008364
9D00834C  00000000   NOP
208:                                             key_state &=~F_LCTRL;
9D008350  978280C8   LHU V0, -32568(GP)
9D008354  3042FFDF   ANDI V0, V0, -33
9D008358  A78280C8   SH V0, -32568(GP)
9D00835C  0B40213A   J 0x9D0084E8
9D008360  00001021   ADDU V0, ZERO, ZERO
209:                                         }else{
210:                                             key_state |= F_LCTRL;
9D008364  978280C8   LHU V0, -32568(GP)
9D008368  3042FFFF   ANDI V0, V0, -1
9D00836C  34420020   ORI V0, V0, 32
9D008370  A78280C8   SH V0, -32568(GP)
9D008374  0B40213A   J 0x9D0084E8
9D008378  00001021   ADDU V0, ZERO, ZERO
211:                                         }
212:                                         code=0;
213:                                         break;
214:                                     case RCTRL:
215:                                         if (flags & REL_BIT){
9D0082CC  0B4020DF   J 0x9D00837C
9D0082D0  30C68000   ANDI A2, A2, -32768
9D00837C  10C00006   BEQ A2, ZERO, 0x9D008398
9D008380  00000000   NOP
216:                                             key_state &=~F_RCTRL;
9D008384  978280C8   LHU V0, -32568(GP)
9D008388  3042FFBF   ANDI V0, V0, -65
9D00838C  A78280C8   SH V0, -32568(GP)
9D008390  0B40213A   J 0x9D0084E8
9D008394  00001021   ADDU V0, ZERO, ZERO
217:                                         }else{
218:                                             key_state |= F_RCTRL;
9D008398  978280C8   LHU V0, -32568(GP)
9D00839C  3042FFFF   ANDI V0, V0, -1
9D0083A0  34420040   ORI V0, V0, 64
9D0083A4  A78280C8   SH V0, -32568(GP)
9D0083A8  0B40213A   J 0x9D0084E8
9D0083AC  00001021   ADDU V0, ZERO, ZERO
219:                                         }
220:                                         code=0;
221:                                         break;
222:                                     case RALT:
223:                                         if (flags & REL_BIT){
9D0083B0  30C68000   ANDI A2, A2, -32768
9D0083B4  10C00006   BEQ A2, ZERO, 0x9D0083D0
9D0083B8  00000000   NOP
224:                                             key_state &=~F_ALTCHAR;
9D0083BC  978280C8   LHU V0, -32568(GP)
9D0083C0  3042FEFF   ANDI V0, V0, -257
9D0083C4  A78280C8   SH V0, -32568(GP)
9D0083C8  0B40213A   J 0x9D0084E8
9D0083CC  00001021   ADDU V0, ZERO, ZERO
225:                                         }else{
226:                                             key_state |= F_ALTCHAR;
9D0083D0  978280C8   LHU V0, -32568(GP)
9D0083D4  3042FFFF   ANDI V0, V0, -1
9D0083D8  34420100   ORI V0, V0, 256
9D0083DC  A78280C8   SH V0, -32568(GP)
9D0083E0  0B40213A   J 0x9D0084E8
9D0083E4  00001021   ADDU V0, ZERO, ZERO
227:                                         }
228:                                         code=0;
229:                                         break;
230:                                     case LALT:
231:                                         if (flags & REL_BIT){
9D008278  0B4020FA   J 0x9D0083E8
9D00827C  30C68000   ANDI A2, A2, -32768
9D0083E8  10C00006   BEQ A2, ZERO, 0x9D008404
9D0083EC  00000000   NOP
232:                                             key_state &=~F_LALT;
9D0083F0  978280C8   LHU V0, -32568(GP)
9D0083F4  3042FF7F   ANDI V0, V0, -129
9D0083F8  A78280C8   SH V0, -32568(GP)
9D0083FC  0B40213A   J 0x9D0084E8
9D008400  00001021   ADDU V0, ZERO, ZERO
233:                                         }else{
234:                                             key_state |= F_LALT;
9D008404  978280C8   LHU V0, -32568(GP)
9D008408  3042FFFF   ANDI V0, V0, -1
9D00840C  34420080   ORI V0, V0, 128
9D008410  A78280C8   SH V0, -32568(GP)
9D008414  0B40213A   J 0x9D0084E8
9D008418  00001021   ADDU V0, ZERO, ZERO
235:                                         }
236:                                         code=0;
237:                                         break;
238:                                     case NUM_LOCK:
239:                                         if (flags & REL_BIT){
9D0082B4  0B402107   J 0x9D00841C
9D0082B8  30C68000   ANDI A2, A2, -32768
9D00841C  10C00032   BEQ A2, ZERO, 0x9D0084E8
9D008420  00001021   ADDU V0, ZERO, ZERO
240:                                             kbd_leds ^= F_NUM;
9D008424  9382805A   LBU V0, -32678(GP)
9D008428  304200FF   ANDI V0, V0, 255
9D00842C  38420002   XORI V0, V0, 2
9D008430  A382805A   SB V0, -32678(GP)
241:                                             key_state ^= F_NUM;
9D008434  978280C8   LHU V0, -32568(GP)
9D008438  3042FFFF   ANDI V0, V0, -1
9D00843C  38420002   XORI V0, V0, 2
9D008440  A78280C8   SH V0, -32568(GP)
242:                                             SetKbdLeds(kbd_leds);
9D008444  9384805A   LBU A0, -32678(GP)
9D008448  0F401F97   JAL SetKbdLeds
9D00844C  308400FF   ANDI A0, A0, 255
9D008450  0B40213A   J 0x9D0084E8
9D008454  00001021   ADDU V0, ZERO, ZERO
243:                                         }
244:                                         code=0;
245:                                         break;
246:                                     case CAPS_LOCK:
247:                                         if (flags & REL_BIT){
9D008290  0B402116   J 0x9D008458
9D008294  30C68000   ANDI A2, A2, -32768
9D008458  10C00023   BEQ A2, ZERO, 0x9D0084E8
9D00845C  00001021   ADDU V0, ZERO, ZERO
248:                                             kbd_leds ^= F_CAPS;
9D008460  9382805A   LBU V0, -32678(GP)
9D008464  304200FF   ANDI V0, V0, 255
9D008468  38420004   XORI V0, V0, 4
9D00846C  A382805A   SB V0, -32678(GP)
249:                                             key_state ^= F_CAPS;
9D008470  978280C8   LHU V0, -32568(GP)
9D008474  3042FFFF   ANDI V0, V0, -1
9D008478  38420004   XORI V0, V0, 4
9D00847C  A78280C8   SH V0, -32568(GP)
250:                                             SetKbdLeds(kbd_leds);
9D008480  9384805A   LBU A0, -32678(GP)
9D008484  0F401F97   JAL SetKbdLeds
9D008488  308400FF   ANDI A0, A0, 255
9D00848C  0B40213A   J 0x9D0084E8
9D008490  00001021   ADDU V0, ZERO, ZERO
251:                                         }
252:                                         code=0;
253:                                         break;
254:                                     case SCROLL_LOCK:
255:                                         if (flags & REL_BIT){
9D008494  30C68000   ANDI A2, A2, -32768
9D008498  10C00013   BEQ A2, ZERO, 0x9D0084E8
9D00849C  00001021   ADDU V0, ZERO, ZERO
256:                                             kbd_leds ^= F_SCROLL;
9D0084A0  9382805A   LBU V0, -32678(GP)
9D0084A4  304200FF   ANDI V0, V0, 255
9D0084A8  38420001   XORI V0, V0, 1
9D0084AC  A382805A   SB V0, -32678(GP)
257:                                             key_state ^= F_SCROLL;
9D0084B0  978280C8   LHU V0, -32568(GP)
9D0084B4  3042FFFF   ANDI V0, V0, -1
9D0084B8  38420001   XORI V0, V0, 1
9D0084BC  A78280C8   SH V0, -32568(GP)
258:                                             SetKbdLeds(kbd_leds);
9D0084C0  9384805A   LBU A0, -32678(GP)
9D0084C4  0F401F97   JAL SetKbdLeds
9D0084C8  308400FF   ANDI A0, A0, 255
9D0084CC  0B40213A   J 0x9D0084E8
9D0084D0  00001021   ADDU V0, ZERO, ZERO
259:                                         }
260:                                         code=0;
261:                                         break;
262:                                     default:;
263:                                 }//switch(code)
264:                                 break;
265:                             }// if
266:                         }//for
267:                         if ((code < 0) && !(code & FN_BIT)) // ne retourne pas les relâchement de touche pour les touches caractères.
9D0084DC  04410002   BGEZ V0, 0x9D0084E8
9D0084E0  30430200   ANDI V1, V0, 512
268:                             return 0;
9D0084E4  0003100A   MOVZ V0, ZERO, V1
269:                         else
270:                             return code;
271:                 }// GetScancode()
9D0084E8  8FBF0014   LW RA, 20(SP)
9D0084EC  8FB00010   LW S0, 16(SP)
9D0084F0  03E00008   JR RA
9D0084F4  27BD0018   ADDIU SP, SP, 24
272:                 
273:                 
274:                 short KbdKey(short scancode){  // obtient la transcription du code en ASCII
9D007A94  7C042620   SEH A0, A0
275:                 	int a,i;
276:                 	a=0;
9D007B00  0B401F21   J 0x9D007C84
9D007B04  00001021   ADDU V0, ZERO, ZERO
277:                 	if (scancode & XT_BIT){
9D007A98  3086FFFF   ANDI A2, A0, -1
9D007A9C  30C20100   ANDI V0, A2, 256
9D007AA0  10400019   BEQ V0, ZERO, 0x9D007B08
9D007AA4  3C029D01   LUI V0, -25343
278:                 		i=0;
279:                 		while (qwerty_xt_char[i].code){
9D007AA8  8443E9E0   LH V1, -5664(V0)
9D007AAC  10600075   BEQ V1, ZERO, 0x9D007C84
9D007AB0  00001021   ADDU V0, ZERO, ZERO
9D007AF4  84430000   LH V1, 0(V0)
9D007AF8  1460FFF2   BNE V1, ZERO, 0x9D007AC4
9D007AFC  24A50001   ADDIU A1, A1, 1
280:                 			if (qwerty_xt_char[i].code==scancode){
9D007AB4  5483000D   BNEL A0, V1, 0x9D007AEC
9D007AB8  3C029D01   LUI V0, -25343
9D007ABC  0B401EB5   J 0x9D007AD4
9D007AC0  00002821   ADDU A1, ZERO, ZERO
9D007AC4  1483000B   BNE A0, V1, 0x9D007AF4
9D007AC8  24420004   ADDIU V0, V0, 4
9D007AF0  00002821   ADDU A1, ZERO, ZERO
281:                 				a=qwerty_xt_char[i].ascii;
9D007ACC  0B401EB6   J 0x9D007AD8
9D007AD0  00052880   SLL A1, A1, 2
9D007AD4  00052880   SLL A1, A1, 2
9D007AD8  3C029D01   LUI V0, -25343
9D007ADC  2442E9E0   ADDIU V0, V0, -5664
9D007AE0  00452821   ADDU A1, V0, A1
282:                 				break;
9D007AE4  0B401F21   J 0x9D007C84
9D007AE8  84A20002   LH V0, 2(A1)
9D007AEC  2442E9E4   ADDIU V0, V0, -5660
283:                 			}
284:                 			i++;
285:                 		} // while (xt_char[i].code)
286:                 	}else if (key_state & F_SHIFT){
9D007B08  978280C8   LHU V0, -32568(GP)
9D007B0C  30420018   ANDI V0, V0, 24
9D007B10  5440000A   BNEL V0, ZERO, 0x9D007B3C
9D007B14  3C029D01   LUI V0, -25343
287:                 		i=0;
288:                 		while (qwerty_shifted_key[i].code){
9D007B3C  8442E98C   LH V0, -5748(V0)
9D007B40  50400019   BEQL V0, ZERO, 0x9D007BA8
9D007B44  3C029D01   LUI V0, -25343
9D007B98  84430000   LH V1, 0(V0)
9D007B9C  1460FFEF   BNE V1, ZERO, 0x9D007B5C
9D007BA0  24A50001   ADDIU A1, A1, 1
289:                 			if (qwerty_shifted_key[i].code==(scancode&0xff)){
9D007B48  30C700FF   ANDI A3, A2, 255
9D007B4C  14470010   BNE V0, A3, 0x9D007B90
9D007B50  3C029D01   LUI V0, -25343
9D007B54  0B401EDB   J 0x9D007B6C
9D007B58  00002821   ADDU A1, ZERO, ZERO
9D007B5C  1467000E   BNE V1, A3, 0x9D007B98
9D007B60  24420004   ADDIU V0, V0, 4
9D007B94  00002821   ADDU A1, ZERO, ZERO
290:                 				a=qwerty_shifted_key[i].ascii;
9D007B64  0B401EDC   J 0x9D007B70
9D007B68  00052880   SLL A1, A1, 2
9D007B6C  00052880   SLL A1, A1, 2
9D007B70  3C029D01   LUI V0, -25343
9D007B74  2442E98C   ADDIU V0, V0, -5748
9D007B78  00452821   ADDU A1, V0, A1
9D007B7C  84A20002   LH V0, 2(A1)
291:                 				break;
292:                 			}
293:                 			i++;
294:                 		}// while (shifted_key.code)
295:                 		if (!a){
9D007B80  14400041   BNE V0, ZERO, 0x9D007C88
9D007B84  2403FF00   ADDIU V1, ZERO, -256
9D007B90  2442E990   ADDIU V0, V0, -5744
296:                 			i=0;
297:                 			while (qwerty[i].code){
9D007B88  0B401EEA   J 0x9D007BA8
9D007B8C  3C029D01   LUI V0, -25343
9D007BA4  3C029D01   LUI V0, -25343
9D007BA8  8443E87C   LH V1, -6020(V0)
9D007BAC  10600035   BEQ V1, ZERO, 0x9D007C84
9D007BB0  00001021   ADDU V0, ZERO, ZERO
9D007C08  84430000   LH V1, 0(V0)
9D007C0C  1460FFEE   BNE V1, ZERO, 0x9D007BC8
9D007C10  24A50001   ADDIU A1, A1, 1
9D007C14  0B401F21   J 0x9D007C84
9D007C18  00001021   ADDU V0, ZERO, ZERO
298:                 				if (qwerty[i].code==(scancode&0xff)){
9D007BB4  30C600FF   ANDI A2, A2, 255
9D007BB8  54660011   BNEL V1, A2, 0x9D007C00
9D007BBC  3C029D01   LUI V0, -25343
9D007BC0  0B401EF6   J 0x9D007BD8
9D007BC4  00002821   ADDU A1, ZERO, ZERO
9D007BC8  14C3000F   BNE A2, V1, 0x9D007C08
9D007BCC  24420004   ADDIU V0, V0, 4
9D007C04  00002821   ADDU A1, ZERO, ZERO
299:                 					a=qwerty[i].ascii;
9D007BD0  0B401EF7   J 0x9D007BDC
9D007BD4  00052880   SLL A1, A1, 2
9D007BD8  00052880   SLL A1, A1, 2
9D007BDC  3C029D01   LUI V0, -25343
9D007BE0  2442E87C   ADDIU V0, V0, -6020
9D007BE4  00452821   ADDU A1, V0, A1
9D007BE8  84A20002   LH V0, 2(A1)
300:                 					break;
301:                 				}
302:                 				i++;
303:                 			}// while (translate.code)
304:                 			if (a>='a' && a<='z'){
9D007BEC  2445FF9F   ADDIU A1, V0, -97
9D007BF0  2CA5001A   SLTIU A1, A1, 26
9D007C00  2442E880   ADDIU V0, V0, -6016
305:                 				a -=32;
9D007BF4  2443FFE0   ADDIU V1, V0, -32
9D007BF8  0B401F21   J 0x9D007C84
9D007BFC  0065100B   MOVN V0, V1, A1
306:                 			}
307:                 		} // if (!a)
308:                 	}else{
309:                 		i=0;
310:                 		while (qwerty[i].code){
9D007B18  3C029D01   LUI V0, -25343
9D007B1C  8443E87C   LH V1, -6020(V0)
9D007B20  10600058   BEQ V1, ZERO, 0x9D007C84
9D007B24  00001021   ADDU V0, ZERO, ZERO
9D007C60  84430000   LH V1, 0(V0)
9D007C64  1460FFED   BNE V1, ZERO, 0x9D007C1C
9D007C68  24A50001   ADDIU A1, A1, 1
9D007C6C  0B401F21   J 0x9D007C84
9D007C70  00001021   ADDU V0, ZERO, ZERO
311:                 			if (qwerty[i].code==(scancode&0xff)){
9D007B28  30C600FF   ANDI A2, A2, 255
9D007B2C  1466004A   BNE V1, A2, 0x9D007C58
9D007B30  3C029D01   LUI V0, -25343
9D007B34  0B401F0B   J 0x9D007C2C
9D007B38  00002821   ADDU A1, ZERO, ZERO
9D007C1C  14660010   BNE V1, A2, 0x9D007C60
9D007C20  24420004   ADDIU V0, V0, 4
9D007C5C  00002821   ADDU A1, ZERO, ZERO
312:                 				a=qwerty[i].ascii;
9D007C24  0B401F0C   J 0x9D007C30
9D007C28  00052880   SLL A1, A1, 2
9D007C2C  00052880   SLL A1, A1, 2
9D007C30  3C029D01   LUI V0, -25343
9D007C34  2442E87C   ADDIU V0, V0, -6020
9D007C38  00452821   ADDU A1, V0, A1
9D007C3C  84A20002   LH V0, 2(A1)
313:                 				break;
314:                 			}
315:                 			i++;
316:                 		}// while (translate.code)
317:                 		if (a>='a' && a<='z' && (key_state & F_CAPS)){
9D007C40  2443FF9F   ADDIU V1, V0, -97
9D007C44  2C63001A   SLTIU V1, V1, 26
9D007C48  1460000A   BNE V1, ZERO, 0x9D007C74
9D007C4C  2403FF00   ADDIU V1, ZERO, -256
9D007C58  2442E880   ADDIU V0, V0, -6016
9D007C74  978580C8   LHU A1, -32568(GP)
9D007C78  30A50004   ANDI A1, A1, 4
318:                 			a -=32;
9D007C7C  2443FFE0   ADDIU V1, V0, -32
9D007C80  0065100B   MOVN V0, V1, A1
319:                 		}
320:                 	}
321:                 	return a|(scancode&0xff00);
9D007C50  0B401F23   J 0x9D007C8C
9D007C54  00832024   AND A0, A0, V1
9D007C84  2403FF00   ADDIU V1, ZERO, -256
9D007C88  00832024   AND A0, A0, V1
9D007C8C  00441025   OR V0, V0, A0
322:                 } // GetKey()
9D007C90  03E00008   JR RA
9D007C94  7C021620   SEH V0, V0
323:                 
324:                 void KbdSend(char cmd){  // envoie une commande au clavier
9D007C98  7C042420   SEB A0, A0
325:                     register unsigned int dly;
326:                         bit_cnt=0;
9D007C9C  A380805B   SB ZERO, -32677(GP)
327:                 	parity=0;
9D007CA0  A380805C   SB ZERO, -32676(GP)
328:                 	IEC0CLR=_IEC0_INT4IE_MASK; // désactive les interruptions sur KBD_CLK
9D007CA4  3C030080   LUI V1, 128
9D007CA8  3C02BF88   LUI V0, -16504
9D007CAC  AC431064   SW V1, 4196(V0)
329:                         TRISACLR = KBD_CLK; // MCU prend le contrôle de la ligne KBD_CLK
9D007CB0  24020001   ADDIU V0, ZERO, 1
9D007CB4  3C03BF88   LUI V1, -16504
9D007CB8  AC626014   SW V0, 24596(V1)
330:                         LATACLR = KBD_CLK; //  mis à 0  KBD_CLK
9D007CBC  3C03BF88   LUI V1, -16504
9D007CC0  AC626034   SW V0, 24628(V1)
9D007CC4  240204C5   ADDIU V0, ZERO, 1221
9D007CC8  2442FFFF   ADDIU V0, V0, -1
331:                         // délais minimum 100µsec
332:                         for (dly=(100/3*CLK_PER_USEC);dly;dly--);
9D007CCC  1440FFFF   BNE V0, ZERO, 0x9D007CCC
9D007CD0  2442FFFF   ADDIU V0, V0, -1
333:                         TRISACLR = KBD_DAT;	// prend le contrôle de la ligne KBD_DAT
9D007CD4  24020002   ADDIU V0, ZERO, 2
9D007CD8  3C03BF88   LUI V1, -16504
9D007CDC  AC626014   SW V0, 24596(V1)
334:                 	LATACLR = KBD_DAT;   	// met KBD_DAT à zéro
9D007CE0  3C03BF88   LUI V1, -16504
9D007CE4  AC626034   SW V0, 24628(V1)
335:                 	TRISASET = KBD_CLK; 	// libère la ligne clock
9D007CE8  24030001   ADDIU V1, ZERO, 1
9D007CEC  3C02BF88   LUI V0, -16504
9D007CF0  AC436018   SW V1, 24600(V0)
336:                         while (!(PORTAbits.RA0)); // attend que la ligne revienne à 1
9D007CF4  3C03BF88   LUI V1, -16504
9D007CF8  8C626020   LW V0, 24608(V1)
9D007CFC  30420001   ANDI V0, V0, 1
9D007D00  1040FFFD   BEQ V0, ZERO, 0x9D007CF8
9D007D04  00000000   NOP
337:                         while (bit_cnt<8){      // envoie les 8 bits, le moins significatif en premier.
9D007D08  9382805B   LBU V0, -32677(GP)
9D007D0C  304200FF   ANDI V0, V0, 255
9D007D10  2C420008   SLTIU V0, V0, 8
9D007D14  1040001F   BEQ V0, ZERO, 0x9D007D94
9D007D18  3C02BF88   LUI V0, -16504
9D007D80  9383805B   LBU V1, -32677(GP)
9D007D84  306300FF   ANDI V1, V1, 255
9D007D88  2C630008   SLTIU V1, V1, 8
9D007D8C  1460FFE6   BNE V1, ZERO, 0x9D007D28
9D007D90  00042043   SRA A0, A0, 1
338:                 		while (PORTAbits.RA0);   // attend clock à 0
9D007D28  8C436020   LW V1, 24608(V0)
9D007D2C  30630001   ANDI V1, V1, 1
9D007D30  1460FFFD   BNE V1, ZERO, 0x9D007D28
9D007D34  30830001   ANDI V1, A0, 1
339:                                 if (cmd&1){
9D007D38  10600008   BEQ V1, ZERO, 0x9D007D5C
9D007D3C  00000000   NOP
340:                 			LATASET = KBD_DAT;
9D007D24  3C06BF88   LUI A2, -16504
9D007D40  ACC56038   SW A1, 24632(A2)
341:                 			parity++;
9D007D44  9383805C   LBU V1, -32676(GP)
9D007D48  24630001   ADDIU V1, V1, 1
9D007D4C  306300FF   ANDI V1, V1, 255
9D007D50  A383805C   SB V1, -32676(GP)
9D007D54  0B401F58   J 0x9D007D60
9D007D58  00000000   NOP
342:                 		}else{
343:                 			LATACLR = KBD_DAT;
9D007D1C  3C07BF88   LUI A3, -16504
9D007D20  24050002   ADDIU A1, ZERO, 2
9D007D5C  ACE56034   SW A1, 24628(A3)
344:                 		}
345:                 		cmd >>= 1;
346:                 		while (!(PORTAbits.RA0)); // attend clock à 1
9D007D60  8C436020   LW V1, 24608(V0)
9D007D64  30630001   ANDI V1, V1, 1
9D007D68  1060FFFD   BEQ V1, ZERO, 0x9D007D60
9D007D6C  00000000   NOP
347:                 		bit_cnt++;				  // un bit de plus envoyé.
9D007D70  9383805B   LBU V1, -32677(GP)
9D007D74  24630001   ADDIU V1, V1, 1
9D007D78  306300FF   ANDI V1, V1, 255
9D007D7C  A383805B   SB V1, -32677(GP)
348:                 	}
349:                         while (PORTAbits.RA0);   // attend clock à 0
9D007D94  3C03BF88   LUI V1, -16504
9D007D98  8C626020   LW V0, 24608(V1)
9D007D9C  30420001   ANDI V0, V0, 1
9D007DA0  1440FFFD   BNE V0, ZERO, 0x9D007D98
9D007DA4  00000000   NOP
350:                 	if (!(parity & 1)){
9D007DA8  9382805C   LBU V0, -32676(GP)
9D007DAC  30420001   ANDI V0, V0, 1
9D007DB0  14400005   BNE V0, ZERO, 0x9D007DC8
9D007DB4  24030002   ADDIU V1, ZERO, 2
351:                 		LATASET = KBD_DAT;
9D007DB8  3C02BF88   LUI V0, -16504
9D007DBC  AC436038   SW V1, 24632(V0)
352:                 	}else{
353:                 		LATACLR = KBD_DAT;
9D007DC8  3C02BF88   LUI V0, -16504
9D007DCC  AC436034   SW V1, 24628(V0)
354:                 	}
355:                 	while (!(PORTAbits.RA0)); // attend clock à 1
9D007DC0  0B401F75   J 0x9D007DD4
9D007DC4  3C03BF88   LUI V1, -16504
9D007DD0  3C03BF88   LUI V1, -16504
9D007DD4  8C626020   LW V0, 24608(V1)
9D007DD8  30420001   ANDI V0, V0, 1
9D007DDC  1040FFFD   BEQ V0, ZERO, 0x9D007DD4
9D007DE0  00000000   NOP
356:                 	while (PORTAbits.RA0);   // attend clock à 0
9D007DE4  3C03BF88   LUI V1, -16504
9D007DE8  8C626020   LW V0, 24608(V1)
9D007DEC  30420001   ANDI V0, V0, 1
9D007DF0  1440FFFD   BNE V0, ZERO, 0x9D007DE8
9D007DF4  3C02BF88   LUI V0, -16504
357:                 	TRISASET = KBD_DAT;  		// libère la ligne data
9D007DF8  24030002   ADDIU V1, ZERO, 2
9D007DFC  AC436018   SW V1, 24600(V0)
358:                 	while (!(PORTAbits.RA0)); // attend clock à 1
9D007E00  3C03BF88   LUI V1, -16504
9D007E04  8C626020   LW V0, 24608(V1)
9D007E08  30420001   ANDI V0, V0, 1
9D007E0C  1040FFFD   BEQ V0, ZERO, 0x9D007E04
9D007E10  00000000   NOP
359:                 	while (PORTA & (KBD_DAT+KBD_CLK)); 	// attend que le clavier mette data et clock à 0
9D007E14  3C03BF88   LUI V1, -16504
9D007E18  8C626020   LW V0, 24608(V1)
9D007E1C  30420003   ANDI V0, V0, 3
9D007E20  1440FFFD   BNE V0, ZERO, 0x9D007E18
9D007E24  3C04BF88   LUI A0, -16504
360:                 	while (!((PORTA & (KBD_DAT+KBD_CLK))==(KBD_DAT+KBD_CLK))); // attend que les 2 lignes reviennent à 1.
9D007E28  24030003   ADDIU V1, ZERO, 3
9D007E2C  8C826020   LW V0, 24608(A0)
9D007E30  30420003   ANDI V0, V0, 3
9D007E34  1443FFFD   BNE V0, V1, 0x9D007E2C
9D007E38  00000000   NOP
361:                 	bit_cnt=0;
9D007E3C  A380805B   SB ZERO, -32677(GP)
362:                         IFS0CLR=_IFS0_INT4IF_MASK;
9D007E40  3C020080   LUI V0, 128
9D007E44  3C03BF88   LUI V1, -16504
9D007E48  AC621034   SW V0, 4148(V1)
363:                 	IEC0SET = _IEC0_INT4IE_MASK; // réactivation interruption
9D007E4C  3C03BF88   LUI V1, -16504
9D007E50  AC621068   SW V0, 4200(V1)
364:                 } // KbdSend()
9D007E54  03E00008   JR RA
9D007E58  00000000   NOP
365:                 
366:                 int SetKbdLeds(unsigned char leds_state){ // contrôle l'état des LEDS du clavier
9D007E5C  27BDFFE0   ADDIU SP, SP, -32
9D007E60  AFBF001C   SW RA, 28(SP)
9D007E64  AFB20018   SW S2, 24(SP)
9D007E68  AFB10014   SW S1, 20(SP)
9D007E6C  AFB00010   SW S0, 16(SP)
367:                     unsigned int t0;
368:                     short c;
369:                     t0=ticks()+100;
9D007E70  0F40355C   JAL ticks
9D007E74  309200FF   ANDI S2, A0, 255
9D007E78  24510064   ADDIU S1, V0, 100
370:                     KbdSend(KBD_LED);
9D007E7C  0F401F26   JAL KbdSend
9D007E80  2404FFED   ADDIU A0, ZERO, -19
371:                     c=0;
372:                     while (!(ticks()==t0) && !(rx_flags & F_ERROR) && !c){
9D007E84  0B401FA6   J 0x9D007E98
9D007E88  00008021   ADDU S0, ZERO, ZERO
9D007E98  0F40355C   JAL ticks
9D007E9C  00000000   NOP
9D007EA0  10510007   BEQ V0, S1, 0x9D007EC0
9D007EA4  240200FA   ADDIU V0, ZERO, 250
9D007EA8  93828059   LBU V0, -32679(GP)
9D007EAC  30420001   ANDI V0, V0, 1
9D007EB0  14400003   BNE V0, ZERO, 0x9D007EC0
9D007EB4  240200FA   ADDIU V0, ZERO, 250
9D007EB8  1200FFF4   BEQ S0, ZERO, 0x9D007E8C
9D007EBC  00000000   NOP
373:                         c=KbdScancode();
9D007E8C  0F401FCC   JAL KbdScancode
9D007E90  00000000   NOP
9D007E94  00408021   ADDU S0, V0, ZERO
374:                     }
375:                     if (c==KBD_ACK){
9D007EC0  16020015   BNE S0, V0, 0x9D007F18
9D007EC4  24020001   ADDIU V0, ZERO, 1
376:                         t0=ticks()+100;
9D007EC8  0F40355C   JAL ticks
9D007ECC  00008021   ADDU S0, ZERO, ZERO
9D007ED0  24510064   ADDIU S1, V0, 100
377:                         KbdSend(leds_state);
9D007ED4  0F401F26   JAL KbdSend
9D007ED8  7C122420   SEB A0, S2
378:                         c=0;
379:                         while (!(ticks()==t0) && !(rx_flags & F_ERROR) && !c){
9D007EDC  0B401FBC   J 0x9D007EF0
9D007EE0  00000000   NOP
9D007EF0  0F40355C   JAL ticks
9D007EF4  00000000   NOP
9D007EF8  10510007   BEQ V0, S1, 0x9D007F18
9D007EFC  24020001   ADDIU V0, ZERO, 1
9D007F00  93828059   LBU V0, -32679(GP)
9D007F04  30420001   ANDI V0, V0, 1
9D007F08  14400003   BNE V0, ZERO, 0x9D007F18
9D007F0C  24020001   ADDIU V0, ZERO, 1
9D007F10  1200FFF4   BEQ S0, ZERO, 0x9D007EE4
9D007F14  00000000   NOP
380:                             c=KbdScancode();
9D007EE4  0F401FCC   JAL KbdScancode
9D007EE8  00000000   NOP
9D007EEC  00408021   ADDU S0, V0, ZERO
381:                         }
382:                     }
383:                     if (c=KBD_ACK)
384:                         return 1;
385:                     else
386:                         return 0;
387:                 } // SetKbdLeds()
9D007F18  8FBF001C   LW RA, 28(SP)
9D007F1C  8FB20018   LW S2, 24(SP)
9D007F20  8FB10014   LW S1, 20(SP)
9D007F24  8FB00010   LW S0, 16(SP)
9D007F28  03E00008   JR RA
9D007F2C  27BD0020   ADDIU SP, SP, 32
388:                 
389:                 void __ISR(_EXTERNAL_4_VECTOR,IPL6SOFT) kbd_clk_isr(void){
9D008664  415DE800   RDPGPR SP, SP
9D008668  401A7000   MFC0 K0, EPC
9D00866C  401B6000   MFC0 K1, Status
9D008670  27BDFFE0   ADDIU SP, SP, -32
9D008674  AFBA001C   SW K0, 28(SP)
9D008678  401A6002   MFC0 K0, SRSCtl
9D00867C  AFBB0018   SW K1, 24(SP)
9D008680  AFBA0014   SW K0, 20(SP)
9D008684  7C1B7844   INS K1, ZERO, 1, 15
9D008688  377B1800   ORI K1, K1, 6144
9D00868C  409B6000   MTC0 K1, Status
9D008690  AFA4000C   SW A0, 12(SP)
9D008694  AFA30008   SW V1, 8(SP)
9D008698  AFA20004   SW V0, 4(SP)
390:                 	switch (bit_cnt){
9D00869C  9382805B   LBU V0, -32677(GP)
9D0086A0  304200FF   ANDI V0, V0, 255
9D0086A4  24030009   ADDIU V1, ZERO, 9
9D0086A8  10430010   BEQ V0, V1, 0x9D0086EC
9D0086AC  2403000A   ADDIU V1, ZERO, 10
9D0086B0  10430028   BEQ V0, V1, 0x9D008754
9D0086B4  00000000   NOP
9D0086B8  1440003B   BNE V0, ZERO, 0x9D0087A8
9D0086BC  3C02BF88   LUI V0, -16504
391:                 	case 0:   // start bit
392:                 		if (!(PORTA & KBD_DAT)){
9D0086C0  8C426020   LW V0, 24608(V0)
9D0086C4  30420002   ANDI V0, V0, 2
9D0086C8  5440004C   BNEL V0, ZERO, 0x9D0087FC
9D0086CC  3C030080   LUI V1, 128
393:                                     parity=0;
9D0086D0  A380805C   SB ZERO, -32676(GP)
394:                                     bit_cnt++;
9D0086D4  9382805B   LBU V0, -32677(GP)
9D0086D8  24420001   ADDIU V0, V0, 1
9D0086DC  304200FF   ANDI V0, V0, 255
9D0086E0  A382805B   SB V0, -32677(GP)
395:                                 }
396:                 		break;
397:                 	case 9:   // paritée
398:                 		if (PORTA & KBD_DAT)
9D0086EC  3C02BF88   LUI V0, -16504
9D0086F0  8C426020   LW V0, 24608(V0)
9D0086F4  30420002   ANDI V0, V0, 2
9D0086F8  10400005   BEQ V0, ZERO, 0x9D008710
9D0086FC  00000000   NOP
399:                 			parity++;
9D008700  9382805C   LBU V0, -32676(GP)
9D008704  24420001   ADDIU V0, V0, 1
9D008708  304200FF   ANDI V0, V0, 255
9D00870C  A382805C   SB V0, -32676(GP)
400:                 		if (!(parity & 1)){
9D008710  9382805C   LBU V0, -32676(GP)
9D008714  30420001   ANDI V0, V0, 1
9D008718  14400008   BNE V0, ZERO, 0x9D00873C
9D00871C  00000000   NOP
401:                 			rx_flags |= F_ERROR;
9D008720  93828059   LBU V0, -32679(GP)
9D008724  304200FF   ANDI V0, V0, 255
9D008728  34420001   ORI V0, V0, 1
9D00872C  A3828059   SB V0, -32679(GP)
402:                                         IEC0CLR = _IEC0_INT4IE_MASK; // désactive l'interruption
9D008730  3C030080   LUI V1, 128
9D008734  3C02BF88   LUI V0, -16504
9D008738  AC431064   SW V1, 4196(V0)
403:                 		}
404:                 		bit_cnt++;
9D00873C  9382805B   LBU V0, -32677(GP)
9D008740  24420001   ADDIU V0, V0, 1
9D008744  304200FF   ANDI V0, V0, 255
9D008748  A382805B   SB V0, -32677(GP)
405:                 		break;
9D00874C  0B4021FF   J 0x9D0087FC
9D008750  3C030080   LUI V1, 128
406:                 	case 10:  // stop bit
407:                 		kbd_queue[tail]=in_byte;
9D008754  9384805D   LBU A0, -32675(GP)
9D008758  308400FF   ANDI A0, A0, 255
9D00875C  9383805E   LBU V1, -32674(GP)
9D008760  3C02A000   LUI V0, -24576
9D008764  24422A20   ADDIU V0, V0, 10784
9D008768  00821021   ADDU V0, A0, V0
9D00876C  A0430000   SB V1, 0(V0)
408:                 		tail++;
9D008770  9382805D   LBU V0, -32675(GP)
9D008774  24420001   ADDIU V0, V0, 1
9D008778  304200FF   ANDI V0, V0, 255
9D00877C  A382805D   SB V0, -32675(GP)
409:                 		tail &=31;
9D008780  9382805D   LBU V0, -32675(GP)
9D008784  3042001F   ANDI V0, V0, 31
9D008788  A382805D   SB V0, -32675(GP)
410:                 		bit_cnt=0;
9D00878C  A380805B   SB ZERO, -32677(GP)
411:                 		rx_flags |= F_RCVD;
9D008790  93828059   LBU V0, -32679(GP)
9D008794  304200FF   ANDI V0, V0, 255
9D008798  34420002   ORI V0, V0, 2
9D00879C  A3828059   SB V0, -32679(GP)
412:                 		break;
9D0087A0  0B4021FF   J 0x9D0087FC
9D0087A4  3C030080   LUI V1, 128
413:                 	default:
414:                 		in_byte >>=1;
9D0087A8  9382805E   LBU V0, -32674(GP)
9D0087AC  7C423040   EXT V0, V0, 1, 7
9D0087B0  A382805E   SB V0, -32674(GP)
415:                 		if(PORTA & KBD_DAT){
9D0087B4  3C02BF88   LUI V0, -16504
9D0087B8  8C426020   LW V0, 24608(V0)
9D0087BC  30420002   ANDI V0, V0, 2
9D0087C0  10400009   BEQ V0, ZERO, 0x9D0087E8
9D0087C4  00000000   NOP
416:                 			in_byte |=128;
9D0087C8  9382805E   LBU V0, -32674(GP)
9D0087CC  3042007F   ANDI V0, V0, 127
9D0087D0  34420080   ORI V0, V0, 128
9D0087D4  A382805E   SB V0, -32674(GP)
417:                 			parity++;
9D0087D8  9382805C   LBU V0, -32676(GP)
9D0087DC  24420001   ADDIU V0, V0, 1
9D0087E0  304200FF   ANDI V0, V0, 255
9D0087E4  A382805C   SB V0, -32676(GP)
418:                 		}
419:                 		bit_cnt++;
9D0087E8  9382805B   LBU V0, -32677(GP)
9D0087EC  24420001   ADDIU V0, V0, 1
9D0087F0  304200FF   ANDI V0, V0, 255
9D0087F4  A382805B   SB V0, -32677(GP)
420:                 	}
421:                         mINT4ClearIntFlag();
9D0086E4  0B4021FF   J 0x9D0087FC
9D0086E8  3C030080   LUI V1, 128
9D0087F8  3C030080   LUI V1, 128
9D0087FC  3C02BF88   LUI V0, -16504
9D008800  AC431034   SW V1, 4148(V0)
422:                 } // kbd_clk_isr()
9D008804  8FA4000C   LW A0, 12(SP)
9D008808  8FA30008   LW V1, 8(SP)
9D00880C  8FA20004   LW V0, 4(SP)
9D008810  41606000   DI ZERO
9D008814  000000C0   EHB
9D008818  8FBA001C   LW K0, 28(SP)
9D00881C  8FBB0018   LW K1, 24(SP)
9D008820  409A7000   MTC0 K0, EPC
9D008824  8FBA0014   LW K0, 20(SP)
9D008828  27BD0020   ADDIU SP, SP, 32
9D00882C  409A6002   MTC0 K0, SRSCtl
9D008830  41DDE800   WRPGPR SP, SP
9D008834  409B6000   MTC0 K1, Status
9D008838  42000018   ERET
423:                 
424:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/sdmmc.c  ------------------------------
1:                   /*
2:                   ** SDMMC.c SD card interface
3:                   **
4:                   ** 7/20/06 v1.4 LDJ
5:                   ** 7/14/07 v2.0 LDJ
6:                   **
7:                   [30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
8:                   ** 07 May 2012	Changes made to allow SD card library to support
9:                   **					PIC32 Pinguino and PIC32 Pinguino Micro that have neither
10:                  **					SD card presence nor WP switch detection switches.
11:                  **					see functions getCD() and getWP() below.
12:                  */
13:                  
14:                  #ifndef __SDMMC_C__
15:                  #define __SDMMC_C__
16:                  
17:                  //#include <system.c>
18:                  //#include <digitalw.c>
19:                  //#include <spi.c>        // in order to use default SPI port
20:                  #include <plib.h>
21:                  #include "sdmmc.h"
22:                  //#include "diskio.h"
23:                  //#include "ff.h"
24:                  
25:                  // send one byte of data and receive one back at the same time
26:                  unsigned char writeSPI(unsigned char b)
27:                  {
9D00C364  308400FF   ANDI A0, A0, 255
28:                  
29:                  	SPI2BUF = b;						
9D00C368  3C02BF80   LUI V0, -16512
9D00C36C  AC445A20   SW A0, 23072(V0)
30:                  	while(!SPI2STATbits.SPIRBF);	// wait transfer complete
9D00C370  3C03BF80   LUI V1, -16512
9D00C374  8C625A10   LW V0, 23056(V1)
9D00C378  30420001   ANDI V0, V0, 1
9D00C37C  1040FFFD   BEQ V0, ZERO, 0x9D00C374
9D00C380  3C02BF80   LUI V0, -16512
31:                  	return SPI2BUF;					// read the received value
9D00C384  8C425A20   LW V0, 23072(V0)
32:                  
33:                  /*
34:                  	BUFFER = b;			            // write to buffer for TX
35:                  	while (!STATRX);		        // wait until cycle complete
36:                  	return BUFFER;			        // return with byte read
37:                   */
38:                  }	// writeSPI
9D00C388  03E00008   JR RA
9D00C38C  304200FF   ANDI V0, V0, 255
39:                  
40:                  void initSD(void)
41:                  {
42:                  	PORTB |=SDCSEL; //digitalwrite(SDCSEL, HIGH);	// initially keep the SD card disabled
9D00C390  3C02BF88   LUI V0, -16504
9D00C394  8C436120   LW V1, 24864(V0)
9D00C398  34630004   ORI V1, V1, 4
9D00C39C  AC436120   SW V1, 24864(V0)
43:                  	TRISB &=~SDCSEL; //pinmode(SDCSEL, OUTPUT);		// make Card select an output pin
9D00C3A0  3C02BF88   LUI V0, -16504
9D00C3A4  8C446110   LW A0, 24848(V0)
9D00C3A8  2403FFFB   ADDIU V1, ZERO, -5
9D00C3AC  00831824   AND V1, A0, V1
9D00C3B0  AC436110   SW V1, 24848(V0)
44:                  
45:                  	// init the spi module for a slow (safe) clock speed first
46:                  
47:                  	SPI2CON = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
9D00C3B4  34038120   ORI V1, ZERO, -32480
9D00C3B8  3C02BF80   LUI V0, -16512
9D00C3BC  AC435A00   SW V1, 23040(V0)
48:                  	SPI2BRG = (mGetPeripheralClock() / (2 * 250000)) - 1;
9D00C3C0  2403004A   ADDIU V1, ZERO, 74
9D00C3C4  3C02BF80   LUI V0, -16512
9D00C3C8  AC435A30   SW V1, 23088(V0)
49:                  
50:                  /*
51:                  	SPICONF = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
52:                  	CLKSPD  = (GetPeripheralClock() / (2 * 250000)) - 1;
53:                  */
54:                  }   // initSD
9D00C3CC  03E00008   JR RA
9D00C3D0  00000000   NOP
55:                  
56:                  #define readSPI()   writeSPI(0xFF)
57:                  #define clockSPI()  writeSPI(0xFF)
58:                  
59:                  void disableSD(void)
60:                  {
9D00C3D4  27BDFFE8   ADDIU SP, SP, -24
9D00C3D8  AFBF0014   SW RA, 20(SP)
61:                  
62:                         PORTB |= SDCSEL; //digitalwrite(SDCSEL, HIGH);	// Deselected = SDCSEL high
9D00C3DC  3C02BF88   LUI V0, -16504
9D00C3E0  8C436120   LW V1, 24864(V0)
9D00C3E4  34630004   ORI V1, V1, 4
9D00C3E8  AC436120   SW V1, 24864(V0)
63:                         clockSPI();
9D00C3EC  0F4030D9   JAL writeSPI
9D00C3F0  240400FF   ADDIU A0, ZERO, 255
64:                  }
9D00C3F4  8FBF0014   LW RA, 20(SP)
9D00C3F8  03E00008   JR RA
9D00C3FC  27BD0018   ADDIU SP, SP, 24
65:                  
66:                  void enableSD(void)
67:                  {
68:                  	PORTB &= ~ SDCSEL; //digitalwrite(SDCSEL, LOW);	// Selected = SDCSEL low
9D00C400  3C02BF88   LUI V0, -16504
9D00C404  8C446120   LW A0, 24864(V0)
9D00C408  2403FFFB   ADDIU V1, ZERO, -5
9D00C40C  00831824   AND V1, A0, V1
9D00C410  AC436120   SW V1, 24864(V0)
69:                  }
9D00C414  03E00008   JR RA
9D00C418  00000000   NOP
70:                  
71:                  // c    command code
72:                  // a    byte address of data block
73:                  int sendSDCmd(unsigned char c, unsigned a)
74:                  {
9D00C41C  27BDFFE0   ADDIU SP, SP, -32
9D00C420  AFBF001C   SW RA, 28(SP)
9D00C424  AFB10018   SW S1, 24(SP)
9D00C428  AFB00014   SW S0, 20(SP)
9D00C42C  00A08821   ADDU S1, A1, ZERO
75:                  	int i, r;
76:                  
77:                  	// enable SD card
78:                  	// CS low
79:                  	enableSD();
9D00C430  0F403100   JAL enableSD
9D00C434  309000FF   ANDI S0, A0, 255
80:                  
81:                  	// send a comand packet (6 bytes)
82:                  	writeSPI(c | 0x40);    // send command
9D00C438  0F4030D9   JAL writeSPI
9D00C43C  36040040   ORI A0, S0, 64
83:                  	writeSPI(a>>24);       // msb of the address
9D00C440  0F4030D9   JAL writeSPI
9D00C444  00112602   SRL A0, S1, 24
84:                  	writeSPI(a>>16);
9D00C448  0F4030D9   JAL writeSPI
9D00C44C  7E243C00   EXT A0, S1, 16, 8
85:                  	writeSPI(a>>8);
9D00C450  0F4030D9   JAL writeSPI
9D00C454  7E243A00   EXT A0, S1, 8, 8
86:                  	writeSPI(a);           // lsb
9D00C458  0F4030D9   JAL writeSPI
9D00C45C  322400FF   ANDI A0, S1, 255
87:                  
88:                  	writeSPI(0x95);        // send CMD0 CRC
9D00C460  0F4030D9   JAL writeSPI
9D00C464  24040095   ADDIU A0, ZERO, 149
9D00C468  24100008   ADDIU S0, ZERO, 8
89:                  
90:                  	// now wait for a response, allow for up to 8 bytes delay
91:                  	for(i=0; i<8; i++)
9D00C480  1600FFFA   BNE S0, ZERO, 0x9D00C46C
9D00C484  00000000   NOP
92:                  	{
93:                  		r = readSPI();
9D00C46C  0F4030D9   JAL writeSPI
9D00C470  240400FF   ADDIU A0, ZERO, 255
94:                  		if (r != 0xFF)
9D00C474  240300FF   ADDIU V1, ZERO, 255
9D00C478  14430003   BNE V0, V1, 0x9D00C488
9D00C47C  2610FFFF   ADDIU S0, S0, -1
95:                  			break;
96:                  	}
97:                  	return (r);
98:                  
99:                  	/* return response
100:                 	FF - timeout
101:                 	00 - command accepted
102:                 	01 - command received, card in idle state after RESET
103:                 
104:                 	other codes:
105:                 	bit 0 = Idle state
106:                 	bit 1 = Erase Reset
107:                 	bit 2 = Illegal command
108:                 	bit 3 = Communication CRC error
109:                 	bit 4 = Erase sequence error
110:                 	bit 5 = Address error
111:                 	bit 6 = Parameter error
112:                 	bit 7 = Always 0
113:                 	*/
114:                 	// NOTE CSCD is still low!
115:                 } // sendSDCmd
9D00C488  8FBF001C   LW RA, 28(SP)
9D00C48C  8FB10018   LW S1, 24(SP)
9D00C490  8FB00014   LW S0, 20(SP)
9D00C494  03E00008   JR RA
9D00C498  27BD0020   ADDIU SP, SP, 32
116:                 
117:                 
118:                 // returns 0 if successful
119:                 //          E_COMMAND_ACK   failed to acknowledge reset command
120:                 //          E_INIT_TIMEOUT  failed to initialize
121:                 int initMedia(void)
122:                 {
9D00C49C  27BDFFE0   ADDIU SP, SP, -32
9D00C4A0  AFBF001C   SW RA, 28(SP)
9D00C4A4  AFB10018   SW S1, 24(SP)
123:                 	int i, r;
124:                 
125:                 	// 1. with the card NOT selected
126:                 	// Set DI and CS high
127:                 	disableSD();
9D00C4A8  0F4030F5   JAL disableSD
9D00C4AC  AFB00014   SW S0, 20(SP)
128:                 
129:                 	// 2. send 74 or more clock cycles to start up
130:                 	// apply 74 or more clock pulses to SCLK.
131:                 	// The card will enter its native operating mode and go ready to accept native commands.
132:                 	for (i=0; i<10; i++)
9D00C4B0  00008021   ADDU S0, ZERO, ZERO
9D00C4B4  2411000A   ADDIU S1, ZERO, 10
9D00C4C0  26100001   ADDIU S0, S0, 1
9D00C4C4  1611FFFC   BNE S0, S1, 0x9D00C4B8
9D00C4C8  00000000   NOP
133:                 		clockSPI();
9D00C4B8  0F4030D9   JAL writeSPI
9D00C4BC  240400FF   ADDIU A0, ZERO, 255
134:                 
135:                 	// 3. now select the card
136:                 	enableSD();
9D00C4CC  0F403100   JAL enableSD
9D00C4D0  00000000   NOP
137:                 
138:                 	//card detection is now in disk_initialize()
139:                 
140:                 	return 0;
141:                 } // init media
9D00C4D4  00001021   ADDU V0, ZERO, ZERO
9D00C4D8  8FBF001C   LW RA, 28(SP)
9D00C4DC  8FB10018   LW S1, 24(SP)
9D00C4E0  8FB00014   LW S0, 20(SP)
9D00C4E4  03E00008   JR RA
9D00C4E8  27BD0020   ADDIU SP, SP, 32
142:                 
143:                 
144:                 // a        LBA of sector requested
145:                 // p        pointer to sector buffer
146:                 // returns  TRUE if successful
147:                 int readSECTOR(LBA a, char *p)
148:                 {
9D00C4EC  27BDFFD8   ADDIU SP, SP, -40
9D00C4F0  AFBF0024   SW RA, 36(SP)
9D00C4F4  AFB40020   SW S4, 32(SP)
9D00C4F8  AFB3001C   SW S3, 28(SP)
9D00C4FC  AFB20018   SW S2, 24(SP)
9D00C500  AFB10014   SW S1, 20(SP)
9D00C504  AFB00010   SW S0, 16(SP)
9D00C508  00A08821   ADDU S1, A1, ZERO
149:                 	int r, i;
150:                 
151:                 	#ifdef READ_LED
152:                         _read_off();
9D00C50C  3C02BF88   LUI V0, -16504
9D00C510  8C456120   LW A1, 24864(V0)
9D00C514  2403FFF7   ADDIU V1, ZERO, -9
9D00C518  00A31824   AND V1, A1, V1
9D00C51C  AC436120   SW V1, 24864(V0)
153:                 	//digitalwrite(READ_LED, 0);
154:                 	#endif
155:                 
156:                 	// 1. send READ command
157:                 	r = sendSDCmd(READ_SINGLE, (a << 9));
9D00C520  00042A40   SLL A1, A0, 9
9D00C524  0F403107   JAL sendSDCmd
9D00C528  24040011   ADDIU A0, ZERO, 17
158:                 	if (r == 0)    // check if command was accepted
9D00C52C  1440001A   BNE V0, ZERO, 0x9D00C598
9D00C530  00409021   ADDU S2, V0, ZERO
9D00C534  00008021   ADDU S0, ZERO, ZERO
159:                 	{
160:                 	// 2. wait for a response
161:                 	for(i=0; i<R_TIMEOUT; i++)
9D00C53C  241461A8   ADDIU S4, ZERO, 25000
9D00C550  26100001   ADDIU S0, S0, 1
9D00C554  1614FFFA   BNE S0, S4, 0x9D00C540
9D00C558  00000000   NOP
9D00C55C  0B403166   J 0x9D00C598
9D00C560  00000000   NOP
162:                 	{
163:                 	r = readSPI();
9D00C540  0F4030D9   JAL writeSPI
9D00C544  240400FF   ADDIU A0, ZERO, 255
164:                 	if (r == DATA_START)
9D00C538  241300FE   ADDIU S3, ZERO, 254
9D00C548  10530006   BEQ V0, S3, 0x9D00C564
9D00C54C  00409021   ADDU S2, V0, ZERO
165:                 	break;
166:                 	}
167:                 
168:                 	// 3. if it did not timeout, read 512 byte of data
169:                 	if (i != R_TIMEOUT)
9D00C564  240261A8   ADDIU V0, ZERO, 25000
9D00C568  1202000B   BEQ S0, V0, 0x9D00C598
9D00C56C  26300200   ADDIU S0, S1, 512
170:                 	{
171:                 		i = 512;
172:                 		do{
173:                 			*p++ = readSPI();
9D00C570  0F4030D9   JAL writeSPI
9D00C574  240400FF   ADDIU A0, ZERO, 255
9D00C578  A2220000   SB V0, 0(S1)
9D00C57C  26310001   ADDIU S1, S1, 1
174:                 		} while (--i>0);
9D00C580  1630FFFB   BNE S1, S0, 0x9D00C570
9D00C584  00000000   NOP
175:                 
176:                 		// 4. ignore CRC
177:                 		readSPI();
9D00C588  0F4030D9   JAL writeSPI
9D00C58C  240400FF   ADDIU A0, ZERO, 255
178:                 		readSPI();
9D00C590  0F4030D9   JAL writeSPI
9D00C594  240400FF   ADDIU A0, ZERO, 255
179:                 
180:                 	} // data arrived
181:                 
182:                 	} // command accepted
183:                 
184:                 	// 5. remember to disable the card
185:                 	disableSD();
9D00C598  0F4030F5   JAL disableSD
9D00C59C  00000000   NOP
186:                 
187:                 	#ifdef READ_LED
188:                         _read_on();
9D00C5A0  3C02BF88   LUI V0, -16504
9D00C5A4  8C436120   LW V1, 24864(V0)
9D00C5A8  34630008   ORI V1, V1, 8
9D00C5AC  AC436120   SW V1, 24864(V0)
189:                 	//digital(READ_LED, 1);
190:                 	#endif
191:                 
192:                 	return (r == DATA_START);    // return TRUE if successful
9D00C5B0  3A4200FE   XORI V0, S2, 254
193:                 } // readSECTOR
9D00C5B4  2C420001   SLTIU V0, V0, 1
9D00C5B8  8FBF0024   LW RA, 36(SP)
9D00C5BC  8FB40020   LW S4, 32(SP)
9D00C5C0  8FB3001C   LW S3, 28(SP)
9D00C5C4  8FB20018   LW S2, 24(SP)
9D00C5C8  8FB10014   LW S1, 20(SP)
9D00C5CC  8FB00010   LW S0, 16(SP)
9D00C5D0  03E00008   JR RA
9D00C5D4  27BD0028   ADDIU SP, SP, 40
194:                 
195:                 
196:                 // a        LBA of sector requested
197:                 // p        pointer to sector buffer
198:                 // returns  TRUE if successful
199:                 int writeSECTOR(LBA a, char *p)
9D00C60C  26110200   ADDIU S1, S0, 512
200:                 {
9D00C5D8  27BDFFE0   ADDIU SP, SP, -32
9D00C5DC  AFBF001C   SW RA, 28(SP)
9D00C5E0  AFB20018   SW S2, 24(SP)
9D00C5E4  AFB10014   SW S1, 20(SP)
9D00C5E8  AFB00010   SW S0, 16(SP)
9D00C5EC  00A08021   ADDU S0, A1, ZERO
201:                 	unsigned r, i;
202:                 
203:                 	// 0. check Write Protect
204:                 //	if (getWP())
205:                 //		return FAIL;
206:                 
207:                 	// 1. send WRITE command
208:                 	r = sendSDCmd(WRITE_SINGLE, (a << 9));
9D00C5F0  00042A40   SLL A1, A0, 9
9D00C5F4  0F403107   JAL sendSDCmd
9D00C5F8  24040018   ADDIU A0, ZERO, 24
209:                 	if (r == 0)    // check if command was accepted
9D00C5FC  14400025   BNE V0, ZERO, 0x9D00C694
9D00C600  00409021   ADDU S2, V0, ZERO
210:                 	{
211:                 		// 2. send data
212:                 		writeSPI(DATA_START);
9D00C604  0F4030D9   JAL writeSPI
9D00C608  240400FE   ADDIU A0, ZERO, 254
213:                 
214:                 		// send 512 bytes of data
215:                 		for(i=0; i<512; i++)
9D00C61C  5611FFFD   BNEL S0, S1, 0x9D00C614
9D00C620  92040000   LBU A0, 0(S0)
216:                 		writeSPI(*p++);
9D00C610  92040000   LBU A0, 0(S0)
9D00C614  0F4030D9   JAL writeSPI
9D00C618  26100001   ADDIU S0, S0, 1
217:                 
218:                 		// 3. send dummy CRC
219:                 		clockSPI();
9D00C624  0F4030D9   JAL writeSPI
9D00C628  240400FF   ADDIU A0, ZERO, 255
220:                 		clockSPI();
9D00C62C  0F4030D9   JAL writeSPI
9D00C630  240400FF   ADDIU A0, ZERO, 255
221:                 
222:                 		// 4. check if data accepted
223:                 		r = readSPI();
9D00C634  0F4030D9   JAL writeSPI
9D00C638  240400FF   ADDIU A0, ZERO, 255
224:                 		if ((r & 0xf) == DATA_ACCEPT)
9D00C63C  3042000F   ANDI V0, V0, 15
9D00C640  24030005   ADDIU V1, ZERO, 5
9D00C644  14430013   BNE V0, V1, 0x9D00C694
9D00C648  3C02BF88   LUI V0, -16504
225:                 		{
226:                 			#ifdef WRITE_LED
227:                                         _write_off();
9D00C64C  8C446120   LW A0, 24864(V0)
9D00C650  2403FFF7   ADDIU V1, ZERO, -9
9D00C654  00831824   AND V1, A0, V1
9D00C658  AC436120   SW V1, 24864(V0)
228:                 			//digitalwrite(WRITE_LED, 0);
229:                 			#endif
230:                 
231:                 			// 5. wait for write completion
232:                 			for(i=0; i<W_TIMEOUT; i++)
9D00C65C  00008021   ADDU S0, ZERO, ZERO
9D00C660  3C110003   LUI S1, 3
9D00C664  3631D090   ORI S1, S1, -12144
9D00C678  26100001   ADDIU S0, S0, 1
9D00C67C  1611FFFA   BNE S0, S1, 0x9D00C668
9D00C680  00000000   NOP
233:                 			{
234:                 				r = readSPI();
9D00C668  0F4030D9   JAL writeSPI
9D00C66C  240400FF   ADDIU A0, ZERO, 255
235:                 				if (r != 0 )
9D00C670  14400004   BNE V0, ZERO, 0x9D00C684
9D00C674  00409021   ADDU S2, V0, ZERO
236:                 					break;
237:                 			}
238:                 			#ifdef WRITE_LED
239:                                         _write_on();
9D00C684  3C02BF88   LUI V0, -16504
9D00C688  8C436120   LW V1, 24864(V0)
9D00C68C  34630008   ORI V1, V1, 8
9D00C690  AC436120   SW V1, 24864(V0)
240:                 			//digitalwrite(WRITE_LED, 1);
241:                 			#endif
242:                 		} // accepted
243:                 		else
244:                 		{
245:                 			r = FAIL;
246:                 		}
247:                 	} // command accepted
248:                 
249:                 	// 6. disable the card
250:                 	disableSD();
9D00C694  0F4030F5   JAL disableSD
9D00C698  00000000   NOP
251:                 
252:                 	return (r);      // return TRUE if successful
253:                 } // writeSECTOR
9D00C69C  02401021   ADDU V0, S2, ZERO
9D00C6A0  8FBF001C   LW RA, 28(SP)
9D00C6A4  8FB20018   LW S2, 24(SP)
9D00C6A8  8FB10014   LW S1, 20(SP)
9D00C6AC  8FB00010   LW S0, 16(SP)
9D00C6B0  03E00008   JR RA
9D00C6B4  27BD0020   ADDIU SP, SP, 32
254:                 
255:                 
256:                 // SD card connector presence detection switch
257:                 // returns  TRUE card present
258:                 //          FALSE card not present
259:                 int getCD(void)
260:                 {
261:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
262:                 // 2013-09-05 ** added support for VPC_32
263:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined (EMPEROR460) || defined(VPC_32)
264:                 	return TRUE;
265:                 #else
266:                 	return (SDCD);
267:                 #endif
268:                 }
9D00C6B8  03E00008   JR RA
9D00C6BC  24020001   ADDIU V0, ZERO, 1
269:                 
270:                 // card Write Protect tab detection switch
271:                 // returns  TRUE write protect tab on LOCK
272:                 //          FALSE write protection tab OPEN
273:                 int getWP(void)
274:                 {
275:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
276:                 // 2013-09-05 ** added support for VPC_32
277:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined(EMPEROR460) || defined (VPC_32)
278:                 	return FALSE;
279:                 #else
280:                 	return (SDWP);
281:                 #endif
282:                 }
9D00C6C0  03E00008   JR RA
9D00C6C4  00001021   ADDU V0, ZERO, ZERO
283:                 
284:                 #endif /* __SDMMC_C__ */
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/fileio.c  -----------------------------
1:                   /*	----------------------------------------------------------------------------
2:                   	FILE:			fileio.c
3:                   	PROJECT:		pinguino32
4:                   	PURPOSE:		SD Card file system functions
5:                   	AUTHORS:		Alfred Broda <alfredbroda@gmail.com>
6:                   					Mark Harper <markfh@f2s.com>
7:                   					Regis Blanchot <rblanchot@gmail.com>
8:                   	FIRST RELEASE:	23 dec. 2011
9:                   	LAST RELEASE:	06 jan. 2012
10:                  	----------------------------------------------------------------------------
11:                  	based on original code by Regis Blanchot and FatFS example for PIC24
12:                  	----------------------------------------------------------------------------
13:                   	[30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
14:                  	07 May 2012	As part of providing support for PIC32 Pinguino Micro and
15:                  					potentially other cards removed #if defined (PIC32_Pinguino) etc
16:                  					and #endif in function mount() so that SDCS is set via mount 
17:                  					for all cards.
18:                  */
19:                  
20:                  #ifndef __FILEIO_C__
21:                  #define __FILEIO_C__
22:                  
23:                  // standard C libraries used
24:                  #include <ctype.h>      		// toupper...
25:                  #include <string.h>     		// memcpy...
26:                  //#include <malloc.h>				// malloc, free?
27:                  #include <GenericTypeDefs.h>
28:                  
29:                  #include "fileio.h"
30:                  #include "sdmmc.h"
31:                  #include "ff.h"					// Fat Filesystem
32:                  #include "diskio.h"				// card access functions
33:                  #include "../serial_comm.h"
34:                  
35:                  //#define SD_DEBUG
36:                  
37:                  //#ifdef SD_DEBUG
38:                  //    #include <__cdc.c>          // USB CDC functions
39:                  //#endif
40:                  
41:                  /*	----------------------------------------------------------------------------
42:                   mount
43:                   initializes a MEDIA structure for FILEIO access
44:                   will mount only the first partition on the disk/card
45:                   --------------------------------------------------------------------------*/
46:                  
47:                  static FATFS _Fat;
48:                  
49:                  char mount(unsigned char pin) {
9D00D0EC  27BDFFE0   ADDIU SP, SP, -32
9D00D0F0  AFBF001C   SW RA, 28(SP)
50:                  	int flag, i;
51:                  	FRESULT r;
52:                  
53:                  	SDCS = pin;
9D00D0F4  A38480DC   SB A0, -32548(GP)
54:                  
55:                  	// 0. init the I/Os
56:                  #ifdef SD_DEBUG
57:                  	UartPrint(STDOUT,"Initialisation carte SD\r");
9D00D0F8  24040001   ADDIU A0, ZERO, 1
9D00D0FC  3C059D01   LUI A1, -25343
9D00D100  0F4032EC   JAL UartPrint
9D00D104  24A5F0B8   ADDIU A1, A1, -3912
58:                  #endif
59:                  	initSD();
9D00D108  0F4030E4   JAL initSD
9D00D10C  00000000   NOP
60:                  
61:                  #ifdef SD_DEBUG
62:                  	UartPrint(STDOUT,"Looking for SD slot... ");
9D00D110  24040001   ADDIU A0, ZERO, 1
9D00D114  3C059D01   LUI A1, -25343
9D00D118  0F4032EC   JAL UartPrint
9D00D11C  24A5F0D4   ADDIU A1, A1, -3884
63:                  #endif
64:                  	// 1. check if the card is in the slot
65:                  	if (!getCD()) {
9D00D120  0F4031AE   JAL getCD
9D00D124  00000000   NOP
9D00D128  14400008   BNE V0, ZERO, 0x9D00D14C
9D00D12C  24040001   ADDIU A0, ZERO, 1
66:                  		FError = FE_NOT_PRESENT;
9D00D130  24020002   ADDIU V0, ZERO, 2
9D00D134  A38280D0   SB V0, -32560(GP)
67:                  #ifdef SD_DEBUG
68:                  		UartPrint(STDOUT, "Échec!\r");
9D00D138  3C059D01   LUI A1, -25343
9D00D13C  0F4032EC   JAL UartPrint
9D00D140  24A5F0EC   ADDIU A1, A1, -3860
69:                  #endif
70:                  		return FALSE;
9D00D144  0B403497   J 0x9D00D25C
9D00D148  00001021   ADDU V0, ZERO, ZERO
71:                  	}
72:                  #ifdef SD_DEBUG
73:                  	UartPrint(STDOUT,"OK\r");
9D00D14C  3C059D01   LUI A1, -25343
9D00D150  0F4032EC   JAL UartPrint
9D00D154  24A5F0F4   ADDIU A1, A1, -3852
74:                  #endif
75:                  
76:                  	// 2. initialize the card
77:                  #ifdef SD_DEBUG
78:                  	UartPrint(STDOUT,"Initializing SD card... ");
9D00D158  24040001   ADDIU A0, ZERO, 1
9D00D15C  3C059D01   LUI A1, -25343
9D00D160  0F4032EC   JAL UartPrint
9D00D164  24A5F0F8   ADDIU A1, A1, -3848
79:                  #endif
80:                  	initMedia();
9D00D168  0F403127   JAL initMedia
9D00D16C  00000000   NOP
81:                          if (disk_initialize(0)==STA_NOINIT){
9D00D170  0F4022E6   JAL disk_initialize
9D00D174  00002021   ADDU A0, ZERO, ZERO
9D00D178  24030001   ADDIU V1, ZERO, 1
9D00D17C  14430006   BNE V0, V1, 0x9D00D198
9D00D180  24040001   ADDIU A0, ZERO, 1
82:                  #ifdef SD_DEBUG
83:                              UartPrint(STDOUT,"Echec d'initialisation de la carte SD\r");
9D00D184  3C059D01   LUI A1, -25343
9D00D188  0F4032EC   JAL UartPrint
9D00D18C  24A5F114   ADDIU A1, A1, -3820
84:                  #endif
85:                              return 0;
9D00D190  0B403497   J 0x9D00D25C
9D00D194  00001021   ADDU V0, ZERO, ZERO
86:                          };
87:                  #ifdef SD_DEBUG
88:                          UartPrint(STDOUT,"OK\r");
9D00D198  3C059D01   LUI A1, -25343
9D00D19C  0F4032EC   JAL UartPrint
9D00D1A0  24A5F0F4   ADDIU A1, A1, -3852
89:                  #endif
90:                  	// We're skipping the old step 3 because there's no need for malloc
91:                  	// This takes 6k off the code size if malloc is not used elsewhere.
92:                  	// Instead, just point it to our _Fat var.
93:                  	// The FATFS struct takes only 560 bytes of mem.
94:                  	Fat = &_Fat;
9D00D1A4  3C02A000   LUI V0, -24576
9D00D1A8  24422774   ADDIU V0, V0, 10100
9D00D1AC  AF8280D4   SW V0, -32556(GP)
95:                  
96:                  	// Mount media
97:                  #ifdef SD_DEBUG
98:                  	UartPrint(STDOUT,"Mounting FAT filesystem... ");
9D00D1B0  24040001   ADDIU A0, ZERO, 1
9D00D1B4  3C059D01   LUI A1, -25343
9D00D1B8  0F4032EC   JAL UartPrint
9D00D1BC  24A5F13C   ADDIU A1, A1, -3780
99:                  #endif
100:                 	r = f_mount(0, Fat);
9D00D1C0  00002021   ADDU A0, ZERO, ZERO
9D00D1C4  0F40140C   JAL f_mount
9D00D1C8  8F8580D4   LW A1, -32556(GP)
101:                 	if (r != FR_OK) {
9D00D1CC  10400007   BEQ V0, ZERO, 0x9D00D1EC
9D00D1D0  24040001   ADDIU A0, ZERO, 1
102:                 		FError = r;
9D00D1D4  A38280D0   SB V0, -32560(GP)
103:                 #ifdef SD_DEBUG
104:                 		UartPrint(STDOUT,"Failed!\r");
9D00D1D8  3C059D01   LUI A1, -25343
9D00D1DC  0F4032EC   JAL UartPrint
9D00D1E0  24A5F158   ADDIU A1, A1, -3752
105:                 #endif
106:                 		//free(Fat);
107:                 		return FALSE;
9D00D1E4  0B403497   J 0x9D00D25C
9D00D1E8  00001021   ADDU V0, ZERO, ZERO
108:                 	}
109:                 #ifdef SD_DEBUG
110:                 	UartPrint(STDOUT, "OK\r");
9D00D1EC  3C059D01   LUI A1, -25343
9D00D1F0  0F4032EC   JAL UartPrint
9D00D1F4  24A5F0F4   ADDIU A1, A1, -3852
111:                 #endif
112:                 
113:                 #ifdef SD_DEBUG
114:                 	UartPrint(STDOUT,"Checking FAT filesystem... ");
9D00D1F8  24040001   ADDIU A0, ZERO, 1
9D00D1FC  3C059D01   LUI A1, -25343
9D00D200  0F4032EC   JAL UartPrint
9D00D204  24A5F164   ADDIU A1, A1, -3740
115:                 #endif
116:                 	const TCHAR * pth = "/";
9D00D208  3C029D01   LUI V0, -25343
9D00D20C  2442F180   ADDIU V0, V0, -3712
9D00D210  AFA20010   SW V0, 16(SP)
117:                 	r = chk_mounted(&pth, &Fat, 0);
9D00D214  27A40010   ADDIU A0, SP, 16
9D00D218  278580D4   ADDIU A1, GP, -32556
9D00D21C  0F4012DA   JAL chk_mounted
9D00D220  00003021   ADDU A2, ZERO, ZERO
118:                 	if (r != FR_OK) {
9D00D224  10400009   BEQ V0, ZERO, 0x9D00D24C
9D00D228  24040001   ADDIU A0, ZERO, 1
119:                 		FError = r;
9D00D22C  A38280D0   SB V0, -32560(GP)
120:                 #ifdef SD_DEBUG
121:                 		UartPrint(STDOUT, "Failed!\r");
9D00D230  3C059D01   LUI A1, -25343
9D00D234  0F4032EC   JAL UartPrint
9D00D238  24A5F158   ADDIU A1, A1, -3752
122:                                  //put_rc(r);
123:                 #endif
124:                 		unmount();
9D00D23C  0F403430   JAL unmount
9D00D240  00000000   NOP
125:                 		return FALSE;
9D00D244  0B403497   J 0x9D00D25C
9D00D248  00001021   ADDU V0, ZERO, ZERO
126:                 	}
127:                 #ifdef SD_DEBUG
128:                 	UartPrint(STDOUT, "OK\r");
9D00D24C  3C059D01   LUI A1, -25343
9D00D250  0F4032EC   JAL UartPrint
9D00D254  24A5F0F4   ADDIU A1, A1, -3852
129:                 #endif
130:                 
131:                 	return TRUE;
9D00D258  24020001   ADDIU V0, ZERO, 1
132:                 } // mount
9D00D25C  8FBF001C   LW RA, 28(SP)
9D00D260  03E00008   JR RA
9D00D264  27BD0020   ADDIU SP, SP, 32
133:                 
134:                 /*	----------------------------------------------------------------------------
135:                  unmount    initializes a MEDIA structure for FILEIO access
136:                  --------------------------------------------------------------------------*/
137:                 
138:                 void unmount(void) {
9D00D0C0  27BDFFE8   ADDIU SP, SP, -24
9D00D0C4  AFBF0014   SW RA, 20(SP)
139:                 	f_mount(0, NULL);
9D00D0C8  00002021   ADDU A0, ZERO, ZERO
9D00D0CC  0F40140C   JAL f_mount
9D00D0D0  00002821   ADDU A1, ZERO, ZERO
140:                 	//free(Fat);
141:                 	SPI2CONCLR = 0x8000; // SPI2 OFF
9D00D0D4  34038000   ORI V1, ZERO, -32768
9D00D0D8  3C02BF80   LUI V0, -16512
9D00D0DC  AC435A04   SW V1, 23044(V0)
142:                 } // unmount
9D00D0E0  8FBF0014   LW RA, 20(SP)
9D00D0E4  03E00008   JR RA
9D00D0E8  27BD0018   ADDIU SP, SP, 24
143:                 
144:                 /*	----------------------------------------------------------------------------
145:                  present   test if a SD card is present
146:                  --------------------------------------------------------------------------*/
147:                 
148:                 char SD_present(unsigned char pin) {
9D00D268  27BDFFE8   ADDIU SP, SP, -24
9D00D26C  AFBF0014   SW RA, 20(SP)
149:                 	if (mount(pin)) {
9D00D270  0F40343B   JAL mount
9D00D274  308400FF   ANDI A0, A0, 255
9D00D278  10400004   BEQ V0, ZERO, 0x9D00D28C
9D00D27C  00001821   ADDU V1, ZERO, ZERO
150:                 		unmount();
9D00D280  0F403430   JAL unmount
9D00D284  00000000   NOP
151:                 		return TRUE;
9D00D288  24030001   ADDIU V1, ZERO, 1
152:                 	} else {
153:                 		return FALSE;
154:                 	}
155:                 }
9D00D28C  00601021   ADDU V0, V1, ZERO
9D00D290  8FBF0014   LW RA, 20(SP)
9D00D294  03E00008   JR RA
9D00D298  27BD0018   ADDIU SP, SP, 24
156:                 
157:                 /*	----------------------------------------------------------------------------
158:                  Scans the current disk and compiles a list of files with a given extension
159:                  list     array of file names max * 8
160:                  max      number of entries
161:                  ext      file extension we are searching for
162:                  return   number of files found
163:                  --------------------------------------------------------------------------*/
164:                 
165:                 //unsigned listTYPE(char *listname, long *listsize, int max, const char *ext )
166:                 unsigned listTYPE(DIRTABLE *list, int max, const char *ext)
167:                 //unsigned listTYPE(char *list, int max, const char *ext )
168:                 {
169:                 	//TODO: implement
170:                 
171:                 	return 0;
172:                 } // listTYPE
9D00D29C  03E00008   JR RA
9D00D2A0  00001021   ADDU V0, ZERO, ZERO
173:                 
174:                 /* Prints the directory contents */
175:                 unsigned listDir(const char *path) {
9D00D2A4  27BDFFC0   ADDIU SP, SP, -64
9D00D2A8  AFBF003C   SW RA, 60(SP)
9D00D2AC  AFB10038   SW S1, 56(SP)
9D00D2B0  AFB00034   SW S0, 52(SP)
9D00D2B4  00808021   ADDU S0, A0, ZERO
176:                 	//TODO: remove all CDC references
177:                 	long p1;
178:                 	PF_BYTE res, b;
179:                 	UINT s1, s2;
180:                 	DIR dir; /* Directory object */
181:                 
182:                 	res = f_opendir(&dir, "/");
9D00D2B8  27A40010   ADDIU A0, SP, 16
9D00D2BC  3C059D01   LUI A1, -25343
9D00D2C0  0F40178A   JAL f_opendir
9D00D2C4  24A5F180   ADDIU A1, A1, -3712
183:                 #ifdef SD_DEBUG
184:                 	UartPrint(STDOUT,"f_opendir? ");
9D00D2C8  24040001   ADDIU A0, ZERO, 1
9D00D2CC  3C059D01   LUI A1, -25343
9D00D2D0  0F4032EC   JAL UartPrint
9D00D2D4  24A5F184   ADDIU A1, A1, -3708
185:                 	//put_rc(res);
186:                 #endif
187:                 	p1 = s1 = s2 = 0;
9D00D2F8  00008821   ADDU S1, ZERO, ZERO
188:                 	//CDCprintln("\nf_readdir('%s'): ", path);
189:                         print("\rnf_readdir('");
9D00D2D8  3C049D01   LUI A0, -25343
9D00D2DC  0F402601   JAL print
9D00D2E0  2484F190   ADDIU A0, A0, -3696
190:                         print(path);
9D00D2E4  0F402601   JAL print
9D00D2E8  02002021   ADDU A0, S0, ZERO
191:                         print("'):");
9D00D2EC  3C049D01   LUI A0, -25343
9D00D2F0  0F402601   JAL print
9D00D2F4  2484F1A0   ADDIU A0, A0, -3680
192:                 	for (;;) {
193:                 		res = f_readdir(&dir, &Finfo);
9D00D2FC  3C10A000   LUI S0, -24576
9D00D300  2610255C   ADDIU S0, S0, 9564
9D00D304  27A40010   ADDIU A0, SP, 16
9D00D308  0F4017BB   JAL f_readdir
9D00D30C  02002821   ADDU A1, S0, ZERO
194:                 #ifdef SD_DEBUG
195:                 //		put_rc(res);
196:                 #endif
197:                 		if ((res != FR_OK) || !Finfo.fname[0]) {
9D00D310  304200FF   ANDI V0, V0, 255
9D00D314  14400009   BNE V0, ZERO, 0x9D00D33C
9D00D318  02201021   ADDU V0, S1, ZERO
9D00D31C  82020009   LB V0, 9(S0)
9D00D320  10400006   BEQ V0, ZERO, 0x9D00D33C
9D00D324  02201021   ADDU V0, S1, ZERO
198:                 			break;
199:                 		}
200:                 
201:                 		if (Finfo.fattrib & AM_DIR) {
9D00D328  92020008   LBU V0, 8(S0)
9D00D32C  30420010   ANDI V0, V0, 16
202:                 			s2++;
203:                 		} else {
204:                 			s1++;
9D00D330  2C420001   SLTIU V0, V0, 1
9D00D334  0B4034C1   J 0x9D00D304
9D00D338  02228821   ADDU S1, S1, V0
205:                 			p1 += Finfo.fsize;
206:                 		}
207:                 /* what about other outputs ?
208:                 		UartPrint(STDOUT,"%c%c%c%c%c ",
209:                                 (Finfo.fattrib & AM_DIR) ? 'D' : '-',
210:                 				(Finfo.fattrib & AM_RDO) ? 'R' : '-',
211:                 				(Finfo.fattrib & AM_HID) ? 'H' : '-',
212:                 				(Finfo.fattrib & AM_SYS) ? 'S' : '-',
213:                 				(Finfo.fattrib & AM_ARC) ? 'A' : '-');
214:                 		UartPrint(STDOUT,"%u/%02u/%02u %02u:%02u ",
215:                                 (Finfo.fdate >> 9) + 1980,
216:                 				(Finfo.fdate >> 5) & 15, Finfo.fdate & 31, (Finfo.ftime >> 11),
217:                 				(Finfo.ftime >> 5) & 63);
218:                 		UartPrint(STDOUT," %9u ", Finfo.fsize);
219:                 		UartPrint(STDOUT, " %-12s %s", Finfo.fname,
220:                 #if _USE_LFN
221:                 				Lfname);
222:                 #else
223:                 				"");
224:                 #endif
225:                 */
226:                 	}
227:                 
228:                 	return s1;
229:                 } // listDir
9D00D33C  8FBF003C   LW RA, 60(SP)
9D00D340  8FB10038   LW S1, 56(SP)
9D00D344  8FB00034   LW S0, 52(SP)
9D00D348  03E00008   JR RA
9D00D34C  27BD0040   ADDIU SP, SP, 64
230:                 
231:                 char isDirectory(FILINFO file) {
9D00D350  AFA40000   SW A0, 0(SP)
9D00D354  AFA50004   SW A1, 4(SP)
9D00D358  AFA60008   SW A2, 8(SP)
9D00D35C  AFA7000C   SW A3, 12(SP)
232:                 	if (file.fattrib & AM_DIR) {
233:                 		return TRUE;
234:                 	} else {
235:                 		return FALSE;
236:                 	}
237:                 }
9D00D360  03E00008   JR RA
9D00D364  7CC20100   EXT V0, A2, 4, 1
238:                 
239:                 char isReadOnly(FILINFO file) {
9D00D368  AFA40000   SW A0, 0(SP)
9D00D36C  AFA50004   SW A1, 4(SP)
9D00D370  AFA60008   SW A2, 8(SP)
9D00D374  AFA7000C   SW A3, 12(SP)
240:                 	if (file.fattrib & AM_RDO) {
241:                 		return TRUE;
242:                 	} else {
243:                 		return FALSE;
244:                 	}
245:                 }
9D00D378  03E00008   JR RA
9D00D37C  30C20001   ANDI V0, A2, 1
246:                 
247:                 char isHidden(FILINFO file) {
9D00D380  AFA40000   SW A0, 0(SP)
9D00D384  AFA50004   SW A1, 4(SP)
9D00D388  AFA60008   SW A2, 8(SP)
9D00D38C  AFA7000C   SW A3, 12(SP)
248:                 	if (file.fattrib & AM_HID) {
249:                 		return TRUE;
250:                 	} else {
251:                 		return FALSE;
252:                 	}
253:                 }
9D00D390  03E00008   JR RA
9D00D394  7CC20040   EXT V0, A2, 1, 1
254:                 
255:                 char isSystem(FILINFO file) {
9D00D398  AFA40000   SW A0, 0(SP)
9D00D39C  AFA50004   SW A1, 4(SP)
9D00D3A0  AFA60008   SW A2, 8(SP)
9D00D3A4  AFA7000C   SW A3, 12(SP)
256:                 	if (file.fattrib & AM_SYS) {
257:                 		return TRUE;
258:                 	} else {
259:                 		return FALSE;
260:                 	}
261:                 }
9D00D3A8  03E00008   JR RA
9D00D3AC  7CC20080   EXT V0, A2, 2, 1
262:                 
263:                 char isArchive(FILINFO file) {
9D00D3B0  AFA40000   SW A0, 0(SP)
9D00D3B4  AFA50004   SW A1, 4(SP)
9D00D3B8  AFA60008   SW A2, 8(SP)
9D00D3BC  AFA7000C   SW A3, 12(SP)
264:                 	if (file.fattrib & AM_ARC) {
265:                 		return TRUE;
266:                 	} else {
267:                 		return FALSE;
268:                 	}
269:                 }
9D00D3C0  03E00008   JR RA
9D00D3C4  7CC20140   EXT V0, A2, 5, 1
270:                 #endif /* __FILEIO_C__ */
271:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/ff.c  ---------------------------------
1:                   /*----------------------------------------------------------------------------/
2:                    /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
3:                    /-----------------------------------------------------------------------------/
4:                    / FatFs module is a generic FAT file system module for small embedded systems.
5:                    / This is a free software that opened for education, research and commercial
6:                    / developments under license policy of following terms.
7:                    /
8:                    /  Copyright (C) 2011, ChaN, all right reserved.
9:                    /
10:                   / * The FatFs module is a free software and there is NO WARRANTY.
11:                   / * No restriction on use. You can use, modify and redistribute it for
12:                   /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
13:                   / * Redistributions of source code must retain the above copyright notice.
14:                   /
15:                   /-----------------------------------------------------------------------------/
16:                   / Feb 26,'06 R0.00  Prototype.
17:                   /
18:                   / Apr 29,'06 R0.01  First stable version.
19:                   /
20:                   / Jun 01,'06 R0.02  Added FAT12 support.
21:                   /                   Removed unbuffered mode.
22:                   /                   Fixed a problem on small (<32M) partition.
23:                   / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
24:                   /
25:                   / Sep 22,'06 R0.03  Added f_rename().
26:                   /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
27:                   / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
28:                   /                   Fixed f_mkdir() creates incorrect directory on FAT32.
29:                   /
30:                   / Feb 04,'07 R0.04  Supported multiple drive system.
31:                   /                   Changed some interfaces for multiple drive system.
32:                   /                   Changed f_mountdrv() to f_mount().
33:                   /                   Added f_mkfs().
34:                   / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
35:                   /                   Added a capability of extending file size to f_lseek().
36:                   /                   Added minimization level 3.
37:                   /                   Fixed an endian sensitive code in f_mkfs().
38:                   / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
39:                   /                   Added FSInfo support.
40:                   /                   Fixed DBCS name can result FR_INVALID_NAME.
41:                   /                   Fixed short seek (<= csize) collapses the file object.
42:                   /
43:                   / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
44:                   /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
45:                   /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
46:                   / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
47:                   /                   Fixed off by one error at FAT sub-type determination.
48:                   /                   Fixed btr in f_read() can be mistruncated.
49:                   /                   Fixed cached sector is not flushed when create and close without write.
50:                   /
51:                   / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
52:                   /                   Improved performance of f_lseek() on moving to the same or following cluster.
53:                   /
54:                   / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
55:                   /                   Added long file name feature.
56:                   /                   Added multiple code page feature.
57:                   /                   Added re-entrancy for multitask operation.
58:                   /                   Added auto cluster size selection to f_mkfs().
59:                   /                   Added rewind option to f_readdir().
60:                   /                   Changed result code of critical errors.
61:                   /                   Renamed string functions to avoid name collision.
62:                   / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
63:                   /                   Added multiple sector size feature.
64:                   / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
65:                   /                   Fixed wrong cache control in f_lseek().
66:                   /                   Added relative path feature.
67:                   /                   Added f_chdir() and f_chdrive().
68:                   /                   Added proper case conversion to extended char.
69:                   / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
70:                   /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
71:                   /                   Fixed name matching error on the 13 char boundary.
72:                   /                   Added a configuration option, _LFN_UNICODE.
73:                   /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
74:                   /
75:                   / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
76:                   /                   Added file lock feature. (_FS_SHARE)
77:                   /                   Added fast seek feature. (_USE_FASTSEEK)
78:                   /                   Changed some types on the API, XCHAR->TCHAR.
79:                   /                   Changed fname member in the FILINFO structure on Unicode cfg.
80:                   /                   String functions support UTF-8 encoding files on Unicode cfg.
81:                   / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
82:                   /                   Added sector erase feature. (_USE_ERASE)
83:                   /                   Moved file lock semaphore table from fs object to the bss.
84:                   /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
85:                   /                   Fixed f_mkfs() creates wrong FAT32 volume.
86:                   / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
87:                   /                   f_lseek() reports required table size on creating CLMP.
88:                   /                   Extended format syntax of f_printf function.
89:                   /                   Ignores duplicated directory separators in given path names.
90:                   /
91:                   / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
92:                   /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
93:                   /---------------------------------------------------------------------------
94:                   / 2011-12 Alfred Broda <alfredbroda@gmail.com> adapted for Pinguno Project
95:                   / BYTE and WORD were changed to PF_BYTE and PF_WORD because of a conflict.
96:                   ---------------------------------------------------------------------------*/
97:                  
98:                  #include "ff.h"			/* FatFs configurations and declarations */
99:                  #include "diskio.h"		/* Declarations of low level disk I/O functions */
100:                 
101:                 /*--------------------------------------------------------------------------
102:                 
103:                  Module Private Definitions
104:                 
105:                  ---------------------------------------------------------------------------*/
106:                 
107:                 #if _FATFS != 6502	/* Revision ID */
108:                 #error Wrong include file (ff.h).
109:                 #endif
110:                 
111:                 /* Definitions on sector size */
112:                 #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
113:                 #error Wrong sector size.
114:                 #endif
115:                 #if _MAX_SS != 512
116:                 #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
117:                 #else
118:                 #define	SS(fs)	512U			/* Fixed sector size */
119:                 #endif
120:                 
121:                 /* Reentrancy related */
122:                 #if _FS_REENTRANT
123:                 #if _USE_LFN == 1
124:                 #error Static LFN work area must not be used in re-entrant configuration.
125:                 #endif
126:                 #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
127:                 #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
128:                 #else
129:                 #define	ENTER_FF(fs)
130:                 #define LEAVE_FF(fs, res)	return res
131:                 #endif
132:                 
133:                 #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
134:                 
135:                 /* File shareing feature */
136:                 #if _FS_SHARE
137:                 #if _FS_READONLY
138:                 #error _FS_SHARE must be 0 on read-only cfg.
139:                 #endif
140:                 typedef struct {
141:                 	FATFS *fs; /* File ID 1, volume (NULL:blank entry) */
142:                 	DWORD clu; /* File ID 2, directory */
143:                 	PF_WORD idx; /* File ID 3, directory index */
144:                 	PF_WORD ctr; /* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
145:                 }FILESEM;
146:                 #endif
147:                 
148:                 /* Misc definitions */
149:                 #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
150:                 #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
151:                 
152:                 /* DBCS code ranges and SBCS extend char conversion table */
153:                 
154:                 #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
155:                 #define _DF1S	0x81	/* DBC 1st byte range 1 start */
156:                 #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
157:                 #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
158:                 #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
159:                 #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
160:                 #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
161:                 #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
162:                 #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
163:                 
164:                 #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
165:                 #define _DF1S	0x81
166:                 #define _DF1E	0xFE
167:                 #define _DS1S	0x40
168:                 #define _DS1E	0x7E
169:                 #define _DS2S	0x80
170:                 #define _DS2E	0xFE
171:                 
172:                 #elif _CODE_PAGE == 949	/* Korean */
173:                 #define _DF1S	0x81
174:                 #define _DF1E	0xFE
175:                 #define _DS1S	0x41
176:                 #define _DS1E	0x5A
177:                 #define _DS2S	0x61
178:                 #define _DS2E	0x7A
179:                 #define _DS3S	0x81
180:                 #define _DS3E	0xFE
181:                 
182:                 #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
183:                 #define _DF1S	0x81
184:                 #define _DF1E	0xFE
185:                 #define _DS1S	0x40
186:                 #define _DS1E	0x7E
187:                 #define _DS2S	0xA1
188:                 #define _DS2E	0xFE
189:                 
190:                 #elif _CODE_PAGE == 437	/* U.S. (OEM) */
191:                 #define _DF1S	0
192:                 #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
193:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
194:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
195:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
196:                 
197:                 #elif _CODE_PAGE == 720	/* Arabic (OEM) */
198:                 #define _DF1S	0
199:                 #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
200:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
201:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
202:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
203:                 
204:                 #elif _CODE_PAGE == 737	/* Greek (OEM) */
205:                 #define _DF1S	0
206:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
207:                 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
208:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
209:                 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
210:                 
211:                 #elif _CODE_PAGE == 775	/* Baltic (OEM) */
212:                 #define _DF1S	0
213:                 #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
214:                 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
215:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
216:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
217:                 
218:                 #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
219:                 #define _DF1S	0
220:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
221:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
222:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
223:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
224:                 
225:                 #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
226:                 #define _DF1S	0
227:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
228:                 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
229:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
230:                 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
231:                 
232:                 #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
233:                 #define _DF1S	0
234:                 #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
235:                 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
236:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
237:                 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
238:                 
239:                 #elif _CODE_PAGE == 857	/* Turkish (OEM) */
240:                 #define _DF1S	0
241:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
242:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
243:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
244:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
245:                 
246:                 #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
247:                 #define _DF1S	0
248:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
249:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
250:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
251:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
252:                 
253:                 #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
254:                 #define _DF1S	0
255:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
256:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
257:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
258:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
259:                 
260:                 #elif _CODE_PAGE == 866	/* Russian (OEM) */
261:                 #define _DF1S	0
262:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
263:                 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
264:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
265:                 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
266:                 
267:                 #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
268:                 #define _DF1S	0
269:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
270:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
271:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
272:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
273:                 
274:                 #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
275:                 #define _DF1S	0
276:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
277:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
278:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
279:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
280:                 
281:                 #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
282:                 #define _DF1S	0
283:                 #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
284:                 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
285:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
286:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
287:                 
288:                 #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
289:                 #define _DF1S	0
290:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
291:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
292:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
293:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
294:                 
295:                 #elif _CODE_PAGE == 1253 /* Greek (Windows) */
296:                 #define _DF1S	0
297:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
298:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
299:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
300:                 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
301:                 
302:                 #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
303:                 #define _DF1S	0
304:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
305:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
306:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
307:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
308:                 
309:                 #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
310:                 #define _DF1S	0
311:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
312:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
313:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
314:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
315:                 
316:                 #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
317:                 #define _DF1S	0
318:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
319:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
320:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
321:                 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
322:                 
323:                 #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
324:                 #define _DF1S	0
325:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
326:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
327:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
328:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
329:                 
330:                 #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
331:                 #define _DF1S	0
332:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
333:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
334:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
335:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
336:                 
337:                 #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
338:                 #if _USE_LFN
339:                 #error Cannot use LFN feature without valid code page.
340:                 #endif
341:                 #define _DF1S	0
342:                 
343:                 #else
344:                 #error Unknown code page
345:                 
346:                 #endif
347:                 
348:                 /* Character code support macros */
349:                 #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
350:                 #define IsLower(c)	(((c)>='a')&&((c)<='z'))
351:                 #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
352:                 
353:                 #if _DF1S		/* Code page is DBCS */
354:                 
355:                 #ifdef _DF2S	/* Two 1st byte areas */
356:                 #define IsDBCS1(c)	(((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E) || ((PF_BYTE)(c) >= _DF2S && (PF_BYTE)(c) <= _DF2E))
357:                 #else			/* One 1st byte area */
358:                 #define IsDBCS1(c)	((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E)
359:                 #endif
360:                 
361:                 #ifdef _DS3S	/* Three 2nd byte areas */
362:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E) || ((PF_BYTE)(c) >= _DS3S && (PF_BYTE)(c) <= _DS3E))
363:                 #else			/* Two 2nd byte areas */
364:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E))
365:                 #endif
366:                 
367:                 #else			/* Code page is SBCS */
368:                 
369:                 #define IsDBCS1(c)	0
370:                 #define IsDBCS2(c)	0
371:                 
372:                 #endif /* _DF1S */
373:                 
374:                 /* Name status flags */
375:                 #define NS			11		/* Index of name status byte in fn[] */
376:                 #define NS_LOSS		0x01	/* Out of 8.3 format */
377:                 #define NS_LFN		0x02	/* Force to create LFN entry */
378:                 #define NS_LAST		0x04	/* Last segment */
379:                 #define NS_BODY		0x08	/* Lower case flag (body) */
380:                 #define NS_EXT		0x10	/* Lower case flag (ext) */
381:                 #define NS_DOT		0x20	/* Dot entry */
382:                 
383:                 /* FAT sub-type boundaries */
384:                 /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
385:                 #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
386:                 #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
387:                 
388:                 /* FatFs refers the members in the FAT structures as byte array instead of
389:                  / structure member because the structure is not binary compatible between
390:                  / different platforms */
391:                 
392:                 #define BS_jmpBoot			0	/* Jump instruction (3) */
393:                 #define BS_OEMName			3	/* OEM name (8) */
394:                 #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
395:                 #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
396:                 #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
397:                 #define BPB_NumFATs			16	/* Number of FAT copies (1) */
398:                 #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
399:                 #define BPB_TotSec16		19	/* Volume size [sector] (2) */
400:                 #define BPB_Media			21	/* Media descriptor (1) */
401:                 #define BPB_FATSz16			22	/* FAT size [sector] (2) */
402:                 #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
403:                 #define BPB_NumHeads		26	/* Number of heads (2) */
404:                 #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
405:                 #define BPB_TotSec32		32	/* Volume size [sector] (4) */
406:                 #define BS_DrvNum			36	/* Physical drive number (2) */
407:                 #define BS_BootSig			38	/* Extended boot signature (1) */
408:                 #define BS_VolID			39	/* Volume serial number (4) */
409:                 #define BS_VolLab			43	/* Volume label (8) */
410:                 #define BS_FilSysType		54	/* File system type (1) */
411:                 #define BPB_FATSz32			36	/* FAT size [sector] (4) */
412:                 #define BPB_ExtFlags		40	/* Extended flags (2) */
413:                 #define BPB_FSVer			42	/* File system version (2) */
414:                 #define BPB_RootClus		44	/* Root dir first cluster (4) */
415:                 #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
416:                 #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
417:                 #define BS_DrvNum32			64	/* Physical drive number (2) */
418:                 #define BS_BootSig32		66	/* Extended boot signature (1) */
419:                 #define BS_VolID32			67	/* Volume serial number (4) */
420:                 #define BS_VolLab32			71	/* Volume label (8) */
421:                 #define BS_FilSysType32		82	/* File system type (1) */
422:                 #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
423:                 #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
424:                 #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
425:                 #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
426:                 #define MBR_Table			446	/* MBR: Partition table offset (2) */
427:                 #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
428:                 #define BS_55AA				510	/* Boot sector signature (2) */
429:                 
430:                 #define	DIR_Name			0	/* Short file name (11) */
431:                 #define	DIR_Attr			11	/* Attribute (1) */
432:                 #define	DIR_NTres			12	/* NT flag (1) */
433:                 #define	DIR_CrtTime			14	/* Created time (2) */
434:                 #define	DIR_CrtDate			16	/* Created date (2) */
435:                 #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
436:                 #define	DIR_WrtTime			22	/* Modified time (2) */
437:                 #define	DIR_WrtDate			24	/* Modified date (2) */
438:                 #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
439:                 #define	DIR_FileSize		28	/* File size (4) */
440:                 #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
441:                 #define	LDIR_Attr			11	/* LFN attribute (1) */
442:                 #define	LDIR_Type			12	/* LFN type (1) */
443:                 #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
444:                 #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
445:                 #define	SZ_DIR				32		/* Size of a directory entry */
446:                 #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
447:                 #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
448:                 #define	NDDE				0x05	/* Replacement of a character collides with DDE */
449:                 
450:                 /*------------------------------------------------------------*/
451:                 /* Module private work area                                   */
452:                 /*------------------------------------------------------------*/
453:                 /* Note that uninitialized variables with static duration are
454:                  /  zeroed/nulled at start-up. If not, the compiler or start-up
455:                  /  routine is out of ANSI-C standard.
456:                  */
457:                 
458:                 #if _VOLUMES
459:                 static FATFS *FatFs[_VOLUMES]; /* Pointer to the file system objects (logical drives) */
460:                 #else
461:                 #error Number of volumes must not be 0.
462:                 #endif
463:                 
464:                 static PF_WORD Fsid; /* File system mount ID */
465:                 
466:                 #if _FS_RPATH
467:                 static
468:                 PF_BYTE CurrVol; /* Current drive */
469:                 #endif
470:                 
471:                 #if _FS_SHARE
472:                 static
473:                 FILESEM Files[_FS_SHARE]; /* File lock semaphores */
474:                 #endif
475:                 
476:                 #if _USE_LFN == 0			/* No LFN feature */
477:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
478:                 #define INIT_BUF(dobj)		(dobj).fn = sfn
479:                 #define	FREE_BUF()
480:                 
481:                 #elif _USE_LFN == 1			/* LFN feature with static working buffer */
482:                 static WCHAR LfnBuf[_MAX_LFN+1];
483:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
484:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
485:                 #define	FREE_BUF()
486:                 
487:                 #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
488:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
489:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
490:                 #define	FREE_BUF()
491:                 
492:                 #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
493:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR *lfn
494:                 #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
495:                 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
496:                 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
497:                 #define	FREE_BUF()			ff_memfree(lfn)
498:                 
499:                 #else
500:                 #error Wrong LFN configuration.
501:                 #endif
502:                 
503:                 /*--------------------------------------------------------------------------
504:                 
505:                  Module Private Functions
506:                 
507:                  ---------------------------------------------------------------------------*/
508:                 
509:                 /*-----------------------------------------------------------------------*/
510:                 /* String functions                                                      */
511:                 /*-----------------------------------------------------------------------*/
512:                 
513:                 /* Copy memory to memory */
514:                 static
515:                 void mem_cpy(void* dst, const void* src, UINT cnt) {
9D003764  00862021   ADDU A0, A0, A2
516:                 	PF_BYTE *d = (PF_BYTE*) dst;
517:                 	const PF_BYTE *s = (const PF_BYTE*) src;
518:                 
519:                 #if _WORD_ACCESS == 1
520:                 	while (cnt >= sizeof(int)) {
521:                 		*(int*) d = *(int*) s;
522:                 		d += sizeof(int);
523:                 		s += sizeof(int);
524:                 		cnt -= sizeof(int);
525:                 	}
526:                 #endif
527:                 	while (cnt--)
9D00375C  10C00007   BEQ A2, ZERO, 0x9D00377C
9D003760  00801021   ADDU V0, A0, ZERO
9D003774  1444FFFC   BNE V0, A0, 0x9D003768
9D003778  24A50001   ADDIU A1, A1, 1
9D00377C  03E00008   JR RA
9D003780  00000000   NOP
528:                 		*d++ = *s++;
9D003768  90A30000   LBU V1, 0(A1)
9D00376C  A0430000   SB V1, 0(V0)
9D003770  24420001   ADDIU V0, V0, 1
529:                 }
530:                 
531:                 /* Fill memory */
532:                 static
533:                 void mem_set(void* dst, int val, UINT cnt) {
9D00378C  00862021   ADDU A0, A0, A2
534:                 	PF_BYTE *d = (PF_BYTE*) dst;
535:                 
536:                 	while (cnt--)
9D003784  10C00006   BEQ A2, ZERO, 0x9D0037A0
9D003788  00801021   ADDU V0, A0, ZERO
9D003798  5444FFFE   BNEL V0, A0, 0x9D003794
9D00379C  A0450000   SB A1, 0(V0)
9D0037A0  03E00008   JR RA
9D0037A4  00000000   NOP
537:                 		*d++ = (PF_BYTE) val;
9D003790  A0450000   SB A1, 0(V0)
9D003794  24420001   ADDIU V0, V0, 1
538:                 }
539:                 
540:                 /* Compare memory to memory */
541:                 static
542:                 int mem_cmp(const void* dst, const void* src, UINT cnt) {
543:                 	const PF_BYTE *d = (const PF_BYTE *) dst, *s = (const PF_BYTE *) src;
9D0047FC  01402021   ADDU A0, T2, ZERO
544:                 	int r = 0;
545:                 
546:                 	while (cnt-- && (r = *d++ - *s++) == 0)
9D004808  50680037   BEQL V1, T0, 0x9D0048E8
9D00480C  9143000B   LBU V1, 11(T2)
9D004810  90660000   LBU A2, 0(V1)
9D004814  90850000   LBU A1, 0(A0)
9D004818  24630001   ADDIU V1, V1, 1
9D00481C  10C5FFFA   BEQ A2, A1, 0x9D004808
9D004820  24840001   ADDIU A0, A0, 1
547:                 		;
548:                 	return r;
549:                 }
550:                 
551:                 /* Check if chr is contained in the string */
552:                 static
553:                 int chk_chr(const char* str, int chr) {
554:                 	while (*str && *str != chr)
9D0045C8  24160022   ADDIU S6, ZERO, 34
9D0045CC  3C179D01   LUI S7, -25343
9D0046E0  10560071   BEQ V0, S6, 0x9D0048A8
9D0046E4  00405021   ADDU T2, V0, ZERO
9D0046E8  26E5FFF8   ADDIU A1, S7, -8
9D0046F0  80A70000   LB A3, 0(A1)
9D0046F4  50E00005   BEQL A3, ZERO, 0x9D00470C
9D0046F8  2445FFBF   ADDIU A1, V0, -65
9D0046FC  5547FFFC   BNEL T2, A3, 0x9D0046F0
9D004700  24A50001   ADDIU A1, A1, 1
9D004704  0B40122D   J 0x9D0048B4
9D004708  24020006   ADDIU V0, ZERO, 6
9D0048A8  0B40122D   J 0x9D0048B4
9D0048AC  24020006   ADDIU V0, ZERO, 6
9D0048B0  24020006   ADDIU V0, ZERO, 6
555:                 		str++;
9D0046EC  24A50001   ADDIU A1, A1, 1
556:                 	return *str;
557:                 }
558:                 
559:                 /*-----------------------------------------------------------------------*/
560:                 /* Request/Release grant to access the volume                            */
561:                 /*-----------------------------------------------------------------------*/
562:                 #if _FS_REENTRANT
563:                 
564:                 static
565:                 int lock_fs (
566:                 		FATFS *fs /* File system object */
567:                 )
568:                 {
569:                 	return ff_req_grant(fs->sobj);
570:                 }
571:                 
572:                 static
573:                 void unlock_fs (
574:                 		FATFS *fs, /* File system object */
575:                 		FRESULT res /* Result code to be returned */
576:                 )
577:                 {
578:                 	if (res != FR_NOT_ENABLED &&
579:                 			res != FR_INVALID_DRIVE &&
580:                 			res != FR_INVALID_OBJECT &&
581:                 			res != FR_TIMEOUT) {
582:                 		ff_rel_grant(fs->sobj);
583:                 	}
584:                 }
585:                 #endif
586:                 
587:                 /*-----------------------------------------------------------------------*/
588:                 /* File shareing control functions                                       */
589:                 /*-----------------------------------------------------------------------*/
590:                 #if _FS_SHARE
591:                 
592:                 static
593:                 FRESULT chk_lock ( /* Check if the file can be accessed */
594:                 		DIR* dj, /* Directory object pointing the file to be checked */
595:                 		int acc /* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
596:                 )
597:                 {
598:                 	UINT i, be;
599:                 
600:                 	/* Search file semaphore table */
601:                 	for (i = be = 0; i < _FS_SHARE; i++) {
602:                 		if (Files[i].fs) { /* Existing entry */
603:                 			if (Files[i].fs == dj->fs && /* Check if the file matched with an open file */
604:                 					Files[i].clu == dj->sclust &&
605:                 					Files[i].idx == dj->index) break;
606:                 		} else { /* Blank entry */
607:                 			be++;
608:                 		}
609:                 	}
610:                 	if (i == _FS_SHARE) /* The file is not opened */
611:                 	return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES; /* Is there a blank entry for new file? */
612:                 
613:                 	/* The file has been opened. Reject any open against writing file and all write mode open */
614:                 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
615:                 }
616:                 
617:                 static
618:                 int enq_lock (void) /* Check if an entry is available for a new file */
619:                 {
620:                 	UINT i;
621:                 
622:                 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
623:                 	return (i == _FS_SHARE) ? 0 : 1;
624:                 }
625:                 
626:                 static
627:                 UINT inc_lock ( /* Increment file open counter and returns its index (0:int error) */
628:                 		DIR* dj, /* Directory object pointing the file to register or increment */
629:                 		int acc /* Desired access mode (0:Read, !0:Write) */
630:                 )
631:                 {
632:                 	UINT i;
633:                 
634:                 	for (i = 0; i < _FS_SHARE; i++) { /* Find the file */
635:                 		if (Files[i].fs == dj->fs &&
636:                 				Files[i].clu == dj->sclust &&
637:                 				Files[i].idx == dj->index) break;
638:                 	}
639:                 
640:                 	if (i == _FS_SHARE) { /* Not opened. Register it as new. */
641:                 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
642:                 		if (i == _FS_SHARE) return 0; /* No space to register (int err) */
643:                 		Files[i].fs = dj->fs;
644:                 		Files[i].clu = dj->sclust;
645:                 		Files[i].idx = dj->index;
646:                 		Files[i].ctr = 0;
647:                 	}
648:                 
649:                 	if (acc && Files[i].ctr) return 0; /* Access violation (int err) */
650:                 
651:                 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1; /* Set semaphore value */
652:                 
653:                 	return i + 1;
654:                 }
655:                 
656:                 static
657:                 FRESULT dec_lock ( /* Decrement file open counter */
658:                 		UINT i /* Semaphore index */
659:                 )
660:                 {
661:                 	PF_WORD n;
662:                 	FRESULT res;
663:                 
664:                 	if (--i < _FS_SHARE) {
665:                 		n = Files[i].ctr;
666:                 		if (n == 0x100) n = 0;
667:                 		if (n) n--;
668:                 		Files[i].ctr = n;
669:                 		if (!n) Files[i].fs = 0;
670:                 		res = FR_OK;
671:                 	} else {
672:                 		res = FR_INT_ERR;
673:                 	}
674:                 	return res;
675:                 }
676:                 
677:                 static
678:                 void clear_lock ( /* Clear lock entries of the volume */
679:                 		FATFS *fs
680:                 )
681:                 {
682:                 	UINT i;
683:                 
684:                 	for (i = 0; i < _FS_SHARE; i++) {
685:                 		if (Files[i].fs == fs) Files[i].fs = 0;
686:                 	}
687:                 }
688:                 #endif
689:                 
690:                 /*-----------------------------------------------------------------------*/
691:                 /* Change window offset                                                  */
692:                 /*-----------------------------------------------------------------------*/
693:                 
694:                 static FRESULT move_window(FATFS *fs, /* File system object */
695:                 DWORD sector /* Sector number to make appearance in the fs->win[] */
696:                 ) /* Move to zero only writes back dirty window */
697:                 {
9D003944  27BDFFD8   ADDIU SP, SP, -40
9D003948  AFBF0024   SW RA, 36(SP)
9D00394C  AFB40020   SW S4, 32(SP)
9D003950  AFB3001C   SW S3, 28(SP)
9D003954  AFB20018   SW S2, 24(SP)
9D003958  AFB10014   SW S1, 20(SP)
9D00395C  AFB00010   SW S0, 16(SP)
9D003960  00808021   ADDU S0, A0, ZERO
9D003964  00A09021   ADDU S2, A1, ZERO
698:                 	DWORD wsect;
699:                 
700:                 	wsect = fs->winsect;
9D003968  8C91002C   LW S1, 44(A0)
701:                 	if (wsect != sector) { /* Changed current window */
9D00396C  1225002D   BEQ S1, A1, 0x9D003A24
9D003970  00001821   ADDU V1, ZERO, ZERO
702:                 #if !_FS_READONLY
703:                 		if (fs->wflag) { /* Write back dirty window if needed */
9D003974  90820004   LBU V0, 4(A0)
9D003978  1040001F   BEQ V0, ZERO, 0x9D0039F8
9D00397C  02203021   ADDU A2, S1, ZERO
704:                 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
9D003980  24940030   ADDIU S4, A0, 48
9D003984  90840001   LBU A0, 1(A0)
9D003988  02802821   ADDU A1, S4, ZERO
9D00398C  0F4023B4   JAL disk_write
9D003990  24070001   ADDIU A3, ZERO, 1
9D003994  14400023   BNE V0, ZERO, 0x9D003A24
9D003998  24030001   ADDIU V1, ZERO, 1
705:                 				return FR_DISK_ERR;
706:                 			fs->wflag = 0;
9D00399C  A2000004   SB ZERO, 4(S0)
707:                 			if (wsect < (fs->fatbase + fs->fsize)) { /* In FAT area */
9D0039A0  8E03001C   LW V1, 28(S0)
9D0039A4  8E020020   LW V0, 32(S0)
9D0039A8  00621021   ADDU V0, V1, V0
9D0039AC  0222102B   SLTU V0, S1, V0
9D0039B0  10400011   BEQ V0, ZERO, 0x9D0039F8
9D0039B4  00000000   NOP
708:                 				PF_BYTE nf;
709:                 				for (nf = fs->n_fats; nf > 1; nf--) { /* Reflect the change to all FAT copies */
9D0039B8  92130003   LBU S3, 3(S0)
9D0039BC  2E620002   SLTIU V0, S3, 2
9D0039C0  1440000D   BNE V0, ZERO, 0x9D0039F8
9D0039C4  00000000   NOP
9D0039E4  2673FFFF   ADDIU S3, S3, -1
9D0039E8  327300FF   ANDI S3, S3, 255
9D0039EC  24020001   ADDIU V0, ZERO, 1
9D0039F0  5662FFF6   BNEL S3, V0, 0x9D0039CC
9D0039F4  8E02001C   LW V0, 28(S0)
710:                 					wsect += fs->fsize;
9D0039C8  8E02001C   LW V0, 28(S0)
9D0039CC  02228821   ADDU S1, S1, V0
711:                 					disk_write(fs->drv, fs->win, wsect, 1);
9D0039D0  92040001   LBU A0, 1(S0)
9D0039D4  02802821   ADDU A1, S4, ZERO
9D0039D8  02203021   ADDU A2, S1, ZERO
9D0039DC  0F4023B4   JAL disk_write
9D0039E0  24070001   ADDIU A3, ZERO, 1
712:                 				}
713:                 			}
714:                 		}
715:                 #endif
716:                 		if (sector) {
9D0039F8  1240000A   BEQ S2, ZERO, 0x9D003A24
9D0039FC  00001821   ADDU V1, ZERO, ZERO
717:                 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
9D003A00  92040001   LBU A0, 1(S0)
9D003A04  26050030   ADDIU A1, S0, 48
9D003A08  02403021   ADDU A2, S2, ZERO
9D003A0C  0F40237E   JAL disk_read
9D003A10  24070001   ADDIU A3, ZERO, 1
9D003A14  14400003   BNE V0, ZERO, 0x9D003A24
9D003A18  24030001   ADDIU V1, ZERO, 1
718:                 				return FR_DISK_ERR;
719:                 			fs->winsect = sector;
9D003A1C  AE12002C   SW S2, 44(S0)
720:                 		}
721:                 	}
722:                 
723:                 	return FR_OK;
9D003A20  00001821   ADDU V1, ZERO, ZERO
724:                 }
9D003A24  00601021   ADDU V0, V1, ZERO
9D003A28  8FBF0024   LW RA, 36(SP)
9D003A2C  8FB40020   LW S4, 32(SP)
9D003A30  8FB3001C   LW S3, 28(SP)
9D003A34  8FB20018   LW S2, 24(SP)
9D003A38  8FB10014   LW S1, 20(SP)
9D003A3C  8FB00010   LW S0, 16(SP)
9D003A40  03E00008   JR RA
9D003A44  27BD0028   ADDIU SP, SP, 40
725:                 
726:                 /*-----------------------------------------------------------------------*/
727:                 /* Clean-up cached data                                                  */
728:                 /*-----------------------------------------------------------------------*/
729:                 #if !_FS_READONLY
730:                 static FRESULT sync( /* FR_OK: successful, FR_DISK_ERR: failed */
731:                 FATFS *fs /* File system object */
732:                 ) {
9D003B20  27BDFFE0   ADDIU SP, SP, -32
9D003B24  AFBF001C   SW RA, 28(SP)
9D003B28  AFB20018   SW S2, 24(SP)
9D003B2C  AFB10014   SW S1, 20(SP)
9D003B30  AFB00010   SW S0, 16(SP)
9D003B34  00808821   ADDU S1, A0, ZERO
733:                 	FRESULT res;
734:                 
735:                 	res = move_window(fs, 0);
9D003B38  0F400E51   JAL 0x9D003944
9D003B3C  00002821   ADDU A1, ZERO, ZERO
736:                 	if (res == FR_OK) {
9D003B40  1440003A   BNE V0, ZERO, 0x9D003C2C
9D003B44  00408021   ADDU S0, V0, ZERO
737:                 		/* Update FSInfo sector if needed */
738:                 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
9D003B48  92230000   LBU V1, 0(S1)
9D003B4C  24020003   ADDIU V0, ZERO, 3
9D003B50  54620031   BNEL V1, V0, 0x9D003C18
9D003B54  92240001   LBU A0, 1(S1)
9D003B58  92220005   LBU V0, 5(S1)
9D003B5C  5040002E   BEQL V0, ZERO, 0x9D003C18
9D003B60  92240001   LBU A0, 1(S1)
739:                 			fs->winsect = 0;
9D003B64  AE20002C   SW ZERO, 44(S1)
740:                 			/* Create FSInfo structure */
741:                 			mem_set(fs->win, 0, 512);
9D003B68  26320030   ADDIU S2, S1, 48
9D003B6C  02402021   ADDU A0, S2, ZERO
9D003B70  00002821   ADDU A1, ZERO, ZERO
9D003B74  0F400DE1   JAL 0x9D003784
9D003B78  24060200   ADDIU A2, ZERO, 512
742:                 			ST_WORD(fs->win+BS_55AA, 0xAA55);
9D003B7C  24020055   ADDIU V0, ZERO, 85
9D003B80  A222022E   SB V0, 558(S1)
9D003B84  2402FFAA   ADDIU V0, ZERO, -86
9D003B88  A222022F   SB V0, 559(S1)
743:                 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
9D003B8C  24020052   ADDIU V0, ZERO, 82
9D003B90  A2220030   SB V0, 48(S1)
9D003B94  A2220031   SB V0, 49(S1)
9D003B98  24020061   ADDIU V0, ZERO, 97
9D003B9C  A2220032   SB V0, 50(S1)
9D003BA0  24030041   ADDIU V1, ZERO, 65
9D003BA4  A2230033   SB V1, 51(S1)
744:                 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
9D003BA8  24040072   ADDIU A0, ZERO, 114
9D003BAC  A2240214   SB A0, 532(S1)
9D003BB0  A2240215   SB A0, 533(S1)
9D003BB4  A2230216   SB V1, 534(S1)
9D003BB8  A2220217   SB V0, 535(S1)
745:                 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
9D003BBC  8E220010   LW V0, 16(S1)
9D003BC0  A2220218   SB V0, 536(S1)
9D003BC4  7C433A00   EXT V1, V0, 8, 8
9D003BC8  A2230219   SB V1, 537(S1)
9D003BCC  00021C02   SRL V1, V0, 16
9D003BD0  A223021A   SB V1, 538(S1)
9D003BD4  00021602   SRL V0, V0, 24
9D003BD8  A222021B   SB V0, 539(S1)
746:                 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
9D003BDC  8E22000C   LW V0, 12(S1)
9D003BE0  A222021C   SB V0, 540(S1)
9D003BE4  7C433A00   EXT V1, V0, 8, 8
9D003BE8  A223021D   SB V1, 541(S1)
9D003BEC  00021C02   SRL V1, V0, 16
9D003BF0  A223021E   SB V1, 542(S1)
9D003BF4  00021602   SRL V0, V0, 24
9D003BF8  A222021F   SB V0, 543(S1)
747:                 			/* Write it into the FSInfo sector */
748:                 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
9D003BFC  92240001   LBU A0, 1(S1)
9D003C00  02402821   ADDU A1, S2, ZERO
9D003C04  8E260014   LW A2, 20(S1)
9D003C08  0F4023B4   JAL disk_write
9D003C0C  24070001   ADDIU A3, ZERO, 1
749:                 			fs->fsi_flag = 0;
9D003C10  A2200005   SB ZERO, 5(S1)
750:                 		}
751:                 		/* Make sure that no pending write process in the physical drive */
752:                 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
9D003C14  92240001   LBU A0, 1(S1)
9D003C18  00002821   ADDU A1, ZERO, ZERO
9D003C1C  0F4023F9   JAL disk_ioctl
9D003C20  00003021   ADDU A2, ZERO, ZERO
753:                 			res = FR_DISK_ERR;
9D003C24  24030001   ADDIU V1, ZERO, 1
9D003C28  0062800B   MOVN S0, V1, V0
754:                 	}
755:                 
756:                 	return res;
757:                 }
9D003C2C  02001021   ADDU V0, S0, ZERO
9D003C30  8FBF001C   LW RA, 28(SP)
9D003C34  8FB20018   LW S2, 24(SP)
9D003C38  8FB10014   LW S1, 20(SP)
9D003C3C  8FB00010   LW S0, 16(SP)
9D003C40  03E00008   JR RA
9D003C44  27BD0020   ADDIU SP, SP, 32
758:                 #endif
759:                 
760:                 /*-----------------------------------------------------------------------*/
761:                 /* Get sector# from cluster#                                             */
762:                 /*-----------------------------------------------------------------------*/
763:                 
764:                 DWORD clust2sect( /* !=0: Sector number, 0: Failed - invalid cluster# */
765:                 FATFS *fs, /* File system object */
766:                 DWORD clst /* Cluster# to be converted */
767:                 ) {
768:                 	clst -= 2;
9D003C94  24A5FFFE   ADDIU A1, A1, -2
769:                 	if (clst >= (fs->n_fatent - 2))
9D003C98  8C830018   LW V1, 24(A0)
9D003C9C  2463FFFE   ADDIU V1, V1, -2
9D003CA0  00A3182B   SLTU V1, A1, V1
9D003CA4  10600005   BEQ V1, ZERO, 0x9D003CBC
9D003CA8  00001021   ADDU V0, ZERO, ZERO
770:                 		return 0; /* Invalid cluster# */
771:                 	return clst * fs->csize + fs->database;
9D003CAC  90820002   LBU V0, 2(A0)
9D003CB0  8C830028   LW V1, 40(A0)
9D003CB4  70A22002   MUL A0, A1, V0
9D003CB8  00831021   ADDU V0, A0, V1
772:                 }
9D003CBC  03E00008   JR RA
9D003CC0  00000000   NOP
773:                 
774:                 /*-----------------------------------------------------------------------*/
775:                 /* FAT access - Read value of a FAT entry                                */
776:                 /*-----------------------------------------------------------------------*/
777:                 
778:                 DWORD get_fat( /* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
779:                 FATFS *fs, /* File system object */
780:                 DWORD clst /* Cluster# to get the link information */
781:                 ) {
9D003CC4  27BDFFD8   ADDIU SP, SP, -40
9D003CC8  AFBF0024   SW RA, 36(SP)
9D003CCC  AFB30020   SW S3, 32(SP)
9D003CD0  AFB2001C   SW S2, 28(SP)
9D003CD4  AFB10018   SW S1, 24(SP)
9D003CD8  AFB00014   SW S0, 20(SP)
9D003CDC  00808021   ADDU S0, A0, ZERO
9D003CE0  00A08821   ADDU S1, A1, ZERO
782:                 	UINT wc, bc;
783:                 	PF_BYTE *p;
784:                 
785:                 	if (clst < 2 || clst >= fs->n_fatent) /* Chack range */
9D003CE4  2CA20002   SLTIU V0, A1, 2
9D003CE8  1440004F   BNE V0, ZERO, 0x9D003E28
9D003CEC  24030001   ADDIU V1, ZERO, 1
9D003CF0  8C820018   LW V0, 24(A0)
9D003CF4  00A2102B   SLTU V0, A1, V0
9D003CF8  1040004C   BEQ V0, ZERO, 0x9D003E2C
9D003CFC  00601021   ADDU V0, V1, ZERO
786:                 		return 1;
787:                 
788:                 	switch (fs->fs_type) {
9D003D00  90820000   LBU V0, 0(A0)
9D003D04  24030002   ADDIU V1, ZERO, 2
9D003D08  50430025   BEQL V0, V1, 0x9D003DA0
9D003D0C  00052A02   SRL A1, A1, 8
9D003D10  24030003   ADDIU V1, ZERO, 3
9D003D14  5043002F   BEQL V0, V1, 0x9D003DD4
9D003D18  000529C2   SRL A1, A1, 7
9D003D1C  24030001   ADDIU V1, ZERO, 1
9D003D20  54430041   BNEL V0, V1, 0x9D003E28
9D003D24  2403FFFF   ADDIU V1, ZERO, -1
789:                 	case FS_FAT12:
790:                 		bc = (UINT) clst;
791:                 		bc += bc / 2;
9D003D28  00059042   SRL S2, A1, 1
9D003D2C  02459021   ADDU S2, S2, A1
792:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D003D30  00122A42   SRL A1, S2, 9
9D003D34  8C820020   LW V0, 32(A0)
9D003D38  0F400E51   JAL 0x9D003944
9D003D3C  00A22821   ADDU A1, A1, V0
9D003D40  14400039   BNE V0, ZERO, 0x9D003E28
9D003D44  2403FFFF   ADDIU V1, ZERO, -1
793:                 			break;
794:                 		wc = fs->win[bc % SS(fs)];
9D003D48  324201FF   ANDI V0, S2, 511
9D003D4C  02021021   ADDU V0, S0, V0
9D003D50  90530030   LBU S3, 48(V0)
795:                 		bc++;
9D003D54  26520001   ADDIU S2, S2, 1
796:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D003D58  00122A42   SRL A1, S2, 9
9D003D5C  8E020020   LW V0, 32(S0)
9D003D60  02002021   ADDU A0, S0, ZERO
9D003D64  0F400E51   JAL 0x9D003944
9D003D68  00A22821   ADDU A1, A1, V0
9D003D6C  1440002E   BNE V0, ZERO, 0x9D003E28
9D003D70  2403FFFF   ADDIU V1, ZERO, -1
797:                 			break;
798:                 		wc |= fs->win[bc % SS(fs)] << 8;
9D003D74  325201FF   ANDI S2, S2, 511
9D003D78  02128021   ADDU S0, S0, S2
9D003D7C  92030030   LBU V1, 48(S0)
9D003D80  00031A00   SLL V1, V1, 8
9D003D84  00739825   OR S3, V1, S3
799:                 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
9D003D88  32310001   ANDI S1, S1, 1
9D003D8C  00131102   SRL V0, S3, 4
9D003D90  32730FFF   ANDI S3, S3, 4095
9D003D94  00401821   ADDU V1, V0, ZERO
9D003D98  0B400F8A   J 0x9D003E28
9D003D9C  0271180A   MOVZ V1, S3, S1
800:                 
801:                 	case FS_FAT16:
802:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))))
9D003DA0  8C820020   LW V0, 32(A0)
9D003DA4  0F400E51   JAL 0x9D003944
9D003DA8  00A22821   ADDU A1, A1, V0
9D003DAC  1440001E   BNE V0, ZERO, 0x9D003E28
9D003DB0  2403FFFF   ADDIU V1, ZERO, -1
803:                 			break;
804:                 		p = &fs->win[clst * 2 % SS(fs)];
9D003DB4  00118840   SLL S1, S1, 1
9D003DB8  323101FF   ANDI S1, S1, 511
805:                 		return LD_WORD(p);
9D003DBC  02111021   ADDU V0, S0, S1
9D003DC0  90430031   LBU V1, 49(V0)
9D003DC4  00031A00   SLL V1, V1, 8
9D003DC8  90420030   LBU V0, 48(V0)
9D003DCC  0B400F8A   J 0x9D003E28
9D003DD0  00621825   OR V1, V1, V0
806:                 
807:                 	case FS_FAT32:
808:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))))
9D003DD4  8C820020   LW V0, 32(A0)
9D003DD8  0F400E51   JAL 0x9D003944
9D003DDC  00A22821   ADDU A1, A1, V0
9D003DE0  14400011   BNE V0, ZERO, 0x9D003E28
9D003DE4  2403FFFF   ADDIU V1, ZERO, -1
809:                 			break;
810:                 		p = &fs->win[clst * 4 % SS(fs)];
9D003DE8  00118880   SLL S1, S1, 2
9D003DEC  323101FF   ANDI S1, S1, 511
9D003DF0  26220030   ADDIU V0, S1, 48
9D003DF4  02021021   ADDU V0, S0, V0
811:                 		return LD_DWORD(p) & 0x0FFFFFFF;
9D003DF8  90440002   LBU A0, 2(V0)
9D003DFC  00042400   SLL A0, A0, 16
9D003E00  90430003   LBU V1, 3(V0)
9D003E04  00031E00   SLL V1, V1, 24
9D003E08  00831825   OR V1, A0, V1
9D003E0C  90420001   LBU V0, 1(V0)
9D003E10  00021200   SLL V0, V0, 8
9D003E14  00621825   OR V1, V1, V0
9D003E18  02118021   ADDU S0, S0, S1
9D003E1C  92020030   LBU V0, 48(S0)
9D003E20  00621825   OR V1, V1, V0
9D003E24  7C63D800   EXT V1, V1, 0, 28
812:                 	}
813:                 
814:                 	return 0xFFFFFFFF; /* An error occurred at the disk I/O layer */
815:                 }
9D003E28  00601021   ADDU V0, V1, ZERO
9D003E2C  8FBF0024   LW RA, 36(SP)
9D003E30  8FB30020   LW S3, 32(SP)
9D003E34  8FB2001C   LW S2, 28(SP)
9D003E38  8FB10018   LW S1, 24(SP)
9D003E3C  8FB00014   LW S0, 20(SP)
9D003E40  03E00008   JR RA
9D003E44  27BD0028   ADDIU SP, SP, 40
816:                 
817:                 /*-----------------------------------------------------------------------*/
818:                 /* FAT access - Change value of a FAT entry                              */
819:                 /*-----------------------------------------------------------------------*/
820:                 #if !_FS_READONLY
821:                 
822:                 FRESULT put_fat(FATFS *fs, /* File system object */
823:                 DWORD clst, /* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
824:                 DWORD val /* New value to mark the cluster */
825:                 ) {
9D004004  27BDFFD8   ADDIU SP, SP, -40
9D004008  AFBF0024   SW RA, 36(SP)
9D00400C  AFB30020   SW S3, 32(SP)
9D004010  AFB2001C   SW S2, 28(SP)
9D004014  AFB10018   SW S1, 24(SP)
9D004018  AFB00014   SW S0, 20(SP)
9D00401C  00808021   ADDU S0, A0, ZERO
9D004020  00A08821   ADDU S1, A1, ZERO
9D004024  00C09021   ADDU S2, A2, ZERO
826:                 	UINT bc;
827:                 	PF_BYTE *p;
828:                 	FRESULT res;
829:                 
830:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D004028  2CA30002   SLTIU V1, A1, 2
9D00402C  1460005D   BNE V1, ZERO, 0x9D0041A4
9D004030  24020002   ADDIU V0, ZERO, 2
9D004034  8C830018   LW V1, 24(A0)
9D004038  00A3182B   SLTU V1, A1, V1
9D00403C  10600059   BEQ V1, ZERO, 0x9D0041A4
9D004040  24030002   ADDIU V1, ZERO, 2
831:                 		res = FR_INT_ERR;
832:                 
833:                 	} else {
834:                 		switch (fs->fs_type) {
9D004044  90820000   LBU V0, 0(A0)
9D004048  10430030   BEQ V0, V1, 0x9D00410C
9D00404C  24030003   ADDIU V1, ZERO, 3
9D004050  1043003B   BEQ V0, V1, 0x9D004140
9D004054  24030001   ADDIU V1, ZERO, 1
9D004058  14430050   BNE V0, V1, 0x9D00419C
9D00405C  24020002   ADDIU V0, ZERO, 2
835:                 		case FS_FAT12:
836:                 			bc = clst;
837:                 			bc += bc / 2;
9D004060  00059842   SRL S3, A1, 1
9D004064  02659821   ADDU S3, S3, A1
838:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D004068  00132A42   SRL A1, S3, 9
9D00406C  8C820020   LW V0, 32(A0)
9D004070  0F400E51   JAL 0x9D003944
9D004074  00A22821   ADDU A1, A1, V0
839:                 			if (res != FR_OK)
9D004078  14400049   BNE V0, ZERO, 0x9D0041A0
9D00407C  24030001   ADDIU V1, ZERO, 1
840:                 				break;
841:                 			p = &fs->win[bc % SS(fs)];
9D004080  326301FF   ANDI V1, S3, 511
842:                 			*p = (clst & 1) ? ((*p & 0x0F) | ((PF_BYTE) val << 4))
9D004084  32310001   ANDI S1, S1, 1
9D004088  12200008   BEQ S1, ZERO, 0x9D0040AC
9D00408C  324200FF   ANDI V0, S2, 255
9D004090  02031021   ADDU V0, S0, V1
9D004094  90440030   LBU A0, 48(V0)
9D004098  3084000F   ANDI A0, A0, 15
9D00409C  324200FF   ANDI V0, S2, 255
9D0040A0  00021100   SLL V0, V0, 4
9D0040A4  00821025   OR V0, A0, V0
9D0040A8  304200FF   ANDI V0, V0, 255
9D0040AC  02031821   ADDU V1, S0, V1
9D0040B0  A0620030   SB V0, 48(V1)
843:                 					: (PF_BYTE) val;
844:                 			bc++;
9D0040B4  26730001   ADDIU S3, S3, 1
845:                 			fs->wflag = 1;
9D0040B8  24020001   ADDIU V0, ZERO, 1
9D0040BC  A2020004   SB V0, 4(S0)
846:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D0040C0  00132A42   SRL A1, S3, 9
9D0040C4  8E020020   LW V0, 32(S0)
9D0040C8  02002021   ADDU A0, S0, ZERO
9D0040CC  0F400E51   JAL 0x9D003944
9D0040D0  00A22821   ADDU A1, A1, V0
847:                 			if (res != FR_OK)
9D0040D4  14400032   BNE V0, ZERO, 0x9D0041A0
9D0040D8  24030001   ADDIU V1, ZERO, 1
848:                 				break;
849:                 			p = &fs->win[bc % SS(fs)];
850:                 			*p = (clst & 1) ? (PF_BYTE) (val >> 4) : ((*p & 0xF0)
9D0040DC  12200003   BEQ S1, ZERO, 0x9D0040EC
9D0040E0  327301FF   ANDI S3, S3, 511
9D0040E4  0B401040   J 0x9D004100
9D0040E8  7E523900   EXT S2, S2, 4, 8
9D0040EC  02131821   ADDU V1, S0, S3
9D0040F0  90630030   LBU V1, 48(V1)
9D0040F4  306300F0   ANDI V1, V1, 240
9D0040F8  7E521A00   EXT S2, S2, 8, 4
9D0040FC  00729025   OR S2, V1, S2
9D004100  02139821   ADDU S3, S0, S3
851:                 					| ((PF_BYTE) (val >> 8) & 0x0F));
852:                 			break;
9D004104  0B401067   J 0x9D00419C
9D004108  A2720030   SB S2, 48(S3)
853:                 
854:                 		case FS_FAT16:
855:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
9D00410C  00052A02   SRL A1, A1, 8
9D004110  8C820020   LW V0, 32(A0)
9D004114  0F400E51   JAL 0x9D003944
9D004118  00A22821   ADDU A1, A1, V0
856:                 			if (res != FR_OK)
9D00411C  14400020   BNE V0, ZERO, 0x9D0041A0
9D004120  24030001   ADDIU V1, ZERO, 1
857:                 				break;
858:                 			p = &fs->win[clst * 2 % SS(fs)];
9D004124  00118840   SLL S1, S1, 1
9D004128  323101FF   ANDI S1, S1, 511
859:                 			ST_WORD(p, (PF_WORD)val)
9D00412C  02111821   ADDU V1, S0, S1
9D004130  A0720030   SB S2, 48(V1)
9D004134  7E523A00   EXT S2, S2, 8, 8
860:                 			;
861:                 			break;
9D004138  0B401067   J 0x9D00419C
9D00413C  A0720031   SB S2, 49(V1)
862:                 
863:                 		case FS_FAT32:
864:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
9D004140  000529C2   SRL A1, A1, 7
9D004144  8C820020   LW V0, 32(A0)
9D004148  0F400E51   JAL 0x9D003944
9D00414C  00A22821   ADDU A1, A1, V0
865:                 			if (res != FR_OK)
9D004150  14400013   BNE V0, ZERO, 0x9D0041A0
9D004154  24030001   ADDIU V1, ZERO, 1
866:                 				break;
867:                 			p = &fs->win[clst * 4 % SS(fs)];
9D004158  00118880   SLL S1, S1, 2
9D00415C  323101FF   ANDI S1, S1, 511
9D004160  26230030   ADDIU V1, S1, 48
9D004164  02031821   ADDU V1, S0, V1
868:                 			val |= LD_DWORD(p) & 0xF0000000;
9D004168  90640003   LBU A0, 3(V1)
9D00416C  00042600   SLL A0, A0, 24
9D004170  02118821   ADDU S1, S0, S1
9D004174  3C05F000   LUI A1, -4096
9D004178  00852024   AND A0, A0, A1
9D00417C  00929025   OR S2, A0, S2
869:                 			ST_DWORD(p, val)
9D004180  A2320030   SB S2, 48(S1)
9D004184  7E443A00   EXT A0, S2, 8, 8
9D004188  A0640001   SB A0, 1(V1)
9D00418C  00122402   SRL A0, S2, 16
9D004190  A0640002   SB A0, 2(V1)
9D004194  00129602   SRL S2, S2, 24
9D004198  A0720003   SB S2, 3(V1)
870:                 			;
871:                 			break;
872:                 
873:                 		default:
874:                 			res = FR_INT_ERR;
875:                 		}
876:                 		fs->wflag = 1;
9D00419C  24030001   ADDIU V1, ZERO, 1
9D0041A0  A2030004   SB V1, 4(S0)
877:                 	}
878:                 
879:                 	return res;
880:                 }
9D0041A4  8FBF0024   LW RA, 36(SP)
9D0041A8  8FB30020   LW S3, 32(SP)
9D0041AC  8FB2001C   LW S2, 28(SP)
9D0041B0  8FB10018   LW S1, 24(SP)
9D0041B4  8FB00014   LW S0, 20(SP)
9D0041B8  03E00008   JR RA
9D0041BC  27BD0028   ADDIU SP, SP, 40
881:                 #endif /* !_FS_READONLY */
882:                 
883:                 /*-----------------------------------------------------------------------*/
884:                 /* FAT handling - Remove a cluster chain                                 */
885:                 /*-----------------------------------------------------------------------*/
886:                 #if !_FS_READONLY
887:                 static FRESULT remove_chain(FATFS *fs, /* File system object */
888:                 DWORD clst /* Cluster# to remove a chain from */
889:                 ) {
9D004A80  27BDFFD0   ADDIU SP, SP, -48
9D004A84  AFBF002C   SW RA, 44(SP)
9D004A88  AFB50028   SW S5, 40(SP)
9D004A8C  AFB40024   SW S4, 36(SP)
9D004A90  AFB30020   SW S3, 32(SP)
9D004A94  AFB2001C   SW S2, 28(SP)
9D004A98  AFB10018   SW S1, 24(SP)
9D004A9C  AFB00014   SW S0, 20(SP)
9D004AA0  00808821   ADDU S1, A0, ZERO
9D004AA4  00A09021   ADDU S2, A1, ZERO
890:                 	FRESULT res;
891:                 	DWORD nxt;
892:                 #if _USE_ERASE
893:                 	DWORD scl = clst, ecl = clst, resion[2];
894:                 #endif
895:                 
896:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D004AA8  2CA30002   SLTIU V1, A1, 2
9D004AAC  14600025   BNE V1, ZERO, 0x9D004B44
9D004AB0  24020002   ADDIU V0, ZERO, 2
9D004AB4  8C830018   LW V1, 24(A0)
9D004AB8  00A3182B   SLTU V1, A1, V1
9D004ABC  14600003   BNE V1, ZERO, 0x9D004ACC
9D004AC0  24140001   ADDIU S4, ZERO, 1
897:                 		res = FR_INT_ERR;
898:                 
899:                 	} else {
900:                 		res = FR_OK;
901:                 		while (clst < fs->n_fatent) { /* Not a last link? */
9D004B20  8E230018   LW V1, 24(S1)
9D004B24  0203182B   SLTU V1, S0, V1
9D004B28  1460FFEA   BNE V1, ZERO, 0x9D004AD4
9D004B2C  02009021   ADDU S2, S0, ZERO
902:                 			nxt = get_fat(fs, clst); /* Get cluster status */
9D004AD4  02202021   ADDU A0, S1, ZERO
9D004AD8  0F400F31   JAL get_fat
9D004ADC  02402821   ADDU A1, S2, ZERO
903:                 			if (nxt == 0)
9D004AE0  10400015   BEQ V0, ZERO, 0x9D004B38
9D004AE4  00408021   ADDU S0, V0, ZERO
9D004B38  0B4012D1   J 0x9D004B44
9D004B3C  00001021   ADDU V0, ZERO, ZERO
904:                 				break; /* Empty cluster? */
905:                 			if (nxt == 1) {
9D004AE8  50540016   BEQL V0, S4, 0x9D004B44
9D004AEC  24020002   ADDIU V0, ZERO, 2
906:                 				res = FR_INT_ERR;
907:                 				break;
908:                 			} /* Internal error? */
909:                 			if (nxt == 0xFFFFFFFF) {
9D004ACC  2413FFFF   ADDIU S3, ZERO, -1
9D004AF0  10530013   BEQ V0, S3, 0x9D004B40
9D004AF4  02202021   ADDU A0, S1, ZERO
910:                 				res = FR_DISK_ERR;
9D004B40  24020001   ADDIU V0, ZERO, 1
911:                 				break;
912:                 			} /* Disk error? */
913:                 			res = put_fat(fs, clst, 0); /* Mark the cluster "empty" */
9D004AF8  02402821   ADDU A1, S2, ZERO
9D004AFC  0F401001   JAL put_fat
9D004B00  00003021   ADDU A2, ZERO, ZERO
914:                 			if (res != FR_OK)
9D004B04  14400010   BNE V0, ZERO, 0x9D004B48
9D004B08  8FBF002C   LW RA, 44(SP)
915:                 				break;
916:                 			if (fs->free_clust != 0xFFFFFFFF) { /* Update FSInfo */
9D004B0C  8E230010   LW V1, 16(S1)
9D004B10  10730003   BEQ V1, S3, 0x9D004B20
9D004B14  24630001   ADDIU V1, V1, 1
917:                 				fs->free_clust++;
9D004B18  AE230010   SW V1, 16(S1)
918:                 				fs->fsi_flag = 1;
9D004AD0  24150001   ADDIU S5, ZERO, 1
9D004B1C  A2350005   SB S5, 5(S1)
919:                 			}
920:                 #if _USE_ERASE
921:                 			if (ecl + 1 == nxt) { /* Next cluster is contiguous */
922:                 				ecl = nxt;
923:                 			} else { /* End of contiguous clusters */
924:                 				resion[0] = clust2sect(fs, scl); /* Start sector */
925:                 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1; /* End sector */
926:                 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion); /* Erase the block */
927:                 				scl = ecl = nxt;
928:                 			}
929:                 #endif
930:                 			clst = nxt; /* Next cluster */
931:                 		}
932:                 	}
933:                 
934:                 	return res;
935:                 }
9D004AC4  0B4012D2   J 0x9D004B48
9D004AC8  8FBF002C   LW RA, 44(SP)
9D004B30  0B4012D2   J 0x9D004B48
9D004B34  8FBF002C   LW RA, 44(SP)
9D004B44  8FBF002C   LW RA, 44(SP)
9D004B48  8FB50028   LW S5, 40(SP)
9D004B4C  8FB40024   LW S4, 36(SP)
9D004B50  8FB30020   LW S3, 32(SP)
9D004B54  8FB2001C   LW S2, 28(SP)
9D004B58  8FB10018   LW S1, 24(SP)
9D004B5C  8FB00014   LW S0, 20(SP)
9D004B60  03E00008   JR RA
9D004B64  27BD0030   ADDIU SP, SP, 48
936:                 #endif
937:                 
938:                 /*-----------------------------------------------------------------------*/
939:                 /* FAT handling - Stretch or Create a cluster chain                      */
940:                 /*-----------------------------------------------------------------------*/
941:                 #if !_FS_READONLY
942:                 static DWORD create_chain( /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
943:                 FATFS *fs, /* File system object */
944:                 DWORD clst /* Cluster# to stretch. 0 means create a new chain. */
945:                 ) {
9D0041C0  27BDFFD0   ADDIU SP, SP, -48
9D0041C4  AFBF002C   SW RA, 44(SP)
9D0041C8  AFB60028   SW S6, 40(SP)
9D0041CC  AFB50024   SW S5, 36(SP)
9D0041D0  AFB40020   SW S4, 32(SP)
9D0041D4  AFB3001C   SW S3, 28(SP)
9D0041D8  AFB20018   SW S2, 24(SP)
9D0041DC  AFB10014   SW S1, 20(SP)
9D0041E0  AFB00010   SW S0, 16(SP)
9D0041E4  00808821   ADDU S1, A0, ZERO
946:                 	DWORD cs, ncl, scl;
947:                 	FRESULT res;
948:                 
949:                 	if (clst == 0) { /* Create a new chain */
9D0041E8  14A00009   BNE A1, ZERO, 0x9D004210
9D0041EC  00A0B021   ADDU S6, A1, ZERO
950:                 		scl = fs->last_clust; /* Get suggested start point */
9D0041F0  8C92000C   LW S2, 12(A0)
951:                 		if (!scl || scl >= fs->n_fatent)
9D0041F4  52400011   BEQL S2, ZERO, 0x9D00423C
9D0041F8  24120001   ADDIU S2, ZERO, 1
9D0041FC  8C830018   LW V1, 24(A0)
9D004200  0243182B   SLTU V1, S2, V1
952:                 			scl = 1;
9D004204  24020001   ADDIU V0, ZERO, 1
9D004208  0B40108F   J 0x9D00423C
9D00420C  0043900A   MOVZ S2, V0, V1
953:                 	} else { /* Stretch the current chain */
954:                 		cs = get_fat(fs, clst); /* Check the cluster status */
9D004210  0F400F31   JAL get_fat
9D004214  00000000   NOP
955:                 		if (cs < 2)
9D004218  2C430002   SLTIU V1, V0, 2
9D00421C  5460003F   BNEL V1, ZERO, 0x9D00431C
9D004220  24020001   ADDIU V0, ZERO, 1
956:                 			return 1; /* It is an invalid cluster */
957:                 		if (cs < fs->n_fatent)
9D004224  8E230018   LW V1, 24(S1)
9D004228  0043182B   SLTU V1, V0, V1
9D00422C  10600003   BEQ V1, ZERO, 0x9D00423C
9D004230  02C09021   ADDU S2, S6, ZERO
958:                 			return cs; /* It is already followed by next cluster */
959:                 		scl = clst;
960:                 	}
961:                 
962:                 	ncl = scl; /* Start cluster */
9D00423C  02408021   ADDU S0, S2, ZERO
963:                 	for (;;) {
964:                 		ncl++; /* Next cluster */
9D00424C  26100001   ADDIU S0, S0, 1
965:                 		if (ncl >= fs->n_fatent) { /* Wrap around */
9D004250  8E220018   LW V0, 24(S1)
9D004254  0202102B   SLTU V0, S0, V0
9D004258  14400004   BNE V0, ZERO, 0x9D00426C
9D00425C  02202021   ADDU A0, S1, ZERO
966:                 			ncl = 2;
967:                 			if (ncl > scl)
9D004240  2E550002   SLTIU S5, S2, 2
9D004260  16A0002D   BNE S5, ZERO, 0x9D004318
9D004264  24100002   ADDIU S0, ZERO, 2
968:                 				return 0; /* No free cluster */
969:                 		}
970:                 		cs = get_fat(fs, ncl); /* Get the cluster status */
9D004268  02202021   ADDU A0, S1, ZERO
9D00426C  0F400F31   JAL get_fat
9D004270  02002821   ADDU A1, S0, ZERO
971:                 		if (cs == 0)
9D004274  50400009   BEQL V0, ZERO, 0x9D00429C
9D004278  02009021   ADDU S2, S0, ZERO
972:                 			break; /* Found a free cluster */
973:                 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
9D004244  2413FFFF   ADDIU S3, ZERO, -1
9D004248  24140001   ADDIU S4, ZERO, 1
9D00427C  10530028   BEQ V0, S3, 0x9D004320
9D004280  8FBF002C   LW RA, 44(SP)
9D004284  50540027   BEQL V0, S4, 0x9D004324
9D004288  8FB60028   LW S6, 40(SP)
974:                 			return cs;
975:                 		if (ncl == scl)
9D00428C  1612FFF0   BNE S0, S2, 0x9D004250
9D004290  26100001   ADDIU S0, S0, 1
976:                 			return 0; /* No free cluster */
9D004294  0B4010C7   J 0x9D00431C
9D004298  00001021   ADDU V0, ZERO, ZERO
977:                 	}
978:                 
979:                 	res = put_fat(fs, ncl, 0x0FFFFFFF); /* Mark the new cluster "last link" */
9D00429C  02202021   ADDU A0, S1, ZERO
9D0042A0  02002821   ADDU A1, S0, ZERO
9D0042A4  3C060FFF   LUI A2, 4095
9D0042A8  0F401001   JAL put_fat
9D0042AC  34C6FFFF   ORI A2, A2, -1
980:                 	if (res == FR_OK && clst != 0) {
9D0042B0  54400014   BNEL V0, ZERO, 0x9D004304
9D0042B4  38420001   XORI V0, V0, 1
9D0042B8  52C00008   BEQL S6, ZERO, 0x9D0042DC
9D0042BC  AE32000C   SW S2, 12(S1)
981:                 		res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
9D0042C0  02202021   ADDU A0, S1, ZERO
9D0042C4  02C02821   ADDU A1, S6, ZERO
9D0042C8  0F401001   JAL put_fat
9D0042CC  02003021   ADDU A2, S0, ZERO
982:                 	}
983:                 	if (res == FR_OK) {
9D0042D0  5440000C   BNEL V0, ZERO, 0x9D004304
9D0042D4  38420001   XORI V0, V0, 1
984:                 		fs->last_clust = ncl; /* Update FSINFO */
9D0042D8  AE32000C   SW S2, 12(S1)
985:                 		if (fs->free_clust != 0xFFFFFFFF) {
9D0042DC  8E230010   LW V1, 16(S1)
9D0042E0  2404FFFF   ADDIU A0, ZERO, -1
9D0042E4  1064000D   BEQ V1, A0, 0x9D00431C
9D0042E8  02001021   ADDU V0, S0, ZERO
986:                 			fs->free_clust--;
9D0042EC  2463FFFF   ADDIU V1, V1, -1
9D0042F0  AE230010   SW V1, 16(S1)
987:                 			fs->fsi_flag = 1;
9D0042F4  24020001   ADDIU V0, ZERO, 1
9D0042F8  A2220005   SB V0, 5(S1)
9D0042FC  0B4010C7   J 0x9D00431C
9D004300  02001021   ADDU V0, S0, ZERO
988:                 		}
989:                 	} else {
990:                 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
9D004304  2403FFFF   ADDIU V1, ZERO, -1
9D004308  24040001   ADDIU A0, ZERO, 1
9D00430C  0082180B   MOVN V1, A0, V0
9D004310  0B4010C7   J 0x9D00431C
9D004314  00601021   ADDU V0, V1, ZERO
9D004318  00001021   ADDU V0, ZERO, ZERO
991:                 	}
992:                 
993:                 	return ncl; /* Return new cluster number or error code */
994:                 }
9D004234  0B4010C8   J 0x9D004320
9D004238  8FBF002C   LW RA, 44(SP)
9D00431C  8FBF002C   LW RA, 44(SP)
9D004320  8FB60028   LW S6, 40(SP)
9D004324  8FB50024   LW S5, 36(SP)
9D004328  8FB40020   LW S4, 32(SP)
9D00432C  8FB3001C   LW S3, 28(SP)
9D004330  8FB20018   LW S2, 24(SP)
9D004334  8FB10014   LW S1, 20(SP)
9D004338  8FB00010   LW S0, 16(SP)
9D00433C  03E00008   JR RA
9D004340  27BD0030   ADDIU SP, SP, 48
995:                 #endif /* !_FS_READONLY */
996:                 
997:                 /*-----------------------------------------------------------------------*/
998:                 /* FAT handling - Convert offset into cluster with link map table        */
999:                 /*-----------------------------------------------------------------------*/
1000:                
1001:                #if _USE_FASTSEEK
1002:                static DWORD clmt_clust( /* <2:Error, >=2:Cluster number */
1003:                FIL* fp, /* Pointer to the file object */
1004:                DWORD ofs /* File offset to be converted to cluster# */
1005:                ) {
1006:                	DWORD cl, ncl, *tbl;
1007:                
1008:                	tbl = fp->cltbl + 1; /* Top of CLMT */
9D0037A8  8C820024   LW V0, 36(A0)
9D0037AC  24470004   ADDIU A3, V0, 4
1009:                	cl = ofs / SS(fp->fs) / fp->fs->csize; /* Cluster order from top of the file */
9D0037B0  8C860000   LW A2, 0(A0)
9D0037B4  90C30002   LBU V1, 2(A2)
9D0037C4  00052A42   SRL A1, A1, 9
9D0037C8  00A3001B   DIVU A1, V1
9D0037CC  006001F4   TEQ V1, ZERO
9D0037D0  00001812   MFLO V1, 0
9D0037D4  00001012   MFLO V0, 0
1010:                	for (;;) {
1011:                		ncl = *tbl++; /* Number of cluters in the fragment */
9D0037B8  8C460004   LW A2, 4(V0)
9D0037EC  00603021   ADDU A2, V1, ZERO
9D0037FC  8C830004   LW V1, 4(A0)
1012:                		if (!ncl)
9D0037BC  10C00017   BEQ A2, ZERO, 0x9D00381C
9D0037C0  00001021   ADDU V0, ZERO, ZERO
9D003800  5460FFFA   BNEL V1, ZERO, 0x9D0037EC
9D003804  00461023   SUBU V0, V0, A2
1013:                			return 0; /* End of table? (error) */
9D003808  03E00008   JR RA
9D00380C  00001021   ADDU V0, ZERO, ZERO
1014:                		if (cl < ncl)
9D0037D8  0066182B   SLTU V1, V1, A2
9D0037DC  10600007   BEQ V1, ZERO, 0x9D0037FC
9D0037E0  24E40004   ADDIU A0, A3, 4
9D0037F0  0043182B   SLTU V1, V0, V1
9D0037F4  14600006   BNE V1, ZERO, 0x9D003810
9D0037F8  24840008   ADDIU A0, A0, 8
1015:                			break; /* In this fragment? */
1016:                		cl -= ncl;
1017:                		tbl++; /* Next fragment */
1018:                	}
1019:                	return cl + *tbl; /* Return the cluster number */
9D0037E4  0B400E05   J 0x9D003814
9D0037E8  8C830000   LW V1, 0(A0)
9D003810  8C830000   LW V1, 0(A0)
9D003814  03E00008   JR RA
9D003818  00431021   ADDU V0, V0, V1
1020:                }
9D00381C  03E00008   JR RA
9D003820  00000000   NOP
1021:                #endif	/* _USE_FASTSEEK */
1022:                
1023:                /*-----------------------------------------------------------------------*/
1024:                /* Directory handling - Set directory index                              */
1025:                /*-----------------------------------------------------------------------*/
1026:                
1027:                static FRESULT dir_sdi(DIR *dj, /* Pointer to directory object */
9D003EF0  3294FFFF   ANDI S4, S4, -1
9D003EF4  02328823   SUBU S1, S1, S2
9D003EF8  3231FFFF   ANDI S1, S1, -1
9D003EFC  2413FFFF   ADDIU S3, ZERO, -1
1028:                PF_WORD idx /* Directory index number */
1029:                ) {
9D003E48  27BDFFD8   ADDIU SP, SP, -40
9D003E4C  AFBF0024   SW RA, 36(SP)
9D003E50  AFB40020   SW S4, 32(SP)
9D003E54  AFB3001C   SW S3, 28(SP)
9D003E58  AFB20018   SW S2, 24(SP)
9D003E5C  AFB10014   SW S1, 20(SP)
9D003E60  AFB00010   SW S0, 16(SP)
9D003E64  00808021   ADDU S0, A0, ZERO
9D003E68  00A08821   ADDU S1, A1, ZERO
1030:                	DWORD clst;
1031:                	PF_WORD ic;
1032:                
1033:                	dj->index = idx;
9D003E6C  A4850006   SH A1, 6(A0)
1034:                	clst = dj->sclust;
9D003E70  8C850008   LW A1, 8(A0)
1035:                	if (clst == 1 || clst >= dj->fs->n_fatent) /* Check start cluster range */
9D003E74  24030001   ADDIU V1, ZERO, 1
9D003E78  10A30044   BEQ A1, V1, 0x9D003F8C
9D003E7C  24020002   ADDIU V0, ZERO, 2
9D003E80  8C830000   LW V1, 0(A0)
9D003E84  8C640018   LW A0, 24(V1)
9D003E88  00A4202B   SLTU A0, A1, A0
9D003E8C  50800040   BEQL A0, ZERO, 0x9D003F90
9D003E90  8FBF0024   LW RA, 36(SP)
1036:                		return FR_INT_ERR;
1037:                	if (!clst && dj->fs->fs_type == FS_FAT32) /* Replace cluster# 0 with root cluster# if in FAT32 */
9D003E94  54A00012   BNEL A1, ZERO, 0x9D003EE0
9D003E98  90720002   LBU S2, 2(V1)
9D003E9C  90640000   LBU A0, 0(V1)
9D003EA0  24020003   ADDIU V0, ZERO, 3
9D003EA4  54820005   BNEL A0, V0, 0x9D003EBC
9D003EA8  AE00000C   SW ZERO, 12(S0)
1038:                		clst = dj->fs->dirbase;
9D003EAC  8C650024   LW A1, 36(V1)
1039:                
1040:                	if (clst == 0) { /* Static table (root-dir in FAT12/16) */
9D003EB0  54A0000B   BNEL A1, ZERO, 0x9D003EE0
9D003EB4  90720002   LBU S2, 2(V1)
1041:                		dj->clust = clst;
9D003EB8  AE00000C   SW ZERO, 12(S0)
1042:                		if (idx >= dj->fs->n_rootdir) /* Index is out of range */
9D003EBC  94640008   LHU A0, 8(V1)
9D003EC0  0224202B   SLTU A0, S1, A0
9D003EC4  10800031   BEQ A0, ZERO, 0x9D003F8C
9D003EC8  24020002   ADDIU V0, ZERO, 2
1043:                			return FR_INT_ERR;
1044:                		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D003ECC  7E247900   EXT A0, S1, 4, 16
9D003ED0  8C620024   LW V0, 36(V1)
9D003ED4  00821021   ADDU V0, A0, V0
9D003ED8  0B400FD8   J 0x9D003F60
9D003EDC  AE020010   SW V0, 16(S0)
1045:                	} else { /* Dynamic table (sub-dirs or root-dir in FAT32) */
1046:                		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize; /* Entries per cluster */
9D003EE0  00129100   SLL S2, S2, 4
1047:                		while (idx >= ic) { /* Follow cluster chain */
9D003EE4  0232102B   SLTU V0, S1, S2
9D003EE8  14400017   BNE V0, ZERO, 0x9D003F48
9D003EEC  0012A023   SUBU S4, ZERO, S2
9D003F34  00521821   ADDU V1, V0, S2
9D003F38  3063FFFF   ANDI V1, V1, -1
9D003F3C  0072182B   SLTU V1, V1, S2
9D003F40  5060FFEF   BEQL V1, ZERO, 0x9D003F00
9D003F44  00408821   ADDU S1, V0, ZERO
1048:                			clst = get_fat(dj->fs, clst); /* Get next cluster */
9D003F00  0F400F31   JAL get_fat
9D003F04  8E040000   LW A0, 0(S0)
1049:                			if (clst == 0xFFFFFFFF)
9D003F08  1053001D   BEQ V0, S3, 0x9D003F80
9D003F0C  00402821   ADDU A1, V0, ZERO
1050:                				return FR_DISK_ERR; /* Disk error */
9D003F80  0B400FE3   J 0x9D003F8C
9D003F84  24020001   ADDIU V0, ZERO, 1
1051:                			if (clst < 2 || clst >= dj->fs->n_fatent) /* Reached to end of table or int error */
9D003F10  2C420002   SLTIU V0, V0, 2
9D003F14  1440001D   BNE V0, ZERO, 0x9D003F8C
9D003F18  24020002   ADDIU V0, ZERO, 2
9D003F1C  8E020000   LW V0, 0(S0)
9D003F20  8C420018   LW V0, 24(V0)
9D003F24  00A2102B   SLTU V0, A1, V0
9D003F28  10400017   BEQ V0, ZERO, 0x9D003F88
9D003F2C  02341021   ADDU V0, S1, S4
9D003F30  3042FFFF   ANDI V0, V0, -1
1052:                				return FR_INT_ERR;
9D003F88  24020002   ADDIU V0, ZERO, 2
1053:                			idx -= ic;
1054:                		}
1055:                		dj->clust = clst;
9D003F48  AE05000C   SW A1, 12(S0)
1056:                		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D003F4C  0F400F25   JAL clust2sect
9D003F50  8E040000   LW A0, 0(S0)
9D003F54  7E237900   EXT V1, S1, 4, 16
9D003F58  00621021   ADDU V0, V1, V0
9D003F5C  AE020010   SW V0, 16(S0)
1057:                	}
1058:                
1059:                	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR; /* Ptr to the entry in the sector */
9D003F60  8E020000   LW V0, 0(S0)
9D003F64  24420030   ADDIU V0, V0, 48
9D003F68  3231000F   ANDI S1, S1, 15
9D003F6C  00118940   SLL S1, S1, 5
9D003F70  00518821   ADDU S1, V0, S1
9D003F74  AE110014   SW S1, 20(S0)
1060:                
1061:                	return FR_OK; /* Seek succeeded */
9D003F78  0B400FE3   J 0x9D003F8C
9D003F7C  00001021   ADDU V0, ZERO, ZERO
1062:                }
9D003F8C  8FBF0024   LW RA, 36(SP)
9D003F90  8FB40020   LW S4, 32(SP)
9D003F94  8FB3001C   LW S3, 28(SP)
9D003F98  8FB20018   LW S2, 24(SP)
9D003F9C  8FB10014   LW S1, 20(SP)
9D003FA0  8FB00010   LW S0, 16(SP)
9D003FA4  03E00008   JR RA
9D003FA8  27BD0028   ADDIU SP, SP, 40
1063:                
1064:                /*-----------------------------------------------------------------------*/
1065:                /* Directory handling - Move directory index next                        */
1066:                /*-----------------------------------------------------------------------*/
1067:                
1068:                static FRESULT dir_next( /* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
1069:                DIR *dj, /* Pointer to directory object */
1070:                int stretch /* 0: Do not stretch table, 1: Stretch table if needed */
1071:                ) {
9D004344  27BDFFD8   ADDIU SP, SP, -40
9D004348  AFBF0024   SW RA, 36(SP)
9D00434C  AFB40020   SW S4, 32(SP)
9D004350  AFB3001C   SW S3, 28(SP)
9D004354  AFB20018   SW S2, 24(SP)
9D004358  AFB10014   SW S1, 20(SP)
9D00435C  AFB00010   SW S0, 16(SP)
9D004360  00808821   ADDU S1, A0, ZERO
9D004364  00A08021   ADDU S0, A1, ZERO
1072:                	DWORD clst;
1073:                	PF_WORD i;
1074:                
1075:                	stretch = stretch; /* To suppress warning on read-only cfg. */
1076:                	i = dj->index + 1;
9D004368  94920006   LHU S2, 6(A0)
9D00436C  26520001   ADDIU S2, S2, 1
9D004370  3252FFFF   ANDI S2, S2, -1
1077:                	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
9D004374  1240006C   BEQ S2, ZERO, 0x9D004528
9D004378  24030004   ADDIU V1, ZERO, 4
9D00437C  8C820010   LW V0, 16(A0)
9D004380  5040006A   BEQL V0, ZERO, 0x9D00452C
9D004384  00601021   ADDU V0, V1, ZERO
1078:                		return FR_NO_FILE;
1079:                
1080:                	if (!(i % (SS(dj->fs) / SZ_DIR))) { /* Sector changed? */
9D004388  3243000F   ANDI V1, S2, 15
9D00438C  5460005D   BNEL V1, ZERO, 0x9D004504
9D004390  A6320006   SH S2, 6(S1)
1081:                		dj->sect++; /* Next sector */
9D004394  24420001   ADDIU V0, V0, 1
9D004398  AC820010   SW V0, 16(A0)
1082:                
1083:                		if (dj->clust == 0) { /* Static table */
9D00439C  8C85000C   LW A1, 12(A0)
9D0043A0  54A00008   BNEL A1, ZERO, 0x9D0043C4
9D0043A4  8C840000   LW A0, 0(A0)
1084:                			if (i >= dj->fs->n_rootdir) /* Report EOT when end of table */
9D0043A8  8C820000   LW V0, 0(A0)
9D0043AC  94420008   LHU V0, 8(V0)
9D0043B0  0242102B   SLTU V0, S2, V0
9D0043B4  14400052   BNE V0, ZERO, 0x9D004500
9D0043B8  24030004   ADDIU V1, ZERO, 4
1085:                				return FR_NO_FILE;
1086:                		} else { /* Dynamic table */
1087:                			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) { /* Cluster changed? */
9D0043C4  90820002   LBU V0, 2(A0)
9D0043C8  2442FFFF   ADDIU V0, V0, -1
9D0043CC  00121902   SRL V1, S2, 4
9D0043D0  00431024   AND V0, V0, V1
9D0043D4  5440004B   BNEL V0, ZERO, 0x9D004504
9D0043D8  A6320006   SH S2, 6(S1)
1088:                				clst = get_fat(dj->fs, dj->clust); /* Get next cluster */
9D0043DC  0F400F31   JAL get_fat
9D0043E0  00000000   NOP
9D0043E4  00409821   ADDU S3, V0, ZERO
1089:                				if (clst <= 1)
9D0043E8  2C420002   SLTIU V0, V0, 2
9D0043EC  1440004E   BNE V0, ZERO, 0x9D004528
9D0043F0  24030002   ADDIU V1, ZERO, 2
1090:                					return FR_INT_ERR;
1091:                				if (clst == 0xFFFFFFFF)
9D0043F4  2402FFFF   ADDIU V0, ZERO, -1
9D0043F8  1262004B   BEQ S3, V0, 0x9D004528
9D0043FC  24030001   ADDIU V1, ZERO, 1
1092:                					return FR_DISK_ERR;
1093:                				if (clst >= dj->fs->n_fatent) { /* When it reached end of dynamic table */
9D004400  8E240000   LW A0, 0(S1)
9D004404  8C820018   LW V0, 24(A0)
9D004408  0262102B   SLTU V0, S3, V0
9D00440C  54400038   BNEL V0, ZERO, 0x9D0044F0
9D004410  AE33000C   SW S3, 12(S1)
1094:                #if !_FS_READONLY
1095:                					PF_BYTE c;
1096:                					if (!stretch)
9D004414  12000044   BEQ S0, ZERO, 0x9D004528
9D004418  24030004   ADDIU V1, ZERO, 4
1097:                						return FR_NO_FILE; /* When do not stretch, report EOT */
1098:                					clst = create_chain(dj->fs, dj->clust); /* Stretch cluster chain */
9D00441C  0F401070   JAL 0x9D0041C0
9D004420  8E25000C   LW A1, 12(S1)
9D004424  00409821   ADDU S3, V0, ZERO
1099:                					if (clst == 0)
9D004428  1040003F   BEQ V0, ZERO, 0x9D004528
9D00442C  24030007   ADDIU V1, ZERO, 7
1100:                						return FR_DENIED; /* No free cluster */
1101:                					if (clst == 1)
9D004430  24020001   ADDIU V0, ZERO, 1
9D004434  1262003C   BEQ S3, V0, 0x9D004528
9D004438  24030002   ADDIU V1, ZERO, 2
1102:                						return FR_INT_ERR;
1103:                					if (clst == 0xFFFFFFFF)
9D00443C  2402FFFF   ADDIU V0, ZERO, -1
9D004440  12620039   BEQ S3, V0, 0x9D004528
9D004444  24030001   ADDIU V1, ZERO, 1
1104:                						return FR_DISK_ERR;
1105:                					/* Clean-up stretched table */
1106:                					if (move_window(dj->fs, 0))
9D004448  8E240000   LW A0, 0(S1)
9D00444C  0F400E51   JAL 0x9D003944
9D004450  00002821   ADDU A1, ZERO, ZERO
9D004454  14400034   BNE V0, ZERO, 0x9D004528
9D004458  24030001   ADDIU V1, ZERO, 1
1107:                						return FR_DISK_ERR; /* Flush active window */
1108:                					mem_set(dj->fs->win, 0, SS(dj->fs)); /* Clear window buffer */
9D00445C  8E240000   LW A0, 0(S1)
9D004460  24840030   ADDIU A0, A0, 48
9D004464  00002821   ADDU A1, ZERO, ZERO
9D004468  0F400DE1   JAL 0x9D003784
9D00446C  24060200   ADDIU A2, ZERO, 512
1109:                					dj->fs->winsect = clust2sect(dj->fs, clst); /* Cluster start sector */
9D004470  8E300000   LW S0, 0(S1)
9D004474  02002021   ADDU A0, S0, ZERO
9D004478  0F400F25   JAL clust2sect
9D00447C  02602821   ADDU A1, S3, ZERO
9D004480  AE02002C   SW V0, 44(S0)
1110:                					for (c = 0; c < dj->fs->csize; c++) { /* Fill the new cluster with 0 */
9D004484  8E220000   LW V0, 0(S1)
9D004488  90430002   LBU V1, 2(V0)
9D00448C  10600014   BEQ V1, ZERO, 0x9D0044E0
9D004490  00008021   ADDU S0, ZERO, ZERO
9D0044C0  321000FF   ANDI S0, S0, 255
9D0044C4  8E220000   LW V0, 0(S1)
9D0044C8  90430002   LBU V1, 2(V0)
9D0044CC  0203182B   SLTU V1, S0, V1
9D0044D0  5460FFF2   BNEL V1, ZERO, 0x9D00449C
9D0044D4  A0540004   SB S4, 4(V0)
1111:                						dj->fs->wflag = 1;
9D004494  24140001   ADDIU S4, ZERO, 1
9D004498  A0540004   SB S4, 4(V0)
1112:                						if (move_window(dj->fs, 0))
9D00449C  8E240000   LW A0, 0(S1)
9D0044A0  0F400E51   JAL 0x9D003944
9D0044A4  00002821   ADDU A1, ZERO, ZERO
9D0044A8  1440001E   BNE V0, ZERO, 0x9D004524
9D0044AC  26100001   ADDIU S0, S0, 1
1113:                							return FR_DISK_ERR;
9D004524  24030001   ADDIU V1, ZERO, 1
1114:                						dj->fs->winsect++;
9D0044B0  8E220000   LW V0, 0(S1)
9D0044B4  8C43002C   LW V1, 44(V0)
9D0044B8  24630001   ADDIU V1, V1, 1
9D0044BC  AC43002C   SW V1, 44(V0)
1115:                					}
1116:                					dj->fs->winsect -= c; /* Rewind window address */
9D0044D8  0B401139   J 0x9D0044E4
9D0044DC  8C43002C   LW V1, 44(V0)
9D0044E0  8C43002C   LW V1, 44(V0)
9D0044E4  00708023   SUBU S0, V1, S0
9D0044E8  AC50002C   SW S0, 44(V0)
1117:                #else
1118:                					return FR_NO_FILE; /* Report EOT */
1119:                #endif
1120:                				}
1121:                				dj->clust = clst; /* Initialize data for new cluster */
9D0044EC  AE33000C   SW S3, 12(S1)
1122:                				dj->sect = clust2sect(dj->fs, clst);
9D0044F0  8E240000   LW A0, 0(S1)
9D0044F4  0F400F25   JAL clust2sect
9D0044F8  02602821   ADDU A1, S3, ZERO
9D0044FC  AE220010   SW V0, 16(S1)
1123:                			}
1124:                		}
1125:                	}
1126:                
1127:                	dj->index = i;
9D004500  A6320006   SH S2, 6(S1)
1128:                	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
9D004504  8E220000   LW V0, 0(S1)
9D004508  24420030   ADDIU V0, V0, 48
9D00450C  3252000F   ANDI S2, S2, 15
9D004510  00129140   SLL S2, S2, 5
9D004514  00529021   ADDU S2, V0, S2
9D004518  AE320014   SW S2, 20(S1)
1129:                
1130:                	return FR_OK;
9D00451C  0B40114A   J 0x9D004528
9D004520  00001821   ADDU V1, ZERO, ZERO
1131:                }
9D0043BC  0B40114B   J 0x9D00452C
9D0043C0  00601021   ADDU V0, V1, ZERO
9D004528  00601021   ADDU V0, V1, ZERO
9D00452C  8FBF0024   LW RA, 36(SP)
9D004530  8FB40020   LW S4, 32(SP)
9D004534  8FB3001C   LW S3, 28(SP)
9D004538  8FB20018   LW S2, 24(SP)
9D00453C  8FB10014   LW S1, 20(SP)
9D004540  8FB00010   LW S0, 16(SP)
9D004544  03E00008   JR RA
9D004548  27BD0028   ADDIU SP, SP, 40
1132:                
1133:                /*-----------------------------------------------------------------------*/
1134:                /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
1135:                /*-----------------------------------------------------------------------*/
1136:                #if _USE_LFN
1137:                static
1138:                const PF_BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30}; /* Offset of LFN chars in the directory entry */
1139:                
1140:                static
1141:                int cmp_lfn ( /* 1:Matched, 0:Not matched */
1142:                		WCHAR *lfnbuf, /* Pointer to the LFN to be compared */
1143:                		PF_BYTE *dir /* Pointer to the directory entry containing a part of LFN */
1144:                )
1145:                {
1146:                	UINT i, s;
1147:                	WCHAR wc, uc;
1148:                
1149:                	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13; /* Get offset in the LFN buffer */
1150:                	s = 0; wc = 1;
1151:                	do {
1152:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1153:                		if (wc) { /* Last char has not been processed */
1154:                			wc = ff_wtoupper(uc); /* Convert it to upper case */
1155:                			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++])) /* Compare it */
1156:                			return 0; /* Not matched */
1157:                		} else {
1158:                			if (uc != 0xFFFF) return 0; /* Check filler */
1159:                		}
1160:                	}while (++s < 13); /* Repeat until all chars in the entry are checked */
1161:                
1162:                	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i]) /* Last segment matched but different length */
1163:                	return 0;
1164:                
1165:                	return 1; /* The part of LFN matched */
1166:                }
1167:                
1168:                static
1169:                int pick_lfn ( /* 1:Succeeded, 0:Buffer overflow */
1170:                		WCHAR *lfnbuf, /* Pointer to the Unicode-LFN buffer */
1171:                		PF_BYTE *dir /* Pointer to the directory entry */
1172:                )
1173:                {
1174:                	UINT i, s;
1175:                	WCHAR wc, uc;
1176:                
1177:                	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13; /* Offset in the LFN buffer */
1178:                
1179:                	s = 0; wc = 1;
1180:                	do {
1181:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1182:                		if (wc) { /* Last char has not been processed */
1183:                			if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1184:                			lfnbuf[i++] = wc = uc; /* Store it */
1185:                		} else {
1186:                			if (uc != 0xFFFF) return 0; /* Check filler */
1187:                		}
1188:                	}while (++s < 13); /* Read all character in the entry */
1189:                
1190:                	if (dir[LDIR_Ord] & LLE) { /* Put terminator if it is the last LFN part */
1191:                		if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1192:                		lfnbuf[i] = 0;
1193:                	}
1194:                
1195:                	return 1;
1196:                }
1197:                
1198:                #if !_FS_READONLY
1199:                static
1200:                void fit_lfn (
1201:                		const WCHAR *lfnbuf, /* Pointer to the LFN buffer */
1202:                		PF_BYTE *dir, /* Pointer to the directory entry */
1203:                		PF_BYTE ord, /* LFN order (1-20) */
1204:                		PF_BYTE sum /* SFN sum */
1205:                )
1206:                {
1207:                	UINT i, s;
1208:                	WCHAR wc;
1209:                
1210:                	dir[LDIR_Chksum] = sum; /* Set check sum */
1211:                	dir[LDIR_Attr] = AM_LFN; /* Set attribute. LFN entry */
1212:                	dir[LDIR_Type] = 0;
1213:                	ST_WORD(dir+LDIR_FstClusLO, 0);
1214:                
1215:                	i = (ord - 1) * 13; /* Get offset in the LFN buffer */
1216:                	s = wc = 0;
1217:                	do {
1218:                		if (wc != 0xFFFF) wc = lfnbuf[i++]; /* Get an effective char */
1219:                		ST_WORD(dir+LfnOfs[s], wc); /* Put it */
1220:                		if (!wc) wc = 0xFFFF; /* Padding chars following last char */
1221:                	}while (++s < 13);
1222:                	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE; /* Bottom LFN part is the start of LFN sequence */
1223:                	dir[LDIR_Ord] = ord; /* Set the LFN order */
1224:                }
1225:                
1226:                #endif
1227:                #endif
1228:                
1229:                /*-----------------------------------------------------------------------*/
1230:                /* Create numbered name                                                  */
1231:                /*-----------------------------------------------------------------------*/
1232:                #if _USE_LFN
1233:                void gen_numname (
1234:                		PF_BYTE *dst, /* Pointer to generated SFN */
1235:                		const PF_BYTE *src, /* Pointer to source SFN to be modified */
1236:                		const WCHAR *lfn, /* Pointer to LFN */
1237:                		PF_WORD seq /* Sequence number */
1238:                )
1239:                {
1240:                	PF_BYTE ns[8], c;
1241:                	UINT i, j;
1242:                
1243:                	mem_cpy(dst, src, 11);
1244:                
1245:                	if (seq > 5) { /* On many collisions, generate a hash number instead of sequential number */
1246:                		do seq = (seq >> 1) + (seq << 15) + (PF_WORD)*lfn++; while (*lfn);
1247:                	}
1248:                
1249:                	/* itoa (hexdecimal) */
1250:                	i = 7;
1251:                	do {
1252:                		c = (seq % 16) + '0';
1253:                		if (c > '9') c += 7;
1254:                		ns[i--] = c;
1255:                		seq /= 16;
1256:                	}while (seq);
1257:                	ns[i] = '~';
1258:                
1259:                	/* Append the number */
1260:                	for (j = 0; j < i && dst[j] != ' '; j++) {
1261:                		if (IsDBCS1(dst[j])) {
1262:                			if (j == i - 1) break;
1263:                			j++;
1264:                		}
1265:                	}
1266:                	do {
1267:                		dst[j++] = (i < 8) ? ns[i++] : ' ';
1268:                	}while (j < 8);
1269:                }
1270:                #endif
1271:                
1272:                /*-----------------------------------------------------------------------*/
1273:                /* Calculate sum of an SFN                                               */
1274:                /*-----------------------------------------------------------------------*/
1275:                #if _USE_LFN
1276:                static
1277:                PF_BYTE sum_sfn (
1278:                		const PF_BYTE *dir /* Ptr to directory entry */
1279:                )
1280:                {
1281:                	PF_BYTE sum = 0;
1282:                	UINT n = 11;
1283:                
1284:                	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
1285:                	return sum;
1286:                }
1287:                #endif
1288:                
1289:                /*-----------------------------------------------------------------------*/
1290:                /* Directory handling - Find an object in the directory                  */
1291:                /*-----------------------------------------------------------------------*/
1292:                
1293:                static FRESULT dir_find(DIR *dj /* Pointer to the directory object linked to the file name */
1294:                ) {
1295:                	FRESULT res;
1296:                	PF_BYTE c, *dir;
1297:                #if _USE_LFN
1298:                	PF_BYTE a, ord, sum;
1299:                #endif
1300:                
1301:                	res = dir_sdi(dj, 0); /* Rewind directory object */
9D0047B0  02402021   ADDU A0, S2, ZERO
9D0047B4  0F400F92   JAL 0x9D003E48
9D0047B8  00002821   ADDU A1, ZERO, ZERO
1302:                	if (res != FR_OK)
9D0047BC  5440001F   BNEL V0, ZERO, 0x9D00483C
9D0047C0  8E430018   LW V1, 24(S2)
1303:                		return res;
1304:                
1305:                #if _USE_LFN
1306:                	ord = sum = 0xFF;
1307:                #endif
1308:                	do {
1309:                		res = move_window(dj->fs, dj->sect);
9D0047C4  8E440000   LW A0, 0(S2)
9D0047C8  0F400E51   JAL 0x9D003944
9D0047CC  8E450010   LW A1, 16(S2)
1310:                		if (res != FR_OK)
9D0047D0  5440001A   BNEL V0, ZERO, 0x9D00483C
9D0047D4  8E430018   LW V1, 24(S2)
1311:                			break;
1312:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D0047D8  8E470014   LW A3, 20(S2)
1313:                		c = dir[DIR_Name];
1314:                		if (c == 0) {
9D0047DC  90E30000   LBU V1, 0(A3)
9D0047E0  50600046   BEQL V1, ZERO, 0x9D0048FC
9D0047E4  8E420018   LW V0, 24(S2)
1315:                			res = FR_NO_FILE;
1316:                			break;
1317:                		} /* Reached to end of table */
1318:                #if _USE_LFN	/* LFN configuration */
1319:                		a = dir[DIR_Attr] & AM_MASK;
1320:                		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1321:                			ord = 0xFF;
1322:                		} else {
1323:                			if (a == AM_LFN) { /* An LFN entry is found */
1324:                				if (dj->lfn) {
1325:                					if (c & LLE) { /* Is it start of LFN sequence? */
1326:                						sum = dir[LDIR_Chksum];
1327:                						c &= ~LLE; ord = c; /* LFN start order */
1328:                						dj->lfn_idx = dj->index;
1329:                					}
1330:                					/* Check validity of the LFN entry and compare it with given name */
1331:                					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1332:                				}
1333:                			} else { /* An SFN entry is found */
1334:                				if (!ord && sum == sum_sfn(dir)) break; /* LFN matched? */
1335:                				ord = 0xFF; dj->lfn_idx = 0xFFFF; /* Reset LFN sequence */
1336:                				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break; /* SFN matched? */
1337:                			}
1338:                		}
1339:                #else		/* Non LFN configuration */
1340:                		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
9D0047E8  90E9000B   LBU T1, 11(A3)
9D0047EC  31230008   ANDI V1, T1, 8
9D0047F0  1460000C   BNE V1, ZERO, 0x9D004824
9D0047F4  00E01821   ADDU V1, A3, ZERO
9D0047F8  8E4A0018   LW T2, 24(S2)
1341:                			break;
1342:                #endif
1343:                		res = dir_next(dj, 0); /* Next entry */
9D004824  02402021   ADDU A0, S2, ZERO
9D004828  0F4010D1   JAL 0x9D004344
9D00482C  00002821   ADDU A1, ZERO, ZERO
1344:                	} while (res == FR_OK);
9D004830  5040FFE5   BEQL V0, ZERO, 0x9D0047C8
9D004834  8E440000   LW A0, 0(S2)
1345:                
1346:                	return res;
1347:                }
1348:                
1349:                /*-----------------------------------------------------------------------*/
1350:                /* Read an object from the directory                                     */
1351:                /*-----------------------------------------------------------------------*/
1352:                #if _FS_MINIMIZE <= 1
1353:                static FRESULT dir_read(DIR *dj /* Pointer to the directory object that pointing the entry to be read */
1354:                ) {
9D0049D8  27BDFFE0   ADDIU SP, SP, -32
9D0049DC  AFBF001C   SW RA, 28(SP)
9D0049E0  AFB20018   SW S2, 24(SP)
9D0049E4  AFB10014   SW S1, 20(SP)
9D0049E8  AFB00010   SW S0, 16(SP)
9D0049EC  00808021   ADDU S0, A0, ZERO
1355:                	FRESULT res;
1356:                	PF_BYTE c, *dir;
1357:                #if _USE_LFN
1358:                	PF_BYTE a, ord = 0xFF, sum = 0xFF;
1359:                #endif
1360:                
1361:                	res = FR_NO_FILE;
9D0049F0  24020004   ADDIU V0, ZERO, 4
1362:                	while (dj->sect) {
9D0049F8  0B401294   J 0x9D004A50
9D0049FC  2412002E   ADDIU S2, ZERO, 46
9D004A50  8E050010   LW A1, 16(S0)
9D004A54  14A0FFEA   BNE A1, ZERO, 0x9D004A00
9D004A58  00000000   NOP
1363:                		res = move_window(dj->fs, dj->sect);
9D004A00  0F400E51   JAL 0x9D003944
9D004A04  8E040000   LW A0, 0(S0)
1364:                		if (res != FR_OK)
9D004A08  54400017   BNEL V0, ZERO, 0x9D004A68
9D004A0C  AE000010   SW ZERO, 16(S0)
1365:                			break;
1366:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D004A10  8E040014   LW A0, 20(S0)
1367:                		c = dir[DIR_Name];
9D004A14  90830000   LBU V1, 0(A0)
1368:                		if (c == 0) {
9D004A18  50600012   BEQL V1, ZERO, 0x9D004A64
9D004A1C  24020004   ADDIU V0, ZERO, 4
1369:                			res = FR_NO_FILE;
1370:                			break;
1371:                		} /* Reached to end of table */
1372:                #if _USE_LFN	/* LFN configuration */
1373:                		a = dir[DIR_Attr] & AM_MASK;
1374:                		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1375:                			ord = 0xFF;
1376:                		} else {
1377:                			if (a == AM_LFN) { /* An LFN entry is found */
1378:                				if (c & LLE) { /* Is it start of LFN sequence? */
1379:                					sum = dir[LDIR_Chksum];
1380:                					c &= ~LLE; ord = c;
1381:                					dj->lfn_idx = dj->index;
1382:                				}
1383:                				/* Check LFN validity and capture it */
1384:                				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1385:                			} else { /* An SFN entry is found */
1386:                				if (ord || sum != sum_sfn(dir)) /* Is there a valid LFN? */
1387:                				dj->lfn_idx = 0xFFFF; /* It has no LFN. */
1388:                				break;
1389:                			}
1390:                		}
1391:                #else		/* Non LFN configuration */
1392:                		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL)) /* Is it a valid entry? */
9D0049F4  241100E5   ADDIU S1, ZERO, 229
9D004A20  50710007   BEQL V1, S1, 0x9D004A40
9D004A24  02002021   ADDU A0, S0, ZERO
9D004A28  50720005   BEQL V1, S2, 0x9D004A40
9D004A2C  02002021   ADDU A0, S0, ZERO
9D004A30  9083000B   LBU V1, 11(A0)
9D004A34  30630008   ANDI V1, V1, 8
9D004A38  1060000B   BEQ V1, ZERO, 0x9D004A68
9D004A3C  02002021   ADDU A0, S0, ZERO
1393:                			break;
1394:                #endif
1395:                		res = dir_next(dj, 0); /* Next entry */
9D004A40  0F4010D1   JAL 0x9D004344
9D004A44  00002821   ADDU A1, ZERO, ZERO
1396:                		if (res != FR_OK)
9D004A48  54400007   BNEL V0, ZERO, 0x9D004A68
9D004A4C  AE000010   SW ZERO, 16(S0)
1397:                			break;
1398:                	}
1399:                
1400:                	if (res != FR_OK)
9D004A5C  10400003   BEQ V0, ZERO, 0x9D004A6C
9D004A60  8FBF001C   LW RA, 28(SP)
1401:                		dj->sect = 0;
9D004A64  AE000010   SW ZERO, 16(S0)
1402:                
1403:                	return res;
1404:                }
9D004A68  8FBF001C   LW RA, 28(SP)
9D004A6C  8FB20018   LW S2, 24(SP)
9D004A70  8FB10014   LW S1, 20(SP)
9D004A74  8FB00010   LW S0, 16(SP)
9D004A78  03E00008   JR RA
9D004A7C  27BD0020   ADDIU SP, SP, 32
1405:                #endif
1406:                
1407:                /*-----------------------------------------------------------------------*/
1408:                /* Register an object to the directory                                   */
1409:                /*-----------------------------------------------------------------------*/
1410:                #if !_FS_READONLY
1411:                static FRESULT dir_register( /* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
1412:                DIR *dj /* Target directory with object name to be created */
1413:                ) {
9D004904  27BDFFE0   ADDIU SP, SP, -32
9D004908  AFBF001C   SW RA, 28(SP)
9D00490C  AFB20018   SW S2, 24(SP)
9D004910  AFB10014   SW S1, 20(SP)
9D004914  AFB00010   SW S0, 16(SP)
9D004918  00808821   ADDU S1, A0, ZERO
1414:                	FRESULT res;
1415:                	PF_BYTE c, *dir;
1416:                #if _USE_LFN	/* LFN configuration */
1417:                	PF_WORD n, ne, is;
1418:                	PF_BYTE sn[12], *fn, sum;
1419:                	WCHAR *lfn;
1420:                
1421:                	fn = dj->fn; lfn = dj->lfn;
1422:                	mem_cpy(sn, fn, 12);
1423:                
1424:                	if (_FS_RPATH && (sn[NS] & NS_DOT)) /* Cannot create dot entry */
1425:                	return FR_INVALID_NAME;
1426:                
1427:                	if (sn[NS] & NS_LOSS) { /* When LFN is out of 8.3 format, generate a numbered name */
1428:                		fn[NS] = 0; dj->lfn = 0; /* Find only SFN */
1429:                		for (n = 1; n < 100; n++) {
1430:                			gen_numname(fn, sn, lfn, n); /* Generate a numbered name */
1431:                			res = dir_find(dj); /* Check if the name collides with existing SFN */
1432:                			if (res != FR_OK) break;
1433:                		}
1434:                		if (n == 100) return FR_DENIED; /* Abort if too many collisions */
1435:                		if (res != FR_NO_FILE) return res; /* Abort if the result is other than 'not collided' */
1436:                		fn[NS] = sn[NS]; dj->lfn = lfn;
1437:                	}
1438:                
1439:                	if (sn[NS] & NS_LFN) { /* When LFN is to be created, reserve an SFN + LFN entries. */
1440:                		for (ne = 0; lfn[ne]; ne++);
1441:                		ne = (ne + 25) / 13;
1442:                	} else { /* Otherwise reserve only an SFN entry. */
1443:                		ne = 1;
1444:                	}
1445:                
1446:                	/* Reserve contiguous entries */
1447:                	res = dir_sdi(dj, 0);
1448:                	if (res != FR_OK) return res;
1449:                	n = is = 0;
1450:                	do {
1451:                		res = move_window(dj->fs, dj->sect);
1452:                		if (res != FR_OK) break;
1453:                		c = *dj->dir; /* Check the entry status */
1454:                		if (c == DDE || c == 0) { /* Is it a blank entry? */
1455:                			if (n == 0) is = dj->index; /* First index of the contiguous entry */
1456:                			if (++n == ne) break; /* A contiguous entry that required count is found */
1457:                		} else {
1458:                			n = 0; /* Not a blank entry. Restart to search */
1459:                		}
1460:                		res = dir_next(dj, 1); /* Next entry with table stretch */
1461:                	}while (res == FR_OK);
1462:                
1463:                	if (res == FR_OK && ne > 1) { /* Initialize LFN entry if needed */
1464:                		res = dir_sdi(dj, is);
1465:                		if (res == FR_OK) {
1466:                			sum = sum_sfn(dj->fn); /* Sum of the SFN tied to the LFN */
1467:                			ne--;
1468:                			do { /* Store LFN entries in bottom first */
1469:                				res = move_window(dj->fs, dj->sect);
1470:                				if (res != FR_OK) break;
1471:                				fit_lfn(dj->lfn, dj->dir, (PF_BYTE)ne, sum);
1472:                				dj->fs->wflag = 1;
1473:                				res = dir_next(dj, 0); /* Next entry */
1474:                			}while (res == FR_OK && --ne);
1475:                		}
1476:                	}
1477:                
1478:                #else	/* Non LFN configuration */
1479:                	res = dir_sdi(dj, 0);
9D00491C  0F400F92   JAL 0x9D003E48
9D004920  00002821   ADDU A1, ZERO, ZERO
1480:                	if (res == FR_OK) {
9D004924  1440001E   BNE V0, ZERO, 0x9D0049A0
9D004928  00408021   ADDU S0, V0, ZERO
1481:                		do { /* Find a blank entry for the SFN */
1482:                			res = move_window(dj->fs, dj->sect);
9D004930  8E240000   LW A0, 0(S1)
9D004934  0F400E51   JAL 0x9D003944
9D004938  8E250010   LW A1, 16(S1)
1483:                			if (res != FR_OK)
9D00493C  14400018   BNE V0, ZERO, 0x9D0049A0
9D004940  00408021   ADDU S0, V0, ZERO
1484:                				break;
1485:                			c = *dj->dir;
9D004944  8E220014   LW V0, 20(S1)
9D004948  90420000   LBU V0, 0(V0)
1486:                			if (c == DDE || c == 0)
9D00492C  241200E5   ADDIU S2, ZERO, 229
9D00494C  5052001C   BEQL V0, S2, 0x9D0049C0
9D004950  8E240000   LW A0, 0(S1)
9D004954  10400019   BEQ V0, ZERO, 0x9D0049BC
9D004958  02202021   ADDU A0, S1, ZERO
1487:                				break; /* Is it a blank entry? */
1488:                			res = dir_next(dj, 1); /* Next entry with table stretch */
9D00495C  0F4010D1   JAL 0x9D004344
9D004960  24050001   ADDIU A1, ZERO, 1
1489:                		} while (res == FR_OK);
9D004964  1040FFF2   BEQ V0, ZERO, 0x9D004930
9D004968  00408021   ADDU S0, V0, ZERO
1490:                	}
1491:                #endif
1492:                
1493:                	if (res == FR_OK) { /* Initialize the SFN entry */
1494:                		res = move_window(dj->fs, dj->sect);
9D0049BC  8E240000   LW A0, 0(S1)
9D0049C0  0F400E51   JAL 0x9D003944
9D0049C4  8E250010   LW A1, 16(S1)
1495:                		if (res == FR_OK) {
9D0049C8  1440FFF5   BNE V0, ZERO, 0x9D0049A0
9D0049CC  00408021   ADDU S0, V0, ZERO
1496:                			dir = dj->dir;
9D0049D0  0B40125D   J 0x9D004974
9D0049D4  8E320014   LW S2, 20(S1)
1497:                			mem_set(dir, 0, SZ_DIR); /* Clean the entry */
9D004974  02402021   ADDU A0, S2, ZERO
9D004978  00002821   ADDU A1, ZERO, ZERO
9D00497C  0F400DE1   JAL 0x9D003784
9D004980  24060020   ADDIU A2, ZERO, 32
1498:                			mem_cpy(dir, dj->fn, 11); /* Put SFN */
9D004984  02402021   ADDU A0, S2, ZERO
9D004988  8E250018   LW A1, 24(S1)
9D00498C  0F400DD7   JAL 0x9D00375C
9D004990  2406000B   ADDIU A2, ZERO, 11
1499:                #if _USE_LFN
1500:                			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT); /* Put NT flag */
1501:                #endif
1502:                			dj->fs->wflag = 1;
9D004994  8E220000   LW V0, 0(S1)
9D004998  24030001   ADDIU V1, ZERO, 1
9D00499C  A0430004   SB V1, 4(V0)
1503:                		}
1504:                	}
1505:                
1506:                	return res;
1507:                }
9D00496C  0B401269   J 0x9D0049A4
9D004970  02001021   ADDU V0, S0, ZERO
9D0049A0  02001021   ADDU V0, S0, ZERO
9D0049A4  8FBF001C   LW RA, 28(SP)
9D0049A8  8FB20018   LW S2, 24(SP)
9D0049AC  8FB10014   LW S1, 20(SP)
9D0049B0  8FB00010   LW S0, 16(SP)
9D0049B4  03E00008   JR RA
9D0049B8  27BD0020   ADDIU SP, SP, 32
1508:                #endif /* !_FS_READONLY */
1509:                
1510:                /*-----------------------------------------------------------------------*/
1511:                /* Remove an object from the directory                                   */
1512:                /*-----------------------------------------------------------------------*/
1513:                #if !_FS_READONLY && !_FS_MINIMIZE
1514:                static FRESULT dir_remove( /* FR_OK: Successful, FR_DISK_ERR: A disk error */
1515:                DIR *dj /* Directory object pointing the entry to be removed */
1516:                ) {
9D003FAC  27BDFFE8   ADDIU SP, SP, -24
9D003FB0  AFBF0014   SW RA, 20(SP)
9D003FB4  AFB00010   SW S0, 16(SP)
9D003FB8  00808021   ADDU S0, A0, ZERO
1517:                	FRESULT res;
1518:                #if _USE_LFN	/* LFN configuration */
1519:                	PF_WORD i;
1520:                
1521:                	i = dj->index; /* SFN index */
1522:                	res = dir_sdi(dj, (PF_WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx)); /* Goto the SFN or top of the LFN entries */
1523:                	if (res == FR_OK) {
1524:                		do {
1525:                			res = move_window(dj->fs, dj->sect);
1526:                			if (res != FR_OK) break;
1527:                			*dj->dir = DDE; /* Mark the entry "deleted" */
1528:                			dj->fs->wflag = 1;
1529:                			if (dj->index >= i) break; /* When reached SFN, all entries of the object has been deleted. */
1530:                			res = dir_next(dj, 0); /* Next entry */
1531:                		}while (res == FR_OK);
1532:                		if (res == FR_NO_FILE) res = FR_INT_ERR;
1533:                	}
1534:                
1535:                #else			/* Non LFN configuration */
1536:                	res = dir_sdi(dj, dj->index);
9D003FBC  0F400F92   JAL 0x9D003E48
9D003FC0  94850006   LHU A1, 6(A0)
1537:                	if (res == FR_OK) {
9D003FC4  1440000C   BNE V0, ZERO, 0x9D003FF8
9D003FC8  8FBF0014   LW RA, 20(SP)
1538:                		res = move_window(dj->fs, dj->sect);
9D003FCC  8E040000   LW A0, 0(S0)
9D003FD0  0F400E51   JAL 0x9D003944
9D003FD4  8E050010   LW A1, 16(S0)
1539:                		if (res == FR_OK) {
9D003FD8  14400006   BNE V0, ZERO, 0x9D003FF4
9D003FDC  2404FFE5   ADDIU A0, ZERO, -27
1540:                			*dj->dir = DDE; /* Mark the entry "deleted" */
9D003FE0  8E030014   LW V1, 20(S0)
9D003FE4  A0640000   SB A0, 0(V1)
1541:                			dj->fs->wflag = 1;
9D003FE8  8E030000   LW V1, 0(S0)
9D003FEC  24040001   ADDIU A0, ZERO, 1
9D003FF0  A0640004   SB A0, 4(V1)
1542:                		}
1543:                	}
1544:                #endif
1545:                
1546:                	return res;
1547:                }
9D003FF4  8FBF0014   LW RA, 20(SP)
9D003FF8  8FB00010   LW S0, 16(SP)
9D003FFC  03E00008   JR RA
9D004000  27BD0018   ADDIU SP, SP, 24
1548:                #endif /* !_FS_READONLY */
1549:                
1550:                /*-----------------------------------------------------------------------*/
1551:                /* Pick a segment and create the object name in directory form           */
1552:                /*-----------------------------------------------------------------------*/
1553:                
1554:                static FRESULT create_name(DIR *dj, /* Pointer to the directory object */
1555:                const TCHAR **path /* Pointer to pointer to the segment in the path string */
1556:                ) {
1557:                #ifdef _EXCVT
1558:                	static const PF_BYTE excvt[] = _EXCVT; /* Upper conversion table for extended chars */
1559:                #endif
1560:                
1561:                #if _USE_LFN	/* LFN configuration */
1562:                	PF_BYTE b, cf;
1563:                	WCHAR w, *lfn;
1564:                	UINT i, ni, si, di;
1565:                	const TCHAR *p;
1566:                
1567:                	/* Create LFN in Unicode */
1568:                	for (p = *path; *p == '/' || *p == '\\'; p++); /* Strip duplicated separator */
1569:                	lfn = dj->lfn;
1570:                	si = di = 0;
1571:                	for (;;) {
1572:                		w = p[si++]; /* Get a character */
1573:                		if (w < ' ' || w == '/' || w == '\\') break; /* Break on end of segment */
1574:                		if (di >= _MAX_LFN) /* Reject too long name */
1575:                		return FR_INVALID_NAME;
1576:                #if !_LFN_UNICODE
1577:                		w &= 0xFF;
1578:                		if (IsDBCS1(w)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1579:                			b = (PF_BYTE)p[si++]; /* Get 2nd byte */
1580:                			if (!IsDBCS2(b))
1581:                			return FR_INVALID_NAME; /* Reject invalid sequence */
1582:                			w = (w << 8) + b; /* Create a DBC */
1583:                		}
1584:                		w = ff_convert(w, 1); /* Convert ANSI/OEM to Unicode */
1585:                		if (!w) return FR_INVALID_NAME; /* Reject invalid code */
1586:                #endif
1587:                		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
1588:                		return FR_INVALID_NAME;
1589:                		lfn[di++] = w; /* Store the Unicode char */
1590:                	}
1591:                	*path = &p[si]; /* Return pointer to the next segment */
1592:                	cf = (w < ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
1593:                #if _FS_RPATH
1594:                	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
1595:                			(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
1596:                		lfn[di] = 0;
1597:                		for (i = 0; i < 11; i++)
1598:                		dj->fn[i] = (i < di) ? '.' : ' ';
1599:                		dj->fn[i] = cf | NS_DOT; /* This is a dot entry */
1600:                		return FR_OK;
1601:                	}
1602:                #endif
1603:                	while (di) { /* Strip trailing spaces and dots */
1604:                		w = lfn[di-1];
1605:                		if (w != ' ' && w != '.') break;
1606:                		di--;
1607:                	}
1608:                	if (!di) return FR_INVALID_NAME; /* Reject nul string */
1609:                
1610:                	lfn[di] = 0; /* LFN is created */
1611:                
1612:                	/* Create SFN in directory form */
1613:                	mem_set(dj->fn, ' ', 11);
1614:                	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++); /* Strip leading spaces and dots */
1615:                	if (si) cf |= NS_LOSS | NS_LFN;
1616:                	while (di && lfn[di - 1] != '.') di--; /* Find extension (di<=si: no extension) */
1617:                
1618:                	b = i = 0; ni = 8;
1619:                	for (;;) {
1620:                		w = lfn[si++]; /* Get an LFN char */
1621:                		if (!w) break; /* Break on end of the LFN */
1622:                		if (w == ' ' || (w == '.' && si != di)) { /* Remove spaces and dots */
1623:                			cf |= NS_LOSS | NS_LFN; continue;
1624:                		}
1625:                
1626:                		if (i >= ni || si == di) { /* Extension or end of SFN */
1627:                			if (ni == 11) { /* Long extension */
1628:                				cf |= NS_LOSS | NS_LFN; break;
1629:                			}
1630:                			if (si != di) cf |= NS_LOSS | NS_LFN; /* Out of 8.3 format */
1631:                			if (si > di) break; /* No extension */
1632:                			si = di; i = 8; ni = 11; /* Enter extension section */
1633:                			b <<= 2; continue;
1634:                		}
1635:                
1636:                		if (w >= 0x80) { /* Non ASCII char */
1637:                #ifdef _EXCVT
1638:                			w = ff_convert(w, 0); /* Unicode -> OEM code */
1639:                			if (w) w = excvt[w - 0x80]; /* Convert extended char to upper (SBCS) */
1640:                #else
1641:                			w = ff_convert(ff_wtoupper(w), 0); /* Upper converted Unicode -> OEM code */
1642:                #endif
1643:                			cf |= NS_LFN; /* Force create LFN entry */
1644:                		}
1645:                
1646:                		if (_DF1S && w >= 0x100) { /* Double byte char (always false on SBCS cfg) */
1647:                			if (i >= ni - 1) {
1648:                				cf |= NS_LOSS | NS_LFN; i = ni; continue;
1649:                			}
1650:                			dj->fn[i++] = (PF_BYTE)(w >> 8);
1651:                		} else { /* Single byte char */
1652:                			if (!w || chk_chr("+,;=[]", w)) { /* Replace illegal chars for SFN */
1653:                				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
1654:                			} else {
1655:                				if (IsUpper(w)) { /* ASCII large capital */
1656:                					b |= 2;
1657:                				} else {
1658:                					if (IsLower(w)) { /* ASCII small capital */
1659:                						b |= 1; w -= 0x20;
1660:                					}
1661:                				}
1662:                			}
1663:                		}
1664:                		dj->fn[i++] = (PF_BYTE)w;
1665:                	}
1666:                
1667:                	if (dj->fn[0] == DDE) dj->fn[0] = NDDE; /* If the first char collides with deleted mark, replace it with 0x05 */
1668:                
1669:                	if (ni == 8) b <<= 2;
1670:                	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) /* Create LFN entry when there are composite capitals */
1671:                	cf |= NS_LFN;
1672:                	if (!(cf & NS_LFN)) { /* When LFN is in 8.3 format without extended char, NT flags are created */
1673:                		if ((b & 0x03) == 0x01) cf |= NS_EXT; /* NT flag (Extension has only small capital) */
1674:                		if ((b & 0x0C) == 0x04) cf |= NS_BODY; /* NT flag (Filename has only small capital) */
1675:                	}
1676:                
1677:                	dj->fn[NS] = cf; /* SFN is created */
1678:                
1679:                	return FR_OK;
1680:                
1681:                #else	/* Non-LFN configuration */
1682:                	PF_BYTE b, c, d, *sfn;
1683:                	UINT ni, si, i;
1684:                	const char *p;
1685:                
1686:                	/* Create file name in directory form */
1687:                	for (p = *path; *p == '/' || *p == '\\'; p++)
9D0045C0  2413005C   ADDIU S3, ZERO, 92
9D0045D0  82020000   LB V0, 0(S0)
9D0045D4  5051FFFE   BEQL V0, S1, 0x9D0045D0
9D0045D8  26100001   ADDIU S0, S0, 1
9D0045DC  5053FFFC   BEQL V0, S3, 0x9D0045D0
9D0045E0  26100001   ADDIU S0, S0, 1
1688:                		; /* Strip duplicated separator */
1689:                	sfn = dj->fn;
9D0045E4  8E550018   LW S5, 24(S2)
1690:                	mem_set(sfn, ' ', 11);
9D0045E8  02A02021   ADDU A0, S5, ZERO
9D0045EC  24050020   ADDIU A1, ZERO, 32
9D0045F0  0F400DE1   JAL 0x9D003784
9D0045F4  2406000B   ADDIU A2, ZERO, 11
1691:                	si = i = b = 0;
9D0045F8  00003021   ADDU A2, ZERO, ZERO
9D0045FC  00001821   ADDU V1, ZERO, ZERO
9D004604  00004021   ADDU T0, ZERO, ZERO
1692:                	ni = 8;
9D004600  24040008   ADDIU A0, ZERO, 8
1693:                #if _FS_RPATH
1694:                	if (p[si] == '.') { /* Is this a dot entry? */
1695:                		for (;;) {
1696:                			c = (PF_BYTE)p[si++];
1697:                			if (c != '.' || si >= 3) break;
1698:                			sfn[i++] = c;
1699:                		}
1700:                		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
1701:                		*path = &p[si]; /* Return pointer to the next segment */
1702:                		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT; /* Set last segment flag if end of path */
1703:                		return FR_OK;
1704:                	}
1705:                #endif
1706:                	for (;;) {
1707:                		c = (PF_BYTE) p[si++];
9D00460C  02031021   ADDU V0, S0, V1
9D004610  80450000   LB A1, 0(V0)
9D004614  30A200FF   ANDI V0, A1, 255
1708:                		if (c <= ' ' || c == '/' || c == '\\')
9D004618  2C470021   SLTIU A3, V0, 33
9D00461C  14E0004C   BNE A3, ZERO, 0x9D004750
9D004620  24630001   ADDIU V1, V1, 1
9D004624  505100AE   BEQL V0, S1, 0x9D0048E0
9D004628  02038021   ADDU S0, S0, V1
9D00462C  505300AC   BEQL V0, S3, 0x9D0048E0
9D004630  02038021   ADDU S0, S0, V1
1709:                			break; /* Break on end of segment */
1710:                		if (c == '.' || i >= ni) {
9D0045C4  2414002E   ADDIU S4, ZERO, 46
9D004634  10540003   BEQ V0, S4, 0x9D004644
9D004638  00C4382B   SLTU A3, A2, A0
9D00463C  14E0000A   BNE A3, ZERO, 0x9D004668
9D004640  35070003   ORI A3, T0, 3
1711:                			if (ni != 8 || c != '.')
9D004608  24090008   ADDIU T1, ZERO, 8
9D004644  5489009B   BNEL A0, T1, 0x9D0048B4
9D004648  24020006   ADDIU V0, ZERO, 6
9D00464C  14540099   BNE V0, S4, 0x9D0048B4
9D004650  24020006   ADDIU V0, ZERO, 6
1712:                				return FR_INVALID_NAME;
1713:                			i = 8;
9D00465C  01203021   ADDU A2, T1, ZERO
1714:                			ni = 11;
9D004660  0B401183   J 0x9D00460C
9D004664  2404000B   ADDIU A0, ZERO, 11
1715:                			b <<= 2;
9D004654  00084080   SLL T0, T0, 2
9D004658  310800FF   ANDI T0, T0, 255
1716:                			continue;
1717:                		}
1718:                		if (c >= 0x80) { /* Extended char? */
1719:                			b |= 3; /* Eliminate NT flag */
9D004668  28A50000   SLTI A1, A1, 0
9D00466C  00E5400B   MOVN T0, A3, A1
1720:                #ifdef _EXCVT
1721:                			c = excvt[c-0x80]; /* Upper conversion (SBCS) */
1722:                #else
1723:                #if !_DF1S	/* ASCII only cfg */
1724:                			return FR_INVALID_NAME;
1725:                #endif
1726:                #endif
1727:                		}
1728:                		if (IsDBCS1(c)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
9D004670  2445007F   ADDIU A1, V0, 127
9D004674  30A500FF   ANDI A1, A1, 255
9D004678  2CA5001F   SLTIU A1, A1, 31
9D00467C  14A00006   BNE A1, ZERO, 0x9D004698
9D004680  02032821   ADDU A1, S0, V1
9D004684  24450020   ADDIU A1, V0, 32
9D004688  30A500FF   ANDI A1, A1, 255
9D00468C  2CA5001D   SLTIU A1, A1, 29
9D004690  10A00013   BEQ A1, ZERO, 0x9D0046E0
9D004694  02032821   ADDU A1, S0, V1
1729:                			d = (PF_BYTE) p[si++]; /* Get 2nd byte */
9D004698  90A50000   LBU A1, 0(A1)
1730:                			if (!IsDBCS2(d) || i >= ni - 1) /* Reject invalid DBC */
9D00469C  24A7FFC0   ADDIU A3, A1, -64
9D0046A0  30E700FF   ANDI A3, A3, 255
9D0046A4  2CE7003F   SLTIU A3, A3, 63
9D0046A8  14E00005   BNE A3, ZERO, 0x9D0046C0
9D0046AC  2487FFFF   ADDIU A3, A0, -1
9D0046B0  38A70080   XORI A3, A1, 128
9D0046B4  2CE7007D   SLTIU A3, A3, 125
9D0046B8  10E00077   BEQ A3, ZERO, 0x9D004898
9D0046BC  2487FFFF   ADDIU A3, A0, -1
9D0046C0  00C7382B   SLTU A3, A2, A3
9D0046C4  10E00076   BEQ A3, ZERO, 0x9D0048A0
9D0046C8  24630001   ADDIU V1, V1, 1
9D004898  0B40122D   J 0x9D0048B4
9D00489C  24020006   ADDIU V0, ZERO, 6
9D0048A0  0B40122D   J 0x9D0048B4
9D0048A4  24020006   ADDIU V0, ZERO, 6
1731:                				return FR_INVALID_NAME;
1732:                			sfn[i++] = c;
9D0046CC  02A63821   ADDU A3, S5, A2
9D0046D0  A0E20000   SB V0, 0(A3)
1733:                			sfn[i++] = d;
9D0046D4  A0E50001   SB A1, 1(A3)
9D0046D8  0B401183   J 0x9D00460C
9D0046DC  24C60002   ADDIU A2, A2, 2
1734:                		} else { /* Single byte code */
1735:                			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) /* Reject illegal chrs for SFN */
1736:                				return FR_INVALID_NAME;
1737:                			if (IsUpper(c)) { /* ASCII large capital? */
9D00470C  30A500FF   ANDI A1, A1, 255
9D004710  2CA5001A   SLTIU A1, A1, 26
9D004714  10A00003   BEQ A1, ZERO, 0x9D004724
9D004718  2445FF9F   ADDIU A1, V0, -97
1738:                				b |= 2;
9D00471C  0B4011D0   J 0x9D004740
9D004720  35080002   ORI T0, T0, 2
1739:                			} else {
1740:                				if (IsLower(c)) { /* ASCII small capital? */
9D004724  30A500FF   ANDI A1, A1, 255
9D004728  2CA5001A   SLTIU A1, A1, 26
9D00472C  10A00005   BEQ A1, ZERO, 0x9D004744
9D004730  02A62821   ADDU A1, S5, A2
1741:                					b |= 1;
9D004734  35080001   ORI T0, T0, 1
1742:                					c -= 0x20;
9D004738  2442FFE0   ADDIU V0, V0, -32
9D00473C  304200FF   ANDI V0, V0, 255
1743:                				}
1744:                			}
1745:                			sfn[i++] = c;
9D004740  02A62821   ADDU A1, S5, A2
9D004744  A0A20000   SB V0, 0(A1)
9D004748  0B401183   J 0x9D00460C
9D00474C  24C60001   ADDIU A2, A2, 1
1746:                		}
1747:                	}
1748:                	*path = &p[si]; /* Return pointer to the next segment */
9D004750  02038021   ADDU S0, S0, V1
1749:                	c = (c <= ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
9D004754  24020004   ADDIU V0, ZERO, 4
9D0048E0  0B4011D6   J 0x9D004758
9D0048E4  00001021   ADDU V0, ZERO, ZERO
1750:                
1751:                	if (!i)
9D004758  10C00055   BEQ A2, ZERO, 0x9D0048B0
9D00475C  240300E5   ADDIU V1, ZERO, 229
1752:                		return FR_INVALID_NAME; /* Reject nul string */
1753:                	if (sfn[0] == DDE)
9D004760  92A50000   LBU A1, 0(S5)
9D004764  14A30004   BNE A1, V1, 0x9D004778
9D004768  24030008   ADDIU V1, ZERO, 8
1754:                		sfn[0] = NDDE; /* When first char collides with DDE, replace it with 0x05 */
9D00476C  24030005   ADDIU V1, ZERO, 5
9D004770  A2A30000   SB V1, 0(S5)
1755:                
1756:                	if (ni == 8)
9D004774  24030008   ADDIU V1, ZERO, 8
9D004778  14830004   BNE A0, V1, 0x9D00478C
9D00477C  01002021   ADDU A0, T0, ZERO
1757:                		b <<= 2;
9D004780  00084080   SLL T0, T0, 2
9D004784  310800FF   ANDI T0, T0, 255
1758:                	if ((b & 0x03) == 0x01)
9D004788  01002021   ADDU A0, T0, ZERO
9D00478C  31080003   ANDI T0, T0, 3
1759:                		c |= NS_EXT; /* NT flag (Name extension has only small capital) */
9D004790  34430010   ORI V1, V0, 16
9D004794  39080001   XORI T0, T0, 1
9D004798  0068100A   MOVZ V0, V1, T0
1760:                	if ((b & 0x0C) == 0x04)
9D00479C  3084000C   ANDI A0, A0, 12
1761:                		c |= NS_BODY; /* NT flag (Name body has only small capital) */
9D0047A0  34430008   ORI V1, V0, 8
9D0047A4  38840004   XORI A0, A0, 4
9D0047A8  0064100A   MOVZ V0, V1, A0
1762:                
1763:                	sfn[NS] = c; /* Store NT flag, File name is created */
9D0047AC  A2A2000B   SB V0, 11(S5)
1764:                
1765:                	return FR_OK;
1766:                #endif
1767:                }
1768:                
1769:                /*-----------------------------------------------------------------------*/
1770:                /* Get file information from directory entry                             */
1771:                /*-----------------------------------------------------------------------*/
1772:                #if _FS_MINIMIZE <= 1
1773:                static
1774:                void get_fileinfo( /* No return code */
9D003858  00C41021   ADDU V0, A2, A0
1775:                DIR *dj, /* Pointer to the directory object */
1776:                FILINFO *fno /* Pointer to the file information to be filled */
1777:                ) {
1778:                	UINT i;
1779:                	PF_BYTE nt, *dir;
1780:                	TCHAR *p, c;
1781:                
1782:                	p = fno->fname;
1783:                	if (dj->sect) {
9D003824  8C820010   LW V0, 16(A0)
9D003828  10400039   BEQ V0, ZERO, 0x9D003910
9D00382C  24A30009   ADDIU V1, A1, 9
1784:                		dir = dj->dir;
9D003830  8C860014   LW A2, 20(A0)
1785:                		nt = dir[DIR_NTres]; /* NT flag */
1786:                		for (i = 0; i < 8; i++) { /* Copy name body */
9D00384C  24080008   ADDIU T0, ZERO, 8
9D003874  24840001   ADDIU A0, A0, 1
9D003878  1488FFF7   BNE A0, T0, 0x9D003858
9D00387C  24630001   ADDIU V1, V1, 1
1787:                			c = dir[i];
9D003834  80C20000   LB V0, 0(A2)
9D00385C  80420000   LB V0, 0(V0)
1788:                			if (c == ' ')
9D003838  24040020   ADDIU A0, ZERO, 32
9D00383C  10440010   BEQ V0, A0, 0x9D003880
9D003840  00002021   ADDU A0, ZERO, ZERO
9D003850  0B400E1A   J 0x9D003868
9D003854  240B0020   ADDIU T3, ZERO, 32
9D003860  504B0008   BEQL V0, T3, 0x9D003884
9D003864  90C40008   LBU A0, 8(A2)
1789:                				break;
1790:                			if (c == NDDE)
9D003844  240A0005   ADDIU T2, ZERO, 5
1791:                				c = (TCHAR) DDE;
9D003848  2409FFE5   ADDIU T1, ZERO, -27
9D003868  004A3826   XOR A3, V0, T2
9D00386C  0127100A   MOVZ V0, T1, A3
1792:                			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c))
1793:                				c += 0x20;
1794:                #if _LFN_UNICODE
1795:                			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
1796:                			c = (c << 8) | dir[++i];
1797:                			c = ff_convert(c, 1);
1798:                			if (!c) c = '?';
1799:                #endif
1800:                			*p++ = c;
9D003870  A0620000   SB V0, 0(V1)
1801:                		}
1802:                		if (dir[8] != ' ') { /* Copy name extension */
9D003880  90C40008   LBU A0, 8(A2)
9D003884  24020020   ADDIU V0, ZERO, 32
9D003888  1082000A   BEQ A0, V0, 0x9D0038B4
9D00388C  2402002E   ADDIU V0, ZERO, 46
1803:                			*p++ = '.';
9D003890  A0620000   SB V0, 0(V1)
1804:                			for (i = 8; i < 11; i++) {
1805:                				c = dir[i];
9D003894  80C20008   LB V0, 8(A2)
9D00391C  80C20009   LB V0, 9(A2)
9D003930  80C2000A   LB V0, 10(A2)
1806:                				if (c == ' ')
9D003898  24040020   ADDIU A0, ZERO, 32
9D00389C  1444001E   BNE V0, A0, 0x9D003918
9D0038A0  24630001   ADDIU V1, V1, 1
9D003920  24040020   ADDIU A0, ZERO, 32
9D003924  1044FFE3   BEQ V0, A0, 0x9D0038B4
9D003928  24630001   ADDIU V1, V1, 1
9D003934  1444FFDD   BNE V0, A0, 0x9D0038AC
9D003938  24630001   ADDIU V1, V1, 1
1807:                					break;
1808:                				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c))
1809:                					c += 0x20;
1810:                #if _LFN_UNICODE
1811:                				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
1812:                				c = (c << 8) | dir[++i];
1813:                				c = ff_convert(c, 1);
1814:                				if (!c) c = '?';
1815:                #endif
1816:                				*p++ = c;
9D0038AC  A0620000   SB V0, 0(V1)
9D0038B0  24630001   ADDIU V1, V1, 1
9D003918  A0620000   SB V0, 0(V1)
9D00392C  A0620000   SB V0, 0(V1)
1817:                			}
1818:                		}
1819:                		fno->fattrib = dir[DIR_Attr]; /* Attribute */
9D0038A4  0B400E2E   J 0x9D0038B8
9D0038A8  90C2000B   LBU V0, 11(A2)
9D0038B4  90C2000B   LBU V0, 11(A2)
9D0038B8  A0A20008   SB V0, 8(A1)
9D00393C  0B400E2E   J 0x9D0038B8
9D003940  90C2000B   LBU V0, 11(A2)
1820:                		fno->fsize = LD_DWORD(dir+DIR_FileSize); /* Size */
9D0038BC  90C4001F   LBU A0, 31(A2)
9D0038C0  00042600   SLL A0, A0, 24
9D0038C4  90C2001E   LBU V0, 30(A2)
9D0038C8  00021400   SLL V0, V0, 16
9D0038CC  00821025   OR V0, A0, V0
9D0038D0  90C4001C   LBU A0, 28(A2)
9D0038D4  00441025   OR V0, V0, A0
9D0038D8  90C4001D   LBU A0, 29(A2)
9D0038DC  00042200   SLL A0, A0, 8
9D0038E0  00441025   OR V0, V0, A0
9D0038E4  ACA20000   SW V0, 0(A1)
1821:                		fno->fdate = LD_WORD(dir+DIR_WrtDate); /* Date */
9D0038E8  90C20019   LBU V0, 25(A2)
9D0038EC  00021200   SLL V0, V0, 8
9D0038F0  90C40018   LBU A0, 24(A2)
9D0038F4  00441025   OR V0, V0, A0
9D0038F8  A4A20004   SH V0, 4(A1)
1822:                		fno->ftime = LD_WORD(dir+DIR_WrtTime); /* Time */
9D0038FC  90C20017   LBU V0, 23(A2)
9D003900  00021200   SLL V0, V0, 8
9D003904  90C40016   LBU A0, 22(A2)
9D003908  00441025   OR V0, V0, A0
9D00390C  A4A20006   SH V0, 6(A1)
1823:                	}
1824:                	*p = 0; /* Terminate SFN str by a \0 */
1825:                
1826:                #if _USE_LFN
1827:                	if (fno->lfname && fno->lfsize) {
1828:                		TCHAR *tp = fno->lfname;
1829:                		WCHAR w, *lfn;
1830:                
1831:                		i = 0;
1832:                		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
1833:                			lfn = dj->lfn;
1834:                			while ((w = *lfn++) != 0) { /* Get an LFN char */
1835:                #if !_LFN_UNICODE
1836:                				w = ff_convert(w, 0); /* Unicode -> OEM conversion */
1837:                				if (!w) {i = 0; break;} /* Could not convert, no LFN */
1838:                				if (_DF1S && w >= 0x100) /* Put 1st byte if it is a DBC (always false on SBCS cfg) */
1839:                				tp[i++] = (TCHAR)(w >> 8);
1840:                #endif
1841:                				if (i >= fno->lfsize - 1) {i = 0; break;} /* Buffer overflow, no LFN */
1842:                				tp[i++] = (TCHAR)w;
1843:                			}
1844:                		}
1845:                		tp[i] = 0; /* Terminate the LFN str by a \0 */
1846:                	}
1847:                #endif
1848:                }
9D003910  03E00008   JR RA
9D003914  A0600000   SB ZERO, 0(V1)
1849:                #endif /* _FS_MINIMIZE <= 1 */
1850:                
1851:                /*-----------------------------------------------------------------------*/
1852:                /* Follow a file path                                                    */
1853:                /*-----------------------------------------------------------------------*/
1854:                
1855:                static FRESULT follow_path( /* FR_OK(0): successful, !=0: error code */
9D004800  0B401204   J 0x9D004810
9D004804  24E8000B   ADDIU T0, A3, 11
1856:                DIR *dj, /* Directory object to return last directory and found object */
1857:                const TCHAR *path /* Full-path string to find a file or directory */
1858:                ) {
9D00454C  27BDFFC8   ADDIU SP, SP, -56
9D004550  AFBF0034   SW RA, 52(SP)
9D004554  AFB70030   SW S7, 48(SP)
9D004558  AFB6002C   SW S6, 44(SP)
9D00455C  AFB50028   SW S5, 40(SP)
9D004560  AFB40024   SW S4, 36(SP)
9D004564  AFB30020   SW S3, 32(SP)
9D004568  AFB2001C   SW S2, 28(SP)
9D00456C  AFB10018   SW S1, 24(SP)
9D004570  AFB00014   SW S0, 20(SP)
9D004574  00809021   ADDU S2, A0, ZERO
1859:                	FRESULT res;
1860:                	PF_BYTE *dir, ns;
1861:                
1862:                #if _FS_RPATH
1863:                	if (*path == '/' || *path == '\\') { /* There is a heading separator */
1864:                		path++; dj->sclust = 0; /* Strip it and start from the root dir */
1865:                	} else { /* No heading separator */
1866:                		dj->sclust = dj->fs->cdir; /* Start from the current dir */
1867:                	}
1868:                #else
1869:                	if (*path == '/' || *path == '\\') /* Strip heading separator if exist */
9D004578  80A20000   LB V0, 0(A1)
9D00457C  2403002F   ADDIU V1, ZERO, 47
9D004580  10430004   BEQ V0, V1, 0x9D004594
9D004584  00A08021   ADDU S0, A1, ZERO
9D004588  2403005C   ADDIU V1, ZERO, 92
9D00458C  54430003   BNEL V0, V1, 0x9D00459C
9D004590  AE400008   SW ZERO, 8(S2)
1870:                		path++;
9D004594  26100001   ADDIU S0, S0, 1
1871:                	dj->sclust = 0; /* Start from the root dir */
9D004598  AE400008   SW ZERO, 8(S2)
1872:                #endif
1873:                
1874:                	if ((UINT) *path < ' ') { /* Nul path means the start directory itself */
9D00459C  92020000   LBU V0, 0(S0)
9D0045A0  2C420020   SLTIU V0, V0, 32
9D0045A4  10400006   BEQ V0, ZERO, 0x9D0045C0
9D0045A8  2411002F   ADDIU S1, ZERO, 47
1875:                		res = dir_sdi(dj, 0);
9D0045AC  02402021   ADDU A0, S2, ZERO
9D0045B0  0F400F92   JAL 0x9D003E48
9D0045B4  00002821   ADDU A1, ZERO, ZERO
1876:                		dj->dir = 0;
9D0045B8  0B40122D   J 0x9D0048B4
9D0045BC  AE400014   SW ZERO, 20(S2)
1877:                
1878:                	} else { /* Follow path */
1879:                		for (;;) {
1880:                			res = create_name(dj, &path); /* Get a segment */
1881:                			if (res != FR_OK)
1882:                				break;
1883:                			res = dir_find(dj); /* Find it */
9D004850  24030004   ADDIU V1, ZERO, 4
9D004854  24020005   ADDIU V0, ZERO, 5
9D004858  0B40122D   J 0x9D0048B4
9D00485C  0064100B   MOVN V0, V1, A0
1884:                			ns = *(dj->fn + NS);
9D004838  8E430018   LW V1, 24(S2)
9D00483C  9064000B   LBU A0, 11(V1)
9D0048FC  0B401213   J 0x9D00484C
9D004900  9044000B   LBU A0, 11(V0)
1885:                			if (res != FR_OK) { /* Failed to find the object */
1886:                				if (res != FR_NO_FILE)
9D004840  24030004   ADDIU V1, ZERO, 4
9D004844  1443001C   BNE V0, V1, 0x9D0048B8
9D004848  8FBF0034   LW RA, 52(SP)
1887:                					break; /* Abort if any hard error occured */
1888:                				/* Object not found */
1889:                				if (_FS_RPATH && (ns & NS_DOT)) { /* If dot entry is not exit */
1890:                					dj->sclust = 0;
1891:                					dj->dir = 0; /* It is the root dir */
1892:                					res = FR_OK;
1893:                					if (!(ns & NS_LAST))
1894:                						continue;
1895:                				} else { /* Could not find the object */
1896:                					if (!(ns & NS_LAST))
9D00484C  30840004   ANDI A0, A0, 4
1897:                						res = FR_NO_PATH;
1898:                				}
1899:                				break;
1900:                			}
1901:                			if (ns & NS_LAST)
9D0048E8  30630004   ANDI V1, V1, 4
9D0048EC  5060FFDC   BEQL V1, ZERO, 0x9D004860
9D0048F0  31290010   ANDI T1, T1, 16
1902:                				break; /* Last segment match. Function completed. */
1903:                			dir = dj->dir; /* There is next segment. Follow the sub directory */
1904:                			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
9D004860  11200014   BEQ T1, ZERO, 0x9D0048B4
9D004864  24020005   ADDIU V0, ZERO, 5
1905:                				res = FR_NO_PATH;
1906:                				break;
1907:                			}
1908:                			dj->sclust = LD_CLUST(dir);
9D004868  90E30015   LBU V1, 21(A3)
9D00486C  00031A00   SLL V1, V1, 8
9D004870  90E20014   LBU V0, 20(A3)
9D004874  00621825   OR V1, V1, V0
9D004878  00031C00   SLL V1, V1, 16
9D00487C  90E2001B   LBU V0, 27(A3)
9D004880  00021200   SLL V0, V0, 8
9D004884  90E4001A   LBU A0, 26(A3)
9D004888  00441025   OR V0, V0, A0
9D00488C  00621025   OR V0, V1, V0
9D004890  0B401174   J 0x9D0045D0
9D004894  AE420008   SW V0, 8(S2)
1909:                		}
1910:                	}
1911:                
1912:                	return res;
1913:                }
9D0048B4  8FBF0034   LW RA, 52(SP)
9D0048B8  8FB70030   LW S7, 48(SP)
9D0048BC  8FB6002C   LW S6, 44(SP)
9D0048C0  8FB50028   LW S5, 40(SP)
9D0048C4  8FB40024   LW S4, 36(SP)
9D0048C8  8FB30020   LW S3, 32(SP)
9D0048CC  8FB2001C   LW S2, 28(SP)
9D0048D0  8FB10018   LW S1, 24(SP)
9D0048D4  8FB00014   LW S0, 20(SP)
9D0048D8  03E00008   JR RA
9D0048DC  27BD0038   ADDIU SP, SP, 56
9D0048F4  0B40122E   J 0x9D0048B8
9D0048F8  8FBF0034   LW RA, 52(SP)
1914:                
1915:                /*-----------------------------------------------------------------------*/
1916:                /* Load a sector and check if it is an FAT Volume Boot Record            */
1917:                /*-----------------------------------------------------------------------*/
1918:                
1919:                static PF_BYTE check_fs( /* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
1920:                FATFS *fs, /* File system object */
1921:                DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
1922:                ) {
9D003A48  27BDFFE8   ADDIU SP, SP, -24
9D003A4C  AFBF0014   SW RA, 20(SP)
9D003A50  AFB00010   SW S0, 16(SP)
9D003A54  00808021   ADDU S0, A0, ZERO
9D003A58  00A03021   ADDU A2, A1, ZERO
1923:                	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK) /* Load boot record */
9D003A5C  90840001   LBU A0, 1(A0)
9D003A60  26050030   ADDIU A1, S0, 48
9D003A64  0F40237E   JAL disk_read
9D003A68  24070001   ADDIU A3, ZERO, 1
9D003A6C  14400027   BNE V0, ZERO, 0x9D003B0C
9D003A70  24030003   ADDIU V1, ZERO, 3
1924:                		return 3;
9D003AFC  3C02FFAB   LUI V0, -85
9D003B00  3442BEBA   ORI V0, V0, -16710
9D003B04  00621821   ADDU V1, V1, V0
9D003B08  0003182B   SLTU V1, ZERO, V1
1925:                	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55) /* Check record signature (always placed at offset 510 even if the sector size is >512) */
9D003A74  9204022F   LBU A0, 559(S0)
9D003A78  00042200   SLL A0, A0, 8
9D003A7C  9202022E   LBU V0, 558(S0)
9D003A80  00822025   OR A0, A0, V0
9D003A84  7C042620   SEH A0, A0
9D003A88  2402AA55   ADDIU V0, ZERO, -21931
9D003A8C  1482001F   BNE A0, V0, 0x9D003B0C
9D003A90  24030002   ADDIU V1, ZERO, 2
1926:                		return 2;
1927:                
1928:                	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) /* Check "FAT" string */
9D003A94  92040069   LBU A0, 105(S0)
9D003A98  00042600   SLL A0, A0, 24
9D003A9C  92020068   LBU V0, 104(S0)
9D003AA0  00021400   SLL V0, V0, 16
9D003AA4  00822025   OR A0, A0, V0
9D003AA8  92020066   LBU V0, 102(S0)
9D003AAC  00822025   OR A0, A0, V0
9D003AB0  92020067   LBU V0, 103(S0)
9D003AB4  00021200   SLL V0, V0, 8
9D003AB8  00822025   OR A0, A0, V0
9D003ABC  7C84B800   EXT A0, A0, 0, 24
9D003AC0  3C020054   LUI V0, 84
9D003AC4  24424146   ADDIU V0, V0, 16710
9D003AC8  10820010   BEQ A0, V0, 0x9D003B0C
9D003ACC  00001821   ADDU V1, ZERO, ZERO
1929:                		return 0;
1930:                	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
9D003AD0  92030085   LBU V1, 133(S0)
9D003AD4  00031E00   SLL V1, V1, 24
9D003AD8  92020084   LBU V0, 132(S0)
9D003ADC  00021400   SLL V0, V0, 16
9D003AE0  00621825   OR V1, V1, V0
9D003AE4  92020082   LBU V0, 130(S0)
9D003AE8  00621825   OR V1, V1, V0
9D003AEC  92020083   LBU V0, 131(S0)
9D003AF0  00021200   SLL V0, V0, 8
9D003AF4  00621825   OR V1, V1, V0
9D003AF8  7C63B800   EXT V1, V1, 0, 24
1931:                		return 0;
1932:                
1933:                	return 1;
1934:                }
9D003B0C  00601021   ADDU V0, V1, ZERO
9D003B10  8FBF0014   LW RA, 20(SP)
9D003B14  8FB00010   LW S0, 16(SP)
9D003B18  03E00008   JR RA
9D003B1C  27BD0018   ADDIU SP, SP, 24
1935:                
1936:                /*-----------------------------------------------------------------------*/
1937:                /* Check if the file system object is valid or not                       */
1938:                /*-----------------------------------------------------------------------*/
1939:                
1940:                FRESULT chk_mounted( /* FR_OK(0): successful, !=0: any error occurred */
1941:                                            const TCHAR **path, /* Pointer to pointer to the path name (drive number) */
1942:                                            FATFS **rfs, /* Pointer to pointer to the found file system object */
1943:                                            PF_BYTE chk_wp /* !=0: Check media write protection for write access */
1944:                                            ) {
9D004B68  27BDFFE0   ADDIU SP, SP, -32
9D004B6C  AFBF001C   SW RA, 28(SP)
9D004B70  AFB20018   SW S2, 24(SP)
9D004B74  AFB10014   SW S1, 20(SP)
9D004B78  AFB00010   SW S0, 16(SP)
9D004B7C  30D100FF   ANDI S1, A2, 255
1945:                	PF_BYTE fmt, b, pi, *tbl;
1946:                	UINT vol;
1947:                	DSTATUS stat;
1948:                	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
1949:                	PF_WORD nrsv;
1950:                	const TCHAR *p = *path;
9D004B80  8C820000   LW V0, 0(A0)
1951:                	FATFS *fs;
1952:                
1953:                	/* Get logical drive number from the path name */
1954:                	vol = p[0] - '0'; /* Is there a drive number? */
9D004B84  80430000   LB V1, 0(V0)
9D004B88  2463FFD0   ADDIU V1, V1, -48
1955:                	if (vol <= 9 && p[1] == ':') { /* Found a drive number, get and strip it */
9D004B8C  2C66000A   SLTIU A2, V1, 10
9D004B90  10C0000A   BEQ A2, ZERO, 0x9D004BBC
9D004B94  8F90806C   LW S0, -32660(GP)
9D004B98  80470001   LB A3, 1(V0)
9D004B9C  2406003A   ADDIU A2, ZERO, 58
9D004BA0  54E60007   BNEL A3, A2, 0x9D004BC0
9D004BA4  ACB00000   SW S0, 0(A1)
1956:                		p += 2;
9D004BA8  24420002   ADDIU V0, V0, 2
1957:                		*path = p; /* Return pointer to the path name */
9D004BAC  AC820000   SW V0, 0(A0)
1958:                	} else { /* No drive number is given */
1959:                #if _FS_RPATH
1960:                		vol = CurrVol; /* Use current drive */
1961:                #else
1962:                		vol = 0; /* Use drive 0 */
1963:                #endif
1964:                	}
1965:                
1966:                	/* Check if the file system object is valid or not */
1967:                	if (vol >= _VOLUMES) /* Is the drive number valid? */
9D004BB0  14600112   BNE V1, ZERO, 0x9D004FFC
9D004BB4  2402000B   ADDIU V0, ZERO, 11
1968:                		return FR_INVALID_DRIVE;
1969:                	*rfs = fs = FatFs[vol]; /* Return pointer to the corresponding file system object */
9D004BB8  8F90806C   LW S0, -32660(GP)
9D004BBC  ACB00000   SW S0, 0(A1)
1970:                	if (!fs)
9D004BC0  1200010E   BEQ S0, ZERO, 0x9D004FFC
9D004BC4  2402000C   ADDIU V0, ZERO, 12
1971:                		return FR_NOT_ENABLED; /* Is the file system object available? */
1972:                
1973:                	ENTER_FF(fs); /* Lock file system */
1974:                
1975:                	if (fs->fs_type) { /* If the logical drive has been mounted */
9D004BC8  92020000   LBU V0, 0(S0)
9D004BCC  5040000D   BEQL V0, ZERO, 0x9D004C04
9D004BD0  A2000000   SB ZERO, 0(S0)
1976:                		stat = disk_status(fs->drv);
9D004BD4  0F402377   JAL disk_status
9D004BD8  92040001   LBU A0, 1(S0)
9D004BDC  00401821   ADDU V1, V0, ZERO
1977:                		if (!(stat & STA_NOINIT)) { /* and the physical drive is kept initialized (has not been changed), */
9D004BE0  30420001   ANDI V0, V0, 1
9D004BE4  54400007   BNEL V0, ZERO, 0x9D004C04
9D004BE8  A2000000   SB ZERO, 0(S0)
1978:                			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check write protection if needed */
9D004BEC  12200103   BEQ S1, ZERO, 0x9D004FFC
9D004BF0  2404000A   ADDIU A0, ZERO, 10
9D004BF4  30620004   ANDI V0, V1, 4
1979:                				return FR_WRITE_PROTECTED;
1980:                			return FR_OK; /* The file system object is valid */
9D004BF8  0002200A   MOVZ A0, ZERO, V0
9D004BFC  0B4013FF   J 0x9D004FFC
9D004C00  00801021   ADDU V0, A0, ZERO
1981:                		}
1982:                	}
1983:                
1984:                	/* The file system object is not valid. */
1985:                	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
1986:                
1987:                	fs->fs_type = 0; /* Clear the file system object */
1988:                	fs->drv = LD2PD(vol); /* Bind the logical drive and a physical drive */
9D004C04  A2000001   SB ZERO, 1(S0)
1989:                	stat = disk_initialize(fs->drv); /* Initialize low level disk I/O layer */
9D004C08  0F4022E6   JAL disk_initialize
9D004C0C  00002021   ADDU A0, ZERO, ZERO
9D004C10  00401821   ADDU V1, V0, ZERO
1990:                	if (stat & STA_NOINIT) /* Check if the initialization succeeded */
9D004C14  30440001   ANDI A0, V0, 1
9D004C18  148000F8   BNE A0, ZERO, 0x9D004FFC
9D004C1C  24020003   ADDIU V0, ZERO, 3
1991:                		return FR_NOT_READY; /* Failed to initialize due to no media or hard error */
1992:                	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check disk write protection if needed */
9D004C20  12200003   BEQ S1, ZERO, 0x9D004C30
9D004C24  30630004   ANDI V1, V1, 4
9D004C28  146000F4   BNE V1, ZERO, 0x9D004FFC
9D004C2C  2402000A   ADDIU V0, ZERO, 10
1993:                		return FR_WRITE_PROTECTED;
1994:                #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
1995:                	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
1996:                	return FR_DISK_ERR;
1997:                #endif
1998:                	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
1999:                	fmt = check_fs(fs, bsect = 0); /* Load sector 0 and check if it is an FAT-VBR (in SFD) */
9D004C30  02002021   ADDU A0, S0, ZERO
9D004C34  0F400E92   JAL 0x9D003A48
9D004C38  00002821   ADDU A1, ZERO, ZERO
9D004C3C  00401821   ADDU V1, V0, ZERO
2000:                	if (LD2PT(vol) && !fmt)
2001:                		fmt = 1; /* Force non-SFD if the volume is forced partition */
2002:                	if (fmt == 1) { /* Not an FAT-VBR, the physical drive can be partitioned */
9D004C40  24020001   ADDIU V0, ZERO, 1
9D004C44  14620012   BNE V1, V0, 0x9D004C90
9D004C48  00008821   ADDU S1, ZERO, ZERO
2003:                		/* Check the partition listed in the partition table */
2004:                		pi = LD2PT(vol);
2005:                		if (pi)
2006:                			pi--;
2007:                		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
2008:                		if (tbl[4]) { /* Is the partition existing? */
9D004C4C  920301F2   LBU V1, 498(S0)
9D004C50  106000EA   BEQ V1, ZERO, 0x9D004FFC
9D004C54  2402000D   ADDIU V0, ZERO, 13
2009:                			bsect = LD_DWORD(&tbl[8]); /* Partition offset in LBA */
9D004C58  921101F9   LBU S1, 505(S0)
9D004C5C  00118E00   SLL S1, S1, 24
9D004C60  920201F8   LBU V0, 504(S0)
9D004C64  00021400   SLL V0, V0, 16
9D004C68  02228825   OR S1, S1, V0
9D004C6C  920201F6   LBU V0, 502(S0)
9D004C70  02228825   OR S1, S1, V0
9D004C74  920201F7   LBU V0, 503(S0)
9D004C78  00021200   SLL V0, V0, 8
9D004C7C  02228825   OR S1, S1, V0
2010:                			fmt = check_fs(fs, bsect); /* Check the partition */
9D004C80  02002021   ADDU A0, S0, ZERO
9D004C84  0F400E92   JAL 0x9D003A48
9D004C88  02202821   ADDU A1, S1, ZERO
9D004C8C  00401821   ADDU V1, V0, ZERO
2011:                		}
2012:                	}
2013:                	if (fmt == 3)
9D004C90  24040003   ADDIU A0, ZERO, 3
9D004C94  106400D9   BEQ V1, A0, 0x9D004FFC
9D004C98  24020001   ADDIU V0, ZERO, 1
2014:                		return FR_DISK_ERR;
2015:                	if (fmt)
9D004C9C  146000D7   BNE V1, ZERO, 0x9D004FFC
9D004CA0  2402000D   ADDIU V0, ZERO, 13
2016:                		return FR_NO_FILESYSTEM; /* No FAT volume is found */
2017:                
2018:                	/* An FAT volume is found. Following code initializes the file system object */
2019:                
2020:                	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs)) /* (BPB_BytsPerSec must be equal to the physical sector size) */
9D004CA4  9204003C   LBU A0, 60(S0)
9D004CA8  00042200   SLL A0, A0, 8
9D004CAC  9202003B   LBU V0, 59(S0)
9D004CB0  00822025   OR A0, A0, V0
9D004CB4  7C042620   SEH A0, A0
9D004CB8  24030200   ADDIU V1, ZERO, 512
9D004CBC  148300CF   BNE A0, V1, 0x9D004FFC
9D004CC0  2402000D   ADDIU V0, ZERO, 13
2021:                		return FR_NO_FILESYSTEM;
2022:                
2023:                	fasize = LD_WORD(fs->win+BPB_FATSz16); /* Number of sectors per FAT */
9D004CC4  92030047   LBU V1, 71(S0)
9D004CC8  00031A00   SLL V1, V1, 8
9D004CCC  92020046   LBU V0, 70(S0)
9D004CD0  00621825   OR V1, V1, V0
2024:                	if (!fasize)
9D004CD4  5460000C   BNEL V1, ZERO, 0x9D004D08
9D004CD8  AE03001C   SW V1, 28(S0)
2025:                		fasize = LD_DWORD(fs->win+BPB_FATSz32);
9D004CDC  92030057   LBU V1, 87(S0)
9D004CE0  00031E00   SLL V1, V1, 24
9D004CE4  92020056   LBU V0, 86(S0)
9D004CE8  00021400   SLL V0, V0, 16
9D004CEC  00621825   OR V1, V1, V0
9D004CF0  92020054   LBU V0, 84(S0)
9D004CF4  00621825   OR V1, V1, V0
9D004CF8  92020055   LBU V0, 85(S0)
9D004CFC  00021200   SLL V0, V0, 8
9D004D00  00621825   OR V1, V1, V0
2026:                	fs->fsize = fasize;
9D004D04  AE03001C   SW V1, 28(S0)
2027:                
2028:                	fs->n_fats = b = fs->win[BPB_NumFATs]; /* Number of FAT copies */
9D004D08  92040040   LBU A0, 64(S0)
9D004D0C  A2040003   SB A0, 3(S0)
2029:                	if (b != 1 && b != 2)
9D004D10  2485FFFF   ADDIU A1, A0, -1
9D004D14  30A500FF   ANDI A1, A1, 255
9D004D18  2CA50002   SLTIU A1, A1, 2
9D004D1C  10A000B7   BEQ A1, ZERO, 0x9D004FFC
9D004D20  2402000D   ADDIU V0, ZERO, 13
2030:                		return FR_NO_FILESYSTEM; /* (Must be 1 or 2) */
2031:                	fasize *= b; /* Number of sectors for FAT area */
9D004DB4  70642002   MUL A0, V1, A0
2032:                
2033:                	fs->csize = b = fs->win[BPB_SecPerClus]; /* Number of sectors per cluster */
9D004D24  9205003D   LBU A1, 61(S0)
2034:                	if (!b || (b & (b - 1)))
9D004D28  10A000B4   BEQ A1, ZERO, 0x9D004FFC
9D004D2C  A2050002   SB A1, 2(S0)
9D004D30  24A6FFFF   ADDIU A2, A1, -1
9D004D34  00C53024   AND A2, A2, A1
9D004D38  14C000B1   BNE A2, ZERO, 0x9D005000
9D004D3C  8FBF001C   LW RA, 28(SP)
2035:                		return FR_NO_FILESYSTEM; /* (Must be power of 2) */
2036:                
2037:                	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt); /* Number of root directory entries */
9D004D40  92060042   LBU A2, 66(S0)
9D004D44  00063200   SLL A2, A2, 8
9D004D48  92020041   LBU V0, 65(S0)
9D004D4C  00C23025   OR A2, A2, V0
9D004D50  A6060008   SH A2, 8(S0)
2038:                	if (fs->n_rootdir % (SS(fs) / SZ_DIR))
9D004D54  30C7000F   ANDI A3, A2, 15
9D004D58  14E000A8   BNE A3, ZERO, 0x9D004FFC
9D004D5C  2402000D   ADDIU V0, ZERO, 13
2039:                		return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be sector aligned) */
2040:                
2041:                	tsect = LD_WORD(fs->win+BPB_TotSec16); /* Number of sectors on the volume */
9D004D60  92070044   LBU A3, 68(S0)
9D004D64  00073A00   SLL A3, A3, 8
9D004D68  92020043   LBU V0, 67(S0)
9D004D6C  00E23825   OR A3, A3, V0
2042:                	if (!tsect)
9D004D70  14E0000B   BNE A3, ZERO, 0x9D004DA0
9D004D74  9208003F   LBU T0, 63(S0)
2043:                		tsect = LD_DWORD(fs->win+BPB_TotSec32);
9D004D78  92070053   LBU A3, 83(S0)
9D004D7C  00073E00   SLL A3, A3, 24
9D004D80  92020052   LBU V0, 82(S0)
9D004D84  00021400   SLL V0, V0, 16
9D004D88  00E23825   OR A3, A3, V0
9D004D8C  92020050   LBU V0, 80(S0)
9D004D90  00E23825   OR A3, A3, V0
9D004D94  92020051   LBU V0, 81(S0)
9D004D98  00021200   SLL V0, V0, 8
9D004D9C  00E23825   OR A3, A3, V0
2044:                
2045:                	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt); /* Number of reserved sectors */
9D004DA0  00084200   SLL T0, T0, 8
9D004DA4  9202003E   LBU V0, 62(S0)
9D004DA8  01024025   OR T0, T0, V0
2046:                	if (!nrsv)
9D004DAC  11000093   BEQ T0, ZERO, 0x9D004FFC
9D004DB0  2402000D   ADDIU V0, ZERO, 13
2047:                		return FR_NO_FILESYSTEM; /* (BPB_RsvdSecCnt must not be 0) */
2048:                
2049:                	/* Determine the FAT sub type */
2050:                	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR); /* RSV+FAT+DIR */
9D004DB8  00064902   SRL T1, A2, 4
9D004DBC  01284821   ADDU T1, T1, T0
9D004DC0  01244821   ADDU T1, T1, A0
2051:                	if (tsect < sysect)
9D004DC4  00E9502B   SLTU T2, A3, T1
9D004DC8  1540008D   BNE T2, ZERO, 0x9D005000
9D004DCC  8FBF001C   LW RA, 28(SP)
2052:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2053:                	nclst = (tsect - sysect) / fs->csize; /* Number of clusters */
9D004DD0  00E93823   SUBU A3, A3, T1
9D004DD4  00E5001B   DIVU A3, A1
9D004DD8  00A001F4   TEQ A1, ZERO
9D004DDC  00002812   MFLO A1, 0
2054:                	if (!nclst)
9D004DE0  10A00086   BEQ A1, ZERO, 0x9D004FFC
9D004DE4  2CB20FF6   SLTIU S2, A1, 4086
2055:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2056:                	fmt = FS_FAT12;
9D004DE8  24020001   ADDIU V0, ZERO, 1
9D004DEC  240A0002   ADDIU T2, ZERO, 2
9D004DF0  0152100A   MOVZ V0, T2, S2
9D004DF4  00409021   ADDU S2, V0, ZERO
2057:                	if (nclst >= MIN_FAT16)
2058:                		fmt = FS_FAT16;
2059:                	if (nclst >= MIN_FAT32)
9D004DF8  3402FFF6   ORI V0, ZERO, -10
9D004DFC  00A2102B   SLTU V0, A1, V0
9D004E00  10400084   BEQ V0, ZERO, 0x9D005014
9D004E04  24A50002   ADDIU A1, A1, 2
2060:                		fmt = FS_FAT32;
9D005028  0B401389   J 0x9D004E24
9D00502C  24120003   ADDIU S2, ZERO, 3
2061:                
2062:                	/* Boundaries and Limits */
2063:                	fs->n_fatent = nclst + 2; /* Number of FAT entries */
9D004E08  AE050018   SW A1, 24(S0)
9D005014  AE050018   SW A1, 24(S0)
2064:                	fs->database = bsect + sysect; /* Data start sector */
9D004E0C  02294821   ADDU T1, S1, T1
9D004E10  AE090028   SW T1, 40(S0)
9D005018  02294821   ADDU T1, S1, T1
9D00501C  AE090028   SW T1, 40(S0)
2065:                	fs->fatbase = bsect + nrsv; /* FAT start sector */
9D004E14  02284021   ADDU T0, S1, T0
9D005020  02284021   ADDU T0, S1, T0
9D005024  AE080020   SW T0, 32(S0)
2066:                	if (fmt == FS_FAT32) {
9D004E18  24020003   ADDIU V0, ZERO, 3
9D004E1C  16420010   BNE S2, V0, 0x9D004E60
9D004E20  AE080020   SW T0, 32(S0)
2067:                		if (fs->n_rootdir)
9D004E24  14C00075   BNE A2, ZERO, 0x9D004FFC
9D004E28  2402000D   ADDIU V0, ZERO, 13
2068:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be 0) */
2069:                		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
9D004E2C  9204005F   LBU A0, 95(S0)
9D004E30  00042600   SLL A0, A0, 24
9D004E34  9202005E   LBU V0, 94(S0)
9D004E38  00021400   SLL V0, V0, 16
9D004E3C  00822025   OR A0, A0, V0
9D004E40  9202005C   LBU V0, 92(S0)
9D004E44  00822025   OR A0, A0, V0
9D004E48  9202005D   LBU V0, 93(S0)
9D004E4C  00021200   SLL V0, V0, 8
9D004E50  00821025   OR V0, A0, V0
9D004E54  AE020024   SW V0, 36(S0)
2070:                		szbfat = fs->n_fatent * 4; /* (Required FAT size) */
9D004E58  0B4013A5   J 0x9D004E94
9D004E5C  00052880   SLL A1, A1, 2
2071:                	} else {
2072:                		if (!fs->n_rootdir)
9D004E60  10C00066   BEQ A2, ZERO, 0x9D004FFC
9D004E64  2402000D   ADDIU V0, ZERO, 13
2073:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must not be 0) */
2074:                		fs->dirbase = fs->fatbase + fasize; /* Root directory start sector */
9D004E68  00882021   ADDU A0, A0, T0
2075:                		szbfat = (fmt == FS_FAT16) ? /* (Required FAT size) */
2076:                		fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
9D004E6C  24020002   ADDIU V0, ZERO, 2
9D004E70  16420003   BNE S2, V0, 0x9D004E80
9D004E74  AE040024   SW A0, 36(S0)
9D004E78  0B4013A5   J 0x9D004E94
9D004E7C  00052840   SLL A1, A1, 1
9D004E80  24020003   ADDIU V0, ZERO, 3
9D004E84  70A21002   MUL V0, A1, V0
9D004E88  00021042   SRL V0, V0, 1
9D004E8C  30A50001   ANDI A1, A1, 1
9D004E90  00452821   ADDU A1, V0, A1
2077:                	}
2078:                	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) /* (BPB_FATSz must not be less than required) */
9D004E94  24A501FF   ADDIU A1, A1, 511
9D004E98  00052A42   SRL A1, A1, 9
9D004E9C  0065182B   SLTU V1, V1, A1
9D004EA0  14600056   BNE V1, ZERO, 0x9D004FFC
9D004EA4  2402000D   ADDIU V0, ZERO, 13
2079:                		return FR_NO_FILESYSTEM;
2080:                
2081:                #if !_FS_READONLY
2082:                	/* Initialize cluster allocation information */
2083:                	fs->free_clust = 0xFFFFFFFF;
9D004EA8  2402FFFF   ADDIU V0, ZERO, -1
9D004EAC  AE020010   SW V0, 16(S0)
2084:                	fs->last_clust = 0;
2085:                
2086:                	/* Get fsinfo if available */
2087:                	if (fmt == FS_FAT32) {
9D004EB0  24020003   ADDIU V0, ZERO, 3
9D004EB4  16420048   BNE S2, V0, 0x9D004FD8
9D004EB8  AE00000C   SW ZERO, 12(S0)
2088:                		fs->fsi_flag = 0;
9D004EBC  A2000005   SB ZERO, 5(S0)
2089:                		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
9D004EC0  92060061   LBU A2, 97(S0)
9D004EC4  00063200   SLL A2, A2, 8
9D004EC8  92020060   LBU V0, 96(S0)
9D004ECC  00C23025   OR A2, A2, V0
9D004ED0  02263021   ADDU A2, S1, A2
9D004ED4  AE060014   SW A2, 20(S0)
2090:                		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK
9D004ED8  92040001   LBU A0, 1(S0)
9D004EDC  26050030   ADDIU A1, S0, 48
9D004EE0  0F40237E   JAL disk_read
9D004EE4  24070001   ADDIU A3, ZERO, 1
9D004EE8  5440003C   BNEL V0, ZERO, 0x9D004FDC
9D004EEC  A2120000   SB S2, 0(S0)
2091:                				&& LD_WORD(fs->win+BS_55AA) == 0xAA55
9D004EF0  9203022F   LBU V1, 559(S0)
9D004EF4  00031A00   SLL V1, V1, 8
9D004EF8  9202022E   LBU V0, 558(S0)
9D004EFC  00621825   OR V1, V1, V0
9D004F00  7C031E20   SEH V1, V1
9D004F04  2402AA55   ADDIU V0, ZERO, -21931
9D004F08  54620034   BNEL V1, V0, 0x9D004FDC
9D004F0C  A2120000   SB S2, 0(S0)
2092:                				&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
9D004F10  92030033   LBU V1, 51(S0)
9D004F14  00031E00   SLL V1, V1, 24
9D004F18  92020032   LBU V0, 50(S0)
9D004F1C  00021400   SLL V0, V0, 16
9D004F20  00621825   OR V1, V1, V0
9D004F24  92020030   LBU V0, 48(S0)
9D004F28  00621825   OR V1, V1, V0
9D004F2C  92020031   LBU V0, 49(S0)
9D004F30  00021200   SLL V0, V0, 8
9D004F34  00621825   OR V1, V1, V0
9D004F38  3C024161   LUI V0, 16737
9D004F3C  24425252   ADDIU V0, V0, 21074
9D004F40  54620026   BNEL V1, V0, 0x9D004FDC
9D004F44  A2120000   SB S2, 0(S0)
2093:                				&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
9D004F48  92030217   LBU V1, 535(S0)
9D004F4C  00031E00   SLL V1, V1, 24
9D004F50  92020216   LBU V0, 534(S0)
9D004F54  00021400   SLL V0, V0, 16
9D004F58  00621825   OR V1, V1, V0
9D004F5C  92020214   LBU V0, 532(S0)
9D004F60  00621825   OR V1, V1, V0
9D004F64  92020215   LBU V0, 533(S0)
9D004F68  00021200   SLL V0, V0, 8
9D004F6C  00621825   OR V1, V1, V0
9D004F70  3C026141   LUI V0, 24897
9D004F74  24427272   ADDIU V0, V0, 29298
9D004F78  54620018   BNEL V1, V0, 0x9D004FDC
9D004F7C  A2120000   SB S2, 0(S0)
2094:                			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
9D004F80  9203021F   LBU V1, 543(S0)
9D004F84  00031E00   SLL V1, V1, 24
9D004F88  9202021E   LBU V0, 542(S0)
9D004F8C  00021400   SLL V0, V0, 16
9D004F90  00621825   OR V1, V1, V0
9D004F94  9202021C   LBU V0, 540(S0)
9D004F98  00621825   OR V1, V1, V0
9D004F9C  9202021D   LBU V0, 541(S0)
9D004FA0  00021200   SLL V0, V0, 8
9D004FA4  00621025   OR V0, V1, V0
9D004FA8  AE02000C   SW V0, 12(S0)
2095:                			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
9D004FAC  9203021B   LBU V1, 539(S0)
9D004FB0  00031E00   SLL V1, V1, 24
9D004FB4  9202021A   LBU V0, 538(S0)
9D004FB8  00021400   SLL V0, V0, 16
9D004FBC  00621825   OR V1, V1, V0
9D004FC0  92020218   LBU V0, 536(S0)
9D004FC4  00621825   OR V1, V1, V0
9D004FC8  92020219   LBU V0, 537(S0)
9D004FCC  00021200   SLL V0, V0, 8
9D004FD0  00621025   OR V0, V1, V0
9D004FD4  AE020010   SW V0, 16(S0)
2096:                		}
2097:                	}
2098:                #endif
2099:                	fs->fs_type = fmt; /* FAT sub-type */
9D004FD8  A2120000   SB S2, 0(S0)
2100:                	fs->id = ++Fsid; /* File system mount ID */
9D004FDC  97828070   LHU V0, -32656(GP)
9D004FE0  24420001   ADDIU V0, V0, 1
9D004FE4  3042FFFF   ANDI V0, V0, -1
9D004FE8  A7828070   SH V0, -32656(GP)
9D004FEC  A6020006   SH V0, 6(S0)
2101:                	fs->winsect = 0; /* Invalidate sector cache */
9D004FF0  AE00002C   SW ZERO, 44(S0)
2102:                	fs->wflag = 0;
9D004FF4  A2000004   SB ZERO, 4(S0)
2103:                #if _FS_RPATH
2104:                	fs->cdir = 0; /* Current directory (root dir) */
2105:                #endif
2106:                #if _FS_SHARE				/* Clear file lock semaphores */
2107:                	clear_lock(fs);
2108:                #endif
2109:                
2110:                	return FR_OK;
9D004FF8  00001021   ADDU V0, ZERO, ZERO
2111:                }
9D004FFC  8FBF001C   LW RA, 28(SP)
9D005000  8FB20018   LW S2, 24(SP)
9D005004  8FB10014   LW S1, 20(SP)
9D005008  8FB00010   LW S0, 16(SP)
9D00500C  03E00008   JR RA
9D005010  27BD0020   ADDIU SP, SP, 32
2112:                
2113:                /*-----------------------------------------------------------------------*/
2114:                /* Check if the file/dir object is valid or not                          */
2115:                /*-----------------------------------------------------------------------*/
2116:                
2117:                static FRESULT validate( /* FR_OK(0): The object is valid, !=0: Invalid */
2118:                FATFS *fs, /* Pointer to the file system object */
2119:                PF_WORD id /* Member id of the target object to be checked */
2120:                ) {
9D003C48  27BDFFE8   ADDIU SP, SP, -24
9D003C4C  AFBF0014   SW RA, 20(SP)
2121:                	if (!fs || !fs->fs_type || fs->id != id)
9D003C50  1080000D   BEQ A0, ZERO, 0x9D003C88
9D003C54  24020009   ADDIU V0, ZERO, 9
9D003C58  90830000   LBU V1, 0(A0)
9D003C5C  1060000B   BEQ V1, ZERO, 0x9D003C8C
9D003C60  8FBF0014   LW RA, 20(SP)
9D003C64  94830006   LHU V1, 6(A0)
9D003C68  14650008   BNE V1, A1, 0x9D003C8C
9D003C6C  00000000   NOP
2122:                		return FR_INVALID_OBJECT;
2123:                
2124:                	ENTER_FF(fs); /* Lock file system */
2125:                
2126:                	if (disk_status(fs->drv) & STA_NOINIT)
9D003C70  0F402377   JAL disk_status
9D003C74  90840001   LBU A0, 1(A0)
9D003C78  30420001   ANDI V0, V0, 1
2127:                		return FR_NOT_READY;
9D003C7C  24030003   ADDIU V1, ZERO, 3
9D003C80  0002180A   MOVZ V1, ZERO, V0
9D003C84  00601021   ADDU V0, V1, ZERO
2128:                
2129:                	return FR_OK;
2130:                }
9D003C88  8FBF0014   LW RA, 20(SP)
9D003C8C  03E00008   JR RA
9D003C90  27BD0018   ADDIU SP, SP, 24
2131:                
2132:                /*--------------------------------------------------------------------------
2133:                
2134:                 Public Functions
2135:                
2136:                 --------------------------------------------------------------------------*/
2137:                
2138:                /*-----------------------------------------------------------------------*/
2139:                /* Mount/Unmount a Logical Drive                                         */
2140:                /*-----------------------------------------------------------------------*/
2141:                
2142:                FRESULT f_mount(PF_BYTE vol, /* Logical drive number to be mounted/unmounted */
2143:                                FATFS *fs /* Pointer to new file system object (NULL for unmount)*/
2144:                                ) {
9D005030  308400FF   ANDI A0, A0, 255
2145:                	FATFS *rfs;
2146:                
2147:                	if (vol >= _VOLUMES) {/* Check if the drive number is valid */
9D005034  14800008   BNE A0, ZERO, 0x9D005058
9D005038  2402000B   ADDIU V0, ZERO, 11
2148:                		return FR_INVALID_DRIVE;
2149:                	}
2150:                	rfs = FatFs[vol]; /* Get current fs object */
9D00503C  8F82806C   LW V0, -32660(GP)
2151:                
2152:                	if (rfs) {
9D005040  54400001   BNEL V0, ZERO, 0x9D005048
9D005044  A0400000   SB ZERO, 0(V0)
2153:                #if _FS_SHARE
2154:                		clear_lock(rfs);
2155:                #endif
2156:                #if _FS_REENTRANT				/* Discard sync object of the current volume */
2157:                		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2158:                #endif
2159:                		rfs->fs_type = 0; /* Clear old fs object */
2160:                	}
2161:                
2162:                	if (fs) {
9D005048  54A00001   BNEL A1, ZERO, 0x9D005050
9D00504C  A0A00000   SB ZERO, 0(A1)
2163:                		fs->fs_type = 0; /* Clear new fs object */
2164:                #if _FS_REENTRANT				/* Create sync object for the new volume */
2165:                		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2166:                #endif
2167:                	}
2168:                	FatFs[vol] = fs; /* Register new fs object */
9D005050  AF85806C   SW A1, -32660(GP)
2169:                
2170:                	return FR_OK;
9D005054  00001021   ADDU V0, ZERO, ZERO
2171:                }
9D005058  03E00008   JR RA
9D00505C  00000000   NOP
2172:                
2173:                /*-----------------------------------------------------------------------*/
2174:                /* Open or Create a File                                                 */
2175:                /*-----------------------------------------------------------------------*/
2176:                
2177:                FRESULT f_open(FIL *fp, /* Pointer to the blank file object */
2178:                                const TCHAR *path, /* Pointer to the file name */
2179:                                PF_BYTE mode /* Access mode and file open mode flags */
2180:                                ) {
9D005060  27BDFFB0   ADDIU SP, SP, -80
9D005064  AFBF004C   SW RA, 76(SP)
9D005068  AFB40048   SW S4, 72(SP)
9D00506C  AFB30044   SW S3, 68(SP)
9D005070  AFB20040   SW S2, 64(SP)
9D005074  AFB1003C   SW S1, 60(SP)
9D005078  AFB00038   SW S0, 56(SP)
9D00507C  00808821   ADDU S1, A0, ZERO
9D005080  AFA50054   SW A1, 84(SP)
2181:                	FRESULT res;
2182:                	DIR dj;
2183:                	PF_BYTE *dir;
2184:                	DEF_NAMEBUF;
2185:                
2186:                	fp->fs = 0; /* Clear file object */
9D005084  AC800000   SW ZERO, 0(A0)
2187:                
2188:                #if !_FS_READONLY
2189:                	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS
9D005088  30D2001F   ANDI S2, A2, 31
2190:                			| FA_CREATE_NEW;
2191:                	res = chk_mounted(&path, &dj.fs, (PF_BYTE) (mode & ~FA_READ));
9D00508C  02409821   ADDU S3, S2, ZERO
9D005090  27A40054   ADDIU A0, SP, 84
9D005094  27A50010   ADDIU A1, SP, 16
9D005098  0F4012DA   JAL chk_mounted
9D00509C  3246001E   ANDI A2, S2, 30
2192:                #else
2193:                	mode &= FA_READ;
2194:                	res = chk_mounted(&path, &dj.fs, 0);
2195:                #endif
2196:                	INIT_BUF(dj);
9D0050A0  27A3002C   ADDIU V1, SP, 44
2197:                	if (res == FR_OK)
9D0050A4  14400086   BNE V0, ZERO, 0x9D0052C0
9D0050A8  AFA30028   SW V1, 40(SP)
2198:                		res = follow_path(&dj, path); /* Follow the file path */
9D0050AC  27A40010   ADDIU A0, SP, 16
9D0050B0  0F401153   JAL 0x9D00454C
9D0050B4  8FA50054   LW A1, 84(SP)
2199:                	dir = dj.dir;
9D0052C0  0B401432   J 0x9D0050C8
9D0052C4  8FB00024   LW S0, 36(SP)
2200:                
2201:                #if !_FS_READONLY	/* R/W configuration */
2202:                	if (res == FR_OK) {
9D0050B8  14400003   BNE V0, ZERO, 0x9D0050C8
9D0050BC  8FB00024   LW S0, 36(SP)
2203:                		if (!dir) /* Current dir itself */
2204:                			res = FR_INVALID_NAME;
9D0050C0  24030006   ADDIU V1, ZERO, 6
9D0050C4  0070100A   MOVZ V0, V1, S0
2205:                #if _FS_SHARE
2206:                		else
2207:                		res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2208:                #endif
2209:                	}
2210:                	/* Create or Open a file */
2211:                	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
9D0050C8  3263001C   ANDI V1, S3, 28
9D0050CC  10600044   BEQ V1, ZERO, 0x9D0051E0
9D0050D0  00000000   NOP
2212:                		DWORD dw, cl;
2213:                
2214:                		if (res != FR_OK) { /* No file, create new */
9D0050D4  5040000B   BEQL V0, ZERO, 0x9D005104
9D0050D8  9203000B   LBU V1, 11(S0)
2215:                			if (res == FR_NO_FILE) /* There is no file to open, create a new entry */
9D0050DC  24030004   ADDIU V1, ZERO, 4
9D0050E0  14430070   BNE V0, V1, 0x9D0052A4
9D0050E4  8FBF004C   LW RA, 76(SP)
2216:                #if _FS_SHARE
2217:                				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
2218:                #else
2219:                				res = dir_register(&dj);
9D0050E8  0F401241   JAL 0x9D004904
9D0050EC  27A40010   ADDIU A0, SP, 16
2220:                #endif
2221:                			mode |= FA_CREATE_ALWAYS; /* File is created */
2222:                			dir = dj.dir; /* New entry */
9D0050F0  8FB00024   LW S0, 36(SP)
2223:                		} else { /* Any object is already existing */
2224:                			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) { /* Cannot overwrite it (R/O or DIR) */
9D005104  30630011   ANDI V1, V1, 17
9D005108  14600065   BNE V1, ZERO, 0x9D0052A0
9D00510C  24020007   ADDIU V0, ZERO, 7
2225:                				res = FR_DENIED;
2226:                			} else {
2227:                				if (mode & FA_CREATE_NEW) /* Cannot create as new file */
9D005110  32730004   ANDI S3, S3, 4
9D005114  16600062   BNE S3, ZERO, 0x9D0052A0
9D005118  24020008   ADDIU V0, ZERO, 8
2228:                					res = FR_EXIST;
2229:                			}
2230:                		}
2231:                		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) { /* Truncate it if overwrite mode */
9D0050F4  10400009   BEQ V0, ZERO, 0x9D00511C
9D0050F8  36520008   ORI S2, S2, 8
9D00511C  32420008   ANDI V0, S2, 8
9D005120  1040003F   BEQ V0, ZERO, 0x9D005220
9D005124  8FA30010   LW V1, 16(SP)
2232:                			dw = get_fattime(); /* Created time */
9D005128  0F4024D9   JAL get_fattime
9D00512C  00000000   NOP
2233:                			ST_DWORD(dir+DIR_CrtTime, dw);
9D005130  A202000E   SB V0, 14(S0)
9D005134  7C433A00   EXT V1, V0, 8, 8
9D005138  A203000F   SB V1, 15(S0)
9D00513C  00021C02   SRL V1, V0, 16
9D005140  A2030010   SB V1, 16(S0)
9D005144  00021602   SRL V0, V0, 24
9D005148  A2020011   SB V0, 17(S0)
2234:                			dir[DIR_Attr] = 0; /* Reset attribute */
9D00514C  A200000B   SB ZERO, 11(S0)
2235:                			ST_DWORD(dir+DIR_FileSize, 0); /* size = 0 */
9D005150  A200001C   SB ZERO, 28(S0)
9D005154  A200001D   SB ZERO, 29(S0)
9D005158  A200001E   SB ZERO, 30(S0)
9D00515C  A200001F   SB ZERO, 31(S0)
2236:                			cl = LD_CLUST(dir); /* Get start cluster */
9D005160  92020015   LBU V0, 21(S0)
9D005164  00021200   SLL V0, V0, 8
9D005168  92030014   LBU V1, 20(S0)
9D00516C  00431025   OR V0, V0, V1
9D005170  00021400   SLL V0, V0, 16
9D005174  9213001B   LBU S3, 27(S0)
9D005178  00139A00   SLL S3, S3, 8
9D00517C  9203001A   LBU V1, 26(S0)
9D005180  02639825   OR S3, S3, V1
9D005184  00539825   OR S3, V0, S3
2237:                			ST_CLUST(dir, 0); /* cluster = 0 */
9D005188  A200001A   SB ZERO, 26(S0)
9D00518C  A200001B   SB ZERO, 27(S0)
9D005190  A2000014   SB ZERO, 20(S0)
9D005194  A2000015   SB ZERO, 21(S0)
2238:                			dj.fs->wflag = 1;
9D005198  8FA40010   LW A0, 16(SP)
9D00519C  24020001   ADDIU V0, ZERO, 1
2239:                			if (cl) { /* Remove the cluster chain if exist */
9D0051A0  12600049   BEQ S3, ZERO, 0x9D0052C8
9D0051A4  A0820004   SB V0, 4(A0)
2240:                				dw = dj.fs->winsect;
9D0051A8  8C94002C   LW S4, 44(A0)
2241:                				res = remove_chain(dj.fs, cl);
9D0051AC  0F4012A0   JAL 0x9D004A80
9D0051B0  02602821   ADDU A1, S3, ZERO
2242:                				if (res == FR_OK) {
9D0051B4  1440003B   BNE V0, ZERO, 0x9D0052A4
9D0051B8  8FBF004C   LW RA, 76(SP)
2243:                					dj.fs->last_clust = cl - 1; /* Reuse the cluster hole */
9D0051BC  8FA40010   LW A0, 16(SP)
9D0051C0  2673FFFF   ADDIU S3, S3, -1
9D0051C4  AC93000C   SW S3, 12(A0)
2244:                					res = move_window(dj.fs, dw);
9D0051C8  0F400E51   JAL 0x9D003944
9D0051CC  02802821   ADDU A1, S4, ZERO
2245:                				}
2246:                			}
2247:                		}
2248:                	} else { /* Open an existing file */
2249:                		if (res == FR_OK) { /* Follow succeeded */
9D0051E0  14400030   BNE V0, ZERO, 0x9D0052A4
9D0051E4  8FBF004C   LW RA, 76(SP)
2250:                			if (dir[DIR_Attr] & AM_DIR) { /* It is a directory */
9D0051E8  9203000B   LBU V1, 11(S0)
9D0051EC  30640010   ANDI A0, V1, 16
9D0051F0  1480002B   BNE A0, ZERO, 0x9D0052A0
9D0051F4  24020004   ADDIU V0, ZERO, 4
2251:                				res = FR_NO_FILE;
2252:                			} else {
2253:                				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
9D0051F8  32730002   ANDI S3, S3, 2
9D0051FC  12600033   BEQ S3, ZERO, 0x9D0052CC
9D005200  32420008   ANDI V0, S2, 8
9D005204  30630001   ANDI V1, V1, 1
9D005208  14600025   BNE V1, ZERO, 0x9D0052A0
9D00520C  24020007   ADDIU V0, ZERO, 7
2254:                					res = FR_DENIED;
2255:                			}
2256:                		}
2257:                	}
2258:                	if (res == FR_OK) {
9D0051D0  10400012   BEQ V0, ZERO, 0x9D00521C
9D0051D4  36520020   ORI S2, S2, 32
2259:                		if (mode & FA_CREATE_ALWAYS) /* Set file change flag if created or overwritten */
9D005210  0B4014B3   J 0x9D0052CC
9D005214  32420008   ANDI V0, S2, 8
9D0052C8  32420008   ANDI V0, S2, 8
9D0052CC  1040FFD4   BEQ V0, ZERO, 0x9D005220
9D0052D0  8FA30010   LW V1, 16(SP)
9D0052D4  0B401486   J 0x9D005218
9D0052D8  00001021   ADDU V0, ZERO, ZERO
2260:                			mode |= FA__WRITTEN;
9D005218  36520020   ORI S2, S2, 32
2261:                		fp->dir_sect = dj.fs->winsect; /* Pointer to the directory entry */
9D00521C  8FA30010   LW V1, 16(SP)
9D005220  8C64002C   LW A0, 44(V1)
9D005224  AE24001C   SW A0, 28(S1)
2262:                		fp->dir_ptr = dir;
9D005228  AE300020   SW S0, 32(S1)
2263:                #if _FS_SHARE
2264:                		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2265:                		if (!fp->lockid) res = FR_INT_ERR;
2266:                #endif
2267:                	}
2268:                
2269:                #else				/* R/O configuration */
2270:                	if (res == FR_OK) { /* Follow succeeded */
2271:                		if (!dir) { /* Current dir itself */
2272:                			res = FR_INVALID_NAME;
2273:                		} else {
2274:                			if (dir[DIR_Attr] & AM_DIR) /* It is a directory */
2275:                			res = FR_NO_FILE;
2276:                		}
2277:                	}
2278:                #endif
2279:                	FREE_BUF();
2280:                
2281:                	if (res == FR_OK) {
2282:                		fp->flag = mode; /* File access mode */
9D00522C  A2320006   SB S2, 6(S1)
2283:                		fp->sclust = LD_CLUST(dir); /* File start cluster */
9D005230  92050015   LBU A1, 21(S0)
9D005234  00052A00   SLL A1, A1, 8
9D005238  92060014   LBU A2, 20(S0)
9D00523C  00A62825   OR A1, A1, A2
9D005240  00052C00   SLL A1, A1, 16
9D005244  9204001B   LBU A0, 27(S0)
9D005248  00042200   SLL A0, A0, 8
9D00524C  9206001A   LBU A2, 26(S0)
9D005250  00862025   OR A0, A0, A2
9D005254  00A42025   OR A0, A1, A0
9D005258  AE240010   SW A0, 16(S1)
2284:                		fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
9D00525C  9205001F   LBU A1, 31(S0)
9D005260  00052E00   SLL A1, A1, 24
9D005264  9204001E   LBU A0, 30(S0)
9D005268  00042400   SLL A0, A0, 16
9D00526C  00A42025   OR A0, A1, A0
9D005270  9205001C   LBU A1, 28(S0)
9D005274  00852025   OR A0, A0, A1
9D005278  9205001D   LBU A1, 29(S0)
9D00527C  00052A00   SLL A1, A1, 8
9D005280  00852025   OR A0, A0, A1
9D005284  AE24000C   SW A0, 12(S1)
2285:                		fp->fptr = 0; /* File pointer */
9D005288  AE200008   SW ZERO, 8(S1)
2286:                		fp->dsect = 0;
9D00528C  AE200018   SW ZERO, 24(S1)
2287:                #if _USE_FASTSEEK
2288:                		fp->cltbl = 0; /* Normal seek mode */
9D005290  AE200024   SW ZERO, 36(S1)
2289:                #endif
2290:                		fp->fs = dj.fs;
9D005294  AE230000   SW V1, 0(S1)
2291:                		fp->id = dj.fs->id; /* Validate file object */
9D005298  94630006   LHU V1, 6(V1)
9D00529C  A6230004   SH V1, 4(S1)
2292:                	}
2293:                
2294:                	LEAVE_FF(dj.fs, res);
2295:                }
9D0050FC  0B4014A9   J 0x9D0052A4
9D005100  8FBF004C   LW RA, 76(SP)
9D0051D8  0B4014A9   J 0x9D0052A4
9D0051DC  8FBF004C   LW RA, 76(SP)
9D0052A0  8FBF004C   LW RA, 76(SP)
9D0052A4  8FB40048   LW S4, 72(SP)
9D0052A8  8FB30044   LW S3, 68(SP)
9D0052AC  8FB20040   LW S2, 64(SP)
9D0052B0  8FB1003C   LW S1, 60(SP)
9D0052B4  8FB00038   LW S0, 56(SP)
9D0052B8  03E00008   JR RA
9D0052BC  27BD0050   ADDIU SP, SP, 80
2296:                
2297:                /*-----------------------------------------------------------------------*/
2298:                /* Read File                                                             */
2299:                /*-----------------------------------------------------------------------*/
2300:                
2301:                FRESULT f_read(FIL *fp, /* Pointer to the file object */
2302:                                void *buff, /* Pointer to data buffer */
2303:                                UINT btr, /* Number of bytes to read */
2304:                                UINT *br /* Pointer to number of bytes read */
2305:                                ) {
9D0052DC  27BDFFC8   ADDIU SP, SP, -56
9D0052E0  AFBF0034   SW RA, 52(SP)
9D0052E4  AFBE0030   SW S8, 48(SP)
9D0052E8  AFB7002C   SW S7, 44(SP)
9D0052EC  AFB60028   SW S6, 40(SP)
9D0052F0  AFB50024   SW S5, 36(SP)
9D0052F4  AFB40020   SW S4, 32(SP)
9D0052F8  AFB3001C   SW S3, 28(SP)
9D0052FC  AFB20018   SW S2, 24(SP)
9D005300  AFB10014   SW S1, 20(SP)
9D005304  AFB00010   SW S0, 16(SP)
9D005308  00808021   ADDU S0, A0, ZERO
9D00530C  00A0A021   ADDU S4, A1, ZERO
9D005310  00C08821   ADDU S1, A2, ZERO
9D005314  00E09821   ADDU S3, A3, ZERO
2306:                	FRESULT res;
2307:                	DWORD clst, sect, remain;
2308:                	UINT rcnt, cc;
2309:                	PF_BYTE csect, *rbuff = buff;
2310:                
2311:                	*br = 0; /* Initialize byte counter */
9D005318  ACE00000   SW ZERO, 0(A3)
2312:                
2313:                	res = validate(fp->fs, fp->id); /* Check validity */
9D00531C  8C840000   LW A0, 0(A0)
9D005320  0F400F12   JAL 0x9D003C48
9D005324  96050004   LHU A1, 4(S0)
2314:                	if (res != FR_OK)
9D005328  1440008A   BNE V0, ZERO, 0x9D005554
9D00532C  0040B821   ADDU S7, V0, ZERO
2315:                		LEAVE_FF(fp->fs, res);
2316:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D005330  92020006   LBU V0, 6(S0)
9D005334  7C021C20   SEB V1, V0
9D005338  04600085   BLTZ V1, 0x9D005550
9D00533C  30420001   ANDI V0, V0, 1
2317:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2318:                	if (!(fp->flag & FA_READ)) /* Check access mode */
9D005340  50400084   BEQL V0, ZERO, 0x9D005554
9D005344  24170007   ADDIU S7, ZERO, 7
9D005354  0251102B   SLTU V0, S2, S1
9D005358  0222900A   MOVZ S2, S1, V0
2319:                		LEAVE_FF(fp->fs, FR_DENIED);
2320:                	remain = fp->fsize - fp->fptr;
9D005348  8E12000C   LW S2, 12(S0)
9D00534C  8E020008   LW V0, 8(S0)
9D005350  02429023   SUBU S2, S2, V0
2321:                	if (btr > remain)
2322:                		btr = (UINT) remain; /* Truncate btr by remaining bytes */
2323:                
2324:                	for (; btr; /* Repeat until all data read */
9D00535C  1240007E   BEQ S2, ZERO, 0x9D005558
9D005360  02E01021   ADDU V0, S7, ZERO
9D005540  12400004   BEQ S2, ZERO, 0x9D005554
9D005544  AE620000   SW V0, 0(S3)
2325:                	rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
9D005528  8E020008   LW V0, 8(S0)
9D00552C  00511021   ADDU V0, V0, S1
9D005530  AE020008   SW V0, 8(S0)
9D005534  8E620000   LW V0, 0(S3)
9D005538  00511021   ADDU V0, V0, S1
9D00553C  02519023   SUBU S2, S2, S1
9D005548  0B4014D9   J 0x9D005364
9D00554C  0291A021   ADDU S4, S4, S1
9D005550  24170002   ADDIU S7, ZERO, 2
2326:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D005364  8E050008   LW A1, 8(S0)
9D005368  30A201FF   ANDI V0, A1, 511
9D00536C  54400057   BNEL V0, ZERO, 0x9D0054CC
9D005370  8E110008   LW S1, 8(S0)
2327:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D005374  8E040000   LW A0, 0(S0)
9D005378  00051242   SRL V0, A1, 9
9D00537C  90950002   LBU S5, 2(A0)
9D005380  26B5FFFF   ADDIU S5, S5, -1
9D005384  0055A824   AND S5, V0, S5
9D005388  32B500FF   ANDI S5, S5, 255
2328:                			if (!csect) { /* On the cluster boundary? */
9D00538C  56A0001F   BNEL S5, ZERO, 0x9D00540C
9D005390  8E160000   LW S6, 0(S0)
2329:                				if (fp->fptr == 0) { /* On the top of the file? */
9D005394  54A00003   BNEL A1, ZERO, 0x9D0053A4
9D005398  8E020024   LW V0, 36(S0)
2330:                					clst = fp->sclust; /* Follow from the origin */
9D00539C  0B4014F1   J 0x9D0053C4
9D0053A0  8E020010   LW V0, 16(S0)
2331:                				} else { /* Middle or end of the file */
2332:                #if _USE_FASTSEEK
2333:                					if (fp->cltbl)
9D0053A4  10400005   BEQ V0, ZERO, 0x9D0053BC
9D0053A8  00000000   NOP
2334:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D0053AC  0F400DEA   JAL 0x9D0037A8
9D0053B0  02002021   ADDU A0, S0, ZERO
2335:                					else
2336:                #endif
2337:                						clst = get_fat(fp->fs, fp->clust); /* Follow cluster chain on the FAT */
9D0053BC  0F400F31   JAL get_fat
9D0053C0  8E050014   LW A1, 20(S0)
2338:                				}
2339:                				if (clst < 2)
9D0053B4  0B4014F2   J 0x9D0053C8
9D0053B8  2C430002   SLTIU V1, V0, 2
9D0053C4  2C430002   SLTIU V1, V0, 2
9D0053C8  10600007   BEQ V1, ZERO, 0x9D0053E8
9D0053CC  2403FFFF   ADDIU V1, ZERO, -1
2340:                					ABORT(fp->fs, FR_INT_ERR);
9D0053D0  92030006   LBU V1, 6(S0)
9D0053D4  2402FF80   ADDIU V0, ZERO, -128
9D0053D8  00621025   OR V0, V1, V0
9D0053DC  A2020006   SB V0, 6(S0)
9D0053E0  0B401555   J 0x9D005554
9D0053E4  24170002   ADDIU S7, ZERO, 2
2341:                				if (clst == 0xFFFFFFFF)
9D0053E8  54430007   BNEL V0, V1, 0x9D005408
9D0053EC  AE020014   SW V0, 20(S0)
2342:                					ABORT(fp->fs, FR_DISK_ERR);
9D0053F0  92030006   LBU V1, 6(S0)
9D0053F4  2402FF80   ADDIU V0, ZERO, -128
9D0053F8  00621025   OR V0, V1, V0
9D0053FC  A2020006   SB V0, 6(S0)
9D005400  0B401555   J 0x9D005554
9D005404  24170001   ADDIU S7, ZERO, 1
2343:                				fp->clust = clst; /* Update current cluster */
2344:                			}
2345:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D005408  8E160000   LW S6, 0(S0)
9D00540C  02C02021   ADDU A0, S6, ZERO
9D005410  0F400F25   JAL clust2sect
9D005414  8E050014   LW A1, 20(S0)
2346:                			if (!sect)
9D005418  14400007   BNE V0, ZERO, 0x9D005438
9D00541C  00128A42   SRL S1, S2, 9
2347:                				ABORT(fp->fs, FR_INT_ERR);
9D005420  92030006   LBU V1, 6(S0)
9D005424  2402FF80   ADDIU V0, ZERO, -128
9D005428  00621025   OR V0, V1, V0
9D00542C  A2020006   SB V0, 6(S0)
9D005430  0B401555   J 0x9D005554
9D005434  24170002   ADDIU S7, ZERO, 2
2348:                			sect += csect;
2349:                			cc = btr / SS(fp->fs); /* When remaining bytes >= sector size, */
2350:                			if (cc) { /* Read maximum contiguous sectors directly */
9D005438  12200022   BEQ S1, ZERO, 0x9D0054C4
9D00543C  0055F021   ADDU S8, V0, S5
2351:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D005440  92C20002   LBU V0, 2(S6)
9D005444  02351821   ADDU V1, S1, S5
9D005448  0043182B   SLTU V1, V0, V1
2352:                					cc = fp->fs->csize - csect;
9D00544C  0055A823   SUBU S5, V0, S5
9D005450  02A3880B   MOVN S1, S5, V1
2353:                				if (disk_read(fp->fs->drv, rbuff, sect, (PF_BYTE) cc) != RES_OK)
9D005454  92C40001   LBU A0, 1(S6)
9D005458  02802821   ADDU A1, S4, ZERO
9D00545C  03C03021   ADDU A2, S8, ZERO
9D005460  0F40237E   JAL disk_read
9D005464  322700FF   ANDI A3, S1, 255
9D005468  50400007   BEQL V0, ZERO, 0x9D005488
9D00546C  8E050000   LW A1, 0(S0)
2354:                					ABORT(fp->fs, FR_DISK_ERR);
9D005470  92030006   LBU V1, 6(S0)
9D005474  2402FF80   ADDIU V0, ZERO, -128
9D005478  00621025   OR V0, V1, V0
9D00547C  A2020006   SB V0, 6(S0)
9D005480  0B401555   J 0x9D005554
9D005484  24170001   ADDIU S7, ZERO, 1
2355:                #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
2356:                #if _FS_TINY
2357:                				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
9D005488  90A20004   LBU V0, 4(A1)
9D00548C  50400026   BEQL V0, ZERO, 0x9D005528
9D005490  00118A40   SLL S1, S1, 9
9D005494  8CA2002C   LW V0, 44(A1)
9D005498  005EF023   SUBU S8, V0, S8
9D00549C  03D1102B   SLTU V0, S8, S1
9D0054A0  50400021   BEQL V0, ZERO, 0x9D005528
9D0054A4  00118A40   SLL S1, S1, 9
2358:                				mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
9D0054A8  001EF240   SLL S8, S8, 9
9D0054AC  029E2021   ADDU A0, S4, S8
9D0054B0  24A50030   ADDIU A1, A1, 48
9D0054B4  0F400DD7   JAL 0x9D00375C
9D0054B8  24060200   ADDIU A2, ZERO, 512
2359:                #else
2360:                				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
2361:                					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf,
2362:                							SS(fp->fs));
2363:                #endif
2364:                #endif
2365:                				rcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2366:                				continue;
9D0054BC  0B40154A   J 0x9D005528
9D0054C0  00118A40   SLL S1, S1, 9
2367:                			}
2368:                #if !_FS_TINY
2369:                			if (fp->dsect != sect) { /* Load data sector if not in cache */
2370:                #if !_FS_READONLY
2371:                				if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2372:                					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2373:                							!= RES_OK)
2374:                						ABORT(fp->fs, FR_DISK_ERR);
2375:                					fp->flag &= ~FA__DIRTY;
2376:                				}
2377:                #endif
2378:                				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK) /* Fill sector cache */
2379:                					ABORT(fp->fs, FR_DISK_ERR);
2380:                			}
2381:                #endif
2382:                			fp->dsect = sect;
9D0054C4  AE1E0018   SW S8, 24(S0)
2383:                		}
2384:                		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs)); /* Get partial sector data from sector buffer */
9D0054C8  8E110008   LW S1, 8(S0)
9D0054F8  24020200   ADDIU V0, ZERO, 512
9D0054FC  00518823   SUBU S1, V0, S1
9D005500  0232102B   SLTU V0, S1, S2
9D005504  0242880A   MOVZ S1, S2, V0
2385:                		if (rcnt > btr)
2386:                			rcnt = btr;
2387:                #if _FS_TINY
2388:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D0054CC  8E040000   LW A0, 0(S0)
9D0054D0  0F400E51   JAL 0x9D003944
9D0054D4  8E050018   LW A1, 24(S0)
9D0054D8  10400007   BEQ V0, ZERO, 0x9D0054F8
9D0054DC  323101FF   ANDI S1, S1, 511
2389:                		ABORT(fp->fs, FR_DISK_ERR);
9D0054E0  92030006   LBU V1, 6(S0)
9D0054E4  2402FF80   ADDIU V0, ZERO, -128
9D0054E8  00621025   OR V0, V1, V0
9D0054EC  A2020006   SB V0, 6(S0)
9D0054F0  0B401555   J 0x9D005554
9D0054F4  24170001   ADDIU S7, ZERO, 1
2390:                		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
9D005508  8E050000   LW A1, 0(S0)
9D00550C  24A50030   ADDIU A1, A1, 48
9D005510  8E020008   LW V0, 8(S0)
9D005514  304201FF   ANDI V0, V0, 511
9D005518  02802021   ADDU A0, S4, ZERO
9D00551C  00A22821   ADDU A1, A1, V0
9D005520  0F400DD7   JAL 0x9D00375C
9D005524  02203021   ADDU A2, S1, ZERO
2391:                #else
2392:                		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
2393:                #endif
2394:                	}
2395:                
2396:                	LEAVE_FF(fp->fs, FR_OK);
2397:                }
9D005554  02E01021   ADDU V0, S7, ZERO
9D005558  8FBF0034   LW RA, 52(SP)
9D00555C  8FBE0030   LW S8, 48(SP)
9D005560  8FB7002C   LW S7, 44(SP)
9D005564  8FB60028   LW S6, 40(SP)
9D005568  8FB50024   LW S5, 36(SP)
9D00556C  8FB40020   LW S4, 32(SP)
9D005570  8FB3001C   LW S3, 28(SP)
9D005574  8FB20018   LW S2, 24(SP)
9D005578  8FB10014   LW S1, 20(SP)
9D00557C  8FB00010   LW S0, 16(SP)
9D005580  03E00008   JR RA
9D005584  27BD0038   ADDIU SP, SP, 56
2398:                
2399:                #if !_FS_READONLY
2400:                /*-----------------------------------------------------------------------*/
2401:                /* Write File                                                            */
2402:                /*-----------------------------------------------------------------------*/
2403:                
2404:                FRESULT f_write(FIL *fp, /* Pointer to the file object */
2405:                                const void *buff, /* Pointer to the data to be written */
2406:                                UINT btw, /* Number of bytes to write */
2407:                                UINT *bw /* Pointer to number of bytes written */
2408:                                ) {
9D005588  27BDFFC8   ADDIU SP, SP, -56
9D00558C  AFBF0034   SW RA, 52(SP)
9D005590  AFBE0030   SW S8, 48(SP)
9D005594  AFB7002C   SW S7, 44(SP)
9D005598  AFB60028   SW S6, 40(SP)
9D00559C  AFB50024   SW S5, 36(SP)
9D0055A0  AFB40020   SW S4, 32(SP)
9D0055A4  AFB3001C   SW S3, 28(SP)
9D0055A8  AFB20018   SW S2, 24(SP)
9D0055AC  AFB10014   SW S1, 20(SP)
9D0055B0  AFB00010   SW S0, 16(SP)
9D0055B4  00808021   ADDU S0, A0, ZERO
9D0055B8  00A0A021   ADDU S4, A1, ZERO
9D0055BC  00C08821   ADDU S1, A2, ZERO
9D0055C0  00E09821   ADDU S3, A3, ZERO
2409:                	FRESULT res;
2410:                	DWORD clst, sect;
2411:                	UINT wcnt, cc;
2412:                	const PF_BYTE *wbuff = buff;
2413:                	PF_BYTE csect;
2414:                
2415:                	*bw = 0; /* Initialize byte counter */
9D0055C4  ACE00000   SW ZERO, 0(A3)
2416:                
2417:                	res = validate(fp->fs, fp->id); /* Check validity */
9D0055C8  8C840000   LW A0, 0(A0)
9D0055CC  0F400F12   JAL 0x9D003C48
9D0055D0  96050004   LHU A1, 4(S0)
2418:                	if (res != FR_OK)
9D0055D4  144000BA   BNE V0, ZERO, 0x9D0058C0
9D0055D8  0040B821   ADDU S7, V0, ZERO
2419:                		LEAVE_FF(fp->fs, res);
2420:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D0055DC  92020006   LBU V0, 6(S0)
9D0055E0  7C021C20   SEB V1, V0
9D0055E4  046000B5   BLTZ V1, 0x9D0058BC
9D0055E8  30420002   ANDI V0, V0, 2
2421:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2422:                	if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D0055EC  504000B4   BEQL V0, ZERO, 0x9D0058C0
9D0055F0  24170007   ADDIU S7, ZERO, 7
2423:                		LEAVE_FF(fp->fs, FR_DENIED);
2424:                	if ((DWORD) (fp->fsize + btw) < fp->fsize)
9D0055F4  8E02000C   LW V0, 12(S0)
9D0055F8  02221821   ADDU V1, S1, V0
9D0055FC  0062102B   SLTU V0, V1, V0
9D005600  544000A6   BNEL V0, ZERO, 0x9D00589C
9D005604  8E020008   LW V0, 8(S0)
2425:                		btw = 0; /* File size cannot reach 4GB */
2426:                
2427:                	for (; btw; /* Repeat until all data written */
9D005608  522000A4   BEQL S1, ZERO, 0x9D00589C
9D00560C  8E020008   LW V0, 8(S0)
9D005888  12200003   BEQ S1, ZERO, 0x9D005898
9D00588C  AE620000   SW V0, 0(S3)
2428:                	wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
9D005870  8E020008   LW V0, 8(S0)
9D005874  00521021   ADDU V0, V0, S2
9D005878  AE020008   SW V0, 8(S0)
9D00587C  8E620000   LW V0, 0(S3)
9D005880  00521021   ADDU V0, V0, S2
9D005884  02328823   SUBU S1, S1, S2
9D005890  0B401584   J 0x9D005610
9D005894  0292A021   ADDU S4, S4, S2
2429:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D005610  8E050008   LW A1, 8(S0)
9D005614  30A201FF   ANDI V0, A1, 511
9D005618  5440007B   BNEL V0, ZERO, 0x9D005808
9D00561C  8E120008   LW S2, 8(S0)
2430:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D005620  8E040000   LW A0, 0(S0)
9D005624  00051242   SRL V0, A1, 9
9D005628  90950002   LBU S5, 2(A0)
9D00562C  26B5FFFF   ADDIU S5, S5, -1
9D005630  0055A824   AND S5, V0, S5
9D005634  32B500FF   ANDI S5, S5, 255
2431:                			if (!csect) { /* On the cluster boundary? */
9D005638  56A00026   BNEL S5, ZERO, 0x9D0056D4
9D00563C  8C83002C   LW V1, 44(A0)
2432:                				if (fp->fptr == 0) { /* On the top of the file? */
9D005640  54A00008   BNEL A1, ZERO, 0x9D005664
9D005644  8E020024   LW V0, 36(S0)
2433:                					clst = fp->sclust; /* Follow from the origin */
9D005648  8E020010   LW V0, 16(S0)
2434:                					if (clst == 0) /* When no cluster is allocated, */
9D00564C  1440000F   BNE V0, ZERO, 0x9D00568C
9D005650  24030001   ADDIU V1, ZERO, 1
2435:                						fp->sclust = clst = create_chain(fp->fs, 0); /* Create a new cluster chain */
9D005654  0F401070   JAL 0x9D0041C0
9D005658  00000000   NOP
9D00565C  0B4015A1   J 0x9D005684
9D005660  AE020010   SW V0, 16(S0)
2436:                				} else { /* Middle or end of the file */
2437:                #if _USE_FASTSEEK
2438:                					if (fp->cltbl)
9D005664  10400005   BEQ V0, ZERO, 0x9D00567C
9D005668  00000000   NOP
2439:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D00566C  0F400DEA   JAL 0x9D0037A8
9D005670  02002021   ADDU A0, S0, ZERO
9D005674  0B4015A1   J 0x9D005684
9D005678  00000000   NOP
2440:                					else
2441:                #endif
2442:                						clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
9D00567C  0F401070   JAL 0x9D0041C0
9D005680  8E050014   LW A1, 20(S0)
2443:                				}
2444:                				if (clst == 0)
9D005684  10400084   BEQ V0, ZERO, 0x9D005898
9D005688  24030001   ADDIU V1, ZERO, 1
2445:                					break; /* Could not allocate a new cluster (disk full) */
2446:                				if (clst == 1)
9D00568C  14430007   BNE V0, V1, 0x9D0056AC
9D005690  2403FFFF   ADDIU V1, ZERO, -1
2447:                					ABORT(fp->fs, FR_INT_ERR);
9D005694  92030006   LBU V1, 6(S0)
9D005698  2402FF80   ADDIU V0, ZERO, -128
9D00569C  00621025   OR V0, V1, V0
9D0056A0  A2020006   SB V0, 6(S0)
9D0056A4  0B401630   J 0x9D0058C0
9D0056A8  24170002   ADDIU S7, ZERO, 2
2448:                				if (clst == 0xFFFFFFFF)
9D0056AC  54430007   BNEL V0, V1, 0x9D0056CC
9D0056B0  AE020014   SW V0, 20(S0)
2449:                					ABORT(fp->fs, FR_DISK_ERR);
9D0056B4  92030006   LBU V1, 6(S0)
9D0056B8  2402FF80   ADDIU V0, ZERO, -128
9D0056BC  00621025   OR V0, V1, V0
9D0056C0  A2020006   SB V0, 6(S0)
9D0056C4  0B401630   J 0x9D0058C0
9D0056C8  24170001   ADDIU S7, ZERO, 1
2450:                				fp->clust = clst; /* Update current cluster */
2451:                			}
2452:                #if _FS_TINY
2453:                			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0)) /* Write-back sector cache */
9D0056CC  8E040000   LW A0, 0(S0)
9D0056D0  8C83002C   LW V1, 44(A0)
9D0056D4  8E020018   LW V0, 24(S0)
9D0056D8  5462000B   BNEL V1, V0, 0x9D005708
9D0056DC  8E160000   LW S6, 0(S0)
9D0056E0  0F400E51   JAL 0x9D003944
9D0056E4  00002821   ADDU A1, ZERO, ZERO
9D0056E8  50400007   BEQL V0, ZERO, 0x9D005708
9D0056EC  8E160000   LW S6, 0(S0)
2454:                			ABORT(fp->fs, FR_DISK_ERR);
9D0056F0  92030006   LBU V1, 6(S0)
9D0056F4  2402FF80   ADDIU V0, ZERO, -128
9D0056F8  00621025   OR V0, V1, V0
9D0056FC  A2020006   SB V0, 6(S0)
9D005700  0B401630   J 0x9D0058C0
9D005704  24170001   ADDIU S7, ZERO, 1
2455:                #else
2456:                			if (fp->flag & FA__DIRTY) { /* Write-back sector cache */
2457:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2458:                					ABORT(fp->fs, FR_DISK_ERR);
2459:                				fp->flag &= ~FA__DIRTY;
2460:                			}
2461:                #endif
2462:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D005708  02C02021   ADDU A0, S6, ZERO
9D00570C  0F400F25   JAL clust2sect
9D005710  8E050014   LW A1, 20(S0)
2463:                			if (!sect)
9D005714  14400007   BNE V0, ZERO, 0x9D005734
9D005718  00119242   SRL S2, S1, 9
2464:                				ABORT(fp->fs, FR_INT_ERR);
9D00571C  92030006   LBU V1, 6(S0)
9D005720  2402FF80   ADDIU V0, ZERO, -128
9D005724  00621025   OR V0, V1, V0
9D005728  A2020006   SB V0, 6(S0)
9D00572C  0B401630   J 0x9D0058C0
9D005730  24170002   ADDIU S7, ZERO, 2
2465:                			sect += csect;
2466:                			cc = btw / SS(fp->fs); /* When remaining bytes >= sector size, */
2467:                			if (cc) { /* Write maximum contiguous sectors directly */
9D005734  12400021   BEQ S2, ZERO, 0x9D0057BC
9D005738  0055F021   ADDU S8, V0, S5
2468:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D00573C  92C20002   LBU V0, 2(S6)
9D005740  02551821   ADDU V1, S2, S5
9D005744  0043182B   SLTU V1, V0, V1
2469:                					cc = fp->fs->csize - csect;
9D005748  0055A823   SUBU S5, V0, S5
9D00574C  02A3900B   MOVN S2, S5, V1
2470:                				if (disk_write(fp->fs->drv, wbuff, sect, (PF_BYTE) cc)
9D005750  92C40001   LBU A0, 1(S6)
9D005754  02802821   ADDU A1, S4, ZERO
9D005758  03C03021   ADDU A2, S8, ZERO
9D00575C  0F4023B4   JAL disk_write
9D005760  324700FF   ANDI A3, S2, 255
9D005764  50400007   BEQL V0, ZERO, 0x9D005784
9D005768  8E040000   LW A0, 0(S0)
2471:                						!= RES_OK)
2472:                					ABORT(fp->fs, FR_DISK_ERR);
9D00576C  92030006   LBU V1, 6(S0)
9D005770  2402FF80   ADDIU V0, ZERO, -128
9D005774  00621025   OR V0, V1, V0
9D005778  A2020006   SB V0, 6(S0)
9D00577C  0B401630   J 0x9D0058C0
9D005780  24170001   ADDIU S7, ZERO, 1
2473:                #if _FS_TINY
2474:                				if (fp->fs->winsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
9D005784  8C82002C   LW V0, 44(A0)
9D005788  005EF023   SUBU S8, V0, S8
9D00578C  03D2102B   SLTU V0, S8, S2
9D005790  50400037   BEQL V0, ZERO, 0x9D005870
9D005794  00129240   SLL S2, S2, 9
2475:                					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
9D005798  001EF240   SLL S8, S8, 9
9D00579C  24840030   ADDIU A0, A0, 48
9D0057A0  029E2821   ADDU A1, S4, S8
9D0057A4  0F400DD7   JAL 0x9D00375C
9D0057A8  24060200   ADDIU A2, ZERO, 512
2476:                					fp->fs->wflag = 0;
9D0057AC  8E020000   LW V0, 0(S0)
9D0057B0  A0400004   SB ZERO, 4(V0)
2477:                				}
2478:                #else
2479:                				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
2480:                					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)),
2481:                							SS(fp->fs));
2482:                					fp->flag &= ~FA__DIRTY;
2483:                				}
2484:                #endif
2485:                				wcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2486:                				continue;
9D0057B4  0B40161C   J 0x9D005870
9D0057B8  00129240   SLL S2, S2, 9
2487:                			}
2488:                #if _FS_TINY
2489:                			if (fp->fptr >= fp->fsize) { /* Avoid silly cache filling at growing edge */
9D0057BC  8E030008   LW V1, 8(S0)
9D0057C0  8E02000C   LW V0, 12(S0)
9D0057C4  0062102B   SLTU V0, V1, V0
9D0057C8  5440000E   BNEL V0, ZERO, 0x9D005804
9D0057CC  AE1E0018   SW S8, 24(S0)
2490:                				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
9D0057D0  02C02021   ADDU A0, S6, ZERO
9D0057D4  0F400E51   JAL 0x9D003944
9D0057D8  00002821   ADDU A1, ZERO, ZERO
9D0057DC  50400007   BEQL V0, ZERO, 0x9D0057FC
9D0057E0  8E020000   LW V0, 0(S0)
9D0057E4  92030006   LBU V1, 6(S0)
9D0057E8  2402FF80   ADDIU V0, ZERO, -128
9D0057EC  00621025   OR V0, V1, V0
9D0057F0  A2020006   SB V0, 6(S0)
9D0057F4  0B401630   J 0x9D0058C0
9D0057F8  24170001   ADDIU S7, ZERO, 1
2491:                				fp->fs->winsect = sect;
9D0057FC  AC5E002C   SW S8, 44(V0)
2492:                			}
2493:                #else
2494:                			if (fp->dsect != sect) { /* Fill sector cache with file data */
2495:                				if (fp->fptr < fp->fsize && disk_read(fp->fs->drv, fp->buf,
2496:                						sect, 1) != RES_OK)
2497:                					ABORT(fp->fs, FR_DISK_ERR);
2498:                			}
2499:                #endif
2500:                			fp->dsect = sect;
9D005800  AE1E0018   SW S8, 24(S0)
2501:                		}
2502:                		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
9D005804  8E120008   LW S2, 8(S0)
9D005834  24020200   ADDIU V0, ZERO, 512
9D005838  00529023   SUBU S2, V0, S2
9D00583C  0251102B   SLTU V0, S2, S1
9D005840  0222900A   MOVZ S2, S1, V0
2503:                		if (wcnt > btw)
2504:                			wcnt = btw;
2505:                #if _FS_TINY
2506:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D005808  8E040000   LW A0, 0(S0)
9D00580C  0F400E51   JAL 0x9D003944
9D005810  8E050018   LW A1, 24(S0)
9D005814  10400007   BEQ V0, ZERO, 0x9D005834
9D005818  325201FF   ANDI S2, S2, 511
2507:                		ABORT(fp->fs, FR_DISK_ERR);
9D00581C  92030006   LBU V1, 6(S0)
9D005820  2402FF80   ADDIU V0, ZERO, -128
9D005824  00621025   OR V0, V1, V0
9D005828  A2020006   SB V0, 6(S0)
9D00582C  0B401630   J 0x9D0058C0
9D005830  24170001   ADDIU S7, ZERO, 1
2508:                		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
9D005844  8E040000   LW A0, 0(S0)
9D005848  24840030   ADDIU A0, A0, 48
9D00584C  8E020008   LW V0, 8(S0)
9D005850  304201FF   ANDI V0, V0, 511
9D005854  00822021   ADDU A0, A0, V0
9D005858  02802821   ADDU A1, S4, ZERO
9D00585C  0F400DD7   JAL 0x9D00375C
9D005860  02403021   ADDU A2, S2, ZERO
2509:                		fp->fs->wflag = 1;
9D005864  8E020000   LW V0, 0(S0)
9D005868  24030001   ADDIU V1, ZERO, 1
9D00586C  A0430004   SB V1, 4(V0)
2510:                #else
2511:                		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
2512:                		fp->flag |= FA__DIRTY;
2513:                #endif
2514:                	}
2515:                
2516:                	if (fp->fptr > fp->fsize)
9D005898  8E020008   LW V0, 8(S0)
9D00589C  8E03000C   LW V1, 12(S0)
9D0058A0  0062182B   SLTU V1, V1, V0
9D0058A4  54600001   BNEL V1, ZERO, 0x9D0058AC
9D0058A8  AE02000C   SW V0, 12(S0)
2517:                		fp->fsize = fp->fptr; /* Update file size if needed */
2518:                	fp->flag |= FA__WRITTEN; /* Set file change flag */
9D0058AC  92020006   LBU V0, 6(S0)
9D0058B0  34420020   ORI V0, V0, 32
2519:                
2520:                	LEAVE_FF(fp->fs, FR_OK);
9D0058B4  0B401630   J 0x9D0058C0
9D0058B8  A2020006   SB V0, 6(S0)
9D0058BC  24170002   ADDIU S7, ZERO, 2
2521:                }
9D0058C0  02E01021   ADDU V0, S7, ZERO
9D0058C4  8FBF0034   LW RA, 52(SP)
9D0058C8  8FBE0030   LW S8, 48(SP)
9D0058CC  8FB7002C   LW S7, 44(SP)
9D0058D0  8FB60028   LW S6, 40(SP)
9D0058D4  8FB50024   LW S5, 36(SP)
9D0058D8  8FB40020   LW S4, 32(SP)
9D0058DC  8FB3001C   LW S3, 28(SP)
9D0058E0  8FB20018   LW S2, 24(SP)
9D0058E4  8FB10014   LW S1, 20(SP)
9D0058E8  8FB00010   LW S0, 16(SP)
9D0058EC  03E00008   JR RA
9D0058F0  27BD0038   ADDIU SP, SP, 56
2522:                
2523:                /*-----------------------------------------------------------------------*/
2524:                /* Synchronize the File Object                                           */
2525:                /*-----------------------------------------------------------------------*/
2526:                
2527:                FRESULT f_sync(FIL *fp /* Pointer to the file object */
2528:                ) {
9D0058F4  27BDFFE0   ADDIU SP, SP, -32
9D0058F8  AFBF001C   SW RA, 28(SP)
9D0058FC  AFB10018   SW S1, 24(SP)
9D005900  AFB00014   SW S0, 20(SP)
9D005904  00808021   ADDU S0, A0, ZERO
2529:                	FRESULT res;
2530:                	DWORD tim;
2531:                	PF_BYTE *dir;
2532:                
2533:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D005908  8C840000   LW A0, 0(A0)
9D00590C  0F400F12   JAL 0x9D003C48
9D005910  96050004   LHU A1, 4(S0)
2534:                	if (res == FR_OK) {
9D005914  14400032   BNE V0, ZERO, 0x9D0059E0
9D005918  8FBF001C   LW RA, 28(SP)
2535:                		if (fp->flag & FA__WRITTEN) { /* Has the file been written? */
9D00591C  92030006   LBU V1, 6(S0)
9D005920  30630020   ANDI V1, V1, 32
9D005924  1060002F   BEQ V1, ZERO, 0x9D0059E4
9D005928  8FB10018   LW S1, 24(SP)
2536:                #if !_FS_TINY	/* Write-back dirty buffer */
2537:                			if (fp->flag & FA__DIRTY) {
2538:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2539:                					LEAVE_FF(fp->fs, FR_DISK_ERR);
2540:                				fp->flag &= ~FA__DIRTY;
2541:                			}
2542:                #endif
2543:                			/* Update the directory entry */
2544:                			res = move_window(fp->fs, fp->dir_sect);
9D00592C  8E040000   LW A0, 0(S0)
9D005930  0F400E51   JAL 0x9D003944
9D005934  8E05001C   LW A1, 28(S0)
2545:                			if (res == FR_OK) {
9D005938  14400029   BNE V0, ZERO, 0x9D0059E0
9D00593C  8FBF001C   LW RA, 28(SP)
2546:                				dir = fp->dir_ptr;
9D005940  8E110020   LW S1, 32(S0)
2547:                				dir[DIR_Attr] |= AM_ARC; /* Set archive bit */
9D005944  9222000B   LBU V0, 11(S1)
9D005948  34420020   ORI V0, V0, 32
9D00594C  A222000B   SB V0, 11(S1)
2548:                				ST_DWORD(dir+DIR_FileSize, fp->fsize); /* Update file size */
9D005950  8E02000C   LW V0, 12(S0)
9D005954  A222001C   SB V0, 28(S1)
9D005958  9602000C   LHU V0, 12(S0)
9D00595C  00021202   SRL V0, V0, 8
9D005960  A222001D   SB V0, 29(S1)
9D005964  9602000E   LHU V0, 14(S0)
9D005968  A222001E   SB V0, 30(S1)
9D00596C  9202000F   LBU V0, 15(S0)
9D005970  A222001F   SB V0, 31(S1)
2549:                				ST_CLUST(dir, fp->sclust); /* Update start cluster */
9D005974  8E020010   LW V0, 16(S0)
9D005978  A222001A   SB V0, 26(S1)
9D00597C  96020010   LHU V0, 16(S0)
9D005980  00021202   SRL V0, V0, 8
9D005984  A222001B   SB V0, 27(S1)
9D005988  96020012   LHU V0, 18(S0)
9D00598C  A2220014   SB V0, 20(S1)
9D005990  96020012   LHU V0, 18(S0)
9D005994  00021202   SRL V0, V0, 8
2550:                				tim = get_fattime(); /* Update updated time */
9D005998  0F4024D9   JAL get_fattime
9D00599C  A2220015   SB V0, 21(S1)
2551:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D0059A0  A2220016   SB V0, 22(S1)
9D0059A4  7C433A00   EXT V1, V0, 8, 8
9D0059A8  A2230017   SB V1, 23(S1)
9D0059AC  00021C02   SRL V1, V0, 16
9D0059B0  A2230018   SB V1, 24(S1)
9D0059B4  00021602   SRL V0, V0, 24
9D0059B8  A2220019   SB V0, 25(S1)
2552:                				fp->flag &= ~FA__WRITTEN;
9D0059BC  92020006   LBU V0, 6(S0)
9D0059C0  304200DF   ANDI V0, V0, 223
9D0059C4  A2020006   SB V0, 6(S0)
2553:                				fp->fs->wflag = 1;
9D0059C8  8E020000   LW V0, 0(S0)
9D0059CC  24030001   ADDIU V1, ZERO, 1
9D0059D0  A0430004   SB V1, 4(V0)
2554:                				res = sync(fp->fs);
9D0059D4  0F400EC8   JAL 0x9D003B20
9D0059D8  8E040000   LW A0, 0(S0)
2555:                			}
2556:                		}
2557:                	}
2558:                
2559:                	LEAVE_FF(fp->fs, res);
2560:                }
9D0059DC  8FBF001C   LW RA, 28(SP)
9D0059E0  8FB10018   LW S1, 24(SP)
9D0059E4  8FB00014   LW S0, 20(SP)
9D0059E8  03E00008   JR RA
9D0059EC  27BD0020   ADDIU SP, SP, 32
2561:                
2562:                #endif /* !_FS_READONLY */
2563:                
2564:                /*-----------------------------------------------------------------------*/
2565:                /* Close File                                                            */
2566:                /*-----------------------------------------------------------------------*/
2567:                
2568:                FRESULT f_close(FIL *fp /* Pointer to the file object to be closed */
2569:                ) {
9D0059F0  27BDFFE8   ADDIU SP, SP, -24
9D0059F4  AFBF0014   SW RA, 20(SP)
9D0059F8  AFB00010   SW S0, 16(SP)
2570:                	FRESULT res;
2571:                
2572:                #if _FS_READONLY
2573:                	FATFS *fs = fp->fs;
2574:                	res = validate(fs, fp->id);
2575:                	if (res == FR_OK) fp->fs = 0; /* Discard file object */
2576:                	LEAVE_FF(fs, res);
2577:                
2578:                #else
2579:                	res = f_sync(fp); /* Flush cached data */
9D0059FC  0F40163D   JAL f_sync
9D005A00  00808021   ADDU S0, A0, ZERO
2580:                #if _FS_SHARE
2581:                	if (res == FR_OK) { /* Decrement open counter */
2582:                #if _FS_REENTRANT
2583:                		res = validate(fp->fs, fp->id);
2584:                		if (res == FR_OK) {
2585:                			res = dec_lock(fp->lockid);
2586:                			unlock_fs(fp->fs, FR_OK);
2587:                		}
2588:                #else
2589:                		res = dec_lock(fp->lockid);
2590:                #endif
2591:                	}
2592:                #endif
2593:                	if (res == FR_OK)
9D005A04  50400001   BEQL V0, ZERO, 0x9D005A0C
9D005A08  AE000000   SW ZERO, 0(S0)
2594:                		fp->fs = 0; /* Discard file object */
2595:                	return res;
2596:                #endif
2597:                }
9D005A0C  8FBF0014   LW RA, 20(SP)
9D005A10  8FB00010   LW S0, 16(SP)
9D005A14  03E00008   JR RA
9D005A18  27BD0018   ADDIU SP, SP, 24
2598:                
2599:                /*-----------------------------------------------------------------------*/
2600:                /* Current Drive/Directory Handlings                                     */
2601:                /*-----------------------------------------------------------------------*/
2602:                
2603:                #if _FS_RPATH >= 1
2604:                
2605:                FRESULT f_chdrive (
2606:                		PF_BYTE drv /* Drive number */
2607:                )
2608:                {
2609:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
2610:                
2611:                	CurrVol = drv;
2612:                
2613:                	return FR_OK;
2614:                }
2615:                
2616:                FRESULT f_chdir (
2617:                		const TCHAR *path /* Pointer to the directory path */
2618:                )
2619:                {
2620:                	FRESULT res;
2621:                	DIR dj;
2622:                	DEF_NAMEBUF;
2623:                
2624:                	res = chk_mounted(&path, &dj.fs, 0);
2625:                	if (res == FR_OK) {
2626:                		INIT_BUF(dj);
2627:                		res = follow_path(&dj, path); /* Follow the path */
2628:                		FREE_BUF();
2629:                		if (res == FR_OK) { /* Follow completed */
2630:                			if (!dj.dir) {
2631:                				dj.fs->cdir = dj.sclust; /* Start directory itself */
2632:                			} else {
2633:                				if (dj.dir[DIR_Attr] & AM_DIR) /* Reached to the directory */
2634:                				dj.fs->cdir = LD_CLUST(dj.dir);
2635:                				else
2636:                				res = FR_NO_PATH; /* Reached but a file */
2637:                			}
2638:                		}
2639:                		if (res == FR_NO_FILE) res = FR_NO_PATH;
2640:                	}
2641:                
2642:                	LEAVE_FF(dj.fs, res);
2643:                }
2644:                
2645:                #if _FS_RPATH >= 2
2646:                FRESULT f_getcwd (
2647:                		TCHAR *path, /* Pointer to the directory path */
2648:                		UINT sz_path /* Size of path */
2649:                )
2650:                {
2651:                	FRESULT res;
2652:                	DIR dj;
2653:                	UINT i, n;
2654:                	DWORD ccl;
2655:                	TCHAR *tp;
2656:                	FILINFO fno;
2657:                	DEF_NAMEBUF;
2658:                
2659:                	*path = 0;
2660:                	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0); /* Get current volume */
2661:                	if (res == FR_OK) {
2662:                		INIT_BUF(dj);
2663:                		i = sz_path; /* Bottom of buffer (dir stack base) */
2664:                		dj.sclust = dj.fs->cdir; /* Start to follow upper dir from current dir */
2665:                		while ((ccl = dj.sclust) != 0) { /* Repeat while current dir is a sub-dir */
2666:                			res = dir_sdi(&dj, 1); /* Get parent dir */
2667:                			if (res != FR_OK) break;
2668:                			res = dir_read(&dj);
2669:                			if (res != FR_OK) break;
2670:                			dj.sclust = LD_CLUST(dj.dir); /* Goto parent dir */
2671:                			res = dir_sdi(&dj, 0);
2672:                			if (res != FR_OK) break;
2673:                			do { /* Find the entry links to the child dir */
2674:                				res = dir_read(&dj);
2675:                				if (res != FR_OK) break;
2676:                				if (ccl == LD_CLUST(dj.dir)) break; /* Found the entry */
2677:                				res = dir_next(&dj, 0);
2678:                			}while (res == FR_OK);
2679:                			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
2680:                			if (res != FR_OK) break;
2681:                #if _USE_LFN
2682:                			fno.lfname = path;
2683:                			fno.lfsize = i;
2684:                #endif
2685:                			get_fileinfo(&dj, &fno); /* Get the dir name and push it to the buffer */
2686:                			tp = fno.fname;
2687:                			if (_USE_LFN && *path) tp = path;
2688:                			for (n = 0; tp[n]; n++);
2689:                			if (i < n + 3) {
2690:                				res = FR_NOT_ENOUGH_CORE; break;
2691:                			}
2692:                			while (n) path[--i] = tp[--n];
2693:                			path[--i] = '/';
2694:                		}
2695:                		tp = path;
2696:                		if (res == FR_OK) {
2697:                			*tp++ = '0' + CurrVol; /* Put drive number */
2698:                			*tp++ = ':';
2699:                			if (i == sz_path) { /* Root-dir */
2700:                				*tp++ = '/';
2701:                			} else { /* Sub-dir */
2702:                				do /* Add stacked path str */
2703:                				*tp++ = path[i++];
2704:                				while (i < sz_path);
2705:                			}
2706:                		}
2707:                		*tp = 0;
2708:                		FREE_BUF();
2709:                	}
2710:                
2711:                	LEAVE_FF(dj.fs, res);
2712:                }
2713:                #endif /* _FS_RPATH >= 2 */
2714:                #endif /* _FS_RPATH >= 1 */
2715:                
2716:                #if _FS_MINIMIZE <= 2
2717:                /*-----------------------------------------------------------------------*/
2718:                /* Seek File R/W Pointer                                                 */
2719:                /*-----------------------------------------------------------------------*/
2720:                
2721:                FRESULT f_lseek(FIL *fp, /* Pointer to the file object */
9D005CB8  02539023   SUBU S2, S2, S3
9D005CBC  2414FFFF   ADDIU S4, ZERO, -1
2722:                                DWORD ofs /* File pointer from top of file */
2723:                                ) {
9D005A1C  27BDFFC8   ADDIU SP, SP, -56
9D005A20  AFBF0034   SW RA, 52(SP)
9D005A24  AFBE0030   SW S8, 48(SP)
9D005A28  AFB7002C   SW S7, 44(SP)
9D005A2C  AFB60028   SW S6, 40(SP)
9D005A30  AFB50024   SW S5, 36(SP)
9D005A34  AFB40020   SW S4, 32(SP)
9D005A38  AFB3001C   SW S3, 28(SP)
9D005A3C  AFB20018   SW S2, 24(SP)
9D005A40  AFB10014   SW S1, 20(SP)
9D005A44  AFB00010   SW S0, 16(SP)
9D005A48  00808021   ADDU S0, A0, ZERO
9D005A4C  00A09021   ADDU S2, A1, ZERO
2724:                	FRESULT res;
2725:                
2726:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D005A50  8C840000   LW A0, 0(A0)
9D005A54  0F400F12   JAL 0x9D003C48
9D005A58  96050004   LHU A1, 4(S0)
2727:                	if (res != FR_OK)
9D005A5C  144000E5   BNE V0, ZERO, 0x9D005DF4
9D005A60  00408821   ADDU S1, V0, ZERO
2728:                		LEAVE_FF(fp->fs, res);
2729:                	if (fp->flag & FA__ERROR) /* Check abort flag */
9D005A64  92130006   LBU S3, 6(S0)
9D005A68  7C131420   SEB V0, S3
9D005A6C  044200E1   BLTZL V0, 0x9D005DF4
9D005A70  24110002   ADDIU S1, ZERO, 2
2730:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2731:                
2732:                #if _USE_FASTSEEK
2733:                	if (fp->cltbl) { /* Fast seek */
9D005A74  8E170024   LW S7, 36(S0)
9D005A78  12E00055   BEQ S7, ZERO, 0x9D005BD0
9D005A7C  2402FFFF   ADDIU V0, ZERO, -1
2734:                		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
2735:                
2736:                		if (ofs == CREATE_LINKMAP) { /* Create CLMT */
9D005A80  56420034   BNEL S2, V0, 0x9D005B54
9D005A84  8E02000C   LW V0, 12(S0)
2737:                			tbl = fp->cltbl;
2738:                			tlen = *tbl++;
9D005A88  8EFE0000   LW S8, 0(S7)
9D005A8C  26F70004   ADDIU S7, S7, 4
2739:                			ulen = 2; /* Given table size and required table size */
9D005A94  24150002   ADDIU S5, ZERO, 2
2740:                			cl = fp->sclust; /* Top of the chain */
9D005A90  8E160010   LW S6, 16(S0)
2741:                			if (cl) {
9D005A98  16C00003   BNE S6, ZERO, 0x9D005AA8
9D005A9C  2414FFFF   ADDIU S4, ZERO, -1
2742:                				do {
2743:                					/* Get a fragment */
2744:                					tcl = cl;
2745:                					ncl = 0;
9D005AAC  00009821   ADDU S3, ZERO, ZERO
2746:                					ulen += 2; /* Top, length and used items */
9D005B08  26B50002   ADDIU S5, S5, 2
2747:                					do {
2748:                						pcl = cl;
2749:                						ncl++;
2750:                						cl = get_fat(fp->fs, cl);
9D005AA8  02C09021   ADDU S2, S6, ZERO
9D005AB0  8E040000   LW A0, 0(S0)
9D005AB4  0F400F31   JAL get_fat
9D005AB8  02402821   ADDU A1, S2, ZERO
2751:                						if (cl <= 1)
9D005ABC  2C430002   SLTIU V1, V0, 2
9D005AC0  10600007   BEQ V1, ZERO, 0x9D005AE0
9D005AC4  00000000   NOP
2752:                							ABORT(fp->fs, FR_INT_ERR);
9D005AC8  92030006   LBU V1, 6(S0)
9D005ACC  2402FF80   ADDIU V0, ZERO, -128
9D005AD0  00621025   OR V0, V1, V0
9D005AD4  A2020006   SB V0, 6(S0)
9D005AD8  0B40177D   J 0x9D005DF4
9D005ADC  24110002   ADDIU S1, ZERO, 2
2753:                						if (cl == 0xFFFFFFFF)
9D005AE0  14540007   BNE V0, S4, 0x9D005B00
9D005AE4  26520001   ADDIU S2, S2, 1
2754:                							ABORT(fp->fs, FR_DISK_ERR);
9D005AE8  92030006   LBU V1, 6(S0)
9D005AEC  2402FF80   ADDIU V0, ZERO, -128
9D005AF0  00621025   OR V0, V1, V0
9D005AF4  A2020006   SB V0, 6(S0)
9D005AF8  0B40177D   J 0x9D005DF4
9D005AFC  24110001   ADDIU S1, ZERO, 1
2755:                					} while (cl == pcl + 1);
9D005B00  1242FFEB   BEQ S2, V0, 0x9D005AB0
9D005B04  26730001   ADDIU S3, S3, 1
2756:                					if (ulen <= tlen) { /* Store the length and top of the fragment */
9D005B0C  03D5182B   SLTU V1, S8, S5
9D005B10  54600005   BNEL V1, ZERO, 0x9D005B28
9D005B14  8E030000   LW V1, 0(S0)
2757:                						*tbl++ = ncl;
9D005B18  AEF30000   SW S3, 0(S7)
2758:                						*tbl++ = tcl;
9D005B1C  AEF60004   SW S6, 4(S7)
9D005B20  26F70008   ADDIU S7, S7, 8
2759:                					}
2760:                				} while (cl < fp->fs->n_fatent); /* Repeat until end of chain */
9D005B24  8E030000   LW V1, 0(S0)
9D005B28  8C630018   LW V1, 24(V1)
9D005B2C  0043182B   SLTU V1, V0, V1
9D005B30  1460FFDD   BNE V1, ZERO, 0x9D005AA8
9D005B34  0040B021   ADDU S6, V0, ZERO
2761:                			}
2762:                			*fp->cltbl = ulen; /* Number of items used */
9D005AA0  0B4016CF   J 0x9D005B3C
9D005AA4  8E020024   LW V0, 36(S0)
9D005B38  8E020024   LW V0, 36(S0)
9D005B3C  AC550000   SW S5, 0(V0)
2763:                			if (ulen <= tlen)
9D005B40  03D5A82B   SLTU S5, S8, S5
9D005B44  56A000AB   BNEL S5, ZERO, 0x9D005DF4
9D005B48  24110011   ADDIU S1, ZERO, 17
2764:                				*tbl = 0; /* Terminate table */
9D005B4C  0B40177D   J 0x9D005DF4
9D005B50  AEE00000   SW ZERO, 0(S7)
9D005B54  0052182B   SLTU V1, V0, S2
9D005B58  0043900B   MOVN S2, V0, V1
2765:                			else
2766:                				res = FR_NOT_ENOUGH_CORE; /* Given table size is smaller than required */
2767:                
2768:                		} else { /* Fast seek */
2769:                			if (ofs > fp->fsize) /* Clip offset at the file size */
2770:                				ofs = fp->fsize;
2771:                			fp->fptr = ofs; /* Set file pointer */
2772:                			if (ofs) {
9D005B5C  124000A5   BEQ S2, ZERO, 0x9D005DF4
9D005B60  AE120008   SW S2, 8(S0)
2773:                				fp->clust = clmt_clust(fp, ofs - 1);
9D005B64  2655FFFF   ADDIU S5, S2, -1
9D005B68  02002021   ADDU A0, S0, ZERO
9D005B6C  0F400DEA   JAL 0x9D0037A8
9D005B70  02A02821   ADDU A1, S5, ZERO
9D005B74  AE020014   SW V0, 20(S0)
2774:                				dsc = clust2sect(fp->fs, fp->clust);
9D005B78  8E140000   LW S4, 0(S0)
9D005B7C  02802021   ADDU A0, S4, ZERO
9D005B80  0F400F25   JAL clust2sect
9D005B84  00402821   ADDU A1, V0, ZERO
2775:                				if (!dsc)
9D005B88  14400006   BNE V0, ZERO, 0x9D005BA4
9D005B8C  325201FF   ANDI S2, S2, 511
2776:                					ABORT(fp->fs, FR_INT_ERR);
9D005B90  2402FF80   ADDIU V0, ZERO, -128
9D005B94  02629825   OR S3, S3, V0
9D005B98  A2130006   SB S3, 6(S0)
9D005B9C  0B40177D   J 0x9D005DF4
9D005BA0  24110002   ADDIU S1, ZERO, 2
2777:                				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
9D005BAC  0015AA42   SRL S5, S5, 9
9D005BB0  2463FFFF   ADDIU V1, V1, -1
9D005BB4  02A31824   AND V1, S5, V1
9D005BB8  00431021   ADDU V0, V0, V1
2778:                				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) { /* Refill sector cache if needed */
9D005BA4  12400093   BEQ S2, ZERO, 0x9D005DF4
9D005BA8  92830002   LBU V1, 2(S4)
9D005BBC  8E030018   LW V1, 24(S0)
9D005BC0  5462008C   BNEL V1, V0, 0x9D005DF4
9D005BC4  AE020018   SW V0, 24(S0)
2779:                #if !_FS_TINY
2780:                #if !_FS_READONLY
2781:                					if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2782:                						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2783:                								!= RES_OK)
2784:                							ABORT(fp->fs, FR_DISK_ERR);
2785:                						fp->flag &= ~FA__DIRTY;
2786:                					}
2787:                #endif
2788:                					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK) /* Load current sector */
2789:                						ABORT(fp->fs, FR_DISK_ERR);
2790:                #endif
2791:                					fp->dsect = dsc;
2792:                				}
2793:                			}
2794:                		}
2795:                	} else
2796:                #endif
2797:                
2798:                	/* Normal Seek */
2799:                	{
2800:                		DWORD clst, bcs, nsect, ifptr;
2801:                
2802:                		if (ofs > fp->fsize /* In read-only mode, clip offset with the file size */
9D005BD0  8E02000C   LW V0, 12(S0)
9D005BD4  0052182B   SLTU V1, V0, S2
9D005BD8  50600004   BEQL V1, ZERO, 0x9D005BEC
9D005BDC  8E020008   LW V0, 8(S0)
2803:                #if !_FS_READONLY
2804:                				&& !(fp->flag & FA_WRITE)
9D005BE0  32730002   ANDI S3, S3, 2
2805:                #endif
2806:                		)
2807:                			ofs = fp->fsize;
9D005BE4  0053900A   MOVZ S2, V0, S3
2808:                
2809:                		ifptr = fp->fptr;
9D005BE8  8E020008   LW V0, 8(S0)
2810:                		fp->fptr = nsect = 0;
2811:                		if (ofs) {
9D005BEC  12400081   BEQ S2, ZERO, 0x9D005DF4
9D005BF0  AE000008   SW ZERO, 8(S0)
2812:                			bcs = (DWORD) fp->fs->csize * SS(fp->fs); /* Cluster size (byte) */
9D005BF4  8E040000   LW A0, 0(S0)
9D005BF8  90930002   LBU S3, 2(A0)
2813:                			if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
9D005BFC  10400012   BEQ V0, ZERO, 0x9D005C48
9D005C00  00139A40   SLL S3, S3, 9
9D005C04  2442FFFF   ADDIU V0, V0, -1
9D005C08  2643FFFF   ADDIU V1, S2, -1
9D005C0C  0073001B   DIVU V1, S3
9D005C10  026001F4   TEQ S3, ZERO
9D005C14  00001812   MFLO V1, 0
9D005C18  0053001B   DIVU V0, S3
9D005C1C  026001F4   TEQ S3, ZERO
9D005C20  00002812   MFLO A1, 0
9D005C24  0065182B   SLTU V1, V1, A1
9D005C28  54600008   BNEL V1, ZERO, 0x9D005C4C
9D005C2C  8E020010   LW V0, 16(S0)
2814:                				fp->fptr = (ifptr - 1) & ~(bcs - 1); /* start from the current cluster */
9D005C30  00131823   SUBU V1, ZERO, S3
9D005C34  00621024   AND V0, V1, V0
9D005C38  AE020008   SW V0, 8(S0)
2815:                				ofs -= fp->fptr;
9D005C3C  02429023   SUBU S2, S2, V0
2816:                				clst = fp->clust;
9D005C40  0B401729   J 0x9D005CA4
9D005C44  8E020014   LW V0, 20(S0)
2817:                			} else { /* When seek to back cluster, */
2818:                				clst = fp->sclust; /* start from the first cluster */
9D005C48  8E020010   LW V0, 16(S0)
2819:                #if !_FS_READONLY
2820:                				if (clst == 0) { /* If no cluster chain, create a new chain */
9D005C4C  54400015   BNEL V0, ZERO, 0x9D005CA4
9D005C50  AE020014   SW V0, 20(S0)
2821:                					clst = create_chain(fp->fs, 0);
9D005C54  0F401070   JAL 0x9D0041C0
9D005C58  00002821   ADDU A1, ZERO, ZERO
2822:                					if (clst == 1)
9D005C5C  24030001   ADDIU V1, ZERO, 1
9D005C60  14430007   BNE V0, V1, 0x9D005C80
9D005C64  2403FFFF   ADDIU V1, ZERO, -1
2823:                						ABORT(fp->fs, FR_INT_ERR);
9D005C68  92030006   LBU V1, 6(S0)
9D005C6C  2402FF80   ADDIU V0, ZERO, -128
9D005C70  00621025   OR V0, V1, V0
9D005C74  A2020006   SB V0, 6(S0)
9D005C78  0B40177D   J 0x9D005DF4
9D005C7C  24110002   ADDIU S1, ZERO, 2
2824:                					if (clst == 0xFFFFFFFF)
9D005C80  54430007   BNEL V0, V1, 0x9D005CA0
9D005C84  AE020010   SW V0, 16(S0)
2825:                						ABORT(fp->fs, FR_DISK_ERR);
9D005C88  92030006   LBU V1, 6(S0)
9D005C8C  2402FF80   ADDIU V0, ZERO, -128
9D005C90  00621025   OR V0, V1, V0
9D005C94  A2020006   SB V0, 6(S0)
9D005C98  0B40177D   J 0x9D005DF4
9D005C9C  24110001   ADDIU S1, ZERO, 1
2826:                					fp->sclust = clst;
2827:                				}
2828:                #endif
2829:                				fp->clust = clst;
9D005CA0  AE020014   SW V0, 20(S0)
2830:                			}
2831:                			if (clst != 0) {
9D005CA4  10400043   BEQ V0, ZERO, 0x9D005DB4
9D005CA8  00001821   ADDU V1, ZERO, ZERO
2832:                				while (ofs > bcs) { /* Cluster following loop */
9D005CAC  0272182B   SLTU V1, S3, S2
9D005CB0  1060002E   BEQ V1, ZERO, 0x9D005D6C
9D005CB4  0013A823   SUBU S5, ZERO, S3
9D005D54  00732021   ADDU A0, V1, S3
9D005D58  0264202B   SLTU A0, S3, A0
9D005D5C  5480FFD8   BNEL A0, ZERO, 0x9D005CC0
9D005D60  00609021   ADDU S2, V1, ZERO
2833:                #if !_FS_READONLY
2834:                					if (fp->flag & FA_WRITE) { /* Check if in write mode or not */
9D005CC0  92030006   LBU V1, 6(S0)
9D005CC4  30630002   ANDI V1, V1, 2
9D005CC8  10600007   BEQ V1, ZERO, 0x9D005CE8
9D005CCC  8E040000   LW A0, 0(S0)
2835:                						clst = create_chain(fp->fs, clst); /* Force stretch if in write mode */
9D005CD0  0F401070   JAL 0x9D0041C0
9D005CD4  00402821   ADDU A1, V0, ZERO
2836:                						if (clst == 0) { /* When disk gets full, clip file size */
9D005CD8  14400005   BNE V0, ZERO, 0x9D005CF0
9D005CDC  00000000   NOP
2837:                							ofs = bcs;
9D005CE0  0B40175B   J 0x9D005D6C
9D005CE4  02609021   ADDU S2, S3, ZERO
2838:                							break;
2839:                						}
2840:                					} else
2841:                #endif
2842:                						clst = get_fat(fp->fs, clst); /* Follow cluster chain if not in write mode */
9D005CE8  0F400F31   JAL get_fat
9D005CEC  00402821   ADDU A1, V0, ZERO
2843:                					if (clst == 0xFFFFFFFF)
9D005CF0  14540007   BNE V0, S4, 0x9D005D10
9D005CF4  2C430002   SLTIU V1, V0, 2
2844:                						ABORT(fp->fs, FR_DISK_ERR);
9D005CF8  92030006   LBU V1, 6(S0)
9D005CFC  2402FF80   ADDIU V0, ZERO, -128
9D005D00  00621025   OR V0, V1, V0
9D005D04  A2020006   SB V0, 6(S0)
9D005D08  0B40177D   J 0x9D005DF4
9D005D0C  24110001   ADDIU S1, ZERO, 1
2845:                					if (clst <= 1 || clst >= fp->fs->n_fatent)
9D005D10  54600007   BNEL V1, ZERO, 0x9D005D30
9D005D14  92030006   LBU V1, 6(S0)
9D005D18  8E030000   LW V1, 0(S0)
9D005D1C  8C630018   LW V1, 24(V1)
9D005D20  0043182B   SLTU V1, V0, V1
9D005D24  54600007   BNEL V1, ZERO, 0x9D005D44
9D005D28  AE020014   SW V0, 20(S0)
2846:                						ABORT(fp->fs, FR_INT_ERR);
9D005D2C  92030006   LBU V1, 6(S0)
9D005D30  2402FF80   ADDIU V0, ZERO, -128
9D005D34  00621025   OR V0, V1, V0
9D005D38  A2020006   SB V0, 6(S0)
9D005D3C  0B40177D   J 0x9D005DF4
9D005D40  24110002   ADDIU S1, ZERO, 2
2847:                					fp->clust = clst;
2848:                					fp->fptr += bcs;
9D005D44  8E030008   LW V1, 8(S0)
9D005D48  00731821   ADDU V1, V1, S3
9D005D4C  AE030008   SW V1, 8(S0)
9D005D50  02551821   ADDU V1, S2, S5
2849:                					ofs -= bcs;
2850:                				}
2851:                				fp->fptr += ofs;
9D005D64  0B40175C   J 0x9D005D70
9D005D68  8E030008   LW V1, 8(S0)
9D005D6C  8E030008   LW V1, 8(S0)
9D005D70  00721821   ADDU V1, V1, S2
9D005D74  AE030008   SW V1, 8(S0)
2852:                				if (ofs % SS(fp->fs)) {
9D005D78  324401FF   ANDI A0, S2, 511
9D005D7C  1080000D   BEQ A0, ZERO, 0x9D005DB4
9D005D80  00001821   ADDU V1, ZERO, ZERO
2853:                					nsect = clust2sect(fp->fs, clst); /* Current sector */
9D005D84  8E040000   LW A0, 0(S0)
9D005D88  0F400F25   JAL clust2sect
9D005D8C  00402821   ADDU A1, V0, ZERO
2854:                					if (!nsect)
9D005D90  14400007   BNE V0, ZERO, 0x9D005DB0
9D005D94  00121A42   SRL V1, S2, 9
2855:                						ABORT(fp->fs, FR_INT_ERR);
9D005D98  92030006   LBU V1, 6(S0)
9D005D9C  2402FF80   ADDIU V0, ZERO, -128
9D005DA0  00621025   OR V0, V1, V0
9D005DA4  A2020006   SB V0, 6(S0)
9D005DA8  0B40177D   J 0x9D005DF4
9D005DAC  24110002   ADDIU S1, ZERO, 2
2856:                					nsect += ofs / SS(fp->fs);
9D005DB0  00431821   ADDU V1, V0, V1
2857:                				}
2858:                			}
2859:                		}
2860:                		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) { /* Fill sector cache if needed */
9D005DB4  8E020008   LW V0, 8(S0)
9D005DB8  304201FF   ANDI V0, V0, 511
9D005DBC  50400005   BEQL V0, ZERO, 0x9D005DD4
9D005DC0  8E020008   LW V0, 8(S0)
9D005DC4  8E020018   LW V0, 24(S0)
9D005DC8  54430001   BNEL V0, V1, 0x9D005DD0
9D005DCC  AE030018   SW V1, 24(S0)
2861:                #if !_FS_TINY
2862:                #if !_FS_READONLY
2863:                			if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2864:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2865:                					ABORT(fp->fs, FR_DISK_ERR);
2866:                				fp->flag &= ~FA__DIRTY;
2867:                			}
2868:                #endif
2869:                			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK) /* Fill sector cache */
2870:                				ABORT(fp->fs, FR_DISK_ERR);
2871:                #endif
2872:                			fp->dsect = nsect;
2873:                		}
2874:                #if !_FS_READONLY
2875:                		if (fp->fptr > fp->fsize) { /* Set file change flag if the file size is extended */
9D005DD0  8E020008   LW V0, 8(S0)
9D005DD4  8E03000C   LW V1, 12(S0)
9D005DD8  0062182B   SLTU V1, V1, V0
9D005DDC  50600006   BEQL V1, ZERO, 0x9D005DF8
9D005DE0  02201021   ADDU V0, S1, ZERO
2876:                			fp->fsize = fp->fptr;
9D005DE4  AE02000C   SW V0, 12(S0)
2877:                			fp->flag |= FA__WRITTEN;
9D005DE8  92020006   LBU V0, 6(S0)
9D005DEC  34420020   ORI V0, V0, 32
9D005DF0  A2020006   SB V0, 6(S0)
2878:                		}
2879:                #endif
2880:                	}
2881:                
2882:                	LEAVE_FF(fp->fs, res);
2883:                }
9D005BC8  0B40177E   J 0x9D005DF8
9D005BCC  02201021   ADDU V0, S1, ZERO
9D005DF4  02201021   ADDU V0, S1, ZERO
9D005DF8  8FBF0034   LW RA, 52(SP)
9D005DFC  8FBE0030   LW S8, 48(SP)
9D005E00  8FB7002C   LW S7, 44(SP)
9D005E04  8FB60028   LW S6, 40(SP)
9D005E08  8FB50024   LW S5, 36(SP)
9D005E0C  8FB40020   LW S4, 32(SP)
9D005E10  8FB3001C   LW S3, 28(SP)
9D005E14  8FB20018   LW S2, 24(SP)
9D005E18  8FB10014   LW S1, 20(SP)
9D005E1C  8FB00010   LW S0, 16(SP)
9D005E20  03E00008   JR RA
9D005E24  27BD0038   ADDIU SP, SP, 56
2884:                
2885:                #if _FS_MINIMIZE <= 1
2886:                /*-----------------------------------------------------------------------*/
2887:                /* Create a Directroy Object                                             */
2888:                /*-----------------------------------------------------------------------*/
2889:                
2890:                FRESULT f_opendir(DIR *dj, /* Pointer to directory object to create */
2891:                const TCHAR *path /* Pointer to the directory path */
2892:                ) {
9D005E28  27BDFFD8   ADDIU SP, SP, -40
9D005E2C  AFBF0024   SW RA, 36(SP)
9D005E30  AFB00020   SW S0, 32(SP)
9D005E34  00808021   ADDU S0, A0, ZERO
9D005E38  AFA5002C   SW A1, 44(SP)
2893:                	FRESULT res;
2894:                	DEF_NAMEBUF;
2895:                
2896:                	res = chk_mounted(&path, &dj->fs, 0);
9D005E3C  27A4002C   ADDIU A0, SP, 44
9D005E40  02002821   ADDU A1, S0, ZERO
9D005E44  0F4012DA   JAL chk_mounted
9D005E48  00003021   ADDU A2, ZERO, ZERO
2897:                	if (res == FR_OK) {
9D005E4C  14400024   BNE V0, ZERO, 0x9D005EE0
9D005E50  8FBF0024   LW RA, 36(SP)
2898:                		INIT_BUF(*dj);
9D005E54  27A20010   ADDIU V0, SP, 16
9D005E58  AE020018   SW V0, 24(S0)
2899:                		res = follow_path(dj, path); /* Follow the path to the directory */
9D005E5C  02002021   ADDU A0, S0, ZERO
9D005E60  0F401153   JAL 0x9D00454C
9D005E64  8FA5002C   LW A1, 44(SP)
2900:                		FREE_BUF();
2901:                		if (res == FR_OK) { /* Follow completed */
9D005E68  1440001A   BNE V0, ZERO, 0x9D005ED4
9D005E6C  38440004   XORI A0, V0, 4
2902:                			if (dj->dir) { /* It is not the root dir */
9D005E70  8E030014   LW V1, 20(S0)
9D005E74  50600011   BEQL V1, ZERO, 0x9D005EBC
9D005E78  8E020000   LW V0, 0(S0)
2903:                				if (dj->dir[DIR_Attr] & AM_DIR) { /* The object is a directory */
9D005E7C  9064000B   LBU A0, 11(V1)
9D005E80  30840010   ANDI A0, A0, 16
9D005E84  10800015   BEQ A0, ZERO, 0x9D005EDC
9D005E88  24020005   ADDIU V0, ZERO, 5
2904:                					dj->sclust = LD_CLUST(dj->dir);
9D005E8C  90640015   LBU A0, 21(V1)
9D005E90  00042200   SLL A0, A0, 8
9D005E94  90620014   LBU V0, 20(V1)
9D005E98  00822025   OR A0, A0, V0
9D005E9C  00042400   SLL A0, A0, 16
9D005EA0  9062001B   LBU V0, 27(V1)
9D005EA4  00021200   SLL V0, V0, 8
9D005EA8  9063001A   LBU V1, 26(V1)
9D005EAC  00431025   OR V0, V0, V1
9D005EB0  00821025   OR V0, A0, V0
9D005EB4  AE020008   SW V0, 8(S0)
2905:                				} else { /* The object is not a directory */
2906:                					res = FR_NO_PATH;
2907:                				}
2908:                			}
2909:                			if (res == FR_OK) {
2910:                				dj->id = dj->fs->id;
9D005EB8  8E020000   LW V0, 0(S0)
9D005EBC  94420006   LHU V0, 6(V0)
9D005EC0  A6020004   SH V0, 4(S0)
2911:                				res = dir_sdi(dj, 0); /* Rewind dir */
9D005EC4  02002021   ADDU A0, S0, ZERO
9D005EC8  0F400F92   JAL 0x9D003E48
9D005ECC  00002821   ADDU A1, ZERO, ZERO
2912:                			}
2913:                		}
2914:                		if (res == FR_NO_FILE)
2915:                			res = FR_NO_PATH;
9D005ED0  38440004   XORI A0, V0, 4
9D005ED4  24030005   ADDIU V1, ZERO, 5
9D005ED8  0064100A   MOVZ V0, V1, A0
2916:                	}
2917:                
2918:                	LEAVE_FF(dj->fs, res);
2919:                }
9D005EDC  8FBF0024   LW RA, 36(SP)
9D005EE0  8FB00020   LW S0, 32(SP)
9D005EE4  03E00008   JR RA
9D005EE8  27BD0028   ADDIU SP, SP, 40
2920:                
2921:                /*-----------------------------------------------------------------------*/
2922:                /* Read Directory Entry in Sequense                                      */
2923:                /*-----------------------------------------------------------------------*/
2924:                
2925:                FRESULT f_readdir(DIR *dj, /* Pointer to the open directory object */
2926:                FILINFO *fno /* Pointer to file information to return */
2927:                ) {
9D005EEC  27BDFFD0   ADDIU SP, SP, -48
9D005EF0  AFBF002C   SW RA, 44(SP)
9D005EF4  AFB20028   SW S2, 40(SP)
9D005EF8  AFB10024   SW S1, 36(SP)
9D005EFC  AFB00020   SW S0, 32(SP)
9D005F00  00808821   ADDU S1, A0, ZERO
9D005F04  00A09021   ADDU S2, A1, ZERO
2928:                	FRESULT res;
2929:                	DEF_NAMEBUF;
2930:                
2931:                	res = validate(dj->fs, dj->id); /* Check validity of the object */
9D005F08  8C840000   LW A0, 0(A0)
9D005F0C  0F400F12   JAL 0x9D003C48
9D005F10  96250004   LHU A1, 4(S1)
2932:                	if (res == FR_OK) {
9D005F14  1440001C   BNE V0, ZERO, 0x9D005F88
9D005F18  00408021   ADDU S0, V0, ZERO
2933:                		if (!fno) {
9D005F1C  16400006   BNE S2, ZERO, 0x9D005F38
9D005F20  27A20010   ADDIU V0, SP, 16
2934:                			res = dir_sdi(dj, 0); /* Rewind the directory object */
9D005F24  02202021   ADDU A0, S1, ZERO
9D005F28  0F400F92   JAL 0x9D003E48
9D005F2C  00002821   ADDU A1, ZERO, ZERO
9D005F30  0B4017E2   J 0x9D005F88
9D005F34  00408021   ADDU S0, V0, ZERO
2935:                		} else {
2936:                			INIT_BUF(*dj);
9D005F38  AE220018   SW V0, 24(S1)
2937:                			res = dir_read(dj); /* Read an directory item */
9D005F3C  0F401276   JAL 0x9D0049D8
9D005F40  02202021   ADDU A0, S1, ZERO
2938:                			if (res == FR_NO_FILE) { /* Reached end of dir */
9D005F44  24030004   ADDIU V1, ZERO, 4
9D005F48  14430003   BNE V0, V1, 0x9D005F58
9D005F4C  00000000   NOP
2939:                				dj->sect = 0;
9D005F50  0B4017D8   J 0x9D005F60
9D005F54  AE200010   SW ZERO, 16(S1)
2940:                				res = FR_OK;
2941:                			}
2942:                			if (res == FR_OK) { /* A valid entry is found */
9D005F58  5440000B   BNEL V0, ZERO, 0x9D005F88
9D005F5C  00408021   ADDU S0, V0, ZERO
2943:                				get_fileinfo(dj, fno); /* Get the object information */
9D005F60  02202021   ADDU A0, S1, ZERO
9D005F64  0F400E09   JAL 0x9D003824
9D005F68  02402821   ADDU A1, S2, ZERO
2944:                				res = dir_next(dj, 0); /* Increment index for next */
9D005F6C  02202021   ADDU A0, S1, ZERO
9D005F70  0F4010D1   JAL 0x9D004344
9D005F74  00002821   ADDU A1, ZERO, ZERO
2945:                				if (res == FR_NO_FILE) {
9D005F78  24030004   ADDIU V1, ZERO, 4
9D005F7C  54430002   BNEL V0, V1, 0x9D005F88
9D005F80  00408021   ADDU S0, V0, ZERO
9D005F84  AE200010   SW ZERO, 16(S1)
2946:                					dj->sect = 0;
2947:                					res = FR_OK;
2948:                				}
2949:                			} FREE_BUF();
2950:                		}
2951:                	}
2952:                
2953:                	LEAVE_FF(dj->fs, res);
2954:                }
9D005F88  02001021   ADDU V0, S0, ZERO
9D005F8C  8FBF002C   LW RA, 44(SP)
9D005F90  8FB20028   LW S2, 40(SP)
9D005F94  8FB10024   LW S1, 36(SP)
9D005F98  8FB00020   LW S0, 32(SP)
9D005F9C  03E00008   JR RA
9D005FA0  27BD0030   ADDIU SP, SP, 48
2955:                
2956:                #if _FS_MINIMIZE == 0
2957:                /*-----------------------------------------------------------------------*/
2958:                /* Get File Status                                                       */
2959:                /*-----------------------------------------------------------------------*/
2960:                
2961:                FRESULT f_stat(const TCHAR *path, /* Pointer to the file path */
2962:                                FILINFO *fno /* Pointer to file information to return */
2963:                                ) {
9D005FA4  27BDFFB8   ADDIU SP, SP, -72
9D005FA8  AFBF0044   SW RA, 68(SP)
9D005FAC  AFB10040   SW S1, 64(SP)
9D005FB0  AFB0003C   SW S0, 60(SP)
9D005FB4  AFA40048   SW A0, 72(SP)
9D005FB8  00A08821   ADDU S1, A1, ZERO
2964:                	FRESULT res;
2965:                	DIR dj;
2966:                	DEF_NAMEBUF;
2967:                
2968:                	res = chk_mounted(&path, &dj.fs, 0);
9D005FBC  27A40048   ADDIU A0, SP, 72
9D005FC0  27A50010   ADDIU A1, SP, 16
9D005FC4  0F4012DA   JAL chk_mounted
9D005FC8  00003021   ADDU A2, ZERO, ZERO
2969:                	if (res == FR_OK) {
9D005FCC  14400010   BNE V0, ZERO, 0x9D006010
9D005FD0  00408021   ADDU S0, V0, ZERO
2970:                		INIT_BUF(dj);
9D005FD4  27A2002C   ADDIU V0, SP, 44
9D005FD8  AFA20028   SW V0, 40(SP)
2971:                		res = follow_path(&dj, path); /* Follow the file path */
9D005FDC  27A40010   ADDIU A0, SP, 16
9D005FE0  0F401153   JAL 0x9D00454C
9D005FE4  8FA50048   LW A1, 72(SP)
2972:                		if (res == FR_OK) { /* Follow completed */
9D005FE8  14400009   BNE V0, ZERO, 0x9D006010
9D005FEC  00408021   ADDU S0, V0, ZERO
2973:                			if (dj.dir) /* Found an object */
9D005FF0  8FA20024   LW V0, 36(SP)
9D005FF4  10400005   BEQ V0, ZERO, 0x9D00600C
9D005FF8  27A40010   ADDIU A0, SP, 16
2974:                				get_fileinfo(&dj, fno);
9D005FFC  0F400E09   JAL 0x9D003824
9D006000  02202821   ADDU A1, S1, ZERO
2975:                			else
2976:                				/* It is root dir */
2977:                				res = FR_INVALID_NAME;
9D00600C  24100006   ADDIU S0, ZERO, 6
2978:                		}FREE_BUF();
2979:                	}
2980:                
2981:                	LEAVE_FF(dj.fs, res);
2982:                }
9D006004  0B401805   J 0x9D006014
9D006008  02001021   ADDU V0, S0, ZERO
9D006010  02001021   ADDU V0, S0, ZERO
9D006014  8FBF0044   LW RA, 68(SP)
9D006018  8FB10040   LW S1, 64(SP)
9D00601C  8FB0003C   LW S0, 60(SP)
9D006020  03E00008   JR RA
9D006024  27BD0048   ADDIU SP, SP, 72
2983:                
2984:                #if !_FS_READONLY
2985:                /*-----------------------------------------------------------------------*/
2986:                /* Get Number of Free Clusters                                           */
2987:                /*-----------------------------------------------------------------------*/
2988:                
2989:                FRESULT f_getfree(const TCHAR *path, /* Pointer to the logical drive number (root dir) */
2990:                DWORD *nclst, /* Pointer to the variable to return number of free clusters */
2991:                FATFS **fatfs /* Pointer to pointer to corresponding file system object to return */
2992:                ) {
9D006028  27BDFFC8   ADDIU SP, SP, -56
9D00602C  AFBF0034   SW RA, 52(SP)
9D006030  AFB70030   SW S7, 48(SP)
9D006034  AFB6002C   SW S6, 44(SP)
9D006038  AFB50028   SW S5, 40(SP)
9D00603C  AFB40024   SW S4, 36(SP)
9D006040  AFB30020   SW S3, 32(SP)
9D006044  AFB2001C   SW S2, 28(SP)
9D006048  AFB10018   SW S1, 24(SP)
9D00604C  AFB00014   SW S0, 20(SP)
9D006050  AFA40038   SW A0, 56(SP)
9D006054  00A0B821   ADDU S7, A1, ZERO
9D006058  00C09021   ADDU S2, A2, ZERO
2993:                	FRESULT res;
2994:                	DWORD n, clst, sect, stat;
2995:                	UINT i;
2996:                	PF_BYTE fat, *p;
2997:                
2998:                	/* Get drive number */
2999:                	res = chk_mounted(&path, fatfs, 0);
9D00605C  27A40038   ADDIU A0, SP, 56
9D006060  00C02821   ADDU A1, A2, ZERO
9D006064  0F4012DA   JAL chk_mounted
9D006068  00003021   ADDU A2, ZERO, ZERO
3000:                	if (res == FR_OK) {
9D00606C  1440005A   BNE V0, ZERO, 0x9D0061D8
9D006070  00408021   ADDU S0, V0, ZERO
3001:                		/* If free_clust is valid, return it without full cluster scan */
3002:                		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
9D006074  8E420000   LW V0, 0(S2)
9D006078  8C430010   LW V1, 16(V0)
9D00607C  8C510018   LW S1, 24(V0)
9D006080  2624FFFE   ADDIU A0, S1, -2
9D006084  0083202B   SLTU A0, A0, V1
9D006088  54800003   BNEL A0, ZERO, 0x9D006098
9D00608C  90540000   LBU S4, 0(V0)
3003:                			*nclst = (*fatfs)->free_clust;
9D006090  0B401876   J 0x9D0061D8
9D006094  AEE30000   SW V1, 0(S7)
3004:                		} else {
3005:                			/* Get number of free clusters */
3006:                			fat = (*fatfs)->fs_type;
3007:                			n = 0;
9D0060FC  00009821   ADDU S3, ZERO, ZERO
3008:                			if (fat == FS_FAT12) {
9D006098  24030001   ADDIU V1, ZERO, 1
9D00609C  56830015   BNEL S4, V1, 0x9D0060F4
9D0060A0  8C560020   LW S6, 32(V0)
9D0060A4  24110002   ADDIU S1, ZERO, 2
9D0060A8  00009821   ADDU S3, ZERO, ZERO
3009:                				clst = 2;
3010:                				do {
3011:                					stat = get_fat(*fatfs, clst);
9D0060B4  8E440000   LW A0, 0(S2)
9D0060B8  0F400F31   JAL get_fat
9D0060BC  02202821   ADDU A1, S1, ZERO
3012:                					if (stat == 0xFFFFFFFF) {
9D0060AC  2415FFFF   ADDIU S5, ZERO, -1
9D0060C0  5055003C   BEQL V0, S5, 0x9D0061B4
9D0060C4  24100001   ADDIU S0, ZERO, 1
3013:                						res = FR_DISK_ERR;
3014:                						break;
3015:                					}
3016:                					if (stat == 1) {
9D0060B0  24160001   ADDIU S6, ZERO, 1
9D0060C8  10560037   BEQ V0, S6, 0x9D0061A8
9D0060CC  2C420001   SLTIU V0, V0, 1
3017:                						res = FR_INT_ERR;
9D0061A8  0B40186D   J 0x9D0061B4
9D0061AC  24100002   ADDIU S0, ZERO, 2
3018:                						break;
3019:                					}
3020:                					if (stat == 0)
3021:                						n++;
9D0060D0  02629821   ADDU S3, S3, V0
3022:                				} while (++clst < (*fatfs)->n_fatent);
9D0060D4  26310001   ADDIU S1, S1, 1
9D0060D8  8E420000   LW V0, 0(S2)
9D0060DC  8C430018   LW V1, 24(V0)
9D0060E0  0223182B   SLTU V1, S1, V1
9D0060E4  5460FFF4   BNEL V1, ZERO, 0x9D0060B8
9D0060E8  8E440000   LW A0, 0(S2)
3023:                			} else {
3024:                				clst = (*fatfs)->n_fatent;
3025:                				sect = (*fatfs)->fatbase;
3026:                				i = 0;
9D0060F8  00001821   ADDU V1, ZERO, ZERO
3027:                				p = 0;
9D0060F4  00001021   ADDU V0, ZERO, ZERO
3028:                				do {
3029:                					if (!i) {
9D006104  14600009   BNE V1, ZERO, 0x9D00612C
9D006108  00000000   NOP
3030:                						res = move_window(*fatfs, sect++);
9D00610C  8E440000   LW A0, 0(S2)
9D006110  0F400E51   JAL 0x9D003944
9D006114  02C02821   ADDU A1, S6, ZERO
9D0061B0  00408021   ADDU S0, V0, ZERO
3031:                						if (res != FR_OK)
9D006118  14400025   BNE V0, ZERO, 0x9D0061B0
9D00611C  26D60001   ADDIU S6, S6, 1
3032:                							break;
3033:                						p = (*fatfs)->win;
9D006120  8E420000   LW V0, 0(S2)
9D006124  24420030   ADDIU V0, V0, 48
3034:                						i = SS(*fatfs);
9D006128  24030200   ADDIU V1, ZERO, 512
3035:                					}
3036:                					if (fat == FS_FAT16) {
9D006100  24150002   ADDIU S5, ZERO, 2
9D00612C  5695000B   BNEL S4, S5, 0x9D00615C
9D006130  90450003   LBU A1, 3(V0)
3037:                						if (LD_WORD(p) == 0)
9D006134  90440001   LBU A0, 1(V0)
9D006138  00042200   SLL A0, A0, 8
9D00613C  90450000   LBU A1, 0(V0)
9D006140  00852025   OR A0, A0, A1
9D006144  7C042620   SEH A0, A0
3038:                							n++;
9D006148  2C840001   SLTIU A0, A0, 1
9D00614C  02649821   ADDU S3, S3, A0
3039:                						p += 2;
9D006150  24420002   ADDIU V0, V0, 2
3040:                						i -= 2;
9D006154  0B401865   J 0x9D006194
9D006158  2463FFFE   ADDIU V1, V1, -2
3041:                					} else {
3042:                						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0)
9D00615C  00052E00   SLL A1, A1, 24
9D006160  90440002   LBU A0, 2(V0)
9D006164  00042400   SLL A0, A0, 16
9D006168  00A42025   OR A0, A1, A0
9D00616C  90450000   LBU A1, 0(V0)
9D006170  00852025   OR A0, A0, A1
9D006174  90450001   LBU A1, 1(V0)
9D006178  00052A00   SLL A1, A1, 8
9D00617C  00852025   OR A0, A0, A1
9D006180  7C84D800   EXT A0, A0, 0, 28
3043:                							n++;
9D006184  2C840001   SLTIU A0, A0, 1
9D006188  02649821   ADDU S3, S3, A0
3044:                						p += 4;
9D00618C  24420004   ADDIU V0, V0, 4
3045:                						i -= 4;
9D006190  2463FFFC   ADDIU V1, V1, -4
3046:                					}
3047:                				} while (--clst);
9D006194  2631FFFF   ADDIU S1, S1, -1
9D006198  1620FFDA   BNE S1, ZERO, 0x9D006104
9D00619C  00000000   NOP
3048:                			}
3049:                			(*fatfs)->free_clust = n;
9D0060EC  0B401875   J 0x9D0061D4
9D0060F0  AC530010   SW S3, 16(V0)
9D0061A0  0B40186E   J 0x9D0061B8
9D0061A4  8E420000   LW V0, 0(S2)
9D0061B4  8E420000   LW V0, 0(S2)
9D0061B8  AC530010   SW S3, 16(V0)
3050:                			if (fat == FS_FAT32)
9D0061BC  24020003   ADDIU V0, ZERO, 3
9D0061C0  56820005   BNEL S4, V0, 0x9D0061D8
9D0061C4  AEF30000   SW S3, 0(S7)
3051:                				(*fatfs)->fsi_flag = 1;
9D0061C8  8E420000   LW V0, 0(S2)
9D0061CC  24030001   ADDIU V1, ZERO, 1
9D0061D0  A0430005   SB V1, 5(V0)
3052:                			*nclst = n;
9D0061D4  AEF30000   SW S3, 0(S7)
3053:                		}
3054:                	}
3055:                	LEAVE_FF(*fatfs, res);
3056:                }
9D0061D8  02001021   ADDU V0, S0, ZERO
9D0061DC  8FBF0034   LW RA, 52(SP)
9D0061E0  8FB70030   LW S7, 48(SP)
9D0061E4  8FB6002C   LW S6, 44(SP)
9D0061E8  8FB50028   LW S5, 40(SP)
9D0061EC  8FB40024   LW S4, 36(SP)
9D0061F0  8FB30020   LW S3, 32(SP)
9D0061F4  8FB2001C   LW S2, 28(SP)
9D0061F8  8FB10018   LW S1, 24(SP)
9D0061FC  8FB00014   LW S0, 20(SP)
9D006200  03E00008   JR RA
9D006204  27BD0038   ADDIU SP, SP, 56
3057:                
3058:                /*-----------------------------------------------------------------------*/
3059:                /* Truncate File                                                         */
3060:                /*-----------------------------------------------------------------------*/
3061:                
3062:                FRESULT f_truncate(FIL *fp /* Pointer to the file object */
3063:                ) {
9D006208  27BDFFE0   ADDIU SP, SP, -32
9D00620C  AFBF001C   SW RA, 28(SP)
9D006210  AFB10018   SW S1, 24(SP)
9D006214  AFB00014   SW S0, 20(SP)
9D006218  00808021   ADDU S0, A0, ZERO
3064:                	FRESULT res;
3065:                	DWORD ncl;
3066:                
3067:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D00621C  8C840000   LW A0, 0(A0)
9D006220  0F400F12   JAL 0x9D003C48
9D006224  96050004   LHU A1, 4(S0)
3068:                	if (res == FR_OK) {
9D006228  14400033   BNE V0, ZERO, 0x9D0062F8
9D00622C  8FBF001C   LW RA, 28(SP)
3069:                		if (fp->flag & FA__ERROR) { /* Check abort flag */
9D006230  92030006   LBU V1, 6(S0)
9D006234  7C032420   SEB A0, V1
9D006238  04800005   BLTZ A0, 0x9D006250
9D00623C  30640002   ANDI A0, V1, 2
3070:                			res = FR_INT_ERR;
9D006250  0B4018BD   J 0x9D0062F4
9D006254  24020002   ADDIU V0, ZERO, 2
3071:                		} else {
3072:                			if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D006240  54800031   BNEL A0, ZERO, 0x9D006308
9D006244  8E040008   LW A0, 8(S0)
3073:                				res = FR_DENIED;
9D006248  0B4018BD   J 0x9D0062F4
9D00624C  24020007   ADDIU V0, ZERO, 7
3074:                		}
3075:                	}
3076:                	if (res == FR_OK) {
3077:                		if (fp->fsize > fp->fptr) {
9D006308  8E05000C   LW A1, 12(S0)
9D00630C  0085282B   SLTU A1, A0, A1
9D006310  54A0FFD1   BNEL A1, ZERO, 0x9D006258
9D006314  AE04000C   SW A0, 12(S0)
3078:                			fp->fsize = fp->fptr; /* Set file size to current R/W point */
3079:                			fp->flag |= FA__WRITTEN;
9D006258  34630020   ORI V1, V1, 32
3080:                			if (fp->fptr == 0) { /* When set file size to zero, remove entire cluster chain */
9D00625C  14800006   BNE A0, ZERO, 0x9D006278
9D006260  A2030006   SB V1, 6(S0)
3081:                				res = remove_chain(fp->fs, fp->sclust);
9D006264  8E040000   LW A0, 0(S0)
9D006268  0F4012A0   JAL 0x9D004A80
9D00626C  8E050010   LW A1, 16(S0)
3082:                				fp->sclust = 0;
9D006270  0B4018B7   J 0x9D0062DC
9D006274  AE000010   SW ZERO, 16(S0)
3083:                			} else { /* When truncate a part of the file, remove remaining clusters */
3084:                				ncl = get_fat(fp->fs, fp->clust);
9D006278  8E040000   LW A0, 0(S0)
9D00627C  0F400F31   JAL get_fat
9D006280  8E050014   LW A1, 20(S0)
9D006284  00408821   ADDU S1, V0, ZERO
3085:                				res = FR_OK;
9D006294  26220001   ADDIU V0, S1, 1
9D006298  2C420001   SLTIU V0, V0, 1
3086:                				if (ncl == 0xFFFFFFFF)
3087:                					res = FR_DISK_ERR;
3088:                				if (ncl == 1)
9D006288  24020001   ADDIU V0, ZERO, 1
9D00628C  12220015   BEQ S1, V0, 0x9D0062E4
9D006290  24020002   ADDIU V0, ZERO, 2
3089:                					res = FR_INT_ERR;
3090:                				if (res == FR_OK && ncl < fp->fs->n_fatent) {
9D00629C  54400012   BNEL V0, ZERO, 0x9D0062E8
9D0062A0  92040006   LBU A0, 6(S0)
9D0062A4  8E040000   LW A0, 0(S0)
9D0062A8  8C830018   LW V1, 24(A0)
9D0062AC  0223182B   SLTU V1, S1, V1
9D0062B0  10600011   BEQ V1, ZERO, 0x9D0062F8
9D0062B4  8FBF001C   LW RA, 28(SP)
3091:                					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
9D0062B8  8E050014   LW A1, 20(S0)
9D0062BC  3C060FFF   LUI A2, 4095
9D0062C0  0F401001   JAL put_fat
9D0062C4  34C6FFFF   ORI A2, A2, -1
3092:                					if (res == FR_OK)
9D0062C8  54400007   BNEL V0, ZERO, 0x9D0062E8
9D0062CC  92040006   LBU A0, 6(S0)
3093:                						res = remove_chain(fp->fs, ncl);
9D0062D0  8E040000   LW A0, 0(S0)
9D0062D4  0F4012A0   JAL 0x9D004A80
9D0062D8  02202821   ADDU A1, S1, ZERO
3094:                				}
3095:                			}
3096:                		}
3097:                		if (res != FR_OK)
9D0062DC  10400006   BEQ V0, ZERO, 0x9D0062F8
9D0062E0  8FBF001C   LW RA, 28(SP)
3098:                			fp->flag |= FA__ERROR;
9D0062E4  92040006   LBU A0, 6(S0)
9D0062E8  2403FF80   ADDIU V1, ZERO, -128
9D0062EC  00831825   OR V1, A0, V1
9D0062F0  A2030006   SB V1, 6(S0)
3099:                	}
3100:                
3101:                	LEAVE_FF(fp->fs, res);
3102:                }
9D0062F4  8FBF001C   LW RA, 28(SP)
9D0062F8  8FB10018   LW S1, 24(SP)
9D0062FC  8FB00014   LW S0, 20(SP)
9D006300  03E00008   JR RA
9D006304  27BD0020   ADDIU SP, SP, 32
9D006318  0B4018BE   J 0x9D0062F8
9D00631C  8FBF001C   LW RA, 28(SP)
3103:                
3104:                /*-----------------------------------------------------------------------*/
3105:                /* Delete a File or Directory                                            */
3106:                /*-----------------------------------------------------------------------*/
3107:                
3108:                FRESULT f_unlink(const TCHAR *path /* Pointer to the file or directory path */
3109:                ) {
9D006320  27BDFFA0   ADDIU SP, SP, -96
9D006324  AFBF005C   SW RA, 92(SP)
9D006328  AFB00058   SW S0, 88(SP)
9D00632C  AFA40060   SW A0, 96(SP)
3110:                	FRESULT res;
3111:                	DIR dj, sdj;
3112:                	PF_BYTE *dir;
3113:                	DWORD dclst;
3114:                	DEF_NAMEBUF;
3115:                
3116:                	res = chk_mounted(&path, &dj.fs, 1);
9D006330  27A40060   ADDIU A0, SP, 96
9D006334  27A50010   ADDIU A1, SP, 16
9D006338  0F4012DA   JAL chk_mounted
9D00633C  24060001   ADDIU A2, ZERO, 1
3117:                	if (res == FR_OK) {
9D006340  1440002E   BNE V0, ZERO, 0x9D0063FC
9D006344  8FBF005C   LW RA, 92(SP)
3118:                		INIT_BUF(dj);
9D006348  27A20048   ADDIU V0, SP, 72
9D00634C  AFA20028   SW V0, 40(SP)
3119:                		res = follow_path(&dj, path); /* Follow the file path */
9D006350  27A40010   ADDIU A0, SP, 16
9D006354  0F401153   JAL 0x9D00454C
9D006358  8FA50060   LW A1, 96(SP)
3120:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3121:                			res = FR_INVALID_NAME; /* Cannot remove dot entry */
3122:                #if _FS_SHARE
3123:                		if (res == FR_OK) res = chk_lock(&dj, 2); /* Cannot remove open file */
3124:                #endif
3125:                		if (res == FR_OK) { /* The object is accessible */
9D00635C  14400026   BNE V0, ZERO, 0x9D0063F8
9D006360  8FA30024   LW V1, 36(SP)
3126:                			dir = dj.dir;
3127:                			if (!dir) {
9D006364  10600024   BEQ V1, ZERO, 0x9D0063F8
9D006368  24020006   ADDIU V0, ZERO, 6
3128:                				res = FR_INVALID_NAME; /* Cannot remove the start directory */
3129:                			} else {
3130:                				if (dir[DIR_Attr] & AM_RDO)
9D00636C  9062000B   LBU V0, 11(V1)
9D006370  30420001   ANDI V0, V0, 1
9D006374  5040002A   BEQL V0, ZERO, 0x9D006420
9D006378  90620015   LBU V0, 21(V1)
3131:                					res = FR_DENIED; /* Cannot remove R/O object */
9D00637C  0B4018FE   J 0x9D0063F8
9D006380  24020007   ADDIU V0, ZERO, 7
3132:                			}
3133:                			dclst = LD_CLUST(dir);
9D006420  00021200   SLL V0, V0, 8
9D006424  90640014   LBU A0, 20(V1)
9D006428  00441025   OR V0, V0, A0
9D00642C  00021400   SLL V0, V0, 16
9D006430  9070001B   LBU S0, 27(V1)
9D006434  00108200   SLL S0, S0, 8
9D006438  9064001A   LBU A0, 26(V1)
9D00643C  02048025   OR S0, S0, A0
9D006440  00508025   OR S0, V0, S0
3134:                			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) { /* Is it a sub-dir? */
9D006444  9062000B   LBU V0, 11(V1)
9D006448  30420010   ANDI V0, V0, 16
9D00644C  1440FFCD   BNE V0, ZERO, 0x9D006384
9D006450  2E030002   SLTIU V1, S0, 2
9D006454  0B401902   J 0x9D006408
9D006458  00000000   NOP
3135:                				if (dclst < 2) {
9D006384  1460001C   BNE V1, ZERO, 0x9D0063F8
9D006388  24020002   ADDIU V0, ZERO, 2
3136:                					res = FR_INT_ERR;
3137:                				} else {
3138:                					mem_cpy(&sdj, &dj, sizeof(DIR)); /* Check if the sub-dir is empty or not */
9D00638C  27A4002C   ADDIU A0, SP, 44
9D006390  27A50010   ADDIU A1, SP, 16
9D006394  0F400DD7   JAL 0x9D00375C
9D006398  2406001C   ADDIU A2, ZERO, 28
3139:                					sdj.sclust = dclst;
9D00639C  AFB00034   SW S0, 52(SP)
3140:                					res = dir_sdi(&sdj, 2); /* Exclude dot entries */
9D0063A0  27A4002C   ADDIU A0, SP, 44
9D0063A4  0F400F92   JAL 0x9D003E48
9D0063A8  24050002   ADDIU A1, ZERO, 2
3141:                					if (res == FR_OK) {
9D0063AC  14400013   BNE V0, ZERO, 0x9D0063FC
9D0063B0  8FBF005C   LW RA, 92(SP)
3142:                						res = dir_read(&sdj);
9D0063B4  0F401276   JAL 0x9D0049D8
9D0063B8  27A4002C   ADDIU A0, SP, 44
3143:                						if (res == FR_OK /* Not empty dir */
9D0063BC  5040000E   BEQL V0, ZERO, 0x9D0063F8
9D0063C0  24020007   ADDIU V0, ZERO, 7
3144:                #if _FS_RPATH
3145:                							|| dclst == sdj.fs->cdir /* Current dir */
3146:                #endif
3147:                							) res = FR_DENIED;
3148:                						if (res == FR_NO_FILE)
9D0063C4  24030004   ADDIU V1, ZERO, 4
9D0063C8  1043000F   BEQ V0, V1, 0x9D006408
9D0063CC  8FBF005C   LW RA, 92(SP)
3149:                							res = FR_OK; /* Empty */
3150:                					}
3151:                				}
3152:                			}
3153:                			if (res == FR_OK) {
3154:                				res = dir_remove(&dj); /* Remove the directory entry */
9D006408  0F400FEB   JAL 0x9D003FAC
9D00640C  27A40010   ADDIU A0, SP, 16
3155:                				if (res == FR_OK) {
9D006410  1040FFF1   BEQ V0, ZERO, 0x9D0063D8
9D006414  8FBF005C   LW RA, 92(SP)
3156:                					if (dclst) /* Remove the cluster chain if exist */
9D0063D8  12000005   BEQ S0, ZERO, 0x9D0063F0
9D0063DC  8FA40010   LW A0, 16(SP)
3157:                						res = remove_chain(dj.fs, dclst);
9D0063E0  0F4012A0   JAL 0x9D004A80
9D0063E4  02002821   ADDU A1, S0, ZERO
3158:                					if (res == FR_OK)
9D0063E8  14400004   BNE V0, ZERO, 0x9D0063FC
9D0063EC  8FBF005C   LW RA, 92(SP)
3159:                						res = sync(dj.fs);
9D0063F0  0F400EC8   JAL 0x9D003B20
9D0063F4  8FA40010   LW A0, 16(SP)
3160:                				}
3161:                			}
3162:                		}FREE_BUF();
3163:                	}
3164:                	LEAVE_FF(dj.fs, res);
3165:                }
9D0063D0  0B401900   J 0x9D006400
9D0063D4  8FB00058   LW S0, 88(SP)
9D0063F8  8FBF005C   LW RA, 92(SP)
9D0063FC  8FB00058   LW S0, 88(SP)
9D006400  03E00008   JR RA
9D006404  27BD0060   ADDIU SP, SP, 96
9D006418  0B401900   J 0x9D006400
9D00641C  8FB00058   LW S0, 88(SP)
3166:                
3167:                /*-----------------------------------------------------------------------*/
3168:                /* Create a Directory                                                    */
3169:                /*-----------------------------------------------------------------------*/
3170:                
3171:                FRESULT f_mkdir(const TCHAR *path /* Pointer to the directory path */
9D006620  32B500FF   ANDI S5, S5, 255
9D006624  26B50001   ADDIU S5, S5, 1
9D006628  02B2A821   ADDU S5, S5, S2
3172:                ) {
9D00645C  27BDFF88   ADDIU SP, SP, -120
9D006460  AFBF0074   SW RA, 116(SP)
9D006464  AFBE0070   SW S8, 112(SP)
9D006468  AFB7006C   SW S7, 108(SP)
9D00646C  AFB60068   SW S6, 104(SP)
9D006470  AFB50064   SW S5, 100(SP)
9D006474  AFB40060   SW S4, 96(SP)
9D006478  AFB3005C   SW S3, 92(SP)
9D00647C  AFB20058   SW S2, 88(SP)
9D006480  AFB10054   SW S1, 84(SP)
9D006484  AFB00050   SW S0, 80(SP)
3173:                	FRESULT res;
3174:                	DIR dj;
3175:                	PF_BYTE *dir, n;
3176:                	DWORD dsc, dcl, pcl, tim = get_fattime();
9D006488  0F4024D9   JAL get_fattime
9D00648C  AFA40078   SW A0, 120(SP)
9D006490  00408821   ADDU S1, V0, ZERO
3177:                	DEF_NAMEBUF;
3178:                
3179:                	res = chk_mounted(&path, &dj.fs, 1);
9D006494  27A40078   ADDIU A0, SP, 120
9D006498  27A50010   ADDIU A1, SP, 16
9D00649C  0F4012DA   JAL chk_mounted
9D0064A0  24060001   ADDIU A2, ZERO, 1
3180:                	if (res == FR_OK) {
9D0064A4  1440008C   BNE V0, ZERO, 0x9D0066D8
9D0064A8  00408021   ADDU S0, V0, ZERO
3181:                		INIT_BUF(dj);
9D0064AC  27A2002C   ADDIU V0, SP, 44
9D0064B0  AFA20028   SW V0, 40(SP)
3182:                		res = follow_path(&dj, path); /* Follow the file path */
9D0064B4  27A40010   ADDIU A0, SP, 16
9D0064B8  0F401153   JAL 0x9D00454C
9D0064BC  8FA50078   LW A1, 120(SP)
3183:                		if (res == FR_OK)
9D0064C0  50400085   BEQL V0, ZERO, 0x9D0066D8
9D0064C4  24100008   ADDIU S0, ZERO, 8
3184:                			res = FR_EXIST; /* Any object with same name is already existing */
3185:                		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
3186:                			res = FR_INVALID_NAME;
3187:                		if (res == FR_NO_FILE) { /* Can create a new directory */
9D0064C8  24030004   ADDIU V1, ZERO, 4
9D0064CC  54430082   BNEL V0, V1, 0x9D0066D8
9D0064D0  00408021   ADDU S0, V0, ZERO
3188:                			dcl = create_chain(dj.fs, 0); /* Allocate a cluster for the new directory table */
9D0064D4  8FA40010   LW A0, 16(SP)
9D0064D8  0F401070   JAL 0x9D0041C0
9D0064DC  00002821   ADDU A1, ZERO, ZERO
3189:                			res = FR_OK;
3190:                			if (dcl == 0)
9D0064E0  10400009   BEQ V0, ZERO, 0x9D006508
9D0064E4  00409821   ADDU S3, V0, ZERO
3191:                				res = FR_DENIED; /* No space to allocate a new cluster */
9D006508  24100007   ADDIU S0, ZERO, 7
3192:                			if (dcl == 1)
9D0064E8  24020001   ADDIU V0, ZERO, 1
9D0064EC  52620060   BEQL S3, V0, 0x9D006670
9D0064F0  24100002   ADDIU S0, ZERO, 2
3193:                				res = FR_INT_ERR;
3194:                			if (dcl == 0xFFFFFFFF)
9D0064F4  2402FFFF   ADDIU V0, ZERO, -1
9D0064F8  5262005D   BEQL S3, V0, 0x9D006670
9D0064FC  24100001   ADDIU S0, ZERO, 1
9D006500  0B401943   J 0x9D00650C
9D006504  00000000   NOP
3195:                				res = FR_DISK_ERR;
3196:                			if (res == FR_OK) /* Flush FAT */
9D00650C  16000058   BNE S0, ZERO, 0x9D006670
9D006510  8FA40010   LW A0, 16(SP)
3197:                				res = move_window(dj.fs, 0);
9D006514  0F400E51   JAL 0x9D003944
9D006518  00002821   ADDU A1, ZERO, ZERO
3198:                			if (res == FR_OK) { /* Initialize the new directory table */
9D00651C  14400054   BNE V0, ZERO, 0x9D006670
9D006520  00408021   ADDU S0, V0, ZERO
3199:                				dsc = clust2sect(dj.fs, dcl);
9D006524  8FB00010   LW S0, 16(SP)
9D006528  02002021   ADDU A0, S0, ZERO
9D00652C  0F400F25   JAL clust2sect
9D006530  02602821   ADDU A1, S3, ZERO
9D006534  00409021   ADDU S2, V0, ZERO
3200:                				dir = dj.fs->win;
9D006538  26140030   ADDIU S4, S0, 48
3201:                				mem_set(dir, 0, SS(dj.fs));
9D00653C  02802021   ADDU A0, S4, ZERO
9D006540  00002821   ADDU A1, ZERO, ZERO
9D006544  0F400DE1   JAL 0x9D003784
9D006548  24060200   ADDIU A2, ZERO, 512
3202:                				mem_set(dir + DIR_Name, ' ', 8 + 3); /* Create "." entry */
9D00654C  02802021   ADDU A0, S4, ZERO
9D006550  24050020   ADDIU A1, ZERO, 32
9D006554  0F400DE1   JAL 0x9D003784
9D006558  2406000B   ADDIU A2, ZERO, 11
3203:                				dir[DIR_Name] = '.';
9D00655C  2415002E   ADDIU S5, ZERO, 46
9D006560  A2150030   SB S5, 48(S0)
3204:                				dir[DIR_Attr] = AM_DIR;
9D006564  24020010   ADDIU V0, ZERO, 16
9D006568  A202003B   SB V0, 59(S0)
3205:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D00656C  322200FF   ANDI V0, S1, 255
9D006570  AFA20038   SW V0, 56(SP)
9D006574  A2020046   SB V0, 70(S0)
9D006578  00111A02   SRL V1, S1, 8
9D00657C  A3A30048   SB V1, 72(SP)
9D006580  A2030047   SB V1, 71(S0)
9D006584  7E223C00   EXT V0, S1, 16, 8
9D006588  AFA2003C   SW V0, 60(SP)
9D00658C  A2020048   SB V0, 72(S0)
9D006590  00118E02   SRL S1, S1, 24
9D006594  AFB10040   SW S1, 64(SP)
9D006598  A2110049   SB S1, 73(S0)
3206:                				ST_CLUST(dir, dcl);
9D00659C  326300FF   ANDI V1, S3, 255
9D0065A0  AFA30044   SW V1, 68(SP)
9D0065A4  A203004A   SB V1, 74(S0)
9D0065A8  0013BA02   SRL S7, S3, 8
9D0065AC  A217004B   SB S7, 75(S0)
9D0065B0  0013B402   SRL S6, S3, 16
9D0065B4  32DE00FF   ANDI S8, S6, 255
9D0065B8  A21E0044   SB S8, 68(S0)
9D0065BC  0016B202   SRL S6, S6, 8
9D0065C0  A2160045   SB S6, 69(S0)
3207:                				mem_cpy(dir + SZ_DIR, dir, SZ_DIR); /* Create ".." entry */
9D0065C4  26040050   ADDIU A0, S0, 80
9D0065C8  02802821   ADDU A1, S4, ZERO
9D0065CC  0F400DD7   JAL 0x9D00375C
9D0065D0  24060020   ADDIU A2, ZERO, 32
3208:                				dir[33] = '.';
9D0065D4  A2150051   SB S5, 81(S0)
3209:                				pcl = dj.sclust;
3210:                				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
9D0065D8  8FA30010   LW V1, 16(SP)
9D0065DC  90650000   LBU A1, 0(V1)
9D0065E0  24040003   ADDIU A0, ZERO, 3
9D0065E4  14A40004   BNE A1, A0, 0x9D0065F8
9D0065E8  8FA20018   LW V0, 24(SP)
9D0065EC  8C640024   LW A0, 36(V1)
3211:                					pcl = 0;
9D0065F0  00822026   XOR A0, A0, V0
9D0065F4  0004100A   MOVZ V0, ZERO, A0
3212:                				ST_CLUST(dir+SZ_DIR, pcl);
9D0065F8  A202006A   SB V0, 106(S0)
9D0065FC  7C443A00   EXT A0, V0, 8, 8
9D006600  A204006B   SB A0, 107(S0)
9D006604  00021402   SRL V0, V0, 16
9D006608  A2020064   SB V0, 100(S0)
9D00660C  00021202   SRL V0, V0, 8
9D006610  A2020065   SB V0, 101(S0)
3213:                				for (n = dj.fs->csize; n; n--) { /* Write dot entries and clear following sectors */
9D006614  90620002   LBU V0, 2(V1)
9D006618  1040003C   BEQ V0, ZERO, 0x9D00670C
9D00661C  2455FFFF   ADDIU S5, V0, -1
9D006660  1655FFF4   BNE S2, S5, 0x9D006634
9D006664  8FA40010   LW A0, 16(SP)
9D006668  0B4019C3   J 0x9D00670C
9D00666C  00000000   NOP
3214:                					dj.fs->winsect = dsc++;
9D006630  8FA40010   LW A0, 16(SP)
9D006634  AC92002C   SW S2, 44(A0)
9D006638  26520001   ADDIU S2, S2, 1
3215:                					dj.fs->wflag = 1;
9D00662C  24110001   ADDIU S1, ZERO, 1
9D00663C  A0910004   SB S1, 4(A0)
3216:                					res = move_window(dj.fs, 0);
9D006640  0F400E51   JAL 0x9D003944
9D006644  00002821   ADDU A1, ZERO, ZERO
3217:                					if (res != FR_OK)
9D006648  14400009   BNE V0, ZERO, 0x9D006670
9D00664C  00408021   ADDU S0, V0, ZERO
3218:                						break;
3219:                					mem_set(dir, 0, SS(dj.fs));
9D006650  02802021   ADDU A0, S4, ZERO
9D006654  00002821   ADDU A1, ZERO, ZERO
9D006658  0F400DE1   JAL 0x9D003784
9D00665C  24060200   ADDIU A2, ZERO, 512
3220:                				}
3221:                			}
3222:                			if (res == FR_OK)
3223:                				res = dir_register(&dj); /* Register the object to the directoy */
9D00670C  0F401241   JAL 0x9D004904
9D006710  27A40010   ADDIU A0, SP, 16
3224:                			if (res != FR_OK) {
9D006714  1040FFDB   BEQ V0, ZERO, 0x9D006684
9D006718  00408021   ADDU S0, V0, ZERO
3225:                				remove_chain(dj.fs, dcl); /* Could not register, remove cluster chain */
9D006670  8FA40010   LW A0, 16(SP)
9D006674  0F4012A0   JAL 0x9D004A80
9D006678  02602821   ADDU A1, S3, ZERO
9D00671C  0B40199D   J 0x9D006674
9D006720  8FA40010   LW A0, 16(SP)
3226:                			} else {
3227:                				dir = dj.dir;
9D006684  8FA20024   LW V0, 36(SP)
3228:                				dir[DIR_Attr] = AM_DIR; /* Attribute */
9D006688  24030010   ADDIU V1, ZERO, 16
9D00668C  A043000B   SB V1, 11(V0)
3229:                				ST_DWORD(dir+DIR_WrtTime, tim); /* Created time */
9D006690  8FA30038   LW V1, 56(SP)
9D006694  A0430016   SB V1, 22(V0)
9D006698  93A30048   LBU V1, 72(SP)
9D00669C  A0430017   SB V1, 23(V0)
9D0066A0  8FA3003C   LW V1, 60(SP)
9D0066A4  A0430018   SB V1, 24(V0)
9D0066A8  8FA30040   LW V1, 64(SP)
9D0066AC  A0430019   SB V1, 25(V0)
3230:                				ST_CLUST(dir, dcl); /* Table start cluster */
9D0066B0  8FA30044   LW V1, 68(SP)
9D0066B4  A043001A   SB V1, 26(V0)
9D0066B8  A057001B   SB S7, 27(V0)
9D0066BC  A05E0014   SB S8, 20(V0)
9D0066C0  A0560015   SB S6, 21(V0)
3231:                				dj.fs->wflag = 1;
9D0066C4  8FA40010   LW A0, 16(SP)
9D0066C8  24020001   ADDIU V0, ZERO, 1
3232:                				res = sync(dj.fs);
9D0066CC  0F400EC8   JAL 0x9D003B20
9D0066D0  A0820004   SB V0, 4(A0)
9D0066D4  00408021   ADDU S0, V0, ZERO
3233:                			}
3234:                		}FREE_BUF();
3235:                	}
3236:                
3237:                	LEAVE_FF(dj.fs, res);
3238:                }
9D00667C  0B4019B7   J 0x9D0066DC
9D006680  02001021   ADDU V0, S0, ZERO
9D0066D8  02001021   ADDU V0, S0, ZERO
9D0066DC  8FBF0074   LW RA, 116(SP)
9D0066E0  8FBE0070   LW S8, 112(SP)
9D0066E4  8FB7006C   LW S7, 108(SP)
9D0066E8  8FB60068   LW S6, 104(SP)
9D0066EC  8FB50064   LW S5, 100(SP)
9D0066F0  8FB40060   LW S4, 96(SP)
9D0066F4  8FB3005C   LW S3, 92(SP)
9D0066F8  8FB20058   LW S2, 88(SP)
9D0066FC  8FB10054   LW S1, 84(SP)
9D006700  8FB00050   LW S0, 80(SP)
9D006704  03E00008   JR RA
9D006708  27BD0078   ADDIU SP, SP, 120
3239:                
3240:                /*-----------------------------------------------------------------------*/
3241:                /* Change Attribute                                                      */
3242:                /*-----------------------------------------------------------------------*/
3243:                
3244:                FRESULT f_chmod(const TCHAR *path, /* Pointer to the file path */
3245:                PF_BYTE value, /* Attribute bits */
3246:                PF_BYTE mask /* Attribute mask to change */
3247:                ) {
9D006724  27BDFFB8   ADDIU SP, SP, -72
9D006728  AFBF0044   SW RA, 68(SP)
9D00672C  AFB10040   SW S1, 64(SP)
9D006730  AFB0003C   SW S0, 60(SP)
9D006734  AFA40048   SW A0, 72(SP)
9D006738  30B100FF   ANDI S1, A1, 255
9D00673C  30D000FF   ANDI S0, A2, 255
3248:                	FRESULT res;
3249:                	DIR dj;
3250:                	PF_BYTE *dir;
3251:                	DEF_NAMEBUF;
3252:                
3253:                	res = chk_mounted(&path, &dj.fs, 1);
9D006740  27A40048   ADDIU A0, SP, 72
9D006744  27A50010   ADDIU A1, SP, 16
9D006748  0F4012DA   JAL chk_mounted
9D00674C  24060001   ADDIU A2, ZERO, 1
3254:                	if (res == FR_OK) {
9D006750  14400016   BNE V0, ZERO, 0x9D0067AC
9D006754  8FBF0044   LW RA, 68(SP)
3255:                		INIT_BUF(dj);
9D006758  27A2002C   ADDIU V0, SP, 44
9D00675C  AFA20028   SW V0, 40(SP)
3256:                		res = follow_path(&dj, path); /* Follow the file path */
9D006760  27A40010   ADDIU A0, SP, 16
9D006764  0F401153   JAL 0x9D00454C
9D006768  8FA50048   LW A1, 72(SP)
3257:                		FREE_BUF();
3258:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3259:                			res = FR_INVALID_NAME;
3260:                		if (res == FR_OK) {
9D00676C  1440000E   BNE V0, ZERO, 0x9D0067A8
9D006770  8FA30024   LW V1, 36(SP)
3261:                			dir = dj.dir;
3262:                			if (!dir) { /* Is it a root directory? */
9D006774  1060000C   BEQ V1, ZERO, 0x9D0067A8
9D006778  24020006   ADDIU V0, ZERO, 6
3263:                				res = FR_INVALID_NAME;
3264:                			} else { /* File or sub directory */
3265:                				mask &= AM_RDO | AM_HID | AM_SYS | AM_ARC; /* Valid attribute mask */
9D00677C  32100027   ANDI S0, S0, 39
3266:                				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr]
9D006784  9062000B   LBU V0, 11(V1)
9D006788  00821024   AND V0, A0, V0
9D00678C  02118024   AND S0, S0, S1
9D006790  00508025   OR S0, V0, S0
9D006794  A070000B   SB S0, 11(V1)
3267:                						& (PF_BYTE) ~mask); /* Apply attribute change */
9D006780  00102027   NOR A0, ZERO, S0
3268:                				dj.fs->wflag = 1;
9D006798  8FA40010   LW A0, 16(SP)
9D00679C  24020001   ADDIU V0, ZERO, 1
3269:                				res = sync(dj.fs);
9D0067A0  0F400EC8   JAL 0x9D003B20
9D0067A4  A0820004   SB V0, 4(A0)
3270:                			}
3271:                		}
3272:                	}
3273:                
3274:                	LEAVE_FF(dj.fs, res);
3275:                }
9D0067A8  8FBF0044   LW RA, 68(SP)
9D0067AC  8FB10040   LW S1, 64(SP)
9D0067B0  8FB0003C   LW S0, 60(SP)
9D0067B4  03E00008   JR RA
9D0067B8  27BD0048   ADDIU SP, SP, 72
3276:                
3277:                /*-----------------------------------------------------------------------*/
3278:                /* Change Timestamp                                                      */
3279:                /*-----------------------------------------------------------------------*/
3280:                
3281:                FRESULT f_utime(const TCHAR *path, /* Pointer to the file/directory name */
3282:                const FILINFO *fno /* Pointer to the time stamp to be set */
3283:                ) {
9D0067BC  27BDFFC0   ADDIU SP, SP, -64
9D0067C0  AFBF003C   SW RA, 60(SP)
9D0067C4  AFB00038   SW S0, 56(SP)
9D0067C8  AFA40040   SW A0, 64(SP)
9D0067CC  00A08021   ADDU S0, A1, ZERO
3284:                	FRESULT res;
3285:                	DIR dj;
3286:                	PF_BYTE *dir;
3287:                	DEF_NAMEBUF;
3288:                
3289:                	res = chk_mounted(&path, &dj.fs, 1);
9D0067D0  27A40040   ADDIU A0, SP, 64
9D0067D4  27A50010   ADDIU A1, SP, 16
9D0067D8  0F4012DA   JAL chk_mounted
9D0067DC  24060001   ADDIU A2, ZERO, 1
3290:                	if (res == FR_OK) {
9D0067E0  14400019   BNE V0, ZERO, 0x9D006848
9D0067E4  8FBF003C   LW RA, 60(SP)
3291:                		INIT_BUF(dj);
9D0067E8  27A2002C   ADDIU V0, SP, 44
9D0067EC  AFA20028   SW V0, 40(SP)
3292:                		res = follow_path(&dj, path); /* Follow the file path */
9D0067F0  27A40010   ADDIU A0, SP, 16
9D0067F4  0F401153   JAL 0x9D00454C
9D0067F8  8FA50040   LW A1, 64(SP)
3293:                		FREE_BUF();
3294:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3295:                			res = FR_INVALID_NAME;
3296:                		if (res == FR_OK) {
9D0067FC  14400011   BNE V0, ZERO, 0x9D006844
9D006800  8FA30024   LW V1, 36(SP)
3297:                			dir = dj.dir;
3298:                			if (!dir) { /* Root directory */
9D006804  1060000F   BEQ V1, ZERO, 0x9D006844
9D006808  24020006   ADDIU V0, ZERO, 6
3299:                				res = FR_INVALID_NAME;
3300:                			} else { /* File or sub-directory */
3301:                				ST_WORD(dir+DIR_WrtTime, fno->ftime);
9D00680C  96020006   LHU V0, 6(S0)
9D006810  A0620016   SB V0, 22(V1)
9D006814  96020006   LHU V0, 6(S0)
9D006818  00021202   SRL V0, V0, 8
9D00681C  A0620017   SB V0, 23(V1)
3302:                				ST_WORD(dir+DIR_WrtDate, fno->fdate);
9D006820  96020004   LHU V0, 4(S0)
9D006824  A0620018   SB V0, 24(V1)
9D006828  96020004   LHU V0, 4(S0)
9D00682C  00021202   SRL V0, V0, 8
9D006830  A0620019   SB V0, 25(V1)
3303:                				dj.fs->wflag = 1;
9D006834  8FA40010   LW A0, 16(SP)
9D006838  24020001   ADDIU V0, ZERO, 1
3304:                				res = sync(dj.fs);
9D00683C  0F400EC8   JAL 0x9D003B20
9D006840  A0820004   SB V0, 4(A0)
3305:                			}
3306:                		}
3307:                	}
3308:                
3309:                	LEAVE_FF(dj.fs, res);
3310:                }
9D006844  8FBF003C   LW RA, 60(SP)
9D006848  8FB00038   LW S0, 56(SP)
9D00684C  03E00008   JR RA
9D006850  27BD0040   ADDIU SP, SP, 64
3311:                
3312:                /*-----------------------------------------------------------------------*/
3313:                /* Rename File/Directory                                                 */
3314:                /*-----------------------------------------------------------------------*/
3315:                
3316:                FRESULT f_rename(const TCHAR *path_old, /* Pointer to the old name */
3317:                const TCHAR *path_new /* Pointer to the new name */
3318:                ) {
9D006854  27BDFF80   ADDIU SP, SP, -128
9D006858  AFBF007C   SW RA, 124(SP)
9D00685C  AFB10078   SW S1, 120(SP)
9D006860  AFB00074   SW S0, 116(SP)
9D006864  AFA40080   SW A0, 128(SP)
9D006868  00A08021   ADDU S0, A1, ZERO
3319:                	FRESULT res;
3320:                	DIR djo, djn;
3321:                	PF_BYTE buf[21], *dir;
3322:                	DWORD dw;
3323:                	DEF_NAMEBUF;
3324:                
3325:                	res = chk_mounted(&path_old, &djo.fs, 1);
9D00686C  27A40080   ADDIU A0, SP, 128
9D006870  27A50010   ADDIU A1, SP, 16
9D006874  0F4012DA   JAL chk_mounted
9D006878  24060001   ADDIU A2, ZERO, 1
3326:                	if (res == FR_OK) {
9D00687C  14400064   BNE V0, ZERO, 0x9D006A10
9D006880  8FBF007C   LW RA, 124(SP)
3327:                		djn.fs = djo.fs;
9D006884  8FA20010   LW V0, 16(SP)
9D006888  AFA2002C   SW V0, 44(SP)
3328:                		INIT_BUF(djo);
9D00688C  27A20060   ADDIU V0, SP, 96
9D006890  AFA20028   SW V0, 40(SP)
3329:                		res = follow_path(&djo, path_old); /* Check old object */
9D006894  27A40010   ADDIU A0, SP, 16
9D006898  0F401153   JAL 0x9D00454C
9D00689C  8FA50080   LW A1, 128(SP)
3330:                		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
3331:                			res = FR_INVALID_NAME;
3332:                #if _FS_SHARE
3333:                		if (res == FR_OK) res = chk_lock(&djo, 2);
3334:                #endif
3335:                		if (res == FR_OK) { /* Old object is found */
9D0068A0  1440005A   BNE V0, ZERO, 0x9D006A0C
9D0068A4  8FA50024   LW A1, 36(SP)
3336:                			if (!djo.dir) { /* Is root dir? */
9D0068A8  10A00058   BEQ A1, ZERO, 0x9D006A0C
9D0068AC  24020004   ADDIU V0, ZERO, 4
3337:                				res = FR_NO_FILE;
3338:                			} else {
3339:                				mem_cpy(buf, djo.dir + DIR_Attr, 21); /* Save the object information except for name */
9D0068B0  27A40048   ADDIU A0, SP, 72
9D0068B4  24A5000B   ADDIU A1, A1, 11
9D0068B8  0F400DD7   JAL 0x9D00375C
9D0068BC  24060015   ADDIU A2, ZERO, 21
3340:                				mem_cpy(&djn, &djo, sizeof(DIR)); /* Check new object */
9D0068C0  27A4002C   ADDIU A0, SP, 44
9D0068C4  27A50010   ADDIU A1, SP, 16
9D0068C8  0F400DD7   JAL 0x9D00375C
9D0068CC  2406001C   ADDIU A2, ZERO, 28
3341:                				res = follow_path(&djn, path_new);
9D0068D0  27A4002C   ADDIU A0, SP, 44
9D0068D4  0F401153   JAL 0x9D00454C
9D0068D8  02002821   ADDU A1, S0, ZERO
3342:                				if (res == FR_OK)
9D0068DC  5040004B   BEQL V0, ZERO, 0x9D006A0C
9D0068E0  24020008   ADDIU V0, ZERO, 8
3343:                					res = FR_EXIST; /* The new object name is already existing */
3344:                				if (res == FR_NO_FILE) { /* Is it a valid path and no name collision? */
9D0068E4  24030004   ADDIU V1, ZERO, 4
9D0068E8  14430049   BNE V0, V1, 0x9D006A10
9D0068EC  8FBF007C   LW RA, 124(SP)
3345:                					/* Start critical section that any interruption or error can cause cross-link */
3346:                					res = dir_register(&djn); /* Register the new entry */
9D0068F0  0F401241   JAL 0x9D004904
9D0068F4  27A4002C   ADDIU A0, SP, 44
3347:                					if (res == FR_OK) {
9D0068F8  14400045   BNE V0, ZERO, 0x9D006A10
9D0068FC  8FBF007C   LW RA, 124(SP)
3348:                						dir = djn.dir; /* Copy object information except for name */
9D006900  8FB00040   LW S0, 64(SP)
3349:                						mem_cpy(dir + 13, buf + 2, 19);
9D006904  2604000D   ADDIU A0, S0, 13
9D006908  27A5004A   ADDIU A1, SP, 74
9D00690C  0F400DD7   JAL 0x9D00375C
9D006910  24060013   ADDIU A2, ZERO, 19
3350:                						dir[DIR_Attr] = buf[0] | AM_ARC;
9D006914  93A20048   LBU V0, 72(SP)
9D006918  34420020   ORI V0, V0, 32
9D00691C  A202000B   SB V0, 11(S0)
3351:                						djo.fs->wflag = 1;
9D006920  24030001   ADDIU V1, ZERO, 1
9D006924  8FA20010   LW V0, 16(SP)
9D006928  A0430004   SB V1, 4(V0)
3352:                						if (djo.sclust != djn.sclust
9D00692C  8FA20034   LW V0, 52(SP)
9D006930  8FA30018   LW V1, 24(SP)
9D006934  1062002D   BEQ V1, V0, 0x9D0069EC
9D006938  00000000   NOP
3353:                								&& (dir[DIR_Attr] & AM_DIR)) { /* Update .. entry in the directory if needed */
9D00693C  9202000B   LBU V0, 11(S0)
9D006940  30420010   ANDI V0, V0, 16
9D006944  10400029   BEQ V0, ZERO, 0x9D0069EC
9D006948  8FB1002C   LW S1, 44(SP)
3354:                							dw = clust2sect(djn.fs, LD_CLUST(dir));
9D00694C  92050015   LBU A1, 21(S0)
9D006950  00052A00   SLL A1, A1, 8
9D006954  92020014   LBU V0, 20(S0)
9D006958  00A22825   OR A1, A1, V0
9D00695C  00052C00   SLL A1, A1, 16
9D006960  9203001B   LBU V1, 27(S0)
9D006964  00031A00   SLL V1, V1, 8
9D006968  9202001A   LBU V0, 26(S0)
9D00696C  00621025   OR V0, V1, V0
9D006970  02202021   ADDU A0, S1, ZERO
9D006974  0F400F25   JAL clust2sect
9D006978  00A22825   OR A1, A1, V0
9D00697C  00402821   ADDU A1, V0, ZERO
3355:                							if (!dw) {
9D006980  10A00022   BEQ A1, ZERO, 0x9D006A0C
9D006984  24020002   ADDIU V0, ZERO, 2
3356:                								res = FR_INT_ERR;
3357:                							} else {
3358:                								res = move_window(djn.fs, dw);
9D006988  0F400E51   JAL 0x9D003944
9D00698C  02202021   ADDU A0, S1, ZERO
3359:                								dir = djn.fs->win + SZ_DIR; /* .. entry */
3360:                								if (res == FR_OK && dir[1] == '.') {
9D006990  1440001E   BNE V0, ZERO, 0x9D006A0C
9D006994  8FA3002C   LW V1, 44(SP)
9D006998  90640051   LBU A0, 81(V1)
9D00699C  2402002E   ADDIU V0, ZERO, 46
9D0069A0  14820012   BNE A0, V0, 0x9D0069EC
9D0069A4  24020003   ADDIU V0, ZERO, 3
3361:                									dw
3362:                											= (djn.fs->fs_type == FS_FAT32
3363:                													&& djn.sclust
3364:                															== djn.fs->dirbase) ? 0
3365:                													: djn.sclust;
9D0069A8  90640000   LBU A0, 0(V1)
9D0069AC  14820006   BNE A0, V0, 0x9D0069C8
9D0069B0  8FA20034   LW V0, 52(SP)
9D0069B4  8C640024   LW A0, 36(V1)
9D0069B8  8FA50034   LW A1, 52(SP)
9D0069BC  10A40002   BEQ A1, A0, 0x9D0069C8
9D0069C0  00001021   ADDU V0, ZERO, ZERO
9D0069C4  8FA20034   LW V0, 52(SP)
3366:                									ST_CLUST(dir, dw);
9D0069C8  A062006A   SB V0, 106(V1)
9D0069CC  7C443A00   EXT A0, V0, 8, 8
9D0069D0  A064006B   SB A0, 107(V1)
9D0069D4  00021402   SRL V0, V0, 16
9D0069D8  A0620064   SB V0, 100(V1)
9D0069DC  00021202   SRL V0, V0, 8
9D0069E0  A0620065   SB V0, 101(V1)
3367:                									djn.fs->wflag = 1;
9D0069E4  24020001   ADDIU V0, ZERO, 1
9D0069E8  A0620004   SB V0, 4(V1)
3368:                								}
3369:                							}
3370:                						}
3371:                						if (res == FR_OK) {
3372:                							res = dir_remove(&djo); /* Remove old entry */
9D0069EC  0F400FEB   JAL 0x9D003FAC
9D0069F0  27A40010   ADDIU A0, SP, 16
3373:                							if (res == FR_OK)
9D0069F4  54400006   BNEL V0, ZERO, 0x9D006A10
9D0069F8  8FBF007C   LW RA, 124(SP)
3374:                								res = sync(djo.fs);
9D0069FC  0F400EC8   JAL 0x9D003B20
9D006A00  8FA40010   LW A0, 16(SP)
3375:                						}
3376:                					}
3377:                					/* End critical section */
3378:                				}
3379:                			}
3380:                		}FREE_BUF();
3381:                	}
3382:                	LEAVE_FF(djo.fs, res);
3383:                }
9D006A04  0B401A84   J 0x9D006A10
9D006A08  8FBF007C   LW RA, 124(SP)
9D006A0C  8FBF007C   LW RA, 124(SP)
9D006A10  8FB10078   LW S1, 120(SP)
9D006A14  8FB00074   LW S0, 116(SP)
9D006A18  03E00008   JR RA
9D006A1C  27BD0080   ADDIU SP, SP, 128
3384:                
3385:                #endif /* !_FS_READONLY */
3386:                #endif /* _FS_MINIMIZE == 0 */
3387:                #endif /* _FS_MINIMIZE <= 1 */
3388:                #endif /* _FS_MINIMIZE <= 2 */
3389:                
3390:                /*-----------------------------------------------------------------------*/
3391:                /* Forward data to the stream directly (available on only tiny cfg)      */
3392:                /*-----------------------------------------------------------------------*/
3393:                #if _USE_FORWARD && _FS_TINY
3394:                
3395:                FRESULT f_forward (
3396:                		FIL *fp, /* Pointer to the file object */
3397:                		UINT (*func)(const PF_BYTE*,UINT), /* Pointer to the streaming function */
3398:                		UINT btr, /* Number of bytes to forward */
3399:                		UINT *bf /* Pointer to number of bytes forwarded */
3400:                )
3401:                {
3402:                	FRESULT res;
3403:                	DWORD remain, clst, sect;
3404:                	UINT rcnt;
3405:                	PF_BYTE csect;
3406:                
3407:                	*bf = 0; /* Initialize byte counter */
3408:                
3409:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
3410:                	if (res != FR_OK) LEAVE_FF(fp->fs, res);
3411:                	if (fp->flag & FA__ERROR) /* Check error flag */
3412:                	LEAVE_FF(fp->fs, FR_INT_ERR);
3413:                	if (!(fp->flag & FA_READ)) /* Check access mode */
3414:                	LEAVE_FF(fp->fs, FR_DENIED);
3415:                
3416:                	remain = fp->fsize - fp->fptr;
3417:                	if (btr > remain) btr = (UINT)remain; /* Truncate btr by remaining bytes */
3418:                
3419:                	for (; btr && (*func)(0, 0); /* Repeat until all data transferred or stream becomes busy */
3420:                			fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
3421:                		csect = (PF_BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
3422:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
3423:                			if (!csect) { /* On the cluster boundary? */
3424:                				clst = (fp->fptr == 0) ? /* On the top of the file? */
3425:                				fp->sclust : get_fat(fp->fs, fp->clust);
3426:                				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
3427:                				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
3428:                				fp->clust = clst; /* Update current cluster */
3429:                			}
3430:                		}
3431:                		sect = clust2sect(fp->fs, fp->clust); /* Get current data sector */
3432:                		if (!sect) ABORT(fp->fs, FR_INT_ERR);
3433:                		sect += csect;
3434:                		if (move_window(fp->fs, sect)) /* Move sector window */
3435:                		ABORT(fp->fs, FR_DISK_ERR);
3436:                		fp->dsect = sect;
3437:                		rcnt = SS(fp->fs) - (PF_WORD)(fp->fptr % SS(fp->fs)); /* Forward data from sector window */
3438:                		if (rcnt > btr) rcnt = btr;
3439:                		rcnt = (*func)(&fp->fs->win[(PF_WORD)fp->fptr % SS(fp->fs)], rcnt);
3440:                		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
3441:                	}
3442:                
3443:                	LEAVE_FF(fp->fs, FR_OK);
3444:                }
3445:                #endif /* _USE_FORWARD */
3446:                
3447:                #if _USE_MKFS && !_FS_READONLY
3448:                /*-----------------------------------------------------------------------*/
3449:                /* Create File System on the Drive                                       */
3450:                /*-----------------------------------------------------------------------*/
3451:                #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
3452:                #define N_FATS		1		/* Number of FAT copies (1 or 2) */
3453:                
3454:                FRESULT f_mkfs (
3455:                		PF_BYTE drv, /* Logical drive number */
3456:                		PF_BYTE sfd, /* Partitioning rule 0:FDISK, 1:SFD */
3457:                		UINT au /* Allocation unit size [bytes] */
3458:                )
3459:                {
3460:                	static const PF_WORD vst[] = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0};
3461:                	static const PF_WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
3462:                	PF_BYTE fmt, md, sys, *tbl, pdrv, part;
3463:                	DWORD n_clst, vs, n, wsect;
3464:                	UINT i;
3465:                	DWORD b_vol, b_fat, b_dir, b_data; /* LBA */
3466:                	DWORD n_vol, n_rsv, n_fat, n_dir; /* Size */
3467:                	FATFS *fs;
3468:                	DSTATUS stat;
3469:                
3470:                	/* Check mounted drive and clear work area */
3471:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
3472:                	if (sfd > 1) return FR_INVALID_PARAMETER;
3473:                	if (au & (au - 1)) return FR_INVALID_PARAMETER;
3474:                	fs = FatFs[drv];
3475:                	if (!fs) return FR_NOT_ENABLED;
3476:                	fs->fs_type = 0;
3477:                	pdrv = LD2PD(drv); /* Physical drive */
3478:                	part = LD2PT(drv); /* Partition (0:auto detect, 1-4:get from partition table)*/
3479:                
3480:                	/* Get disk statics */
3481:                	stat = disk_initialize(pdrv);
3482:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3483:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3484:                #if _MAX_SS != 512					/* Get disk sector size */
3485:                	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
3486:                	return FR_DISK_ERR;
3487:                #endif
3488:                	if (_MULTI_PARTITION && part) {
3489:                		/* Get partition information from partition table in the MBR */
3490:                		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3491:                		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
3492:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3493:                		if (!tbl[4]) return FR_MKFS_ABORTED; /* No partition? */
3494:                		b_vol = LD_DWORD(tbl+8); /* Volume start sector */
3495:                		n_vol = LD_DWORD(tbl+12); /* Volume size */
3496:                	} else {
3497:                		/* Create a partition in this function */
3498:                		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
3499:                		return FR_DISK_ERR;
3500:                		b_vol = (sfd) ? 0 : 63; /* Volume start sector */
3501:                		n_vol -= b_vol; /* Volume size */
3502:                	}
3503:                
3504:                	if (!au) { /* AU auto selection */
3505:                		vs = n_vol / (2000 / (SS(fs) / 512));
3506:                		for (i = 0; vs < vst[i]; i++);
3507:                		au = cst[i];
3508:                	}
3509:                	au /= SS(fs); /* Number of sectors per cluster */
3510:                	if (au == 0) au = 1;
3511:                	if (au > 128) au = 128;
3512:                
3513:                	/* Pre-compute number of clusters and FAT syb-type */
3514:                	n_clst = n_vol / au;
3515:                	fmt = FS_FAT12;
3516:                	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
3517:                	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
3518:                
3519:                	/* Determine offset and size of FAT structure */
3520:                	if (fmt == FS_FAT32) {
3521:                		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
3522:                		n_rsv = 32;
3523:                		n_dir = 0;
3524:                	} else {
3525:                		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
3526:                		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
3527:                		n_rsv = 1;
3528:                		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
3529:                	}
3530:                	b_fat = b_vol + n_rsv; /* FAT area start sector */
3531:                	b_dir = b_fat + n_fat * N_FATS; /* Directory area start sector */
3532:                	b_data = b_dir + n_dir; /* Data area start sector */
3533:                	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED; /* Too small volume */
3534:                
3535:                	/* Align data start sector to erase block boundary (for flash memory media) */
3536:                	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
3537:                	n = (b_data + n - 1) & ~(n - 1); /* Next nearest erase block from current data start */
3538:                	n = (n - b_data) / N_FATS;
3539:                	if (fmt == FS_FAT32) { /* FAT32: Move FAT offset */
3540:                		n_rsv += n;
3541:                		b_fat += n;
3542:                	} else { /* FAT12/16: Expand FAT size */
3543:                		n_fat += n;
3544:                	}
3545:                
3546:                	/* Determine number of clusters and final check of validity of the FAT sub-type */
3547:                	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
3548:                	if ( (fmt == FS_FAT16 && n_clst < MIN_FAT16)
3549:                			|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
3550:                	return FR_MKFS_ABORTED;
3551:                
3552:                	switch (fmt) { /* Determine system ID for partition table */
3553:                		case FS_FAT12: sys = 0x01; break;
3554:                		case FS_FAT16: sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
3555:                		default: sys = 0x0C;
3556:                	}
3557:                
3558:                	if (_MULTI_PARTITION && part) {
3559:                		/* Update system ID in the partition table */
3560:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3561:                		tbl[4] = sys;
3562:                		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3563:                		md = 0xF8;
3564:                	} else {
3565:                		if (sfd) { /* No patition table (SFD) */
3566:                			md = 0xF0;
3567:                		} else { /* Create partition table (FDISK) */
3568:                			mem_set(fs->win, 0, SS(fs));
3569:                			tbl = fs->win+MBR_Table; /* Create partiton table for single partition in the drive */
3570:                			tbl[1] = 1; /* Partition start head */
3571:                			tbl[2] = 1; /* Partition start sector */
3572:                			tbl[3] = 0; /* Partition start cylinder */
3573:                			tbl[4] = sys; /* System type */
3574:                			tbl[5] = 254; /* Partition end head */
3575:                			n = (b_vol + n_vol) / 63 / 255;
3576:                			tbl[6] = (PF_BYTE)((n >> 2) | 63); /* Partiiton end sector */
3577:                			tbl[7] = (PF_BYTE)n; /* End cylinder */
3578:                			ST_DWORD(tbl+8, 63); /* Partition start in LBA */
3579:                			ST_DWORD(tbl+12, n_vol); /* Partition size in LBA */
3580:                			ST_WORD(fs->win+BS_55AA, 0xAA55); /* MBR signature */
3581:                			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) /* Write it to the MBR sector */
3582:                			return FR_DISK_ERR;
3583:                			md = 0xF8;
3584:                		}
3585:                	}
3586:                
3587:                	/* Create BPB in the VBR */
3588:                	tbl = fs->win; /* Clear sector */
3589:                	mem_set(tbl, 0, SS(fs));
3590:                	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
3591:                	i = SS(fs); /* Sector size */
3592:                	ST_WORD(tbl+BPB_BytsPerSec, i);
3593:                	tbl[BPB_SecPerClus] = (PF_BYTE)au; /* Sectors per cluster */
3594:                	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv); /* Reserved sectors */
3595:                	tbl[BPB_NumFATs] = N_FATS; /* Number of FATs */
3596:                	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR; /* Number of rootdir entries */
3597:                	ST_WORD(tbl+BPB_RootEntCnt, i);
3598:                	if (n_vol < 0x10000) { /* Number of total sectors */
3599:                		ST_WORD(tbl+BPB_TotSec16, n_vol);
3600:                	} else {
3601:                		ST_DWORD(tbl+BPB_TotSec32, n_vol);
3602:                	}
3603:                	tbl[BPB_Media] = md; /* Media descriptor */
3604:                	ST_WORD(tbl+BPB_SecPerTrk, 63); /* Number of sectors per track */
3605:                	ST_WORD(tbl+BPB_NumHeads, 255); /* Number of heads */
3606:                	ST_DWORD(tbl+BPB_HiddSec, b_vol); /* Hidden sectors */
3607:                	n = get_fattime(); /* Use current time as VSN */
3608:                	if (fmt == FS_FAT32) {
3609:                		ST_DWORD(tbl+BS_VolID32, n); /* VSN */
3610:                		ST_DWORD(tbl+BPB_FATSz32, n_fat); /* Number of sectors per FAT */
3611:                		ST_DWORD(tbl+BPB_RootClus, 2); /* Root directory start cluster (2) */
3612:                		ST_WORD(tbl+BPB_FSInfo, 1); /* FSInfo record offset (VBR+1) */
3613:                		ST_WORD(tbl+BPB_BkBootSec, 6); /* Backup boot record offset (VBR+6) */
3614:                		tbl[BS_DrvNum32] = 0x80; /* Drive number */
3615:                		tbl[BS_BootSig32] = 0x29; /* Extended boot signature */
3616:                		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19); /* Volume label, FAT signature */
3617:                	} else {
3618:                		ST_DWORD(tbl+BS_VolID, n); /* VSN */
3619:                		ST_WORD(tbl+BPB_FATSz16, n_fat); /* Number of sectors per FAT */
3620:                		tbl[BS_DrvNum] = 0x80; /* Drive number */
3621:                		tbl[BS_BootSig] = 0x29; /* Extended boot signature */
3622:                		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19); /* Volume label, FAT signature */
3623:                	}
3624:                	ST_WORD(tbl+BS_55AA, 0xAA55); /* Signature (Offset is fixed here regardless of sector size) */
3625:                	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK) /* Write it to the VBR sector */
3626:                	return FR_DISK_ERR;
3627:                	if (fmt == FS_FAT32) /* Write backup VBR if needed (VBR+6) */
3628:                	disk_write(pdrv, tbl, b_vol + 6, 1);
3629:                
3630:                	/* Initialize FAT area */
3631:                	wsect = b_fat;
3632:                	for (i = 0; i < N_FATS; i++) { /* Initialize each FAT copy */
3633:                		mem_set(tbl, 0, SS(fs)); /* 1st sector of the FAT  */
3634:                		n = md; /* Media descriptor byte */
3635:                		if (fmt != FS_FAT32) {
3636:                			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
3637:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT12/16) */
3638:                		} else {
3639:                			n |= 0xFFFFFF00;
3640:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT32) */
3641:                			ST_DWORD(tbl+4, 0xFFFFFFFF);
3642:                			ST_DWORD(tbl+8, 0x0FFFFFFF); /* Reserve cluster #2 for root dir */
3643:                		}
3644:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3645:                		return FR_DISK_ERR;
3646:                		mem_set(tbl, 0, SS(fs)); /* Fill following FAT entries with zero */
3647:                		for (n = 1; n < n_fat; n++) { /* This loop may take a time on FAT32 volume due to many single sector writes */
3648:                			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3649:                			return FR_DISK_ERR;
3650:                		}
3651:                	}
3652:                
3653:                	/* Initialize root directory */
3654:                	i = (fmt == FS_FAT32) ? au : n_dir;
3655:                	do {
3656:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3657:                		return FR_DISK_ERR;
3658:                	}while (--i);
3659:                
3660:                #if _USE_ERASE	/* Erase data area if needed */
3661:                	{
3662:                		DWORD eb[2];
3663:                
3664:                		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
3665:                		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
3666:                	}
3667:                #endif
3668:                
3669:                	/* Create FSInfo if needed */
3670:                	if (fmt == FS_FAT32) {
3671:                		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
3672:                		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
3673:                		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1); /* Number of free clusters */
3674:                		ST_DWORD(tbl+FSI_Nxt_Free, 2); /* Last allocated cluster# */
3675:                		ST_WORD(tbl+BS_55AA, 0xAA55);
3676:                		disk_write(pdrv, tbl, b_vol + 1, 1); /* Write original (VBR+1) */
3677:                		disk_write(pdrv, tbl, b_vol + 7, 1); /* Write backup (VBR+7) */
3678:                	}
3679:                
3680:                	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
3681:                }
3682:                
3683:                #if _MULTI_PARTITION == 2
3684:                /*-----------------------------------------------------------------------*/
3685:                /* Divide Physical Drive                                                 */
3686:                /*-----------------------------------------------------------------------*/
3687:                
3688:                FRESULT f_fdisk (
3689:                		PF_BYTE pdrv, /* Physical drive number */
3690:                		const DWORD szt[], /* Pointer to the size table for each partitions */
3691:                		void* work /* Pointer to the working buffer */
3692:                )
3693:                {
3694:                	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
3695:                	PF_BYTE s_hd, e_hd, *p, *buf = (PF_BYTE*)work;
3696:                	DSTATUS stat;
3697:                	DWORD sz_disk, sz_part, s_part;
3698:                
3699:                	stat = disk_initialize(pdrv);
3700:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3701:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3702:                	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
3703:                
3704:                	/* Determine CHS in the table regardless of the drive geometry */
3705:                	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2);
3706:                	if (n == 256) n--;
3707:                	e_hd = n - 1;
3708:                	sz_cyl = 63 * n;
3709:                	tot_cyl = sz_disk / sz_cyl;
3710:                
3711:                	/* Create partition table */
3712:                	mem_set(buf, 0, _MAX_SS);
3713:                	p = buf + MBR_Table; b_cyl = 0;
3714:                	for (i = 0; i < 4; i++, p += SZ_PTE) {
3715:                		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
3716:                		if (!p_cyl) continue;
3717:                		s_part = (DWORD)sz_cyl * b_cyl;
3718:                		sz_part = (DWORD)sz_cyl * p_cyl;
3719:                		if (i == 0) { /* Exclude first track of cylinder 0 */
3720:                			s_hd = 1;
3721:                			s_part += 63; sz_part -= 63;
3722:                		} else {
3723:                			s_hd = 0;
3724:                		}
3725:                		e_cyl = b_cyl + p_cyl - 1;
3726:                		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
3727:                
3728:                		/* Set partition table */
3729:                		p[1] = s_hd; /* Start head */
3730:                		p[2] = (PF_BYTE)((b_cyl >> 2) + 1); /* Start sector */
3731:                		p[3] = (PF_BYTE)b_cyl; /* Start cylinder */
3732:                		p[4] = 0x06; /* System type (temporary setting) */
3733:                		p[5] = e_hd; /* End head */
3734:                		p[6] = (PF_BYTE)((e_cyl >> 2) + 63); /* End sector */
3735:                		p[7] = (PF_BYTE)e_cyl; /* End cylinder */
3736:                		ST_DWORD(p + 8, s_part); /* Start sector in LBA */
3737:                		ST_DWORD(p + 12, sz_part); /* Partition size */
3738:                
3739:                		/* Next partition */
3740:                		b_cyl += p_cyl;
3741:                	}
3742:                	ST_WORD(p, 0xAA55);
3743:                
3744:                	/* Write it to the MBR */
3745:                	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
3746:                }
3747:                
3748:                #endif /* _MULTI_PARTITION == 2 */
3749:                #endif /* _USE_MKFS && !_FS_READONLY */
3750:                
3751:                #if _USE_STRFUNC
3752:                /*-----------------------------------------------------------------------*/
3753:                /* Get a string from the file                                            */
3754:                /*-----------------------------------------------------------------------*/
3755:                TCHAR* f_gets (
3756:                		TCHAR* buff, /* Pointer to the string buffer to read */
3757:                		int len, /* Size of string buffer (characters) */
3758:                		FIL* fil /* Pointer to the file object */
3759:                )
3760:                {
3761:                	int n = 0;
3762:                	TCHAR c, *p = buff;
3763:                	PF_BYTE s[2];
3764:                	UINT rc;
3765:                
3766:                	while (n < len - 1) { /* Read bytes until buffer gets filled */
3767:                		f_read(fil, s, 1, &rc);
3768:                		if (rc != 1) break; /* Break on EOF or error */
3769:                		c = s[0];
3770:                #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
3771:                		if (c >= 0x80) {
3772:                			if (c < 0xC0) continue; /* Skip stray trailer */
3773:                			if (c < 0xE0) { /* Two-byte sequense */
3774:                				f_read(fil, s, 1, &rc);
3775:                				if (rc != 1) break;
3776:                				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
3777:                				if (c < 0x80) c = '?';
3778:                			} else {
3779:                				if (c < 0xF0) { /* Three-byte sequense */
3780:                					f_read(fil, s, 2, &rc);
3781:                					if (rc != 2) break;
3782:                					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
3783:                					if (c < 0x800) c = '?';
3784:                				} else { /* Reject four-byte sequense */
3785:                					c = '?';
3786:                				}
3787:                			}
3788:                		}
3789:                #endif
3790:                #if _USE_STRFUNC >= 2
3791:                		if (c == '\r') continue; /* Strip '\r' */
3792:                #endif
3793:                		*p++ = c;
3794:                		n++;
3795:                		if (c == '\n') break; /* Break on EOL */
3796:                	}
3797:                	*p = 0;
3798:                	return n ? buff : 0; /* When no data read (eof or error), return with error. */
3799:                }
3800:                
3801:                #if !_FS_READONLY
3802:                #include <stdarg.h>
3803:                /*-----------------------------------------------------------------------*/
3804:                /* Put a character to the file                                           */
3805:                /*-----------------------------------------------------------------------*/
3806:                int f_putc (
3807:                		TCHAR c, /* A character to be output */
3808:                		FIL* fil /* Pointer to the file object */
3809:                )
3810:                {
3811:                	UINT bw, btw;
3812:                	PF_BYTE s[3];
3813:                
3814:                #if _USE_STRFUNC >= 2
3815:                	if (c == '\n') f_putc ('\r', fil); /* LF -> CRLF conversion */
3816:                #endif
3817:                
3818:                #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
3819:                	if (c < 0x80) { /* 7-bit */
3820:                		s[0] = (PF_BYTE)c;
3821:                		btw = 1;
3822:                	} else {
3823:                		if (c < 0x800) { /* 11-bit */
3824:                			s[0] = (PF_BYTE)(0xC0 | (c >> 6));
3825:                			s[1] = (PF_BYTE)(0x80 | (c & 0x3F));
3826:                			btw = 2;
3827:                		} else { /* 16-bit */
3828:                			s[0] = (PF_BYTE)(0xE0 | (c >> 12));
3829:                			s[1] = (PF_BYTE)(0x80 | ((c >> 6) & 0x3F));
3830:                			s[2] = (PF_BYTE)(0x80 | (c & 0x3F));
3831:                			btw = 3;
3832:                		}
3833:                	}
3834:                #else				/* Write the character without conversion */
3835:                	s[0] = (PF_BYTE)c;
3836:                	btw = 1;
3837:                #endif
3838:                	f_write(fil, s, btw, &bw); /* Write the char to the file */
3839:                	return (bw == btw) ? 1 : EOF; /* Return the result */
3840:                }
3841:                
3842:                /*-----------------------------------------------------------------------*/
3843:                /* Put a string to the file                                              */
3844:                /*-----------------------------------------------------------------------*/
3845:                int f_puts (
3846:                		const TCHAR* str, /* Pointer to the string to be output */
3847:                		FIL* fil /* Pointer to the file object */
3848:                )
3849:                {
3850:                	int n;
3851:                
3852:                	for (n = 0; *str; str++, n++) {
3853:                		if (f_putc(*str, fil) == EOF) return EOF;
3854:                	}
3855:                	return n;
3856:                }
3857:                
3858:                /*-----------------------------------------------------------------------*/
3859:                /* Put a formatted string to the file                                    */
3860:                /*-----------------------------------------------------------------------*/
3861:                int f_printf (
3862:                		FIL* fil, /* Pointer to the file object */
3863:                		const TCHAR* str, /* Pointer to the format string */
3864:                		... /* Optional arguments... */
3865:                )
3866:                {
3867:                	va_list arp;
3868:                	PF_BYTE f, r;
3869:                	UINT i, j, w;
3870:                	ULONG v;
3871:                	TCHAR c, d, s[16], *p;
3872:                	int res, chc, cc;
3873:                
3874:                	va_start(arp, str);
3875:                
3876:                	for (cc = res = 0; cc != EOF; res += cc) {
3877:                		c = *str++;
3878:                		if (c == 0) break; /* End of string */
3879:                		if (c != '%') { /* Non escape character */
3880:                			cc = f_putc(c, fil);
3881:                			if (cc != EOF) cc = 1;
3882:                			continue;
3883:                		}
3884:                		w = f = 0;
3885:                		c = *str++;
3886:                		if (c == '0') { /* Flag: '0' padding */
3887:                			f = 1; c = *str++;
3888:                		} else {
3889:                			if (c == '-') { /* Flag: left justified */
3890:                				f = 2; c = *str++;
3891:                			}
3892:                		}
3893:                		while (IsDigit(c)) { /* Precision */
3894:                			w = w * 10 + c - '0';
3895:                			c = *str++;
3896:                		}
3897:                		if (c == 'l' || c == 'L') { /* Prefix: Size is long int */
3898:                			f |= 4; c = *str++;
3899:                		}
3900:                		if (!c) break;
3901:                		d = c;
3902:                		if (IsLower(d)) d -= 0x20;
3903:                		switch (d) { /* Type is... */
3904:                			case 'S' : /* String */
3905:                			p = va_arg(arp, TCHAR*);
3906:                			for (j = 0; p[j]; j++);
3907:                			chc = 0;
3908:                			if (!(f & 2)) {
3909:                				while (j++ < w) chc += (cc = f_putc(' ', fil));
3910:                			}
3911:                			chc += (cc = f_puts(p, fil));
3912:                			while (j++ < w) chc += (cc = f_putc(' ', fil));
3913:                			if (cc != EOF) cc = chc;
3914:                			continue;
3915:                			case 'C' : /* Character */
3916:                			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
3917:                			case 'B' : /* Binary */
3918:                			r = 2; break;
3919:                			case 'O' : /* Octal */
3920:                			r = 8; break;
3921:                			case 'D' : /* Signed decimal */
3922:                			case 'U' : /* Unsigned decimal */
3923:                			r = 10; break;
3924:                			case 'X' : /* Hexdecimal */
3925:                			r = 16; break;
3926:                			default: /* Unknown type (passthrough) */
3927:                			cc = f_putc(c, fil); continue;
3928:                		}
3929:                
3930:                		/* Get an argument and put it in numeral */
3931:                		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
3932:                		if (d == 'D' && (v & 0x80000000)) {
3933:                			v = 0 - v;
3934:                			f |= 8;
3935:                		}
3936:                		i = 0;
3937:                		do {
3938:                			d = (TCHAR)(v % r); v /= r;
3939:                			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
3940:                			s[i++] = d + '0';
3941:                		}while (v && i < sizeof(s) / sizeof(s[0]));
3942:                		if (f & 8) s[i++] = '-';
3943:                		j = i; d = (f & 1) ? '0' : ' ';
3944:                		res = 0;
3945:                		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
3946:                		do res += (cc = f_putc(s[--i], fil)); while(i);
3947:                		while (j++ < w) res += (cc = f_putc(' ', fil));
3948:                		if (cc != EOF) cc = res;
3949:                	}
3950:                
3951:                	va_end(arp);
3952:                	return (cc == EOF) ? cc : res;
3953:                }
3954:                
3955:                #endif /* !_FS_READONLY */
3956:                #endif /* _USE_STRFUNC */
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/diskio.c  -----------------------------
1:                   /*------------------------------------------------------------------------/
2:                    /  MMCv3/SDv1/SDv2 (in SPI mode) control module
3:                    /-------------------------------------------------------------------------/
4:                    /
5:                    /  Copyright (C) 2010, ChaN, all right reserved.
6:                    /
7:                    / * This software is a free software and there is NO WARRANTY.
8:                    / * No restriction on use. You can use, modify and redistribute it for
9:                    /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
10:                   / * Redistributions of source code must retain the above copyright notice.
11:                   /
12:                   /-------------------------------------------------------------------------*/
13:                  
14:                  // 07 May 2012 Changes made to allow SD card library to support
15:                  //					PIC32 Pinguino Micro and potentially other cards that
16:                  //					do not support the use of the RTCC library.
17:                  // 25 May 2012 Added includes for delay.c and digitalw.c
18:                  
19:                  //#include "ff.h"
20:                  #include "diskio.h"
21:                  //#include <delay.c>
22:                  //#include <digitalw.c>
23:                  #include "../HardwareProfile.h"
24:                  #include "sdmmc.h"
25:                  
26:                  // For boards known to support the RTCC library ***Added 07 May 2012
27:                  // to allow SD Library to support PIC32 Pinguino Micro, which
28:                  // which does not have a RTCC crystal and associated components,
29:                  // and would not operate if #include <rtcc.c> is included.
30:                  // See also changes to get_fattime() below.
31:                  
32:                  #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
33:                  	#include <rtcc.c>
34:                  #endif
35:                  
36:                  /* Definitions for MMC/SDC command */
37:                  #define CMD0   (0)			/* GO_IDLE_STATE */
38:                  #define CMD1   (1)			/* SEND_OP_COND */
39:                  #define ACMD41 (41|0x80)	/* SEND_OP_COND (SDC) */
40:                  #define CMD8   (8)			/* SEND_IF_COND */
41:                  #define CMD9   (9)			/* SEND_CSD */
42:                  #define CMD10  (10)			/* SEND_CID */
43:                  #define CMD12  (12)			/* STOP_TRANSMISSION */
44:                  #define ACMD13 (13|0x80)	/* SD_STATUS (SDC) */
45:                  #define CMD16  (16)			/* SET_BLOCKLEN */
46:                  #define CMD17  (17)			/* READ_SINGLE_BLOCK */
47:                  #define CMD18  (18)			/* READ_MULTIPLE_BLOCK */
48:                  #define CMD23  (23)			/* SET_BLOCK_COUNT */
49:                  #define ACMD23 (23|0x80)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
50:                  #define CMD24  (24)			/* WRITE_BLOCK */
51:                  #define CMD25  (25)			/* WRITE_MULTIPLE_BLOCK */
52:                  #define CMD41  (41)			/* SEND_OP_COND (ACMD) */
53:                  #define CMD55  (55)			/* APP_CMD */
54:                  #define CMD58  (58)			/* READ_OCR */
55:                  
56:                  /* Port Controls  (Platform dependent) */
57:                  //#define SOCKPORT	PORTB		/* Socket contact port */
58:                  //#define SOCKWP	(1<<10)		/* Write protect switch (RB10) */
59:                  //#define SOCKINS	(1<<11)		/* Card detect switch (RB11) */
60:                  
61:                  //#define	FCLK_SLOW()			/* Set slow clock (100k-400k) */
62:                  //#define	FCLK_FAST()			/* Set fast clock (depends on the CSD) */
63:                  
64:                  
65:                  /*--------------------------------------------------------------------------
66:                  
67:                   Module Private Functions
68:                  
69:                   ---------------------------------------------------------------------------*/
70:                  
71:                  static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
72:                  
73:                  static volatile UINT16 Timer1, Timer2; /* 1000Hz decrement timer */
74:                  
75:                  static UINT16 CardType;
76:                  
77:                  /*-----------------------------------------------------------------------*/
78:                  /* Exchange a byte between PIC and MMC via SPI  (Platform dependent)     */
79:                  /*-----------------------------------------------------------------------*/
80:                  
81:                  #define xmit_spi(dat) 	writeSPI(dat)
82:                  #define rcvr_spi()	writeSPI(0xFF)
83:                  #define rcvr_spi_m(p)	SPI2BUF = 0xFF; while (!SPI2STATbits.SPIRBF); *(p) = (PF_BYTE)SPI2BUF;
84:                  #define xchg_spi (dat)  writeSPI(dat)
85:                  #define DLY_US(i)	delay_us(i)
86:                  #define CS_H()		(PORTB|=SDCSEL)//digitalwrite(SDCS, HIGH)
87:                  #define CS_L()		(PORTB&=~SDCSEL)//digitalwrite(SDCS, LOW)
88:                  
89:                  /*-----------------------------------------------------------------------*/
90:                  /* Wait for card ready                                                   */
91:                  /*-----------------------------------------------------------------------*/
92:                  
93:                  static
94:                  int wait_ready(void) {
9D00883C  27BDFFE0   ADDIU SP, SP, -32
9D008840  AFBF001C   SW RA, 28(SP)
9D008844  AFB10018   SW S1, 24(SP)
9D008848  AFB00014   SW S0, 20(SP)
9D00884C  24111388   ADDIU S1, ZERO, 5000
95:                  	PF_BYTE d;
96:                  	UINT16 tmr;
97:                  
98:                  	for (tmr = 5000; tmr; tmr--) { /* Wait for ready in timeout of 500ms */
9D008878  1620FFF5   BNE S1, ZERO, 0x9D008850
9D00887C  3A0200FF   XORI V0, S0, 255
99:                  		d = rcvr_spi();
9D008850  0F4030D9   JAL writeSPI
9D008854  240400FF   ADDIU A0, ZERO, 255
9D008858  00408021   ADDU S0, V0, ZERO
100:                 		if (d == 0xFF)
9D00885C  240200FF   ADDIU V0, ZERO, 255
9D008860  12020007   BEQ S0, V0, 0x9D008880
9D008864  3A0200FF   XORI V0, S0, 255
101:                 			break;
102:                 		DLY_US(100);
9D008868  0F40355F   JAL delay_us
9D00886C  24040064   ADDIU A0, ZERO, 100
9D008870  2631FFFF   ADDIU S1, S1, -1
9D008874  3231FFFF   ANDI S1, S1, -1
103:                 	}
104:                 
105:                 	return (d == 0xFF) ? 1 : 0;
106:                 }
9D008880  2C420001   SLTIU V0, V0, 1
9D008884  8FBF001C   LW RA, 28(SP)
9D008888  8FB10018   LW S1, 24(SP)
9D00888C  8FB00014   LW S0, 20(SP)
9D008890  03E00008   JR RA
9D008894  27BD0020   ADDIU SP, SP, 32
107:                 
108:                 /*-----------------------------------------------------------------------*/
109:                 /* Deselect the card and release SPI bus                                 */
110:                 /*-----------------------------------------------------------------------*/
111:                 
112:                 #define deselect() disableSD();
113:                 
114:                 /*-----------------------------------------------------------------------*/
115:                 /* Select the card and wait ready                                        */
116:                 /*-----------------------------------------------------------------------*/
117:                 
118:                 static int select(void) /* 1:Successful, 0:Timeout */
119:                 {
9D008898  27BDFFE8   ADDIU SP, SP, -24
9D00889C  AFBF0014   SW RA, 20(SP)
120:                 	enableSD();
9D0088A0  0F403100   JAL enableSD
9D0088A4  00000000   NOP
121:                 	rcvr_spi(); /* Dummy clock (force DO enabled) */
9D0088A8  0F4030D9   JAL writeSPI
9D0088AC  240400FF   ADDIU A0, ZERO, 255
122:                 
123:                 	if (wait_ready())
9D0088B0  0F40220F   JAL 0x9D00883C
9D0088B4  00000000   NOP
9D0088B8  14400004   BNE V0, ZERO, 0x9D0088CC
9D0088BC  24030001   ADDIU V1, ZERO, 1
124:                 		return 1; /* OK */
125:                 	deselect();
9D0088C0  0F4030F5   JAL disableSD
9D0088C4  00000000   NOP
126:                 	return 0; /* Timeout */
9D0088C8  00001821   ADDU V1, ZERO, ZERO
127:                 }
9D0088CC  00601021   ADDU V0, V1, ZERO
9D0088D0  8FBF0014   LW RA, 20(SP)
9D0088D4  03E00008   JR RA
9D0088D8  27BD0018   ADDIU SP, SP, 24
128:                 
129:                 /*-----------------------------------------------------------------------*/
130:                 /* Receive a data packet from MMC                                        */
131:                 /*-----------------------------------------------------------------------*/
132:                 
133:                 static int rcvr_datablock( /* 1:OK, 0:Failed */
9D008B60  0B4022B9   J 0x9D008AE4
9D008B64  26310004   ADDIU S1, S1, 4
134:                                           PF_BYTE *buff, /* Data buffer to store received data */
135:                                           UINT16 btr /* Byte count (must be multiple of 4) */
136:                                           ) {
9D008A7C  27BDFFE0   ADDIU SP, SP, -32
9D008A80  AFBF001C   SW RA, 28(SP)
9D008A84  AFB20018   SW S2, 24(SP)
9D008A88  AFB10014   SW S1, 20(SP)
9D008A8C  AFB00010   SW S0, 16(SP)
9D008A90  00808821   ADDU S1, A0, ZERO
9D008A94  00A09021   ADDU S2, A1, ZERO
9D008A98  241003E8   ADDIU S0, ZERO, 1000
137:                 	PF_BYTE d;
138:                 	UINT16 tmr;
139:                 
140:                 	for (tmr = 1000; tmr; tmr--) { /* Wait for data packet in timeout of 100ms */
9D008AC0  1600FFF6   BNE S0, ZERO, 0x9D008A9C
9D008AC4  00001821   ADDU V1, ZERO, ZERO
141:                 		d = rcvr_spi();
9D008A9C  0F4030D9   JAL writeSPI
9D008AA0  240400FF   ADDIU A0, ZERO, 255
142:                 		if (d != 0xFF)
9D008AA4  240300FF   ADDIU V1, ZERO, 255
9D008AA8  14430009   BNE V0, V1, 0x9D008AD0
9D008AAC  240400FE   ADDIU A0, ZERO, 254
143:                 			break;
144:                 		DLY_US(100);
9D008AB0  0F40355F   JAL delay_us
9D008AB4  24040064   ADDIU A0, ZERO, 100
9D008AB8  2610FFFF   ADDIU S0, S0, -1
9D008ABC  3210FFFF   ANDI S0, S0, -1
145:                 	}
146:                 	if (d != 0xFE)
9D008AD0  1444002A   BNE V0, A0, 0x9D008B7C
9D008AD4  00001821   ADDU V1, ZERO, ZERO
147:                 		return 0; /* If not valid data token, return with error */
148:                 
149:                 	do { /* Receive the data block into buffer */
150:                 		rcvr_spi_m(buff++);
9D008AD8  3C04BF80   LUI A0, -16512
9D008ADC  240500FF   ADDIU A1, ZERO, 255
9D008AE0  3C02BF80   LUI V0, -16512
9D008AE4  AC855A20   SW A1, 23072(A0)
9D008AE8  8C435A10   LW V1, 23056(V0)
9D008AEC  30630001   ANDI V1, V1, 1
9D008AF0  1060FFFD   BEQ V1, ZERO, 0x9D008AE8
9D008AF4  00000000   NOP
9D008AF8  8C835A20   LW V1, 23072(A0)
9D008AFC  A2230000   SB V1, 0(S1)
151:                 		rcvr_spi_m(buff++);
9D008B00  AC855A20   SW A1, 23072(A0)
9D008B04  8C435A10   LW V1, 23056(V0)
9D008B08  30630001   ANDI V1, V1, 1
9D008B0C  1060FFFD   BEQ V1, ZERO, 0x9D008B04
9D008B10  00000000   NOP
9D008B14  8C835A20   LW V1, 23072(A0)
9D008B18  A2230001   SB V1, 1(S1)
152:                 		rcvr_spi_m(buff++);
9D008B1C  AC855A20   SW A1, 23072(A0)
9D008B20  8C435A10   LW V1, 23056(V0)
9D008B24  30630001   ANDI V1, V1, 1
9D008B28  1060FFFD   BEQ V1, ZERO, 0x9D008B20
9D008B2C  00000000   NOP
9D008B30  8C835A20   LW V1, 23072(A0)
9D008B34  A2230002   SB V1, 2(S1)
153:                 		rcvr_spi_m(buff++);
9D008B38  AC855A20   SW A1, 23072(A0)
9D008B3C  8C435A10   LW V1, 23056(V0)
9D008B40  30630001   ANDI V1, V1, 1
9D008B44  1060FFFD   BEQ V1, ZERO, 0x9D008B3C
9D008B48  00000000   NOP
9D008B4C  8C835A20   LW V1, 23072(A0)
154:                 	} while (btr -= 4);
9D008B50  2652FFFC   ADDIU S2, S2, -4
9D008B54  3252FFFF   ANDI S2, S2, -1
9D008B58  12400003   BEQ S2, ZERO, 0x9D008B68
9D008B5C  A2230003   SB V1, 3(S1)
155:                 	rcvr_spi(); /* Discard CRC */
9D008B68  0F4030D9   JAL writeSPI
9D008B6C  240400FF   ADDIU A0, ZERO, 255
156:                 	rcvr_spi();
9D008B70  0F4030D9   JAL writeSPI
9D008B74  240400FF   ADDIU A0, ZERO, 255
157:                 
158:                 	return 1; /* Return with success */
9D008B78  24030001   ADDIU V1, ZERO, 1
159:                 }
9D008AC8  0B4022E0   J 0x9D008B80
9D008ACC  00601021   ADDU V0, V1, ZERO
9D008B7C  00601021   ADDU V0, V1, ZERO
9D008B80  8FBF001C   LW RA, 28(SP)
9D008B84  8FB20018   LW S2, 24(SP)
9D008B88  8FB10014   LW S1, 20(SP)
9D008B8C  8FB00010   LW S0, 16(SP)
9D008B90  03E00008   JR RA
9D008B94  27BD0020   ADDIU SP, SP, 32
160:                 
161:                 /*-----------------------------------------------------------------------*/
162:                 /* Send a data packet to MMC                                             */
163:                 /*-----------------------------------------------------------------------*/
164:                 
165:                 #if _READONLY == 0
166:                 static int xmit_datablock( /* 1:OK, 0:Failed */
9D008A20  26110200   ADDIU S1, S0, 512
9D008A5C  38630005   XORI V1, V1, 5
9D008A60  2C630001   SLTIU V1, V1, 1
167:                                           const PF_BYTE *buff, /* 512 byte data block to be transmitted */
168:                                           PF_BYTE token /* Data token */
169:                                           ) {
9D0089E8  27BDFFE0   ADDIU SP, SP, -32
9D0089EC  AFBF001C   SW RA, 28(SP)
9D0089F0  AFB10018   SW S1, 24(SP)
9D0089F4  AFB00014   SW S0, 20(SP)
9D0089F8  00808021   ADDU S0, A0, ZERO
170:                 	PF_BYTE resp;
171:                 	UINT16 bc = BLK_SIZE;
172:                 
173:                 	if (!wait_ready())
9D0089FC  0F40220F   JAL 0x9D00883C
9D008A00  00A08821   ADDU S1, A1, ZERO
9D008A04  10400017   BEQ V0, ZERO, 0x9D008A64
9D008A08  00001821   ADDU V1, ZERO, ZERO
174:                 		return 0;
175:                 
176:                 	xmit_spi(token); /* Xmit a token */
9D008A0C  0F4030D9   JAL writeSPI
9D008A10  02202021   ADDU A0, S1, ZERO
177:                 	if (token != 0xFD) { /* Not StopTran token */
9D008A14  240200FD   ADDIU V0, ZERO, 253
9D008A18  12220012   BEQ S1, V0, 0x9D008A64
9D008A1C  24030001   ADDIU V1, ZERO, 1
178:                 		do { /* Xmit the 512 byte data block to the MMC */
179:                 			xmit_spi(*buff++);
9D008A24  0F4030D9   JAL writeSPI
9D008A28  92040000   LBU A0, 0(S0)
180:                 			xmit_spi(*buff++);
9D008A2C  92040001   LBU A0, 1(S0)
9D008A30  0F4030D9   JAL writeSPI
9D008A34  26100002   ADDIU S0, S0, 2
181:                 		} while (bc -= 2);
9D008A38  1630FFFA   BNE S1, S0, 0x9D008A24
9D008A3C  00000000   NOP
182:                 		xmit_spi(0xFF); /* CRC (Dummy) */
9D008A40  0F4030D9   JAL writeSPI
9D008A44  240400FF   ADDIU A0, ZERO, 255
183:                 		xmit_spi(0xFF);
9D008A48  0F4030D9   JAL writeSPI
9D008A4C  240400FF   ADDIU A0, ZERO, 255
184:                 		resp = rcvr_spi(); /* Receive a data response */
9D008A50  0F4030D9   JAL writeSPI
9D008A54  240400FF   ADDIU A0, ZERO, 255
185:                 		if ((resp & 0x1F) != 0x05) /* If not accepted, return with error */
9D008A58  3043001F   ANDI V1, V0, 31
186:                 			return 0;
187:                 	}
188:                 
189:                 	return 1;
190:                 }
9D008A64  00601021   ADDU V0, V1, ZERO
9D008A68  8FBF001C   LW RA, 28(SP)
9D008A6C  8FB10018   LW S1, 24(SP)
9D008A70  8FB00014   LW S0, 20(SP)
9D008A74  03E00008   JR RA
9D008A78  27BD0020   ADDIU SP, SP, 32
191:                 #endif	/* _READONLY */
192:                 
193:                 /*-----------------------------------------------------------------------*/
194:                 /* Send a command packet to MMC                                          */
195:                 /*-----------------------------------------------------------------------*/
196:                 
197:                 static PF_BYTE send_cmd(PF_BYTE cmd, /* Command byte */
198:                                         DWORD arg /* Argument */
199:                                         ) {
9D0088DC  27BDFFE0   ADDIU SP, SP, -32
9D0088E0  AFBF001C   SW RA, 28(SP)
9D0088E4  AFB10018   SW S1, 24(SP)
9D0088E8  AFB00014   SW S0, 20(SP)
9D0088EC  00A08821   ADDU S1, A1, ZERO
9D008988  2410000A   ADDIU S0, ZERO, 10
9D0089D0  0B402263   J 0x9D00898C
9D0089D4  2410000A   ADDIU S0, ZERO, 10
9D0089E0  0B402263   J 0x9D00898C
9D0089E4  2410000A   ADDIU S0, ZERO, 10
200:                 	PF_BYTE n, res;
201:                 
202:                 	if (cmd & 0x80) { /* ACMD<n> is the command sequense of CMD55-CMD<n> */
9D0088F0  7C041420   SEB V0, A0
9D0088F4  04410009   BGEZ V0, 0x9D00891C
9D0088F8  00808021   ADDU S0, A0, ZERO
203:                 		cmd &= 0x7F;
9D008918  3210007F   ANDI S0, S0, 127
204:                 		res = send_cmd(CMD55, 0);
9D0088FC  24040037   ADDIU A0, ZERO, 55
9D008900  0F402237   JAL 0x9D0088DC
9D008904  00002821   ADDU A1, ZERO, ZERO
9D008908  00401821   ADDU V1, V0, ZERO
205:                 		if (res > 1)
9D00890C  2C420002   SLTIU V0, V0, 2
9D008910  10400028   BEQ V0, ZERO, 0x9D0089B4
9D008914  00601021   ADDU V0, V1, ZERO
206:                 			return res;
207:                 	}
208:                 
209:                 	/* Select the card and wait for ready */
210:                 	deselect();
9D00891C  0F4030F5   JAL disableSD
9D008920  00000000   NOP
211:                 	if (!select())
9D008924  0F402226   JAL 0x9D008898
9D008928  00000000   NOP
9D00892C  10400020   BEQ V0, ZERO, 0x9D0089B0
9D008930  240300FF   ADDIU V1, ZERO, 255
212:                 		return 0xFF;
213:                 
214:                 	/* Send command packet */
215:                 	xmit_spi(0x40 | cmd); /* Start + Command index */
9D008934  0F4030D9   JAL writeSPI
9D008938  36040040   ORI A0, S0, 64
216:                 	xmit_spi((PF_BYTE)(arg >> 24)); /* Argument[31..24] */
9D00893C  0F4030D9   JAL writeSPI
9D008940  00112602   SRL A0, S1, 24
217:                 	xmit_spi((PF_BYTE)(arg >> 16)); /* Argument[23..16] */
9D008944  0F4030D9   JAL writeSPI
9D008948  7E243C00   EXT A0, S1, 16, 8
218:                 	xmit_spi((PF_BYTE)(arg >> 8)); /* Argument[15..8] */
9D00894C  0F4030D9   JAL writeSPI
9D008950  7E243A00   EXT A0, S1, 8, 8
219:                 	xmit_spi((PF_BYTE)arg); /* Argument[7..0] */
9D008954  0F4030D9   JAL writeSPI
9D008958  322400FF   ANDI A0, S1, 255
220:                 	n = 0x01; /* Dummy CRC + Stop */
221:                 	if (cmd == CMD0)
9D00895C  1200001E   BEQ S0, ZERO, 0x9D0089D8
9D008960  24020008   ADDIU V0, ZERO, 8
222:                 		n = 0x95; /* Valid CRC for CMD0(0) */
223:                 	if (cmd == CMD8)
9D008964  12020018   BEQ S0, V0, 0x9D0089C8
9D008968  00000000   NOP
224:                 		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
225:                 	xmit_spi(n);
9D00896C  0F4030D9   JAL writeSPI
9D008970  24040001   ADDIU A0, ZERO, 1
9D0089C8  0F4030D9   JAL writeSPI
9D0089CC  24040087   ADDIU A0, ZERO, 135
9D0089D8  0F4030D9   JAL writeSPI
9D0089DC  24040095   ADDIU A0, ZERO, 149
226:                 
227:                 	/* Receive command response */
228:                 	if (cmd == CMD12)
9D008974  2402000C   ADDIU V0, ZERO, 12
9D008978  16020004   BNE S0, V0, 0x9D00898C
9D00897C  2410000A   ADDIU S0, ZERO, 10
229:                 		rcvr_spi(); /* Skip a stuff byte when stop reading */
9D008980  0F4030D9   JAL writeSPI
9D008984  240400FF   ADDIU A0, ZERO, 255
230:                 	n = 10; /* Wait for a valid response in timeout of 10 attempts */
231:                 	do
232:                 		res = rcvr_spi();
9D00898C  0F4030D9   JAL writeSPI
9D008990  240400FF   ADDIU A0, ZERO, 255
9D008994  00401821   ADDU V1, V0, ZERO
233:                 	while ((res & 0x80) && --n);
9D008998  7C021420   SEB V0, V0
9D00899C  04410004   BGEZ V0, 0x9D0089B0
9D0089A0  2610FFFF   ADDIU S0, S0, -1
9D0089A4  321000FF   ANDI S0, S0, 255
9D0089A8  1600FFF8   BNE S0, ZERO, 0x9D00898C
9D0089AC  00000000   NOP
234:                 
235:                 	return res; /* Return with the response value */
236:                 }
9D0089B0  00601021   ADDU V0, V1, ZERO
9D0089B4  8FBF001C   LW RA, 28(SP)
9D0089B8  8FB10018   LW S1, 24(SP)
9D0089BC  8FB00014   LW S0, 20(SP)
9D0089C0  03E00008   JR RA
9D0089C4  27BD0020   ADDIU SP, SP, 32
237:                 
238:                 /*--------------------------------------------------------------------------
239:                 
240:                  Public Functions
241:                 
242:                  ---------------------------------------------------------------------------*/
243:                 
244:                 /*-----------------------------------------------------------------------*/
245:                 /* Initialize Disk Drive                                                 */
246:                 /*-----------------------------------------------------------------------*/
247:                 
248:                 DSTATUS disk_initialize(PF_BYTE drv /* Physical drive number (0) */
9D008C48  27B10014   ADDIU S1, SP, 20
9D008CE4  27A40010   ADDIU A0, SP, 16
9D008CE8  00901821   ADDU V1, A0, S0
249:                                         ) {
9D008B98  27BDFFD8   ADDIU SP, SP, -40
9D008B9C  AFBF0024   SW RA, 36(SP)
9D008BA0  AFB10020   SW S1, 32(SP)
9D008BA4  AFB0001C   SW S0, 28(SP)
9D008BA8  308400FF   ANDI A0, A0, 255
250:                 	PF_BYTE n, ty, cmd, buf[4];
251:                 	UINT16 tmr;
252:                 	DSTATUS s = 0;
253:                 	if (drv)
9D008BAC  14800084   BNE A0, ZERO, 0x9D008DC0
9D008BB0  24020001   ADDIU V0, ZERO, 1
254:                 		return STA_NOINIT; /* Supports only single drive */
255:                 	if (Stat & STA_NODISK)
9D008BB4  93828004   LBU V0, -32764(GP)
9D008BB8  30420002   ANDI V0, V0, 2
9D008BBC  10400004   BEQ V0, ZERO, 0x9D008BD0
9D008BC0  00000000   NOP
256:                 		return Stat; /* No card in the socket */
9D008BC4  93828004   LBU V0, -32764(GP)
9D008BC8  0B402370   J 0x9D008DC0
9D008BCC  304200FF   ANDI V0, V0, 255
257:                 
258:                 	deselect(); /* Force socket power on */
9D008BD0  0F4030F5   JAL disableSD
9D008BD4  2410000A   ADDIU S0, ZERO, 10
259:                 	//FCLK_SLOW();
260:                 	for (n = 10; n; n--)
9D008BE8  1600FFFB   BNE S0, ZERO, 0x9D008BD8
9D008BEC  3C02BF88   LUI V0, -16504
261:                 		rcvr_spi(); /* 80 dummy clocks */
9D008BD8  0F4030D9   JAL writeSPI
9D008BDC  240400FF   ADDIU A0, ZERO, 255
9D008BE0  2610FFFF   ADDIU S0, S0, -1
9D008BE4  321000FF   ANDI S0, S0, 255
262:                 	CS_H();
9D008BF0  8C436120   LW V1, 24864(V0)
9D008BF4  34630004   ORI V1, V1, 4
9D008BF8  AC436120   SW V1, 24864(V0)
9D008BFC  2410000A   ADDIU S0, ZERO, 10
263:                 	for (n = 10; n; n--)
9D008C10  1600FFFB   BNE S0, ZERO, 0x9D008C00
9D008C14  00002021   ADDU A0, ZERO, ZERO
264:                 		rcvr_spi(); /* 80 dummy clocks */
9D008C00  0F4030D9   JAL writeSPI
9D008C04  240400FF   ADDIU A0, ZERO, 255
9D008C08  2610FFFF   ADDIU S0, S0, -1
9D008C0C  321000FF   ANDI S0, S0, 255
265:                 
266:                 	ty = 0;
267:                 	if (send_cmd(CMD0, 0) == 1) { /* Enter Idle state */
9D008C18  0F402237   JAL 0x9D0088DC
9D008C1C  00002821   ADDU A1, ZERO, ZERO
9D008C20  24030001   ADDIU V1, ZERO, 1
9D008C24  5443006B   BNEL V0, V1, 0x9D008DD4
9D008C28  A7808060   SH ZERO, -32672(GP)
268:                 		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2? */
9D008C2C  24040008   ADDIU A0, ZERO, 8
9D008C30  0F402237   JAL 0x9D0088DC
9D008C34  240501AA   ADDIU A1, ZERO, 426
9D008C38  24030001   ADDIU V1, ZERO, 1
9D008C3C  14430035   BNE V0, V1, 0x9D008D14
9D008C40  240400A9   ADDIU A0, ZERO, 169
9D008C44  27B00010   ADDIU S0, SP, 16
269:                 			for (n = 0; n < 4; n++)
9D008C5C  1611FFFB   BNE S0, S1, 0x9D008C4C
9D008C60  93A30012   LBU V1, 18(SP)
270:                 				buf[n] = rcvr_spi(); /* Get trailing return value of R7 resp */
9D008C4C  0F4030D9   JAL writeSPI
9D008C50  240400FF   ADDIU A0, ZERO, 255
9D008C54  A2020000   SB V0, 0(S0)
9D008C58  26100001   ADDIU S0, S0, 1
271:                 			if (buf[2] == 0x01 && buf[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
9D008C64  24020001   ADDIU V0, ZERO, 1
9D008C68  54620050   BNEL V1, V0, 0x9D008DAC
9D008C6C  A7808060   SH ZERO, -32672(GP)
9D008C70  93A30013   LBU V1, 19(SP)
9D008C74  240200AA   ADDIU V0, ZERO, 170
9D008C78  54620056   BNEL V1, V0, 0x9D008DD4
9D008C7C  A7808060   SH ZERO, -32672(GP)
9D008C80  241003E8   ADDIU S0, ZERO, 1000
272:                 				for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state (ACMD41 with HCS bit) */
9D008CA0  2610FFFF   ADDIU S0, S0, -1
9D008CA4  3210FFFF   ANDI S0, S0, -1
9D008CA8  1600FFF7   BNE S0, ZERO, 0x9D008C88
9D008CAC  240400A9   ADDIU A0, ZERO, 169
273:                 					if (send_cmd(ACMD41, 1UL << 30) == 0)
9D008C84  240400A9   ADDIU A0, ZERO, 169
9D008C88  0F402237   JAL 0x9D0088DC
9D008C8C  3C054000   LUI A1, 16384
9D008C90  10400009   BEQ V0, ZERO, 0x9D008CB8
9D008C94  00000000   NOP
274:                 						break;
275:                 					DLY_US(1000);
9D008C98  0F40355F   JAL delay_us
9D008C9C  240403E8   ADDIU A0, ZERO, 1000
276:                 				}
277:                 				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
9D008CB8  52000046   BEQL S0, ZERO, 0x9D008DD4
9D008CBC  A7808060   SH ZERO, -32672(GP)
9D008CC0  2404003A   ADDIU A0, ZERO, 58
9D008CC4  0F402237   JAL 0x9D0088DC
9D008CC8  00002821   ADDU A1, ZERO, ZERO
9D008CCC  54400041   BNEL V0, ZERO, 0x9D008DD4
9D008CD0  A7808060   SH ZERO, -32672(GP)
9D008CD4  00008021   ADDU S0, ZERO, ZERO
278:                 					for (n = 0; n < 4; n++)
9D008CD8  24110004   ADDIU S1, ZERO, 4
9D008CF0  1611FFFA   BNE S0, S1, 0x9D008CDC
9D008CF4  A0620000   SB V0, 0(V1)
279:                 						buf[n] = rcvr_spi();
9D008CDC  0F4030D9   JAL writeSPI
9D008CE0  240400FF   ADDIU A0, ZERO, 255
9D008CEC  26100001   ADDIU S0, S0, 1
280:                 					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 */
9D008CF8  93A40010   LBU A0, 16(SP)
9D008CFC  30840040   ANDI A0, A0, 64
9D008D00  24030004   ADDIU V1, ZERO, 4
9D008D04  2402000C   ADDIU V0, ZERO, 12
9D008D08  0064100A   MOVZ V0, V1, A0
281:                 				}
282:                 			}
283:                 		} else { /* SDv1 or MMCv3 */
284:                 			if (send_cmd(ACMD41, 0) <= 1) {
9D008D14  0F402237   JAL 0x9D0088DC
9D008D18  00002821   ADDU A1, ZERO, ZERO
9D008D1C  2C420002   SLTIU V0, V0, 2
285:                 				ty = CT_SD1;
9D008D20  24030002   ADDIU V1, ZERO, 2
9D008D24  24040001   ADDIU A0, ZERO, 1
9D008D28  00608821   ADDU S1, V1, ZERO
9D008D2C  0082880A   MOVZ S1, A0, V0
286:                 				cmd = ACMD41; /* SDv1 */
287:                 			} else {
288:                 				ty = CT_MMC;
289:                 				cmd = CMD1; /* MMCv3 */
290:                 			}
291:                 			for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state */
9D008D30  241003E8   ADDIU S0, ZERO, 1000
9D008D50  2610FFFF   ADDIU S0, S0, -1
9D008D54  3210FFFF   ANDI S0, S0, -1
9D008D58  1600FFF7   BNE S0, ZERO, 0x9D008D38
9D008D5C  240400A9   ADDIU A0, ZERO, 169
292:                 				if (send_cmd(ACMD41, 0) == 0)
9D008D34  240400A9   ADDIU A0, ZERO, 169
9D008D38  0F402237   JAL 0x9D0088DC
9D008D3C  00002821   ADDU A1, ZERO, ZERO
9D008D40  10400009   BEQ V0, ZERO, 0x9D008D68
9D008D44  00000000   NOP
293:                 					break;
294:                 				DLY_US(1000);
9D008D48  0F40355F   JAL delay_us
9D008D4C  240403E8   ADDIU A0, ZERO, 1000
295:                 			}
296:                 			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
9D008D68  5200001A   BEQL S0, ZERO, 0x9D008DD4
9D008D6C  A7808060   SH ZERO, -32672(GP)
9D008D70  24040010   ADDIU A0, ZERO, 16
9D008D74  0F402237   JAL 0x9D0088DC
9D008D78  24050200   ADDIU A1, ZERO, 512
9D008D7C  54400015   BNEL V0, ZERO, 0x9D008DD4
9D008D80  A7808060   SH ZERO, -32672(GP)
297:                 				ty = 0;
298:                 		}
299:                 	}
300:                 	CardType = ty;
9D008CB0  0B402375   J 0x9D008DD4
9D008CB4  A7808060   SH ZERO, -32672(GP)
9D008D0C  0B402364   J 0x9D008D90
9D008D10  A7828060   SH V0, -32672(GP)
9D008D60  0B402375   J 0x9D008DD4
9D008D64  A7808060   SH ZERO, -32672(GP)
9D008D84  A7918060   SH S1, -32672(GP)
301:                 	if (ty) {/* Initialization succeded */
9D008D88  12200008   BEQ S1, ZERO, 0x9D008DAC
9D008D8C  24020001   ADDIU V0, ZERO, 1
302:                 		s &= ~STA_NOINIT;
9D008DA8  00001021   ADDU V0, ZERO, ZERO
303:                 		// 6. increase speed
304:                 		SPI2CON = 0; // disable the SPI2 module
9D008D90  3C02BF80   LUI V0, -16512
9D008D94  AC405A00   SW ZERO, 23040(V0)
305:                 		SPI2BRG = 0; // maximum possible baud rate = Fpb/2
9D008D98  3C03BF80   LUI V1, -16512
9D008D9C  AC605A30   SW ZERO, 23088(V1)
306:                 		SPI2CON = 0x8120; // re-enable the SPI2 module
9D008DA0  34038120   ORI V1, ZERO, -32480
9D008DA4  AC435A00   SW V1, 23040(V0)
307:                 	} else {
308:                 		/* Initialization failed */
309:                 		s |= STA_NOINIT;
9D008DD4  0B40236B   J 0x9D008DAC
9D008DD8  24020001   ADDIU V0, ZERO, 1
310:                 	}
311:                 	Stat = s;
9D008DAC  A3828004   SB V0, -32764(GP)
312:                 
313:                 	deselect();
9D008DB0  0F4030F5   JAL disableSD
9D008DB4  00000000   NOP
314:                 
315:                 	return Stat;
9D008DB8  93828004   LBU V0, -32764(GP)
9D008DBC  304200FF   ANDI V0, V0, 255
316:                 }
9D008DC0  8FBF0024   LW RA, 36(SP)
9D008DC4  8FB10020   LW S1, 32(SP)
9D008DC8  8FB0001C   LW S0, 28(SP)
9D008DCC  03E00008   JR RA
9D008DD0  27BD0028   ADDIU SP, SP, 40
317:                 
318:                 /*-----------------------------------------------------------------------*/
319:                 /* Get Disk Status                                                       */
320:                 /*-----------------------------------------------------------------------*/
321:                 
322:                 DSTATUS disk_status(PF_BYTE drv /* Physical drive number (0) */
323:                 ) {
9D008DDC  308400FF   ANDI A0, A0, 255
324:                 	if (drv)
9D008DE0  14800003   BNE A0, ZERO, 0x9D008DF0
9D008DE4  24020001   ADDIU V0, ZERO, 1
325:                 		return STA_NOINIT; /* Supports only single drive */
326:                 	return Stat;
9D008DE8  93828004   LBU V0, -32764(GP)
9D008DEC  304200FF   ANDI V0, V0, 255
327:                 }
9D008DF0  03E00008   JR RA
9D008DF4  00000000   NOP
328:                 
329:                 /*-----------------------------------------------------------------------*/
330:                 /* Read Sector(s)                                                        */
331:                 /*-----------------------------------------------------------------------*/
332:                 
333:                 DRESULT disk_read(PF_BYTE drv, /* Physical drive nmuber (0) */
334:                                   PF_BYTE *buff, /* Pointer to the data buffer to store read data */
335:                                   DWORD sector, /* Start sector number (LBA) */
336:                                   PF_BYTE count /* Sector count (1..255) */
337:                                   ) {
9D008DF8  27BDFFE0   ADDIU SP, SP, -32
9D008DFC  AFBF001C   SW RA, 28(SP)
9D008E00  AFB10018   SW S1, 24(SP)
9D008E04  AFB00014   SW S0, 20(SP)
9D008E08  00A08821   ADDU S1, A1, ZERO
9D008E0C  308400FF   ANDI A0, A0, 255
9D008E10  30F000FF   ANDI S0, A3, 255
338:                 	if (drv || !count)
9D008E14  14800029   BNE A0, ZERO, 0x9D008EBC
9D008E18  24020004   ADDIU V0, ZERO, 4
9D008E1C  52000028   BEQL S0, ZERO, 0x9D008EC0
9D008E20  8FBF001C   LW RA, 28(SP)
339:                 		return RES_PARERR;
340:                 	if (Stat & STA_NOINIT)
9D008E24  93838004   LBU V1, -32764(GP)
9D008E28  30630001   ANDI V1, V1, 1
9D008E2C  14600023   BNE V1, ZERO, 0x9D008EBC
9D008E30  24020003   ADDIU V0, ZERO, 3
341:                 		return RES_NOTRDY;
342:                 
343:                 	if (!(CardType & CT_BLOCK))
9D008E34  97838060   LHU V1, -32672(GP)
9D008E38  30630008   ANDI V1, V1, 8
344:                 		sector *= BLK_SIZE; /* Convert to byte address if needed */
9D008E3C  00061240   SLL V0, A2, 9
9D008E40  0043300A   MOVZ A2, V0, V1
345:                 
346:                 	if (count == 1) { /* Single block read */
9D008E44  24020001   ADDIU V0, ZERO, 1
9D008E48  1602000A   BNE S0, V0, 0x9D008E74
9D008E4C  24040012   ADDIU A0, ZERO, 18
347:                 		if ((send_cmd(CMD17, sector) == 0) /* READ_SINGLE_BLOCK */
9D008E50  24040011   ADDIU A0, ZERO, 17
9D008E54  0F402237   JAL 0x9D0088DC
9D008E58  00C02821   ADDU A1, A2, ZERO
9D008E5C  14400014   BNE V0, ZERO, 0x9D008EB0
9D008E60  02202021   ADDU A0, S1, ZERO
348:                 		&& rcvr_datablock(buff, BLK_SIZE))
9D008E64  0F40229F   JAL 0x9D008A7C
9D008E68  24050200   ADDIU A1, ZERO, 512
349:                 			count = 0;
9D008E6C  0B4023AC   J 0x9D008EB0
9D008E70  0002800B   MOVN S0, ZERO, V0
350:                 	} else { /* Multiple block read */
351:                 		if (send_cmd(CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
9D008E74  0F402237   JAL 0x9D0088DC
9D008E78  00C02821   ADDU A1, A2, ZERO
9D008E7C  1440000C   BNE V0, ZERO, 0x9D008EB0
9D008E80  00000000   NOP
352:                 			do {
353:                 				if (!rcvr_datablock(buff, BLK_SIZE))
9D008E84  02202021   ADDU A0, S1, ZERO
9D008E88  0F40229F   JAL 0x9D008A7C
9D008E8C  24050200   ADDIU A1, ZERO, 512
9D008E90  10400005   BEQ V0, ZERO, 0x9D008EA8
9D008E94  2404000C   ADDIU A0, ZERO, 12
354:                 					break;
355:                 				buff += BLK_SIZE;
356:                 			} while (--count);
9D008E98  2610FFFF   ADDIU S0, S0, -1
9D008E9C  321000FF   ANDI S0, S0, 255
9D008EA0  1600FFF8   BNE S0, ZERO, 0x9D008E84
9D008EA4  26310200   ADDIU S1, S1, 512
357:                 			send_cmd(CMD12, 0); /* STOP_TRANSMISSION */
9D008EA8  0F402237   JAL 0x9D0088DC
9D008EAC  00002821   ADDU A1, ZERO, ZERO
358:                 		}
359:                 	}
360:                 	deselect();
9D008EB0  0F4030F5   JAL disableSD
9D008EB4  00000000   NOP
361:                 
362:                 	return count ? RES_ERROR : RES_OK;
9D008EB8  0010102B   SLTU V0, ZERO, S0
363:                 }
9D008EBC  8FBF001C   LW RA, 28(SP)
9D008EC0  8FB10018   LW S1, 24(SP)
9D008EC4  8FB00014   LW S0, 20(SP)
9D008EC8  03E00008   JR RA
9D008ECC  27BD0020   ADDIU SP, SP, 32
364:                 
365:                 /*-----------------------------------------------------------------------*/
366:                 /* Write Sector(s)                                                       */
367:                 /*-----------------------------------------------------------------------*/
368:                 
369:                 #if _READONLY == 0
370:                 DRESULT disk_write(PF_BYTE drv, /* Physical drive number (0) */
371:                                    const PF_BYTE *buff, /* Pointer to the data to be written */
372:                                    DWORD sector, /* Start sector number (LBA) */
373:                                    PF_BYTE count /* Sector count (1..255) */
374:                                    ) {
9D008ED0  27BDFFE0   ADDIU SP, SP, -32
9D008ED4  AFBF001C   SW RA, 28(SP)
9D008ED8  AFB20018   SW S2, 24(SP)
9D008EDC  AFB10014   SW S1, 20(SP)
9D008EE0  AFB00010   SW S0, 16(SP)
9D008EE4  00A08821   ADDU S1, A1, ZERO
9D008EE8  00C08021   ADDU S0, A2, ZERO
9D008EEC  308400FF   ANDI A0, A0, 255
9D008EF0  30F200FF   ANDI S2, A3, 255
375:                 	if (drv || !count)
9D008EF4  14800035   BNE A0, ZERO, 0x9D008FCC
9D008EF8  24020004   ADDIU V0, ZERO, 4
9D008EFC  52400034   BEQL S2, ZERO, 0x9D008FD0
9D008F00  8FBF001C   LW RA, 28(SP)
376:                 		return RES_PARERR;
377:                 	if (Stat & STA_NOINIT)
9D008F04  93838004   LBU V1, -32764(GP)
9D008F08  30630001   ANDI V1, V1, 1
9D008F0C  1460002F   BNE V1, ZERO, 0x9D008FCC
9D008F10  24020003   ADDIU V0, ZERO, 3
378:                 		return RES_NOTRDY;
379:                 	if (Stat & STA_PROTECT)
9D008F14  93838004   LBU V1, -32764(GP)
9D008F18  30630004   ANDI V1, V1, 4
9D008F1C  1460002B   BNE V1, ZERO, 0x9D008FCC
9D008F20  24020002   ADDIU V0, ZERO, 2
380:                 		return RES_WRPRT;
381:                 
382:                 	if (!(CardType & CT_BLOCK))
9D008F24  97828060   LHU V0, -32672(GP)
9D008F28  30440008   ANDI A0, V0, 8
383:                 		sector *= 512; /* Convert to byte address if needed */
9D008F2C  00061A40   SLL V1, A2, 9
9D008F30  0064800A   MOVZ S0, V1, A0
384:                 
385:                 	if (count == 1) { /* Single block write */
9D008F34  24030001   ADDIU V1, ZERO, 1
9D008F38  1643000A   BNE S2, V1, 0x9D008F64
9D008F3C  30420006   ANDI V0, V0, 6
386:                 		if ((send_cmd(CMD24, sector) == 0) /* WRITE_BLOCK */
9D008F40  24040018   ADDIU A0, ZERO, 24
9D008F44  0F402237   JAL 0x9D0088DC
9D008F48  02002821   ADDU A1, S0, ZERO
9D008F4C  1440001C   BNE V0, ZERO, 0x9D008FC0
9D008F50  02202021   ADDU A0, S1, ZERO
387:                 		&& xmit_datablock(buff, 0xFE))
9D008F54  0F40227A   JAL 0x9D0089E8
9D008F58  240500FE   ADDIU A1, ZERO, 254
388:                 			count = 0;
9D008F5C  0B4023F0   J 0x9D008FC0
9D008F60  0002900B   MOVN S2, ZERO, V0
389:                 	} else { /* Multiple block write */
390:                 		if (CardType & CT_SDC)
9D008F64  10400005   BEQ V0, ZERO, 0x9D008F7C
9D008F68  24040019   ADDIU A0, ZERO, 25
391:                 			send_cmd(ACMD23, count);
9D008F6C  24040097   ADDIU A0, ZERO, 151
9D008F70  0F402237   JAL 0x9D0088DC
9D008F74  02402821   ADDU A1, S2, ZERO
392:                 		if (send_cmd(CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
9D008F78  24040019   ADDIU A0, ZERO, 25
9D008F7C  0F402237   JAL 0x9D0088DC
9D008F80  02002821   ADDU A1, S0, ZERO
9D008F84  1440000E   BNE V0, ZERO, 0x9D008FC0
9D008F88  00000000   NOP
393:                 			do {
394:                 				if (!xmit_datablock(buff, 0xFC))
9D008F8C  02202021   ADDU A0, S1, ZERO
9D008F90  0F40227A   JAL 0x9D0089E8
9D008F94  240500FC   ADDIU A1, ZERO, 252
9D008F98  10400005   BEQ V0, ZERO, 0x9D008FB0
9D008F9C  00002021   ADDU A0, ZERO, ZERO
395:                 					break;
396:                 				buff += 512;
397:                 			} while (--count);
9D008FA0  2652FFFF   ADDIU S2, S2, -1
9D008FA4  325200FF   ANDI S2, S2, 255
9D008FA8  1640FFF8   BNE S2, ZERO, 0x9D008F8C
9D008FAC  26310200   ADDIU S1, S1, 512
398:                 			if (!xmit_datablock(0, 0xFD)) /* STOP_TRAN token */
9D008FB0  0F40227A   JAL 0x9D0089E8
9D008FB4  240500FD   ADDIU A1, ZERO, 253
399:                 				count = 1;
9D008FB8  24030001   ADDIU V1, ZERO, 1
9D008FBC  0062900A   MOVZ S2, V1, V0
400:                 		}
401:                 	}
402:                 	deselect();
9D008FC0  0F4030F5   JAL disableSD
9D008FC4  00000000   NOP
403:                 
404:                 	return count ? RES_ERROR : RES_OK;
9D008FC8  0012102B   SLTU V0, ZERO, S2
405:                 }
9D008FCC  8FBF001C   LW RA, 28(SP)
9D008FD0  8FB20018   LW S2, 24(SP)
9D008FD4  8FB10014   LW S1, 20(SP)
9D008FD8  8FB00010   LW S0, 16(SP)
9D008FDC  03E00008   JR RA
9D008FE0  27BD0020   ADDIU SP, SP, 32
406:                 #endif /* _READONLY */
407:                 
408:                 /*-----------------------------------------------------------------------*/
409:                 /* Miscellaneous Functions                                               */
410:                 /*-----------------------------------------------------------------------*/
411:                 
412:                 DRESULT disk_ioctl(PF_BYTE drv, /* Physical drive number (0) */
9D0092E8  26300004   ADDIU S0, S1, 4
413:                                    PF_BYTE ctrl, /* Control code */
414:                                    void *buff /* Buffer to send/receive data block */
415:                                    ) {
9D008FE4  27BDFFD0   ADDIU SP, SP, -48
9D008FE8  AFBF002C   SW RA, 44(SP)
9D008FEC  AFB20028   SW S2, 40(SP)
9D008FF0  AFB10024   SW S1, 36(SP)
9D008FF4  AFB00020   SW S0, 32(SP)
9D008FF8  00C08821   ADDU S1, A2, ZERO
9D008FFC  308400FF   ANDI A0, A0, 255
9D009000  30A500FF   ANDI A1, A1, 255
416:                 	DRESULT res;
417:                 	PF_BYTE n, csd[16], *ptr = buff;
418:                 	DWORD csize;
419:                 
420:                 	if (drv)
9D009004  148000D0   BNE A0, ZERO, 0x9D009348
9D009008  24100004   ADDIU S0, ZERO, 4
421:                 		return RES_PARERR;
422:                 	if (Stat & STA_NOINIT)
9D00900C  93828004   LBU V0, -32764(GP)
9D009010  30420001   ANDI V0, V0, 1
9D009014  144000CC   BNE V0, ZERO, 0x9D009348
9D009018  24100003   ADDIU S0, ZERO, 3
423:                 		return RES_NOTRDY;
424:                 
425:                 	res = RES_ERROR;
9D0092A0  0B4024D0   J 0x9D009340
9D0092A4  2C500001   SLTIU S0, V0, 1
9D0092C8  0B4024D0   J 0x9D009340
9D0092CC  2C500001   SLTIU S0, V0, 1
9D009334  0B4024D0   J 0x9D009340
9D009338  2C500001   SLTIU S0, V0, 1
426:                 	switch (ctrl) {
9D00901C  2CA2000F   SLTIU V0, A1, 15
9D009020  504000C7   BEQL V0, ZERO, 0x9D009340
9D009024  24100004   ADDIU S0, ZERO, 4
9D009028  00052880   SLL A1, A1, 2
9D00902C  3C029D01   LUI V0, -25343
9D009030  24429044   ADDIU V0, V0, -28604
9D009034  00452821   ADDU A1, V0, A1
9D009038  8CA20000   LW V0, 0(A1)
9D00903C  00400008   JR V0
9D009040  00000000   NOP
427:                 	case CTRL_SYNC: /* Flush dirty buffer if present */
428:                 		if (select()) {
9D009080  0F402226   JAL 0x9D008898
9D009084  24100001   ADDIU S0, ZERO, 1
9D009088  104000AD   BEQ V0, ZERO, 0x9D009340
9D00908C  00000000   NOP
429:                 			deselect();
9D009090  0F4030F5   JAL disableSD
9D009094  00008021   ADDU S0, ZERO, ZERO
9D009098  0B4024D0   J 0x9D009340
9D00909C  00000000   NOP
430:                 			res = RES_OK;
431:                 		}
432:                 		break;
433:                 
434:                 	case GET_SECTOR_COUNT: /* Get number of sectors on the disk (WORD) */
435:                 		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
9D0090A0  24040009   ADDIU A0, ZERO, 9
9D0090A4  0F402237   JAL 0x9D0088DC
9D0090A8  00002821   ADDU A1, ZERO, ZERO
9D0090AC  144000A4   BNE V0, ZERO, 0x9D009340
9D0090B0  24100001   ADDIU S0, ZERO, 1
9D0090B4  27A40010   ADDIU A0, SP, 16
9D0090B8  0F40229F   JAL 0x9D008A7C
9D0090BC  24050010   ADDIU A1, ZERO, 16
9D0090C0  1040009F   BEQ V0, ZERO, 0x9D009340
9D0090C4  93A30010   LBU V1, 16(SP)
436:                 			if ((csd[0] >> 6) == 1) { /* SDv2? */
9D0090C8  00031982   SRL V1, V1, 6
9D0090CC  24020001   ADDIU V0, ZERO, 1
9D0090D0  1462000A   BNE V1, V0, 0x9D0090FC
9D0090D4  93A30018   LBU V1, 24(SP)
437:                 				csize = csd[9] + ((WORD) csd[8] << 8) + 1;
9D0090D8  93A30019   LBU V1, 25(SP)
9D0090DC  24630001   ADDIU V1, V1, 1
9D0090E0  93A20018   LBU V0, 24(SP)
9D0090E4  00021200   SLL V0, V0, 8
9D0090E8  00621021   ADDU V0, V1, V0
438:                 				*(DWORD*) buff = (DWORD) csize << 10;
9D0090EC  00021280   SLL V0, V0, 10
9D0090F0  AE220000   SW V0, 0(S1)
439:                 			} else { /* SDv1 or MMCv2 */
440:                 				n = (csd[5] & 15) + ((csd[10] & 128) >> 7)
9D009120  93A40015   LBU A0, 21(SP)
9D009124  3084000F   ANDI A0, A0, 15
9D009128  93A2001A   LBU V0, 26(SP)
9D00912C  000211C2   SRL V0, V0, 7
9D009130  00822021   ADDU A0, A0, V0
9D009134  93A20019   LBU V0, 25(SP)
9D009138  30420003   ANDI V0, V0, 3
9D00913C  00021040   SLL V0, V0, 1
441:                 						+ ((csd[9] & 3) << 1) + 2;
442:                 				csize = (csd[8] >> 6) + ((WORD) csd[7] << 2) + ((WORD) (csd[6]
9D0090FC  00031982   SRL V1, V1, 6
9D009100  93A20017   LBU V0, 23(SP)
9D009104  00021080   SLL V0, V0, 2
9D009108  00621821   ADDU V1, V1, V0
9D00910C  24630001   ADDIU V1, V1, 1
443:                 						& 3) << 10) + 1;
9D009110  93A20016   LBU V0, 22(SP)
9D009114  30420003   ANDI V0, V0, 3
9D009118  00021280   SLL V0, V0, 10
9D00911C  00621821   ADDU V1, V1, V0
444:                 				*(DWORD*) buff = (DWORD) csize << (n - 9);
9D009140  00821021   ADDU V0, A0, V0
9D009144  2442FFF9   ADDIU V0, V0, -7
9D009148  00431004   SLLV V0, V1, V0
9D00914C  AE220000   SW V0, 0(S1)
445:                 			}
446:                 			res = RES_OK;
9D0090F4  0B4024D0   J 0x9D009340
9D0090F8  00008021   ADDU S0, ZERO, ZERO
9D009150  0B4024D0   J 0x9D009340
9D009154  00008021   ADDU S0, ZERO, ZERO
447:                 		}
448:                 		break;
449:                 
450:                 	case GET_SECTOR_SIZE: /* Get sectors on the disk (WORD) */
451:                 		*(WORD*) buff = 512;
9D009158  24020200   ADDIU V0, ZERO, 512
9D00915C  A4C20000   SH V0, 0(A2)
452:                 		res = RES_OK;
453:                 		break;
9D009160  0B4024D0   J 0x9D009340
9D009164  00008021   ADDU S0, ZERO, ZERO
454:                 
455:                 	case GET_BLOCK_SIZE: /* Get erase block size in unit of sectors (DWORD) */
456:                 		if (CardType & CT_SD2) { /* SDv2? */
9D009168  97828060   LHU V0, -32672(GP)
9D00916C  30420004   ANDI V0, V0, 4
9D009170  10400019   BEQ V0, ZERO, 0x9D0091D8
9D009174  24040009   ADDIU A0, ZERO, 9
457:                 			if (send_cmd(ACMD13, 0) == 0) { /* Read SD status */
9D009178  2404008D   ADDIU A0, ZERO, 141
9D00917C  0F402237   JAL 0x9D0088DC
9D009180  00002821   ADDU A1, ZERO, ZERO
9D009184  1440006E   BNE V0, ZERO, 0x9D009340
9D009188  24100001   ADDIU S0, ZERO, 1
458:                 				rcvr_spi();
9D00918C  0F4030D9   JAL writeSPI
9D009190  240400FF   ADDIU A0, ZERO, 255
459:                 				if (rcvr_datablock(csd, 16)) { /* Read partial block */
9D009194  27A40010   ADDIU A0, SP, 16
9D009198  0F40229F   JAL 0x9D008A7C
9D00919C  24050010   ADDIU A1, ZERO, 16
9D0091A0  10400067   BEQ V0, ZERO, 0x9D009340
9D0091A4  00000000   NOP
9D0091A8  24100030   ADDIU S0, ZERO, 48
460:                 					for (n = 64 - 16; n; n--)
9D0091B4  2610FFFF   ADDIU S0, S0, -1
9D0091B8  321000FF   ANDI S0, S0, 255
9D0091BC  1600FFFB   BNE S0, ZERO, 0x9D0091AC
9D0091C0  93A2001A   LBU V0, 26(SP)
461:                 						rcvr_spi(); /* Purge trailing data */
9D0091AC  0F4030D9   JAL writeSPI
9D0091B0  240400FF   ADDIU A0, ZERO, 255
462:                 					*(DWORD*) buff = 16UL << (csd[10] >> 4);
9D0091C4  00021102   SRL V0, V0, 4
9D0091C8  24030010   ADDIU V1, ZERO, 16
9D0091CC  00431004   SLLV V0, V1, V0
9D0091D0  0B4024D0   J 0x9D009340
9D0091D4  AE220000   SW V0, 0(S1)
463:                 					res = RES_OK;
464:                 				}
465:                 			}
466:                 		} else { /* SDv1 or MMCv3 */
467:                 			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) { /* Read CSD */
9D0091D8  0F402237   JAL 0x9D0088DC
9D0091DC  00002821   ADDU A1, ZERO, ZERO
9D0091E0  14400057   BNE V0, ZERO, 0x9D009340
9D0091E4  24100001   ADDIU S0, ZERO, 1
9D0091E8  27A40010   ADDIU A0, SP, 16
9D0091EC  0F40229F   JAL 0x9D008A7C
9D0091F0  24050010   ADDIU A1, ZERO, 16
9D0091F4  10400052   BEQ V0, ZERO, 0x9D009340
9D0091F8  97828060   LHU V0, -32672(GP)
468:                 				if (CardType & CT_SD1) { /* SDv1 */
9D0091FC  30420002   ANDI V0, V0, 2
9D009200  1040000F   BEQ V0, ZERO, 0x9D009240
9D009204  93A2001B   LBU V0, 27(SP)
469:                 					*(DWORD*) buff = (((csd[10] & 63) << 1) + ((WORD) (csd[11]
9D009210  24630001   ADDIU V1, V1, 1
9D009214  93A2001A   LBU V0, 26(SP)
9D009218  3042003F   ANDI V0, V0, 63
9D00921C  00021040   SLL V0, V0, 1
9D009234  AE220000   SW V0, 0(S1)
470:                 							& 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
9D009208  93A3001B   LBU V1, 27(SP)
9D00920C  000319C2   SRL V1, V1, 7
9D009220  00621821   ADDU V1, V1, V0
9D009224  93A2001D   LBU V0, 29(SP)
9D009228  00021182   SRL V0, V0, 6
9D00922C  2442FFFF   ADDIU V0, V0, -1
9D009230  00431004   SLLV V0, V1, V0
471:                 				} else { /* MMCv3 */
472:                 					*(DWORD*) buff = ((WORD) ((csd[10] & 124) >> 2) + 1)
9D009240  93A3001A   LBU V1, 26(SP)
9D009244  7C632080   EXT V1, V1, 2, 5
9D009248  24630001   ADDIU V1, V1, 1
9D009264  AE220000   SW V0, 0(S1)
473:                 							* (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5)
9D00924C  00022142   SRL A0, V0, 5
9D009250  24840001   ADDIU A0, A0, 1
9D009254  30420003   ANDI V0, V0, 3
9D009258  000210C0   SLL V0, V0, 3
9D009260  70621002   MUL V0, V1, V0
474:                 									+ 1);
9D00925C  00821021   ADDU V0, A0, V0
475:                 				}
476:                 				res = RES_OK;
9D009238  0B4024D0   J 0x9D009340
9D00923C  00008021   ADDU S0, ZERO, ZERO
9D009268  0B4024D0   J 0x9D009340
9D00926C  00008021   ADDU S0, ZERO, ZERO
477:                 			}
478:                 		}
479:                 		break;
480:                 
481:                 	case MMC_GET_TYPE: /* Get card type flags (1 byte) */
482:                 		*ptr = CardType;
9D009270  97828060   LHU V0, -32672(GP)
9D009274  A0C20000   SB V0, 0(A2)
483:                 		res = RES_OK;
484:                 		break;
9D009278  0B4024D0   J 0x9D009340
9D00927C  00008021   ADDU S0, ZERO, ZERO
485:                 
486:                 	case MMC_GET_CSD: /* Receive CSD as a data block (16 bytes) */
487:                 		if ((send_cmd(CMD9, 0) == 0) /* READ_CSD */
9D009280  24040009   ADDIU A0, ZERO, 9
9D009284  0F402237   JAL 0x9D0088DC
9D009288  00002821   ADDU A1, ZERO, ZERO
9D00928C  1440002C   BNE V0, ZERO, 0x9D009340
9D009290  24100001   ADDIU S0, ZERO, 1
488:                 		&& rcvr_datablock(buff, 16))
9D009294  02202021   ADDU A0, S1, ZERO
9D009298  0F40229F   JAL 0x9D008A7C
9D00929C  24050010   ADDIU A1, ZERO, 16
489:                 			res = RES_OK;
490:                 		break;
491:                 
492:                 	case MMC_GET_CID: /* Receive CID as a data block (16 bytes) */
493:                 		if ((send_cmd(CMD10, 0) == 0) /* READ_CID */
9D0092A8  2404000A   ADDIU A0, ZERO, 10
9D0092AC  0F402237   JAL 0x9D0088DC
9D0092B0  00002821   ADDU A1, ZERO, ZERO
9D0092B4  14400022   BNE V0, ZERO, 0x9D009340
9D0092B8  24100001   ADDIU S0, ZERO, 1
494:                 		&& rcvr_datablock(buff, 16))
9D0092BC  02202021   ADDU A0, S1, ZERO
9D0092C0  0F40229F   JAL 0x9D008A7C
9D0092C4  24050010   ADDIU A1, ZERO, 16
495:                 			res = RES_OK;
496:                 		break;
497:                 
498:                 	case MMC_GET_OCR: /* Receive OCR as an R3 resp (4 bytes) */
499:                 		if (send_cmd(CMD58, 0) == 0) { /* READ_OCR */
9D0092D0  2404003A   ADDIU A0, ZERO, 58
9D0092D4  0F402237   JAL 0x9D0088DC
9D0092D8  00002821   ADDU A1, ZERO, ZERO
9D0092DC  14400018   BNE V0, ZERO, 0x9D009340
9D0092E0  24100001   ADDIU S0, ZERO, 1
9D0092E4  02209021   ADDU S2, S1, ZERO
500:                 			for (n = 0; n < 4; n++)
9D0092FC  1650FFFB   BNE S2, S0, 0x9D0092EC
9D009300  00000000   NOP
501:                 				*((PF_BYTE*) buff + n) = rcvr_spi();
9D0092EC  0F4030D9   JAL writeSPI
9D0092F0  240400FF   ADDIU A0, ZERO, 255
9D0092F4  A2420000   SB V0, 0(S2)
9D0092F8  26520001   ADDIU S2, S2, 1
502:                 			res = RES_OK;
9D009304  0B4024D0   J 0x9D009340
9D009308  00008021   ADDU S0, ZERO, ZERO
503:                 		}
504:                 		break;
505:                 
506:                 	case MMC_GET_SDSTAT: /* Receive SD status as a data block (64 bytes) */
507:                 		if (send_cmd(ACMD13, 0) == 0) { /* SD_STATUS */
9D00930C  2404008D   ADDIU A0, ZERO, 141
9D009310  0F402237   JAL 0x9D0088DC
9D009314  00002821   ADDU A1, ZERO, ZERO
9D009318  14400009   BNE V0, ZERO, 0x9D009340
9D00931C  24100001   ADDIU S0, ZERO, 1
508:                 			rcvr_spi();
9D009320  0F4030D9   JAL writeSPI
9D009324  240400FF   ADDIU A0, ZERO, 255
509:                 			if (rcvr_datablock(buff, 64))
9D009328  02202021   ADDU A0, S1, ZERO
9D00932C  0F40229F   JAL 0x9D008A7C
9D009330  24050040   ADDIU A1, ZERO, 64
510:                 				res = RES_OK;
511:                 		}
512:                 		break;
513:                 
514:                 	default:
515:                 		res = RES_PARERR;
9D00933C  24100004   ADDIU S0, ZERO, 4
516:                 	}
517:                 
518:                 	deselect();
9D009340  0F4030F5   JAL disableSD
9D009344  00000000   NOP
519:                 
520:                 	return res;
521:                 }
9D009348  02001021   ADDU V0, S0, ZERO
9D00934C  8FBF002C   LW RA, 44(SP)
9D009350  8FB20028   LW S2, 40(SP)
9D009354  8FB10024   LW S1, 36(SP)
9D009358  8FB00020   LW S0, 32(SP)
9D00935C  03E00008   JR RA
9D009360  27BD0030   ADDIU SP, SP, 48
522:                 
523:                 /*-----------------------------------------------------------------------*/
524:                 /* Device Timer Interrupt Procedure  (Platform dependent)                */
525:                 /*-----------------------------------------------------------------------*/
526:                 /* This function must be called in period of 1ms                         */
527:                 /*
528:                 void disk_timerproc(void) {
529:                 	static WORD pv;
530:                 	WORD p;
531:                 	PF_BYTE s;
532:                 	UINT16 n;
533:                 
534:                 	n = Timer1; // 1000Hz decrement timer
535:                 	if (n)
536:                 		Timer1 = --n;
537:                 	n = Timer2;
538:                 	if (n)
539:                 		Timer2 = --n;
540:                 
541:                 	p = pv;
542:                 	pv = getCD() & getWP(); // Sample socket switch
543:                 
544:                 	if (p == pv) { // Have contacts stabled?
545:                 		s = Stat;
546:                 
547:                 		if (p & getWP()) // WP is H (write protected)
548:                 			s |= STA_PROTECT;
549:                 		else
550:                 			//* WP is L (write enabled)
551:                 			s &= ~STA_PROTECT;
552:                 
553:                 		if (p & getCD()) // INS = H (Socket empty)
554:                 			s |= (STA_NODISK | STA_NOINIT);
555:                 		else
556:                 			// INS = L (Card inserted)
557:                 			s &= ~STA_NODISK;
558:                 
559:                 		Stat = s;
560:                 	}
561:                 }
562:                 */
563:                 
564:                 /*---------------------------------------------------------*/
565:                 /* User Provided RTC Function for FatFs module             */
566:                 /*---------------------------------------------------------*/
567:                 /* This is a real time clock service to be called from     */
568:                 /* FatFs module. Any valid time must be returned even if   */
569:                 /* the system does not support an RTC.                     */
570:                 /* This function is not required in read-only cfg.         */
571:                 
572:                 /*	The current time is returned packed into a DWORD
573:                 	(32 bit) value. The bit fields are as follows:
574:                 		bits 31:25	Year from 1980 (0..127)
575:                 		bits 24:21	Month (1..12)
576:                 		bits 20:16	Day in month (1..31)
577:                 		bits 15:11	Hour (0..23)
578:                 		bits 10:05	Minute (0..59)
579:                 		bits 04:00	Second / 2 (0..29)						*/
580:                 
581:                 DWORD get_fattime(void) {
582:                 	DWORD tmr = 0;
583:                 
584:                 // Pre-processor commands added so only use RTCC if the board is known
585:                 // to support the RTCC ** Added 07 May 2012
586:                 
587:                 // For boards known to support the RTCC library
588:                 
589:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
590:                 	rtccTime pTm, cTm;
591:                 	rtccDate pDt, cDt;
592:                 
593:                 	RTCC_GetTimeDate(&pTm, &pDt);	// get time and date from RTC
594:                 											// assumes RTC has been set and is running
595:                 											// OK - could be expanded to check that RTC
596:                 											// is running and that a valid value is
597:                 											// being returned by the RTC
598:                 	cTm = RTCC_ConvertTime(&pTm);	// convert time from bcd to decimal format
599:                 	cDt = RTCC_ConvertDate(&pDt);	// convert date from bcd to decimal format
600:                 
601:                 	/* Pack date and time into a DWORD variable */
602:                 //	tmr = (((DWORD) pDt.year - 80)) | ((DWORD) pDt.mon) | ((DWORD) pDt.mday)
603:                 //			| (WORD) (pTm.hour) | (WORD) (pTm.min) | (WORD) (pTm.sec);
604:                 	tmr = cDt.year + 20;
605:                    
606:                   // Correction according to a newer rtcc library, with diff struct members.
607:                   
608:                 	 tmr = (tmr << 4) | cDt.month;		// shifts left 4 bits and adds monthth
609:                 	tmr = (tmr << 5) | cDt.dayofmonth;		// shifts left 5 bits and adds m.day
610:                 	tmr = (tmr << 5) | cTm.hours;		// shifts left 5 bits and adds hour
611:                 	tmr = (tmr << 6) | cTm.minutes;		// shift left 6 bits and adds minutes
612:                 	tmr = (tmr << 5) | (cTm.seconds/2);	// shifts left 5 bits and adds seconds/2
613:                 
614:                 //	For other boards use a fixed date and time of 01 Jan 2012 12:00:00
615:                 #else
616:                      tmr = 12 + 20;
617:                      tmr = (tmr << 4) | 1;       // shifts left 4 bits and adds month
618:                      tmr = (tmr << 5) | 1;    	// shifts left 5 bits and adds m.day
619:                      tmr = (tmr << 5) | 12;    	// shifts left 5 bits and adds hour
620:                      tmr = (tmr << 6) | 0;       // shift left 6 bits and adds minutes
621:                      tmr = (tmr << 5) | (0/2);   // shifts left 5 bits and adds seconds/2
622:                 #endif
623:                 
624:                 	return tmr;
625:                 }
9D009364  3C024021   LUI V0, 16417
9D009368  03E00008   JR RA
9D00936C  24426000   ADDIU V0, V0, 24576
626:                 
627:                 void put_rc(FRESULT rc) {
628:                 	const char *str =
629:                                         "OK\0" "DISK_ERR\0" "INT_ERR\0" "NOT_READY\0" "NO_FILE\0" "NO_PATH\0"
630:                                                 "INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
631:                                                 "INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
632:                                                 "LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0";
633:                 	FRESULT i;
634:                 
635:                 	for (i = 0; i != rc && *str; i++) {
636:                 		while (*str++)
637:                 			;
638:                 	}
639:                 	//CDCprintln("rc=%u FR_%s", (UINT16) rc, str);
640:                         print("rc=");
641:                         print_int(rc,5);
642:                         cursor_right();
643:                         print(str);
644:                         put_char('\r');
645:                 }
646:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/HardwareProfile.c  -----------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   HardwareProfile.h
21:                   * Author: Jacques Deschênes
22:                   * Description: configuration hardware spécifique, assignation des périphériques
23:                   *     UART2 assigné à PB10,PB11
24:                   * Created on 17 avril 2013, 14:41
25:                   *
26:                   */
27:                  
28:                  #include "HardwareProfile.h"
29:                  #include <plib.h>
30:                  #include "../sound.h"
31:                  
32:                  volatile unsigned int  sys_tick; // compteur pour les milli-secondes
33:                  
34:                  
35:                  void HardwareInit(){
9D00D3C8  27BDFFE8   ADDIU SP, SP, -24
9D00D3CC  AFBF0014   SW RA, 20(SP)
36:                     SYSTEMConfig(mGetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
37:                     INTEnableSystemMultiVectoredInt();
9D00D3F4  0F403EED   JAL INTEnableSystemMultiVectoredInt
9D00D3F8  00000000   NOP
38:                     // activation du PROXIMITY TIMER pour les interruption inférieures à IPL=7
39:                  //   INTCONbits.TPC=0;
40:                  //   IPTMRCLR=0xFFFFFFFF;
41:                  //   INTCONbits.TPC=7;
42:                  //   IPTMR=CORE_TICK_RATE/2;
43:                      // configure coretimer pour le sys_tick
44:                  #ifdef USE_CORE_TIMER
45:                     OpenCoreTimer(CORE_TICK_RATE);
9D00D3FC  0F404002   JAL OpenCoreTimer
9D00D400  2404493E   ADDIU A0, ZERO, 18750
46:                     mConfigIntCoreTimer((CT_INT_ON | CT_INT_PRIOR_1 | CT_INT_SUB_PRIOR_0));
9D00D404  24020001   ADDIU V0, ZERO, 1
9D00D408  3C03BF88   LUI V1, -16504
9D00D40C  AC621034   SW V0, 4148(V1)
9D00D410  3C06BF88   LUI A2, -16504
9D00D414  2403001C   ADDIU V1, ZERO, 28
9D00D418  ACC31094   SW V1, 4244(A2)
9D00D41C  3C05BF88   LUI A1, -16504
9D00D420  24030004   ADDIU V1, ZERO, 4
9D00D424  ACA31098   SW V1, 4248(A1)
9D00D428  24040003   ADDIU A0, ZERO, 3
9D00D42C  ACC41094   SW A0, 4244(A2)
9D00D430  ACA01098   SW ZERO, 4248(A1)
9D00D434  3C05BF88   LUI A1, -16504
9D00D438  ACA21064   SW V0, 4196(A1)
9D00D43C  3C05BF88   LUI A1, -16504
9D00D440  ACA21068   SW V0, 4200(A1)
47:                  #endif
48:                     // désactivation de toutes les entrée analogiques.
49:                     ANSELBCLR=0xFFFFFFFF;
9D00D444  3C05BF88   LUI A1, -16504
9D00D448  2406FFFF   ADDIU A2, ZERO, -1
9D00D44C  ACA66104   SW A2, 24836(A1)
50:                     ANSELACLR=0xFFFFFFFF;
9D00D450  3C07BF88   LUI A3, -16504
9D00D454  ACE66004   SW A2, 24580(A3)
51:                      // configuration PB10 sortie et PB11 entrée
52:                     mPORTBSetBits(TX); // mettre à Vdd pour ne pas généré un faux start bit.
9D00D458  24060400   ADDIU A2, ZERO, 1024
9D00D45C  3C07BF88   LUI A3, -16504
9D00D460  ACE66138   SW A2, 24888(A3)
53:                     mPORTBSetPinsDigitalOut(TX);      // sortie PB10(Tx), transmission UART2
9D00D464  3C07BF88   LUI A3, -16504
9D00D468  ACE66114   SW A2, 24852(A3)
9D00D46C  ACA66104   SW A2, 24836(A1)
54:                     mPORTBSetPinsDigitalIn (RX);      // entrée PB11(Rx), réception UART2
9D00D470  24060800   ADDIU A2, ZERO, 2048
9D00D474  3C08BF88   LUI T0, -16504
9D00D478  AD066118   SW A2, 24856(T0)
9D00D47C  ACA66104   SW A2, 24836(A1)
55:                     // assignation des périphériques aux broches
56:                     // l'information se trouve dans pps.h
57:                     PPSUnLock;                     // déverrouillage configuration assignation périphérique
58:                     //clavier
59:                     I2C1CONbits.DISSLW=1; // voir pic32mx1xxx/2xxx-errata.pdf rev. E, point 9
9D00D480  3C05BF80   LUI A1, -16512
9D00D484  8CA65000   LW A2, 20480(A1)
9D00D488  7C464A44   INS A2, V0, 9, 1
9D00D48C  ACA65000   SW A2, 20480(A1)
60:                     RPA0R=0;  // pas de périphérique sur RA0 (keyboard clock)
9D00D490  3C02BF81   LUI V0, -16511
9D00D494  AC40FB00   SW ZERO, -1280(V0)
61:                     RPA1R=0;  // pas de périphérique sur RA1 (keyboard data)
9D00D498  3C02BF81   LUI V0, -16511
9D00D49C  AC40FB04   SW ZERO, -1276(V0)
62:                     RPB3R=0; //  pas de périphérique sur RB3 (status LED)
9D00D4A0  3C02BF81   LUI V0, -16511
9D00D4A4  AC40FB38   SW ZERO, -1224(V0)
63:                     RPB15R=0; // pad de périphérique sur RB15
9D00D4A8  3C02BF81   LUI V0, -16511
9D00D4AC  AC40FB68   SW ZERO, -1176(V0)
64:                     TRISBCLR=STATUS_LED; // broche status LED en sortie
9D00D4B0  24020008   ADDIU V0, ZERO, 8
9D00D4B4  ACE26114   SW V0, 24852(A3)
65:                     _status_off();
9D00D4B8  3C02BF88   LUI V0, -16504
9D00D4BC  8C466120   LW A2, 24864(V0)
9D00D4C0  2405FFF7   ADDIU A1, ZERO, -9
9D00D4C4  00C52824   AND A1, A2, A1
9D00D4C8  AC456120   SW A1, 24864(V0)
66:                     PPSOutput(4, RPB10, U2TX);  // assignation U2TX sur PB10, (groupe, pin, fonction)
9D00D4CC  3C02BF81   LUI V0, -16511
9D00D4D0  8C46FB54   LW A2, -1196(V0)
9D00D4D4  24050002   ADDIU A1, ZERO, 2
9D00D4D8  7CA61804   INS A2, A1, 0, 4
9D00D4DC  AC46FB54   SW A2, -1196(V0)
67:                     PPSInput (2, U2RX, RPB11);  // assignation U2RX sur PB11, (groupe, fonction, pin)
9D00D4E0  3C02BF81   LUI V0, -16511
9D00D4E4  8C46FA58   LW A2, -1448(V0)
9D00D4E8  7C861804   INS A2, A0, 0, 4
9D00D4EC  AC46FA58   SW A2, -1448(V0)
68:                     PPSOutput(2,RPB5,OC2); // 5=OC2  sur PB5 sortie synchronistaiton ntsc
9D00D4F0  3C06BF81   LUI A2, -16511
9D00D4F4  8CC7FB40   LW A3, -1216(A2)
9D00D4F8  24020005   ADDIU V0, ZERO, 5
9D00D4FC  7C471804   INS A3, V0, 0, 4
9D00D500  ACC7FB40   SW A3, -1216(A2)
69:                     PPSOutput(1,RPB4,OC1);  // 5=OC1 impulsion déclenchant SPI , Fsync vidéo
9D00D504  3C06BF81   LUI A2, -16511
9D00D508  8CC7FB3C   LW A3, -1220(A2)
9D00D50C  7C471804   INS A3, V0, 0, 4
9D00D510  ACC7FB3C   SW A3, -1220(A2)
70:                     PPSOutput(3,RPB6,SDO1); // 3=SDO1 sortie SPI1 (vidéo)
9D00D514  3C06BF81   LUI A2, -16511
9D00D518  8CC7FB44   LW A3, -1212(A2)
9D00D51C  7C871804   INS A3, A0, 0, 4
9D00D520  ACC7FB44   SW A3, -1212(A2)
71:                     PPSOutput(4,RPB9,OC3); // OC3 sortie audio.
9D00D524  3C04BF81   LUI A0, -16511
9D00D528  8C86FB50   LW A2, -1200(A0)
9D00D52C  7C461804   INS A2, V0, 0, 4
9D00D530  AC86FB50   SW A2, -1200(A0)
72:                     PPSInput(1,SS1,RPB7); // entrée Fsync sur RPB7
9D00D534  3C02BF81   LUI V0, -16511
9D00D538  8C44FA88   LW A0, -1400(V0)
9D00D53C  7C641804   INS A0, V1, 0, 4
9D00D540  AC44FA88   SW A0, -1400(V0)
73:                     PPSInput(3,SDI2,RPA4); // entrée SDI pour carte SD
9D00D544  3C02BF81   LUI V0, -16511
9D00D548  8C44FA90   LW A0, -1392(V0)
9D00D54C  7CA41804   INS A0, A1, 0, 4
9D00D550  AC44FA90   SW A0, -1392(V0)
74:                     PPSOutput(2,RPB8,SDO2); // sortie commande carte SD
9D00D554  3C02BF81   LUI V0, -16511
9D00D558  8C44FB4C   LW A0, -1204(V0)
9D00D55C  7C641804   INS A0, V1, 0, 4
9D00D560  AC44FB4C   SW A0, -1204(V0)
75:                     PPSLock;                       // reverrouille pour éviter assignation accidentelle.
76:                  }
9D00D564  8FBF0014   LW RA, 20(SP)
9D00D568  03E00008   JR RA
9D00D56C  27BD0018   ADDIU SP, SP, 24
77:                  
78:                  inline unsigned int ticks(void){
79:                      return sys_tick;
9D00D570  8F8280C4   LW V0, -32572(GP)
80:                  } //ticks()
9D00D574  03E00008   JR RA
9D00D578  00000000   NOP
81:                  
82:                  inline void delay_us(unsigned int usec){
83:                      for (usec=usec*(CLK_PER_USEC/3);usec;usec--);
9D00D57C  2402000C   ADDIU V0, ZERO, 12
9D00D580  70821002   MUL V0, A0, V0
9D00D584  10400003   BEQ V0, ZERO, 0x9D00D594
9D00D588  2442FFFF   ADDIU V0, V0, -1
9D00D58C  1440FFFF   BNE V0, ZERO, 0x9D00D58C
9D00D590  2442FFFF   ADDIU V0, V0, -1
9D00D594  03E00008   JR RA
9D00D598  00000000   NOP
84:                  }//delay_us()
85:                  
86:                  void delay_ms(unsigned int msec){
87:                  #ifdef USE_CORE_TIMER
88:                      unsigned int t0;
89:                      t0=sys_tick+msec;
9D00D59C  8F8280C4   LW V0, -32572(GP)
9D00D5A0  00821021   ADDU V0, A0, V0
90:                      while (sys_tick!=t0);
9D00D5A4  8F8380C4   LW V1, -32572(GP)
9D00D5A8  1462FFFE   BNE V1, V0, 0x9D00D5A4
9D00D5AC  00000000   NOP
91:                  #else
92:                      while (msec--)
93:                          delay_us(1000);
94:                  #endif
95:                  } // delay_ms()
9D00D5B0  03E00008   JR RA
9D00D5B4  00000000   NOP
96:                  
97:                  #ifdef USE_CORE_TIMER
98:                    //déclaration du gestionnaire d'interruption
99:                     void __ISR(_CORE_TIMER_VECTOR, IPL1SOFT)  CoreTimerHandler(void){
9D00D5B8  415DE800   RDPGPR SP, SP
9D00D5BC  401A7000   MFC0 K0, EPC
9D00D5C0  401B6000   MFC0 K1, Status
9D00D5C4  27BDFFE8   ADDIU SP, SP, -24
9D00D5C8  AFBA0014   SW K0, 20(SP)
9D00D5CC  401A6002   MFC0 K0, SRSCtl
9D00D5D0  AFBB0010   SW K1, 16(SP)
9D00D5D4  AFBA000C   SW K0, 12(SP)
9D00D5D8  7C1B7844   INS K1, ZERO, 1, 15
9D00D5DC  377B0400   ORI K1, K1, 1024
9D00D5E0  409B6000   MTC0 K1, Status
9D00D5E4  AFA30004   SW V1, 4(SP)
9D00D5E8  AFA20000   SW V0, 0(SP)
100:                        sys_tick++;
9D00D5EC  8F8280C4   LW V0, -32572(GP)
9D00D5F0  24420001   ADDIU V0, V0, 1
9D00D5F4  AF8280C4   SW V0, -32572(GP)
101:                        __asm__("mfc0 $v0, $11");
9D00D5F8  40025800   MFC0 V0, Compare
102:                        __asm__("addiu $v0,$v0,%0"::"I"(CORE_TICK_RATE));
9D00D5FC  2442493E   ADDIU V0, V0, 18750
103:                        __asm__("mtc0 $v0, $11");
9D00D600  40825800   MTC0 V0, Compare
104:                        if (tone_on && !(--duration)){
9D00D604  93828074   LBU V0, -32652(GP)
9D00D608  304200FF   ANDI V0, V0, 255
9D00D60C  1040000C   BEQ V0, ZERO, 0x9D00D640
9D00D610  24030001   ADDIU V1, ZERO, 1
9D00D614  8F8280E0   LW V0, -32544(GP)
9D00D618  2442FFFF   ADDIU V0, V0, -1
9D00D61C  AF8280E0   SW V0, -32544(GP)
9D00D620  8F8280E0   LW V0, -32544(GP)
9D00D624  14400005   BNE V0, ZERO, 0x9D00D63C
9D00D628  3C02BF80   LUI V0, -16512
105:                                mTone_off();
9D00D62C  8C433400   LW V1, 13312(V0)
9D00D630  7C037BC4   INS V1, ZERO, 15, 1
9D00D634  AC433400   SW V1, 13312(V0)
106:                                tone_on=0;
9D00D638  A3808074   SB ZERO, -32652(GP)
107:                        }
108:                        mCTClearIntFlag();
9D00D63C  24030001   ADDIU V1, ZERO, 1
9D00D640  3C02BF88   LUI V0, -16504
9D00D644  AC431034   SW V1, 4148(V0)
109:                    };
9D00D648  8FA30004   LW V1, 4(SP)
9D00D64C  8FA20000   LW V0, 0(SP)
9D00D650  41606000   DI ZERO
9D00D654  000000C0   EHB
9D00D658  8FBA0014   LW K0, 20(SP)
9D00D65C  8FBB0010   LW K1, 16(SP)
9D00D660  409A7000   MTC0 K0, EPC
9D00D664  8FBA000C   LW K0, 12(SP)
9D00D668  27BD0018   ADDIU SP, SP, 24
9D00D66C  409A6002   MTC0 K0, SRSCtl
9D00D670  41DDE800   WRPGPR SP, SP
9D00D674  409B6000   MTC0 K1, Status
9D00D678  42000018   ERET
110:                 #endif
111:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/editor.c  -----------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   editor.h
20:                   * Author: Jacques Deschênes
21:                   *
22:                   * Created on 18 septembre 2013, 07:18
23:                   * Description: un éditeur simple pour le VPC-32
24:                   *
25:                   */
26:                  
27:                  
28:                  #include "hardware/HardwareProfile.h"
29:                  #include "hardware/keyboard.h"
30:                  #include "console.h"
31:                  
32:                  
33:                  void ed(char *file_name){
9D00FC1C  27BDFFE8   ADDIU SP, SP, -24
9D00FC20  AFBF0014   SW RA, 20(SP)
34:                      if (comm_channel!=LOCAL_CON){
9D00FC24  93848064   LBU A0, -32668(GP)
9D00FC28  10800006   BEQ A0, ZERO, 0x9D00FC44
9D00FC2C  8FBF0014   LW RA, 20(SP)
35:                          print(comm_channel, "Cet editeur fonctionne seulement sur la console locale\r");
9D00FC30  7C042420   SEB A0, A0
9D00FC34  3C059D01   LUI A1, -25343
9D00FC38  0F402601   JAL print
9D00FC3C  24A5FAD4   ADDIU A1, A1, -1324
36:                          return;
37:                      }
38:                  
39:                  } // ed()
9D00FC40  8FBF0014   LW RA, 20(SP)
9D00FC44  03E00008   JR RA
9D00FC48  27BD0018   ADDIU SP, SP, 24
40:                  
41:                  
42:                  
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/console.c  ----------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   *  Name: console.c
21:                   *  Description: text console for NTSC video output
22:                   *  Author: Jacques Deschênes
23:                   *  Date Created: 2013-09-06
24:                   */
25:                  
26:                  #include "console.h"
27:                  #include "hardware/HardwareProfile.h"
28:                  #include "hardware/serial_comm.h"
29:                  #include "hardware/keyboard.h"
30:                  
31:                  #define X_OFS  ((HRES%CWIDTH)/2)  // offset vidéo position curseur x
32:                  #define Y_OFS  ((VRES%CHEIGHT)/2)  // offset vidéo position curseur y
33:                  
34:                  // indicateurs booléens
35:                  #define CUR_SHOW 1  // curseur actif
36:                  #define CUR_VIS  2  // curseur visible
37:                  
38:                  
39:                  static unsigned short cx=X_OFS, cy=Y_OFS;  // coordonnée courante du curseur texte en pixels.
40:                  static unsigned char tab_width=TAB_WIDTH;
41:                  static cursor_t cur_shape=CR_UNDER;
42:                  static unsigned short flags=0;
43:                  
44:                  unsigned char comm_channel=LOCAL_CON;
45:                  
46:                  
47:                  void scroll_up(void){
9D00942C  27BDFFE8   ADDIU SP, SP, -24
9D009430  AFBF0014   SW RA, 20(SP)
9D009434  AFB00010   SW S0, 16(SP)
48:                      char *src, *dst;
49:                      dst = (char*)video_bmp+Y_OFS*HRES/8;
9D009438  3C10A000   LUI S0, -24576
9D00943C  2610016C   ADDIU S0, S0, 364
50:                      src = (char*)video_bmp +(CHEIGHT+Y_OFS)*HRES/8;
51:                      memmove(dst,src,(LINE_PER_SCREEN-1)*CHEIGHT*HRES/8);
9D009440  26040078   ADDIU A0, S0, 120
9D009444  260501B8   ADDIU A1, S0, 440
9D009448  0F403DA4   JAL memmove
9D00944C  240621C0   ADDIU A2, ZERO, 8640
52:                      dst= (char*)video_bmp+(CHEIGHT*(LINE_PER_SCREEN-1)+Y_OFS)*HRES/8;
53:                      memset(dst,0,HRES/8*CHEIGHT);
9D009450  26042238   ADDIU A0, S0, 8760
9D009454  00002821   ADDU A1, ZERO, ZERO
9D009458  0F403D34   JAL 0x9D00F4D0
9D00945C  24060140   ADDIU A2, ZERO, 320
54:                  }//scroll_up();
9D009460  8FBF0014   LW RA, 20(SP)
9D009464  8FB00010   LW S0, 16(SP)
9D009468  03E00008   JR RA
9D00946C  27BD0018   ADDIU SP, SP, 24
55:                  
56:                  void scroll_down(void){
9D009470  27BDFFE8   ADDIU SP, SP, -24
9D009474  AFBF0014   SW RA, 20(SP)
9D009478  AFB00010   SW S0, 16(SP)
57:                      char *src, *dst;
58:                      src = (char*)video_bmp+Y_OFS*HRES/8;
9D00947C  3C04A000   LUI A0, -24576
9D009480  2484016C   ADDIU A0, A0, 364
9D009484  24900078   ADDIU S0, A0, 120
59:                      dst = (char*)video_bmp+(CHEIGHT+Y_OFS)*HRES/8;
60:                      memmove(dst,src,(LINE_PER_SCREEN-1)*CHEIGHT*HRES/8);
9D009488  248401B8   ADDIU A0, A0, 440
9D00948C  02002821   ADDU A1, S0, ZERO
9D009490  0F403DA4   JAL memmove
9D009494  240621C0   ADDIU A2, ZERO, 8640
61:                      dst=(char*)video_bmp+Y_OFS*HRES/8;
62:                      memset(dst,0,HRES/8*CHEIGHT);
9D009498  02002021   ADDU A0, S0, ZERO
9D00949C  00002821   ADDU A1, ZERO, ZERO
9D0094A0  0F403D34   JAL 0x9D00F4D0
9D0094A4  24060140   ADDIU A2, ZERO, 320
63:                  }//scroll_down()
9D0094A8  8FBF0014   LW RA, 20(SP)
9D0094AC  8FB00010   LW S0, 16(SP)
9D0094B0  03E00008   JR RA
9D0094B4  27BD0018   ADDIU SP, SP, 24
64:                  
65:                  
66:                  void cursor_right(void){
9D0094B8  27BDFFE8   ADDIU SP, SP, -24
9D0094BC  AFBF0014   SW RA, 20(SP)
67:                      cx += CWIDTH;
9D0094C0  97828006   LHU V0, -32762(GP)
9D0094C4  24420006   ADDIU V0, V0, 6
9D0094C8  3042FFFF   ANDI V0, V0, -1
9D0094CC  A7828006   SH V0, -32762(GP)
68:                      if (cx>(CHAR_PER_LINE*CWIDTH)){
9D0094D0  2C42013F   SLTIU V0, V0, 319
9D0094D4  1440000E   BNE V0, ZERO, 0x9D009510
9D0094D8  24020001   ADDIU V0, ZERO, 1
69:                          cx = X_OFS;
9D0094DC  A7828006   SH V0, -32762(GP)
70:                          cy += CHEIGHT;
9D0094E0  97828008   LHU V0, -32760(GP)
9D0094E4  24420008   ADDIU V0, V0, 8
9D0094E8  3042FFFF   ANDI V0, V0, -1
9D0094EC  A7828008   SH V0, -32760(GP)
71:                          if (cy>(LINE_PER_SCREEN*CHEIGHT)){
9D0094F0  2C4200E1   SLTIU V0, V0, 225
9D0094F4  14400007   BNE V0, ZERO, 0x9D009514
9D0094F8  8FBF0014   LW RA, 20(SP)
72:                              scroll_up();
9D0094FC  0F40250B   JAL scroll_up
9D009500  00000000   NOP
73:                              cy -= CHEIGHT;
9D009504  97828008   LHU V0, -32760(GP)
9D009508  2442FFF8   ADDIU V0, V0, -8
9D00950C  A7828008   SH V0, -32760(GP)
74:                          }
75:                      }
76:                  } // cursor_right()
9D009510  8FBF0014   LW RA, 20(SP)
9D009514  03E00008   JR RA
9D009518  27BD0018   ADDIU SP, SP, 24
77:                  
78:                  void cursor_left(void){
9D00951C  27BDFFE8   ADDIU SP, SP, -24
9D009520  AFBF0014   SW RA, 20(SP)
79:                      if (cx>=(X_OFS+CWIDTH)){
9D009524  97828006   LHU V0, -32762(GP)
9D009528  2C430007   SLTIU V1, V0, 7
9D00952C  54600004   BNEL V1, ZERO, 0x9D009540
9D009530  24020139   ADDIU V0, ZERO, 313
80:                          cx -= CWIDTH;
9D009534  2442FFFA   ADDIU V0, V0, -6
9D009538  0B402559   J 0x9D009564
9D00953C  A7828006   SH V0, -32762(GP)
81:                      }else{
82:                          cx = X_OFS+CWIDTH*(CHAR_PER_LINE-1);
9D009540  A7828006   SH V0, -32762(GP)
83:                          if (cy>=(Y_OFS+CHEIGHT)){
9D009544  97828008   LHU V0, -32760(GP)
9D009548  2C43000B   SLTIU V1, V0, 11
9D00954C  14600003   BNE V1, ZERO, 0x9D00955C
9D009550  2442FFF8   ADDIU V0, V0, -8
84:                              cy -= CHEIGHT;
9D009554  0B402559   J 0x9D009564
9D009558  A7828008   SH V0, -32760(GP)
85:                          }else{
86:                              scroll_down();
9D00955C  0F40251C   JAL scroll_down
9D009560  00000000   NOP
87:                          }
88:                      }
89:                  }// cursor_left()
9D009564  8FBF0014   LW RA, 20(SP)
9D009568  03E00008   JR RA
9D00956C  27BD0018   ADDIU SP, SP, 24
90:                  
91:                  void cursor_up(void){
9D009570  27BDFFE8   ADDIU SP, SP, -24
9D009574  AFBF0014   SW RA, 20(SP)
92:                      if (cy>=(Y_OFS+CHEIGHT)){
9D009578  97828008   LHU V0, -32760(GP)
9D00957C  2C43000B   SLTIU V1, V0, 11
9D009580  14600003   BNE V1, ZERO, 0x9D009590
9D009584  2442FFF8   ADDIU V0, V0, -8
93:                          cy -= CHEIGHT;
9D009588  0B402566   J 0x9D009598
9D00958C  A7828008   SH V0, -32760(GP)
94:                      }else{
95:                          scroll_down();
9D009590  0F40251C   JAL scroll_down
9D009594  00000000   NOP
96:                      }
97:                  }// cursor_up()
9D009598  8FBF0014   LW RA, 20(SP)
9D00959C  03E00008   JR RA
9D0095A0  27BD0018   ADDIU SP, SP, 24
98:                  
99:                  void cursor_down(void){
9D0095A4  27BDFFE8   ADDIU SP, SP, -24
9D0095A8  AFBF0014   SW RA, 20(SP)
100:                     if (cy<=(Y_OFS+(CHEIGHT*(LINE_PER_SCREEN-2)))){
9D0095AC  97828008   LHU V0, -32760(GP)
9D0095B0  2C4300D4   SLTIU V1, V0, 212
9D0095B4  10600003   BEQ V1, ZERO, 0x9D0095C4
9D0095B8  24420008   ADDIU V0, V0, 8
101:                         cy += CHEIGHT;
9D0095BC  0B402573   J 0x9D0095CC
9D0095C0  A7828008   SH V0, -32760(GP)
102:                     }else{
103:                         scroll_up();
9D0095C4  0F40250B   JAL scroll_up
9D0095C8  00000000   NOP
104:                     }
105:                 }//cursor_down()
9D0095CC  8FBF0014   LW RA, 20(SP)
9D0095D0  03E00008   JR RA
9D0095D4  27BD0018   ADDIU SP, SP, 24
106:                 
107:                 void crlf(void){
9D0095D8  27BDFFE8   ADDIU SP, SP, -24
9D0095DC  AFBF0014   SW RA, 20(SP)
108:                     cx=X_OFS;
9D0095E0  24020001   ADDIU V0, ZERO, 1
9D0095E4  A7828006   SH V0, -32762(GP)
109:                     if (cy==(Y_OFS+(LINE_PER_SCREEN-1)*CHEIGHT)){
9D0095E8  97828008   LHU V0, -32760(GP)
9D0095EC  240300DB   ADDIU V1, ZERO, 219
9D0095F0  14430005   BNE V0, V1, 0x9D009608
9D0095F4  24420008   ADDIU V0, V0, 8
110:                         scroll_up();
9D0095F8  0F40250B   JAL scroll_up
9D0095FC  00000000   NOP
111:                     }else{
112:                         cy += CHEIGHT;
9D009608  A7828008   SH V0, -32760(GP)
113:                     }
114:                 }//crlf()
9D009600  0B402584   J 0x9D009610
9D009604  8FBF0014   LW RA, 20(SP)
9D00960C  8FBF0014   LW RA, 20(SP)
9D009610  03E00008   JR RA
9D009614  27BD0018   ADDIU SP, SP, 24
115:                 
116:                 void put_char(dev_t channel, char c){
9D009618  27BDFFE8   ADDIU SP, SP, -24
9D00961C  AFBF0014   SW RA, 20(SP)
9D009620  7C042420   SEB A0, A0
9D009624  7C052C20   SEB A1, A1
9D009718  24660001   ADDIU A2, V1, 1
9D00971C  2404000A   ADDIU A0, ZERO, 10
9D009720  70644802   MUL T1, V1, A0
9D009724  01282021   ADDU A0, T1, T0
9D009728  00044080   SLL T0, A0, 2
9D00972C  3C04A000   LUI A0, -24576
9D009730  2484016C   ADDIU A0, A0, 364
9D009734  00882021   ADDU A0, A0, T0
9D009738  3C089D01   LUI T0, -25343
9D00973C  2509D67C   ADDIU T1, T0, -10628
9D009740  24080007   ADDIU T0, ZERO, 7
9D009744  70A85002   MUL T2, A1, T0
9D009748  01492821   ADDU A1, T2, T1
9D00974C  24630008   ADDIU V1, V1, 8
117:                     register int i,l,r,b,x,y;
118:                     x=cx;
9D009628  97828006   LHU V0, -32762(GP)
119:                     y=cy;
120:                     if (channel==LOCAL_CON){
9D00962C  14800062   BNE A0, ZERO, 0x9D0097B8
9D009630  97838008   LHU V1, -32760(GP)
121:                         switch (c){
9D009634  24040009   ADDIU A0, ZERO, 9
9D009638  10A4000B   BEQ A1, A0, 0x9D009668
9D00963C  2404000D   ADDIU A0, ZERO, 13
9D009640  10A40005   BEQ A1, A0, 0x9D009658
9D009644  24040008   ADDIU A0, ZERO, 8
9D009648  14A4001F   BNE A1, A0, 0x9D0096C8
9D00964C  28A40020   SLTI A0, A1, 32
9D009650  0B4025AE   J 0x9D0096B8
9D009654  00000000   NOP
122:                             case CR:
123:                                 crlf();
9D009658  0F402576   JAL crlf
9D00965C  00000000   NOP
124:                                 break;
9D009660  0B4025F1   J 0x9D0097C4
9D009664  8FBF0014   LW RA, 20(SP)
125:                             case TAB:
126:                                 cx += (cx%tab_width);
9D009668  9384800A   LBU A0, -32758(GP)
9D00966C  0044001A   DIV V0, A0
9D009670  008001F4   TEQ A0, ZERO
9D009674  00002010   MFHI A0, 0
9D009678  00441021   ADDU V0, V0, A0
9D00967C  3042FFFF   ANDI V0, V0, -1
9D009680  A7828006   SH V0, -32762(GP)
127:                                 if (cx>=(X_OFS+CHAR_PER_LINE*CWIDTH)){
9D009684  2C42013F   SLTIU V0, V0, 319
9D009688  1440004D   BNE V0, ZERO, 0x9D0097C0
9D00968C  24020001   ADDIU V0, ZERO, 1
128:                                     cx = X_OFS;
9D009690  A7828006   SH V0, -32762(GP)
129:                                     if (cy==(Y_OFS+(LINE_PER_SCREEN-1)*CHEIGHT)){
9D009694  240200DB   ADDIU V0, ZERO, 219
9D009698  14620005   BNE V1, V0, 0x9D0096B0
9D00969C  24630008   ADDIU V1, V1, 8
130:                                         scroll_up();
9D0096A0  0F40250B   JAL scroll_up
9D0096A4  00000000   NOP
131:                                     }else{
132:                                         cy += CHEIGHT;
9D0096B0  0B4025F0   J 0x9D0097C0
9D0096B4  A7838008   SH V1, -32760(GP)
133:                                     }
134:                                 }
135:                                 break;
136:                             case '\b':
137:                                 cursor_left();
9D0096B8  0F402547   JAL cursor_left
9D0096BC  00000000   NOP
138:                                 break;
9D0096C0  0B4025F1   J 0x9D0097C4
9D0096C4  8FBF0014   LW RA, 20(SP)
139:                             default:
140:                                 if ((c<32) || (c>(FONT_SIZE+32))) break;
9D0096C8  1480003D   BNE A0, ZERO, 0x9D0097C0
9D0096CC  24A5FFE0   ADDIU A1, A1, -32
141:                                 c -=32;
9D0096D0  7C052C20   SEB A1, A1
142:                                 b=x>>5;
9D0096D4  00024143   SRA T0, V0, 5
143:                                 r=0;
144:                                 l=27-(x&0x1f);
9D0096D8  3042001F   ANDI V0, V0, 31
9D0096DC  2406001B   ADDIU A2, ZERO, 27
9D0096E0  00C21023   SUBU V0, A2, V0
145:                                 if (l<0){
146:                                     r=-l;
9D0096E4  00023023   SUBU A2, ZERO, V0
9D0096E8  28470000   SLTI A3, V0, 0
9D0096EC  0007300A   MOVZ A2, ZERO, A3
9D0096F0  00C03821   ADDU A3, A2, ZERO
147:                                 }
148:                                 for (i=0;i<7;i++){
9D0097A0  14C3FFEB   BNE A2, V1, 0x9D009750
9D0097A4  24A50001   ADDIU A1, A1, 1
149:                                     if (r){
9D009750  10E0000C   BEQ A3, ZERO, 0x9D009784
9D009754  8C890000   LW T1, 0(A0)
150:                                         video_bmp[y][b] &= ~(0x1f>>r);
9D0096F4  240C001F   ADDIU T4, ZERO, 31
9D0096F8  00CC7007   SRAV T6, T4, A2
9D0096FC  000E7027   NOR T6, ZERO, T6
9D00975C  01C94824   AND T1, T6, T1
151:                                         video_bmp[y][b] |= font5x7[c][i]>>r;
9D009758  90A80000   LBU T0, 0(A1)
9D009760  00E85007   SRAV T2, T0, A3
9D009764  012A4825   OR T1, T1, T2
9D009768  AC890000   SW T1, 0(A0)
152:                                         video_bmp[y][b+1] &= ~(0x1f<<32-r);
9D009700  240B0020   ADDIU T3, ZERO, 32
9D009704  01665823   SUBU T3, T3, A2
9D009708  016C6804   SLLV T5, T4, T3
9D00970C  000D6827   NOR T5, ZERO, T5
9D00976C  8C890004   LW T1, 4(A0)
9D009770  01A94824   AND T1, T5, T1
153:                                         video_bmp[y][b+1] |= font5x7[c][i]<<(32-r);
9D009774  01684004   SLLV T0, T0, T3
9D009778  01284025   OR T0, T1, T0
9D00977C  0B4025E6   J 0x9D009798
9D009780  AC880004   SW T0, 4(A0)
154:                                         y++;
155:                                     } else{
156:                                         video_bmp[y][b] &= ~(0x1f<<l);
9D009710  004C6004   SLLV T4, T4, V0
9D009714  000C6027   NOR T4, ZERO, T4
9D009784  01894824   AND T1, T4, T1
157:                                         video_bmp[y++][b] |= font5x7[c][i]<<l;
9D009788  90A80000   LBU T0, 0(A1)
9D00978C  00484004   SLLV T0, T0, V0
9D009790  01284025   OR T0, T1, T0
9D009794  AC880000   SW T0, 0(A0)
9D009798  24C60001   ADDIU A2, A2, 1
9D00979C  24840028   ADDIU A0, A0, 40
158:                                     }
159:                                 }
160:                                 cursor_right();
9D0097A8  0F40252E   JAL cursor_right
9D0097AC  00000000   NOP
161:                         }//switch(c)
162:                     }else{
163:                         UartPutch(channel,c);
9D0097B8  0F4032B4   JAL UartPutch
9D0097BC  00000000   NOP
164:                     }
165:                 }//put_char()
9D0096A8  0B4025F1   J 0x9D0097C4
9D0096AC  8FBF0014   LW RA, 20(SP)
9D0097B0  0B4025F1   J 0x9D0097C4
9D0097B4  8FBF0014   LW RA, 20(SP)
9D0097C0  8FBF0014   LW RA, 20(SP)
9D0097C4  03E00008   JR RA
9D0097C8  27BD0018   ADDIU SP, SP, 24
166:                 
167:                 void clear_screen(){
9D0097CC  27BDFFE8   ADDIU SP, SP, -24
9D0097D0  AFBF0014   SW RA, 20(SP)
168:                     memset(video_bmp,0,HRES/8*VRES);
9D0097D4  3C04A000   LUI A0, -24576
9D0097D8  2484016C   ADDIU A0, A0, 364
9D0097DC  00002821   ADDU A1, ZERO, ZERO
9D0097E0  0F403D34   JAL 0x9D00F4D0
9D0097E4  240623F0   ADDIU A2, ZERO, 9200
169:                     cx=X_OFS;
9D0097E8  24020001   ADDIU V0, ZERO, 1
9D0097EC  A7828006   SH V0, -32762(GP)
170:                     cy=Y_OFS;
9D0097F0  24020003   ADDIU V0, ZERO, 3
9D0097F4  A7828008   SH V0, -32760(GP)
171:                 } // clear_screen()
9D0097F8  8FBF0014   LW RA, 20(SP)
9D0097FC  03E00008   JR RA
9D009800  27BD0018   ADDIU SP, SP, 24
172:                 
173:                 void print(dev_t channel, const char *text){
9D009804  27BDFFE8   ADDIU SP, SP, -24
9D009808  AFBF0014   SW RA, 20(SP)
9D00980C  AFB00010   SW S0, 16(SP)
9D009810  7C042420   SEB A0, A0
174:                     if (channel==LOCAL_CON){
9D009814  1480000C   BNE A0, ZERO, 0x9D009848
9D009818  00A08021   ADDU S0, A1, ZERO
175:                         while (*text){
9D00981C  80A50000   LB A1, 0(A1)
9D009820  10A0000C   BEQ A1, ZERO, 0x9D009854
9D009824  8FBF0014   LW RA, 20(SP)
9D009834  82050000   LB A1, 0(S0)
9D009838  14A0FFFC   BNE A1, ZERO, 0x9D00982C
9D00983C  26100001   ADDIU S0, S0, 1
176:                             put_char(channel, *text++);
9D009828  26100001   ADDIU S0, S0, 1
9D00982C  0F402586   JAL put_char
9D009830  00002021   ADDU A0, ZERO, ZERO
177:                         }
178:                     }else{
179:                         UartPrint(channel,text);
9D009848  0F4032EC   JAL UartPrint
9D00984C  00000000   NOP
180:                     }
181:                 }// print()
9D009840  0B402615   J 0x9D009854
9D009844  8FBF0014   LW RA, 20(SP)
9D009850  8FBF0014   LW RA, 20(SP)
9D009854  8FB00010   LW S0, 16(SP)
9D009858  03E00008   JR RA
9D00985C  27BD0018   ADDIU SP, SP, 24
182:                 
183:                 void print_hex(dev_t channel, unsigned int hex, unsigned char width){
9D009860  27BDFFD8   ADDIU SP, SP, -40
9D009864  AFBF0024   SW RA, 36(SP)
9D009868  7C042420   SEB A0, A0
184:                     char c[12], *d;
185:                     int i;
186:                     c[11]=0;
9D00986C  A3A0001B   SB ZERO, 27(SP)
187:                     d= &c[10];
188:                     for(i=width;i>=0||hex;i--){
9D009870  30C600FF   ANDI A2, A2, 255
9D009874  0B40262A   J 0x9D0098A8
9D009878  27A2001A   ADDIU V0, SP, 26
9D0098A4  24C6FFFF   ADDIU A2, A2, -1
9D0098A8  04C1FFF4   BGEZ A2, 0x9D00987C
9D0098AC  30A3000F   ANDI V1, A1, 15
9D0098B0  14A0FFF3   BNE A1, ZERO, 0x9D009880
9D0098B4  2867000A   SLTI A3, V1, 10
189:                         *d=(hex%16);
190:                         if (*d<10)
9D00987C  2867000A   SLTI A3, V1, 10
9D009880  10E00004   BEQ A3, ZERO, 0x9D009894
9D009884  A0430000   SB V1, 0(V0)
191:                             *d += '0';
9D009888  24630030   ADDIU V1, V1, 48
9D00988C  0B402627   J 0x9D00989C
9D009890  A0430000   SB V1, 0(V0)
192:                         else
193:                             *d += 'A'-10;
9D009894  24630037   ADDIU V1, V1, 55
9D009898  A0430000   SB V1, 0(V0)
194:                         hex /=16;
9D00989C  00052902   SRL A1, A1, 4
195:                         d--;
9D0098A0  2442FFFF   ADDIU V0, V0, -1
196:                     }
197:                     print(channel, ++d);
9D0098B8  0F402601   JAL print
9D0098BC  24450001   ADDIU A1, V0, 1
198:                 } // print_hex()
9D0098C0  8FBF0024   LW RA, 36(SP)
9D0098C4  03E00008   JR RA
9D0098C8  27BD0028   ADDIU SP, SP, 40
199:                 
200:                 void print_int(dev_t channel, int number, unsigned short width){ // imprime entier,width inclus le signe
9D0098CC  27BDFFD8   ADDIU SP, SP, -40
9D0098D0  AFBF0024   SW RA, 36(SP)
9D0098D4  7C042420   SEB A0, A0
9D009960  00463023   SUBU A2, V0, A2
9D009964  00401821   ADDU V1, V0, ZERO
201:                     int sign=0, i;
202:                     char str[14], *d;
203:                     str[13]=0;
9D0098D8  30C2FFFF   ANDI V0, A2, -1
9D0098DC  2C42000E   SLTIU V0, V0, 14
9D0098E0  14400002   BNE V0, ZERO, 0x9D0098EC
9D0098E4  A3A0001D   SB ZERO, 29(SP)
9D0098E8  2406000D   ADDIU A2, ZERO, 13
9D0098EC  30C6FFFF   ANDI A2, A2, -1
204:                     d=&str[12];
9D009908  27A2001C   ADDIU V0, SP, 28
9D009944  27A2001C   ADDIU V0, SP, 28
205:                     if (width>13){width=13;}
206:                     if (number<0){
9D0098F0  04A10003   BGEZ A1, 0x9D009900
9D0098F4  00004021   ADDU T0, ZERO, ZERO
207:                         sign=1;
9D0098FC  24080001   ADDIU T0, ZERO, 1
208:                         number = -number;
9D0098F8  00052823   SUBU A1, ZERO, A1
209:                     }
210:                     //for (i=--width;i>=0||number;i--){
211:                     i=width;
212:                     while (number>0){
9D009900  18A00010   BLEZ A1, 0x9D009944
9D009904  00C04821   ADDU T1, A2, ZERO
9D00992C  1CA0FFF8   BGTZ A1, 0x9D009910
9D009930  24C6FFFF   ADDIU A2, A2, -1
213:                        *d--=(number%10)+'0';
9D00990C  2403000A   ADDIU V1, ZERO, 10
9D009910  00A3001A   DIV A1, V1
9D009914  006001F4   TEQ V1, ZERO
9D009918  00003810   MFHI A3, 0
9D00991C  00002812   MFLO A1, 0
9D009920  24E70030   ADDIU A3, A3, 48
9D009924  A0470000   SB A3, 0(V0)
9D009928  2442FFFF   ADDIU V0, V0, -1
214:                         number /= 10;
215:                         i--;
216:                     }
217:                     if (i==width){
9D009934  15260008   BNE T1, A2, 0x9D009958
9D009938  24030030   ADDIU V1, ZERO, 48
218:                         *d--='0';
9D00993C  0B402654   J 0x9D009950
9D009940  A0430000   SB V1, 0(V0)
9D009948  24030030   ADDIU V1, ZERO, 48
9D00994C  A0430000   SB V1, 0(V0)
9D009950  2442FFFF   ADDIU V0, V0, -1
219:                         i--;
9D009954  24C6FFFF   ADDIU A2, A2, -1
220:                     }
221:                     while (i>0){
9D009958  18C00009   BLEZ A2, 0x9D009980
9D00995C  00C03821   ADDU A3, A2, ZERO
9D009974  5466FFFE   BNEL V1, A2, 0x9D009970
9D009978  A0650000   SB A1, 0(V1)
9D00997C  00471023   SUBU V0, V0, A3
222:                         *d--=' ';
9D009968  24050020   ADDIU A1, ZERO, 32
9D00996C  A0650000   SB A1, 0(V1)
9D009970  2463FFFF   ADDIU V1, V1, -1
223:                         i--;
224:                     }
225:                     if (sign){*d='-';}else{*d=' ';}
9D009980  11000004   BEQ T0, ZERO, 0x9D009994
9D009984  24030020   ADDIU V1, ZERO, 32
9D009988  2403002D   ADDIU V1, ZERO, 45
9D00998C  0B402666   J 0x9D009998
9D009990  A0430000   SB V1, 0(V0)
9D009994  A0430000   SB V1, 0(V0)
226:                     
227:                     print(channel, d);
9D009998  0F402601   JAL print
9D00999C  00402821   ADDU A1, V0, ZERO
228:                 }// print_int()
9D0099A0  8FBF0024   LW RA, 36(SP)
9D0099A4  03E00008   JR RA
9D0099A8  27BD0028   ADDIU SP, SP, 40
229:                 
230:                 void set_tab_width(unsigned char width){
231:                     tab_width=width;
232:                 }// set_tab_width()
9D0099AC  03E00008   JR RA
9D0099B0  A384800A   SB A0, -32758(GP)
233:                 
234:                 void clear_eol(void){
9D0099B4  27BDFFE0   ADDIU SP, SP, -32
9D0099B8  AFBF001C   SW RA, 28(SP)
9D0099BC  AFB10018   SW S1, 24(SP)
9D0099C0  AFB00014   SW S0, 20(SP)
235:                     int x,y;
236:                     x=cx;
9D0099C4  97908006   LHU S0, -32762(GP)
237:                     y=cy;
238:                     while (cx<(X_OFS+CWIDTH*(CHAR_PER_LINE-1))){
9D0099C8  2E020139   SLTIU V0, S0, 313
9D0099CC  1040000A   BEQ V0, ZERO, 0x9D0099F8
9D0099D0  97918008   LHU S1, -32760(GP)
9D0099E8  97828006   LHU V0, -32762(GP)
9D0099EC  2C420139   SLTIU V0, V0, 313
9D0099F0  1440FFF9   BNE V0, ZERO, 0x9D0099D8
9D0099F4  00002021   ADDU A0, ZERO, ZERO
239:                         put_char(LOCAL_CON, 32);
9D0099D4  00002021   ADDU A0, ZERO, ZERO
9D0099D8  0F402586   JAL put_char
9D0099DC  24050020   ADDIU A1, ZERO, 32
240:                         cursor_right();
9D0099E0  0F40252E   JAL cursor_right
9D0099E4  00000000   NOP
241:                     }
242:                     put_char(LOCAL_CON, 32);
9D0099F8  00002021   ADDU A0, ZERO, ZERO
9D0099FC  0F402586   JAL put_char
9D009A00  24050020   ADDIU A1, ZERO, 32
243:                     cx=x;
9D009A04  A7908006   SH S0, -32762(GP)
244:                     cy=y;
9D009A08  A7918008   SH S1, -32760(GP)
245:                 }// clear_eol()
9D009A0C  8FBF001C   LW RA, 28(SP)
9D009A10  8FB10018   LW S1, 24(SP)
9D009A14  8FB00014   LW S0, 20(SP)
9D009A18  03E00008   JR RA
9D009A1C  27BD0020   ADDIU SP, SP, 32
246:                 
247:                 text_coord_t get_curpos(){
9D009A20  00801021   ADDU V0, A0, ZERO
248:                     text_coord_t cpos;
249:                     cpos.x = (cx-X_OFS)/CWIDTH;
9D009A3C  97838006   LHU V1, -32762(GP)
9D009A40  2463FFFF   ADDIU V1, V1, -1
9D009A44  3C052AAA   LUI A1, 10922
9D009A48  34A5AAAB   ORI A1, A1, -21845
9D009A4C  00650018   MULT 0, V1, A1
9D009A50  00031FC3   SRA V1, V1, 31
9D009A54  00003810   MFHI A3, 0
9D009A58  00E31823   SUBU V1, A3, V1
9D009A5C  A4430000   SH V1, 0(V0)
250:                     cpos.y = (cy-Y_OFS)/CHEIGHT;
9D009A24  97848008   LHU A0, -32760(GP)
9D009A28  2483FFFD   ADDIU V1, A0, -3
9D009A2C  24840004   ADDIU A0, A0, 4
9D009A30  28650000   SLTI A1, V1, 0
9D009A34  0065200A   MOVZ A0, V1, A1
9D009A38  7C8478C0   EXT A0, A0, 3, 16
251:                     return cpos;
252:                 } // get_cursor_pos()
9D009A60  03E00008   JR RA
9D009A64  A4440002   SH A0, 2(V0)
253:                 
254:                 void set_curpos(unsigned short x, unsigned short y){// {x,y} coordonnée caractère
9D009A68  3084FFFF   ANDI A0, A0, -1
255:                     if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
9D009A6C  2C820035   SLTIU V0, A0, 53
9D009A70  1040000A   BEQ V0, ZERO, 0x9D009A9C
9D009A74  30A5FFFF   ANDI A1, A1, -1
9D009A78  2CA2001C   SLTIU V0, A1, 28
9D009A7C  10400007   BEQ V0, ZERO, 0x9D009A9C
9D009A80  24020006   ADDIU V0, ZERO, 6
256:                         return;
257:                     cx=x*CWIDTH+X_OFS;
9D009A84  70822002   MUL A0, A0, V0
9D009A88  24840001   ADDIU A0, A0, 1
9D009A8C  A7848006   SH A0, -32762(GP)
258:                     cy=y*CHEIGHT+Y_OFS;
9D009A90  000528C0   SLL A1, A1, 3
9D009A94  24A50003   ADDIU A1, A1, 3
9D009A98  A7858008   SH A1, -32760(GP)
9D009A9C  03E00008   JR RA
9D009AA0  00000000   NOP
259:                 }//set_curpos()
260:                 
261:                 void invert_char(void){// inverse vidéo du caractère à la position courante
9D009AE0  24A30001   ADDIU V1, A1, 1
9D009AE4  2402000A   ADDIU V0, ZERO, 10
9D009AE8  70A25002   MUL T2, A1, V0
9D009AEC  01461021   ADDU V0, T2, A2
9D009AF0  00023080   SLL A2, V0, 2
9D009AF4  3C02A000   LUI V0, -24576
9D009AF8  2442016C   ADDIU V0, V0, 364
9D009AFC  00461021   ADDU V0, V0, A2
9D009B00  24A50009   ADDIU A1, A1, 9
262:                     register int i,l,r,b,x,y;
263:                     x=cx;
9D009AA4  97878006   LHU A3, -32762(GP)
264:                     y=cy;
9D009AA8  97858008   LHU A1, -32760(GP)
265:                     b=x>>5;
9D009AAC  00073143   SRA A2, A3, 5
266:                     r=0;
267:                     l=27-(x&0x1f);
9D009AB0  30E7001F   ANDI A3, A3, 31
9D009AB4  2403001B   ADDIU V1, ZERO, 27
9D009AB8  00673823   SUBU A3, V1, A3
268:                     if (l<0){
269:                         r=-l;
9D009ABC  00071823   SUBU V1, ZERO, A3
9D009AC0  28E40000   SLTI A0, A3, 0
9D009AC4  0004180A   MOVZ V1, ZERO, A0
9D009AC8  00602021   ADDU A0, V1, ZERO
270:                     }
271:                     for (i=8;i;i--){
9D009B30  1465FFF4   BNE V1, A1, 0x9D009B04
9D009B34  24420028   ADDIU V0, V0, 40
272:                         if (r){
9D009B04  10800007   BEQ A0, ZERO, 0x9D009B24
9D009B08  8C460000   LW A2, 0(V0)
273:                             video_bmp[y][b] ^= (0x1f>>r);
9D009ACC  2403001F   ADDIU V1, ZERO, 31
9D009AD0  00834807   SRAV T1, V1, A0
9D009B0C  00C93026   XOR A2, A2, T1
9D009B10  AC460000   SW A2, 0(V0)
274:                             video_bmp[y][b+1] ^= (0x1f<<32-r);
9D009AD4  00044023   SUBU T0, ZERO, A0
9D009AD8  01034004   SLLV T0, V1, T0
9D009B14  8C460004   LW A2, 4(V0)
9D009B18  00C83026   XOR A2, A2, T0
9D009B1C  0B4026CB   J 0x9D009B2C
9D009B20  AC460004   SW A2, 4(V0)
275:                             y++;
276:                         } else{
277:                             video_bmp[y++][b] ^= (0x1f<<l);
9D009ADC  00E33804   SLLV A3, V1, A3
9D009B24  00C73026   XOR A2, A2, A3
9D009B28  AC460000   SW A2, 0(V0)
9D009B2C  24630001   ADDIU V1, V1, 1
278:                         }
279:                     }
280:                 }//invert_char()
9D009B38  03E00008   JR RA
9D009B3C  00000000   NOP
281:                 
282:                 static void toggle_underscore(void){
283:                     register int l,r,b,x;
284:                     x=cx;
9D009370  97828006   LHU V0, -32762(GP)
285:                     b=x>>5;
9D009374  00025143   SRA T2, V0, 5
286:                     r=0;
287:                     l=27-(x&0x1f);
9D009378  3042001F   ANDI V0, V0, 31
9D00937C  2403001B   ADDIU V1, ZERO, 27
9D009380  00621023   SUBU V0, V1, V0
288:                     if (l<0){
9D009384  0441001B   BGEZ V0, 0x9D0093F4
9D009388  97838008   LHU V1, -32760(GP)
289:                         r=-l;
9D00938C  00022023   SUBU A0, ZERO, V0
290:                     }
291:                     if (r){
9D009390  10800018   BEQ A0, ZERO, 0x9D0093F4
9D009394  2405000A   ADDIU A1, ZERO, 10
292:                         video_bmp[cy+CHEIGHT-1][b] ^= (0x1f>>r);
9D009398  97828008   LHU V0, -32760(GP)
9D00939C  24420007   ADDIU V0, V0, 7
9D0093A0  70451002   MUL V0, V0, A1
9D0093A4  004A3821   ADDU A3, V0, T2
9D0093A8  00073880   SLL A3, A3, 2
9D0093AC  3C06A000   LUI A2, -24576
9D0093B0  24C6016C   ADDIU A2, A2, 364
9D0093B4  00E63821   ADDU A3, A3, A2
9D0093B8  2405001F   ADDIU A1, ZERO, 31
9D0093BC  00854807   SRAV T1, A1, A0
9D0093C0  8CE80000   LW T0, 0(A3)
9D0093C4  01284026   XOR T0, T1, T0
9D0093C8  ACE80000   SW T0, 0(A3)
293:                         video_bmp[cy+CHEIGHT-1][b+1] ^= (0x1f<<32-r);
9D0093CC  25430001   ADDIU V1, T2, 1
9D0093D0  00431021   ADDU V0, V0, V1
9D0093D4  00021080   SLL V0, V0, 2
9D0093D8  00461021   ADDU V0, V0, A2
9D0093DC  00042023   SUBU A0, ZERO, A0
9D0093E0  00852804   SLLV A1, A1, A0
9D0093E4  8C430000   LW V1, 0(V0)
9D0093E8  00A32826   XOR A1, A1, V1
9D0093EC  03E00008   JR RA
9D0093F0  AC450000   SW A1, 0(V0)
294:                     } else{
295:                         video_bmp[cy+CHEIGHT-1][b] ^= (0x1f<<l);
9D0093F4  24630007   ADDIU V1, V1, 7
9D0093F8  2404000A   ADDIU A0, ZERO, 10
9D0093FC  70642802   MUL A1, V1, A0
9D009400  00AA1821   ADDU V1, A1, T2
9D009404  00031880   SLL V1, V1, 2
9D009408  3C04A000   LUI A0, -24576
9D00940C  2484016C   ADDIU A0, A0, 364
9D009410  00641821   ADDU V1, V1, A0
9D009414  2404001F   ADDIU A0, ZERO, 31
9D009418  00441004   SLLV V0, A0, V0
9D00941C  8C640000   LW A0, 0(V1)
9D009420  00441026   XOR V0, V0, A0
9D009424  03E00008   JR RA
9D009428  AC620000   SW V0, 0(V1)
296:                     }
297:                 }//toggle_underscore()
298:                 
299:                 void show_cursor(BOOL show){
9D009B40  27BDFFE8   ADDIU SP, SP, -24
9D009B44  AFBF0014   SW RA, 20(SP)
300:                     if (show){
9D009B48  10800011   BEQ A0, ZERO, 0x9D009B90
9D009B4C  AFB00010   SW S0, 16(SP)
301:                         flags |= CUR_SHOW;
9D009B50  97828066   LHU V0, -32666(GP)
9D009B54  34420001   ORI V0, V0, 1
302:                         flags ^= CUR_VIS;
9D009B58  38420002   XORI V0, V0, 2
9D009B5C  A7828066   SH V0, -32666(GP)
303:                         if (cur_shape==CR_BLOCK){
9D009B60  24020001   ADDIU V0, ZERO, 1
9D009B64  8F838068   LW V1, -32664(GP)
9D009B68  14620005   BNE V1, V0, 0x9D009B80
9D009B6C  00000000   NOP
304:                             invert_char();
9D009B70  0F4026A9   JAL invert_char
9D009B74  00000000   NOP
305:                         }else{
306:                             toggle_underscore();
9D009B80  0F4024DC   JAL 0x9D009370
9D009B84  00000000   NOP
307:                         }
308:                     }else{
309:                         if (flags & CUR_VIS){
9D009B90  97908066   LHU S0, -32666(GP)
9D009B94  32020002   ANDI V0, S0, 2
9D009B98  1040000D   BEQ V0, ZERO, 0x9D009BD0
9D009B9C  97828066   LHU V0, -32666(GP)
310:                             if (cur_shape==CR_BLOCK){
9D009BA0  24020001   ADDIU V0, ZERO, 1
9D009BA4  8F838068   LW V1, -32664(GP)
9D009BA8  14620005   BNE V1, V0, 0x9D009BC0
9D009BAC  00000000   NOP
311:                                 invert_char();
9D009BB0  0F4026A9   JAL invert_char
9D009BB4  3210FFFD   ANDI S0, S0, -3
312:                             }else{
313:                                 toggle_underscore();
9D009BC0  0F4024DC   JAL 0x9D009370
9D009BC4  3210FFFD   ANDI S0, S0, -3
314:                             }
315:                             flags &= ~CUR_VIS;
9D009BB8  0B4026F3   J 0x9D009BCC
9D009BBC  A7908066   SH S0, -32666(GP)
9D009BC8  A7908066   SH S0, -32666(GP)
316:                         }
317:                         flags &= ~CUR_SHOW;
9D009BCC  97828066   LHU V0, -32666(GP)
9D009BD0  3042FFFE   ANDI V0, V0, -2
9D009BD4  A7828066   SH V0, -32666(GP)
318:                     }
319:                 
320:                 }// show_cursor()
9D009B78  0B4026F7   J 0x9D009BDC
9D009B7C  8FBF0014   LW RA, 20(SP)
9D009B88  0B4026F7   J 0x9D009BDC
9D009B8C  8FBF0014   LW RA, 20(SP)
9D009BD8  8FBF0014   LW RA, 20(SP)
9D009BDC  8FB00010   LW S0, 16(SP)
9D009BE0  03E00008   JR RA
9D009BE4  27BD0018   ADDIU SP, SP, 24
321:                 
322:                 void set_cursor(cursor_t shape){
9D009BE8  27BDFFE8   ADDIU SP, SP, -24
9D009BEC  AFBF0014   SW RA, 20(SP)
9D009BF0  AFB00010   SW S0, 16(SP)
323:                     if (flags & CUR_VIS){
9D009BF4  97828066   LHU V0, -32666(GP)
9D009BF8  30420002   ANDI V0, V0, 2
9D009BFC  10400008   BEQ V0, ZERO, 0x9D009C20
9D009C00  00808021   ADDU S0, A0, ZERO
324:                         show_cursor(FALSE);
9D009C04  0F4026D0   JAL show_cursor
9D009C08  00002021   ADDU A0, ZERO, ZERO
325:                         cur_shape=shape;
9D009C0C  AF908068   SW S0, -32664(GP)
326:                         show_cursor(TRUE);
9D009C10  0F4026D0   JAL show_cursor
9D009C14  24040001   ADDIU A0, ZERO, 1
327:                     }else{
328:                         cur_shape=shape;
9D009C20  AF848068   SW A0, -32664(GP)
329:                     }
330:                 }// set_cursor()
9D009C18  0B40270A   J 0x9D009C28
9D009C1C  8FBF0014   LW RA, 20(SP)
9D009C24  8FBF0014   LW RA, 20(SP)
9D009C28  8FB00010   LW S0, 16(SP)
9D009C2C  03E00008   JR RA
9D009C30  27BD0018   ADDIU SP, SP, 24
331:                 
332:                 unsigned short get_key(dev_t channel){ // lecture touche clavier, retourne 0 s'il n'y a pas de touche ou touche relâchée.
9D009C34  27BDFFE8   ADDIU SP, SP, -24
9D009C38  7C042420   SEB A0, A0
333:                     unsigned short code;
334:                     if (channel==LOCAL_CON){
9D009C3C  1480000C   BNE A0, ZERO, 0x9D009C70
9D009C40  AFBF0014   SW RA, 20(SP)
335:                         code=  KbdScancode();
9D009C44  0F401FCC   JAL KbdScancode
9D009C48  00000000   NOP
9D009C4C  00402021   ADDU A0, V0, ZERO
9D009C50  3042FFFF   ANDI V0, V0, -1
336:                         if (!(code & FN_BIT)){
9D009C54  30430200   ANDI V1, V0, 512
9D009C58  14600009   BNE V1, ZERO, 0x9D009C80
9D009C5C  8FBF0014   LW RA, 20(SP)
337:                             code = KbdKey(code);
9D009C60  0F401EA5   JAL KbdKey
9D009C64  00000000   NOP
9D009C68  0B40271F   J 0x9D009C7C
9D009C6C  3042FFFF   ANDI V0, V0, -1
338:                         }
339:                     }else{
340:                         code=UartGetch(STDIN);
9D009C70  0F4032A7   JAL UartGetch
9D009C74  24040001   ADDIU A0, ZERO, 1
9D009C78  3042FFFF   ANDI V0, V0, -1
341:                         if (code==-1){
342:                             code=0;
343:                         }
344:                     }
345:                     return code;
346:                 }//get_key()
9D009C7C  8FBF0014   LW RA, 20(SP)
9D009C80  03E00008   JR RA
9D009C84  27BD0018   ADDIU SP, SP, 24
347:                 
348:                 unsigned short wait_key(dev_t channel){ // attend qu'une touche soit enfoncée et retourne sa valeur.
9D009C88  27BDFFE0   ADDIU SP, SP, -32
9D009C8C  AFBF001C   SW RA, 28(SP)
9D009C90  AFB10018   SW S1, 24(SP)
9D009C94  AFB00014   SW S0, 20(SP)
349:                     unsigned short key;
350:                     unsigned int t0;
351:                     t0=ticks()+500;
9D009C98  0F40355C   JAL ticks
9D009C9C  7C048420   SEB S0, A0
352:                     if (channel==LOCAL_CON){
9D009CA0  12000013   BEQ S0, ZERO, 0x9D009CF0
9D009CA4  245101F4   ADDIU S1, V0, 500
353:                         while (!(key=get_key(channel))){
9D009CF0  0F40270D   JAL get_key
9D009CF4  00002021   ADDU A0, ZERO, ZERO
9D009CF8  1040FFED   BEQ V0, ZERO, 0x9D009CB0
9D009CFC  00408021   ADDU S0, V0, ZERO
354:                             if (ticks()==t0){
9D009CB0  0F40355C   JAL ticks
9D009CB4  00000000   NOP
9D009CB8  1451000D   BNE V0, S1, 0x9D009CF0
9D009CBC  97828066   LHU V0, -32666(GP)
355:                                 if (flags & CUR_SHOW){
9D009CC0  30420001   ANDI V0, V0, 1
9D009CC4  10400005   BEQ V0, ZERO, 0x9D009CDC
9D009CC8  00000000   NOP
356:                                     show_cursor(FALSE);
9D009CCC  0F4026D0   JAL show_cursor
9D009CD0  00002021   ADDU A0, ZERO, ZERO
9D009CD4  0B402739   J 0x9D009CE4
9D009CD8  00000000   NOP
357:                                 }else{
358:                                     show_cursor(TRUE);
9D009CDC  0F4026D0   JAL show_cursor
9D009CE0  24040001   ADDIU A0, ZERO, 1
359:                                 }
360:                                 t0=ticks()+500;
9D009CE4  0F40355C   JAL ticks
9D009CE8  00000000   NOP
9D009CEC  245101F4   ADDIU S1, V0, 500
361:                             }
362:                         };
363:                         show_cursor(FALSE);
9D009D00  0F4026D0   JAL show_cursor
9D009D04  00002021   ADDU A0, ZERO, ZERO
364:                     }else{
365:                         key=UartWaitch(STDIN,0);
9D009CA8  0B402744   J 0x9D009D10
9D009CAC  24040001   ADDIU A0, ZERO, 1
9D009D10  0F4032C2   JAL UartWaitch
9D009D14  00002821   ADDU A1, ZERO, ZERO
9D009D18  3050FFFF   ANDI S0, V0, -1
366:                     }
367:                     return key;
368:                 }//wait_key()
9D009D08  0B402748   J 0x9D009D20
9D009D0C  02001021   ADDU V0, S0, ZERO
9D009D1C  02001021   ADDU V0, S0, ZERO
9D009D20  8FBF001C   LW RA, 28(SP)
9D009D24  8FB10018   LW S1, 24(SP)
9D009D28  8FB00014   LW S0, 20(SP)
9D009D2C  03E00008   JR RA
9D009D30  27BD0020   ADDIU SP, SP, 32
369:                 
370:                 unsigned char readline(dev_t channel, unsigned char *ibuff,unsigned char max_char){ // lit une ligne au clavier, retourne la longueur de texte.
9D009D34  27BDFFD0   ADDIU SP, SP, -48
9D009D38  AFBF002C   SW RA, 44(SP)
9D009D3C  AFB50028   SW S5, 40(SP)
9D009D40  AFB40024   SW S4, 36(SP)
9D009D44  AFB30020   SW S3, 32(SP)
9D009D48  AFB2001C   SW S2, 28(SP)
9D009D4C  AFB10018   SW S1, 24(SP)
9D009D50  AFB00014   SW S0, 20(SP)
9D009D54  00A09821   ADDU S3, A1, ZERO
9D009D58  7C042420   SEB A0, A0
371:                     unsigned char c=0, count=0;
372:                     if (channel==LOCAL_CON){
9D009D5C  14800025   BNE A0, ZERO, 0x9D009DF4
9D009D60  30D400FF   ANDI S4, A2, 255
9D009D64  00008021   ADDU S0, ZERO, ZERO
373:                         while ((c!='\r') && (count<=max_char)){
9D009DC0  0B402779   J 0x9D009DE4
9D009DC4  0290102B   SLTU V0, S4, S0
9D009DE0  0290102B   SLTU V0, S4, S0
9D009DE4  1040FFE4   BEQ V0, ZERO, 0x9D009D78
9D009DE8  00000000   NOP
374:                             c=wait_key(channel);
9D009D78  0F402722   JAL wait_key
9D009D7C  00002021   ADDU A0, ZERO, ZERO
9D009D80  304200FF   ANDI V0, V0, 255
375:                             if (c==CR){
9D009D68  2411000D   ADDIU S1, ZERO, 13
9D009D84  14510005   BNE V0, S1, 0x9D009D9C
9D009D88  00002021   ADDU A0, ZERO, ZERO
376:                                 put_char(channel,'\r');
9D009D8C  0F402586   JAL put_char
9D009D90  2405000D   ADDIU A1, ZERO, 13
377:                                 break;
9D009D94  0B402781   J 0x9D009E04
9D009D98  A2600000   SB ZERO, 0(S3)
378:                             }else if (c==BS){
9D009D6C  24120008   ADDIU S2, ZERO, 8
9D009D9C  5452000A   BNEL V0, S2, 0x9D009DC8
9D009DA0  A2620000   SB V0, 0(S3)
379:                                 if (count){
9D009DA4  1200FFF4   BEQ S0, ZERO, 0x9D009D78
9D009DA8  00002021   ADDU A0, ZERO, ZERO
380:                                     ibuff--;
9D009DAC  2673FFFF   ADDIU S3, S3, -1
381:                                     count--;
9D009DB0  2610FFFF   ADDIU S0, S0, -1
9D009DB4  321000FF   ANDI S0, S0, 255
382:                                     print(channel,"\b \b");
9D009D70  3C159D01   LUI S5, -25343
9D009D74  26B50088   ADDIU S5, S5, 136
9D009DB8  0F402601   JAL print
9D009DBC  02A02821   ADDU A1, S5, ZERO
383:                                 }
384:                             }else if ((c & FN_BIT)==0){
385:                                 *ibuff++=c;
9D009DC8  26730001   ADDIU S3, S3, 1
386:                                 count++;
9D009DCC  26100001   ADDIU S0, S0, 1
9D009DD0  321000FF   ANDI S0, S0, 255
387:                                 put_char(channel, c);
9D009DD4  00002021   ADDU A0, ZERO, ZERO
9D009DD8  0F402586   JAL put_char
9D009DDC  7C022C20   SEB A1, V0
388:                             }
389:                         }// while
390:                         *ibuff=(char)0;
9D009DEC  0B402781   J 0x9D009E04
9D009DF0  A2600000   SB ZERO, 0(S3)
391:                     }else{
392:                         count=UartReadln(STDIN,ibuff,max_char);
9D009DF4  24040001   ADDIU A0, ZERO, 1
9D009DF8  0F403308   JAL UartReadln
9D009DFC  02803021   ADDU A2, S4, ZERO
9D009E00  305000FF   ANDI S0, V0, 255
393:                     }
394:                     return count;
395:                 } // readline()
9D009E04  02001021   ADDU V0, S0, ZERO
9D009E08  8FBF002C   LW RA, 44(SP)
9D009E0C  8FB50028   LW S5, 40(SP)
9D009E10  8FB40024   LW S4, 36(SP)
9D009E14  8FB30020   LW S3, 32(SP)
9D009E18  8FB2001C   LW S2, 28(SP)
9D009E1C  8FB10018   LW S1, 24(SP)
9D009E20  8FB00014   LW S0, 20(SP)
9D009E24  03E00008   JR RA
9D009E28  27BD0030   ADDIU SP, SP, 48
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/DiosForth.X/source/VM/VMword.c  -------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*********************************************************************
19:                   *
20:                   *                  VMword
21:                   *                  DIOS Forth
22:                   *
23:                   * v.1.0 - 20.12.2012, L.Pekny
24:                   ********************************************************************/
25:                  
26:                  #include <math.h>
27:                  
28:                  #include <plib.h>
29:                  #include <errno.h>
30:                  #include "../../../hardware/HardwareProfile.h"
31:                  #include "..\GenericTypeDefs.h"
32:                  //#include "..\HardwareProfile.h"
33:                  #ifdef VPC_32
34:                  #include "../../../console.h"
35:                  #else
36:                  #include "..\Uart\UartBuf.h"	// emit ?emit key ?key
37:                  #endif
38:                  #include "..\NVMem\NVMem.h"		// flash >flash ;flash
39:                  #ifndef VPC_32
40:                  #include "..\Main.h"			// devhead  devcall
41:                  #endif
42:                  #include "VMcore.h"
43:                  #include "VMword.h"
44:                  
45:                  #ifdef VPC_32
46:                  char *vTib=NULL, *vPad=NULL, *vDict=NULL, *vMem=NULL;
47:                  #else
48:                  char  vTib[tibsize+4], vPad[padsize+4];
49:                  char  vDict[dictsize], vMem[memsize];
50:                  #endif
51:                  //char  *pDict=vDict, *pMem=vMem;
52:                  char *vHere, *vHead, *vHeap, *vCurrent, *vContext;
53:                  char *vHereBak, *vHeadBak;
54:                  BYTE  vIN=0, vSharpTib=0, vBase=16, vState=0, vErrors=0;
55:                  WORD  PrimLast=0;
56:                  BYTE  AddrRAM, AddrROM;
57:                  const char StrVer[]=VerVM;
58:                  
59:                  // functions that are forward referenced
60:                  void abortf(void);
61:                  void linkg(void);
62:                  void comma(void);
63:                  void tick(void);
64:                  void crf(void);
65:                  void aborts(void);
66:                  void udot(void);
67:                  void ver(void);
68:                  void toflash(void);
69:                  void dotstring(void);
70:                  
71:                  // ********** C UTIL **********
72:                  
73:                  void FindLastC(void)  // Find last primitive word
74:                  {
75:                  	WORD i=0;
9D002A9C  00001821   ADDU V1, ZERO, ZERO
76:                  	while(primwords[i].wlink!=0xFF) {i++;}
9D002AA0  2406000C   ADDIU A2, ZERO, 12
9D002AA4  3C029D00   LUI V0, -25344
9D002AA8  24477008   ADDIU A3, V0, 28680
9D002AAC  240500FF   ADDIU A1, ZERO, 255
9D002AB0  24620001   ADDIU V0, V1, 1
9D002AB4  3042FFFF   ANDI V0, V0, -1
9D002AB8  70464002   MUL T0, V0, A2
9D002ABC  01072021   ADDU A0, T0, A3
9D002AC0  94840000   LHU A0, 0(A0)
9D002AC4  5485FFFA   BNEL A0, A1, 0x9D002AB0
9D002AC8  00401821   ADDU V1, V0, ZERO
77:                  	PrimLast=--i;
78:                  }
9D002ACC  03E00008   JR RA
9D002AD0  A7838090   SH V1, -32624(GP)
79:                  
80:                  
81:                  void EEcold(void)  // Find empty 4kB or find last FHere in EETAB, recovery He..
9D002B84  3C069CFF   LUI A2, -25345
9D002B88  34C6FFFC   ORI A2, A2, -4
9D002B8C  01463021   ADDU A2, T2, A2
82:                  {
83:                  	UINT i, f=1, uFHere;
84:                  	UINT *pEETAB;
85:                  
86:                  	i=EETAB; pEETAB=(UINT *)i;		// Cannot make pointer directly from EETAB
9D002AD4  3C02BF88   LUI V0, -16504
9D002AD8  8C4A2060   LW T2, 8288(V0)
9D002ADC  3C0B9CFF   LUI T3, -25345
9D002AE0  356BF000   ORI T3, T3, -4096
9D002AE4  014B5821   ADDU T3, T2, T3
87:                  
88:                  	vFHead=0; uFHere=(int)StrVer&~0xFFF;	// Find empty flash 4kB
9D002AE8  AF808118   SW ZERO, -32488(GP)
9D002AEC  2402F000   ADDIU V0, ZERO, -4096
9D002AF0  3C069D00   LUI A2, -25344
9D002AF4  24C66A34   ADDIU A2, A2, 27188
9D002AF8  00C23024   AND A2, A2, V0
89:                  	while (f)
9D002B64  5460FFEA   BNEL V1, ZERO, 0x9D002B10
9D002B68  24C61000   ADDIU A2, A2, 4096
90:                  	{ f=0;
91:                  	  uFHere+=FLASH_PAGE_SIZE;
9D002B0C  24C61000   ADDIU A2, A2, 4096
9D002B10  24C41000   ADDIU A0, A2, 4096
9D002B6C  00C02021   ADDU A0, A2, ZERO
92:                  	  for (i=uFHere; i<(uFHere+FLASH_PAGE_SIZE); i+=4)
9D002B14  00C4382B   SLTU A3, A2, A0
9D002B18  10E0000E   BEQ A3, ZERO, 0x9D002B54
9D002B1C  00001821   ADDU V1, ZERO, ZERO
9D002B40  24420004   ADDIU V0, V0, 4
9D002B44  0044182B   SLTU V1, V0, A0
9D002B48  5460FFFB   BNEL V1, ZERO, 0x9D002B38
9D002B4C  8C430000   LW V1, 0(V0)
9D002B50  00001821   ADDU V1, ZERO, ZERO
93:                  	  {
94:                  		if (*(int *)i!=-1) {f=1; break;}
9D002AFC  2405FFFF   ADDIU A1, ZERO, -1
9D002B20  8CC70000   LW A3, 0(A2)
9D002B24  24030001   ADDIU V1, ZERO, 1
9D002B28  10E50005   BEQ A3, A1, 0x9D002B40
9D002B2C  00C01021   ADDU V0, A2, ZERO
9D002B30  0B400AD5   J 0x9D002B54
9D002B34  00000000   NOP
9D002B38  14650006   BNE V1, A1, 0x9D002B54
9D002B3C  24030001   ADDIU V1, ZERO, 1
95:                  	  }
96:                  	  if (uFHere==EETAB) {f=0;}				// End of flash
9D002B00  3C09BF88   LUI T1, -16504
9D002B04  3C089CFF   LUI T0, -25345
9D002B08  3508F000   ORI T0, T0, -4096
9D002B54  8D242060   LW A0, 8288(T1)
9D002B58  00882021   ADDU A0, A0, T0
9D002B5C  50860005   BEQL A0, A2, 0x9D002B74
9D002B60  AF848114   SW A0, -32492(GP)
97:                  	}
98:                  	vFHere=(UINT *)uFHere;
9D002B70  AF848114   SW A0, -32492(GP)
99:                  
100:                 	if (*pEETAB!=-1)						// Read last vector from EETAB
9D002B74  8D640000   LW A0, 0(T3)
9D002B78  2402FFFF   ADDIU V0, ZERO, -1
9D002B7C  10820017   BEQ A0, V0, 0x9D002BDC
9D002B80  25620004   ADDIU V0, T3, 4
101:                 	{ f=0;
102:                 	  for (i=0; i<FLASH_PAGE_SIZE; i+=4)	// Find last FHere
9D002BA0  10460003   BEQ V0, A2, 0x9D002BB0
9D002BA4  24420004   ADDIU V0, V0, 4
103:                 	  {
104:                 		if (*pEETAB==-1) {break;} else {uFHere=*pEETAB; f=1;}
9D002B90  2405FFFF   ADDIU A1, ZERO, -1
9D002B94  8C430000   LW V1, 0(V0)
9D002B98  50650007   BEQL V1, A1, 0x9D002BB8
9D002B9C  AF848114   SW A0, -32492(GP)
9D002BA8  0B400AE5   J 0x9D002B94
9D002BAC  00602021   ADDU A0, V1, ZERO
9D002BB0  00602021   ADDU A0, V1, ZERO
105:                 		pEETAB++;
106:                 	  }
107:                 	  vFHere=(UINT *)uFHere;
9D002BB4  AF848114   SW A0, -32492(GP)
108:                 	  if (f&&(*(vFHere-1)==(uFHere-4)))		// Recovery Head, Heap
9D002BB8  2482FFFC   ADDIU V0, A0, -4
9D002BBC  8C83FFFC   LW V1, -4(A0)
9D002BC0  14620006   BNE V1, V0, 0x9D002BDC
9D002BC4  00000000   NOP
109:                 	    {vFHead=(UINT *)(*(vFHere-2)); vHeap=(char *)(*(vFHere-3)); vHead=(char *)vFHead;}
9D002BC8  8C82FFF8   LW V0, -8(A0)
9D002BCC  AF828118   SW V0, -32488(GP)
9D002BD0  8C83FFF4   LW V1, -12(A0)
9D002BD4  AF83810C   SW V1, -32500(GP)
9D002BD8  AF828104   SW V0, -32508(GP)
9D002BDC  03E00008   JR RA
9D002BE0  00000000   NOP
110:                 	}
111:                 }
112:                 
113:                 
114:                 void CompileCxt(WORD i)  // compile xt primitive for C
115:                 {
9D002BE4  27BDFFE8   ADDIU SP, SP, -24
9D002BE8  AFBF0014   SW RA, 20(SP)
9D002BEC  3084FFFF   ANDI A0, A0, -1
116:                 	PUSH((ucell)&primwords[i].wcall); comma(); // XT ,
9D002BF0  8F828014   LW V0, -32748(GP)
9D002BF4  24430004   ADDIU V1, V0, 4
9D002BF8  AF838014   SW V1, -32748(GP)
9D002BFC  2403000C   ADDIU V1, ZERO, 12
9D002C00  70832002   MUL A0, A0, V1
9D002C04  24840008   ADDIU A0, A0, 8
9D002C08  3C039D00   LUI V1, -25344
9D002C0C  24637008   ADDIU V1, V1, 28680
9D002C10  00641821   ADDU V1, V1, A0
9D002C14  0F4007C2   JAL comma
9D002C18  AC430004   SW V1, 4(V0)
117:                 }
9D002C1C  8FBF0014   LW RA, 20(SP)
9D002C20  03E00008   JR RA
9D002C24  27BD0018   ADDIU SP, SP, 24
118:                 
119:                 
120:                 void CompileCpfa(WORD i)  // compile pfa primitive for C
121:                 {
9D0032C4  27BDFFE8   ADDIU SP, SP, -24
9D0032C8  AFBF0014   SW RA, 20(SP)
9D0032CC  3084FFFF   ANDI A0, A0, -1
122:                 	PUSH((ucell)primwords[i].wcall); comma();  // PFA ,
9D0032D0  8F828014   LW V0, -32748(GP)
9D0032D4  24430004   ADDIU V1, V0, 4
9D0032D8  AF838014   SW V1, -32748(GP)
9D0032DC  3C039D00   LUI V1, -25344
9D0032E0  24657008   ADDIU A1, V1, 28680
9D0032E4  2403000C   ADDIU V1, ZERO, 12
9D0032E8  70833002   MUL A2, A0, V1
9D0032EC  00C51821   ADDU V1, A2, A1
9D0032F0  8C630008   LW V1, 8(V1)
9D0032F4  0F4007C2   JAL comma
9D0032F8  AC430004   SW V1, 4(V0)
123:                 }
9D0032FC  8FBF0014   LW RA, 20(SP)
9D003300  03E00008   JR RA
9D003304  27BD0018   ADDIU SP, SP, 24
124:                 
125:                 
126:                 void CompileCcon(void *i)  // compile const for C
127:                 {
9D0034D8  27BDFFE8   ADDIU SP, SP, -24
9D0034DC  AFBF0014   SW RA, 20(SP)
128:                 	PUSH((ucell)i); comma(); // x ,
9D0034E0  8F828014   LW V0, -32748(GP)
9D0034E4  24430004   ADDIU V1, V0, 4
9D0034E8  AF838014   SW V1, -32748(GP)
9D0034EC  0F4007C2   JAL comma
9D0034F0  AC440004   SW A0, 4(V0)
129:                 }
9D0034F4  8FBF0014   LW RA, 20(SP)
9D0034F8  03E00008   JR RA
9D0034FC  27BD0018   ADDIU SP, SP, 24
130:                 
131:                 
132:                 // ********** STACK **********
133:                 
134:                 // drop ( x --  )
135:                 void drop(void) {pDS--;}
9D000020  8F828014   LW V0, -32748(GP)
9D000024  2442FFFC   ADDIU V0, V0, -4
9D000028  03E00008   JR RA
9D00002C  AF828014   SW V0, -32748(GP)
136:                 
137:                 
138:                 // 2drop ( x1 x2 --  )
139:                 void twodrop(void) {pDS-=2;}
9D000030  8F828014   LW V0, -32748(GP)
9D000034  2442FFF8   ADDIU V0, V0, -8
9D000038  03E00008   JR RA
9D00003C  AF828014   SW V0, -32748(GP)
140:                 
141:                 
142:                 // dup (x1 -- x1 x1 )
143:                 void dup(void) {cell tmp=TOS; PUSH(tmp);}
9D000040  8F828014   LW V0, -32748(GP)
9D000044  8C430000   LW V1, 0(V0)
9D000048  24440004   ADDIU A0, V0, 4
9D00004C  AF848014   SW A0, -32748(GP)
9D000050  03E00008   JR RA
9D000054  AC430004   SW V1, 4(V0)
144:                 
145:                 
146:                 // 2dup ( x1 x2 -- x1 x2 x1 x2 )
147:                 void twodup(void) {cell tmp=TOSi(1); PUSH(tmp); tmp=TOSi(1); PUSH(tmp);}
9D000058  8F828014   LW V0, -32748(GP)
9D00005C  8C43FFFC   LW V1, -4(V0)
9D000060  24440004   ADDIU A0, V0, 4
9D000064  AF848014   SW A0, -32748(GP)
9D000068  AC430004   SW V1, 4(V0)
9D00006C  8F828014   LW V0, -32748(GP)
9D000070  8C43FFFC   LW V1, -4(V0)
9D000074  24440004   ADDIU A0, V0, 4
9D000078  AF848014   SW A0, -32748(GP)
9D00007C  03E00008   JR RA
9D000080  AC430004   SW V1, 4(V0)
148:                 
149:                 
150:                 // ?dup ( x -- 0 | x x )
151:                 void isdup(void) {cell tmp=TOS;	if (tmp) {PUSH(tmp);}}
9D000084  8F828014   LW V0, -32748(GP)
9D000088  8C430000   LW V1, 0(V0)
9D00008C  10600003   BEQ V1, ZERO, 0x9D00009C
9D000090  24440004   ADDIU A0, V0, 4
9D000094  AF848014   SW A0, -32748(GP)
9D000098  AC430004   SW V1, 4(V0)
9D00009C  03E00008   JR RA
9D0000A0  00000000   NOP
152:                 
153:                 
154:                 // nip ( x1 x2 -- x2 )
155:                 void nip(void) {TOSi(1)=TOS; pDS--;}
9D0000A4  8F828014   LW V0, -32748(GP)
9D0000A8  8C430000   LW V1, 0(V0)
9D0000AC  AC43FFFC   SW V1, -4(V0)
9D0000B0  8F828014   LW V0, -32748(GP)
9D0000B4  2442FFFC   ADDIU V0, V0, -4
9D0000B8  03E00008   JR RA
9D0000BC  AF828014   SW V0, -32748(GP)
156:                 
157:                 
158:                 // over ( x y -- x y x )
159:                 void over(void) {cell tmp=TOSi(1); PUSH(tmp);}
9D0000C0  8F828014   LW V0, -32748(GP)
9D0000C4  8C43FFFC   LW V1, -4(V0)
9D0000C8  24440004   ADDIU A0, V0, 4
9D0000CC  AF848014   SW A0, -32748(GP)
9D0000D0  03E00008   JR RA
9D0000D4  AC430004   SW V1, 4(V0)
160:                 
161:                 
162:                 // 2over ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
163:                 void twoover(void) {cell tmp=TOSi(3); PUSH(tmp); tmp=TOSi(3); PUSH(tmp);}
9D0000D8  8F828014   LW V0, -32748(GP)
9D0000DC  8C43FFF4   LW V1, -12(V0)
9D0000E0  24440004   ADDIU A0, V0, 4
9D0000E4  AF848014   SW A0, -32748(GP)
9D0000E8  AC430004   SW V1, 4(V0)
9D0000EC  8F828014   LW V0, -32748(GP)
9D0000F0  8C43FFF4   LW V1, -12(V0)
9D0000F4  24440004   ADDIU A0, V0, 4
9D0000F8  AF848014   SW A0, -32748(GP)
9D0000FC  03E00008   JR RA
9D000100  AC430004   SW V1, 4(V0)
164:                 
165:                 
166:                 // pick ( xu ... x1 x0 u -- xu ... x1 x0 xu )  copy xu
167:                 void pick(void) {ucell u=TOS; if (DScnt>u+1) {TOS=TOSi(u+1);} else {vErrors|=4; abortf();}}
9D00134C  27BDFFE8   ADDIU SP, SP, -24
9D001350  AFBF0014   SW RA, 20(SP)
9D001354  8F828014   LW V0, -32748(GP)
9D001358  8C430000   LW V1, 0(V0)
9D00135C  8F848010   LW A0, -32752(GP)
9D001360  00442023   SUBU A0, V0, A0
9D001364  00042083   SRA A0, A0, 2
9D001368  24650001   ADDIU A1, V1, 1
9D00136C  00A4202B   SLTU A0, A1, A0
9D001370  10800006   BEQ A0, ZERO, 0x9D00138C
9D001374  00031827   NOR V1, ZERO, V1
9D001378  00031880   SLL V1, V1, 2
9D00137C  00431821   ADDU V1, V0, V1
9D001380  8C630000   LW V1, 0(V1)
9D001384  0B4004E7   J 0x9D00139C
9D001388  AC430000   SW V1, 0(V0)
9D00138C  9382808F   LBU V0, -32625(GP)
9D001390  34420004   ORI V0, V0, 4
9D001394  0F400360   JAL abortf
9D001398  A382808F   SB V0, -32625(GP)
9D00139C  8FBF0014   LW RA, 20(SP)
9D0013A0  03E00008   JR RA
9D0013A4  27BD0018   ADDIU SP, SP, 24
168:                 
169:                 
170:                 // stick ( xu ... x1 x0 xunew u -- xunew ... x1 x0 )  overwrite xu
171:                 void stick(void) {cell u=POP, new=POP; if (DScnt>u) {TOSi(u)=new;} else {vErrors|=4; abortf();}}
9D0012E8  27BDFFE8   ADDIU SP, SP, -24
9D0012EC  AFBF0014   SW RA, 20(SP)
9D0012F0  8F828014   LW V0, -32748(GP)
9D0012F4  8C430000   LW V1, 0(V0)
9D0012F8  2444FFFC   ADDIU A0, V0, -4
9D0012FC  AF848014   SW A0, -32748(GP)
9D001300  8C45FFFC   LW A1, -4(V0)
9D001304  2442FFF8   ADDIU V0, V0, -8
9D001308  AF828014   SW V0, -32748(GP)
9D00130C  8F848010   LW A0, -32752(GP)
9D001310  00442023   SUBU A0, V0, A0
9D001314  00042083   SRA A0, A0, 2
9D001318  0064202A   SLT A0, V1, A0
9D00131C  10800004   BEQ A0, ZERO, 0x9D001330
9D001320  00031880   SLL V1, V1, 2
9D001324  00431023   SUBU V0, V0, V1
9D001328  0B4004D0   J 0x9D001340
9D00132C  AC450000   SW A1, 0(V0)
9D001330  9382808F   LBU V0, -32625(GP)
9D001334  34420004   ORI V0, V0, 4
9D001338  0F400360   JAL abortf
9D00133C  A382808F   SB V0, -32625(GP)
9D001340  8FBF0014   LW RA, 20(SP)
9D001344  03E00008   JR RA
9D001348  27BD0018   ADDIU SP, SP, 24
172:                 
173:                 
174:                 // roll ( xu ... x1 x0 u -- xu-1... x1 x0 xu )  move xu to TOS
175:                 void roll(void)
176:                 {
9D001250  27BDFFE8   ADDIU SP, SP, -24
9D001254  AFBF0014   SW RA, 20(SP)
177:                 	ucell u=POP, *p=(ucell *)pDSzero;
9D001258  8F838014   LW V1, -32748(GP)
9D00125C  8C620000   LW V0, 0(V1)
9D001260  2463FFFC   ADDIU V1, V1, -4
9D001264  AF838014   SW V1, -32748(GP)
178:                 	cell cnt=DScnt;
9D001268  8F868010   LW A2, -32752(GP)
9D00126C  00663023   SUBU A2, V1, A2
9D001270  00063083   SRA A2, A2, 2
179:                 
180:                 	if (!cnt) {return;}
9D001274  10C00019   BEQ A2, ZERO, 0x9D0012DC
9D001278  0046202B   SLTU A0, V0, A2
181:                 	if (cnt>u)
9D00127C  10800013   BEQ A0, ZERO, 0x9D0012CC
9D001280  00022080   SLL A0, V0, 2
182:                 	{
183:                 		int i;
184:                 		cell xu=TOSi(u);
9D001284  00641823   SUBU V1, V1, A0
9D001288  8C670000   LW A3, 0(V1)
185:                 		for (i=cnt-u; i<cnt; i++) {*(pDSzero+i)=*(pDSzero+i+1);}
9D00128C  00C21023   SUBU V0, A2, V0
9D001290  0046202A   SLT A0, V0, A2
9D001294  1080000A   BEQ A0, ZERO, 0x9D0012C0
9D001298  00401821   ADDU V1, V0, ZERO
9D00129C  00021080   SLL V0, V0, 2
9D0012A0  8F848010   LW A0, -32752(GP)
9D0012A4  00822821   ADDU A1, A0, V0
9D0012A8  24420004   ADDIU V0, V0, 4
9D0012AC  00822021   ADDU A0, A0, V0
9D0012B0  8C840000   LW A0, 0(A0)
9D0012B4  24630001   ADDIU V1, V1, 1
9D0012B8  1466FFF9   BNE V1, A2, 0x9D0012A0
9D0012BC  ACA40000   SW A0, 0(A1)
186:                 		TOS=xu;
9D0012C0  8F828014   LW V0, -32748(GP)
9D0012C4  0B4004B7   J 0x9D0012DC
9D0012C8  AC470000   SW A3, 0(V0)
187:                 	} else {vErrors|=4; abortf();}
9D0012CC  9382808F   LBU V0, -32625(GP)
9D0012D0  34420004   ORI V0, V0, 4
9D0012D4  0F400360   JAL abortf
9D0012D8  A382808F   SB V0, -32625(GP)
188:                 }
9D0012DC  8FBF0014   LW RA, 20(SP)
9D0012E0  03E00008   JR RA
9D0012E4  27BD0018   ADDIU SP, SP, 24
189:                 
190:                 
191:                 // -roll ( xu ... x1 x0 u -- x0 xu... x1 )  insert TOS to xu
192:                 void minusroll(void)
193:                 {
9D0011A8  27BDFFE8   ADDIU SP, SP, -24
9D0011AC  AFBF0014   SW RA, 20(SP)
194:                 	ucell u=POP;
9D0011B0  8F848014   LW A0, -32748(GP)
9D0011B4  8C870000   LW A3, 0(A0)
9D0011B8  2482FFFC   ADDIU V0, A0, -4
9D0011BC  AF828014   SW V0, -32748(GP)
195:                 	cell cnt=DScnt;
9D0011C0  8F838010   LW V1, -32752(GP)
9D0011C4  00431023   SUBU V0, V0, V1
9D0011C8  00021083   SRA V0, V0, 2
196:                 
197:                 	if (!cnt) {return;}
9D0011CC  1040001D   BEQ V0, ZERO, 0x9D001244
9D0011D0  00E2282B   SLTU A1, A3, V0
198:                 	if (cnt>u)
9D0011D4  10A00017   BEQ A1, ZERO, 0x9D001234
9D0011D8  00401821   ADDU V1, V0, ZERO
199:                 	{
200:                 		int i;
201:                 		cell x0=TOS;
9D0011DC  8C88FFFC   LW T0, -4(A0)
202:                 		for (i=cnt; i>cnt-u; i--) {*(pDSzero+i)=*(pDSzero+i-1);}
9D0011E0  00473023   SUBU A2, V0, A3
9D0011E4  00C2202B   SLTU A0, A2, V0
9D0011E8  5080000E   BEQL A0, ZERO, 0x9D001224
9D0011EC  00073880   SLL A3, A3, 2
9D0011F0  8F848010   LW A0, -32752(GP)
9D0011F4  00032880   SLL A1, V1, 2
9D0011F8  00852821   ADDU A1, A0, A1
9D0011FC  2463FFFF   ADDIU V1, V1, -1
9D001200  00031880   SLL V1, V1, 2
9D001204  00832021   ADDU A0, A0, V1
9D001208  8C830000   LW V1, 0(A0)
9D00120C  ACA30000   SW V1, 0(A1)
9D001210  2442FFFF   ADDIU V0, V0, -1
9D001214  00C2202B   SLTU A0, A2, V0
9D001218  1480FFF5   BNE A0, ZERO, 0x9D0011F0
9D00121C  00401821   ADDU V1, V0, ZERO
203:                 		TOSi(u)=x0;
9D001220  00073880   SLL A3, A3, 2
9D001224  8F828014   LW V0, -32748(GP)
9D001228  00473823   SUBU A3, V0, A3
9D00122C  0B400491   J 0x9D001244
9D001230  ACE80000   SW T0, 0(A3)
204:                 	} else {vErrors|=4; abortf();}
9D001234  9382808F   LBU V0, -32625(GP)
9D001238  34420004   ORI V0, V0, 4
9D00123C  0F400360   JAL abortf
9D001240  A382808F   SB V0, -32625(GP)
205:                 }
9D001244  8FBF0014   LW RA, 20(SP)
9D001248  03E00008   JR RA
9D00124C  27BD0018   ADDIU SP, SP, 24
206:                 
207:                 
208:                 // rot ( x1 x2 x3 -- x2 x3 x1 )
209:                 void rot(void) {cell tmp=TOS; TOS=TOSi(2); TOSi(2)=TOSi(1); TOSi(1)=tmp;}
9D000104  8F828014   LW V0, -32748(GP)
9D000108  8C430000   LW V1, 0(V0)
9D00010C  8C44FFF8   LW A0, -8(V0)
9D000110  AC440000   SW A0, 0(V0)
9D000114  8F828014   LW V0, -32748(GP)
9D000118  8C44FFFC   LW A0, -4(V0)
9D00011C  AC44FFF8   SW A0, -8(V0)
9D000120  8F828014   LW V0, -32748(GP)
9D000124  03E00008   JR RA
9D000128  AC43FFFC   SW V1, -4(V0)
210:                 
211:                 
212:                 // -rot ( x1 x2 x3 -- x3 x1 x2 )
213:                 void minusrot(void) {cell tmp=TOS; TOS=TOSi(1); TOSi(1)=TOSi(2); TOSi(2)=tmp;}
9D00012C  8F828014   LW V0, -32748(GP)
9D000130  8C430000   LW V1, 0(V0)
9D000134  8C44FFFC   LW A0, -4(V0)
9D000138  AC440000   SW A0, 0(V0)
9D00013C  8F828014   LW V0, -32748(GP)
9D000140  8C44FFF8   LW A0, -8(V0)
9D000144  AC44FFFC   SW A0, -4(V0)
9D000148  8F828014   LW V0, -32748(GP)
9D00014C  03E00008   JR RA
9D000150  AC43FFF8   SW V1, -8(V0)
214:                 
215:                 
216:                 // swap ( x1 x2 -- x2 x1 )
217:                 void swap(void) {cell tmp=TOS; TOS=TOSi(1); TOSi(1)=tmp;}
9D000154  8F828014   LW V0, -32748(GP)
9D000158  8C430000   LW V1, 0(V0)
9D00015C  8C44FFFC   LW A0, -4(V0)
9D000160  AC440000   SW A0, 0(V0)
9D000164  8F828014   LW V0, -32748(GP)
9D000168  03E00008   JR RA
9D00016C  AC43FFFC   SW V1, -4(V0)
218:                 
219:                 
220:                 // 2swap ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
221:                 void twoswap(void)
222:                 {
223:                 	cell tmp=TOS, tmp2=TOSi(1);
9D000170  8F828014   LW V0, -32748(GP)
9D000174  8C440000   LW A0, 0(V0)
9D000178  8C43FFFC   LW V1, -4(V0)
224:                 	TOS=TOSi(2); TOSi(1)=TOSi(3);
9D00017C  8C45FFF8   LW A1, -8(V0)
9D000180  AC450000   SW A1, 0(V0)
9D000184  8F828014   LW V0, -32748(GP)
9D000188  8C45FFF4   LW A1, -12(V0)
9D00018C  AC45FFFC   SW A1, -4(V0)
225:                 	TOSi(2)=tmp; TOSi(3)=tmp2;
9D000190  8F828014   LW V0, -32748(GP)
9D000194  AC44FFF8   SW A0, -8(V0)
9D000198  8F828014   LW V0, -32748(GP)
226:                 }
9D00019C  03E00008   JR RA
9D0001A0  AC43FFF4   SW V1, -12(V0)
227:                 
228:                 
229:                 // >r ( x -- ) (R: -- x ) 
230:                 void tor(void) {PUSHR(POP);}
9D0001A4  8F83801C   LW V1, -32740(GP)
9D0001A8  24620004   ADDIU V0, V1, 4
9D0001AC  AF82801C   SW V0, -32740(GP)
9D0001B0  8F828014   LW V0, -32748(GP)
9D0001B4  8C440000   LW A0, 0(V0)
9D0001B8  AC640004   SW A0, 4(V1)
9D0001BC  2442FFFC   ADDIU V0, V0, -4
9D0001C0  03E00008   JR RA
9D0001C4  AF828014   SW V0, -32748(GP)
231:                 
232:                 
233:                 // r> ( -- x ) (R: x -- )
234:                 void rfrom(void) {PUSH(POPR);}
9D0001C8  8F838014   LW V1, -32748(GP)
9D0001CC  24620004   ADDIU V0, V1, 4
9D0001D0  AF828014   SW V0, -32748(GP)
9D0001D4  8F82801C   LW V0, -32740(GP)
9D0001D8  8C440000   LW A0, 0(V0)
9D0001DC  AC640004   SW A0, 4(V1)
9D0001E0  2442FFFC   ADDIU V0, V0, -4
9D0001E4  03E00008   JR RA
9D0001E8  AF82801C   SW V0, -32740(GP)
235:                 
236:                 
237:                 // r@ ( -- x ) (R: x -- x )
238:                 void rfetch(void) {PUSH(TOSR);}
9D0001EC  8F828014   LW V0, -32748(GP)
9D0001F0  24430004   ADDIU V1, V0, 4
9D0001F4  AF838014   SW V1, -32748(GP)
9D0001F8  8F83801C   LW V1, -32740(GP)
9D0001FC  8C630000   LW V1, 0(V1)
9D000200  03E00008   JR RA
9D000204  AC430004   SW V1, 4(V0)
239:                 
240:                 
241:                 // depth (  -- x )
242:                 void depth(void) {cell tmp=DScnt; PUSH(tmp);}
9D000208  8F828014   LW V0, -32748(GP)
9D00020C  8F838010   LW V1, -32752(GP)
9D000210  00431823   SUBU V1, V0, V1
9D000214  00031883   SRA V1, V1, 2
9D000218  24440004   ADDIU A0, V0, 4
9D00021C  AF848014   SW A0, -32748(GP)
9D000220  03E00008   JR RA
9D000224  AC430004   SW V1, 4(V0)
243:                 
244:                 
245:                 // depth! ( ... u --  x1 x2 .. xu )
246:                 void depthwrite(void) {ucell tmp=POP; pDS=pDSzero+tmp;}
9D000228  8F828014   LW V0, -32748(GP)
9D00022C  8C420000   LW V0, 0(V0)
9D000230  00021080   SLL V0, V0, 2
9D000234  8F838010   LW V1, -32752(GP)
9D000238  00621021   ADDU V0, V1, V0
9D00023C  03E00008   JR RA
9D000240  AF828014   SW V0, -32748(GP)
247:                 
248:                 
249:                 // rdepth (  -- u )
250:                 void rdepth(void) {cell tmp=RScnt; PUSH(tmp);}
9D000244  8F828018   LW V0, -32744(GP)
9D000248  8F83801C   LW V1, -32740(GP)
9D00024C  00621823   SUBU V1, V1, V0
9D000250  00031883   SRA V1, V1, 2
9D000254  8F828014   LW V0, -32748(GP)
9D000258  24440004   ADDIU A0, V0, 4
9D00025C  AF848014   SW A0, -32748(GP)
9D000260  03E00008   JR RA
9D000264  AC430004   SW V1, 4(V0)
251:                 
252:                 
253:                 // rdepth! ( u --  ) ( R: ... -- x1 x2 .. xu )
254:                 void rdepthwrite(void) {ucell tmp=POP; pRS=pRSzero+tmp;}
9D000268  8F828014   LW V0, -32748(GP)
9D00026C  8C430000   LW V1, 0(V0)
9D000270  2442FFFC   ADDIU V0, V0, -4
9D000274  AF828014   SW V0, -32748(GP)
9D000278  00031080   SLL V0, V1, 2
9D00027C  8F838018   LW V1, -32744(GP)
9D000280  00621021   ADDU V0, V1, V0
9D000284  03E00008   JR RA
9D000288  AF82801C   SW V0, -32740(GP)
255:                 
256:                 
257:                 // sp@ (  -- addr )
258:                 void spfetch(void) {ucell tmp=(ucell)&TOS; PUSH(tmp);}
9D00028C  8F828014   LW V0, -32748(GP)
9D000290  24430004   ADDIU V1, V0, 4
9D000294  AF838014   SW V1, -32748(GP)
9D000298  03E00008   JR RA
9D00029C  AC420004   SW V0, 4(V0)
259:                 
260:                 
261:                 // rp@ (  -- u )
262:                 void rpfetch(void) {ucell tmp=(ucell)&TOSR; PUSH(tmp);}
9D0002A0  8F828014   LW V0, -32748(GP)
9D0002A4  24430004   ADDIU V1, V0, 4
9D0002A8  AF838014   SW V1, -32748(GP)
9D0002AC  8F83801C   LW V1, -32740(GP)
9D0002B0  03E00008   JR RA
9D0002B4  AC430004   SW V1, 4(V0)
263:                 
264:                 
265:                 // ********** OTHER **********
266:                 
267:                 
268:                 // nop ( -- )
269:                 void nop(void) { }
9D0002B8  03E00008   JR RA
9D0002BC  00000000   NOP
270:                 
271:                 
272:                 // emit ( char --  )
273:                 void emit(void)
274:                 {
9D0022CC  27BDFFE8   ADDIU SP, SP, -24
9D0022D0  AFBF0014   SW RA, 20(SP)
275:                 	// while (!isUARTwrite(UARTcon));
276:                 #ifdef VPC_32
277:                     put_char(comm_channel,POP);
9D0022D4  83848064   LB A0, -32668(GP)
9D0022D8  8F828014   LW V0, -32748(GP)
9D0022DC  80450000   LB A1, 0(V0)
9D0022E0  2442FFFC   ADDIU V0, V0, -4
9D0022E4  0F402586   JAL put_char
9D0022E8  AF828014   SW V0, -32748(GP)
278:                 #else
279:                         if (!isUARTwrite(UARTcon)) {delay_us(20000000/UART[UARTcon].Speed);}
280:                 	UARTwrite(UARTcon,POP);
281:                 #endif
282:                 }
9D0022EC  8FBF0014   LW RA, 20(SP)
9D0022F0  03E00008   JR RA
9D0022F4  27BD0018   ADDIU SP, SP, 24
283:                 
284:                 #ifndef VPC_32
285:                 // ?emit ( char --  )
286:                 void isemit(void) {   
287:                     PUSH((cell) isUARTwrite(UARTcon));
288:                 }
289:                 #endif
290:                 
291:                 
292:                 // key (  -- char )
293:                 void key(void)
294:                 {
9D002298  27BDFFE8   ADDIU SP, SP, -24
9D00229C  AFBF0014   SW RA, 20(SP)
9D0022A0  AFB00010   SW S0, 16(SP)
295:                 #ifdef VPC_32
296:                     PUSH (wait_key(comm_channel));
9D0022A4  8F908014   LW S0, -32748(GP)
9D0022A8  26020004   ADDIU V0, S0, 4
9D0022AC  AF828014   SW V0, -32748(GP)
9D0022B0  0F402722   JAL wait_key
9D0022B4  83848064   LB A0, -32668(GP)
9D0022B8  AE020004   SW V0, 4(S0)
297:                 #else
298:                 	while (!isUARTread(UARTcon));
299:                 	PUSH(UARTread(UARTcon));
300:                 #endif
301:                 } 
9D0022BC  8FBF0014   LW RA, 20(SP)
9D0022C0  8FB00010   LW S0, 16(SP)
9D0022C4  03E00008   JR RA
9D0022C8  27BD0018   ADDIU SP, SP, 24
302:                 
303:                 
304:                 // ?key (  -- pressed? )
305:                 void iskey(void) {
9D002264  27BDFFE8   ADDIU SP, SP, -24
9D002268  AFBF0014   SW RA, 20(SP)
9D00226C  AFB00010   SW S0, 16(SP)
306:                 #ifdef VPC_32
307:                     PUSH((cell) get_key(comm_channel));
9D002270  8F908014   LW S0, -32748(GP)
9D002274  26020004   ADDIU V0, S0, 4
9D002278  AF828014   SW V0, -32748(GP)
9D00227C  0F40270D   JAL get_key
9D002280  83848064   LB A0, -32668(GP)
9D002284  AE020004   SW V0, 4(S0)
308:                 #else
309:                     PUSH((cell) isUARTread(UARTcon));
310:                 #endif
311:                 }
9D002288  8FBF0014   LW RA, 20(SP)
9D00228C  8FB00010   LW S0, 16(SP)
9D002290  03E00008   JR RA
9D002294  27BD0018   ADDIU SP, SP, 24
312:                 
313:                 
314:                 // i ( -- i )
315:                 void loop_i(void) {PUSH(TOSR);}
9D0002C0  8F828014   LW V0, -32748(GP)
9D0002C4  24430004   ADDIU V1, V0, 4
9D0002C8  AF838014   SW V1, -32748(GP)
9D0002CC  8F83801C   LW V1, -32740(GP)
9D0002D0  8C630000   LW V1, 0(V1)
9D0002D4  03E00008   JR RA
9D0002D8  AC430004   SW V1, 4(V0)
316:                 
317:                 
318:                 // j ( -- j )
319:                 void loop_j(void) {PUSH(TOSRi(3));}
9D0002DC  8F828014   LW V0, -32748(GP)
9D0002E0  24430004   ADDIU V1, V0, 4
9D0002E4  AF838014   SW V1, -32748(GP)
9D0002E8  8F83801C   LW V1, -32740(GP)
9D0002EC  8C63FFF4   LW V1, -12(V1)
9D0002F0  03E00008   JR RA
9D0002F4  AC430004   SW V1, 4(V0)
320:                 
321:                 
322:                 // k ( -- k )
323:                 void loop_k(void) {PUSH(TOSRi(6));}
9D0002F8  8F828014   LW V0, -32748(GP)
9D0002FC  24430004   ADDIU V1, V0, 4
9D000300  AF838014   SW V1, -32748(GP)
9D000304  8F83801C   LW V1, -32740(GP)
9D000308  8C63FFE8   LW V1, -24(V1)
9D00030C  03E00008   JR RA
9D000310  AC430004   SW V1, 4(V0)
324:                 
325:                 
326:                 // ********** MEMORY **********
327:                 
328:                 
329:                 // @ ( addr -- x )
330:                 void fetch(void) {TOS=pDATA TOS;}
9D000314  8F828014   LW V0, -32748(GP)
9D000318  8C430000   LW V1, 0(V0)
9D00031C  8C630000   LW V1, 0(V1)
9D000320  03E00008   JR RA
9D000324  AC430000   SW V1, 0(V0)
331:                 
332:                 
333:                 // c@ ( addr -- byte )
334:                 void cfetch(void) {TOS=*(BYTE *)TOS;}
9D000328  8F828014   LW V0, -32748(GP)
9D00032C  8C430000   LW V1, 0(V0)
9D000330  90630000   LBU V1, 0(V1)
9D000334  03E00008   JR RA
9D000338  AC430000   SW V1, 0(V0)
335:                 
336:                 
337:                 // w@ ( addr -- w )
338:                 void wfetch(void) {TOS=*(WORD *)TOS;}
9D00033C  8F828014   LW V0, -32748(GP)
9D000340  8C430000   LW V1, 0(V0)
9D000344  94630000   LHU V1, 0(V1)
9D000348  03E00008   JR RA
9D00034C  AC430000   SW V1, 0(V0)
339:                 
340:                 
341:                 // ! ( x addr -- )
342:                 void store(void) {ucell addr=POP; pDATA addr=POP;}
9D000350  8F828014   LW V0, -32748(GP)
9D000354  8C430000   LW V1, 0(V0)
9D000358  2444FFFC   ADDIU A0, V0, -4
9D00035C  AF848014   SW A0, -32748(GP)
9D000360  8C44FFFC   LW A0, -4(V0)
9D000364  AC640000   SW A0, 0(V1)
9D000368  2442FFF8   ADDIU V0, V0, -8
9D00036C  03E00008   JR RA
9D000370  AF828014   SW V0, -32748(GP)
343:                 
344:                 
345:                 // c! ( byte addr -- )
346:                 void cstore(void) {ucell addr=POP; *(BYTE *) addr=POP;}
9D000374  8F828014   LW V0, -32748(GP)
9D000378  8C430000   LW V1, 0(V0)
9D00037C  2444FFFC   ADDIU A0, V0, -4
9D000380  AF848014   SW A0, -32748(GP)
9D000384  8C44FFFC   LW A0, -4(V0)
9D000388  A0640000   SB A0, 0(V1)
9D00038C  2442FFF8   ADDIU V0, V0, -8
9D000390  03E00008   JR RA
9D000394  AF828014   SW V0, -32748(GP)
347:                 
348:                 
349:                 // w! ( w addr -- )
350:                 void wstore(void) {ucell addr=POP; *(WORD *) addr=POP;}
9D000398  8F828014   LW V0, -32748(GP)
9D00039C  8C430000   LW V1, 0(V0)
9D0003A0  2444FFFC   ADDIU A0, V0, -4
9D0003A4  AF848014   SW A0, -32748(GP)
9D0003A8  8C44FFFC   LW A0, -4(V0)
9D0003AC  A4640000   SH A0, 0(V1)
9D0003B0  2442FFF8   ADDIU V0, V0, -8
9D0003B4  03E00008   JR RA
9D0003B8  AF828014   SW V0, -32748(GP)
351:                 
352:                 
353:                 // +! ( n addr -- )
354:                 void plusstore(void) {ucell addr=POP; pDATA addr+=POP;}
9D0003BC  8F828014   LW V0, -32748(GP)
9D0003C0  8C430000   LW V1, 0(V0)
9D0003C4  2444FFFC   ADDIU A0, V0, -4
9D0003C8  AF848014   SW A0, -32748(GP)
9D0003CC  8C650000   LW A1, 0(V1)
9D0003D0  8C44FFFC   LW A0, -4(V0)
9D0003D4  00A42021   ADDU A0, A1, A0
9D0003D8  AC640000   SW A0, 0(V1)
9D0003DC  2442FFF8   ADDIU V0, V0, -8
9D0003E0  03E00008   JR RA
9D0003E4  AF828014   SW V0, -32748(GP)
355:                 
356:                 
357:                 // fill ( addr len c -- )
358:                 void fillf(void)  // fill c
359:                 {
9D002224  27BDFFE8   ADDIU SP, SP, -24
9D002228  AFBF0014   SW RA, 20(SP)
360:                 	ucell value=POP, count=POP, src=POP;
9D00222C  8F828014   LW V0, -32748(GP)
9D002230  8C450000   LW A1, 0(V0)
9D002234  2443FFFC   ADDIU V1, V0, -4
9D002238  AF838014   SW V1, -32748(GP)
9D00223C  8C46FFFC   LW A2, -4(V0)
9D002240  2443FFF8   ADDIU V1, V0, -8
9D002244  AF838014   SW V1, -32748(GP)
9D002248  8C44FFF8   LW A0, -8(V0)
9D00224C  2442FFF4   ADDIU V0, V0, -12
361:                 	memset((char *)src, value, count);
9D002250  0F403D34   JAL 0x9D00F4D0
9D002254  AF828014   SW V0, -32748(GP)
362:                 }
9D002258  8FBF0014   LW RA, 20(SP)
9D00225C  03E00008   JR RA
9D002260  27BD0018   ADDIU SP, SP, 24
363:                 
364:                 
365:                 // move ( src-addr dest-addr len -- )
366:                 void movef(void)  // move c
367:                 {
9D0021E4  27BDFFE8   ADDIU SP, SP, -24
9D0021E8  AFBF0014   SW RA, 20(SP)
368:                 	ucell count=POP, dest=POP, src=POP;
9D0021EC  8F828014   LW V0, -32748(GP)
9D0021F0  8C460000   LW A2, 0(V0)
9D0021F4  2443FFFC   ADDIU V1, V0, -4
9D0021F8  AF838014   SW V1, -32748(GP)
9D0021FC  8C44FFFC   LW A0, -4(V0)
9D002200  2443FFF8   ADDIU V1, V0, -8
9D002204  AF838014   SW V1, -32748(GP)
9D002208  8C45FFF8   LW A1, -8(V0)
9D00220C  2442FFF4   ADDIU V0, V0, -12
369:                 	memmove((char *)dest, (char *)src, count);
9D002210  0F403DA4   JAL memmove
9D002214  AF828014   SW V0, -32748(GP)
370:                 }
9D002218  8FBF0014   LW RA, 20(SP)
9D00221C  03E00008   JR RA
9D002220  27BD0018   ADDIU SP, SP, 24
371:                 
372:                 
373:                 // here ( -- u )
374:                 void here(void) {PUSH((ucell)vHere);}
9D0003E8  8F828014   LW V0, -32748(GP)
9D0003EC  24430004   ADDIU V1, V0, 4
9D0003F0  AF838014   SW V1, -32748(GP)
9D0003F4  8F8380FC   LW V1, -32516(GP)
9D0003F8  03E00008   JR RA
9D0003FC  AC430004   SW V1, 4(V0)
375:                 
376:                 
377:                 // here! ( u -- )
378:                 void herewrite(void) {vHere=(char *)POP;}  // set vHere
9D000400  8F828014   LW V0, -32748(GP)
9D000404  8C430000   LW V1, 0(V0)
9D000408  AF8380FC   SW V1, -32516(GP)
9D00040C  2442FFFC   ADDIU V0, V0, -4
9D000410  03E00008   JR RA
9D000414  AF828014   SW V0, -32748(GP)
379:                 
380:                 
381:                 // head (  -- u )
382:                 void head(void) {PUSH((ucell)vHead);}
9D000418  8F828014   LW V0, -32748(GP)
9D00041C  24430004   ADDIU V1, V0, 4
9D000420  AF838014   SW V1, -32748(GP)
9D000424  8F838104   LW V1, -32508(GP)
9D000428  03E00008   JR RA
9D00042C  AC430004   SW V1, 4(V0)
383:                 
384:                 
385:                 // head! ( u -- )
386:                 void headwrite(void) {vHead=(char *)POP;}
9D000430  8F828014   LW V0, -32748(GP)
9D000434  8C430000   LW V1, 0(V0)
9D000438  AF838104   SW V1, -32508(GP)
9D00043C  2442FFFC   ADDIU V0, V0, -4
9D000440  03E00008   JR RA
9D000444  AF828014   SW V0, -32748(GP)
387:                 
388:                 
389:                 // heap (  -- u )
390:                 void heap(void) {PUSH((ucell)vHeap);}
9D000448  8F828014   LW V0, -32748(GP)
9D00044C  24430004   ADDIU V1, V0, 4
9D000450  AF838014   SW V1, -32748(GP)
9D000454  8F83810C   LW V1, -32500(GP)
9D000458  03E00008   JR RA
9D00045C  AC430004   SW V1, 4(V0)
391:                 
392:                 
393:                 // heap! ( u -- )
394:                 void heapwrite(void) {vHeap=(char *)POP;}
9D000460  8F828014   LW V0, -32748(GP)
9D000464  8C430000   LW V1, 0(V0)
9D000468  AF83810C   SW V1, -32500(GP)
9D00046C  2442FFFC   ADDIU V0, V0, -4
9D000470  03E00008   JR RA
9D000474  AF828014   SW V0, -32748(GP)
395:                 
396:                 
397:                 // ********** ARITHMETIC **********
398:                 
399:                 
400:                 // + ( n1 n2 -- n )
401:                 void plus(void) {cell n2=POP; TOS=TOS+n2;}
9D000478  8F828014   LW V0, -32748(GP)
9D00047C  8C430000   LW V1, 0(V0)
9D000480  2444FFFC   ADDIU A0, V0, -4
9D000484  AF848014   SW A0, -32748(GP)
9D000488  8C44FFFC   LW A0, -4(V0)
9D00048C  00831821   ADDU V1, A0, V1
9D000490  03E00008   JR RA
9D000494  AC43FFFC   SW V1, -4(V0)
402:                 
403:                 
404:                 // - ( n1 n2 -- n )
405:                 void minus(void) {cell n2=POP; TOS=TOS-n2;}
9D000498  8F828014   LW V0, -32748(GP)
9D00049C  8C430000   LW V1, 0(V0)
9D0004A0  2444FFFC   ADDIU A0, V0, -4
9D0004A4  AF848014   SW A0, -32748(GP)
9D0004A8  8C44FFFC   LW A0, -4(V0)
9D0004AC  00831823   SUBU V1, A0, V1
9D0004B0  03E00008   JR RA
9D0004B4  AC43FFFC   SW V1, -4(V0)
406:                 
407:                 
408:                 // d+ ( d1 d2 -- d )
409:                 void dplus(void) 
410:                 {
411:                 	dcell d1, d2;
412:                 	DPOP(d2); DPOP(d1);
9D0004B8  8F828014   LW V0, -32748(GP)
9D0004BC  8C460000   LW A2, 0(V0)
9D0004C0  2443FFFC   ADDIU V1, V0, -4
9D0004C4  AF838014   SW V1, -32748(GP)
9D0004C8  8C44FFFC   LW A0, -4(V0)
9D0004CC  2443FFF8   ADDIU V1, V0, -8
9D0004D0  AF838014   SW V1, -32748(GP)
9D0004D4  8C47FFF8   LW A3, -8(V0)
9D0004D8  2445FFF4   ADDIU A1, V0, -12
9D0004DC  AF858014   SW A1, -32748(GP)
9D0004E0  8C43FFF4   LW V1, -12(V0)
413:                 	DPUSH(d1+d2);
9D0004E4  00642021   ADDU A0, V1, A0
9D0004E8  AC44FFF4   SW A0, -12(V0)
9D0004EC  8F828014   LW V0, -32748(GP)
9D0004F0  24450004   ADDIU A1, V0, 4
9D0004F4  AF858014   SW A1, -32748(GP)
9D0004F8  0083182B   SLTU V1, A0, V1
9D0004FC  00E62821   ADDU A1, A3, A2
9D000500  00651821   ADDU V1, V1, A1
414:                 }
9D000504  03E00008   JR RA
9D000508  AC430004   SW V1, 4(V0)
415:                 
416:                 
417:                 // d- ( d1 d2 -- d )
418:                 void dminus(void)
419:                 {
420:                 	dcell d1, d2;
421:                 	DPOP(d2); DPOP(d1);
9D00050C  8F828014   LW V0, -32748(GP)
9D000510  8C460000   LW A2, 0(V0)
9D000514  2443FFFC   ADDIU V1, V0, -4
9D000518  AF838014   SW V1, -32748(GP)
9D00051C  8C44FFFC   LW A0, -4(V0)
9D000520  2443FFF8   ADDIU V1, V0, -8
9D000524  AF838014   SW V1, -32748(GP)
9D000528  8C47FFF8   LW A3, -8(V0)
9D00052C  2445FFF4   ADDIU A1, V0, -12
9D000530  AF858014   SW A1, -32748(GP)
9D000534  8C43FFF4   LW V1, -12(V0)
422:                 	DPUSH(d1-d2);
9D000538  00642023   SUBU A0, V1, A0
9D00053C  AC44FFF4   SW A0, -12(V0)
9D000540  8F828014   LW V0, -32748(GP)
9D000544  24450004   ADDIU A1, V0, 4
9D000548  AF858014   SW A1, -32748(GP)
9D00054C  0064202B   SLTU A0, V1, A0
9D000550  00E61823   SUBU V1, A3, A2
9D000554  00641823   SUBU V1, V1, A0
423:                 }
9D000558  03E00008   JR RA
9D00055C  AC430004   SW V1, 4(V0)
424:                 
425:                 
426:                 // * ( n1 n2 -- n )
427:                 void mult(void) {cell n2=POP; TOS=TOS*n2;}
9D000560  8F828014   LW V0, -32748(GP)
9D000564  8C430000   LW V1, 0(V0)
9D000568  2444FFFC   ADDIU A0, V0, -4
9D00056C  AF848014   SW A0, -32748(GP)
9D000570  8C44FFFC   LW A0, -4(V0)
9D000574  70831802   MUL V1, A0, V1
9D000578  03E00008   JR RA
9D00057C  AC43FFFC   SW V1, -4(V0)
428:                 
429:                 
430:                 // u* ( u1 u2 -- u ) same as mult
431:                 //void umult(void) {ucell u2=POP; TOS=(ucell)TOS*u2;}
432:                 
433:                 
434:                 // m* ( n1 n2 -- d )
435:                 void mmult(void) {cell n2=POP, n1=POP;	DPUSH((dcell)n1*n2);}
9D000580  8F848014   LW A0, -32748(GP)
9D000584  8C820000   LW V0, 0(A0)
9D000588  2485FFFC   ADDIU A1, A0, -4
9D00058C  AF858014   SW A1, -32748(GP)
9D000590  8C83FFFC   LW V1, -4(A0)
9D000594  70622802   MUL A1, V1, V0
9D000598  AC85FFFC   SW A1, -4(A0)
9D00059C  8F858014   LW A1, -32748(GP)
9D0005A0  24A40004   ADDIU A0, A1, 4
9D0005A4  AF848014   SW A0, -32748(GP)
9D0005A8  000337C3   SRA A2, V1, 31
9D0005AC  000227C3   SRA A0, V0, 31
9D0005B0  00830018   MULT 0, A0, V1
9D0005B4  70C20000   MADD 0, A2, V0
9D0005B8  00002012   MFLO A0, 0
9D0005BC  00620019   MULTU 0, V1, V0
9D0005C0  00001810   MFHI V1, 0
9D0005C4  00832021   ADDU A0, A0, V1
9D0005C8  03E00008   JR RA
9D0005CC  ACA40004   SW A0, 4(A1)
436:                 
437:                 
438:                 // um* ( u1 u2 -- ud )
439:                 void ummult(void) {ucell u2=POP, u1=POP; DPUSH((udcell)u1*u2);}
9D0005D0  8F828014   LW V0, -32748(GP)
9D0005D4  8C430000   LW V1, 0(V0)
9D0005D8  2445FFFC   ADDIU A1, V0, -4
9D0005DC  AF858014   SW A1, -32748(GP)
9D0005E0  8C44FFFC   LW A0, -4(V0)
9D0005E4  70832802   MUL A1, A0, V1
9D0005E8  AC45FFFC   SW A1, -4(V0)
9D0005EC  8F828014   LW V0, -32748(GP)
9D0005F0  24450004   ADDIU A1, V0, 4
9D0005F4  AF858014   SW A1, -32748(GP)
9D0005F8  00830019   MULTU 0, A0, V1
9D0005FC  00002810   MFHI A1, 0
9D000600  03E00008   JR RA
9D000604  AC450004   SW A1, 4(V0)
440:                 
441:                 
442:                 // sqrt ( u1 -- u )
443:                 void sqrtu(void) {ucell u=TOS; TOS=sqrtf(u);}
9D0021A8  27BDFFE8   ADDIU SP, SP, -24
9D0021AC  AFBF0014   SW RA, 20(SP)
9D0021B0  AFB00010   SW S0, 16(SP)
9D0021B4  8F908014   LW S0, -32748(GP)
9D0021B8  0F403E25   JAL __floatunsisf
9D0021BC  8E040000   LW A0, 0(S0)
9D0021C0  0F403DFD   JAL sqrtf
9D0021C4  00402021   ADDU A0, V0, ZERO
9D0021C8  0F40294B   JAL __fixsfsi
9D0021CC  00402021   ADDU A0, V0, ZERO
9D0021D0  AE020000   SW V0, 0(S0)
9D0021D4  8FBF0014   LW RA, 20(SP)
9D0021D8  8FB00010   LW S0, 16(SP)
9D0021DC  03E00008   JR RA
9D0021E0  27BD0018   ADDIU SP, SP, 24
444:                 
445:                 
446:                 // um/mod ( ud u1 -- rem u )
447:                 void umdivmod(void)
448:                 {
9D0010EC  27BDFFD8   ADDIU SP, SP, -40
9D0010F0  AFBF0024   SW RA, 36(SP)
9D0010F4  AFB40020   SW S4, 32(SP)
9D0010F8  AFB3001C   SW S3, 28(SP)
9D0010FC  AFB20018   SW S2, 24(SP)
9D001100  AFB10014   SW S1, 20(SP)
9D001104  AFB00010   SW S0, 16(SP)
449:                 	udcell ud, u1=POP;
9D001108  8F828014   LW V0, -32748(GP)
9D00110C  8C500000   LW S0, 0(V0)
9D001110  00108FC3   SRA S1, S0, 31
9D001114  2452FFFC   ADDIU S2, V0, -4
450:                 	if (u1==0) {vErrors|=8; abortf();}
9D001118  02111825   OR V1, S0, S1
9D00111C  14600007   BNE V1, ZERO, 0x9D00113C
9D001120  AF928014   SW S2, -32748(GP)
9D001124  9382808F   LBU V0, -32625(GP)
9D001128  34420008   ORI V0, V0, 8
9D00112C  0F400360   JAL abortf
9D001130  A382808F   SB V0, -32625(GP)
451:                 	else {DPOP(ud); PUSH(ud%u1); PUSH(ud/u1);}
9D00113C  8C54FFFC   LW S4, -4(V0)
9D001140  2642FFFC   ADDIU V0, S2, -4
9D001144  AF828014   SW V0, -32748(GP)
9D001148  8E53FFFC   LW S3, -4(S2)
9D00114C  02602021   ADDU A0, S3, ZERO
9D001150  02802821   ADDU A1, S4, ZERO
9D001154  02003021   ADDU A2, S0, ZERO
9D001158  0F402EB1   JAL __umoddi3
9D00115C  02203821   ADDU A3, S1, ZERO
9D001160  AE42FFFC   SW V0, -4(S2)
9D001164  8F928014   LW S2, -32748(GP)
9D001168  26420004   ADDIU V0, S2, 4
9D00116C  AF828014   SW V0, -32748(GP)
9D001170  02602021   ADDU A0, S3, ZERO
9D001174  02802821   ADDU A1, S4, ZERO
9D001178  02003021   ADDU A2, S0, ZERO
9D00117C  0F402FC9   JAL __udivdi3
9D001180  02203821   ADDU A3, S1, ZERO
9D001184  AE420004   SW V0, 4(S2)
452:                 } 
9D001134  0B400463   J 0x9D00118C
9D001138  8FBF0024   LW RA, 36(SP)
9D001188  8FBF0024   LW RA, 36(SP)
9D00118C  8FB40020   LW S4, 32(SP)
9D001190  8FB3001C   LW S3, 28(SP)
9D001194  8FB20018   LW S2, 24(SP)
9D001198  8FB10014   LW S1, 20(SP)
9D00119C  8FB00010   LW S0, 16(SP)
9D0011A0  03E00008   JR RA
9D0011A4  27BD0028   ADDIU SP, SP, 40
453:                 
454:                 
455:                 // m/mod ( d n1 -- rem n )
456:                 void mdivmod(void)
457:                 {
9D001030  27BDFFD8   ADDIU SP, SP, -40
9D001034  AFBF0024   SW RA, 36(SP)
9D001038  AFB40020   SW S4, 32(SP)
9D00103C  AFB3001C   SW S3, 28(SP)
9D001040  AFB20018   SW S2, 24(SP)
9D001044  AFB10014   SW S1, 20(SP)
9D001048  AFB00010   SW S0, 16(SP)
458:                 	dcell d, n1=POP;
9D00104C  8F828014   LW V0, -32748(GP)
9D001050  8C500000   LW S0, 0(V0)
9D001054  00108FC3   SRA S1, S0, 31
9D001058  2452FFFC   ADDIU S2, V0, -4
459:                 	if (n1==0) {vErrors|=8; abortf();}
9D00105C  02111825   OR V1, S0, S1
9D001060  14600007   BNE V1, ZERO, 0x9D001080
9D001064  AF928014   SW S2, -32748(GP)
9D001068  9382808F   LBU V0, -32625(GP)
9D00106C  34420008   ORI V0, V0, 8
9D001070  0F400360   JAL abortf
9D001074  A382808F   SB V0, -32625(GP)
460:                 	else {DPOP(d); PUSH(d%n1); PUSH(d/n1);}
9D001080  8C54FFFC   LW S4, -4(V0)
9D001084  2642FFFC   ADDIU V0, S2, -4
9D001088  AF828014   SW V0, -32748(GP)
9D00108C  8E53FFFC   LW S3, -4(S2)
9D001090  02602021   ADDU A0, S3, ZERO
9D001094  02802821   ADDU A1, S4, ZERO
9D001098  02003021   ADDU A2, S0, ZERO
9D00109C  0F402B1C   JAL __moddi3
9D0010A0  02203821   ADDU A3, S1, ZERO
9D0010A4  AE42FFFC   SW V0, -4(S2)
9D0010A8  8F928014   LW S2, -32748(GP)
9D0010AC  26420004   ADDIU V0, S2, 4
9D0010B0  AF828014   SW V0, -32748(GP)
9D0010B4  02602021   ADDU A0, S3, ZERO
9D0010B8  02802821   ADDU A1, S4, ZERO
9D0010BC  02003021   ADDU A2, S0, ZERO
9D0010C0  0F402D87   JAL __divdi3
9D0010C4  02203821   ADDU A3, S1, ZERO
9D0010C8  AE420004   SW V0, 4(S2)
461:                 } 
9D001078  0B400434   J 0x9D0010D0
9D00107C  8FBF0024   LW RA, 36(SP)
9D0010CC  8FBF0024   LW RA, 36(SP)
9D0010D0  8FB40020   LW S4, 32(SP)
9D0010D4  8FB3001C   LW S3, 28(SP)
9D0010D8  8FB20018   LW S2, 24(SP)
9D0010DC  8FB10014   LW S1, 20(SP)
9D0010E0  8FB00010   LW S0, 16(SP)
9D0010E4  03E00008   JR RA
9D0010E8  27BD0028   ADDIU SP, SP, 40
462:                 
463:                 
464:                 // u/mod ( u1 u2 -- rem u )
465:                 void udivmod(void)
466:                 {
9D000FD8  27BDFFE8   ADDIU SP, SP, -24
9D000FDC  AFBF0014   SW RA, 20(SP)
467:                 	ucell u2=TOS, u1=TOSi(1);
9D000FE0  8F828014   LW V0, -32748(GP)
9D000FE4  8C430000   LW V1, 0(V0)
468:                 	if (u2==0) {vErrors|=8; abortf();}
9D000FE8  14600007   BNE V1, ZERO, 0x9D001008
9D000FEC  8C44FFFC   LW A0, -4(V0)
9D000FF0  9382808F   LBU V0, -32625(GP)
9D000FF4  34420008   ORI V0, V0, 8
9D000FF8  0F400360   JAL abortf
9D000FFC  A382808F   SB V0, -32625(GP)
469:                 	else {TOSi(1)=u1%u2; TOS=u1/u2;}
9D001008  0083001B   DIVU A0, V1
9D00100C  006001F4   TEQ V1, ZERO
9D001010  00001810   MFHI V1, 0
9D001014  00002012   MFLO A0, 0
9D001018  AC43FFFC   SW V1, -4(V0)
9D00101C  8F828014   LW V0, -32748(GP)
9D001020  AC440000   SW A0, 0(V0)
470:                 } 
9D001000  0B40040A   J 0x9D001028
9D001004  8FBF0014   LW RA, 20(SP)
9D001024  8FBF0014   LW RA, 20(SP)
9D001028  03E00008   JR RA
9D00102C  27BD0018   ADDIU SP, SP, 24
471:                 
472:                 
473:                 // /mod ( n1 n2 -- rem n )
474:                 void divmod(void)
475:                 {
9D000F80  27BDFFE8   ADDIU SP, SP, -24
9D000F84  AFBF0014   SW RA, 20(SP)
476:                 	cell n2=TOS, n1=TOSi(1);
9D000F88  8F828014   LW V0, -32748(GP)
9D000F8C  8C430000   LW V1, 0(V0)
477:                 	if (n2==0) {vErrors|=8; abortf();}
9D000F90  14600007   BNE V1, ZERO, 0x9D000FB0
9D000F94  8C44FFFC   LW A0, -4(V0)
9D000F98  9382808F   LBU V0, -32625(GP)
9D000F9C  34420008   ORI V0, V0, 8
9D000FA0  0F400360   JAL abortf
9D000FA4  A382808F   SB V0, -32625(GP)
478:                 	else {TOSi(1)=n1%n2; TOS=n1/n2;}
9D000FB0  0083001A   DIV A0, V1
9D000FB4  006001F4   TEQ V1, ZERO
9D000FB8  00001810   MFHI V1, 0
9D000FBC  00002012   MFLO A0, 0
9D000FC0  AC43FFFC   SW V1, -4(V0)
9D000FC4  8F828014   LW V0, -32748(GP)
9D000FC8  AC440000   SW A0, 0(V0)
479:                 } 
9D000FA8  0B4003F4   J 0x9D000FD0
9D000FAC  8FBF0014   LW RA, 20(SP)
9D000FCC  8FBF0014   LW RA, 20(SP)
9D000FD0  03E00008   JR RA
9D000FD4  27BD0018   ADDIU SP, SP, 24
480:                 
481:                 
482:                 //  / ( n1 n2 -- n )
483:                 void divf(void)
484:                 {
9D000F2C  27BDFFE8   ADDIU SP, SP, -24
9D000F30  AFBF0014   SW RA, 20(SP)
485:                 	cell n2=POP, n1=TOS;
9D000F34  8F828014   LW V0, -32748(GP)
9D000F38  8C430000   LW V1, 0(V0)
9D000F3C  2444FFFC   ADDIU A0, V0, -4
9D000F40  AF848014   SW A0, -32748(GP)
486:                 	if (n2==0) {vErrors|=8; abortf();}
9D000F44  14600007   BNE V1, ZERO, 0x9D000F64
9D000F48  8C44FFFC   LW A0, -4(V0)
9D000F4C  9382808F   LBU V0, -32625(GP)
9D000F50  34420008   ORI V0, V0, 8
9D000F54  0F400360   JAL abortf
9D000F58  A382808F   SB V0, -32625(GP)
487:                 	else {TOS=n1/n2;}
9D000F64  0083001A   DIV A0, V1
9D000F68  006001F4   TEQ V1, ZERO
9D000F6C  00002012   MFLO A0, 0
9D000F70  AC44FFFC   SW A0, -4(V0)
488:                 } 
9D000F5C  0B4003DE   J 0x9D000F78
9D000F60  8FBF0014   LW RA, 20(SP)
9D000F74  8FBF0014   LW RA, 20(SP)
9D000F78  03E00008   JR RA
9D000F7C  27BD0018   ADDIU SP, SP, 24
489:                 
490:                 
491:                 // mod ( n1 n2 -- rem )
492:                 void modn(void)
493:                 {
9D000ED8  27BDFFE8   ADDIU SP, SP, -24
9D000EDC  AFBF0014   SW RA, 20(SP)
494:                 	cell n2=POP, n1=TOS;
9D000EE0  8F828014   LW V0, -32748(GP)
9D000EE4  8C430000   LW V1, 0(V0)
9D000EE8  2444FFFC   ADDIU A0, V0, -4
9D000EEC  AF848014   SW A0, -32748(GP)
495:                 	if (n2==0) {vErrors|=8; abortf();}
9D000EF0  14600007   BNE V1, ZERO, 0x9D000F10
9D000EF4  8C44FFFC   LW A0, -4(V0)
9D000EF8  9382808F   LBU V0, -32625(GP)
9D000EFC  34420008   ORI V0, V0, 8
9D000F00  0F400360   JAL abortf
9D000F04  A382808F   SB V0, -32625(GP)
496:                 	else {TOS=n1%n2;}
9D000F10  0083001A   DIV A0, V1
9D000F14  006001F4   TEQ V1, ZERO
9D000F18  00001810   MFHI V1, 0
9D000F1C  AC43FFFC   SW V1, -4(V0)
497:                 } 
9D000F08  0B4003C9   J 0x9D000F24
9D000F0C  8FBF0014   LW RA, 20(SP)
9D000F20  8FBF0014   LW RA, 20(SP)
9D000F24  03E00008   JR RA
9D000F28  27BD0018   ADDIU SP, SP, 24
498:                 
499:                 
500:                 // u*/ ( u1 u2 u3 -- u )
501:                 void umuldiv(void)
502:                 {
9D000E3C  27BDFFE8   ADDIU SP, SP, -24
9D000E40  AFBF0014   SW RA, 20(SP)
9D000E44  AFB00010   SW S0, 16(SP)
503:                 	udcell u3=POP, u2=POP, u1=POP;
9D000E48  8F908014   LW S0, -32748(GP)
9D000E4C  8E060000   LW A2, 0(S0)
9D000E50  00063FC3   SRA A3, A2, 31
9D000E54  2602FFFC   ADDIU V0, S0, -4
9D000E58  AF828014   SW V0, -32748(GP)
9D000E5C  8E02FFFC   LW V0, -4(S0)
9D000E60  2603FFF8   ADDIU V1, S0, -8
9D000E64  AF838014   SW V1, -32748(GP)
9D000E68  8E04FFF8   LW A0, -8(S0)
9D000E6C  2610FFF4   ADDIU S0, S0, -12
9D000E9C  00042FC3   SRA A1, A0, 31
9D000EA0  00021FC3   SRA V1, V0, 31
504:                 	if (u3==0) {vErrors|=8; abortf();}
9D000E70  00C71825   OR V1, A2, A3
9D000E74  14600007   BNE V1, ZERO, 0x9D000E94
9D000E78  AF908014   SW S0, -32748(GP)
9D000E7C  9382808F   LBU V0, -32625(GP)
9D000E80  34420008   ORI V0, V0, 8
9D000E84  0F400360   JAL abortf
9D000E88  A382808F   SB V0, -32625(GP)
505:                 	else {PUSH((u1*u2)/u3);}
9D000E94  26030004   ADDIU V1, S0, 4
9D000E98  AF838014   SW V1, -32748(GP)
9D000EA4  00640018   MULT 0, V1, A0
9D000EA8  70A20000   MADD 0, A1, V0
9D000EAC  00001812   MFLO V1, 0
9D000EB0  00820019   MULTU 0, A0, V0
9D000EB4  00002012   MFLO A0, 0
9D000EB8  00002810   MFHI A1, 0
9D000EBC  0F402FC9   JAL __udivdi3
9D000EC0  00652821   ADDU A1, V1, A1
9D000EC4  AE020004   SW V0, 4(S0)
506:                 }
9D000E8C  0B4003B3   J 0x9D000ECC
9D000E90  8FBF0014   LW RA, 20(SP)
9D000EC8  8FBF0014   LW RA, 20(SP)
9D000ECC  8FB00010   LW S0, 16(SP)
9D000ED0  03E00008   JR RA
9D000ED4  27BD0018   ADDIU SP, SP, 24
507:                 
508:                 
509:                 // */ ( n1 n2 n3 -- n )
510:                 void muldiv(void)
511:                 {
9D000DA0  27BDFFE8   ADDIU SP, SP, -24
9D000DA4  AFBF0014   SW RA, 20(SP)
9D000DA8  AFB00010   SW S0, 16(SP)
512:                 	dcell n3=POP, n2=POP, n1=POP;
9D000DAC  8F908014   LW S0, -32748(GP)
9D000DB0  8E060000   LW A2, 0(S0)
9D000DB4  00063FC3   SRA A3, A2, 31
9D000DB8  2602FFFC   ADDIU V0, S0, -4
9D000DBC  AF828014   SW V0, -32748(GP)
9D000DC0  8E02FFFC   LW V0, -4(S0)
9D000DC4  2603FFF8   ADDIU V1, S0, -8
9D000DC8  AF838014   SW V1, -32748(GP)
9D000DCC  8E04FFF8   LW A0, -8(S0)
9D000DD0  2610FFF4   ADDIU S0, S0, -12
9D000E00  00042FC3   SRA A1, A0, 31
9D000E04  00021FC3   SRA V1, V0, 31
513:                 	if (n3==0) {vErrors|=8; abortf();}
9D000DD4  00C71825   OR V1, A2, A3
9D000DD8  14600007   BNE V1, ZERO, 0x9D000DF8
9D000DDC  AF908014   SW S0, -32748(GP)
9D000DE0  9382808F   LBU V0, -32625(GP)
9D000DE4  34420008   ORI V0, V0, 8
9D000DE8  0F400360   JAL abortf
9D000DEC  A382808F   SB V0, -32625(GP)
514:                 	else {PUSH((n1*n2)/n3);}
9D000DF8  26030004   ADDIU V1, S0, 4
9D000DFC  AF838014   SW V1, -32748(GP)
9D000E08  00640018   MULT 0, V1, A0
9D000E0C  70A20000   MADD 0, A1, V0
9D000E10  00001812   MFLO V1, 0
9D000E14  00820019   MULTU 0, A0, V0
9D000E18  00002012   MFLO A0, 0
9D000E1C  00002810   MFHI A1, 0
9D000E20  0F402D87   JAL __divdi3
9D000E24  00652821   ADDU A1, V1, A1
9D000E28  AE020004   SW V0, 4(S0)
515:                 }
9D000DF0  0B40038C   J 0x9D000E30
9D000DF4  8FBF0014   LW RA, 20(SP)
9D000E2C  8FBF0014   LW RA, 20(SP)
9D000E30  8FB00010   LW S0, 16(SP)
9D000E34  03E00008   JR RA
9D000E38  27BD0018   ADDIU SP, SP, 24
516:                 
517:                 
518:                 // >>a ( n1 u -- n )
519:                 void arshift(void) {ucell u=POP; TOS=(cell)TOS>>u;}
9D000608  8F828014   LW V0, -32748(GP)
9D00060C  8C430000   LW V1, 0(V0)
9D000610  2444FFFC   ADDIU A0, V0, -4
9D000614  AF848014   SW A0, -32748(GP)
9D000618  8C44FFFC   LW A0, -4(V0)
9D00061C  00641807   SRAV V1, A0, V1
9D000620  03E00008   JR RA
9D000624  AC43FFFC   SW V1, -4(V0)
520:                 
521:                 
522:                 // >> ( x1 u -- x )
523:                 void rshift(void) {ucell u=POP; TOS=(ucell)TOS>>u;}
9D000628  8F828014   LW V0, -32748(GP)
9D00062C  8C430000   LW V1, 0(V0)
9D000630  2444FFFC   ADDIU A0, V0, -4
9D000634  AF848014   SW A0, -32748(GP)
9D000638  8C44FFFC   LW A0, -4(V0)
9D00063C  00641806   SRLV V1, A0, V1
9D000640  03E00008   JR RA
9D000644  AC43FFFC   SW V1, -4(V0)
524:                 
525:                 
526:                 // << ( x1 u -- x )
527:                 void lshift(void) {ucell u=POP; TOS=(ucell)TOS<<u;}
9D000648  8F828014   LW V0, -32748(GP)
9D00064C  8C430000   LW V1, 0(V0)
9D000650  2444FFFC   ADDIU A0, V0, -4
9D000654  AF848014   SW A0, -32748(GP)
9D000658  8C44FFFC   LW A0, -4(V0)
9D00065C  00641804   SLLV V1, A0, V1
9D000660  03E00008   JR RA
9D000664  AC43FFFC   SW V1, -4(V0)
528:                 
529:                 
530:                 // 2* ( n1 -- n )
531:                 void twomul(void) {TOS=TOS<<1;}
9D000668  8F828014   LW V0, -32748(GP)
9D00066C  8C430000   LW V1, 0(V0)
9D000670  00031840   SLL V1, V1, 1
9D000674  03E00008   JR RA
9D000678  AC430000   SW V1, 0(V0)
532:                 
533:                 
534:                 // 2/ ( n1 -- n )
535:                 void twodiv(void) {TOS=TOS>>1;}
9D00067C  8F828014   LW V0, -32748(GP)
9D000680  8C430000   LW V1, 0(V0)
9D000684  00031843   SRA V1, V1, 1
9D000688  03E00008   JR RA
9D00068C  AC430000   SW V1, 0(V0)
536:                 
537:                 
538:                 // min ( n1 n2 -- n1|n2 )
539:                 void minf(void) {cell n2=POP; TOS=(n2<TOS) ? n2:TOS;}
9D000690  8F828014   LW V0, -32748(GP)
9D000694  8C430000   LW V1, 0(V0)
9D000698  2444FFFC   ADDIU A0, V0, -4
9D00069C  AF848014   SW A0, -32748(GP)
9D0006A0  8C44FFFC   LW A0, -4(V0)
9D0006A4  0064282A   SLT A1, V1, A0
9D0006A8  0085180A   MOVZ V1, A0, A1
9D0006AC  03E00008   JR RA
9D0006B0  AC43FFFC   SW V1, -4(V0)
540:                 
541:                 
542:                 // max ( n1 n2 -- n1|n2 )
543:                 void maxf(void) {cell n2=POP; TOS=(n2>TOS) ? n2:TOS;}
9D0006B4  8F828014   LW V0, -32748(GP)
9D0006B8  8C430000   LW V1, 0(V0)
9D0006BC  2444FFFC   ADDIU A0, V0, -4
9D0006C0  AF848014   SW A0, -32748(GP)
9D0006C4  8C44FFFC   LW A0, -4(V0)
9D0006C8  0083282A   SLT A1, A0, V1
9D0006CC  0085180A   MOVZ V1, A0, A1
9D0006D0  03E00008   JR RA
9D0006D4  AC43FFFC   SW V1, -4(V0)
544:                 
545:                 
546:                 // abs ( n -- u )
547:                 void absf(void) {TOS=(TOS<0) ? -TOS:TOS;}
9D0006D8  8F828014   LW V0, -32748(GP)
9D0006DC  8C440000   LW A0, 0(V0)
9D0006E0  00041FC3   SRA V1, A0, 31
9D0006E4  00832026   XOR A0, A0, V1
9D0006E8  00831823   SUBU V1, A0, V1
9D0006EC  03E00008   JR RA
9D0006F0  AC430000   SW V1, 0(V0)
548:                 
549:                 
550:                 // 1+ ( n1 -- n )
551:                 void incf(void) {TOS++;} 
9D0006F4  8F828014   LW V0, -32748(GP)
9D0006F8  8C430000   LW V1, 0(V0)
9D0006FC  24630001   ADDIU V1, V1, 1
9D000700  03E00008   JR RA
9D000704  AC430000   SW V1, 0(V0)
552:                 
553:                 
554:                 // 1- ( n1 -- n )
555:                 void decf(void) {TOS--;} 
9D000708  8F828014   LW V0, -32748(GP)
9D00070C  8C430000   LW V1, 0(V0)
9D000710  2463FFFF   ADDIU V1, V1, -1
9D000714  03E00008   JR RA
9D000718  AC430000   SW V1, 0(V0)
556:                 
557:                 
558:                 // negate ( n1 -- n )
559:                 void negate(void) {TOS=-TOS;} 
9D00071C  8F828014   LW V0, -32748(GP)
9D000720  8C430000   LW V1, 0(V0)
9D000724  00031823   SUBU V1, ZERO, V1
9D000728  03E00008   JR RA
9D00072C  AC430000   SW V1, 0(V0)
560:                 
561:                 
562:                 // invert ( n1 -- n )
563:                 void invert(void) {TOS=TOS^-1;} 
9D000730  8F828014   LW V0, -32748(GP)
9D000734  8C430000   LW V1, 0(V0)
9D000738  00031827   NOR V1, ZERO, V1
9D00073C  03E00008   JR RA
9D000740  AC430000   SW V1, 0(V0)
564:                 
565:                 
566:                 // and ( x1 x2 -- x )
567:                 void andf(void) {cell x2=POP; TOS=TOS&x2;}
9D000744  8F828014   LW V0, -32748(GP)
9D000748  8C430000   LW V1, 0(V0)
9D00074C  2444FFFC   ADDIU A0, V0, -4
9D000750  AF848014   SW A0, -32748(GP)
9D000754  8C44FFFC   LW A0, -4(V0)
9D000758  00831824   AND V1, A0, V1
9D00075C  03E00008   JR RA
9D000760  AC43FFFC   SW V1, -4(V0)
568:                 
569:                 
570:                 // or ( x1 x2 -- x )
571:                 void orf(void) {cell x2=POP; TOS=TOS|x2;}
9D000764  8F828014   LW V0, -32748(GP)
9D000768  8C430000   LW V1, 0(V0)
9D00076C  2444FFFC   ADDIU A0, V0, -4
9D000770  AF848014   SW A0, -32748(GP)
9D000774  8C44FFFC   LW A0, -4(V0)
9D000778  00831825   OR V1, A0, V1
9D00077C  03E00008   JR RA
9D000780  AC43FFFC   SW V1, -4(V0)
572:                 
573:                 
574:                 // xor ( x1 x2 -- x )
575:                 void xorf(void) {cell x2=POP; TOS=TOS^x2;}
9D000784  8F828014   LW V0, -32748(GP)
9D000788  8C430000   LW V1, 0(V0)
9D00078C  2444FFFC   ADDIU A0, V0, -4
9D000790  AF848014   SW A0, -32748(GP)
9D000794  8C44FFFC   LW A0, -4(V0)
9D000798  00831826   XOR V1, A0, V1
9D00079C  03E00008   JR RA
9D0007A0  AC43FFFC   SW V1, -4(V0)
576:                 
577:                 
578:                 // ********** LOGIC **********
579:                 
580:                 
581:                 // andl ( x1 x2 -- fl )
582:                 void andl(void) {cell x2=POP; TOS=(x2&&TOS) ? -1:0;;}
9D0007A4  8F828014   LW V0, -32748(GP)
9D0007A8  8C440000   LW A0, 0(V0)
9D0007AC  2443FFFC   ADDIU V1, V0, -4
9D0007B0  AF838014   SW V1, -32748(GP)
9D0007B4  10800004   BEQ A0, ZERO, 0x9D0007C8
9D0007B8  00001821   ADDU V1, ZERO, ZERO
9D0007BC  8C44FFFC   LW A0, -4(V0)
9D0007C0  2403FFFF   ADDIU V1, ZERO, -1
9D0007C4  0004180A   MOVZ V1, ZERO, A0
9D0007C8  03E00008   JR RA
9D0007CC  AC43FFFC   SW V1, -4(V0)
583:                 
584:                 
585:                 // orl ( x1 x2 -- fl )
586:                 void orl(void) {cell x2=POP; TOS=(x2||TOS) ? -1:0;}
9D0007D0  8F828014   LW V0, -32748(GP)
9D0007D4  8C440000   LW A0, 0(V0)
9D0007D8  2443FFFC   ADDIU V1, V0, -4
9D0007DC  AF838014   SW V1, -32748(GP)
9D0007E0  14800003   BNE A0, ZERO, 0x9D0007F0
9D0007E4  2403FFFF   ADDIU V1, ZERO, -1
9D0007E8  8C44FFFC   LW A0, -4(V0)
9D0007EC  0004180A   MOVZ V1, ZERO, A0
9D0007F0  03E00008   JR RA
9D0007F4  AC43FFFC   SW V1, -4(V0)
587:                 
588:                 
589:                 // not ( x1 -- fl )
590:                 void notl(void) {TOS=(TOS) ? 0:-1;}
9D0007F8  8F828014   LW V0, -32748(GP)
9D0007FC  8C440000   LW A0, 0(V0)
9D000800  2403FFFF   ADDIU V1, ZERO, -1
9D000804  0004180B   MOVN V1, ZERO, A0
9D000808  03E00008   JR RA
9D00080C  AC430000   SW V1, 0(V0)
591:                 
592:                 
593:                 // = ( n1 n2 -- fl )
594:                 void equals(void) {cell n2=POP;	TOS=(TOS==n2) ? -1:0;}
9D000810  8F828014   LW V0, -32748(GP)
9D000814  8C430000   LW V1, 0(V0)
9D000818  2444FFFC   ADDIU A0, V0, -4
9D00081C  AF848014   SW A0, -32748(GP)
9D000820  8C44FFFC   LW A0, -4(V0)
9D000824  00831826   XOR V1, A0, V1
9D000828  2404FFFF   ADDIU A0, ZERO, -1
9D00082C  0003200B   MOVN A0, ZERO, V1
9D000830  03E00008   JR RA
9D000834  AC44FFFC   SW A0, -4(V0)
595:                 
596:                 
597:                 // <> ( n1 n2 -- fl )
598:                 void notequals(void) {cell n2=POP; TOS=(TOS!=n2) ? -1:0;}
9D000838  8F828014   LW V0, -32748(GP)
9D00083C  8C430000   LW V1, 0(V0)
9D000840  2444FFFC   ADDIU A0, V0, -4
9D000844  AF848014   SW A0, -32748(GP)
9D000848  8C44FFFC   LW A0, -4(V0)
9D00084C  00831826   XOR V1, A0, V1
9D000850  2404FFFF   ADDIU A0, ZERO, -1
9D000854  0003200A   MOVZ A0, ZERO, V1
9D000858  03E00008   JR RA
9D00085C  AC44FFFC   SW A0, -4(V0)
599:                 
600:                 
601:                 // > ( n1 n2 -- fl )
602:                 void greater(void) {cell n2=POP; TOS=(TOS>n2) ? -1:0;}
9D000860  8F828014   LW V0, -32748(GP)
9D000864  8C440000   LW A0, 0(V0)
9D000868  2443FFFC   ADDIU V1, V0, -4
9D00086C  AF838014   SW V1, -32748(GP)
9D000870  8C43FFFC   LW V1, -4(V0)
9D000874  0083182A   SLT V1, A0, V1
9D000878  2404FFFF   ADDIU A0, ZERO, -1
9D00087C  0003200A   MOVZ A0, ZERO, V1
9D000880  03E00008   JR RA
9D000884  AC44FFFC   SW A0, -4(V0)
603:                 
604:                 
605:                 // < ( n1 n2 -- fl )
606:                 void less(void) {cell n2=POP; TOS=(TOS<n2) ? -1:0;}
9D000888  8F828014   LW V0, -32748(GP)
9D00088C  8C440000   LW A0, 0(V0)
9D000890  2443FFFC   ADDIU V1, V0, -4
9D000894  AF838014   SW V1, -32748(GP)
9D000898  8C43FFFC   LW V1, -4(V0)
9D00089C  0064182A   SLT V1, V1, A0
9D0008A0  2404FFFF   ADDIU A0, ZERO, -1
9D0008A4  0003200A   MOVZ A0, ZERO, V1
9D0008A8  03E00008   JR RA
9D0008AC  AC44FFFC   SW A0, -4(V0)
607:                 
608:                 
609:                 // >= ( n1 n2 -- fl )
610:                 void greaterequals(void) {cell n2=POP; TOS=(TOS>=n2) ? -1:0;}
9D0008B0  8F828014   LW V0, -32748(GP)
9D0008B4  8C440000   LW A0, 0(V0)
9D0008B8  2443FFFC   ADDIU V1, V0, -4
9D0008BC  AF838014   SW V1, -32748(GP)
9D0008C0  8C43FFFC   LW V1, -4(V0)
9D0008C4  0064182A   SLT V1, V1, A0
9D0008C8  2404FFFF   ADDIU A0, ZERO, -1
9D0008CC  0003200B   MOVN A0, ZERO, V1
9D0008D0  03E00008   JR RA
9D0008D4  AC44FFFC   SW A0, -4(V0)
611:                 
612:                 
613:                 // <= ( n1 n2 -- fl )
614:                 void lessequals(void) {cell n2=POP;	TOS=(TOS<=n2) ? -1:0;}
9D0008D8  8F828014   LW V0, -32748(GP)
9D0008DC  8C440000   LW A0, 0(V0)
9D0008E0  2443FFFC   ADDIU V1, V0, -4
9D0008E4  AF838014   SW V1, -32748(GP)
9D0008E8  8C43FFFC   LW V1, -4(V0)
9D0008EC  0083182A   SLT V1, A0, V1
9D0008F0  2404FFFF   ADDIU A0, ZERO, -1
9D0008F4  0003200B   MOVN A0, ZERO, V1
9D0008F8  03E00008   JR RA
9D0008FC  AC44FFFC   SW A0, -4(V0)
615:                 
616:                 
617:                 // 0= ( x1 -- fl )
618:                 void zeroequals(void) {TOS=(TOS==0) ? -1:0;}
9D000900  8F828014   LW V0, -32748(GP)
9D000904  8C440000   LW A0, 0(V0)
9D000908  2403FFFF   ADDIU V1, ZERO, -1
9D00090C  0004180B   MOVN V1, ZERO, A0
9D000910  03E00008   JR RA
9D000914  AC430000   SW V1, 0(V0)
619:                 
620:                 
621:                 // 0< ( n1 -- fl )
622:                 void zeroless(void) {TOS=(TOS<0) ? -1:0;}
9D000918  8F828014   LW V0, -32748(GP)
9D00091C  8C430000   LW V1, 0(V0)
9D000920  28630000   SLTI V1, V1, 0
9D000924  2404FFFF   ADDIU A0, ZERO, -1
9D000928  0003200A   MOVZ A0, ZERO, V1
9D00092C  03E00008   JR RA
9D000930  AC440000   SW A0, 0(V0)
623:                 
624:                 
625:                 // 0> ( x1 -- fl )
626:                 void zerogreater(void) {TOS=(TOS>0) ? -1:0;}
9D000934  8F828014   LW V0, -32748(GP)
9D000938  8C430000   LW V1, 0(V0)
9D00093C  28630001   SLTI V1, V1, 1
9D000940  2404FFFF   ADDIU A0, ZERO, -1
9D000944  0003200B   MOVN A0, ZERO, V1
9D000948  03E00008   JR RA
9D00094C  AC440000   SW A0, 0(V0)
627:                 
628:                 
629:                 // u> ( u1 u2 -- fl )
630:                 void ugreater(void) {ucell u2=POP; TOS=((ucell)TOS>u2) ? -1:0;}
9D000950  8F828014   LW V0, -32748(GP)
9D000954  8C440000   LW A0, 0(V0)
9D000958  2443FFFC   ADDIU V1, V0, -4
9D00095C  AF838014   SW V1, -32748(GP)
9D000960  8C43FFFC   LW V1, -4(V0)
9D000964  0083182B   SLTU V1, A0, V1
9D000968  2404FFFF   ADDIU A0, ZERO, -1
9D00096C  0003200A   MOVZ A0, ZERO, V1
9D000970  03E00008   JR RA
9D000974  AC44FFFC   SW A0, -4(V0)
631:                 
632:                 
633:                 // u< ( u1 u2 -- fl )
634:                 void uless(void) {ucell u2=POP;	TOS=((ucell)TOS<u2) ? -1:0;}
9D000978  8F828014   LW V0, -32748(GP)
9D00097C  8C440000   LW A0, 0(V0)
9D000980  2443FFFC   ADDIU V1, V0, -4
9D000984  AF838014   SW V1, -32748(GP)
9D000988  8C43FFFC   LW V1, -4(V0)
9D00098C  0064182B   SLTU V1, V1, A0
9D000990  2404FFFF   ADDIU A0, ZERO, -1
9D000994  0003200A   MOVZ A0, ZERO, V1
9D000998  03E00008   JR RA
9D00099C  AC44FFFC   SW A0, -4(V0)
635:                 
636:                 
637:                 // u>= ( u1 u2 -- fl )
638:                 void ugreaterequals(void) {ucell u2=POP; TOS=((ucell)TOS>=u2) ? -1:0;}
9D0009A0  8F828014   LW V0, -32748(GP)
9D0009A4  8C440000   LW A0, 0(V0)
9D0009A8  2443FFFC   ADDIU V1, V0, -4
9D0009AC  AF838014   SW V1, -32748(GP)
9D0009B0  8C43FFFC   LW V1, -4(V0)
9D0009B4  0064182B   SLTU V1, V1, A0
9D0009B8  2404FFFF   ADDIU A0, ZERO, -1
9D0009BC  0003200B   MOVN A0, ZERO, V1
9D0009C0  03E00008   JR RA
9D0009C4  AC44FFFC   SW A0, -4(V0)
639:                 
640:                 
641:                 // u<= ( u1 u2 -- fl )
642:                 void ulessequals(void) {ucell u2=POP; TOS=((ucell)TOS<=u2) ? -1:0;}
9D0009C8  8F828014   LW V0, -32748(GP)
9D0009CC  8C440000   LW A0, 0(V0)
9D0009D0  2443FFFC   ADDIU V1, V0, -4
9D0009D4  AF838014   SW V1, -32748(GP)
9D0009D8  8C43FFFC   LW V1, -4(V0)
9D0009DC  0083182B   SLTU V1, A0, V1
9D0009E0  2404FFFF   ADDIU A0, ZERO, -1
9D0009E4  0003200B   MOVN A0, ZERO, V1
9D0009E8  03E00008   JR RA
9D0009EC  AC44FFFC   SW A0, -4(V0)
643:                 
644:                 
645:                 // d= ( d1 d2 -- fl )
646:                 void dequals(void)
647:                 {
648:                 	dcell d1, d2;
649:                 	DPOP(d2); DPOP(d1);
9D0009F0  8F828014   LW V0, -32748(GP)
9D0009F4  8C440000   LW A0, 0(V0)
9D0009F8  2443FFFC   ADDIU V1, V0, -4
9D0009FC  AF838014   SW V1, -32748(GP)
9D000A00  8C43FFFC   LW V1, -4(V0)
9D000A04  00803021   ADDU A2, A0, ZERO
9D000A08  2444FFF8   ADDIU A0, V0, -8
9D000A0C  AF848014   SW A0, -32748(GP)
9D000A10  8C45FFF8   LW A1, -8(V0)
9D000A14  2444FFF4   ADDIU A0, V0, -12
9D000A18  AF848014   SW A0, -32748(GP)
9D000A1C  8C44FFF4   LW A0, -12(V0)
9D000A20  00A03821   ADDU A3, A1, ZERO
9D000A24  2445FFF0   ADDIU A1, V0, -16
650:                 	TOS=(d1==d2) ? -1:0;
9D000A28  14830003   BNE A0, V1, 0x9D000A38
9D000A2C  AF858014   SW A1, -32748(GP)
9D000A30  10E60002   BEQ A3, A2, 0x9D000A3C
9D000A34  2403FFFF   ADDIU V1, ZERO, -1
9D000A38  00001821   ADDU V1, ZERO, ZERO
651:                 }
9D000A3C  03E00008   JR RA
9D000A40  AC43FFF0   SW V1, -16(V0)
652:                 
653:                 
654:                 // d<> ( d1 d2 -- fl )
655:                 void dnotequals(void)
656:                 {
657:                 	dcell d1, d2;
658:                 	DPOP(d2); DPOP(d1);
9D000A44  8F828014   LW V0, -32748(GP)
9D000A48  8C440000   LW A0, 0(V0)
9D000A4C  2443FFFC   ADDIU V1, V0, -4
9D000A50  AF838014   SW V1, -32748(GP)
9D000A54  8C43FFFC   LW V1, -4(V0)
9D000A58  00803021   ADDU A2, A0, ZERO
9D000A5C  2444FFF8   ADDIU A0, V0, -8
9D000A60  AF848014   SW A0, -32748(GP)
9D000A64  8C45FFF8   LW A1, -8(V0)
9D000A68  2444FFF4   ADDIU A0, V0, -12
9D000A6C  AF848014   SW A0, -32748(GP)
9D000A70  8C44FFF4   LW A0, -12(V0)
9D000A74  00A03821   ADDU A3, A1, ZERO
9D000A78  2445FFF0   ADDIU A1, V0, -16
659:                 	TOS=(d1!=d2) ? -1:0;
9D000A7C  14830003   BNE A0, V1, 0x9D000A8C
9D000A80  AF858014   SW A1, -32748(GP)
9D000A84  10E60002   BEQ A3, A2, 0x9D000A90
9D000A88  00001821   ADDU V1, ZERO, ZERO
9D000A8C  2403FFFF   ADDIU V1, ZERO, -1
660:                 }
9D000A90  03E00008   JR RA
9D000A94  AC43FFF0   SW V1, -16(V0)
661:                 
662:                 
663:                 // d> ( d1 d2 -- fl )
664:                 void dgreater(void)
665:                 {
666:                 	dcell d1, d2;
667:                 	DPOP(d2); DPOP(d1);
9D000A98  8F828014   LW V0, -32748(GP)
9D000A9C  8C430000   LW V1, 0(V0)
9D000AA0  2444FFFC   ADDIU A0, V0, -4
9D000AA4  AF848014   SW A0, -32748(GP)
9D000AA8  8C48FFFC   LW T0, -4(V0)
9D000AAC  00603021   ADDU A2, V1, ZERO
9D000AB0  2444FFF8   ADDIU A0, V0, -8
9D000AB4  AF848014   SW A0, -32748(GP)
9D000AB8  8C44FFF8   LW A0, -8(V0)
9D000ABC  2445FFF4   ADDIU A1, V0, -12
9D000AC0  AF858014   SW A1, -32748(GP)
9D000AC4  8C49FFF4   LW T1, -12(V0)
9D000AC8  2445FFF0   ADDIU A1, V0, -16
668:                 	TOS=(d1>d2) ? -1:0;
9D000ACC  0064182A   SLT V1, V1, A0
9D000AD0  14600006   BNE V1, ZERO, 0x9D000AEC
9D000AD4  AF858014   SW A1, -32748(GP)
9D000AD8  14860005   BNE A0, A2, 0x9D000AF0
9D000ADC  00001821   ADDU V1, ZERO, ZERO
9D000AE0  0109402B   SLTU T0, T0, T1
9D000AE4  51000004   BEQL T0, ZERO, 0x9D000AF8
9D000AE8  AC43FFF0   SW V1, -16(V0)
9D000AEC  2403FFFF   ADDIU V1, ZERO, -1
669:                 }
9D000AF0  03E00008   JR RA
9D000AF4  AC43FFF0   SW V1, -16(V0)
9D000AF8  03E00008   JR RA
9D000AFC  00000000   NOP
670:                 
671:                 
672:                 // d< ( d1 d2 -- fl )
673:                 void dless(void)
674:                 {
675:                 	dcell d1, d2;
676:                 	DPOP(d2); DPOP(d1);
9D000B00  8F828014   LW V0, -32748(GP)
9D000B04  8C440000   LW A0, 0(V0)
9D000B08  2443FFFC   ADDIU V1, V0, -4
9D000B0C  AF838014   SW V1, -32748(GP)
9D000B10  8C49FFFC   LW T1, -4(V0)
9D000B14  2443FFF8   ADDIU V1, V0, -8
9D000B18  AF838014   SW V1, -32748(GP)
9D000B1C  8C43FFF8   LW V1, -8(V0)
9D000B20  2445FFF4   ADDIU A1, V0, -12
9D000B24  AF858014   SW A1, -32748(GP)
9D000B28  8C48FFF4   LW T0, -12(V0)
9D000B2C  00603021   ADDU A2, V1, ZERO
9D000B30  2445FFF0   ADDIU A1, V0, -16
677:                 	TOS=(d1<d2) ? -1:0;
9D000B34  0064182A   SLT V1, V1, A0
9D000B38  14600006   BNE V1, ZERO, 0x9D000B54
9D000B3C  AF858014   SW A1, -32748(GP)
9D000B40  14860005   BNE A0, A2, 0x9D000B58
9D000B44  00001821   ADDU V1, ZERO, ZERO
9D000B48  0109402B   SLTU T0, T0, T1
9D000B4C  51000004   BEQL T0, ZERO, 0x9D000B60
9D000B50  AC43FFF0   SW V1, -16(V0)
9D000B54  2403FFFF   ADDIU V1, ZERO, -1
678:                 }
9D000B58  03E00008   JR RA
9D000B5C  AC43FFF0   SW V1, -16(V0)
9D000B60  03E00008   JR RA
9D000B64  00000000   NOP
679:                 
680:                 
681:                 // within ( u min max -- fl )
682:                 void within(void)  // min <= u <max
683:                 {
684:                 	ucell u2=POP, u1=POP, u=TOS;
9D000B68  8F828014   LW V0, -32748(GP)
9D000B6C  8C450000   LW A1, 0(V0)
9D000B70  2443FFFC   ADDIU V1, V0, -4
9D000B74  AF838014   SW V1, -32748(GP)
9D000B78  8C43FFFC   LW V1, -4(V0)
9D000B7C  2444FFF8   ADDIU A0, V0, -8
9D000B80  AF848014   SW A0, -32748(GP)
685:                 	TOS=((u-u1)<(u2-u1)) ? -1:0;
9D000B84  8C44FFF8   LW A0, -8(V0)
9D000B88  00832023   SUBU A0, A0, V1
9D000B8C  00A31823   SUBU V1, A1, V1
9D000B90  0083182B   SLTU V1, A0, V1
9D000B94  2404FFFF   ADDIU A0, ZERO, -1
9D000B98  0003200A   MOVZ A0, ZERO, V1
686:                 }
9D000B9C  03E00008   JR RA
9D000BA0  AC44FFF8   SW A0, -8(V0)
687:                 
688:                 
689:                 // ********** HIGH FORTH **********
690:                 
691:                 // ********** VARIABLE **********
692:                 
693:                 
694:                 // tib ( -- addr )
695:                 void tib(void) {PUSH((ucell)vTib);}
9D000BA4  8F828014   LW V0, -32748(GP)
9D000BA8  24430004   ADDIU V1, V0, 4
9D000BAC  AF838014   SW V1, -32748(GP)
9D000BB0  8F83807C   LW V1, -32644(GP)
9D000BB4  03E00008   JR RA
9D000BB8  AC430004   SW V1, 4(V0)
696:                 
697:                 
698:                 // #tib ( -- addr )
699:                 void sharptib(void) {PUSH((ucell)&vSharpTib);}
9D000BBC  8F828014   LW V0, -32748(GP)
9D000BC0  24430004   ADDIU V1, V0, 4
9D000BC4  AF838014   SW V1, -32748(GP)
9D000BC8  2783808D   ADDIU V1, GP, -32627
9D000BCC  03E00008   JR RA
9D000BD0  AC430004   SW V1, 4(V0)
700:                 
701:                 
702:                 // >in ( -- addr )
703:                 void gin(void) {PUSH((ucell)&vIN);}
9D000BD4  8F828014   LW V0, -32748(GP)
9D000BD8  24430004   ADDIU V1, V0, 4
9D000BDC  AF838014   SW V1, -32748(GP)
9D000BE0  2783808C   ADDIU V1, GP, -32628
9D000BE4  03E00008   JR RA
9D000BE8  AC430004   SW V1, 4(V0)
704:                 
705:                 
706:                 // base ( -- addr )
707:                 void base(void)
708:                 {PUSH((ucell)&vBase); vBase=(vBase<2) ? 2:vBase; vBase=(vBase>32) ? 32:vBase;}
9D000BEC  8F828014   LW V0, -32748(GP)
9D000BF0  24430004   ADDIU V1, V0, 4
9D000BF4  AF838014   SW V1, -32748(GP)
9D000BF8  27838020   ADDIU V1, GP, -32736
9D000BFC  AC430004   SW V1, 4(V0)
9D000C00  93828020   LBU V0, -32736(GP)
9D000C04  304300FF   ANDI V1, V0, 255
9D000C08  2C630002   SLTIU V1, V1, 2
9D000C0C  54600001   BNEL V1, ZERO, 0x9D000C14
9D000C10  24020002   ADDIU V0, ZERO, 2
9D000C14  00401821   ADDU V1, V0, ZERO
9D000C18  304200FF   ANDI V0, V0, 255
9D000C1C  2C420021   SLTIU V0, V0, 33
9D000C20  50400001   BEQL V0, ZERO, 0x9D000C28
9D000C24  24030020   ADDIU V1, ZERO, 32
9D000C28  03E00008   JR RA
9D000C2C  A3838020   SB V1, -32736(GP)
709:                 
710:                 
711:                 // state ( -- addr )
712:                 void state(void) {PUSH((ucell)&vState);}
9D000C30  8F828014   LW V0, -32748(GP)
9D000C34  24430004   ADDIU V1, V0, 4
9D000C38  AF838014   SW V1, -32748(GP)
9D000C3C  2783808E   ADDIU V1, GP, -32626
9D000C40  03E00008   JR RA
9D000C44  AC430004   SW V1, 4(V0)
713:                 
714:                 
715:                 // pad ( -- addr )
716:                 void pad(void) {PUSH((ucell)vPad);}
9D000C48  8F828014   LW V0, -32748(GP)
9D000C4C  24430004   ADDIU V1, V0, 4
9D000C50  AF838014   SW V1, -32748(GP)
9D000C54  8F838080   LW V1, -32640(GP)
9D000C58  03E00008   JR RA
9D000C5C  AC430004   SW V1, 4(V0)
717:                 
718:                 
719:                 // current ( -- addr )
720:                 void current(void) {PUSH((ucell)&vCurrent);}
9D00372C  8F828014   LW V0, -32748(GP)
9D003730  24430004   ADDIU V1, V0, 4
9D003734  AF838014   SW V1, -32748(GP)
9D003738  27838100   ADDIU V1, GP, -32512
9D00373C  03E00008   JR RA
9D003740  AC430004   SW V1, 4(V0)
721:                 
722:                 
723:                 // context ( -- addr )
724:                 void context(void) {PUSH((ucell)&vContext);}
9D003744  8F828014   LW V0, -32748(GP)
9D003748  24430004   ADDIU V1, V0, 4
9D00374C  AF838014   SW V1, -32748(GP)
9D003750  27838108   ADDIU V1, GP, -32504
9D003754  03E00008   JR RA
9D003758  AC430004   SW V1, 4(V0)
725:                 
726:                 
727:                 // bl ( -- n )
728:                 void blf(void) {PUSH(Spc);}
9D000C60  8F828014   LW V0, -32748(GP)
9D000C64  24430004   ADDIU V1, V0, 4
9D000C68  AF838014   SW V1, -32748(GP)
9D000C6C  24030020   ADDIU V1, ZERO, 32
9D000C70  03E00008   JR RA
9D000C74  AC430004   SW V1, 4(V0)
729:                 
730:                 
731:                 // ********** CTRLFLOW **********
732:                 
733:                 
734:                 // <mark ( -- addr )
735:                 void lmark(void) {here(); TOS-=cellsize;}
9D000C78  27BDFFE8   ADDIU SP, SP, -24
9D000C7C  AFBF0014   SW RA, 20(SP)
9D000C80  0F4000FA   JAL here
9D000C84  00000000   NOP
9D000C88  8F828014   LW V0, -32748(GP)
9D000C8C  8C430000   LW V1, 0(V0)
9D000C90  2463FFFC   ADDIU V1, V1, -4
9D000C94  AC430000   SW V1, 0(V0)
9D000C98  8FBF0014   LW RA, 20(SP)
9D000C9C  03E00008   JR RA
9D000CA0  27BD0018   ADDIU SP, SP, 24
736:                 
737:                 
738:                 // <resolve ( addr -- )
739:                 void lresolve(void) {comma();}
9D0020AC  27BDFFE8   ADDIU SP, SP, -24
9D0020B0  AFBF0014   SW RA, 20(SP)
9D0020B4  0F4007C2   JAL comma
9D0020B8  00000000   NOP
9D0020BC  8FBF0014   LW RA, 20(SP)
9D0020C0  03E00008   JR RA
9D0020C4  27BD0018   ADDIU SP, SP, 24
740:                 
741:                 
742:                 // >mark ( -- addr )
743:                 void gmark(void) {here(); vHere+=cellsize;}
9D000CA4  27BDFFE8   ADDIU SP, SP, -24
9D000CA8  AFBF0014   SW RA, 20(SP)
9D000CAC  0F4000FA   JAL here
9D000CB0  00000000   NOP
9D000CB4  8F8280FC   LW V0, -32516(GP)
9D000CB8  24420004   ADDIU V0, V0, 4
9D000CBC  AF8280FC   SW V0, -32516(GP)
9D000CC0  8FBF0014   LW RA, 20(SP)
9D000CC4  03E00008   JR RA
9D000CC8  27BD0018   ADDIU SP, SP, 24
744:                 
745:                 
746:                 // >resolve ( addr -- )
747:                 void gresolve(void) {here(); TOS-=cellsize; swap(); store();}
9D000CCC  27BDFFE8   ADDIU SP, SP, -24
9D000CD0  AFBF0014   SW RA, 20(SP)
9D000CD4  0F4000FA   JAL here
9D000CD8  00000000   NOP
9D000CDC  8F828014   LW V0, -32748(GP)
9D000CE0  8C430000   LW V1, 0(V0)
9D000CE4  2463FFFC   ADDIU V1, V1, -4
9D000CE8  0F400055   JAL swap
9D000CEC  AC430000   SW V1, 0(V0)
9D000CF0  0F4000D4   JAL store
9D000CF4  00000000   NOP
9D000CF8  8FBF0014   LW RA, 20(SP)
9D000CFC  03E00008   JR RA
9D000D00  27BD0018   ADDIU SP, SP, 24
748:                 
749:                 
750:                 // do ( -- addr )
751:                 void dof(void) {CompileCxt(iDODO); gmark(); lmark();}
9D003298  27BDFFE8   ADDIU SP, SP, -24
9D00329C  AFBF0014   SW RA, 20(SP)
9D0032A0  0F400AF9   JAL CompileCxt
9D0032A4  2404000A   ADDIU A0, ZERO, 10
9D0032A8  0F400329   JAL gmark
9D0032AC  00000000   NOP
9D0032B0  0F40031E   JAL lmark
9D0032B4  00000000   NOP
9D0032B8  8FBF0014   LW RA, 20(SP)
9D0032BC  03E00008   JR RA
9D0032C0  27BD0018   ADDIU SP, SP, 24
752:                 
753:                 
754:                 // ?do ( -- addr )
755:                 void isdof(void) {CompileCxt(iISDO); gmark(); lmark();}
9D00326C  27BDFFE8   ADDIU SP, SP, -24
9D003270  AFBF0014   SW RA, 20(SP)
9D003274  0F400AF9   JAL CompileCxt
9D003278  2404000B   ADDIU A0, ZERO, 11
9D00327C  0F400329   JAL gmark
9D003280  00000000   NOP
9D003284  0F40031E   JAL lmark
9D003288  00000000   NOP
9D00328C  8FBF0014   LW RA, 20(SP)
9D003290  03E00008   JR RA
9D003294  27BD0018   ADDIU SP, SP, 24
756:                 
757:                 
758:                 // loop ( addr -- )
759:                 void loop(void) {CompileCxt(iLOOP); lresolve(); gresolve();}
9D003240  27BDFFE8   ADDIU SP, SP, -24
9D003244  AFBF0014   SW RA, 20(SP)
9D003248  0F400AF9   JAL CompileCxt
9D00324C  2404000C   ADDIU A0, ZERO, 12
9D003250  0F40082B   JAL lresolve
9D003254  00000000   NOP
9D003258  0F400333   JAL gresolve
9D00325C  00000000   NOP
9D003260  8FBF0014   LW RA, 20(SP)
9D003264  03E00008   JR RA
9D003268  27BD0018   ADDIU SP, SP, 24
760:                 
761:                 
762:                 // +loop ( addr -- )
763:                 void plusloop(void) {CompileCxt(iPLOOP); lresolve(); gresolve();}
9D003214  27BDFFE8   ADDIU SP, SP, -24
9D003218  AFBF0014   SW RA, 20(SP)
9D00321C  0F400AF9   JAL CompileCxt
9D003220  2404000D   ADDIU A0, ZERO, 13
9D003224  0F40082B   JAL lresolve
9D003228  00000000   NOP
9D00322C  0F400333   JAL gresolve
9D003230  00000000   NOP
9D003234  8FBF0014   LW RA, 20(SP)
9D003238  03E00008   JR RA
9D00323C  27BD0018   ADDIU SP, SP, 24
764:                 
765:                 
766:                 // if ( -- addr )
767:                 void iff(void) {CompileCxt(iDOCBR); gmark();}
9D0031F0  27BDFFE8   ADDIU SP, SP, -24
9D0031F4  AFBF0014   SW RA, 20(SP)
9D0031F8  0F400AF9   JAL CompileCxt
9D0031FC  2404000F   ADDIU A0, ZERO, 15
9D003200  0F400329   JAL gmark
9D003204  00000000   NOP
9D003208  8FBF0014   LW RA, 20(SP)
9D00320C  03E00008   JR RA
9D003210  27BD0018   ADDIU SP, SP, 24
768:                 
769:                 
770:                 // then ( addr -- )
771:                 void thenf(void) {gresolve();}
9D000D04  27BDFFE8   ADDIU SP, SP, -24
9D000D08  AFBF0014   SW RA, 20(SP)
9D000D0C  0F400333   JAL gresolve
9D000D10  00000000   NOP
9D000D14  8FBF0014   LW RA, 20(SP)
9D000D18  03E00008   JR RA
9D000D1C  27BD0018   ADDIU SP, SP, 24
772:                 
773:                 
774:                 // else ( addr1 -- addr2 )
775:                 void elsef(void) {CompileCxt(iDOBR); gmark(); swap(); gresolve();}
9D0031BC  27BDFFE8   ADDIU SP, SP, -24
9D0031C0  AFBF0014   SW RA, 20(SP)
9D0031C4  0F400AF9   JAL CompileCxt
9D0031C8  2404000E   ADDIU A0, ZERO, 14
9D0031CC  0F400329   JAL gmark
9D0031D0  00000000   NOP
9D0031D4  0F400055   JAL swap
9D0031D8  00000000   NOP
9D0031DC  0F400333   JAL gresolve
9D0031E0  00000000   NOP
9D0031E4  8FBF0014   LW RA, 20(SP)
9D0031E8  03E00008   JR RA
9D0031EC  27BD0018   ADDIU SP, SP, 24
776:                 
777:                 
778:                 // begin ( -- addr )
779:                 void beginf(void) {lmark();}
9D000D20  27BDFFE8   ADDIU SP, SP, -24
9D000D24  AFBF0014   SW RA, 20(SP)
9D000D28  0F40031E   JAL lmark
9D000D2C  00000000   NOP
9D000D30  8FBF0014   LW RA, 20(SP)
9D000D34  03E00008   JR RA
9D000D38  27BD0018   ADDIU SP, SP, 24
780:                 
781:                 
782:                 // while ( dest -- orig dest )
783:                 void whilef(void) {CompileCxt(iDOCBR); gmark(); swap();}
9D003190  27BDFFE8   ADDIU SP, SP, -24
9D003194  AFBF0014   SW RA, 20(SP)
9D003198  0F400AF9   JAL CompileCxt
9D00319C  2404000F   ADDIU A0, ZERO, 15
9D0031A0  0F400329   JAL gmark
9D0031A4  00000000   NOP
9D0031A8  0F400055   JAL swap
9D0031AC  00000000   NOP
9D0031B0  8FBF0014   LW RA, 20(SP)
9D0031B4  03E00008   JR RA
9D0031B8  27BD0018   ADDIU SP, SP, 24
784:                 
785:                 
786:                 // until ( addr -- )
787:                 void untilf(void) {CompileCxt(iDOCBR); lresolve();}
9D00316C  27BDFFE8   ADDIU SP, SP, -24
9D003170  AFBF0014   SW RA, 20(SP)
9D003174  0F400AF9   JAL CompileCxt
9D003178  2404000F   ADDIU A0, ZERO, 15
9D00317C  0F40082B   JAL lresolve
9D003180  00000000   NOP
9D003184  8FBF0014   LW RA, 20(SP)
9D003188  03E00008   JR RA
9D00318C  27BD0018   ADDIU SP, SP, 24
788:                 
789:                 
790:                 // repeat ( addr1 -- addr2 )
791:                 void repeatf(void) {CompileCxt(iDOBR); lresolve(); gresolve();}
9D003140  27BDFFE8   ADDIU SP, SP, -24
9D003144  AFBF0014   SW RA, 20(SP)
9D003148  0F400AF9   JAL CompileCxt
9D00314C  2404000E   ADDIU A0, ZERO, 14
9D003150  0F40082B   JAL lresolve
9D003154  00000000   NOP
9D003158  0F400333   JAL gresolve
9D00315C  00000000   NOP
9D003160  8FBF0014   LW RA, 20(SP)
9D003164  03E00008   JR RA
9D003168  27BD0018   ADDIU SP, SP, 24
792:                 
793:                 
794:                 // again ( addr -- )
795:                 void againf(void) {CompileCxt(iDOBR); lresolve();}
9D00311C  27BDFFE8   ADDIU SP, SP, -24
9D003120  AFBF0014   SW RA, 20(SP)
9D003124  0F400AF9   JAL CompileCxt
9D003128  2404000E   ADDIU A0, ZERO, 14
9D00312C  0F40082B   JAL lresolve
9D003130  00000000   NOP
9D003134  8FBF0014   LW RA, 20(SP)
9D003138  03E00008   JR RA
9D00313C  27BD0018   ADDIU SP, SP, 24
796:                 
797:                 
798:                 // leave ( -- )
799:                 void leavef(void) {pRS-=2; EXIT}
9D000D3C  8F82801C   LW V0, -32740(GP)
9D000D40  2443FFF8   ADDIU V1, V0, -8
9D000D44  AF83801C   SW V1, -32740(GP)
9D000D48  8C43FFF8   LW V1, -8(V0)
9D000D4C  AF8380E8   SW V1, -32536(GP)
9D000D50  2442FFF4   ADDIU V0, V0, -12
9D000D54  03E00008   JR RA
9D000D58  AF82801C   SW V0, -32740(GP)
800:                 
801:                 
802:                 // unloop ( -- )
803:                 void unloopf(void) {pRS-=3;}
9D000D5C  8F82801C   LW V0, -32740(GP)
9D000D60  2442FFF4   ADDIU V0, V0, -12
9D000D64  03E00008   JR RA
9D000D68  AF82801C   SW V0, -32740(GP)
804:                 
805:                 
806:                 // recurse ( -- )
807:                 void recursef(void) {linkg(); comma();}
9D002088  27BDFFE8   ADDIU SP, SP, -24
9D00208C  AFBF0014   SW RA, 20(SP)
9D002090  0F40061E   JAL linkg
9D002094  00000000   NOP
9D002098  0F4007C2   JAL comma
9D00209C  00000000   NOP
9D0020A0  8FBF0014   LW RA, 20(SP)
9D0020A4  03E00008   JR RA
9D0020A8  27BD0018   ADDIU SP, SP, 24
808:                 
809:                 
810:                 // case ( -- 0 )
811:                 void casef(void) {PUSH(0);}
9D000D6C  8F828014   LW V0, -32748(GP)
9D000D70  24430004   ADDIU V1, V0, 4
9D000D74  AF838014   SW V1, -32748(GP)
9D000D78  03E00008   JR RA
9D000D7C  AC400004   SW ZERO, 4(V0)
812:                 
813:                 const void *xt_over=over;
814:                 const void *xt_equal=equals;
815:                 const void *xt_drop=drop;
816:                 const void *xt_if=iff;
817:                 const void *xt_then=thenf;
818:                 const void *xt_else=elsef;
819:                 
820:                 
821:                 // of ( #of -- orig #of+1 / x -- )
822:                 void caseof(void)
823:                 {
9D0036CC  27BDFFE8   ADDIU SP, SP, -24
9D0036D0  AFBF0014   SW RA, 20(SP)
824:                 	TOS++; tor();
9D0036D4  8F828014   LW V0, -32748(GP)
9D0036D8  8C430000   LW V1, 0(V0)
9D0036DC  24630001   ADDIU V1, V1, 1
9D0036E0  0F400069   JAL tor
9D0036E4  AC430000   SW V1, 0(V0)
825:                 	CompileCcon(&xt_over);
9D0036E8  0F400D36   JAL CompileCcon
9D0036EC  27848024   ADDIU A0, GP, -32732
826:                 	CompileCcon(&xt_equal);
9D0036F0  0F400D36   JAL CompileCcon
9D0036F4  27848028   ADDIU A0, GP, -32728
827:                 	PUSH((ucell)&xt_if); executew();
9D0036F8  8F828014   LW V0, -32748(GP)
9D0036FC  24430004   ADDIU V1, V0, 4
9D003700  AF838014   SW V1, -32748(GP)
9D003704  27838030   ADDIU V1, GP, -32720
9D003708  0F402C59   JAL executew
9D00370C  AC430004   SW V1, 4(V0)
828:                 	CompileCcon(&xt_drop);
9D003710  0F400D36   JAL CompileCcon
9D003714  2784802C   ADDIU A0, GP, -32724
829:                 	rfrom();
9D003718  0F400072   JAL rfrom
9D00371C  00000000   NOP
830:                 }
9D003720  8FBF0014   LW RA, 20(SP)
9D003724  03E00008   JR RA
9D003728  27BD0018   ADDIU SP, SP, 24
831:                 
832:                 
833:                 // endof ( orig1 #of -- orig2 #of )
834:                 void endof(void)
835:                 {
9D001B64  27BDFFE8   ADDIU SP, SP, -24
9D001B68  AFBF0014   SW RA, 20(SP)
836:                 	tor(); PUSH((ucell)&xt_else); executew(); rfrom();
9D001B6C  0F400069   JAL tor
9D001B70  00000000   NOP
9D001B74  8F828014   LW V0, -32748(GP)
9D001B78  24430004   ADDIU V1, V0, 4
9D001B7C  AF838014   SW V1, -32748(GP)
9D001B80  27838038   ADDIU V1, GP, -32712
9D001B84  0F402C59   JAL executew
9D001B88  AC430004   SW V1, 4(V0)
9D001B8C  0F400072   JAL rfrom
9D001B90  00000000   NOP
837:                 }
9D001B94  8FBF0014   LW RA, 20(SP)
9D001B98  03E00008   JR RA
9D001B9C  27BD0018   ADDIU SP, SP, 24
838:                 
839:                 
840:                 // endcase ( orig 1..orign #of -- )
841:                 void endcase(void)
842:                 {
9D00365C  27BDFFE0   ADDIU SP, SP, -32
9D003660  AFBF001C   SW RA, 28(SP)
9D003664  AFB20018   SW S2, 24(SP)
9D003668  AFB10014   SW S1, 20(SP)
9D00366C  AFB00010   SW S0, 16(SP)
843:                 	ucell i, u=POP;
9D003670  8F828014   LW V0, -32748(GP)
9D003674  8C510000   LW S1, 0(V0)
9D003678  2442FFFC   ADDIU V0, V0, -4
9D00367C  AF828014   SW V0, -32748(GP)
844:                 	CompileCcon(&xt_drop);
9D003680  0F400D36   JAL CompileCcon
9D003684  2784802C   ADDIU A0, GP, -32724
845:                 	if (u>0) {for (i=0; i<u; i++) {PUSH((ucell)&xt_then); executew();}}
9D003688  1220000A   BEQ S1, ZERO, 0x9D0036B4
9D00368C  00008021   ADDU S0, ZERO, ZERO
9D003690  27928034   ADDIU S2, GP, -32716
9D003694  8F828014   LW V0, -32748(GP)
9D003698  24430004   ADDIU V1, V0, 4
9D00369C  AF838014   SW V1, -32748(GP)
9D0036A0  0F402C59   JAL executew
9D0036A4  AC520004   SW S2, 4(V0)
9D0036A8  26100001   ADDIU S0, S0, 1
9D0036AC  1630FFFA   BNE S1, S0, 0x9D003698
9D0036B0  8F828014   LW V0, -32748(GP)
846:                 }
9D0036B4  8FBF001C   LW RA, 28(SP)
9D0036B8  8FB20018   LW S2, 24(SP)
9D0036BC  8FB10014   LW S1, 20(SP)
9D0036C0  8FB00010   LW S0, 16(SP)
9D0036C4  03E00008   JR RA
9D0036C8  27BD0020   ADDIU SP, SP, 32
847:                 
848:                 
849:                 // abort ( -- )
850:                 void abortf(void) {pDS=pDSzero; pRS=pRSzero; vIN=0; vSharpTib=0; vState=0;}
9D000D80  8F828010   LW V0, -32752(GP)
9D000D84  AF828014   SW V0, -32748(GP)
9D000D88  8F828018   LW V0, -32744(GP)
9D000D8C  AF82801C   SW V0, -32740(GP)
9D000D90  A380808C   SB ZERO, -32628(GP)
9D000D94  A380808D   SB ZERO, -32627(GP)
9D000D98  03E00008   JR RA
9D000D9C  A380808E   SB ZERO, -32626(GP)
851:                 const void *xt_abort=abortf;
852:                 
853:                 
854:                 // abort" ( x -- )
855:                 void aborts(void) {iff(); dotstring(); CompileCcon(&xt_abort); thenf();}
9D003628  27BDFFE8   ADDIU SP, SP, -24
9D00362C  AFBF0014   SW RA, 20(SP)
9D003630  0F400C7C   JAL iff
9D003634  00000000   NOP
9D003638  0F400D40   JAL dotstring
9D00363C  00000000   NOP
9D003640  0F400D36   JAL CompileCcon
9D003644  2784803C   ADDIU A0, GP, -32708
9D003648  0F400341   JAL thenf
9D00364C  00000000   NOP
9D003650  8FBF0014   LW RA, 20(SP)
9D003654  03E00008   JR RA
9D003658  27BD0018   ADDIU SP, SP, 24
856:                 
857:                 
858:                 // bye ( -- )
859:                 void bye(void) {
9D001C70  27BDFFE8   ADDIU SP, SP, -24
9D001C74  AFBF0014   SW RA, 20(SP)
860:                 #ifdef VPC_32
861:                     free(vPad);
9D001C78  0F403FAA   JAL free
9D001C7C  8F848080   LW A0, -32640(GP)
862:                     free(vTib);
9D001C80  0F403FAA   JAL free
9D001C84  8F84807C   LW A0, -32644(GP)
863:                     free(vDict);
9D001C88  0F403FAA   JAL free
9D001C8C  8F848084   LW A0, -32636(GP)
864:                     free(vMem);
9D001C90  0F403FAA   JAL free
9D001C94  8F848088   LW A0, -32632(GP)
865:                 #endif
866:                     vState=EndState;
9D001C98  2402FFEE   ADDIU V0, ZERO, -18
9D001C9C  A382808E   SB V0, -32626(GP)
867:                 
868:                 }
9D001CA0  8FBF0014   LW RA, 20(SP)
9D001CA4  03E00008   JR RA
9D001CA8  27BD0018   ADDIU SP, SP, 24
869:                 
870:                 
871:                 // ********** Interpreter **********
872:                 
873:                 
874:                 // [ ( -- )
875:                 void lbracket(void) {vState=0;}  // Interprete
9D0013A8  03E00008   JR RA
9D0013AC  A380808E   SB ZERO, -32626(GP)
876:                 
877:                 
878:                 // ] ( -- )
879:                 void rbracket(void) {vState=1;}  // Compile
9D0013B0  24020001   ADDIU V0, ZERO, 1
9D0013B4  03E00008   JR RA
9D0013B8  A382808E   SB V0, -32626(GP)
880:                 
881:                 
882:                 // bin ( -- )
883:                 void binf(void) {vBase=2;}
9D0013BC  24020002   ADDIU V0, ZERO, 2
9D0013C0  03E00008   JR RA
9D0013C4  A3828020   SB V0, -32736(GP)
884:                 
885:                 
886:                 // decimal ( -- )
887:                 void decimal(void) {vBase=10;}
9D0013C8  2402000A   ADDIU V0, ZERO, 10
9D0013CC  03E00008   JR RA
9D0013D0  A3828020   SB V0, -32736(GP)
888:                 
889:                 
890:                 // hex ( -- )
891:                 void hexf(void) {vBase=16;}
9D0013D4  24020010   ADDIU V0, ZERO, 16
9D0013D8  03E00008   JR RA
9D0013DC  A3828020   SB V0, -32736(GP)
892:                 
893:                 
894:                 cell  KeyBak=0;
895:                 
896:                 // accept ( addr n1 -- n2 )
897:                 void accept(void)  // read until A,D,AD,DA
898:                 {
9D0028AC  27BDFFC8   ADDIU SP, SP, -56
9D0028B0  AFBF0034   SW RA, 52(SP)
9D0028B4  AFBE0030   SW S8, 48(SP)
9D0028B8  AFB7002C   SW S7, 44(SP)
9D0028BC  AFB60028   SW S6, 40(SP)
9D0028C0  AFB50024   SW S5, 36(SP)
9D0028C4  AFB40020   SW S4, 32(SP)
9D0028C8  AFB3001C   SW S3, 28(SP)
9D0028CC  AFB20018   SW S2, 24(SP)
9D0028D0  AFB10014   SW S1, 20(SP)
9D0028D4  AFB00010   SW S0, 16(SP)
899:                 	char fRun=1, k, *pTib, maxnum, num=0;
9D0028F4  00008821   ADDU S1, ZERO, ZERO
9D0028F8  24160001   ADDIU S6, ZERO, 1
900:                 	
901:                 	maxnum=POP; pTib=(char *)POP;
9D0028D8  8F828014   LW V0, -32748(GP)
9D0028DC  80520000   LB S2, 0(V0)
9D0028E0  2443FFFC   ADDIU V1, V0, -4
9D0028E4  AF838014   SW V1, -32748(GP)
9D0028E8  8C57FFFC   LW S7, -4(V0)
9D0028EC  2442FFF8   ADDIU V0, V0, -8
9D0028F0  AF828014   SW V0, -32748(GP)
902:                 	while (fRun)
9D002A08  16C0FFC0   BNE S6, ZERO, 0x9D00290C
9D002A0C  00000000   NOP
903:                 	{
904:                 	  key(); k=POP;
9D00290C  0F4008A6   JAL key
9D002910  00000000   NOP
9D002914  8F828014   LW V0, -32748(GP)
9D002918  80500000   LB S0, 0(V0)
9D00291C  2442FFFC   ADDIU V0, V0, -4
905:                 	  if ((k==BackSpc)&&(num>0))  {num--; *--pTib=Spc; PUSH(k); emit();PUSH(Spc); emit();PUSH(k); emit();}
9D0028FC  24140008   ADDIU S4, ZERO, 8
9D002908  241E0020   ADDIU S8, ZERO, 32
9D002920  16140019   BNE S0, S4, 0x9D002988
9D002924  AF828014   SW V0, -32748(GP)
9D002928  1A200018   BLEZ S1, 0x9D00298C
9D00292C  2A020020   SLTI V0, S0, 32
9D002930  2631FFFF   ADDIU S1, S1, -1
9D002934  7C118C20   SEB S1, S1
9D002938  26F7FFFF   ADDIU S7, S7, -1
9D00293C  A2FE0000   SB S8, 0(S7)
9D002940  8F828014   LW V0, -32748(GP)
9D002944  24430004   ADDIU V1, V0, 4
9D002948  AF838014   SW V1, -32748(GP)
9D00294C  0F4008B3   JAL emit
9D002950  AC540004   SW S4, 4(V0)
9D002954  8F828014   LW V0, -32748(GP)
9D002958  24430004   ADDIU V1, V0, 4
9D00295C  AF838014   SW V1, -32748(GP)
9D002960  24030020   ADDIU V1, ZERO, 32
9D002964  0F4008B3   JAL emit
9D002968  AC430004   SW V1, 4(V0)
9D00296C  8F828014   LW V0, -32748(GP)
9D002970  24430004   ADDIU V1, V0, 4
9D002974  AF838014   SW V1, -32748(GP)
9D002978  0F4008B3   JAL emit
9D00297C  AC540004   SW S4, 4(V0)
9D002980  0B400A78   J 0x9D0029E0
9D002984  00000000   NOP
906:                 	  if ((k>=Spc)&&(num<maxnum)) {num++; *pTib++=k; PUSH(k); emit();}
9D002988  2A020020   SLTI V0, S0, 32
9D00298C  1440000C   BNE V0, ZERO, 0x9D0029C0
9D002990  0232102A   SLT V0, S1, S2
9D002994  1040000A   BEQ V0, ZERO, 0x9D0029C0
9D002998  00000000   NOP
9D00299C  26310001   ADDIU S1, S1, 1
9D0029A0  7C118C20   SEB S1, S1
9D0029A4  A2F00000   SB S0, 0(S7)
9D0029A8  26F70001   ADDIU S7, S7, 1
9D0029AC  8F828014   LW V0, -32748(GP)
9D0029B0  24430004   ADDIU V1, V0, 4
9D0029B4  AF838014   SW V1, -32748(GP)
9D0029B8  0F4008B3   JAL emit
9D0029BC  AC500004   SW S0, 4(V0)
907:                 	  if ((k==CRA)&&(KeyBak==CRD)) {k=0;}
9D0029C0  16130007   BNE S0, S3, 0x9D0029E0
9D0029C4  8F828094   LW V0, -32620(GP)
9D0029C8  00551026   XOR V0, V0, S5
9D0029CC  0002800A   MOVZ S0, ZERO, V0
908:                 	  if ((k==CRD)&&(KeyBak==CRA)) {k=0;}
9D002900  2415000D   ADDIU S5, ZERO, 13
9D002904  2413000A   ADDIU S3, ZERO, 10
9D0029E0  16150007   BNE S0, S5, 0x9D002A00
9D0029E4  0232102A   SLT V0, S1, S2
9D0029E8  8F828094   LW V0, -32620(GP)
9D0029EC  50530003   BEQL V0, S3, 0x9D0029FC
9D0029F0  00008021   ADDU S0, ZERO, ZERO
909:                 	  if ((k==CRD)||(k==CRA)) {fRun=0; crf();}
9D0029D0  12130008   BEQ S0, S3, 0x9D0029F4
9D0029D4  0232102A   SLT V0, S1, S2
9D0029D8  0B400A80   J 0x9D002A00
9D0029DC  00000000   NOP
9D0029F4  0F40095F   JAL crf
9D0029F8  0000B021   ADDU S6, ZERO, ZERO
910:                 	  if (num>=maxnum) {fRun=0;}
9D0029FC  0232102A   SLT V0, S1, S2
9D002A00  10400003   BEQ V0, ZERO, 0x9D002A10
9D002A04  AF908094   SW S0, -32620(GP)
911:                 	  KeyBak=k;
912:                 	}
913:                 	PUSH(num); 
9D002A10  8F828014   LW V0, -32748(GP)
9D002A14  24430004   ADDIU V1, V0, 4
9D002A18  AF838014   SW V1, -32748(GP)
9D002A1C  AC510004   SW S1, 4(V0)
914:                 }
9D002A20  8FBF0034   LW RA, 52(SP)
9D002A24  8FBE0030   LW S8, 48(SP)
9D002A28  8FB7002C   LW S7, 44(SP)
9D002A2C  8FB60028   LW S6, 40(SP)
9D002A30  8FB50024   LW S5, 36(SP)
9D002A34  8FB40020   LW S4, 32(SP)
9D002A38  8FB3001C   LW S3, 28(SP)
9D002A3C  8FB20018   LW S2, 24(SP)
9D002A40  8FB10014   LW S1, 20(SP)
9D002A44  8FB00010   LW S0, 16(SP)
9D002A48  03E00008   JR RA
9D002A4C  27BD0038   ADDIU SP, SP, 56
915:                 
916:                 
917:                 // refill ( -- f )
918:                 void refill(void) {tib(); PUSH(tibsize); accept(); vSharpTib=POP; vIN=0; PUSH(-1);}
9D002A50  27BDFFE8   ADDIU SP, SP, -24
9D002A54  AFBF0014   SW RA, 20(SP)
9D002A58  0F4002E9   JAL tib
9D002A5C  00000000   NOP
9D002A60  8F828014   LW V0, -32748(GP)
9D002A64  24430004   ADDIU V1, V0, 4
9D002A68  AF838014   SW V1, -32748(GP)
9D002A6C  24030050   ADDIU V1, ZERO, 80
9D002A70  0F400A2B   JAL accept
9D002A74  AC430004   SW V1, 4(V0)
9D002A78  8F828014   LW V0, -32748(GP)
9D002A7C  8C430000   LW V1, 0(V0)
9D002A80  A383808D   SB V1, -32627(GP)
9D002A84  A380808C   SB ZERO, -32628(GP)
9D002A88  2403FFFF   ADDIU V1, ZERO, -1
9D002A8C  AC430000   SW V1, 0(V0)
9D002A90  8FBF0014   LW RA, 20(SP)
9D002A94  03E00008   JR RA
9D002A98  27BD0018   ADDIU SP, SP, 24
919:                 
920:                 
921:                 // source ( -- addr u )
922:                 void source(void) {tib(); PUSH(vSharpTib);}
9D0013E0  27BDFFE8   ADDIU SP, SP, -24
9D0013E4  AFBF0014   SW RA, 20(SP)
9D0013E8  0F4002E9   JAL tib
9D0013EC  00000000   NOP
9D0013F0  8F828014   LW V0, -32748(GP)
9D0013F4  24430004   ADDIU V1, V0, 4
9D0013F8  AF838014   SW V1, -32748(GP)
9D0013FC  9383808D   LBU V1, -32627(GP)
9D001400  AC430004   SW V1, 4(V0)
9D001404  8FBF0014   LW RA, 20(SP)
9D001408  03E00008   JR RA
9D00140C  27BD0018   ADDIU SP, SP, 24
923:                 
924:                 
925:                 // count ( addr -- addr+1 u )
926:                 void count(void) {dup(); cfetch(); TOSi(1)++;}
9D001410  27BDFFE8   ADDIU SP, SP, -24
9D001414  AFBF0014   SW RA, 20(SP)
9D001418  0F400010   JAL dup
9D00141C  00000000   NOP
9D001420  0F4000CA   JAL cfetch
9D001424  00000000   NOP
9D001428  8F828014   LW V0, -32748(GP)
9D00142C  8C43FFFC   LW V1, -4(V0)
9D001430  24630001   ADDIU V1, V1, 1
9D001434  AC43FFFC   SW V1, -4(V0)
9D001438  8FBF0014   LW RA, 20(SP)
9D00143C  03E00008   JR RA
9D001440  27BD0018   ADDIU SP, SP, 24
927:                 
928:                 
929:                 // word ( c -- addr )
930:                 void wordf(void)
931:                 {
932:                 	BYTE c=POP, i=1;
9D001444  8F828014   LW V0, -32748(GP)
9D001448  8C470000   LW A3, 0(V0)
9D00144C  2442FFFC   ADDIU V0, V0, -4
9D001450  AF828014   SW V0, -32748(GP)
933:                 
934:                 	if (vSharpTib)
9D001454  9386808D   LBU A2, -32627(GP)
9D001458  10C00038   BEQ A2, ZERO, 0x9D00153C
9D00145C  24030001   ADDIU V1, ZERO, 1
935:                 	{
936:                 	  while((vTib[vIN]==c)&&(vIN<vSharpTib)) {vIN++;}  // Skip spaces
9D001460  8F84807C   LW A0, -32644(GP)
9D001464  9382808C   LBU V0, -32628(GP)
9D001468  00821821   ADDU V1, A0, V0
9D00146C  80650000   LB A1, 0(V1)
9D001470  30E700FF   ANDI A3, A3, 255
9D001474  54A7000D   BNEL A1, A3, 0x9D0014AC
9D001478  00E02821   ADDU A1, A3, ZERO
9D00147C  0046182B   SLTU V1, V0, A2
9D001480  10600029   BEQ V1, ZERO, 0x9D001528
9D001484  24030001   ADDIU V1, ZERO, 1
9D001488  24420001   ADDIU V0, V0, 1
9D00148C  304200FF   ANDI V0, V0, 255
9D001490  A382808C   SB V0, -32628(GP)
9D001494  00821821   ADDU V1, A0, V0
9D001498  80630000   LB V1, 0(V1)
9D00149C  1065000B   BEQ V1, A1, 0x9D0014CC
9D0014A0  00000000   NOP
9D0014CC  5446FFEF   BNEL V0, A2, 0x9D00148C
9D0014D0  24420001   ADDIU V0, V0, 1
937:                 	  while((vTib[vIN]!=c)&&(vIN<vSharpTib))           // Until c
9D0014A4  0B40052C   J 0x9D0014B0
9D0014A8  9382808C   LBU V0, -32628(GP)
9D0014AC  9382808C   LBU V0, -32628(GP)
9D0014B0  00822021   ADDU A0, A0, V0
9D0014B4  80840000   LB A0, 0(A0)
9D0014B8  0046302B   SLTU A2, V0, A2
9D0014BC  14C00007   BNE A2, ZERO, 0x9D0014DC
9D0014C0  24030001   ADDIU V1, ZERO, 1
9D0014D4  0B400558   J 0x9D001560
9D0014D8  9382808C   LBU V0, -32628(GP)
9D0014FC  8F84807C   LW A0, -32644(GP)
9D001500  00822021   ADDU A0, A0, V0
9D001504  80840000   LB A0, 0(A0)
9D001508  10A40007   BEQ A1, A0, 0x9D001528
9D00150C  306300FF   ANDI V1, V1, 255
9D001510  9386808D   LBU A2, -32627(GP)
9D001514  0046102B   SLTU V0, V0, A2
9D001518  1440FFF1   BNE V0, ZERO, 0x9D0014E0
9D00151C  8F828080   LW V0, -32640(GP)
9D001560  0B40054A   J 0x9D001528
9D001564  24030001   ADDIU V1, ZERO, 1
938:                 	  {
939:                 		vPad[i]=vTib[vIN]; i++; vIN++;  // Copy to PAD
9D0014DC  8F828080   LW V0, -32640(GP)
9D0014E0  00431021   ADDU V0, V0, V1
9D0014E4  A0440000   SB A0, 0(V0)
9D0014E8  24630001   ADDIU V1, V1, 1
9D0014EC  9382808C   LBU V0, -32628(GP)
9D0014F0  24420001   ADDIU V0, V0, 1
9D0014F4  304200FF   ANDI V0, V0, 255
9D0014F8  A382808C   SB V0, -32628(GP)
940:                 	  }
941:                 	  if((vTib[vIN]==c)&&(vIN<vSharpTib)) {vIN++;}  // Behind c delimiter 
9D001528  9384808D   LBU A0, -32627(GP)
9D00152C  0044202B   SLTU A0, V0, A0
9D001530  10800002   BEQ A0, ZERO, 0x9D00153C
9D001534  24420001   ADDIU V0, V0, 1
9D001538  A382808C   SB V0, -32628(GP)
942:                 	}
943:                 	vPad[0]=--i;  // Length
9D0014C4  0B400550   J 0x9D001540
9D0014C8  2463FFFF   ADDIU V1, V1, -1
9D001520  0B400551   J 0x9D001544
9D001524  2463FFFF   ADDIU V1, V1, -1
9D00153C  2463FFFF   ADDIU V1, V1, -1
9D001540  8F828080   LW V0, -32640(GP)
9D001544  A0430000   SB V1, 0(V0)
944:                 	PUSH((ucell)vPad);
9D001548  8F828014   LW V0, -32748(GP)
9D00154C  24430004   ADDIU V1, V0, 4
9D001550  AF838014   SW V1, -32748(GP)
9D001554  8F838080   LW V1, -32640(GP)
945:                 }
9D001558  03E00008   JR RA
9D00155C  AC430004   SW V1, 4(V0)
946:                 
947:                 
948:                 // parse ( c -- addr u )
949:                 void parse(void)
9D0015C0  00E43823   SUBU A3, A3, A0
9D0015C4  30E700FF   ANDI A3, A3, 255
950:                 {
951:                 	BYTE c=POP, i=0;
9D001568  8F828014   LW V0, -32748(GP)
9D00156C  8C450000   LW A1, 0(V0)
9D001570  2443FFFC   ADDIU V1, V0, -4
9D001574  AF838014   SW V1, -32748(GP)
952:                 
953:                 	if (vSharpTib)
9D001578  9383808D   LBU V1, -32627(GP)
9D00157C  1060002B   BEQ V1, ZERO, 0x9D00162C
9D001580  30A500FF   ANDI A1, A1, 255
954:                 	{
955:                 	  PUSH((ucell)&vTib[vIN]);         // Addr
9D001584  AF828014   SW V0, -32748(GP)
9D001588  9383808C   LBU V1, -32628(GP)
9D00158C  8F84807C   LW A0, -32644(GP)
9D001590  00831821   ADDU V1, A0, V1
9D001594  AC430000   SW V1, 0(V0)
956:                 	  while((vTib[vIN]!=c)&&(vIN<vSharpTib)) {i++; vIN++;}  // Until c
9D001598  8F86807C   LW A2, -32644(GP)
9D00159C  9384808C   LBU A0, -32628(GP)
9D0015A0  00C41021   ADDU V0, A2, A0
9D0015A4  80430000   LB V1, 0(V0)
9D0015A8  10650012   BEQ V1, A1, 0x9D0015F4
9D0015AC  00001021   ADDU V0, ZERO, ZERO
9D0015B0  9387808D   LBU A3, -32627(GP)
9D0015B4  0087182B   SLTU V1, A0, A3
9D0015B8  1060000F   BEQ V1, ZERO, 0x9D0015F8
9D0015BC  8F838014   LW V1, -32748(GP)
9D0015C8  24420001   ADDIU V0, V0, 1
9D0015CC  304200FF   ANDI V0, V0, 255
9D0015D0  00441821   ADDU V1, V0, A0
9D0015D4  306300FF   ANDI V1, V1, 255
9D0015D8  A383808C   SB V1, -32628(GP)
9D0015DC  00C31821   ADDU V1, A2, V1
9D0015E0  80630000   LB V1, 0(V1)
9D0015E4  10650004   BEQ V1, A1, 0x9D0015F8
9D0015E8  8F838014   LW V1, -32748(GP)
9D0015EC  5447FFF7   BNEL V0, A3, 0x9D0015CC
9D0015F0  24420001   ADDIU V0, V0, 1
957:                 	  PUSH((ucell)i);                  // Length
9D0015F4  8F838014   LW V1, -32748(GP)
9D0015F8  24640004   ADDIU A0, V1, 4
9D0015FC  AF848014   SW A0, -32748(GP)
9D001600  AC620004   SW V0, 4(V1)
958:                 	  if ((vTib[vIN]==c)&&(vIN<vSharpTib)) {vIN++;}         // Behind c delimiter
9D001604  9382808C   LBU V0, -32628(GP)
9D001608  8F83807C   LW V1, -32644(GP)
9D00160C  00621821   ADDU V1, V1, V0
9D001610  80630000   LB V1, 0(V1)
9D001614  14650005   BNE V1, A1, 0x9D00162C
9D001618  9383808D   LBU V1, -32627(GP)
9D00161C  0043182B   SLTU V1, V0, V1
9D001620  10600002   BEQ V1, ZERO, 0x9D00162C
9D001624  24420001   ADDIU V0, V0, 1
9D001628  A382808C   SB V0, -32628(GP)
9D00162C  03E00008   JR RA
9D001630  00000000   NOP
959:                 	}
960:                 }
961:                 
962:                 
963:                 // number ( addr -- n )
964:                 void number(void)
965:                 {
9D0020C8  27BDFFD8   ADDIU SP, SP, -40
9D0020CC  AFBF0024   SW RA, 36(SP)
9D0020D0  AFB20020   SW S2, 32(SP)
9D0020D4  AFB1001C   SW S1, 28(SP)
966:                 	char *pStart, *pEnd;
967:                 	ucell x, y=0, len;
968:                 
969:                 	count(); len=POP; pStart=(char *)POP;
9D0020D8  0F400504   JAL count
9D0020DC  AFB00018   SW S0, 24(SP)
9D0020E0  8F828014   LW V0, -32748(GP)
9D0020E4  8C510000   LW S1, 0(V0)
9D0020E8  2443FFFC   ADDIU V1, V0, -4
9D0020EC  AF838014   SW V1, -32748(GP)
9D0020F0  8C50FFFC   LW S0, -4(V0)
9D0020F4  2442FFF8   ADDIU V0, V0, -8
9D0020F8  AF828014   SW V0, -32748(GP)
970:                 	*(pStart+len)=0;  // Write end of number!
9D0020FC  02111021   ADDU V0, S0, S1
9D002100  A0400000   SB ZERO, 0(V0)
971:                 	if (*pStart=='-') {pStart++; len--; y=1;}
9D002104  82030000   LB V1, 0(S0)
9D002108  2402002D   ADDIU V0, ZERO, 45
9D00210C  14620004   BNE V1, V0, 0x9D002120
9D002110  00009021   ADDU S2, ZERO, ZERO
9D002114  26100001   ADDIU S0, S0, 1
9D002118  2631FFFF   ADDIU S1, S1, -1
9D00211C  24120001   ADDIU S2, ZERO, 1
972:                 
973:                 	base(); drop();
9D002120  0F4002FB   JAL base
9D002124  00000000   NOP
9D002128  0F400008   JAL drop
9D00212C  00000000   NOP
974:                 	if (len)
9D002130  12200015   BEQ S1, ZERO, 0x9D002188
9D002134  9382808F   LBU V0, -32625(GP)
975:                 	{
976:                 	  x=strtoul(pStart, &pEnd, vBase);
9D002138  02002021   ADDU A0, S0, ZERO
9D00213C  27A50010   ADDIU A1, SP, 16
9D002140  0F4038B7   JAL strtoul
9D002144  93868020   LBU A2, -32736(GP)
977:                 	  if (y) {x=-x;};
9D002148  00021823   SUBU V1, ZERO, V0
9D00214C  0072100B   MOVN V0, V1, S2
978:                 	  if (((ucell)pStart+len)==(ucell)pEnd) {PUSH(x);} else {vErrors|=2; abortf();}
9D002150  02118021   ADDU S0, S0, S1
9D002154  8FA30010   LW V1, 16(SP)
9D002158  54700006   BNEL V1, S0, 0x9D002174
9D00215C  9382808F   LBU V0, -32625(GP)
9D002160  8F838014   LW V1, -32748(GP)
9D002164  24640004   ADDIU A0, V1, 4
9D002168  AF848014   SW A0, -32748(GP)
9D00216C  0B400864   J 0x9D002190
9D002170  AC620004   SW V0, 4(V1)
9D002174  34420002   ORI V0, V0, 2
9D002178  0F400360   JAL abortf
9D00217C  A382808F   SB V0, -32625(GP)
979:                 	} else {vErrors|=1;}
9D002188  34420001   ORI V0, V0, 1
9D00218C  A382808F   SB V0, -32625(GP)
980:                 }
9D002180  0B400865   J 0x9D002194
9D002184  8FBF0024   LW RA, 36(SP)
9D002190  8FBF0024   LW RA, 36(SP)
9D002194  8FB20020   LW S2, 32(SP)
9D002198  8FB1001C   LW S1, 28(SP)
9D00219C  8FB00018   LW S0, 24(SP)
9D0021A0  03E00008   JR RA
9D0021A4  27BD0028   ADDIU SP, SP, 40
981:                 
982:                 
983:                 // find ( addr -- addr 0 | xt +-1 )
984:                 void find(void)
985:                 {
9D001634  27BDFFF8   ADDIU SP, SP, -8
9D001638  AFB00004   SW S0, 4(SP)
986:                 	short int i=PrimLast, j, len;
9D00163C  87878090   LH A3, -32624(GP)
987:                 	char *p1=(char *)POP, *pbak=p1, *p2;
9D001640  8F908014   LW S0, -32748(GP)
9D001644  8E0C0000   LW T4, 0(S0)
9D001648  01806821   ADDU T5, T4, ZERO
9D00164C  2602FFFC   ADDIU V0, S0, -4
9D001650  AF828014   SW V0, -32748(GP)
988:                 	ucell *Link, Linkbak, k=0;
989:                 
990:                 	len=*p1 & 0x1F;
9D001654  91890000   LBU T1, 0(T4)
991:                 	if (vHead) {Link=(ucell *)vHead; k=1;}  // Link to new word
9D001658  8F8A8104   LW T2, -32508(GP)
9D00165C  1140003B   BEQ T2, ZERO, 0x9D00174C
9D001660  3129001F   ANDI T1, T1, 31
992:                 	while (k)  // Forth words
993:                 	{
994:                 	  if (((*Link>>24)&0x1F)==len)   // Compare length
9D001678  8D480000   LW T0, 0(T2)
9D00167C  7D0B2600   EXT T3, T0, 24, 5
9D001680  1569002B   BNE T3, T1, 0x9D001730
9D001684  7D02B000   EXT V0, T0, 0, 23
995:                 	  {
996:                 		  Linkbak=(ucell)Link+cellsize;        // Begin of name
997:                 		  j=len; p1=pbak; p2=(char *)Linkbak;
9D0016A4  01201021   ADDU V0, T1, ZERO
998:                 		  while((j>0)&&(*++p1==*p2++)) {j--;}  // Compare text
9D001688  19200011   BLEZ T1, 0x9D0016D0
9D00168C  254E0004   ADDIU T6, T2, 4
9D001690  81A40001   LB A0, 1(T5)
9D001694  81420004   LB V0, 4(T2)
9D001698  1482000D   BNE A0, V0, 0x9D0016D0
9D00169C  25A30001   ADDIU V1, T5, 1
9D0016A0  25C40001   ADDIU A0, T6, 1
9D0016A8  2442FFFF   ADDIU V0, V0, -1
9D0016AC  7C021620   SEH V0, V0
9D0016B0  10400009   BEQ V0, ZERO, 0x9D0016D8
9D0016B4  24630001   ADDIU V1, V1, 1
9D0016B8  80660000   LB A2, 0(V1)
9D0016BC  80850000   LB A1, 0(A0)
9D0016C0  14C5001A   BNE A2, A1, 0x9D00172C
9D0016C4  24840001   ADDIU A0, A0, 1
9D0016C8  0B4005AB   J 0x9D0016AC
9D0016CC  2442FFFF   ADDIU V0, V0, -1
999:                 		  if (!j)
9D0016D0  15200017   BNE T1, ZERO, 0x9D001730
9D0016D4  7D02B000   EXT V0, T0, 0, 23
1000:                		  {
1001:                			Linkbak+=len;
9D0016D8  016E5821   ADDU T3, T3, T6
1002:                			if (Linkbak&3) {Linkbak=(Linkbak&~3)+cellsize;}		// Align
9D0016DC  31620003   ANDI V0, T3, 3
9D0016E0  10400004   BEQ V0, ZERO, 0x9D0016F4
9D0016E4  AF908014   SW S0, -32748(GP)
9D0016E8  2402FFFC   ADDIU V0, ZERO, -4
9D0016EC  01625824   AND T3, T3, V0
9D0016F0  256B0004   ADDIU T3, T3, 4
1003:                			PUSH(Linkbak);										// XT
9D0016F4  AE0B0000   SW T3, 0(S0)
1004:                			if ((*Link>>24)&im) {PUSH(1);} else {PUSH(-1);}		// 1 Immed
9D0016F8  8D420000   LW V0, 0(T2)
9D0016FC  04410006   BGEZ V0, 0x9D001718
9D001700  8F828014   LW V0, -32748(GP)
9D001704  24430004   ADDIU V1, V0, 4
9D001708  AF838014   SW V1, -32748(GP)
9D00170C  24030001   ADDIU V1, ZERO, 1
9D001710  0B400619   J 0x9D001864
9D001714  AC430004   SW V1, 4(V0)
9D001718  24430004   ADDIU V1, V0, 4
9D00171C  AF838014   SW V1, -32748(GP)
9D001720  2403FFFF   ADDIU V1, ZERO, -1
9D001724  0B400619   J 0x9D001864
9D001728  AC430004   SW V1, 4(V0)
1005:                			k=0; i=-1;											// True
1006:                		  }
1007:                	  }
1008:                	  if (k) {Linkbak=*Link&0x7FFFFF;} else {Linkbak=0;}		// Last,zero?
9D00172C  7D02B000   EXT V0, T0, 0, 23
1009:                	  if (!Linkbak) {k=0;}
9D001730  10400006   BEQ V0, ZERO, 0x9D00174C
9D001734  010F4024   AND T0, T0, T7
1010:                	  if (k)
1011:                	  {
1012:                		if (*Link&0x800000) {Linkbak+=AddrRAM<<24;} else {Linkbak+=AddrROM<<24;}
9D001664  939980F4   LBU T9, -32524(GP)
9D001668  0019CE00   SLL T9, T9, 24
9D00166C  939880F5   LBU T8, -32523(GP)
9D001670  0018C600   SLL T8, T8, 24
9D001674  3C0F0080   LUI T7, 128
9D001738  00581821   ADDU V1, V0, T8
9D00173C  00591021   ADDU V0, V0, T9
1013:                		Link=(ucell *)Linkbak;
9D001740  00605021   ADDU T2, V1, ZERO
9D001744  0B40059E   J 0x9D001678
9D001748  0048500A   MOVZ T2, V0, T0
1014:                	  }
1015:                	}
1016:                
1017:                //	if (primwords[i].wlen&0x20)  // Primitives?
1018:                //	{
1019:                	  while(i>=0)
9D00174C  04E00047   BLTZ A3, 0x9D00186C
9D001750  240A000C   ADDIU T2, ZERO, 12
9D001854  04E1FFC2   BGEZ A3, 0x9D001760
9D001858  70EA1002   MUL V0, A3, T2
1020:                	  {
1021:                		if ((primwords[i].wlen&0x1F)==len)     // Compare length
9D001754  3C029D00   LUI V0, -25344
9D001758  244E7008   ADDIU T6, V0, 28680
9D00175C  70EA1002   MUL V0, A3, T2
9D001760  004E1821   ADDU V1, V0, T6
9D001764  94680002   LHU T0, 2(V1)
9D001768  3102001F   ANDI V0, T0, 31
9D00176C  1449002D   BNE V0, T1, 0x9D001824
9D001770  00E05821   ADDU T3, A3, ZERO
1022:                		{
1023:                		  j=len; p1=pbak; p2=primwords[i].wname;
9D001790  01201021   ADDU V0, T1, ZERO
9D001864  0B4005D3   J 0x9D00174C
9D001868  2407FFFF   ADDIU A3, ZERO, -1
1024:                		  while((j>0)&&(*++p1==*p2++)) {j--;}  // Compare text
9D001774  19200011   BLEZ T1, 0x9D0017BC
9D001778  8C640004   LW A0, 4(V1)
9D00177C  81A60001   LB A2, 1(T5)
9D001780  80850000   LB A1, 0(A0)
9D001784  14C5000D   BNE A2, A1, 0x9D0017BC
9D001788  25A30001   ADDIU V1, T5, 1
9D00178C  24840001   ADDIU A0, A0, 1
9D001794  2442FFFF   ADDIU V0, V0, -1
9D001798  7C021620   SEH V0, V0
9D00179C  10400009   BEQ V0, ZERO, 0x9D0017C4
9D0017A0  24630001   ADDIU V1, V1, 1
9D0017A4  80660000   LB A2, 0(V1)
9D0017A8  80850000   LB A1, 0(A0)
9D0017AC  14C5001D   BNE A2, A1, 0x9D001824
9D0017B0  24840001   ADDIU A0, A0, 1
9D0017B4  0B4005E6   J 0x9D001798
9D0017B8  2442FFFF   ADDIU V0, V0, -1
1025:                		  if (!j)
9D0017BC  15200019   BNE T1, ZERO, 0x9D001824
9D0017C0  00000000   NOP
1026:                		  {
1027:                			PUSH((ucell)&primwords[i].wcall);  // XT
9D0017C4  8F828014   LW V0, -32748(GP)
9D0017C8  24430004   ADDIU V1, V0, 4
9D0017CC  AF838014   SW V1, -32748(GP)
9D0017D0  2403000C   ADDIU V1, ZERO, 12
9D0017D4  71631802   MUL V1, T3, V1
9D0017D8  24630008   ADDIU V1, V1, 8
9D0017DC  3C0B9D00   LUI T3, -25344
9D0017E0  256B7008   ADDIU T3, T3, 28680
9D0017E4  01635821   ADDU T3, T3, V1
1028:                			if (primwords[i].wlen&im) {PUSH(1);} else {PUSH(-1);}
9D0017E8  31080080   ANDI T0, T0, 128
9D0017EC  11000007   BEQ T0, ZERO, 0x9D00180C
9D0017F0  AC4B0004   SW T3, 4(V0)
9D0017F4  8F828014   LW V0, -32748(GP)
9D0017F8  24430004   ADDIU V1, V0, 4
9D0017FC  AF838014   SW V1, -32748(GP)
9D001800  24030001   ADDIU V1, ZERO, 1
9D001804  0B40061B   J 0x9D00186C
9D001808  AC430004   SW V1, 4(V0)
9D00180C  8F828014   LW V0, -32748(GP)
9D001810  24430004   ADDIU V1, V0, 4
9D001814  AF838014   SW V1, -32748(GP)
9D001818  2403FFFF   ADDIU V1, ZERO, -1
9D00181C  0B40061B   J 0x9D00186C
9D001820  AC430004   SW V1, 4(V0)
1029:                			i=-1;
1030:                		  }
1031:                		}
1032:                		if (i==0) {PUSH((ucell)pbak); PUSH(0);} // False
9D001824  14E00009   BNE A3, ZERO, 0x9D00184C
9D001828  8F828014   LW V0, -32748(GP)
9D00182C  24430004   ADDIU V1, V0, 4
9D001830  AF838014   SW V1, -32748(GP)
9D001834  AC4C0004   SW T4, 4(V0)
9D001838  8F828014   LW V0, -32748(GP)
9D00183C  24430004   ADDIU V1, V0, 4
9D001840  AF838014   SW V1, -32748(GP)
9D001844  0B40061B   J 0x9D00186C
9D001848  AC400004   SW ZERO, 4(V0)
1033:                		i--; 
9D00184C  24E7FFFF   ADDIU A3, A3, -1
9D001850  7C073E20   SEH A3, A3
1034:                	  }
1035:                //	}
1036:                }
9D00185C  0B40061C   J 0x9D001870
9D001860  8FB00004   LW S0, 4(SP)
9D00186C  8FB00004   LW S0, 4(SP)
9D001870  03E00008   JR RA
9D001874  27BD0008   ADDIU SP, SP, 8
1037:                
1038:                
1039:                // ********** Compiler **********
1040:                
1041:                
1042:                // link> ( -- xt )
1043:                void linkg(void)
1044:                {
1045:                	ucell Linkbak=cellsize+(ucell)vHead;
9D001878  8F838104   LW V1, -32508(GP)
9D00187C  24640004   ADDIU A0, V1, 4
1046:                	Linkbak+=(*(ucell *)vHead>>24)&0x1F;			// Head+len
9D001880  90620003   LBU V0, 3(V1)
9D001884  3042001F   ANDI V0, V0, 31
9D001888  00821021   ADDU V0, A0, V0
1047:                	if (Linkbak&3) {Linkbak=(Linkbak&~3)+cellsize;}	// Align
9D00188C  30430003   ANDI V1, V0, 3
9D001890  10600003   BEQ V1, ZERO, 0x9D0018A0
9D001894  2403FFFC   ADDIU V1, ZERO, -4
9D001898  00431024   AND V0, V0, V1
9D00189C  24420004   ADDIU V0, V0, 4
1048:                	PUSH(Linkbak);  // lfa->cfa
9D0018A0  8F838014   LW V1, -32748(GP)
9D0018A4  24640004   ADDIU A0, V1, 4
9D0018A8  AF848014   SW A0, -32748(GP)
1049:                }
9D0018AC  03E00008   JR RA
9D0018B0  AC620004   SW V0, 4(V1)
1050:                
1051:                
1052:                // >body ( xt -- addr )
1053:                void gbody(void) {TOS+=cellsize;}
9D0018B4  8F828014   LW V0, -32748(GP)
9D0018B8  8C430000   LW V1, 0(V0)
9D0018BC  24630004   ADDIU V1, V1, 4
9D0018C0  03E00008   JR RA
9D0018C4  AC430000   SW V1, 0(V0)
1054:                
1055:                
1056:                // ascii ( -- c )
1057:                void ascii(void)
1058:                {
9D0030BC  27BDFFE8   ADDIU SP, SP, -24
9D0030C0  AFBF0014   SW RA, 20(SP)
1059:                	blf(); wordf(); TOS++; TOS=*(BYTE *)TOS;	// c to stack
9D0030C4  0F400318   JAL blf
9D0030C8  00000000   NOP
9D0030CC  0F400511   JAL wordf
9D0030D0  00000000   NOP
9D0030D4  8F828014   LW V0, -32748(GP)
9D0030D8  8C430000   LW V1, 0(V0)
9D0030DC  24630001   ADDIU V1, V1, 1
9D0030E0  AC430000   SW V1, 0(V0)
9D0030E4  8F828014   LW V0, -32748(GP)
9D0030E8  8C430000   LW V1, 0(V0)
9D0030EC  90630000   LBU V1, 0(V1)
9D0030F0  AC430000   SW V1, 0(V0)
1060:                	if (vState) {CompileCxt(iDOLIT); comma();}	// c to Here
9D0030F4  9382808E   LBU V0, -32626(GP)
9D0030F8  10400006   BEQ V0, ZERO, 0x9D003114
9D0030FC  8FBF0014   LW RA, 20(SP)
9D003100  0F400AF9   JAL CompileCxt
9D003104  24040004   ADDIU A0, ZERO, 4
9D003108  0F4007C2   JAL comma
9D00310C  00000000   NOP
1061:                }
9D003110  8FBF0014   LW RA, 20(SP)
9D003114  03E00008   JR RA
9D003118  27BD0018   ADDIU SP, SP, 24
1062:                
1063:                
1064:                // align ( -- )
1065:                void align(void)
1066:                {
1067:                	if ((ucell)vHere&3)	{vHere=(char *)(((ucell)vHere&~3)+cellsize);}
9D0018C8  8F8280FC   LW V0, -32516(GP)
9D0018CC  30430003   ANDI V1, V0, 3
9D0018D0  10600004   BEQ V1, ZERO, 0x9D0018E4
9D0018D4  2403FFFC   ADDIU V1, ZERO, -4
9D0018D8  00431024   AND V0, V0, V1
9D0018DC  24420004   ADDIU V0, V0, 4
9D0018E0  AF8280FC   SW V0, -32516(GP)
9D0018E4  03E00008   JR RA
9D0018E8  00000000   NOP
1068:                }
1069:                
1070:                
1071:                // allot ( n -- )
1072:                void allot(void) {vHeap+=POP;}
9D0018EC  8F828014   LW V0, -32748(GP)
9D0018F0  8C430000   LW V1, 0(V0)
9D0018F4  8F84810C   LW A0, -32500(GP)
9D0018F8  00831821   ADDU V1, A0, V1
9D0018FC  AF83810C   SW V1, -32500(GP)
9D001900  2442FFFC   ADDIU V0, V0, -4
9D001904  03E00008   JR RA
9D001908  AF828014   SW V0, -32748(GP)
1073:                
1074:                
1075:                // , ( x -- )
1076:                void comma(void)
1077:                {
9D001F08  27BDFFE8   ADDIU SP, SP, -24
9D001F0C  AFBF0014   SW RA, 20(SP)
1078:                //	*(ucell *)vHere=POP; vHere+=cellsize;
1079:                	ucell x=POP;
9D001F10  8F828014   LW V0, -32748(GP)
9D001F14  8C440000   LW A0, 0(V0)
9D001F18  2442FFFC   ADDIU V0, V0, -4
9D001F1C  AF828014   SW V0, -32748(GP)
1080:                	if ((ucell)vHere>>24==AddrRAM) {*(ucell *)vHere=x; vHere+=cellsize;}
9D001F20  8F8280FC   LW V0, -32516(GP)
9D001F24  00022E02   SRL A1, V0, 24
9D001F28  938380F5   LBU V1, -32523(GP)
9D001F2C  14A30006   BNE A1, V1, 0x9D001F48
9D001F30  00000000   NOP
9D001F34  AC440000   SW A0, 0(V0)
9D001F38  8F8280FC   LW V0, -32516(GP)
9D001F3C  24420004   ADDIU V0, V0, 4
9D001F40  0B4007DD   J 0x9D001F74
9D001F44  AF8280FC   SW V0, -32516(GP)
1081:                	else {
1082:                	  if (NVMwriteBuf(x)) {vHere+=cellsize;}
9D001F48  0F403241   JAL NVMwriteBuf
9D001F4C  00000000   NOP
9D001F50  10400004   BEQ V0, ZERO, 0x9D001F64
9D001F54  8F8280FC   LW V0, -32516(GP)
9D001F58  24420004   ADDIU V0, V0, 4
9D001F5C  0B4007DD   J 0x9D001F74
9D001F60  AF8280FC   SW V0, -32516(GP)
1083:                	  else {vErrors|=0x10; abortf();}
9D001F64  9382808F   LBU V0, -32625(GP)
9D001F68  34420010   ORI V0, V0, 16
9D001F6C  0F400360   JAL abortf
9D001F70  A382808F   SB V0, -32625(GP)
1084:                	}
1085:                }
9D001F74  8FBF0014   LW RA, 20(SP)
9D001F78  03E00008   JR RA
9D001F7C  27BD0018   ADDIU SP, SP, 24
1086:                
1087:                
1088:                // c, ( c -- )
1089:                void ccomma(void)
1090:                {
9D001D24  27BDFFE8   ADDIU SP, SP, -24
9D001D28  AFBF0014   SW RA, 20(SP)
1091:                //	*vHere++=POP;
1092:                	char c=POP;
9D001D2C  8F828014   LW V0, -32748(GP)
9D001D30  80440000   LB A0, 0(V0)
9D001D34  2442FFFC   ADDIU V0, V0, -4
9D001D38  AF828014   SW V0, -32748(GP)
1093:                	if ((ucell)vHere>>24==AddrRAM) {*vHere++=c;}
9D001D3C  8F8280FC   LW V0, -32516(GP)
9D001D40  00022E02   SRL A1, V0, 24
9D001D44  938380F5   LBU V1, -32523(GP)
9D001D48  14A30005   BNE A1, V1, 0x9D001D60
9D001D4C  00000000   NOP
9D001D50  A0440000   SB A0, 0(V0)
9D001D54  24420001   ADDIU V0, V0, 1
9D001D58  0B400763   J 0x9D001D8C
9D001D5C  AF8280FC   SW V0, -32516(GP)
1094:                	else { 
1095:                	  if (NVMwriteBufc(c)) {vHere++;}
9D001D60  0F403250   JAL NVMwriteBufc
9D001D64  00000000   NOP
9D001D68  10400004   BEQ V0, ZERO, 0x9D001D7C
9D001D6C  8F8280FC   LW V0, -32516(GP)
9D001D70  24420001   ADDIU V0, V0, 1
9D001D74  0B400763   J 0x9D001D8C
9D001D78  AF8280FC   SW V0, -32516(GP)
1096:                	  else {vErrors|=0x10; abortf();}
9D001D7C  9382808F   LBU V0, -32625(GP)
9D001D80  34420010   ORI V0, V0, 16
9D001D84  0F400360   JAL abortf
9D001D88  A382808F   SB V0, -32625(GP)
1097:                	}
1098:                }
9D001D8C  8FBF0014   LW RA, 20(SP)
9D001D90  03E00008   JR RA
9D001D94  27BD0018   ADDIU SP, SP, 24
1099:                
1100:                
1101:                // w, ( x -- )
1102:                void wcomma(void)
1103:                {
9D001CAC  27BDFFE8   ADDIU SP, SP, -24
9D001CB0  AFBF0014   SW RA, 20(SP)
1104:                //	*(WORD *)vHere=POP; vHere+=2;
1105:                	WORD w=POP;
9D001CB4  8F828014   LW V0, -32748(GP)
9D001CB8  94440000   LHU A0, 0(V0)
9D001CBC  2442FFFC   ADDIU V0, V0, -4
9D001CC0  AF828014   SW V0, -32748(GP)
1106:                	if ((ucell)vHere>>24==AddrRAM) {*(WORD *)vHere=w; vHere+=2;}
9D001CC4  8F8280FC   LW V0, -32516(GP)
9D001CC8  00022E02   SRL A1, V0, 24
9D001CCC  938380F5   LBU V1, -32523(GP)
9D001CD0  14A30006   BNE A1, V1, 0x9D001CEC
9D001CD4  00000000   NOP
9D001CD8  A4440000   SH A0, 0(V0)
9D001CDC  8F8280FC   LW V0, -32516(GP)
9D001CE0  24420002   ADDIU V0, V0, 2
9D001CE4  0B400746   J 0x9D001D18
9D001CE8  AF8280FC   SW V0, -32516(GP)
1107:                	else {
1108:                	  if (NVMwriteBufw(w)) {vHere+=2;}
9D001CEC  0F403266   JAL NVMwriteBufw
9D001CF0  00000000   NOP
9D001CF4  10400004   BEQ V0, ZERO, 0x9D001D08
9D001CF8  8F8280FC   LW V0, -32516(GP)
9D001CFC  24420002   ADDIU V0, V0, 2
9D001D00  0B400746   J 0x9D001D18
9D001D04  AF8280FC   SW V0, -32516(GP)
1109:                	  else {vErrors|=0x10; abortf();}
9D001D08  9382808F   LBU V0, -32625(GP)
9D001D0C  34420010   ORI V0, V0, 16
9D001D10  0F400360   JAL abortf
9D001D14  A382808F   SB V0, -32625(GP)
1110:                	}
1111:                }
9D001D18  8FBF0014   LW RA, 20(SP)
9D001D1C  03E00008   JR RA
9D001D20  27BD0018   ADDIU SP, SP, 24
1112:                
1113:                
1114:                // s, ( addr u -- )
1115:                void scomma(void)
9D001DD0  26310001   ADDIU S1, S1, 1
9D001DD4  2652FFFF   ADDIU S2, S2, -1
9D001DD8  325200FF   ANDI S2, S2, 255
9D001DDC  02328821   ADDU S1, S1, S2
1116:                {
9D001D98  27BDFFE0   ADDIU SP, SP, -32
9D001D9C  AFBF001C   SW RA, 28(SP)
9D001DA0  AFB20018   SW S2, 24(SP)
9D001DA4  AFB10014   SW S1, 20(SP)
9D001DA8  AFB00010   SW S0, 16(SP)
1117:                	BYTE len=POP;
9D001DAC  8F828014   LW V0, -32748(GP)
9D001DB0  90520000   LBU S2, 0(V0)
9D001DB4  2443FFFC   ADDIU V1, V0, -4
9D001DB8  AF838014   SW V1, -32748(GP)
1118:                	char *addr1=(char *)POP;
9D001DBC  8C51FFFC   LW S1, -4(V0)
1119:                	PUSH(len); ccomma();
9D001DC0  0F400749   JAL ccomma
9D001DC4  AC52FFFC   SW S2, -4(V0)
1120:                	while (len>0) {PUSH(*addr1++); ccomma(); len--;}
9D001DC8  1240000E   BEQ S2, ZERO, 0x9D001E04
9D001DCC  02208021   ADDU S0, S1, ZERO
9D001DE0  8F828014   LW V0, -32748(GP)
9D001DE4  24430004   ADDIU V1, V0, 4
9D001DE8  AF838014   SW V1, -32748(GP)
9D001DEC  82030000   LB V1, 0(S0)
9D001DF0  AC430004   SW V1, 4(V0)
9D001DF4  0F400749   JAL ccomma
9D001DF8  26100001   ADDIU S0, S0, 1
9D001DFC  1611FFF9   BNE S0, S1, 0x9D001DE4
9D001E00  8F828014   LW V0, -32748(GP)
1121:                }
9D001E04  8FBF001C   LW RA, 28(SP)
9D001E08  8FB20018   LW S2, 24(SP)
9D001E0C  8FB10014   LW S1, 20(SP)
9D001E10  8FB00010   LW S0, 16(SP)
9D001E14  03E00008   JR RA
9D001E18  27BD0020   ADDIU SP, SP, 32
1122:                
1123:                
1124:                // compile ( -- )
1125:                void compile(void)
1126:                {
9D00204C  27BDFFE8   ADDIU SP, SP, -24
9D002050  AFBF0014   SW RA, 20(SP)
1127:                	PC+=cellsize; PUSH(PC); fetch(); comma(); 
9D002054  8F8380E8   LW V1, -32536(GP)
9D002058  24630004   ADDIU V1, V1, 4
9D00205C  AF8380E8   SW V1, -32536(GP)
9D002060  8F828014   LW V0, -32748(GP)
9D002064  24440004   ADDIU A0, V0, 4
9D002068  AF848014   SW A0, -32748(GP)
9D00206C  0F4000C5   JAL fetch
9D002070  AC430004   SW V1, 4(V0)
9D002074  0F4007C2   JAL comma
9D002078  00000000   NOP
1128:                }
9D00207C  8FBF0014   LW RA, 20(SP)
9D002080  03E00008   JR RA
9D002084  27BD0018   ADDIU SP, SP, 24
1129:                const void *xt_compile=compile;
1130:                
1131:                
1132:                // [compile] ( -- )
1133:                void bracketcompile(void)
1134:                {
9D002028  27BDFFE8   ADDIU SP, SP, -24
9D00202C  AFBF0014   SW RA, 20(SP)
1135:                	tick(); comma();
9D002030  0F400643   JAL tick
9D002034  00000000   NOP
9D002038  0F4007C2   JAL comma
9D00203C  00000000   NOP
1136:                }
9D002040  8FBF0014   LW RA, 20(SP)
9D002044  03E00008   JR RA
9D002048  27BD0018   ADDIU SP, SP, 24
1137:                
1138:                
1139:                // ' ( -- xt )
1140:                void tick(void)
1141:                {
9D00190C  27BDFFE8   ADDIU SP, SP, -24
9D001910  AFBF0014   SW RA, 20(SP)
1142:                	blf(); wordf(); find();
9D001914  0F400318   JAL blf
9D001918  00000000   NOP
9D00191C  0F400511   JAL wordf
9D001920  00000000   NOP
9D001924  0F40058D   JAL find
9D001928  00000000   NOP
1143:                	if (!POP) {vErrors|=0x20; abortf();}
9D00192C  8F828014   LW V0, -32748(GP)
9D001930  8C430000   LW V1, 0(V0)
9D001934  2442FFFC   ADDIU V0, V0, -4
9D001938  14600005   BNE V1, ZERO, 0x9D001950
9D00193C  AF828014   SW V0, -32748(GP)
9D001940  9382808F   LBU V0, -32625(GP)
9D001944  34420020   ORI V0, V0, 32
9D001948  0F400360   JAL abortf
9D00194C  A382808F   SB V0, -32625(GP)
1144:                }
9D001950  8FBF0014   LW RA, 20(SP)
9D001954  03E00008   JR RA
9D001958  27BD0018   ADDIU SP, SP, 24
1145:                
1146:                
1147:                // ['] ( -- )
1148:                void brackettick(void)
1149:                {
9D003090  27BDFFE8   ADDIU SP, SP, -24
9D003094  AFBF0014   SW RA, 20(SP)
1150:                	CompileCxt(iDOLIT); tick(); comma();
9D003098  0F400AF9   JAL CompileCxt
9D00309C  24040004   ADDIU A0, ZERO, 4
9D0030A0  0F400643   JAL tick
9D0030A4  00000000   NOP
9D0030A8  0F4007C2   JAL comma
9D0030AC  00000000   NOP
1151:                }
9D0030B0  8FBF0014   LW RA, 20(SP)
9D0030B4  03E00008   JR RA
9D0030B8  27BD0018   ADDIU SP, SP, 24
1152:                
1153:                
1154:                // postpone ( -- )
1155:                void postpone(void)
1156:                {
9D00359C  27BDFFE8   ADDIU SP, SP, -24
9D0035A0  AFBF0014   SW RA, 20(SP)
1157:                	blf(); wordf(); find(); 
9D0035A4  0F400318   JAL blf
9D0035A8  00000000   NOP
9D0035AC  0F400511   JAL wordf
9D0035B0  00000000   NOP
9D0035B4  0F40058D   JAL find
9D0035B8  00000000   NOP
1158:                	if ((cell)TOS<0) {pDS--; CompileCcon(&xt_compile); comma(); return;} // noimmed
9D0035BC  8F828014   LW V0, -32748(GP)
9D0035C0  8C430000   LW V1, 0(V0)
9D0035C4  04610009   BGEZ V1, 0x9D0035EC
9D0035C8  00000000   NOP
9D0035CC  2442FFFC   ADDIU V0, V0, -4
9D0035D0  AF828014   SW V0, -32748(GP)
9D0035D4  0F400D36   JAL CompileCcon
9D0035D8  27848040   ADDIU A0, GP, -32704
9D0035DC  0F4007C2   JAL comma
9D0035E0  00000000   NOP
9D0035E4  0B400D88   J 0x9D003620
9D0035E8  8FBF0014   LW RA, 20(SP)
1159:                	if ((cell)TOS)   {pDS--; comma(); return;}  // [compile] immed
9D0035EC  50600006   BEQL V1, ZERO, 0x9D003608
9D0035F0  2442FFF8   ADDIU V0, V0, -8
9D0035F4  2442FFFC   ADDIU V0, V0, -4
9D0035F8  0F4007C2   JAL comma
9D0035FC  AF828014   SW V0, -32748(GP)
9D003600  0B400D88   J 0x9D003620
9D003604  8FBF0014   LW RA, 20(SP)
1160:                	pDS-=2; vErrors|=0x20; abortf();
9D003608  AF828014   SW V0, -32748(GP)
9D00360C  9382808F   LBU V0, -32625(GP)
9D003610  34420020   ORI V0, V0, 32
9D003614  0F400360   JAL abortf
9D003618  A382808F   SB V0, -32625(GP)
1161:                }
9D00361C  8FBF0014   LW RA, 20(SP)
9D003620  03E00008   JR RA
9D003624  27BD0018   ADDIU SP, SP, 24
1162:                
1163:                
1164:                // (create) ( name -- )
1165:                void docreate(void)						// |Flg+Len|Link|Name Align|
1166:                {
9D001E1C  27BDFFE8   ADDIU SP, SP, -24
9D001E20  AFBF0014   SW RA, 20(SP)
1167:                	char *bakH;
1168:                	BYTE Len;
1169:                	ucell Link;
1170:                
1171:                	blf(); wordf(); count(); Len=TOS;  // ( -- addr n )
9D001E24  0F400318   JAL blf
9D001E28  AFB00010   SW S0, 16(SP)
9D001E2C  0F400511   JAL wordf
9D001E30  00000000   NOP
9D001E34  0F400504   JAL count
9D001E38  00000000   NOP
9D001E3C  8F828014   LW V0, -32748(GP)
1172:                	if (Len>0)
9D001E40  90430000   LBU V1, 0(V0)
9D001E44  10600020   BEQ V1, ZERO, 0x9D001EC8
9D001E48  8F908104   LW S0, -32508(GP)
1173:                	{
1174:                	  bakH=vHead; vHead=vHere;			// Update Head
9D001E4C  8F8380FC   LW V1, -32516(GP)
9D001E50  AF838104   SW V1, -32508(GP)
1175:                	  PUSH((ucell)bakH); wcomma();		// Link low 16b
9D001E54  24430004   ADDIU V1, V0, 4
9D001E58  AF838014   SW V1, -32748(GP)
9D001E5C  0F40072B   JAL wcomma
9D001E60  AC500004   SW S0, 4(V0)
1176:                	  Link=((ucell)bakH>>16)&0x7F;		// Link hi 23b 
9D001E64  7E033400   EXT V1, S0, 16, 7
1177:                	  Link|=(((ucell)bakH>>24)==AddrROM) ? 0:0x80;  // ROM/RAM
9D001E68  00108602   SRL S0, S0, 24
9D001E6C  938280F4   LBU V0, -32524(GP)
9D001E70  02028026   XOR S0, S0, V0
9D001E74  24020080   ADDIU V0, ZERO, 128
9D001E78  0010100A   MOVZ V0, ZERO, S0
9D001E7C  00408021   ADDU S0, V0, ZERO
9D001E8C  02038025   OR S0, S0, V1
1178:                	  PUSH(Link); ccomma(); scomma();	// Link hi, Length+Name
9D001E80  8F828014   LW V0, -32748(GP)
9D001E84  24440004   ADDIU A0, V0, 4
9D001E88  AF848014   SW A0, -32748(GP)
9D001E90  0F400749   JAL ccomma
9D001E94  AC500004   SW S0, 4(V0)
9D001E98  0F400766   JAL scomma
9D001E9C  00000000   NOP
1179:                	  align();							// 4B align
9D001EA0  0F400632   JAL align
9D001EA4  00000000   NOP
1180:                	  if ((ucell)vHere>>24==AddrROM) {toflash();}  // Write to flash
9D001EA8  938380FF   LBU V1, -32513(GP)
9D001EAC  938280F4   LBU V0, -32524(GP)
9D001EB0  54620008   BNEL V1, V0, 0x9D001ED4
9D001EB4  8FBF0014   LW RA, 20(SP)
9D001EB8  0F4006E8   JAL toflash
9D001EBC  00000000   NOP
1181:                	} else {twodrop();}
9D001EC8  0F40000C   JAL twodrop
9D001ECC  00000000   NOP
1182:                }
9D001EC0  0B4007B5   J 0x9D001ED4
9D001EC4  8FBF0014   LW RA, 20(SP)
9D001ED0  8FBF0014   LW RA, 20(SP)
9D001ED4  8FB00010   LW S0, 16(SP)
9D001ED8  03E00008   JR RA
9D001EDC  27BD0018   ADDIU SP, SP, 24
1183:                
1184:                
1185:                // create ( name -- )
1186:                void createf(void)						// |Flg+Len|Link|Name Align|(con)|PFA|
1187:                {
9D003498  27BDFFE8   ADDIU SP, SP, -24
9D00349C  AFBF0014   SW RA, 20(SP)
1188:                	docreate(); CompileCpfa(iDOCON);	// comma PFA docon
9D0034A0  0F400787   JAL docreate
9D0034A4  00000000   NOP
9D0034A8  0F400CB1   JAL CompileCpfa
9D0034AC  24040006   ADDIU A0, ZERO, 6
1189:                	PUSH((ucell)vHere+cellsize); comma(); // comma PFA new word
9D0034B0  8F828014   LW V0, -32748(GP)
9D0034B4  24430004   ADDIU V1, V0, 4
9D0034B8  AF838014   SW V1, -32748(GP)
9D0034BC  8F8380FC   LW V1, -32516(GP)
9D0034C0  24630004   ADDIU V1, V1, 4
9D0034C4  0F4007C2   JAL comma
9D0034C8  AC430004   SW V1, 4(V0)
1190:                }
9D0034CC  8FBF0014   LW RA, 20(SP)
9D0034D0  03E00008   JR RA
9D0034D4  27BD0018   ADDIU SP, SP, 24
1191:                
1192:                
1193:                // <builds ( name -- )
1194:                void builds(void)						// |Flg+Len|Link|Name Align|-1|-1|
1195:                {
9D001EE0  27BDFFE8   ADDIU SP, SP, -24
9D001EE4  AFBF0014   SW RA, 20(SP)
1196:                	docreate();
9D001EE8  0F400787   JAL docreate
9D001EEC  00000000   NOP
1197:                	vHere+=cellsize; vHere+=cellsize;	// Cells for Flash overwrite
9D001EF0  8F8280FC   LW V0, -32516(GP)
9D001EF4  24420008   ADDIU V0, V0, 8
9D001EF8  AF8280FC   SW V0, -32516(GP)
1198:                }
9D001EFC  8FBF0014   LW RA, 20(SP)
9D001F00  03E00008   JR RA
9D001F04  27BD0018   ADDIU SP, SP, 24
1199:                
1200:                
1201:                // does> ( -- )
1202:                void does(void)
1203:                {
9D003434  27BDFFE8   ADDIU SP, SP, -24
9D003438  AFBF0014   SW RA, 20(SP)
9D00343C  AFB00010   SW S0, 16(SP)
1204:                	char *bak=vHere;
1205:                	linkg(); herewrite(); CompileCpfa(iDODOES);	// Overwrite xt by dodoes
9D003440  0F40061E   JAL linkg
9D003444  8F9080FC   LW S0, -32516(GP)
9D003448  0F400100   JAL herewrite
9D00344C  00000000   NOP
9D003450  0F400CB1   JAL CompileCpfa
9D003454  24040008   ADDIU A0, ZERO, 8
1206:                	PUSH(PC); comma();							// Overwrite xt+1 by PC does>
9D003458  8F828014   LW V0, -32748(GP)
9D00345C  24430004   ADDIU V1, V0, 4
9D003460  AF838014   SW V1, -32748(GP)
9D003464  8F8380E8   LW V1, -32536(GP)
9D003468  0F4007C2   JAL comma
9D00346C  AC430004   SW V1, 4(V0)
1207:                	vHere=bak; EXIT
9D003470  AF9080FC   SW S0, -32516(GP)
9D003474  8F82801C   LW V0, -32740(GP)
9D003478  8C430000   LW V1, 0(V0)
9D00347C  AF8380E8   SW V1, -32536(GP)
9D003480  2442FFFC   ADDIU V0, V0, -4
9D003484  AF82801C   SW V0, -32740(GP)
1208:                }
9D003488  8FBF0014   LW RA, 20(SP)
9D00348C  8FB00010   LW S0, 16(SP)
9D003490  03E00008   JR RA
9D003494  27BD0018   ADDIU SP, SP, 24
1209:                
1210:                
1211:                // : ( -- )
1212:                void colon(void)
1213:                {
9D003408  27BDFFE8   ADDIU SP, SP, -24
9D00340C  AFBF0014   SW RA, 20(SP)
1214:                	docreate(); CompileCpfa(iENTER); /* PFA docolon */ rbracket();
9D003410  0F400787   JAL docreate
9D003414  00000000   NOP
9D003418  0F400CB1   JAL CompileCpfa
9D00341C  24040003   ADDIU A0, ZERO, 3
9D003420  0F4004EC   JAL rbracket
9D003424  00000000   NOP
1215:                }
9D003428  8FBF0014   LW RA, 20(SP)
9D00342C  03E00008   JR RA
9D003430  27BD0018   ADDIU SP, SP, 24
1216:                
1217:                
1218:                // ; ( -- )
1219:                void semicolon(void)
1220:                {
9D00306C  27BDFFE8   ADDIU SP, SP, -24
9D003070  AFBF0014   SW RA, 20(SP)
1221:                	CompileCxt(iEXIT); /* doexit */ lbracket();
9D003074  0F400AF9   JAL CompileCxt
9D003078  00002021   ADDU A0, ZERO, ZERO
9D00307C  0F4004EA   JAL lbracket
9D003080  00000000   NOP
1222:                }
9D003084  8FBF0014   LW RA, 20(SP)
9D003088  03E00008   JR RA
9D00308C  27BD0018   ADDIU SP, SP, 24
1223:                
1224:                
1225:                // immediate ( -- )
1226:                void immediate(void)
1227:                {
1228:                	char *pLen=vHead+3;
9D00195C  8F828104   LW V0, -32508(GP)
1229:                	*pLen|=im;
9D001960  90440003   LBU A0, 3(V0)
9D001964  2403FF80   ADDIU V1, ZERO, -128
9D001968  00831825   OR V1, A0, V1
1230:                }
9D00196C  03E00008   JR RA
9D001970  A0430003   SB V1, 3(V0)
1231:                
1232:                
1233:                // s" ( -- addr n)
1234:                void squote(void)
1235:                {
9D00301C  27BDFFE8   ADDIU SP, SP, -24
9D003020  AFBF0014   SW RA, 20(SP)
1236:                	PUSH('"'); parse();
9D003024  8F828014   LW V0, -32748(GP)
9D003028  24430004   ADDIU V1, V0, 4
9D00302C  AF838014   SW V1, -32748(GP)
9D003030  24030022   ADDIU V1, ZERO, 34
9D003034  0F40055A   JAL parse
9D003038  AC430004   SW V1, 4(V0)
1237:                	if (vState) {CompileCxt(iDOSLIT); scomma(); align();}
9D00303C  9382808E   LBU V0, -32626(GP)
9D003040  10400008   BEQ V0, ZERO, 0x9D003064
9D003044  8FBF0014   LW RA, 20(SP)
9D003048  0F400AF9   JAL CompileCxt
9D00304C  24040005   ADDIU A0, ZERO, 5
9D003050  0F400766   JAL scomma
9D003054  00000000   NOP
9D003058  0F400632   JAL align
9D00305C  00000000   NOP
1238:                }
9D003060  8FBF0014   LW RA, 20(SP)
9D003064  03E00008   JR RA
9D003068  27BD0018   ADDIU SP, SP, 24
1239:                
1240:                
1241:                // literal ( x -- )
1242:                void literal(void)
1243:                {
9D002FF8  27BDFFE8   ADDIU SP, SP, -24
9D002FFC  AFBF0014   SW RA, 20(SP)
1244:                	CompileCxt(iDOLIT); /* doliteral */ comma();
9D003000  0F400AF9   JAL CompileCxt
9D003004  24040004   ADDIU A0, ZERO, 4
9D003008  0F4007C2   JAL comma
9D00300C  00000000   NOP
1245:                }
9D003010  8FBF0014   LW RA, 20(SP)
9D003014  03E00008   JR RA
9D003018  27BD0018   ADDIU SP, SP, 24
1246:                
1247:                
1248:                // constant ( x -- )
1249:                void constant(void)
1250:                {
9D0033DC  27BDFFE8   ADDIU SP, SP, -24
9D0033E0  AFBF0014   SW RA, 20(SP)
1251:                	docreate(); CompileCpfa(iDOCON); /* PFA doconstant */ comma();
9D0033E4  0F400787   JAL docreate
9D0033E8  00000000   NOP
9D0033EC  0F400CB1   JAL CompileCpfa
9D0033F0  24040006   ADDIU A0, ZERO, 6
9D0033F4  0F4007C2   JAL comma
9D0033F8  00000000   NOP
1252:                }
9D0033FC  8FBF0014   LW RA, 20(SP)
9D003400  03E00008   JR RA
9D003404  27BD0018   ADDIU SP, SP, 24
1253:                
1254:                
1255:                // variable ( -- ) 
1256:                void variable(void)
1257:                {
9D00339C  27BDFFE8   ADDIU SP, SP, -24
9D0033A0  AFBF0014   SW RA, 20(SP)
1258:                	docreate(); CompileCpfa(iDOVAR); /* PFA dovariable */
9D0033A4  0F400787   JAL docreate
9D0033A8  00000000   NOP
9D0033AC  0F400CB1   JAL CompileCpfa
9D0033B0  24040007   ADDIU A0, ZERO, 7
1259:                	heap(); comma(); vHeap+=cellsize;
9D0033B4  0F400112   JAL heap
9D0033B8  00000000   NOP
9D0033BC  0F4007C2   JAL comma
9D0033C0  00000000   NOP
9D0033C4  8F82810C   LW V0, -32500(GP)
9D0033C8  24420004   ADDIU V0, V0, 4
9D0033CC  AF82810C   SW V0, -32500(GP)
1260:                }
9D0033D0  8FBF0014   LW RA, 20(SP)
9D0033D4  03E00008   JR RA
9D0033D8  27BD0018   ADDIU SP, SP, 24
1261:                
1262:                
1263:                // value ( x name -- ) 
1264:                void value(void)
1265:                {
9D003348  27BDFFE8   ADDIU SP, SP, -24
9D00334C  AFBF0014   SW RA, 20(SP)
1266:                	docreate(); CompileCpfa(iDOVAL); /* PFA dovalue */
9D003350  0F400787   JAL docreate
9D003354  00000000   NOP
9D003358  0F400CB1   JAL CompileCpfa
9D00335C  24040010   ADDIU A0, ZERO, 16
1267:                	pDATA vHeap=POP;  // value x
9D003360  8F828014   LW V0, -32748(GP)
9D003364  8C440000   LW A0, 0(V0)
9D003368  8F83810C   LW V1, -32500(GP)
9D00336C  AC640000   SW A0, 0(V1)
9D003370  2442FFFC   ADDIU V0, V0, -4
1268:                	heap(); comma(); vHeap+=cellsize;
9D003374  0F400112   JAL heap
9D003378  AF828014   SW V0, -32748(GP)
9D00337C  0F4007C2   JAL comma
9D003380  00000000   NOP
9D003384  8F82810C   LW V0, -32500(GP)
9D003388  24420004   ADDIU V0, V0, 4
9D00338C  AF82810C   SW V0, -32500(GP)
1269:                }
9D003390  8FBF0014   LW RA, 20(SP)
9D003394  03E00008   JR RA
9D003398  27BD0018   ADDIU SP, SP, 24
1270:                
1271:                
1272:                // (to) ( x -- )
1273:                void dotof(void)
1274:                {
1275:                	PC+=cellsize; pDATA PC=POP;
9D001974  8F8380E8   LW V1, -32536(GP)
9D001978  24620004   ADDIU V0, V1, 4
9D00197C  AF8280E8   SW V0, -32536(GP)
9D001980  8F828014   LW V0, -32748(GP)
9D001984  8C440000   LW A0, 0(V0)
9D001988  AC640004   SW A0, 4(V1)
9D00198C  2442FFFC   ADDIU V0, V0, -4
1276:                }
9D001990  03E00008   JR RA
9D001994  AF828014   SW V0, -32748(GP)
1277:                const void *xt_doto=dotof;
1278:                
1279:                
1280:                // to ( x name -- ) 
1281:                void tof(void)
1282:                {
9D003540  27BDFFE8   ADDIU SP, SP, -24
9D003544  AFBF0014   SW RA, 20(SP)
1283:                	tick(); TOS+=cellsize; fetch();
9D003548  0F400643   JAL tick
9D00354C  00000000   NOP
9D003550  8F828014   LW V0, -32748(GP)
9D003554  8C430000   LW V1, 0(V0)
9D003558  24630004   ADDIU V1, V1, 4
9D00355C  0F4000C5   JAL fetch
9D003560  AC430000   SW V1, 0(V0)
1284:                	if(vState) {CompileCcon(&xt_doto); comma();} else {store();}
9D003564  9382808E   LBU V0, -32626(GP)
9D003568  10400007   BEQ V0, ZERO, 0x9D003588
9D00356C  00000000   NOP
9D003570  0F400D36   JAL CompileCcon
9D003574  27848044   ADDIU A0, GP, -32700
9D003578  0F4007C2   JAL comma
9D00357C  00000000   NOP
9D003588  0F4000D4   JAL store
9D00358C  00000000   NOP
1285:                }
9D003580  0B400D65   J 0x9D003594
9D003584  8FBF0014   LW RA, 20(SP)
9D003590  8FBF0014   LW RA, 20(SP)
9D003594  03E00008   JR RA
9D003598  27BD0018   ADDIU SP, SP, 24
1286:                
1287:                
1288:                // defer ( name -- )
1289:                void defer(void)
1290:                {
9D003308  27BDFFE8   ADDIU SP, SP, -24
9D00330C  AFBF0014   SW RA, 20(SP)
1291:                	docreate(); CompileCpfa(iDODEF); /* PFA dodefer */
9D003310  0F400787   JAL docreate
9D003314  00000000   NOP
9D003318  0F400CB1   JAL CompileCpfa
9D00331C  24040009   ADDIU A0, ZERO, 9
1292:                	heap(); comma(); vHeap+=cellsize;
9D003320  0F400112   JAL heap
9D003324  00000000   NOP
9D003328  0F4007C2   JAL comma
9D00332C  00000000   NOP
9D003330  8F82810C   LW V0, -32500(GP)
9D003334  24420004   ADDIU V0, V0, 4
9D003338  AF82810C   SW V0, -32500(GP)
1293:                }
9D00333C  8FBF0014   LW RA, 20(SP)
9D003340  03E00008   JR RA
9D003344  27BD0018   ADDIU SP, SP, 24
1294:                
1295:                
1296:                // defer@ ( xt1 -- xt2 )
1297:                void deferfetch(void)
1298:                {
1299:                	TOS+=cellsize; TOS=pDATA(pDATA(TOS));
9D001998  8F828014   LW V0, -32748(GP)
9D00199C  8C430000   LW V1, 0(V0)
9D0019A0  24630004   ADDIU V1, V1, 4
9D0019A4  AC430000   SW V1, 0(V0)
9D0019A8  8F828014   LW V0, -32748(GP)
9D0019AC  8C430000   LW V1, 0(V0)
9D0019B0  8C630000   LW V1, 0(V1)
9D0019B4  8C630000   LW V1, 0(V1)
1300:                }
9D0019B8  03E00008   JR RA
9D0019BC  AC430000   SW V1, 0(V0)
1301:                
1302:                
1303:                // defer! ( xt2 xt1 -- )
1304:                void deferstore(void)
1305:                {
1306:                	ucell x1=POP+cellsize;
9D0019C0  8F828014   LW V0, -32748(GP)
9D0019C4  8C430000   LW V1, 0(V0)
9D0019C8  2444FFFC   ADDIU A0, V0, -4
9D0019CC  AF848014   SW A0, -32748(GP)
1307:                	pDATA(pDATA(x1))=POP;
9D0019D0  8C630004   LW V1, 4(V1)
9D0019D4  8C44FFFC   LW A0, -4(V0)
9D0019D8  AC640000   SW A0, 0(V1)
9D0019DC  2442FFF8   ADDIU V0, V0, -8
1308:                }
9D0019E0  03E00008   JR RA
9D0019E4  AF828014   SW V0, -32748(GP)
1309:                
1310:                
1311:                // interpret ( ? -- ? )
1312:                void interpret(void)
1313:                {
9D002C28  27BDFFE0   ADDIU SP, SP, -32
9D002C2C  AFBF001C   SW RA, 28(SP)
9D002C30  AFB10018   SW S1, 24(SP)
9D002C34  AFB00014   SW S0, 20(SP)
1314:                	char fRun=1;
9D002C3C  24100001   ADDIU S0, ZERO, 1
1315:                	
1316:                	vErrors=0;
9D002C38  A380808F   SB ZERO, -32625(GP)
1317:                	while (fRun)
9D002D4C  1600FFBD   BNE S0, ZERO, 0x9D002C44
9D002D50  00000000   NOP
1318:                	{	
1319:                	  blf(); wordf(); dup();
9D002C44  0F400318   JAL blf
9D002C48  00000000   NOP
9D002C4C  0F400511   JAL wordf
9D002C50  00000000   NOP
9D002C54  0F400010   JAL dup
9D002C58  00000000   NOP
1320:                	  cfetch();
9D002C5C  0F4000CA   JAL cfetch
9D002C60  00000000   NOP
1321:                	  if (!POP) {drop(); vErrors|=1;}  // Empty TIB
9D002C64  8F828014   LW V0, -32748(GP)
9D002C68  8C430000   LW V1, 0(V0)
9D002C6C  2442FFFC   ADDIU V0, V0, -4
9D002C70  14600007   BNE V1, ZERO, 0x9D002C90
9D002C74  AF828014   SW V0, -32748(GP)
9D002C78  0F400008   JAL drop
9D002C7C  00000000   NOP
9D002C80  9382808F   LBU V0, -32625(GP)
9D002C84  34420001   ORI V0, V0, 1
9D002C88  0B400B4E   J 0x9D002D38
9D002C8C  A382808F   SB V0, -32625(GP)
1322:                	  else
1323:                	  {
1324:                		find();	isdup();
9D002C90  0F40058D   JAL find
9D002C94  00000000   NOP
9D002C98  0F400021   JAL isdup
9D002C9C  00000000   NOP
1325:                		zeroequals();
9D002CA0  0F400240   JAL zeroequals
9D002CA4  00000000   NOP
1326:                		if (POP) {number(); if (vState) {CompileCxt(iDOLIT); comma();}}  // compile number
9D002CA8  8F828014   LW V0, -32748(GP)
9D002CAC  8C430000   LW V1, 0(V0)
9D002CB0  2442FFFC   ADDIU V0, V0, -4
9D002CB4  1060000C   BEQ V1, ZERO, 0x9D002CE8
9D002CB8  AF828014   SW V0, -32748(GP)
9D002CBC  0F400832   JAL number
9D002CC0  00000000   NOP
9D002CC4  9382808E   LBU V0, -32626(GP)
9D002CC8  5040001C   BEQL V0, ZERO, 0x9D002D3C
9D002CCC  9382808F   LBU V0, -32625(GP)
9D002CD0  0F400AF9   JAL CompileCxt
9D002CD4  24040004   ADDIU A0, ZERO, 4
9D002CD8  0F4007C2   JAL comma
9D002CDC  00000000   NOP
1327:                		else
1328:                		{
1329:                		  zerogreater();
9D002CE8  0F40024D   JAL zerogreater
9D002CEC  00000000   NOP
1330:                		  if (POP) {executew();}  // immediate
9D002CF0  8F828014   LW V0, -32748(GP)
9D002CF4  8C430000   LW V1, 0(V0)
9D002CF8  2442FFFC   ADDIU V0, V0, -4
9D002CFC  10600005   BEQ V1, ZERO, 0x9D002D14
9D002D00  AF828014   SW V0, -32748(GP)
9D002D04  0F402C59   JAL executew
9D002D08  00000000   NOP
1331:                		  else
1332:                		  {
1333:                			if (vState) {comma();} else {executew();}  // compile/interpreter
9D002D14  9382808E   LBU V0, -32626(GP)
9D002D18  10400005   BEQ V0, ZERO, 0x9D002D30
9D002D1C  00000000   NOP
9D002D20  0F4007C2   JAL comma
9D002D24  00000000   NOP
9D002D30  0F402C59   JAL executew
9D002D34  00000000   NOP
1334:                		  }
1335:                		}
1336:                	  }
1337:                	  if (vErrors) {fRun=0;}
9D002CE0  0B400B4F   J 0x9D002D3C
9D002CE4  9382808F   LBU V0, -32625(GP)
9D002D0C  0B400B4F   J 0x9D002D3C
9D002D10  9382808F   LBU V0, -32625(GP)
9D002D28  0B400B4F   J 0x9D002D3C
9D002D2C  9382808F   LBU V0, -32625(GP)
9D002D38  9382808F   LBU V0, -32625(GP)
9D002D3C  0002800B   MOVN S0, ZERO, V0
1338:                	  if (vState==EndState) {fRun=0;}
9D002C40  241100EE   ADDIU S1, ZERO, 238
9D002D40  9382808E   LBU V0, -32626(GP)
9D002D44  10510003   BEQ V0, S1, 0x9D002D54
9D002D48  8FBF001C   LW RA, 28(SP)
1339:                	}
1340:                }
9D002D54  8FB10018   LW S1, 24(SP)
9D002D58  8FB00014   LW S0, 20(SP)
9D002D5C  03E00008   JR RA
9D002D60  27BD0020   ADDIU SP, SP, 32
1341:                
1342:                
1343:                // quit ( -- )
1344:                void quit(void)
1345:                {
9D002D64  27BDFFD8   ADDIU SP, SP, -40
9D002D68  AFBF0024   SW RA, 36(SP)
9D002D6C  AFB40020   SW S4, 32(SP)
9D002D70  AFB3001C   SW S3, 28(SP)
9D002D74  AFB20018   SW S2, 24(SP)
9D002D78  AFB10014   SW S1, 20(SP)
9D002D7C  AFB00010   SW S0, 16(SP)
1346:                	pDS=pDSzero; pRS=pRSzero; lbracket();
9D002D80  8F828010   LW V0, -32752(GP)
9D002D84  AF828014   SW V0, -32748(GP)
9D002D88  8F828018   LW V0, -32744(GP)
9D002D8C  0F4004EA   JAL lbracket
9D002D90  AF82801C   SW V0, -32740(GP)
1347:                	do {
1348:                	  if (!vState) {crf(); PUSH('>'); emit(); blf(); emit();};
9D002D94  2412003E   ADDIU S2, ZERO, 62
9D002DA8  9382808E   LBU V0, -32626(GP)
9D002DAC  1440000C   BNE V0, ZERO, 0x9D002DE0
9D002DB0  00000000   NOP
9D002DB4  0F40095F   JAL crf
9D002DB8  00000000   NOP
9D002DBC  8F828014   LW V0, -32748(GP)
9D002DC0  24430004   ADDIU V1, V0, 4
9D002DC4  AF838014   SW V1, -32748(GP)
9D002DC8  0F4008B3   JAL emit
9D002DCC  AC520004   SW S2, 4(V0)
9D002DD0  0F400318   JAL blf
9D002DD4  00000000   NOP
9D002DD8  0F4008B3   JAL emit
9D002DDC  00000000   NOP
1349:                	  refill(); POP;
9D002DE0  0F400A94   JAL refill
9D002DE4  00000000   NOP
9D002DE8  8F828014   LW V0, -32748(GP)
9D002DEC  2442FFFC   ADDIU V0, V0, -4
9D002DF0  AF828014   SW V0, -32748(GP)
1350:                	  vErrors=0; interpret();
9D002DF4  0F400B0A   JAL interpret
9D002DF8  A380808F   SB ZERO, -32625(GP)
1351:                	  if (vErrors<=1) {blf(); emit(); PUSH('o'); emit(); PUSH('k'); emit();}
9D002D9C  2413006F   ADDIU S3, ZERO, 111
9D002DA0  2414006B   ADDIU S4, ZERO, 107
9D002DFC  9382808F   LBU V0, -32625(GP)
9D002E00  2C420002   SLTIU V0, V0, 2
9D002E04  10400011   BEQ V0, ZERO, 0x9D002E4C
9D002E08  00000000   NOP
9D002E0C  0F400318   JAL blf
9D002E10  00000000   NOP
9D002E14  0F4008B3   JAL emit
9D002E18  00000000   NOP
9D002E1C  8F828014   LW V0, -32748(GP)
9D002E20  24430004   ADDIU V1, V0, 4
9D002E24  AF838014   SW V1, -32748(GP)
9D002E28  0F4008B3   JAL emit
9D002E2C  AC530004   SW S3, 4(V0)
9D002E30  8F828014   LW V0, -32748(GP)
9D002E34  24430004   ADDIU V1, V0, 4
9D002E38  AF838014   SW V1, -32748(GP)
9D002E3C  0F4008B3   JAL emit
9D002E40  AC540004   SW S4, 4(V0)
1352:                	  else {blf(); emit(); PUSH('?'); emit(); PUSH('?'); emit(); PUSH(vErrors); udot();}
9D002D98  2410003F   ADDIU S0, ZERO, 63
9D002E4C  0F400318   JAL blf
9D002E50  00000000   NOP
9D002E54  0F4008B3   JAL emit
9D002E58  00000000   NOP
9D002E5C  8F828014   LW V0, -32748(GP)
9D002E60  24430004   ADDIU V1, V0, 4
9D002E64  AF838014   SW V1, -32748(GP)
9D002E68  0F4008B3   JAL emit
9D002E6C  AC500004   SW S0, 4(V0)
9D002E70  8F828014   LW V0, -32748(GP)
9D002E74  24430004   ADDIU V1, V0, 4
9D002E78  AF838014   SW V1, -32748(GP)
9D002E7C  0F4008B3   JAL emit
9D002E80  AC500004   SW S0, 4(V0)
9D002E84  8F828014   LW V0, -32748(GP)
9D002E88  24430004   ADDIU V1, V0, 4
9D002E8C  AF838014   SW V1, -32748(GP)
9D002E90  9383808F   LBU V1, -32625(GP)
9D002E94  0F400948   JAL udot
9D002E98  AC430004   SW V1, 4(V0)
1353:                	} while (vState!=EndState);
9D002DA4  241100EE   ADDIU S1, ZERO, 238
9D002E44  0B400BA8   J 0x9D002EA0
9D002E48  9382808E   LBU V0, -32626(GP)
9D002E9C  9382808E   LBU V0, -32626(GP)
9D002EA0  5451FFC2   BNEL V0, S1, 0x9D002DAC
9D002EA4  9382808E   LBU V0, -32626(GP)
1354:                }
9D002EA8  8FBF0024   LW RA, 36(SP)
9D002EAC  8FB40020   LW S4, 32(SP)
9D002EB0  8FB3001C   LW S3, 28(SP)
9D002EB4  8FB20018   LW S2, 24(SP)
9D002EB8  8FB10014   LW S1, 20(SP)
9D002EBC  8FB00010   LW S0, 16(SP)
9D002EC0  03E00008   JR RA
9D002EC4  27BD0028   ADDIU SP, SP, 40
1355:                
1356:                
1357:                // cold ( -- )
1358:                void cold(void)
1359:                {
9D002EC8  27BDFFE8   ADDIU SP, SP, -24
9D002ECC  AFBF0014   SW RA, 20(SP)
9D002ED0  AFB00010   SW S0, 16(SP)
1360:                
1361:                      // Default init
1362:                #ifdef VPC_32
1363:                    char error=0;
9D002EEC  2C500001   SLTIU S0, V0, 1
1364:                    if (vPad==NULL){
9D002ED4  8F828080   LW V0, -32640(GP)
9D002ED8  14400005   BNE V0, ZERO, 0x9D002EF0
9D002EDC  00008021   ADDU S0, ZERO, ZERO
1365:                        vPad=malloc(padsize*sizeof(char));
9D002EE0  0F403795   JAL malloc
9D002EE4  24040050   ADDIU A0, ZERO, 80
9D002EE8  AF828080   SW V0, -32640(GP)
1366:                        if (!vPad) error=1;
1367:                    }
1368:                    if (vTib==NULL){
9D002EF0  8F82807C   LW V0, -32644(GP)
9D002EF4  14400007   BNE V0, ZERO, 0x9D002F14
9D002EF8  8F848084   LW A0, -32636(GP)
1369:                        vTib=malloc(padsize*sizeof(char));
9D002EFC  0F403795   JAL malloc
9D002F00  24040050   ADDIU A0, ZERO, 80
9D002F04  AF82807C   SW V0, -32644(GP)
1370:                        if (!vTib) error=1;
9D002F08  24030001   ADDIU V1, ZERO, 1
9D002F0C  0062800A   MOVZ S0, V1, V0
1371:                    }
1372:                    if (vDict!=NULL){free(vDict);}
9D002F10  8F848084   LW A0, -32636(GP)
9D002F14  50800004   BEQL A0, ZERO, 0x9D002F28
9D002F18  24040400   ADDIU A0, ZERO, 1024
9D002F1C  0F403FAA   JAL free
9D002F20  00000000   NOP
1373:                    vDict=calloc(dictsize,sizeof(char));
9D002F24  24040400   ADDIU A0, ZERO, 1024
9D002F28  0F403DD4   JAL calloc
9D002F2C  24050001   ADDIU A1, ZERO, 1
9D002F30  AF828084   SW V0, -32636(GP)
1374:                    if (!vDict) error=1;
9D002F34  24030001   ADDIU V1, ZERO, 1
1375:                    if (vMem!=NULL){free(vMem);}
9D002F38  8F848088   LW A0, -32632(GP)
9D002F3C  10800003   BEQ A0, ZERO, 0x9D002F4C
9D002F40  0062800A   MOVZ S0, V1, V0
9D002F44  0F403FAA   JAL free
9D002F48  00000000   NOP
1376:                    vMem=calloc(memsize,sizeof(char));
9D002F4C  24041000   ADDIU A0, ZERO, 4096
9D002F50  0F403DD4   JAL calloc
9D002F54  24050001   ADDIU A1, ZERO, 1
1377:                    if (!vMem) error=1;
9D002F58  10400003   BEQ V0, ZERO, 0x9D002F68
9D002F5C  AF828088   SW V0, -32632(GP)
1378:                    if (error){
9D002F60  12000007   BEQ S0, ZERO, 0x9D002F80
9D002F64  93828087   LBU V0, -32633(GP)
1379:                        print(comm_channel,"not enough memory\r");
9D002F68  83848064   LB A0, -32668(GP)
9D002F6C  3C059D00   LUI A1, -25344
9D002F70  0F402601   JAL print
9D002F74  24A56A20   ADDIU A1, A1, 27168
1380:                        return;
9D002F78  0B400BFB   J 0x9D002FEC
9D002F7C  8FBF0014   LW RA, 20(SP)
1381:                    }
1382:                #endif
1383:                	AddrRAM=(ucell)vDict>>24; AddrROM=(ucell)primwords>>24;
9D002F80  A38280F5   SB V0, -32523(GP)
9D002F84  3C029D00   LUI V0, -25344
9D002F88  24427008   ADDIU V0, V0, 28680
9D002F8C  00021602   SRL V0, V0, 24
9D002F90  A38280F4   SB V0, -32524(GP)
1384:                	pDS=pDSzero; pRS=pRSzero; 
9D002F94  8F828010   LW V0, -32752(GP)
9D002F98  AF828014   SW V0, -32748(GP)
9D002F9C  8F828018   LW V0, -32744(GP)
9D002FA0  AF82801C   SW V0, -32740(GP)
1385:                	vIN=0; vSharpTib=0;
9D002FA4  A380808C   SB ZERO, -32628(GP)
9D002FA8  A380808D   SB ZERO, -32627(GP)
1386:                #ifdef VPC_32
1387:                        vBase=10;
9D002FAC  2402000A   ADDIU V0, ZERO, 10
9D002FB0  A3828020   SB V0, -32736(GP)
1388:                #else
1389:                        vBase=16;
1390:                #endif
1391:                        vState=0; vErrors=0;
9D002FB4  A380808E   SB ZERO, -32626(GP)
1392:                	FindLastC(); vHead=0; vHere=vDict; vHeap=vMem;
9D002FB8  0F400AA7   JAL FindLastC
9D002FBC  A380808F   SB ZERO, -32625(GP)
9D002FC0  AF808104   SW ZERO, -32508(GP)
9D002FC4  8F828084   LW V0, -32636(GP)
9D002FC8  AF8280FC   SW V0, -32516(GP)
9D002FCC  8F828088   LW V0, -32632(GP)
1393:                	// From flash init
1394:                	EEcold();
9D002FD0  0F400AB5   JAL EEcold
9D002FD4  AF82810C   SW V0, -32500(GP)
1395:                	ver();
9D002FD8  0F400970   JAL ver
9D002FDC  00000000   NOP
1396:                	quit();
9D002FE0  0F400B59   JAL quit
9D002FE4  00000000   NOP
1397:                }
9D002FE8  8FBF0014   LW RA, 20(SP)
9D002FEC  8FB00010   LW S0, 16(SP)
9D002FF0  03E00008   JR RA
9D002FF4  27BD0018   ADDIU SP, SP, 24
1398:                
1399:                
1400:                // ********** EMIT **********
1401:                
1402:                
1403:                // cr ( -- )
1404:                void crf(void) {PUSH(CRD); emit(); PUSH(CRA); emit();}
9D00257C  27BDFFE8   ADDIU SP, SP, -24
9D002580  AFBF0014   SW RA, 20(SP)
9D002584  8F828014   LW V0, -32748(GP)
9D002588  24430004   ADDIU V1, V0, 4
9D00258C  AF838014   SW V1, -32748(GP)
9D002590  2403000D   ADDIU V1, ZERO, 13
9D002594  0F4008B3   JAL emit
9D002598  AC430004   SW V1, 4(V0)
9D00259C  8F828014   LW V0, -32748(GP)
9D0025A0  24430004   ADDIU V1, V0, 4
9D0025A4  AF838014   SW V1, -32748(GP)
9D0025A8  2403000A   ADDIU V1, ZERO, 10
9D0025AC  0F4008B3   JAL emit
9D0025B0  AC430004   SW V1, 4(V0)
9D0025B4  8FBF0014   LW RA, 20(SP)
9D0025B8  03E00008   JR RA
9D0025BC  27BD0018   ADDIU SP, SP, 24
1405:                
1406:                
1407:                // space ( -- )
1408:                void spacef(void) {blf(); emit();}
9D002558  27BDFFE8   ADDIU SP, SP, -24
9D00255C  AFBF0014   SW RA, 20(SP)
9D002560  0F400318   JAL blf
9D002564  00000000   NOP
9D002568  0F4008B3   JAL emit
9D00256C  00000000   NOP
9D002570  8FBF0014   LW RA, 20(SP)
9D002574  03E00008   JR RA
9D002578  27BD0018   ADDIU SP, SP, 24
1409:                
1410:                
1411:                // spaces ( n -- )
1412:                void spaces(void) {cell i, n=POP; if (n>0) {for(i=0; i<n; i++) {blf(); emit();}}}
9D00239C  27BDFFE0   ADDIU SP, SP, -32
9D0023A0  AFBF001C   SW RA, 28(SP)
9D0023A4  AFB10018   SW S1, 24(SP)
9D0023A8  AFB00014   SW S0, 20(SP)
9D0023AC  8F828014   LW V0, -32748(GP)
9D0023B0  8C510000   LW S1, 0(V0)
9D0023B4  2442FFFC   ADDIU V0, V0, -4
9D0023B8  1A200008   BLEZ S1, 0x9D0023DC
9D0023BC  AF828014   SW V0, -32748(GP)
9D0023C0  00008021   ADDU S0, ZERO, ZERO
9D0023C4  0F400318   JAL blf
9D0023C8  26100001   ADDIU S0, S0, 1
9D0023CC  0F4008B3   JAL emit
9D0023D0  00000000   NOP
9D0023D4  1611FFFB   BNE S0, S1, 0x9D0023C4
9D0023D8  00000000   NOP
9D0023DC  8FBF001C   LW RA, 28(SP)
9D0023E0  8FB10018   LW S1, 24(SP)
9D0023E4  8FB00014   LW S0, 20(SP)
9D0023E8  03E00008   JR RA
9D0023EC  27BD0020   ADDIU SP, SP, 32
1413:                
1414:                
1415:                // type ( addr u -- )
1416:                void typef(void)
9D00232C  00718821   ADDU S1, V1, S1
1417:                {
9D0022F8  27BDFFE0   ADDIU SP, SP, -32
9D0022FC  AFBF001C   SW RA, 28(SP)
9D002300  AFB10018   SW S1, 24(SP)
9D002304  AFB00014   SW S0, 20(SP)
1418:                	ucell i, u=POP;
9D002308  8F828014   LW V0, -32748(GP)
9D00230C  8C430000   LW V1, 0(V0)
9D002310  2444FFFC   ADDIU A0, V0, -4
9D002314  AF848014   SW A0, -32748(GP)
1419:                	char *p=(char *)(ucell)POP;
9D002318  8C51FFFC   LW S1, -4(V0)
9D00231C  2442FFF8   ADDIU V0, V0, -8
9D002328  02208021   ADDU S0, S1, ZERO
1420:                
1421:                	if (u>0) {for(i=0; i<u; i++) {PUSH(*p++); emit();}}
9D002320  1060000C   BEQ V1, ZERO, 0x9D002354
9D002324  AF828014   SW V0, -32748(GP)
9D002330  8F828014   LW V0, -32748(GP)
9D002334  24430004   ADDIU V1, V0, 4
9D002338  AF838014   SW V1, -32748(GP)
9D00233C  82030000   LB V1, 0(S0)
9D002340  AC430004   SW V1, 4(V0)
9D002344  0F4008B3   JAL emit
9D002348  26100001   ADDIU S0, S0, 1
9D00234C  1611FFF9   BNE S0, S1, 0x9D002334
9D002350  8F828014   LW V0, -32748(GP)
1422:                }
9D002354  8FBF001C   LW RA, 28(SP)
9D002358  8FB10018   LW S1, 24(SP)
9D00235C  8FB00014   LW S0, 20(SP)
9D002360  03E00008   JR RA
9D002364  27BD0020   ADDIU SP, SP, 32
1423:                const void *xt_type=typef;
1424:                
1425:                
1426:                // ." ( -- )
1427:                void dotstring(void) {squote(); if (vState) {CompileCcon(&xt_type);} else {typef();}}
9D003500  27BDFFE8   ADDIU SP, SP, -24
9D003504  AFBF0014   SW RA, 20(SP)
9D003508  0F400C07   JAL squote
9D00350C  00000000   NOP
9D003510  9382808E   LBU V0, -32626(GP)
9D003514  10400005   BEQ V0, ZERO, 0x9D00352C
9D003518  00000000   NOP
9D00351C  0F400D36   JAL CompileCcon
9D003520  27848048   ADDIU A0, GP, -32696
9D003524  0B400D4E   J 0x9D003538
9D003528  8FBF0014   LW RA, 20(SP)
9D00352C  0F4008BE   JAL typef
9D003530  00000000   NOP
9D003534  8FBF0014   LW RA, 20(SP)
9D003538  03E00008   JR RA
9D00353C  27BD0018   ADDIU SP, SP, 24
1428:                
1429:                
1430:                // .( ( -- )
1431:                void dotlparen(void) {PUSH(')'); parse(); typef();}
9D002368  27BDFFE8   ADDIU SP, SP, -24
9D00236C  AFBF0014   SW RA, 20(SP)
9D002370  8F828014   LW V0, -32748(GP)
9D002374  24430004   ADDIU V1, V0, 4
9D002378  AF838014   SW V1, -32748(GP)
9D00237C  24030029   ADDIU V1, ZERO, 41
9D002380  0F40055A   JAL parse
9D002384  AC430004   SW V1, 4(V0)
9D002388  0F4008BE   JAL typef
9D00238C  00000000   NOP
9D002390  8FBF0014   LW RA, 20(SP)
9D002394  03E00008   JR RA
9D002398  27BD0018   ADDIU SP, SP, 24
1432:                
1433:                
1434:                // ( ( -- )
1435:                void lparen(void) {PUSH(')'); parse(); twodrop();}
9D0019E8  27BDFFE8   ADDIU SP, SP, -24
9D0019EC  AFBF0014   SW RA, 20(SP)
9D0019F0  8F828014   LW V0, -32748(GP)
9D0019F4  24430004   ADDIU V1, V0, 4
9D0019F8  AF838014   SW V1, -32748(GP)
9D0019FC  24030029   ADDIU V1, ZERO, 41
9D001A00  0F40055A   JAL parse
9D001A04  AC430004   SW V1, 4(V0)
9D001A08  0F40000C   JAL twodrop
9D001A0C  00000000   NOP
9D001A10  8FBF0014   LW RA, 20(SP)
9D001A14  03E00008   JR RA
9D001A18  27BD0018   ADDIU SP, SP, 24
1436:                
1437:                
1438:                // hold ( c -- )
1439:                void hold(void)
9D001A50  00042027   NOR A0, ZERO, A0
9D001A54  00442021   ADDU A0, V0, A0
1440:                {
1441:                	cell c=POP, len=vPad[0], i;
9D001A1C  8F828014   LW V0, -32748(GP)
9D001A20  8C450000   LW A1, 0(V0)
9D001A24  2442FFFC   ADDIU V0, V0, -4
9D001A28  AF828014   SW V0, -32748(GP)
9D001A2C  8F838080   LW V1, -32640(GP)
9D001A30  80640000   LB A0, 0(V1)
1442:                	char *p1, *p2;
1443:                
1444:                	if (len<padsize-1)
9D001A34  2882004F   SLTI V0, A0, 79
9D001A38  1040000C   BEQ V0, ZERO, 0x9D001A6C
9D001A3C  24820001   ADDIU V0, A0, 1
1445:                	{
1446:                	  len++; vPad[0]=len; p1=vPad+len; p2=p1++;
9D001A40  A0620000   SB V0, 0(V1)
9D001A4C  00621021   ADDU V0, V1, V0
1447:                	  for (i=0; i<len; i++) {*p1--=*p2--;}
9D001A44  18400009   BLEZ V0, 0x9D001A6C
9D001A48  8F838080   LW V1, -32640(GP)
9D001A58  90430000   LBU V1, 0(V0)
9D001A5C  A0430001   SB V1, 1(V0)
9D001A60  2442FFFF   ADDIU V0, V0, -1
9D001A64  5444FFFD   BNEL V0, A0, 0x9D001A5C
9D001A68  90430000   LBU V1, 0(V0)
1448:                	  //memmove(&vPad[1], &vPad[2], vPad[0]);
1449:                	}
1450:                	vPad[1]=c;
9D001A6C  8F828080   LW V0, -32640(GP)
1451:                }
9D001A70  03E00008   JR RA
9D001A74  A0450001   SB A1, 1(V0)
1452:                
1453:                
1454:                // <# ( -- )
1455:                void sharpl(void) {vPad[0]=0;}
9D001A78  8F828080   LW V0, -32640(GP)
9D001A7C  03E00008   JR RA
9D001A80  A0400000   SB ZERO, 0(V0)
1456:                
1457:                
1458:                // # ( x1 -- x2 )
1459:                void sharp(void)
1460:                {
9D001A84  27BDFFE8   ADDIU SP, SP, -24
9D001A88  AFBF0014   SW RA, 20(SP)
1461:                	cell x;
1462:                	base(); cfetch(); udivmod(); swap(); x=POP;
9D001A8C  0F4002FB   JAL base
9D001A90  00000000   NOP
9D001A94  0F4000CA   JAL cfetch
9D001A98  00000000   NOP
9D001A9C  0F4003F6   JAL udivmod
9D001AA0  00000000   NOP
9D001AA4  0F400055   JAL swap
9D001AA8  00000000   NOP
9D001AAC  8F838014   LW V1, -32748(GP)
9D001AB0  8C620000   LW V0, 0(V1)
1463:                	if (x>9) {x+=7;}
9D001AB4  2845000A   SLTI A1, V0, 10
9D001AB8  24440007   ADDIU A0, V0, 7
9D001ABC  0085100A   MOVZ V0, A0, A1
1464:                	PUSH(x+0x30); hold();
9D001AC0  24420030   ADDIU V0, V0, 48
9D001AC4  0F400687   JAL hold
9D001AC8  AC620000   SW V0, 0(V1)
1465:                }
9D001ACC  8FBF0014   LW RA, 20(SP)
9D001AD0  03E00008   JR RA
9D001AD4  27BD0018   ADDIU SP, SP, 24
1466:                
1467:                
1468:                // #s ( x -- 0 )
1469:                void sharps(void) {do{sharp();} while (TOS!=0);}
9D001AD8  27BDFFE8   ADDIU SP, SP, -24
9D001ADC  AFBF0014   SW RA, 20(SP)
9D001AE0  0F4006A1   JAL sharp
9D001AE4  00000000   NOP
9D001AE8  8F828014   LW V0, -32748(GP)
9D001AEC  8C420000   LW V0, 0(V0)
9D001AF0  1440FFFB   BNE V0, ZERO, 0x9D001AE0
9D001AF4  8FBF0014   LW RA, 20(SP)
9D001AF8  03E00008   JR RA
9D001AFC  27BD0018   ADDIU SP, SP, 24
1470:                
1471:                
1472:                // #> ( x -- addr len )
1473:                void sharpg(void) {TOS=(ucell)vPad; count();}
9D001B00  27BDFFE8   ADDIU SP, SP, -24
9D001B04  AFBF0014   SW RA, 20(SP)
9D001B08  8F838080   LW V1, -32640(GP)
9D001B0C  8F828014   LW V0, -32748(GP)
9D001B10  0F400504   JAL count
9D001B14  AC430000   SW V1, 0(V0)
9D001B18  8FBF0014   LW RA, 20(SP)
9D001B1C  03E00008   JR RA
9D001B20  27BD0018   ADDIU SP, SP, 24
1474:                
1475:                
1476:                // u.r ( u n -- )
1477:                void udotr(void)
1478:                {
9D002484  27BDFFE8   ADDIU SP, SP, -24
9D002488  AFBF0014   SW RA, 20(SP)
9D00248C  AFB00010   SW S0, 16(SP)
1479:                	cell n=POP, len;
9D002490  8F828014   LW V0, -32748(GP)
9D002494  8C500000   LW S0, 0(V0)
9D002498  2442FFFC   ADDIU V0, V0, -4
1480:                	sharpl(); sharps(); sharpg(); len=TOS; // ( u -- addr len )
9D00249C  0F40069E   JAL sharpl
9D0024A0  AF828014   SW V0, -32748(GP)
9D0024A4  0F4006B6   JAL sharps
9D0024A8  00000000   NOP
9D0024AC  0F4006C0   JAL sharpg
9D0024B0  00000000   NOP
9D0024B4  8F828014   LW V0, -32748(GP)
9D0024B8  8C430000   LW V1, 0(V0)
1481:                	PUSH(n-len); spaces(); typef();
9D0024BC  24440004   ADDIU A0, V0, 4
9D0024C0  AF848014   SW A0, -32748(GP)
9D0024C4  02038023   SUBU S0, S0, V1
9D0024C8  0F4008E7   JAL spaces
9D0024CC  AC500004   SW S0, 4(V0)
9D0024D0  0F4008BE   JAL typef
9D0024D4  00000000   NOP
1482:                }
9D0024D8  8FBF0014   LW RA, 20(SP)
9D0024DC  8FB00010   LW S0, 16(SP)
9D0024E0  03E00008   JR RA
9D0024E4  27BD0018   ADDIU SP, SP, 24
1483:                
1484:                
1485:                // u. ( u -- )
1486:                void udot(void) {PUSH(0); udotr(); blf(); emit();}
9D002520  27BDFFE8   ADDIU SP, SP, -24
9D002524  AFBF0014   SW RA, 20(SP)
9D002528  8F828014   LW V0, -32748(GP)
9D00252C  24430004   ADDIU V1, V0, 4
9D002530  AF838014   SW V1, -32748(GP)
9D002534  0F400921   JAL udotr
9D002538  AC400004   SW ZERO, 4(V0)
9D00253C  0F400318   JAL blf
9D002540  00000000   NOP
9D002544  0F4008B3   JAL emit
9D002548  00000000   NOP
9D00254C  8FBF0014   LW RA, 20(SP)
9D002550  03E00008   JR RA
9D002554  27BD0018   ADDIU SP, SP, 24
1487:                
1488:                
1489:                // .r ( n1 n2 -- )
1490:                void dotr(void)
1491:                {
9D0023F0  27BDFFE0   ADDIU SP, SP, -32
9D0023F4  AFBF001C   SW RA, 28(SP)
9D0023F8  AFB10018   SW S1, 24(SP)
9D0023FC  AFB00014   SW S0, 20(SP)
1492:                	cell n2=POP, n1=TOS, len;
9D002400  8F828014   LW V0, -32748(GP)
9D002404  8C510000   LW S1, 0(V0)
9D002408  2443FFFC   ADDIU V1, V0, -4
9D00240C  AF838014   SW V1, -32748(GP)
1493:                	absf(); sharpl(); sharps(); if (n1<0) {PUSH('-'); hold();}
9D002410  0F4001B6   JAL absf
9D002414  8C50FFFC   LW S0, -4(V0)
9D002418  0F40069E   JAL sharpl
9D00241C  00000000   NOP
9D002420  0F4006B6   JAL sharps
9D002424  00000000   NOP
9D002428  06010006   BGEZ S0, 0x9D002444
9D00242C  8F828014   LW V0, -32748(GP)
9D002430  24430004   ADDIU V1, V0, 4
9D002434  AF838014   SW V1, -32748(GP)
9D002438  2403002D   ADDIU V1, ZERO, 45
9D00243C  0F400687   JAL hold
9D002440  AC430004   SW V1, 4(V0)
1494:                	sharpg(); len=TOS; // ( u -- addr len )
9D002444  0F4006C0   JAL sharpg
9D002448  00000000   NOP
9D00244C  8F828014   LW V0, -32748(GP)
9D002450  8C430000   LW V1, 0(V0)
1495:                	PUSH(n2-len); spaces(); typef();
9D002454  24440004   ADDIU A0, V0, 4
9D002458  AF848014   SW A0, -32748(GP)
9D00245C  02238823   SUBU S1, S1, V1
9D002460  0F4008E7   JAL spaces
9D002464  AC510004   SW S1, 4(V0)
9D002468  0F4008BE   JAL typef
9D00246C  00000000   NOP
1496:                }
9D002470  8FBF001C   LW RA, 28(SP)
9D002474  8FB10018   LW S1, 24(SP)
9D002478  8FB00014   LW S0, 20(SP)
9D00247C  03E00008   JR RA
9D002480  27BD0020   ADDIU SP, SP, 32
1497:                
1498:                
1499:                // . ( n -- )
1500:                void dot(void) {PUSH(0); dotr(); blf(); emit();}
9D0024E8  27BDFFE8   ADDIU SP, SP, -24
9D0024EC  AFBF0014   SW RA, 20(SP)
9D0024F0  8F828014   LW V0, -32748(GP)
9D0024F4  24430004   ADDIU V1, V0, 4
9D0024F8  AF838014   SW V1, -32748(GP)
9D0024FC  0F4008FC   JAL dotr
9D002500  AC400004   SW ZERO, 4(V0)
9D002504  0F400318   JAL blf
9D002508  00000000   NOP
9D00250C  0F4008B3   JAL emit
9D002510  00000000   NOP
9D002514  8FBF0014   LW RA, 20(SP)
9D002518  03E00008   JR RA
9D00251C  27BD0018   ADDIU SP, SP, 24
1501:                
1502:                
1503:                // \ ( -- )
1504:                void backslash(void) {vIN=vSharpTib;}
9D001B24  9382808D   LBU V0, -32627(GP)
9D001B28  03E00008   JR RA
9D001B2C  A382808C   SB V0, -32628(GP)
1505:                
1506:                
1507:                // dump ( addr u -- )
1508:                void dump(void)
1509:                {
9D0027F8  27BDFFD8   ADDIU SP, SP, -40
9D0027FC  AFBF0024   SW RA, 36(SP)
9D002800  AFB30020   SW S3, 32(SP)
9D002804  AFB2001C   SW S2, 28(SP)
9D002808  AFB10018   SW S1, 24(SP)
9D00280C  AFB00014   SW S0, 20(SP)
1510:                	ucell i, u=POP;
9D002810  8F828014   LW V0, -32748(GP)
9D002814  8C520000   LW S2, 0(V0)
9D002818  2443FFFC   ADDIU V1, V0, -4
9D00281C  AF838014   SW V1, -32748(GP)
1511:                	ucell *p=(ucell *)POP;
9D002820  8C50FFFC   LW S0, -4(V0)
9D002824  2442FFF8   ADDIU V0, V0, -8
9D002830  00008821   ADDU S1, ZERO, ZERO
1512:                
1513:                	if (u>0) {for(i=0; i<u; i++)
9D002828  12400017   BEQ S2, ZERO, 0x9D002888
9D00282C  AF828014   SW V0, -32748(GP)
9D002880  1651FFEE   BNE S2, S1, 0x9D00283C
9D002884  8F828014   LW V0, -32748(GP)
1514:                	{
1515:                	  PUSH(*p++);
9D002838  8F828014   LW V0, -32748(GP)
9D00283C  24430004   ADDIU V1, V0, 4
9D002840  AF838014   SW V1, -32748(GP)
9D002844  8E030000   LW V1, 0(S0)
9D002848  AC430004   SW V1, 4(V0)
1516:                	  if (vBase==10) {dot();} else {udot();}
9D002834  2413000A   ADDIU S3, ZERO, 10
9D00284C  93828020   LBU V0, -32736(GP)
9D002850  14530005   BNE V0, S3, 0x9D002868
9D002854  26100004   ADDIU S0, S0, 4
9D002858  0F40093A   JAL dot
9D00285C  00000000   NOP
9D002860  0B400A1C   J 0x9D002870
9D002864  00000000   NOP
9D002868  0F400948   JAL udot
9D00286C  00000000   NOP
1517:                	  blf(); emit();
9D002870  0F400318   JAL blf
9D002874  26310001   ADDIU S1, S1, 1
9D002878  0F4008B3   JAL emit
9D00287C  00000000   NOP
1518:                	}}
1519:                	crf();
9D002888  0F40095F   JAL crf
9D00288C  00000000   NOP
1520:                }
9D002890  8FBF0024   LW RA, 36(SP)
9D002894  8FB30020   LW S3, 32(SP)
9D002898  8FB2001C   LW S2, 28(SP)
9D00289C  8FB10018   LW S1, 24(SP)
9D0028A0  8FB00014   LW S0, 20(SP)
9D0028A4  03E00008   JR RA
9D0028A8  27BD0028   ADDIU SP, SP, 40
1521:                
1522:                
1523:                // .s ( -- )
1524:                void dots(void)
1525:                {
9D00274C  27BDFFD8   ADDIU SP, SP, -40
9D002750  AFBF0024   SW RA, 36(SP)
9D002754  AFB30020   SW S3, 32(SP)
9D002758  AFB2001C   SW S2, 28(SP)
9D00275C  AFB10018   SW S1, 24(SP)
9D002760  AFB00014   SW S0, 20(SP)
1526:                	cell i, n=DScnt;
9D002764  8F908010   LW S0, -32752(GP)
9D002768  8F928014   LW S2, -32748(GP)
9D00276C  02509023   SUBU S2, S2, S0
9D002770  00129083   SRA S2, S2, 2
1527:                	ucell *p=(ucell *)pDSzero;
1528:                
1529:                	if (n>0) {for(i=0; i<n; i++)
9D002774  1A400017   BLEZ S2, 0x9D0027D4
9D002778  00008821   ADDU S1, ZERO, ZERO
9D0027CC  1632FFED   BNE S1, S2, 0x9D002784
9D0027D0  8F828014   LW V0, -32748(GP)
1530:                	{
1531:                	  PUSH(*++p);
9D002780  8F828014   LW V0, -32748(GP)
9D002784  24430004   ADDIU V1, V0, 4
9D002788  AF838014   SW V1, -32748(GP)
9D00278C  26100004   ADDIU S0, S0, 4
9D002790  8E030000   LW V1, 0(S0)
9D002794  AC430004   SW V1, 4(V0)
1532:                	  if (vBase==10) {dot();} else {udot();}
9D00277C  2413000A   ADDIU S3, ZERO, 10
9D002798  93828020   LBU V0, -32736(GP)
9D00279C  14530005   BNE V0, S3, 0x9D0027B4
9D0027A0  00000000   NOP
9D0027A4  0F40093A   JAL dot
9D0027A8  00000000   NOP
9D0027AC  0B4009EF   J 0x9D0027BC
9D0027B0  00000000   NOP
9D0027B4  0F400948   JAL udot
9D0027B8  00000000   NOP
1533:                	  blf(); emit();
9D0027BC  0F400318   JAL blf
9D0027C0  26310001   ADDIU S1, S1, 1
9D0027C4  0F4008B3   JAL emit
9D0027C8  00000000   NOP
1534:                	}}
1535:                	crf();
9D0027D4  0F40095F   JAL crf
9D0027D8  00000000   NOP
1536:                }
9D0027DC  8FBF0024   LW RA, 36(SP)
9D0027E0  8FB30020   LW S3, 32(SP)
9D0027E4  8FB2001C   LW S2, 28(SP)
9D0027E8  8FB10018   LW S1, 24(SP)
9D0027EC  8FB00014   LW S0, 20(SP)
9D0027F0  03E00008   JR RA
9D0027F4  27BD0028   ADDIU SP, SP, 40
1537:                
1538:                
1539:                // ver ( -- )
1540:                void ver(void) {
9D0025C0  27BDFFE8   ADDIU SP, SP, -24
9D0025C4  AFBF0014   SW RA, 20(SP)
1541:                #ifdef VPC_32
1542:                    print(comm_channel,StrVer);
9D0025C8  83848064   LB A0, -32668(GP)
9D0025CC  3C059D00   LUI A1, -25344
9D0025D0  0F402601   JAL print
9D0025D4  24A56A34   ADDIU A1, A1, 27188
1543:                    crf();
9D0025D8  0F40095F   JAL crf
9D0025DC  00000000   NOP
1544:                #else
1545:                    UARTwriteS(UARTcon,StrVer); crf();
1546:                #endif
1547:                }
9D0025E0  8FBF0014   LW RA, 20(SP)
9D0025E4  03E00008   JR RA
9D0025E8  27BD0018   ADDIU SP, SP, 24
1548:                
1549:                
1550:                // ********** VOCABULARY **********
1551:                
1552:                
1553:                // words ( -- )
1554:                void wordsf(void)
9D002634  26510005   ADDIU S1, S2, 5
9D002638  3042FFFF   ANDI V0, V0, -1
9D00263C  02228821   ADDU S1, S1, V0
1555:                {
9D0025EC  27BDFFD8   ADDIU SP, SP, -40
9D0025F0  AFBF0024   SW RA, 36(SP)
9D0025F4  AFB40020   SW S4, 32(SP)
9D0025F8  AFB3001C   SW S3, 28(SP)
9D0025FC  AFB20018   SW S2, 24(SP)
9D002600  AFB10014   SW S1, 20(SP)
9D002604  AFB00010   SW S0, 16(SP)
1556:                	short int i=PrimLast, j, len;
1557:                	char  *p;
1558:                	ucell *Link, Linkbak, k=0;
1559:                
1560:                	if (vHead) {Link=(ucell *)vHead; k=1;}	// Link to last word
9D002608  8F928104   LW S2, -32508(GP)
9D00260C  12400026   BEQ S2, ZERO, 0x9D0026A8
9D002610  87938090   LH S3, -32624(GP)
1561:                	while (k)								// Forth words
1562:                	{
1563:                	  len=(short int)(*Link>>24)&0x1F ;
9D002618  92420003   LBU V0, 3(S2)
9D00261C  3042001F   ANDI V0, V0, 31
1564:                	  if (len)								// Length?
9D002620  50400015   BEQL V0, ZERO, 0x9D002678
9D002624  8E430000   LW V1, 0(S2)
1565:                	  {
1566:                		  Linkbak=(ucell)Link+cellsize;		// Begin of name
9D002630  26500004   ADDIU S0, S2, 4
1567:                		  j=len; p=(char *)Linkbak;
1568:                		  for(j=0; j<len; j++) {PUSH(*p++); emit();}
9D002628  1840000E   BLEZ V0, 0x9D002664
9D00262C  2442FFFF   ADDIU V0, V0, -1
9D002640  8F828014   LW V0, -32748(GP)
9D002644  24430004   ADDIU V1, V0, 4
9D002648  AF838014   SW V1, -32748(GP)
9D00264C  82030000   LB V1, 0(S0)
9D002650  AC430004   SW V1, 4(V0)
9D002654  0F4008B3   JAL emit
9D002658  26100001   ADDIU S0, S0, 1
9D00265C  1611FFF9   BNE S0, S1, 0x9D002644
9D002660  8F828014   LW V0, -32748(GP)
1569:                		  blf(); emit();
9D002664  0F400318   JAL blf
9D002668  00000000   NOP
9D00266C  0F4008B3   JAL emit
9D002670  00000000   NOP
1570:                	  }
1571:                	  if (k) {Linkbak=*Link&0x7FFFFF;} else {Linkbak=0;}	// Last,zero?
9D002674  8E430000   LW V1, 0(S2)
9D002678  7C62B000   EXT V0, V1, 0, 23
1572:                	  if (!Linkbak) {k=0;}
9D00267C  1040000A   BEQ V0, ZERO, 0x9D0026A8
9D002680  00741824   AND V1, V1, S4
1573:                	  if (k)
1574:                	  {
1575:                		if (*Link&0x800000) {Linkbak+=AddrRAM<<24;} else {Linkbak+=AddrROM<<24;}
9D002614  3C140080   LUI S4, 128
9D002684  50600005   BEQL V1, ZERO, 0x9D00269C
9D002688  939280F4   LBU S2, -32524(GP)
9D00268C  939280F5   LBU S2, -32523(GP)
9D002690  00129600   SLL S2, S2, 24
9D002694  0B400986   J 0x9D002618
9D002698  00529021   ADDU S2, V0, S2
9D00269C  00129600   SLL S2, S2, 24
9D0026A0  0B400986   J 0x9D002618
9D0026A4  00529021   ADDU S2, V0, S2
1576:                		Link=(ucell *)Linkbak;
1577:                	  }
1578:                	}
1579:                
1580:                	if (primwords[i].wlen&pr)  // Primitives?
9D0026A8  3C029D00   LUI V0, -25344
9D0026AC  24437008   ADDIU V1, V0, 28680
9D0026B0  2402000C   ADDIU V0, ZERO, 12
9D0026B4  72622002   MUL A0, S3, V0
9D0026B8  00831021   ADDU V0, A0, V1
9D0026BC  94420002   LHU V0, 2(V0)
9D0026C0  30420020   ANDI V0, V0, 32
9D0026C4  10400017   BEQ V0, ZERO, 0x9D002724
9D0026C8  00000000   NOP
1581:                	{
1582:                	 while(i>=0)
9D0026CC  06600015   BLTZ S3, 0x9D002724
9D0026D0  2410000C   ADDIU S0, ZERO, 12
9D0026D8  2412FFFF   ADDIU S2, ZERO, -1
9D00271C  1672FFF0   BNE S3, S2, 0x9D0026E0
9D002720  72701802   MUL V1, S3, S0
1583:                	 {
1584:                	  if (primwords[i].wlen&0x1F)  // Length?
9D0026D4  00608821   ADDU S1, V1, ZERO
9D0026DC  72701802   MUL V1, S3, S0
9D0026E0  00711021   ADDU V0, V1, S1
9D0026E4  94420002   LHU V0, 2(V0)
9D0026E8  3042001F   ANDI V0, V0, 31
9D0026EC  5040000A   BEQL V0, ZERO, 0x9D002718
9D0026F0  2673FFFF   ADDIU S3, S3, -1
1585:                	  {
1586:                #ifdef VPC_32
1587:                                print(comm_channel,primwords[i].wname);
9D0026F4  72701802   MUL V1, S3, S0
9D0026F8  00711021   ADDU V0, V1, S1
9D0026FC  83848064   LB A0, -32668(GP)
9D002700  0F402601   JAL print
9D002704  8C450004   LW A1, 4(V0)
1588:                #else
1589:                		UARTwriteS(UARTcon,primwords[i].wname);
1590:                #endif
1591:                		blf(); emit();
9D002708  0F400318   JAL blf
9D00270C  2673FFFF   ADDIU S3, S3, -1
9D002710  0F4008B3   JAL emit
9D002714  00000000   NOP
1592:                	  }
1593:                	 i--;
9D002718  7C139E20   SEH S3, S3
1594:                	 }
1595:                	} crf();
9D002724  0F40095F   JAL crf
9D002728  00000000   NOP
1596:                }
9D00272C  8FBF0024   LW RA, 36(SP)
9D002730  8FB40020   LW S4, 32(SP)
9D002734  8FB3001C   LW S3, 28(SP)
9D002738  8FB20018   LW S2, 24(SP)
9D00273C  8FB10014   LW S1, 20(SP)
9D002740  8FB00010   LW S0, 16(SP)
9D002744  03E00008   JR RA
9D002748  27BD0028   ADDIU SP, SP, 40
1597:                
1598:                
1599:                // ********** DEVICE **********
1600:                
1601:                
1602:                // coretim ( -- u )
1603:                void coretim(void) {PUSH(ReadCoreTimer());}
9D001C40  27BDFFE8   ADDIU SP, SP, -24
9D001C44  AFBF0014   SW RA, 20(SP)
9D001C48  AFB00010   SW S0, 16(SP)
9D001C4C  8F908014   LW S0, -32748(GP)
9D001C50  26020004   ADDIU V0, S0, 4
9D001C54  0F40400B   JAL ReadCoreTimer
9D001C58  AF828014   SW V0, -32748(GP)
9D001C5C  AE020004   SW V0, 4(S0)
9D001C60  8FBF0014   LW RA, 20(SP)
9D001C64  8FB00010   LW S0, 16(SP)
9D001C68  03E00008   JR RA
9D001C6C  27BD0018   ADDIU SP, SP, 24
1604:                
1605:                
1606:                // ms ( u -- )
1607:                void msec(void) {delay_us(POP*1000);}
9D001C10  27BDFFE8   ADDIU SP, SP, -24
9D001C14  AFBF0014   SW RA, 20(SP)
9D001C18  8F828014   LW V0, -32748(GP)
9D001C1C  8C440000   LW A0, 0(V0)
9D001C20  2442FFFC   ADDIU V0, V0, -4
9D001C24  AF828014   SW V0, -32748(GP)
9D001C28  240203E8   ADDIU V0, ZERO, 1000
9D001C2C  0F40355F   JAL delay_us
9D001C30  70822002   MUL A0, A0, V0
9D001C34  8FBF0014   LW RA, 20(SP)
9D001C38  03E00008   JR RA
9D001C3C  27BD0018   ADDIU SP, SP, 24
1608:                
1609:                
1610:                // flash ( -- )
1611:                void flash(void)
1612:                {
9D001BD4  27BDFFE8   ADDIU SP, SP, -24
9D001BD8  AFBF0014   SW RA, 20(SP)
1613:                	NVMopen(vFHere);
9D001BDC  0F4031B2   JAL NVMopen
9D001BE0  8F848114   LW A0, -32492(GP)
1614:                	vHereBak=vHere; vHere=(char*)vFHere;	// Swap RAM/ROM
9D001BE4  8F8280FC   LW V0, -32516(GP)
9D001BE8  AF8280F8   SW V0, -32520(GP)
9D001BEC  8F828114   LW V0, -32492(GP)
9D001BF0  AF8280FC   SW V0, -32516(GP)
1615:                	vHeadBak=vHead; vHead=(char*)vFHead;
9D001BF4  8F828104   LW V0, -32508(GP)
9D001BF8  AF8280F0   SW V0, -32528(GP)
9D001BFC  8F828118   LW V0, -32488(GP)
9D001C00  AF828104   SW V0, -32508(GP)
1616:                }
9D001C04  8FBF0014   LW RA, 20(SP)
9D001C08  03E00008   JR RA
9D001C0C  27BD0018   ADDIU SP, SP, 24
1617:                
1618:                
1619:                // >flash ( -- )
1620:                void toflash(void)
1621:                {
9D001BA0  27BDFFE8   ADDIU SP, SP, -24
9D001BA4  AFBF0014   SW RA, 20(SP)
1622:                	if (!NVMflushBuf()) {vErrors|=0x10; abortf();}	// Copy Buf to flash
9D001BA8  0F4031FE   JAL NVMflushBuf
9D001BAC  00000000   NOP
9D001BB0  14400006   BNE V0, ZERO, 0x9D001BCC
9D001BB4  8FBF0014   LW RA, 20(SP)
9D001BB8  9382808F   LBU V0, -32625(GP)
9D001BBC  34420010   ORI V0, V0, 16
9D001BC0  0F400360   JAL abortf
9D001BC4  A382808F   SB V0, -32625(GP)
1623:                }
9D001BC8  8FBF0014   LW RA, 20(SP)
9D001BCC  03E00008   JR RA
9D001BD0  27BD0018   ADDIU SP, SP, 24
1624:                
1625:                
1626:                // ;flash ( -- )
1627:                void endflash(void)
1628:                {
9D001F80  27BDFFE8   ADDIU SP, SP, -24
9D001F84  AFBF0014   SW RA, 20(SP)
1629:                	ucell Bak;
1630:                
1631:                	PUSH((ucell)vHeap); comma();
9D001F88  8F828014   LW V0, -32748(GP)
9D001F8C  24430004   ADDIU V1, V0, 4
9D001F90  AF838014   SW V1, -32748(GP)
9D001F94  8F83810C   LW V1, -32500(GP)
9D001F98  0F4007C2   JAL comma
9D001F9C  AC430004   SW V1, 4(V0)
1632:                	PUSH((ucell)vHead); comma();
9D001FA0  8F828014   LW V0, -32748(GP)
9D001FA4  24430004   ADDIU V1, V0, 4
9D001FA8  AF838014   SW V1, -32748(GP)
9D001FAC  8F838104   LW V1, -32508(GP)
9D001FB0  0F4007C2   JAL comma
9D001FB4  AC430004   SW V1, 4(V0)
1633:                	PUSH((ucell)vHere); comma();
9D001FB8  8F828014   LW V0, -32748(GP)
9D001FBC  24430004   ADDIU V1, V0, 4
9D001FC0  AF838014   SW V1, -32748(GP)
9D001FC4  8F8380FC   LW V1, -32516(GP)
9D001FC8  0F4007C2   JAL comma
9D001FCC  AC430004   SW V1, 4(V0)
1634:                	vFHead=(ucell*)vHead; vHead=vHeadBak;		// Swap RAM/ROM
9D001FD0  8F838104   LW V1, -32508(GP)
9D001FD4  AF838118   SW V1, -32488(GP)
9D001FD8  8F8280F0   LW V0, -32528(GP)
9D001FDC  AF828104   SW V0, -32508(GP)
1635:                	vHere=vHereBak;	
9D001FE0  8F8280F8   LW V0, -32520(GP)
9D001FE4  AF8280FC   SW V0, -32516(GP)
1636:                	
1637:                	Bak=*(ucell *)vDict&0xFF000000;				// Update link RAM to FHead
9D001FE8  8F828084   LW V0, -32636(GP)
9D001FEC  8C450000   LW A1, 0(V0)
9D001FF0  3C04FF00   LUI A0, -256
9D001FF4  00A42024   AND A0, A1, A0
1638:                	Bak|=((ucell)vFHead&0x7FFFFF); *(ucell *)vDict=Bak;
9D001FF8  7C63B000   EXT V1, V1, 0, 23
9D001FFC  00641825   OR V1, V1, A0
9D002000  AC430000   SW V1, 0(V0)
1639:                	if (!(ucell)vHead) {vHead=(char*)vFHead;};	// Head=0?, Head=FHead;
9D002004  8F828104   LW V0, -32508(GP)
9D002008  14400002   BNE V0, ZERO, 0x9D002014
9D00200C  8F828118   LW V0, -32488(GP)
9D002010  AF828104   SW V0, -32508(GP)
1640:                
1641:                	NVMclose();
9D002014  0F40320D   JAL NVMclose
9D002018  00000000   NOP
1642:                }
9D00201C  8FBF0014   LW RA, 20(SP)
9D002020  03E00008   JR RA
9D002024  27BD0018   ADDIU SP, SP, 24
1643:                
1644:                #ifndef VPC_32
1645:                // devhead (  -- u )
1646:                void devhead(void) {PUSH((ucell)DevHead);}
1647:                
1648:                
1649:                // devcall ( u1 u2 -- )		// u1-ptr DevTabxxx, u2-index fce
1650:                void devcall(void)			// 0 ADC 4 devcall (readADC)
1651:                {
1652:                	ucell index=POP;
1653:                	void (*pFce)(void *)=(void *)*(ucell *)((index<<2)+POP);
1654:                	(*pFce)((void *)pDS);
1655:                }
1656:                #endif
1657:                
1658:                // c call ( u1 u2 -- )  	// u1-ptr data, u2-ptr C function
1659:                void ccall(void)			// 0 sp@ ADC 10 + @ ccall (readADC)
1660:                {
9D001B30  27BDFFE8   ADDIU SP, SP, -24
9D001B34  AFBF0014   SW RA, 20(SP)
1661:                	void (*pFce)(void *)=(void *)POP;
9D001B38  8F838014   LW V1, -32748(GP)
9D001B3C  8C620000   LW V0, 0(V1)
9D001B40  2464FFFC   ADDIU A0, V1, -4
9D001B44  AF848014   SW A0, -32748(GP)
1662:                	(*pFce)((void *)POP);
9D001B48  8C64FFFC   LW A0, -4(V1)
9D001B4C  2463FFF8   ADDIU V1, V1, -8
9D001B50  0040F809   JALR V0
9D001B54  AF838014   SW V1, -32748(GP)
1663:                }
9D001B58  8FBF0014   LW RA, 20(SP)
9D001B5C  03E00008   JR RA
9D001B60  27BD0018   ADDIU SP, SP, 24
1664:                
1665:                #ifndef VPC_32
1666:                // device TIM1 ( -- addr )
1667:                void devTIM1(void) {PUSH((ucell)DevTab[0].dcall);}
1668:                
1669:                // device COM ( -- addr )
1670:                void devCOM(void) {PUSH((ucell)DevTab[1].dcall);}
1671:                
1672:                // device PIN ( -- addr )
1673:                void devPIN(void) {PUSH((ucell)DevTab[2].dcall);}
1674:                
1675:                // device ADC ( -- addr )
1676:                void devADC(void) {PUSH((ucell)DevTab[3].dcall);}
1677:                
1678:                // device PWM ( -- addr )
1679:                void devPWM(void) {PUSH((ucell)DevTab[4].dcall);}
1680:                #endif
1681:                
1682:                // ********** DICTIONARY **********
1683:                
1684:                const PRIMWORD primwords[] =
1685:                {	// VMcore
1686:                	{0,pr|6,"(exit)",exitw}, {1,pr|7,"execute",executew}, {2,pr|0,"",nextw}, {3,pr|7,"(colon)",enterw},
1687:                	{4,pr|5,"(lit)",dolitw}, {5,pr|6,"(slit)",doslitw}, {6,pr|5,"(con)",doconw}, {7,pr|5,"(var)",dovarw},
1688:                	{8,pr|6,"(does)",dodoes}, {9,pr|7,"(defer)",dodefer}, {10,pr|4,"(do)",dodo}, {11,pr|5,"(?do)",doisdo},
1689:                	{12,pr|6,"(loop)",doloop}, {13,pr|7,"(+loop)",doplusloop}, {14,pr|8,"(branch)",dobranch}, {15,pr|9,"(?branch)",docbranch},
1690:                	{16,pr|5,"(val)",dovalw},
1691:                	// Stack
1692:                	{1,pr|4,"drop",drop}, {2,pr|5,"2drop",twodrop}, {3,pr|3,"dup",dup}, {4,pr|4,"2dup",twodup},
1693:                	{5,pr|4,"?dup",isdup}, {6,pr|3,"nip",nip}, {7,pr|4,"over",over}, {8,pr|5,"2over",twoover},
1694:                	{9,pr|4,"pick",pick}, {10,pr|5,"stick",stick}, {11,pr|4,"roll",roll}, {12,pr|5,"-roll",minusroll},
1695:                	{13,pr|3,"rot",rot}, {14,pr|4,"-rot",minusrot}, {15,pr|4,"swap",swap}, {16,pr|5,"2swap",twoswap},
1696:                	{17,pr|2,">r",tor}, {18,pr|2,"r>",rfrom}, {19,pr|2,"r@",rfetch}, {20,pr|5,"depth",depth},
1697:                	{21,pr|6,"depth!",depthwrite}, {22,pr|6,"rdepth",rdepth}, {23,pr|7,"rdepth!",rdepthwrite},
1698:                	{24,pr|3,"sp@",spfetch}, {25,pr|3,"rp@",rpfetch},
1699:                	// Other
1700:                	{1,pr|4,"emit",emit},
1701:                #ifndef VPC_32
1702:                        {2,pr|5,"?emit",isemit},
1703:                #endif
1704:                        {3,pr|3,"key",key}, {4,pr|4,"?key",iskey},
1705:                	{5,pr|1,"i",loop_i}, {6,pr|1,"j",loop_j},  {7,pr|1,"k",loop_k}, {8,pr|3,"nop",nop},
1706:                 	// Memory
1707:                	{1,pr|1,"@",fetch}, {2,pr|2,"c@",cfetch}, {3,pr|2,"w@",wfetch}, {4,pr|1,"!",store},
1708:                	{5,pr|2,"c!",cstore}, {6,pr|2,"w!",wstore}, {7,pr|2,"+!",plusstore},
1709:                	{8,pr|4,"fill",fillf}, {9,pr|4,"move",movef}, {10,pr|4,"here",here}, {11,pr|5,"here!",herewrite},
1710:                	{12,pr|4,"head",head}, {13,pr|5,"head!",headwrite}, {14,pr|4,"heap",heap}, {15,pr|5,"heap!",heapwrite},
1711:                	// Arithmetic
1712:                	{1,pr|1,"+",plus}, {2,pr|1,"-",minus}, {3,pr|2,"d+",dplus}, {4,pr|2,"d-",dminus},
1713:                	{5,pr|1,"*",mult}, {6,pr|2,"m*",mmult}, {7,pr|3,"um*",ummult}, {8,pr|4,"sqrt",sqrtu},
1714:                	{9,pr|6,"um/mod",umdivmod}, {10,pr|5,"m/mod",mdivmod}, {11,pr|5,"u/mod",udivmod}, {12,pr|4,"/mod",divmod},
1715:                	{13,pr|1,"/",divf}, {14,pr|3,"mod",modn}, {15,pr|3,"u*/",umuldiv}, {16,pr|2,"*/",muldiv},
1716:                	{17,pr|3,">>a",arshift}, {18,pr|2,">>",rshift}, {19,pr|2,"<<",lshift}, {20,pr|2,"2*",twomul},
1717:                	{21,pr|2,"2/",twodiv}, {22,pr|3,"min",minf}, {23,pr|3,"max",maxf}, {24,pr|3,"abs",absf},
1718:                	{25,pr|2,"1+",incf}, {26,pr|2,"1-",decf}, {27,pr|6,"negate",negate}, {28,pr|6,"invert",invert},
1719:                	{29,pr|3,"and",andf}, {30,pr|2,"or",orf}, {31,pr|3,"xor",xorf},
1720:                	// Logic
1721:                	{1,pr|4,"andl",andl}, {2,pr|3,"orl",orl}, {3,pr|3,"not",notl}, {4,pr|1,"=",equals},
1722:                	{5,pr|2,"<>",notequals}, {6,pr|1,">",greater}, {7,pr|1,"<",less}, {8,pr|2,">=",greaterequals},
1723:                	{9,pr|2,"<=",lessequals}, {10,pr|2,"0=",zeroequals}, {11,pr|2,"0<",zeroless}, {12,pr|2,"0>",zerogreater},
1724:                	{13,pr|2,"u>",ugreater}, {14,pr|2,"u<",uless}, {15,pr|3,"u>=",ugreaterequals}, {16,pr|3,"u<=",ulessequals},
1725:                	{17,pr|2,"d=",dequals}, {18,pr|3,"d<>",dnotequals}, {19,pr|2,"d>",dgreater}, {20,pr|2,"d<",dless},
1726:                	{21,pr|6,"within",within},
1727:                
1728:                	// High FORTH
1729:                	// Variable
1730:                	{1,pr|2,"bl",blf}, {2,pr|4,"base",base}, {3,pr|3,">in",gin}, {4,pr|3,"pad",pad},
1731:                	{5,pr|5,"state",state}, {6,pr|3,"tib",tib}, {7,pr|4,"#tib",sharptib},
1732:                //	{8,pr|7,"current",current}, {9,pr|7,"context",context},
1733:                	// CtrlFlow
1734:                	{1,pr|5,"<mark",lmark}, {2,pr|8,"<resolve",lresolve}, {3,pr|5,">mark",gmark}, {4,pr|8,">resolve",gresolve},
1735:                	{5,pr|im|2,"do",dof}, {6,pr|im|3,"?do",isdof}, {7,pr|im|4,"loop",loop}, {8,pr|im|5,"+loop",plusloop},
1736:                	{9,pr|im|2,"if",iff}, {10,pr|im|4,"then",thenf}, {11,pr|im|4,"else",elsef}, {12,pr|im|5,"begin",beginf},
1737:                	{13,pr|im|5,"while",whilef}, {14,pr|im|5,"until",untilf}, {15,pr|im|6,"repeat",repeatf}, {16,pr|im|5,"again",againf},
1738:                	{17,pr|4,"exit",exitw}, {18,pr|im|7,"recurse",recursef}, {19,pr|5,"leave",leavef}, {20,pr|6,"unloop",unloopf},
1739:                	{21,pr|im|4,"case",casef}, {22,pr|im|2,"of",caseof}, {23,pr|im|5,"endof",endof}, {24,pr|im|7,"endcase",endcase},
1740:                	{25,pr|5,"abort",abortf}, {26,pr|im|6,"abort\"",aborts}, {27,pr|3,"bye",bye},
1741:                	// Interpreter
1742:                	{1,pr|im|1,"[",lbracket}, {2,pr|1,"]",rbracket}, {3,pr|3,"bin",binf}, {4,pr|7,"decimal",decimal},
1743:                	{5,pr|3,"hex",hexf}, {6,pr|6,"accept",accept}, {7,pr|5,"count",count}, {8,pr|4,"find",find},
1744:                	{9,pr|6,"number",number}, {10,pr|5,"parse",parse}, {11,pr|4,"word",wordf}, {12,pr|9,"interpret",interpret},
1745:                	{13,pr|6,"refill",refill}, {14,pr|6,"source",source}, {15,pr|4,"quit",quit}, {16,pr|4,"cold",cold},
1746:                	// Compiler	
1747:                	{1,pr|5,">body",gbody}, {2,pr|5,"link>",linkg}, {3,pr|5,"align",align}, {4,pr|5,"allot",allot},
1748:                	{5,pr|im|5,"ascii",ascii}, {6,pr|1,",",comma}, {7,pr|2,"c,",ccomma}, {8,pr|2,"w,",wcomma},
1749:                	{9,pr|2,"s,",scomma}, {10,pr|1,"'",tick}, {11,pr|im|3,"[']",brackettick}, {12,pr|7,"compile",compile},
1750:                 	{13,pr|im|9,"[compile]",bracketcompile}, {14,pr|8,"(create)",docreate}, {15,pr|6,"create",createf}, {16,pr|7,"<builds",builds},
1751:                	{17,pr|5,"does>",does}, {18,pr|9,"immediate",immediate}, {19,pr|im|8,"postpone",postpone}, {20,pr|1,":",colon},
1752:                	{21,pr|im|1,";",semicolon}, {22,pr|im|2,"s\"",squote}, {23,pr|im|7,"literal",literal}, {24,pr|8,"constant",constant},
1753:                	{25,pr|8,"variable",variable}, {26,pr|5,"value",value}, {27,pr|4,"(to)",tof}, {28,pr|im|2,"to",tof},
1754:                	{29,pr|5,"defer",defer}, {30,pr|6,"defer@",deferfetch}, {31,pr|6,"defer!",deferstore},
1755:                 	// Emit
1756:                	{1,pr|2,"cr",crf}, {2,pr|5,"space",spacef}, {3,pr|6,"spaces",spaces}, {4,pr|4,"type",typef},
1757:                	{5,pr|1,".",dot}, {6,pr|2,"u.",udot}, {7,pr|2,".r",dotr}, {8,pr|3,"u.r",udotr},
1758:                	{9,pr|im|2,".\"",dotstring}, {10,pr|im|2,".(",dotlparen}, {11,pr|im|1,"(",lparen}, {12,pr|4,"hold",hold},
1759:                	{13,pr|2,"<#",sharpl}, {14,pr|1,"#",sharp}, {15,pr|2,"#s",sharps}, {16,pr|2,"#>",sharpg},
1760:                	{17,pr|im|1,"\\",backslash}, {18,pr|4,"dump",dump}, {19,pr|2,".s",dots}, {20,pr|3,"ver",ver},
1761:                	// Vocabulary
1762:                //	{1,pr|4,"also",nop}, {2,pr|11,"definitions",nop}, {3,pr|6,"forget",nop}, {4,pr|5,"forth",nop},
1763:                //	{5,pr|4,"only",nop}, {6,pr|5,"order",nop}, {7,pr|10,"vocabulary",nop},
1764:                	{8,pr|5,"words",wordsf},
1765:                	// Device
1766:                	{1,pr|7,"coretim",coretim}, {2,pr|2,"ms",msec}, {3,pr|5,"flash",flash}, {4,pr|6,">flash",toflash},
1767:                	{5,pr|6,";flash",endflash}, 
1768:                #ifndef VPC_32    
1769:                        {6,pr|7,"devhead",devhead}, {7,pr|7,"devcall",devcall},
1770:                #endif
1771:                        {8,pr|5,"ccall",ccall},
1772:                #ifndef VPC_32
1773:                	{9,pr|4,"TIM1",devTIM1}, {10,pr|3,"COM",devCOM}, {11,pr|3,"PIN",devPIN}, {12,pr|3,"ADC",devADC},
1774:                	{13,pr|3,"PWM",devPWM},
1775:                #endif
1776:                	{0xFF,pr,"",nop}
1777:                
1778:                };
1779:                
1780:                
1781:                //		VMCORE
1782:                //	(exit)  execute  ""  (colon)  (lit)  (slit)  (con)  (var)
1783:                //	(does)  (defer)  (do)  (?do)  (loop)  (+loop)  (branch)  (?branch)
1784:                //	(val)
1785:                //		STACK
1786:                //	drop  2drop  dup  2dup  ?dup  nip  over  2over
1787:                //	pick  stick  roll  -roll  rot  -rot  swap  2swap
1788:                //	>r  r>  r@  depth  depth!  rdepth  rdepth!  sp@  rp@
1789:                //		OTHER
1790:                //	emit  ?emit  key  ?key  i  j  k  nop 
1791:                //		MEMORY
1792:                //	@  c@  w@  !  c!  w!  +!
1793:                //	fill  move  here  here!  head  head!  heap  heap! 
1794:                //		ARITHMETIC
1795:                //	+  -  d+  d-  *  m*  um*  sqrt
1796:                //	um/mod   m/mod  u/mod  /mod  /  mod  u*/  */
1797:                //	>>a  >>  <<  2*  2/  min  max  abs
1798:                //	1+  1-  negate  invert  and  or  xor   
1799:                //		LOGIC
1800:                //	andl  orl  not
1801:                //	=  <>  >  <  >=  <=  0=  0<  0>
1802:                //	u>  u<  u>=  u<=  d=  d<>  d>  d<
1803:                //	within
1804:                //
1805:                //		High FORTH
1806:                //		VARIABLE
1807:                //	bl  base  >in  pad  state  tib  #tib
1808:                //	current  context
1809:                //		CTRLFLOW
1810:                //	<mark  <resolve  >mark  >resolve  do  ?do  loop  +loop  
1811:                //	if  then  else  begin  while  until  repeat  again
1812:                //	exit  recurse  leave  unloop  case  of  endof  endcase
1813:                //	abort  abort"  bye
1814:                //		INTERPRETER
1815:                //	[  ]  bin  decimal  hex  accept  count  find
1816:                //	number  parse  word  interpret  refill  source  quit  cold  
1817:                //		COMPILER
1818:                //	>body  link>  align  allot  ascii  ,  c,  w,
1819:                //	s,  '  [']  compile  [compile]  (create)  create  <builds
1820:                //	does>  immediate  postpone  :  ;  s"  literal  constant
1821:                //	variable  value  (to)  to  defer  defer@  defer!
1822:                //		EMIT
1823:                //	cr  space  spaces  type  .  u.  .r  u.r
1824:                //	."  .(  (  hold  <#  #  #s  #>
1825:                //	\  dump  .s  ver
1826:                //		VOCABULARY
1827:                //	also  definitions  forget  forth  only  order  vocabulary  words
1828:                //		DEVICE
1829:                //	coretim  ms  flash  >flash  ;flash  devhead  devcall  ccall
1830:                //	TIM1  COM  PIN  ADC  PWM
1831:                
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/DiosForth.X/source/VM/VMcore.c  -------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  VMcore
4:                    *                  DIOS Forth
5:                    *
6:                    * v.1.0 - 20.12.2012, L.Pekny
7:                    ********************************************************************/
8:                   
9:                   #include <plib.h>
10:                  #include "..\GenericTypeDefs.h"
11:                  #include "../../../hardware/HardwareProfile.h"
12:                  //#include "..\HardwareProfile.h"
13:                  #include "VMcore.h"
14:                  
15:                  
16:                  cell  DS[DSsize];
17:                  ucell RS[RSsize];
18:                  cell  *pDSzero=DS+8, *pDS=DS+8; 
19:                  ucell *pRSzero=RS+8, *pRS=RS+8, *pRSbak;
20:                  //WORD DScnt, RScnt;
21:                  ucell PC, WORK;
22:                  void (*pFce)(void) = NULL;
23:                  
24:                  
25:                  void exitw(void)  {EXIT}
9D00B14C  8F82801C   LW V0, -32740(GP)
9D00B150  8C430000   LW V1, 0(V0)
9D00B154  AF8380E8   SW V1, -32536(GP)
9D00B158  2442FFFC   ADDIU V0, V0, -4
9D00B15C  03E00008   JR RA
9D00B160  AF82801C   SW V0, -32740(GP)
26:                  
27:                  void executew(void) {EXECUTE}
9D00B164  27BDFFE8   ADDIU SP, SP, -24
9D00B168  AFBF0014   SW RA, 20(SP)
9D00B16C  8F838014   LW V1, -32748(GP)
9D00B170  AF8380E8   SW V1, -32536(GP)
9D00B174  8C620000   LW V0, 0(V1)
9D00B178  8C420000   LW V0, 0(V0)
9D00B17C  AF828078   SW V0, -32648(GP)
9D00B180  2463FFFC   ADDIU V1, V1, -4
9D00B184  0040F809   JALR V0
9D00B188  AF838014   SW V1, -32748(GP)
9D00B18C  8FBF0014   LW RA, 20(SP)
9D00B190  03E00008   JR RA
9D00B194  27BD0018   ADDIU SP, SP, 24
28:                  
29:                  void nextw(void)  {NEXT}
9D00B198  27BDFFE8   ADDIU SP, SP, -24
9D00B19C  AFBF0014   SW RA, 20(SP)
9D00B1A0  8F8280E8   LW V0, -32536(GP)
9D00B1A4  24430004   ADDIU V1, V0, 4
9D00B1A8  AF8380E8   SW V1, -32536(GP)
9D00B1AC  8C420004   LW V0, 4(V0)
9D00B1B0  8C420000   LW V0, 0(V0)
9D00B1B4  0040F809   JALR V0
9D00B1B8  AF828078   SW V0, -32648(GP)
9D00B1BC  8FBF0014   LW RA, 20(SP)
9D00B1C0  03E00008   JR RA
9D00B1C4  27BD0018   ADDIU SP, SP, 24
30:                  
31:                  void enterw(void) {ucell *pRSbak; ENTER}
9D00B1C8  27BDFFE8   ADDIU SP, SP, -24
9D00B1CC  AFBF0014   SW RA, 20(SP)
9D00B1D0  AFB00010   SW S0, 16(SP)
9D00B1D4  8F90801C   LW S0, -32740(GP)
9D00B1D8  26020004   ADDIU V0, S0, 4
9D00B1DC  AF82801C   SW V0, -32740(GP)
9D00B1E0  8F8280E8   LW V0, -32536(GP)
9D00B1E4  AE020004   SW V0, 4(S0)
9D00B1E8  8F8280E8   LW V0, -32536(GP)
9D00B1EC  8C420000   LW V0, 0(V0)
9D00B1F0  AF8280E8   SW V0, -32536(GP)
9D00B1F4  8F82801C   LW V0, -32740(GP)
9D00B1F8  0202102B   SLTU V0, S0, V0
9D00B1FC  1040000D   BEQ V0, ZERO, 0x9D00B234
9D00B200  8FBF0014   LW RA, 20(SP)
9D00B204  8F8280E8   LW V0, -32536(GP)
9D00B208  24430004   ADDIU V1, V0, 4
9D00B20C  AF8380E8   SW V1, -32536(GP)
9D00B210  8C420004   LW V0, 4(V0)
9D00B214  8C420000   LW V0, 0(V0)
9D00B218  0040F809   JALR V0
9D00B21C  AF828078   SW V0, -32648(GP)
9D00B220  8F82801C   LW V0, -32740(GP)
9D00B224  0202102B   SLTU V0, S0, V0
9D00B228  1440FFF7   BNE V0, ZERO, 0x9D00B208
9D00B22C  8F8280E8   LW V0, -32536(GP)
9D00B230  8FBF0014   LW RA, 20(SP)
9D00B234  8FB00010   LW S0, 16(SP)
9D00B238  03E00008   JR RA
9D00B23C  27BD0018   ADDIU SP, SP, 24
32:                  
33:                  void dolitw(void) {DOLIT}
9D00B240  8F8380E8   LW V1, -32536(GP)
9D00B244  24620004   ADDIU V0, V1, 4
9D00B248  AF8280E8   SW V0, -32536(GP)
9D00B24C  8F828014   LW V0, -32748(GP)
9D00B250  24440004   ADDIU A0, V0, 4
9D00B254  AF848014   SW A0, -32748(GP)
9D00B258  8C630004   LW V1, 4(V1)
9D00B25C  03E00008   JR RA
9D00B260  AC430004   SW V1, 4(V0)
34:                  
35:                  void doslitw(void){DOSLIT  PC&=~3;}  // align (PC-cellsize)
9D00B264  8F8380E8   LW V1, -32536(GP)
9D00B268  24620004   ADDIU V0, V1, 4
9D00B26C  AF8280E8   SW V0, -32536(GP)
9D00B270  8F828014   LW V0, -32748(GP)
9D00B274  24440004   ADDIU A0, V0, 4
9D00B278  AF848014   SW A0, -32748(GP)
9D00B27C  24630005   ADDIU V1, V1, 5
9D00B280  AC430004   SW V1, 4(V0)
9D00B284  8F828014   LW V0, -32748(GP)
9D00B288  24430004   ADDIU V1, V0, 4
9D00B28C  AF838014   SW V1, -32748(GP)
9D00B290  8F8380E8   LW V1, -32536(GP)
9D00B294  90630000   LBU V1, 0(V1)
9D00B298  AC430004   SW V1, 4(V0)
9D00B29C  8F828014   LW V0, -32748(GP)
9D00B2A0  8C430000   LW V1, 0(V0)
9D00B2A4  8F8280E8   LW V0, -32536(GP)
9D00B2A8  00621021   ADDU V0, V1, V0
9D00B2AC  2403FFFC   ADDIU V1, ZERO, -4
9D00B2B0  00431024   AND V0, V0, V1
9D00B2B4  03E00008   JR RA
9D00B2B8  AF8280E8   SW V0, -32536(GP)
36:                  
37:                  void doconw(void) {DOCON}
9D00B2BC  8F828014   LW V0, -32748(GP)
9D00B2C0  24430004   ADDIU V1, V0, 4
9D00B2C4  AF838014   SW V1, -32748(GP)
9D00B2C8  8F8380E8   LW V1, -32536(GP)
9D00B2CC  8C630000   LW V1, 0(V1)
9D00B2D0  8C630004   LW V1, 4(V1)
9D00B2D4  03E00008   JR RA
9D00B2D8  AC430004   SW V1, 4(V0)
38:                  
39:                  void dovarw(void) {DOVAR}
9D00B2DC  8F828014   LW V0, -32748(GP)
9D00B2E0  24430004   ADDIU V1, V0, 4
9D00B2E4  AF838014   SW V1, -32748(GP)
9D00B2E8  8F8380E8   LW V1, -32536(GP)
9D00B2EC  8C630000   LW V1, 0(V1)
9D00B2F0  8C630004   LW V1, 4(V1)
9D00B2F4  03E00008   JR RA
9D00B2F8  AC430004   SW V1, 4(V0)
40:                  
41:                  void dovalw(void) {DOVAL}
9D00B2FC  8F828014   LW V0, -32748(GP)
9D00B300  24430004   ADDIU V1, V0, 4
9D00B304  AF838014   SW V1, -32748(GP)
9D00B308  8F8380E8   LW V1, -32536(GP)
9D00B30C  8C630000   LW V1, 0(V1)
9D00B310  8C630004   LW V1, 4(V1)
9D00B314  8C630000   LW V1, 0(V1)
9D00B318  03E00008   JR RA
9D00B31C  AC430004   SW V1, 4(V0)
42:                  
43:                  
44:                  void dodoes(void)
45:                  {
9D00B320  27BDFFE8   ADDIU SP, SP, -24
9D00B324  AFBF0014   SW RA, 20(SP)
9D00B328  AFB00010   SW S0, 16(SP)
46:                  	WORK=pDATA(PC);	PUSH(WORK+dcellsize);	// PFA
9D00B32C  8F8280E8   LW V0, -32536(GP)
9D00B330  8C430000   LW V1, 0(V0)
9D00B334  AF8380E4   SW V1, -32540(GP)
9D00B338  8F828014   LW V0, -32748(GP)
9D00B33C  24440004   ADDIU A0, V0, 4
9D00B340  AF848014   SW A0, -32748(GP)
9D00B344  24630008   ADDIU V1, V1, 8
9D00B348  AC430004   SW V1, 4(V0)
47:                  	WORK+=cellsize;				// Must be used WORK
9D00B34C  8F8280E4   LW V0, -32540(GP)
9D00B350  24420004   ADDIU V0, V0, 4
9D00B354  AF8280E4   SW V0, -32540(GP)
48:                  	ucell *pRSbak; ENTERDOES	// Words behind does>
9D00B358  8F90801C   LW S0, -32740(GP)
9D00B35C  26020004   ADDIU V0, S0, 4
9D00B360  AF82801C   SW V0, -32740(GP)
9D00B364  8F8280E8   LW V0, -32536(GP)
9D00B368  AE020004   SW V0, 4(S0)
9D00B36C  8F8280E4   LW V0, -32540(GP)
9D00B370  8C420000   LW V0, 0(V0)
9D00B374  AF8280E8   SW V0, -32536(GP)
9D00B378  8F82801C   LW V0, -32740(GP)
9D00B37C  0202102B   SLTU V0, S0, V0
9D00B380  1040000D   BEQ V0, ZERO, 0x9D00B3B8
9D00B384  8FBF0014   LW RA, 20(SP)
9D00B388  8F8280E8   LW V0, -32536(GP)
9D00B38C  24430004   ADDIU V1, V0, 4
9D00B390  AF8380E8   SW V1, -32536(GP)
9D00B394  8C420004   LW V0, 4(V0)
9D00B398  8C420000   LW V0, 0(V0)
9D00B39C  0040F809   JALR V0
9D00B3A0  AF828078   SW V0, -32648(GP)
9D00B3A4  8F82801C   LW V0, -32740(GP)
9D00B3A8  0202102B   SLTU V0, S0, V0
9D00B3AC  1440FFF7   BNE V0, ZERO, 0x9D00B38C
9D00B3B0  8F8280E8   LW V0, -32536(GP)
49:                  }
9D00B3B4  8FBF0014   LW RA, 20(SP)
9D00B3B8  8FB00010   LW S0, 16(SP)
9D00B3BC  03E00008   JR RA
9D00B3C0  27BD0018   ADDIU SP, SP, 24
50:                  
51:                  
52:                  void dodefer(void)
53:                  {
9D00B3C4  27BDFFE8   ADDIU SP, SP, -24
9D00B3C8  AFBF0014   SW RA, 20(SP)
54:                  	DOVAL EXECUTE
9D00B3CC  8F828014   LW V0, -32748(GP)
9D00B3D0  24430004   ADDIU V1, V0, 4
9D00B3D4  AF838014   SW V1, -32748(GP)
9D00B3D8  8F8380E8   LW V1, -32536(GP)
9D00B3DC  8C630000   LW V1, 0(V1)
9D00B3E0  8C630004   LW V1, 4(V1)
9D00B3E4  8C630000   LW V1, 0(V1)
9D00B3E8  AC430004   SW V1, 4(V0)
9D00B3EC  8F838014   LW V1, -32748(GP)
9D00B3F0  AF8380E8   SW V1, -32536(GP)
9D00B3F4  8C620000   LW V0, 0(V1)
9D00B3F8  8C420000   LW V0, 0(V0)
9D00B3FC  AF828078   SW V0, -32648(GP)
9D00B400  2463FFFC   ADDIU V1, V1, -4
9D00B404  0040F809   JALR V0
9D00B408  AF838014   SW V1, -32748(GP)
55:                  }
9D00B40C  8FBF0014   LW RA, 20(SP)
9D00B410  03E00008   JR RA
9D00B414  27BD0018   ADDIU SP, SP, 24
56:                  
57:                  
58:                  void dodo(void)
59:                  {
60:                  	cell vStart=POP, vEnd=POP;
9D00B418  8F828014   LW V0, -32748(GP)
9D00B41C  8C440000   LW A0, 0(V0)
9D00B420  2443FFFC   ADDIU V1, V0, -4
9D00B424  AF838014   SW V1, -32748(GP)
9D00B428  8C45FFFC   LW A1, -4(V0)
9D00B42C  2442FFF8   ADDIU V0, V0, -8
9D00B430  AF828014   SW V0, -32748(GP)
61:                  	PC+=cellsize;
9D00B434  8F8380E8   LW V1, -32536(GP)
9D00B438  24620004   ADDIU V0, V1, 4
9D00B43C  AF8280E8   SW V0, -32536(GP)
62:                  	PUSHR(pDATA PC);  // For leave
9D00B440  8F82801C   LW V0, -32740(GP)
9D00B444  24460004   ADDIU A2, V0, 4
9D00B448  AF86801C   SW A2, -32740(GP)
9D00B44C  8C630004   LW V1, 4(V1)
9D00B450  AC430004   SW V1, 4(V0)
63:                  	PUSHR(vEnd); PUSHR(vStart);
9D00B454  8F82801C   LW V0, -32740(GP)
9D00B458  24430004   ADDIU V1, V0, 4
9D00B45C  AF83801C   SW V1, -32740(GP)
9D00B460  AC450004   SW A1, 4(V0)
9D00B464  8F82801C   LW V0, -32740(GP)
9D00B468  24430004   ADDIU V1, V0, 4
9D00B46C  AF83801C   SW V1, -32740(GP)
64:                  }
9D00B470  03E00008   JR RA
9D00B474  AC440004   SW A0, 4(V0)
65:                  
66:                  
67:                  void doisdo(void)
68:                  {
69:                  	cell vStart=POP, vEnd=POP;
9D00B478  8F828014   LW V0, -32748(GP)
9D00B47C  8C430000   LW V1, 0(V0)
9D00B480  2444FFFC   ADDIU A0, V0, -4
9D00B484  AF848014   SW A0, -32748(GP)
9D00B488  8C44FFFC   LW A0, -4(V0)
9D00B48C  2442FFF8   ADDIU V0, V0, -8
9D00B490  AF828014   SW V0, -32748(GP)
70:                  	PC+=cellsize;
9D00B494  8F8280E8   LW V0, -32536(GP)
9D00B498  24450004   ADDIU A1, V0, 4
71:                  	if (vStart==vEnd) {PC=pDATA PC;}
9D00B49C  14640004   BNE V1, A0, 0x9D00B4B0
9D00B4A0  AF8580E8   SW A1, -32536(GP)
9D00B4A4  8C420004   LW V0, 4(V0)
9D00B4A8  03E00008   JR RA
9D00B4AC  AF8280E8   SW V0, -32536(GP)
72:                  	 else {PUSHR(pDATA PC); PUSHR(vEnd); PUSHR(vStart);}
9D00B4B0  8F85801C   LW A1, -32740(GP)
9D00B4B4  24A60004   ADDIU A2, A1, 4
9D00B4B8  AF86801C   SW A2, -32740(GP)
9D00B4BC  8C420004   LW V0, 4(V0)
9D00B4C0  ACA20004   SW V0, 4(A1)
9D00B4C4  8F82801C   LW V0, -32740(GP)
9D00B4C8  24450004   ADDIU A1, V0, 4
9D00B4CC  AF85801C   SW A1, -32740(GP)
9D00B4D0  AC440004   SW A0, 4(V0)
9D00B4D4  8F82801C   LW V0, -32740(GP)
9D00B4D8  24440004   ADDIU A0, V0, 4
9D00B4DC  AF84801C   SW A0, -32740(GP)
9D00B4E0  03E00008   JR RA
9D00B4E4  AC430004   SW V1, 4(V0)
73:                  }
74:                  
75:                  
76:                  void doloop(void)
77:                  {
78:                  	cell vStart=POPR, vEnd=POPR; 
9D00B4E8  8F82801C   LW V0, -32740(GP)
9D00B4EC  8C430000   LW V1, 0(V0)
9D00B4F0  2444FFFC   ADDIU A0, V0, -4
9D00B4F4  AF84801C   SW A0, -32740(GP)
9D00B4F8  8C44FFFC   LW A0, -4(V0)
9D00B4FC  2442FFF8   ADDIU V0, V0, -8
9D00B500  AF82801C   SW V0, -32740(GP)
79:                  	PC+=cellsize; vStart++;
9D00B504  8F8580E8   LW A1, -32536(GP)
9D00B508  24A60004   ADDIU A2, A1, 4
9D00B50C  AF8680E8   SW A2, -32536(GP)
9D00B510  24630001   ADDIU V1, V1, 1
80:                  
81:                  	if (vStart<vEnd)
9D00B514  0064302A   SLT A2, V1, A0
9D00B518  50C0000B   BEQL A2, ZERO, 0x9D00B548
9D00B51C  2442FFFC   ADDIU V0, V0, -4
82:                  	{
83:                  		PC=pDATA PC;
9D00B520  8CA50004   LW A1, 4(A1)
9D00B524  AF8580E8   SW A1, -32536(GP)
84:                  		PUSHR(vEnd); PUSHR(vStart);
9D00B528  24450004   ADDIU A1, V0, 4
9D00B52C  AF85801C   SW A1, -32740(GP)
9D00B530  AC440004   SW A0, 4(V0)
9D00B534  8F82801C   LW V0, -32740(GP)
9D00B538  24440004   ADDIU A0, V0, 4
9D00B53C  AF84801C   SW A0, -32740(GP)
9D00B540  03E00008   JR RA
9D00B544  AC430004   SW V1, 4(V0)
85:                  	}
86:                  	else {pRS--;}  // POPR or leave
9D00B548  03E00008   JR RA
9D00B54C  AF82801C   SW V0, -32740(GP)
87:                  }
88:                  
89:                  
90:                  void doplusloop(void)
91:                  {
92:                  	cell vInc=POP, vStart=POPR, vEnd=POPR;
9D00B550  8F828014   LW V0, -32748(GP)
9D00B554  8C450000   LW A1, 0(V0)
9D00B558  2442FFFC   ADDIU V0, V0, -4
9D00B55C  AF828014   SW V0, -32748(GP)
9D00B560  8F82801C   LW V0, -32740(GP)
9D00B564  8C430000   LW V1, 0(V0)
9D00B568  2444FFFC   ADDIU A0, V0, -4
9D00B56C  AF84801C   SW A0, -32740(GP)
9D00B570  8C44FFFC   LW A0, -4(V0)
9D00B574  2442FFF8   ADDIU V0, V0, -8
9D00B578  AF82801C   SW V0, -32740(GP)
93:                  	char k; 
94:                  
95:                  	PC+=cellsize; vStart+=vInc;
9D00B57C  8F8680E8   LW A2, -32536(GP)
9D00B580  24C70004   ADDIU A3, A2, 4
9D00B584  AF8780E8   SW A3, -32536(GP)
9D00B588  00651821   ADDU V1, V1, A1
96:                  	if (vInc>=0) {k=(char)(vStart<vEnd);} else {k=(char)(vStart>vEnd);}
9D00B58C  0064382A   SLT A3, V1, A0
9D00B590  0083402A   SLT T0, A0, V1
9D00B594  28A50000   SLTI A1, A1, 0
9D00B598  0105380B   MOVN A3, T0, A1
97:                  	if (k)
9D00B59C  50E0000B   BEQL A3, ZERO, 0x9D00B5CC
9D00B5A0  2442FFFC   ADDIU V0, V0, -4
98:                  	{
99:                  		PC=pDATA PC;
9D00B5A4  8CC50004   LW A1, 4(A2)
9D00B5A8  AF8580E8   SW A1, -32536(GP)
100:                 		PUSHR(vEnd); PUSHR(vStart);
9D00B5AC  24450004   ADDIU A1, V0, 4
9D00B5B0  AF85801C   SW A1, -32740(GP)
9D00B5B4  AC440004   SW A0, 4(V0)
9D00B5B8  8F82801C   LW V0, -32740(GP)
9D00B5BC  24440004   ADDIU A0, V0, 4
9D00B5C0  AF84801C   SW A0, -32740(GP)
9D00B5C4  03E00008   JR RA
9D00B5C8  AC430004   SW V1, 4(V0)
101:                 	}
102:                 	else {pRS--;}  // POPR or leave
9D00B5CC  03E00008   JR RA
9D00B5D0  AF82801C   SW V0, -32740(GP)
103:                 }
104:                 
105:                 
106:                 void dobranch(void)
107:                 {
108:                 	PC+=cellsize;
9D00B5D4  8F8280E8   LW V0, -32536(GP)
9D00B5D8  24430004   ADDIU V1, V0, 4
9D00B5DC  AF8380E8   SW V1, -32536(GP)
109:                 	PC=pDATA PC;
9D00B5E0  8C420004   LW V0, 4(V0)
110:                 }
9D00B5E4  03E00008   JR RA
9D00B5E8  AF8280E8   SW V0, -32536(GP)
111:                 
112:                 
113:                 void docbranch(void)
114:                 {
115:                 	PC+=cellsize;
9D00B5EC  8F8380E8   LW V1, -32536(GP)
9D00B5F0  24620004   ADDIU V0, V1, 4
9D00B5F4  AF8280E8   SW V0, -32536(GP)
116:                 	if (!POP) {PC=pDATA PC;}
9D00B5F8  8F828014   LW V0, -32748(GP)
9D00B5FC  8C440000   LW A0, 0(V0)
9D00B600  2442FFFC   ADDIU V0, V0, -4
9D00B604  14800003   BNE A0, ZERO, 0x9D00B614
9D00B608  AF828014   SW V0, -32748(GP)
9D00B60C  8C620004   LW V0, 4(V1)
9D00B610  AF8280E8   SW V0, -32536(GP)
9D00B614  03E00008   JR RA
9D00B618  00000000   NOP
117:                 }
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/DiosForth.X/source/NVMem/NVMem.c  -----------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  NVMem
4:                    *                  DIOS Forth
5:                    *
6:                    * v.1.0 - 10.12.2012, Prog flash memory, L.Pekny
7:                    ********************************************************************/
8:                   
9:                   #include <plib.h>
10:                  #include "..\GenericTypeDefs.h"
11:                  #include "../../../hardware/HardwareProfile.h"
12:                  //#include "..\HardwareProfile.h"
13:                  #include "NVMem.h"
14:                  
15:                  
16:                  UINT FBuf, FBufCnt=0;
17:                  char *pFBuf=(char*)&FBuf;
18:                  UINT *vFHere, *vFHead;
19:                  
20:                  
21:                  void NVMopen(UINT *pFHere)							// Start addr for write
22:                  {
23:                  	FBufCnt=0; vFHere=pFHere;
9D00C6C8  AF808098   SW ZERO, -32616(GP)
24:                  }
9D00C6CC  03E00008   JR RA
9D00C6D0  AF848114   SW A0, -32492(GP)
25:                  
26:                  
27:                  char NVMclose(void)
28:                  {
9D00C834  27BDFFE8   ADDIU SP, SP, -24
9D00C838  AFBF0014   SW RA, 20(SP)
29:                  	UINT i;
30:                  	if (!NVMflushBuf()) {return 0;}					// Copy Buf to flash
9D00C83C  0F4031FE   JAL NVMflushBuf
9D00C840  00000000   NOP
9D00C844  1040002B   BEQ V0, ZERO, 0x9D00C8F4
9D00C848  00001821   ADDU V1, ZERO, ZERO
31:                  
32:                  	for (i=EETAB; i<EETAB+FLASH_PAGE_SIZE; i+=4) {if (*(int *)i==-1) {break;}}
9D00C84C  3C02BF88   LUI V0, -16504
9D00C850  8C432060   LW V1, 8288(V0)
9D00C854  3C049CFF   LUI A0, -25345
9D00C858  3484F000   ORI A0, A0, -4096
9D00C85C  00642021   ADDU A0, V1, A0
9D00C860  8C432060   LW V1, 8288(V0)
9D00C864  3C029D00   LUI V0, -25344
9D00C868  00621021   ADDU V0, V1, V0
9D00C86C  0082102B   SLTU V0, A0, V0
9D00C870  10400012   BEQ V0, ZERO, 0x9D00C8BC
9D00C874  2402FFFF   ADDIU V0, ZERO, -1
9D00C878  8C830000   LW V1, 0(A0)
9D00C87C  14620007   BNE V1, V0, 0x9D00C89C
9D00C880  3C05BF88   LUI A1, -16504
9D00C88C  54460006   BNEL V0, A2, 0x9D00C8A8
9D00C890  24840004   ADDIU A0, A0, 4
9D00C89C  3C039D00   LUI V1, -25344
9D00C8A0  2406FFFF   ADDIU A2, ZERO, -1
9D00C8A4  24840004   ADDIU A0, A0, 4
9D00C8A8  8CA22060   LW V0, 8288(A1)
9D00C8AC  00431021   ADDU V0, V0, V1
9D00C8B0  0082102B   SLTU V0, A0, V0
9D00C8B4  5440FFF5   BNEL V0, ZERO, 0x9D00C88C
9D00C8B8  8C820000   LW V0, 0(A0)
33:                  	if (i>=EETAB+FLASH_PAGE_SIZE) {i=EETAB;}		// Empty place or erase page
9D00C884  0B403230   J 0x9D00C8C0
9D00C888  3C02BF88   LUI V0, -16504
9D00C894  0B403230   J 0x9D00C8C0
9D00C898  3C02BF88   LUI V0, -16504
9D00C8BC  3C02BF88   LUI V0, -16504
9D00C8C0  8C432060   LW V1, 8288(V0)
9D00C8C4  3C029D00   LUI V0, -25344
9D00C8C8  00621021   ADDU V0, V1, V0
9D00C8CC  0082102B   SLTU V0, A0, V0
9D00C8D0  14400005   BNE V0, ZERO, 0x9D00C8E8
9D00C8D4  3C02BF88   LUI V0, -16504
9D00C8D8  8C422060   LW V0, 8288(V0)
9D00C8DC  3C049CFF   LUI A0, -25345
9D00C8E0  3484F000   ORI A0, A0, -4096
9D00C8E4  00442021   ADDU A0, V0, A0
34:                  	return NVMwrite((UINT*)i,(UINT)vFHere); 		// Write vFHere to EETAB
9D00C8E8  0F4031D8   JAL NVMwrite
9D00C8EC  8F858114   LW A1, -32492(GP)
9D00C8F0  00401821   ADDU V1, V0, ZERO
35:                  }
9D00C8F4  00601021   ADDU V0, V1, ZERO
9D00C8F8  8FBF0014   LW RA, 20(SP)
9D00C8FC  03E00008   JR RA
9D00C900  27BD0018   ADDIU SP, SP, 24
36:                  
37:                  
38:                  char NVMerase(UINT *pAddr)
9D00C72C  00501821   ADDU V1, V0, S0
39:                  {
9D00C6D4  27BDFFE8   ADDIU SP, SP, -24
9D00C6D8  AFBF0014   SW RA, 20(SP)
9D00C6DC  AFB00010   SW S0, 16(SP)
40:                  	UINT i, Ad=(UINT)pAddr&~0xFFF;
9D00C6E0  2410F000   ADDIU S0, ZERO, -4096
9D00C6E4  00908024   AND S0, A0, S0
41:                  
42:                  	if (Ad>FLASH_END) {return 0;}
9D00C6E8  3C02BF88   LUI V0, -16504
9D00C6EC  8C422060   LW V0, 8288(V0)
9D00C6F0  3C039CFF   LUI V1, -25345
9D00C6F4  3463FFFF   ORI V1, V1, -1
9D00C6F8  00431821   ADDU V1, V0, V1
9D00C6FC  0070182B   SLTU V1, V1, S0
9D00C700  14600013   BNE V1, ZERO, 0x9D00C750
9D00C704  00001021   ADDU V0, ZERO, ZERO
43:                  
44:                  	NVMErasePage((void *)Ad);
9D00C708  0F403F13   JAL NVMErasePage
9D00C70C  02002021   ADDU A0, S0, ZERO
45:                  
46:                  	for(i=0; i<FLASH_PAGE_SIZE; i+=4) {if (*(int *)(Ad+i)!=-1) {return 0;}}
9D00C710  8E040000   LW A0, 0(S0)
9D00C714  2403FFFF   ADDIU V1, ZERO, -1
9D00C718  1483000D   BNE A0, V1, 0x9D00C750
9D00C71C  00001021   ADDU V0, ZERO, ZERO
9D00C720  24020004   ADDIU V0, ZERO, 4
9D00C724  2404FFFF   ADDIU A0, ZERO, -1
9D00C728  24051000   ADDIU A1, ZERO, 4096
9D00C730  8C630000   LW V1, 0(V1)
9D00C734  14640005   BNE V1, A0, 0x9D00C74C
9D00C738  24420004   ADDIU V0, V0, 4
9D00C73C  1445FFFC   BNE V0, A1, 0x9D00C730
9D00C740  00501821   ADDU V1, V0, S0
9D00C74C  00001021   ADDU V0, ZERO, ZERO
47:                  	return -1;
9D00C744  0B4031D4   J 0x9D00C750
9D00C748  2402FFFF   ADDIU V0, ZERO, -1
48:                  }
9D00C750  8FBF0014   LW RA, 20(SP)
9D00C754  8FB00010   LW S0, 16(SP)
9D00C758  03E00008   JR RA
9D00C75C  27BD0018   ADDIU SP, SP, 24
49:                  
50:                  
51:                  char NVMwrite(UINT *pAddr, UINT Data)
52:                  {
9D00C760  27BDFFE0   ADDIU SP, SP, -32
9D00C764  AFBF001C   SW RA, 28(SP)
9D00C768  AFB10018   SW S1, 24(SP)
9D00C76C  AFB00014   SW S0, 20(SP)
9D00C770  00808021   ADDU S0, A0, ZERO
9D00C774  00A08821   ADDU S1, A1, ZERO
53:                  	UINT Addr=(UINT)pAddr;
54:                  
55:                  	if (Addr>FLASH_END) {return 0;}
9D00C778  3C02BF88   LUI V0, -16504
9D00C77C  8C432060   LW V1, 8288(V0)
9D00C780  3C029CFF   LUI V0, -25345
9D00C784  3442FFFF   ORI V0, V0, -1
9D00C788  00621021   ADDU V0, V1, V0
9D00C78C  0044102B   SLTU V0, V0, A0
9D00C790  14400013   BNE V0, ZERO, 0x9D00C7E0
9D00C794  00001821   ADDU V1, ZERO, ZERO
56:                  	if (!(Addr&0xFFF)&&(pAddr>=vFHere)) {if (!NVMerase(pAddr)) {return 0;}}  // Erase new page
9D00C798  30820FFF   ANDI V0, A0, 4095
9D00C79C  14400008   BNE V0, ZERO, 0x9D00C7C0
9D00C7A0  8F828114   LW V0, -32492(GP)
9D00C7A4  0082102B   SLTU V0, A0, V0
9D00C7A8  54400006   BNEL V0, ZERO, 0x9D00C7C4
9D00C7AC  02002021   ADDU A0, S0, ZERO
9D00C7B0  0F4031B5   JAL NVMerase
9D00C7B4  00000000   NOP
9D00C7B8  10400009   BEQ V0, ZERO, 0x9D00C7E0
9D00C7BC  00001821   ADDU V1, ZERO, ZERO
57:                  	NVMWriteWord(pAddr, Data); if (*pAddr!=Data) {return 0;}  // Write and compare
9D00C7C0  02002021   ADDU A0, S0, ZERO
9D00C7C4  0F403EFA   JAL NVMWriteWord
9D00C7C8  02202821   ADDU A1, S1, ZERO
9D00C7CC  8E030000   LW V1, 0(S0)
9D00C7D0  00718826   XOR S1, V1, S1
9D00C7D4  2402FFFF   ADDIU V0, ZERO, -1
9D00C7D8  00001821   ADDU V1, ZERO, ZERO
9D00C7DC  0051180A   MOVZ V1, V0, S1
58:                  	return -1;
59:                  }
9D00C7E0  00601021   ADDU V0, V1, ZERO
9D00C7E4  8FBF001C   LW RA, 28(SP)
9D00C7E8  8FB10018   LW S1, 24(SP)
9D00C7EC  8FB00014   LW S0, 20(SP)
9D00C7F0  03E00008   JR RA
9D00C7F4  27BD0020   ADDIU SP, SP, 32
60:                  
61:                  
62:                  char NVMflushBuf(void)
63:                  {
9D00C7F8  27BDFFE8   ADDIU SP, SP, -24
9D00C7FC  AFBF0014   SW RA, 20(SP)
64:                  	int r;
65:                  	if (FBufCnt)
9D00C800  8F838098   LW V1, -32616(GP)
9D00C804  10600008   BEQ V1, ZERO, 0x9D00C828
9D00C808  24020001   ADDIU V0, ZERO, 1
66:                  	{	
67:                  	  FBufCnt=0;
9D00C80C  AF808098   SW ZERO, -32616(GP)
68:                  	  r=NVMwrite(vFHere,FBuf); vFHere++;			// 0-err, -1-NVM
9D00C810  8F848114   LW A0, -32492(GP)
9D00C814  0F4031D8   JAL NVMwrite
9D00C818  8F858110   LW A1, -32496(GP)
9D00C81C  8F838114   LW V1, -32492(GP)
9D00C820  24630004   ADDIU V1, V1, 4
9D00C824  AF838114   SW V1, -32492(GP)
69:                  	  return r;
70:                  	} else return 1;								// 1-Buf
71:                  }
9D00C828  8FBF0014   LW RA, 20(SP)
9D00C82C  03E00008   JR RA
9D00C830  27BD0018   ADDIU SP, SP, 24
72:                  
73:                  
74:                  char NVMwriteBuf(UINT Data)							// Write UINT to NVM
75:                  {
9D00C904  27BDFFE8   ADDIU SP, SP, -24
9D00C908  AFBF0014   SW RA, 20(SP)
9D00C90C  AFB00010   SW S0, 16(SP)
76:                  	int r;
77:                  	NVMflushBuf();									// Align 32b
9D00C910  0F4031FE   JAL NVMflushBuf
9D00C914  00808021   ADDU S0, A0, ZERO
78:                  	r=NVMwrite(vFHere,Data); vFHere++;				// 0-err, -1-NVM
9D00C918  8F848114   LW A0, -32492(GP)
9D00C91C  0F4031D8   JAL NVMwrite
9D00C920  02002821   ADDU A1, S0, ZERO
9D00C924  8F838114   LW V1, -32492(GP)
9D00C928  24630004   ADDIU V1, V1, 4
9D00C92C  AF838114   SW V1, -32492(GP)
79:                  	return r;
80:                  }
9D00C930  8FBF0014   LW RA, 20(SP)
9D00C934  8FB00010   LW S0, 16(SP)
9D00C938  03E00008   JR RA
9D00C93C  27BD0018   ADDIU SP, SP, 24
81:                  
82:                  
83:                  char NVMwriteBufc(char Data)						// Delayed write to NVM
84:                  {
9D00C940  27BDFFE8   ADDIU SP, SP, -24
9D00C944  AFBF0014   SW RA, 20(SP)
85:                  	int r;
86:                  	*(char*)(pFBuf+FBufCnt)=Data; FBufCnt++;		// Write byte to FBuf
9D00C948  8F828098   LW V0, -32616(GP)
9D00C94C  8F838054   LW V1, -32684(GP)
9D00C950  00621021   ADDU V0, V1, V0
9D00C954  A0440000   SB A0, 0(V0)
9D00C958  8F828098   LW V0, -32616(GP)
9D00C95C  24420001   ADDIU V0, V0, 1
9D00C960  AF828098   SW V0, -32616(GP)
87:                  
88:                  	if (FBufCnt>3)									// Full? Write to Flash
9D00C964  2C430004   SLTIU V1, V0, 4
9D00C968  14600008   BNE V1, ZERO, 0x9D00C98C
9D00C96C  24020001   ADDIU V0, ZERO, 1
89:                  	{
90:                  	  FBufCnt=0; 
9D00C970  AF808098   SW ZERO, -32616(GP)
91:                  	  r=NVMwrite(vFHere,FBuf); vFHere++;			// 0-err, -1-NVM
9D00C974  8F848114   LW A0, -32492(GP)
9D00C978  0F4031D8   JAL NVMwrite
9D00C97C  8F858110   LW A1, -32496(GP)
9D00C980  8F838114   LW V1, -32492(GP)
9D00C984  24630004   ADDIU V1, V1, 4
9D00C988  AF838114   SW V1, -32492(GP)
92:                  	  return r;
93:                  	} else return 1;								// 1-Buf
94:                  }
9D00C98C  8FBF0014   LW RA, 20(SP)
9D00C990  03E00008   JR RA
9D00C994  27BD0018   ADDIU SP, SP, 24
95:                  
96:                  
97:                  char NVMwriteBufw(WORD Data)						// Delayed write to NVM
98:                  {
9D00C998  27BDFFE8   ADDIU SP, SP, -24
9D00C99C  AFBF0014   SW RA, 20(SP)
9D00C9A0  AFB00010   SW S0, 16(SP)
99:                  	int r;
100:                 	if (FBufCnt==1) {FBufCnt++;}					// Align 16b
9D00C9A4  8F828098   LW V0, -32616(GP)
9D00C9A8  24030001   ADDIU V1, ZERO, 1
9D00C9AC  14430004   BNE V0, V1, 0x9D00C9C0
9D00C9B0  3090FFFF   ANDI S0, A0, -1
9D00C9B4  24020002   ADDIU V0, ZERO, 2
9D00C9B8  0B403275   J 0x9D00C9D4
9D00C9BC  AF828098   SW V0, -32616(GP)
101:                 	if (FBufCnt==3) {NVMflushBuf();}				// Align 32b
9D00C9C0  24030003   ADDIU V1, ZERO, 3
9D00C9C4  54430004   BNEL V0, V1, 0x9D00C9D8
9D00C9C8  8F828098   LW V0, -32616(GP)
9D00C9CC  0F4031FE   JAL NVMflushBuf
9D00C9D0  00000000   NOP
102:                 	*(WORD*)(pFBuf+FBufCnt)=Data; FBufCnt+=2;		// Write word to FBuf
9D00C9D4  8F828098   LW V0, -32616(GP)
9D00C9D8  8F838054   LW V1, -32684(GP)
9D00C9DC  00621021   ADDU V0, V1, V0
9D00C9E0  A4500000   SH S0, 0(V0)
9D00C9E4  8F828098   LW V0, -32616(GP)
9D00C9E8  24420002   ADDIU V0, V0, 2
9D00C9EC  AF828098   SW V0, -32616(GP)
103:                 
104:                 	if (FBufCnt>3)									// Full? Write to Flash
9D00C9F0  2C430004   SLTIU V1, V0, 4
9D00C9F4  14600008   BNE V1, ZERO, 0x9D00CA18
9D00C9F8  24020001   ADDIU V0, ZERO, 1
105:                 	{
106:                 	  FBufCnt=0; 
9D00C9FC  AF808098   SW ZERO, -32616(GP)
107:                 	  r=NVMwrite(vFHere,FBuf); vFHere++;			// 0-err, -1-NVM
9D00CA00  8F848114   LW A0, -32492(GP)
9D00CA04  0F4031D8   JAL NVMwrite
9D00CA08  8F858110   LW A1, -32496(GP)
9D00CA0C  8F838114   LW V1, -32492(GP)
9D00CA10  24630004   ADDIU V1, V1, 4
9D00CA14  AF838114   SW V1, -32492(GP)
108:                 	  return r;
109:                 	} else return 1;								// 1-Buf
110:                 }
9D00CA18  8FBF0014   LW RA, 20(SP)
9D00CA1C  8FB00010   LW S0, 16(SP)
9D00CA20  03E00008   JR RA
9D00CA24  27BD0018   ADDIU SP, SP, 24
111:                 
---  /Volumes/home/c11067/xc32/build/gcc/libgcc2.c  -----------------------------------------------------
9D00AC88  00C01021   ADDU V0, A2, ZERO
9D00B62C  00C01021   ADDU V0, A2, ZERO
9D00BAC4  00C04021   ADDU T0, A2, ZERO
9D00BF24  00C01021   ADDU V0, A2, ZERO
9D00AC8C  00804821   ADDU T1, A0, ZERO
9D00B630  00804821   ADDU T1, A0, ZERO
9D00BAC8  00804821   ADDU T1, A0, ZERO
9D00BF28  00804021   ADDU T0, A0, ZERO
9D00AC90  14E00045   BNE A3, ZERO, 0x9D00ADA8
9D00AC94  00A01821   ADDU V1, A1, ZERO
9D00B634  14E00041   BNE A3, ZERO, 0x9D00B73C
9D00B638  00A01821   ADDU V1, A1, ZERO
9D00BACC  14E0003B   BNE A3, ZERO, 0x9D00BBBC
9D00BAD0  00A01821   ADDU V1, A1, ZERO
9D00BF2C  14E0003D   BNE A3, ZERO, 0x9D00C024
9D00BF30  00A01821   ADDU V1, A1, ZERO
9D00AC98  00A6302B   SLTU A2, A1, A2
9D00AC9C  10C00066   BEQ A2, ZERO, 0x9D00AE38
9D00ACA0  70463020   CLZ A2, V0
9D00B63C  00A6302B   SLTU A2, A1, A2
9D00B640  10C0005F   BEQ A2, ZERO, 0x9D00B7C0
9D00B644  00000000   NOP
9D00BAD4  00A6102B   SLTU V0, A1, A2
9D00BAD8  10400048   BEQ V0, ZERO, 0x9D00BBFC
9D00BADC  70C21020   CLZ V0, A2
9D00BF34  00A6302B   SLTU A2, A1, A2
9D00BF38  10C00046   BEQ A2, ZERO, 0x9D00C054
9D00BF3C  00000000   NOP
9D00B648  70442020   CLZ A0, V0
9D00BF40  70442020   CLZ A0, V0
9D00ACA4  10C00008   BEQ A2, ZERO, 0x9D00ACC8
9D00ACA8  00025C02   SRL T3, V0, 16
9D00B64C  10800008   BEQ A0, ZERO, 0x9D00B670
9D00B650  00022C02   SRL A1, V0, 16
9D00BAE0  50400008   BEQL V0, ZERO, 0x9D00BB04
9D00BAE4  00083402   SRL A2, T0, 16
9D00BF44  10800008   BEQ A0, ZERO, 0x9D00BF68
9D00BF48  00022C02   SRL A1, V0, 16
9D00ACB8  00C21004   SLLV V0, V0, A2
9D00B660  00821004   SLLV V0, V0, A0
9D00BAF4  00464004   SLLV T0, A2, V0
9D00BF58  00821004   SLLV V0, V0, A0
9D00ACAC  00062023   SUBU A0, ZERO, A2
9D00ACB0  00892006   SRLV A0, T1, A0
9D00ACB4  00C51804   SLLV V1, A1, A2
9D00ACBC  00831825   OR V1, A0, V1
9D00B654  00042823   SUBU A1, ZERO, A0
9D00B658  00A92806   SRLV A1, T1, A1
9D00B65C  00831804   SLLV V1, V1, A0
9D00B664  00A31825   OR V1, A1, V1
9D00BAE8  00022023   SUBU A0, ZERO, V0
9D00BAEC  00892006   SRLV A0, T1, A0
9D00BAF0  00451804   SLLV V1, A1, V0
9D00BAF8  00831825   OR V1, A0, V1
9D00BF4C  00042823   SUBU A1, ZERO, A0
9D00BF50  00A82806   SRLV A1, T0, A1
9D00BF54  00831804   SLLV V1, V1, A0
9D00BF5C  00A31825   OR V1, A1, V1
9D00ACC0  00C94804   SLLV T1, T1, A2
9D00B668  00894804   SLLV T1, T1, A0
9D00BAFC  00494804   SLLV T1, T1, V0
9D00BF60  00884004   SLLV T0, T0, A0
9D00ACC4  00025C02   SRL T3, V0, 16
9D00ACC8  006B001B   DIVU V1, T3
9D00ACCC  016001F4   TEQ T3, ZERO
9D00ACD0  304EFFFF   ANDI T6, V0, -1
9D00ACD4  00092402   SRL A0, T1, 16
9D00ACD8  00006812   MFLO T5, 0
9D00ACDC  00006010   MFHI T4, 0
9D00ACE0  000C6400   SLL T4, T4, 16
9D00ACE4  01846025   OR T4, T4, A0
9D00ACE8  71AE6802   MUL T5, T5, T6
9D00ACEC  018D782B   SLTU T7, T4, T5
9D00ACF0  006B001B   DIVU V1, T3
9D00ACF4  016001F4   TEQ T3, ZERO
9D00ACF8  51E00009   BEQL T7, ZERO, 0x9D00AD20
9D00ACFC  018D6023   SUBU T4, T4, T5
9D00AD00  01826021   ADDU T4, T4, V0
9D00AD04  0182182B   SLTU V1, T4, V0
9D00AD08  54600005   BNEL V1, ZERO, 0x9D00AD20
9D00AD0C  018D6023   SUBU T4, T4, T5
9D00AD10  018D182B   SLTU V1, T4, T5
9D00AD14  70622002   MUL A0, V1, V0
9D00AD18  008C6021   ADDU T4, A0, T4
9D00AD1C  018D6023   SUBU T4, T4, T5
9D00AD20  018B001B   DIVU T4, T3
9D00AD24  016001F4   TEQ T3, ZERO
9D00AD28  3129FFFF   ANDI T1, T1, -1
9D00AD2C  00001812   MFLO V1, 0
9D00AD30  00002010   MFHI A0, 0
9D00AD34  00042400   SLL A0, A0, 16
9D00AD38  00894825   OR T1, A0, T1
9D00AD3C  706E1802   MUL V1, V1, T6
9D00AD40  0123202B   SLTU A0, T1, V1
9D00AD44  018B001B   DIVU T4, T3
9D00AD48  016001F4   TEQ T3, ZERO
9D00AD4C  50800009   BEQL A0, ZERO, 0x9D00AD74
9D00AD50  01234823   SUBU T1, T1, V1
9D00AD54  01224821   ADDU T1, T1, V0
9D00AD58  0122202B   SLTU A0, T1, V0
9D00AD5C  54800005   BNEL A0, ZERO, 0x9D00AD74
9D00AD60  01234823   SUBU T1, T1, V1
9D00AD64  0123202B   SLTU A0, T1, V1
9D00AD68  70822802   MUL A1, A0, V0
9D00AD6C  00A94821   ADDU T1, A1, T1
9D00AD70  01234823   SUBU T1, T1, V1
9D00B66C  00022C02   SRL A1, V0, 16
9D00B670  0065001B   DIVU V1, A1
9D00B674  00A001F4   TEQ A1, ZERO
9D00B678  304BFFFF   ANDI T3, V0, -1
9D00B67C  00096402   SRL T4, T1, 16
9D00B680  00005012   MFLO T2, 0
9D00B684  00003810   MFHI A3, 0
9D00B688  00073C00   SLL A3, A3, 16
9D00B68C  00EC3825   OR A3, A3, T4
9D00B690  714B2002   MUL A0, T2, T3
9D00B694  00E4302B   SLTU A2, A3, A0
9D00B698  0065001B   DIVU V1, A1
9D00B69C  00A001F4   TEQ A1, ZERO
9D00B6A0  10C0000B   BEQ A2, ZERO, 0x9D00B6D0
9D00B6A4  00E41823   SUBU V1, A3, A0
9D00B6A8  00E23821   ADDU A3, A3, V0
9D00B6AC  00E2182B   SLTU V1, A3, V0
9D00B6B0  14600006   BNE V1, ZERO, 0x9D00B6CC
9D00B6B4  254AFFFF   ADDIU T2, T2, -1
9D00B6B8  00E4182B   SLTU V1, A3, A0
9D00B6BC  10600004   BEQ V1, ZERO, 0x9D00B6D0
9D00B6C0  00E41823   SUBU V1, A3, A0
9D00B6C4  254AFFFF   ADDIU T2, T2, -1
9D00B6C8  00E23821   ADDU A3, A3, V0
9D00B6CC  00E41823   SUBU V1, A3, A0
9D00B6D0  0065001B   DIVU V1, A1
9D00B6D4  00A001F4   TEQ A1, ZERO
9D00B6D8  3129FFFF   ANDI T1, T1, -1
9D00B6DC  00002012   MFLO A0, 0
9D00B6E0  00003010   MFHI A2, 0
9D00B6E4  00063400   SLL A2, A2, 16
9D00B6E8  00C94825   OR T1, A2, T1
9D00B6EC  708B5802   MUL T3, A0, T3
9D00B6F0  012B302B   SLTU A2, T1, T3
9D00B6F4  0065001B   DIVU V1, A1
9D00B6F8  00A001F4   TEQ A1, ZERO
9D00B6FC  50C00008   BEQL A2, ZERO, 0x9D00B720
9D00B700  000A5400   SLL T2, T2, 16
9D00B704  01224821   ADDU T1, T1, V0
9D00B708  0122102B   SLTU V0, T1, V0
9D00B70C  14400003   BNE V0, ZERO, 0x9D00B71C
9D00B710  2484FFFF   ADDIU A0, A0, -1
9D00B714  012B582B   SLTU T3, T1, T3
9D00B718  008B2023   SUBU A0, A0, T3
9D00B71C  000A5400   SLL T2, T2, 16
9D00B720  008A2025   OR A0, A0, T2
9D00B724  00002821   ADDU A1, ZERO, ZERO
9D00BB00  00083402   SRL A2, T0, 16
9D00BB04  0066001B   DIVU V1, A2
9D00BB08  00C001F4   TEQ A2, ZERO
9D00BB0C  310CFFFF   ANDI T4, T0, -1
9D00BB10  00092402   SRL A0, T1, 16
9D00BB14  00005812   MFLO T3, 0
9D00BB18  00005010   MFHI T2, 0
9D00BB1C  000A5400   SLL T2, T2, 16
9D00BB20  01445025   OR T2, T2, A0
9D00BB24  716C5802   MUL T3, T3, T4
9D00BB28  014B682B   SLTU T5, T2, T3
9D00BB2C  0066001B   DIVU V1, A2
9D00BB30  00C001F4   TEQ A2, ZERO
9D00BB34  51A00009   BEQL T5, ZERO, 0x9D00BB5C
9D00BB38  014B5023   SUBU T2, T2, T3
9D00BB3C  01485021   ADDU T2, T2, T0
9D00BB40  0148182B   SLTU V1, T2, T0
9D00BB44  54600005   BNEL V1, ZERO, 0x9D00BB5C
9D00BB48  014B5023   SUBU T2, T2, T3
9D00BB4C  014B182B   SLTU V1, T2, T3
9D00BB50  70682002   MUL A0, V1, T0
9D00BB54  008A5021   ADDU T2, A0, T2
9D00BB58  014B5023   SUBU T2, T2, T3
9D00BB5C  0146001B   DIVU T2, A2
9D00BB60  00C001F4   TEQ A2, ZERO
9D00BB64  3129FFFF   ANDI T1, T1, -1
9D00BB68  00002012   MFLO A0, 0
9D00BB6C  00001810   MFHI V1, 0
9D00BB70  00031C00   SLL V1, V1, 16
9D00BB74  00694825   OR T1, V1, T1
9D00BB78  708C2002   MUL A0, A0, T4
9D00BB7C  0124182B   SLTU V1, T1, A0
9D00BB80  0146001B   DIVU T2, A2
9D00BB84  00C001F4   TEQ A2, ZERO
9D00BB88  50600009   BEQL V1, ZERO, 0x9D00BBB0
9D00BB8C  01244823   SUBU T1, T1, A0
9D00BB90  01284821   ADDU T1, T1, T0
9D00BB94  0128182B   SLTU V1, T1, T0
9D00BB98  54600005   BNEL V1, ZERO, 0x9D00BBB0
9D00BB9C  01244823   SUBU T1, T1, A0
9D00BBA0  0124182B   SLTU V1, T1, A0
9D00BBA4  70682802   MUL A1, V1, T0
9D00BBA8  00A94821   ADDU T1, A1, T1
9D00BBAC  01244823   SUBU T1, T1, A0
9D00BF64  00022C02   SRL A1, V0, 16
9D00BF68  0065001B   DIVU V1, A1
9D00BF6C  00A001F4   TEQ A1, ZERO
9D00BF70  304AFFFF   ANDI T2, V0, -1
9D00BF74  00085C02   SRL T3, T0, 16
9D00BF78  00004812   MFLO T1, 0
9D00BF7C  00003810   MFHI A3, 0
9D00BF80  00073C00   SLL A3, A3, 16
9D00BF84  00EB3825   OR A3, A3, T3
9D00BF88  712A2002   MUL A0, T1, T2
9D00BF8C  00E4302B   SLTU A2, A3, A0
9D00BF90  0065001B   DIVU V1, A1
9D00BF94  00A001F4   TEQ A1, ZERO
9D00BF98  10C0000B   BEQ A2, ZERO, 0x9D00BFC8
9D00BF9C  00E41823   SUBU V1, A3, A0
9D00BFA0  00E23821   ADDU A3, A3, V0
9D00BFA4  00E2182B   SLTU V1, A3, V0
9D00BFA8  14600006   BNE V1, ZERO, 0x9D00BFC4
9D00BFAC  2529FFFF   ADDIU T1, T1, -1
9D00BFB0  00E4182B   SLTU V1, A3, A0
9D00BFB4  10600004   BEQ V1, ZERO, 0x9D00BFC8
9D00BFB8  00E41823   SUBU V1, A3, A0
9D00BFBC  2529FFFF   ADDIU T1, T1, -1
9D00BFC0  00E23821   ADDU A3, A3, V0
9D00BFC4  00E41823   SUBU V1, A3, A0
9D00BFC8  0065001B   DIVU V1, A1
9D00BFCC  00A001F4   TEQ A1, ZERO
9D00BFD0  3108FFFF   ANDI T0, T0, -1
9D00BFD4  00002012   MFLO A0, 0
9D00BFD8  00003010   MFHI A2, 0
9D00BFDC  00063400   SLL A2, A2, 16
9D00BFE0  00C84025   OR T0, A2, T0
9D00BFE4  708A5002   MUL T2, A0, T2
9D00BFE8  010A302B   SLTU A2, T0, T2
9D00BFEC  0065001B   DIVU V1, A1
9D00BFF0  00A001F4   TEQ A1, ZERO
9D00BFF4  10C00006   BEQ A2, ZERO, 0x9D00C010
9D00BFF8  01024021   ADDU T0, T0, V0
9D00BFFC  0102102B   SLTU V0, T0, V0
9D00C000  14400003   BNE V0, ZERO, 0x9D00C010
9D00C004  2484FFFF   ADDIU A0, A0, -1
9D00C008  010A502B   SLTU T2, T0, T2
9D00C00C  008A2023   SUBU A0, A0, T2
9D00C010  00094C00   SLL T1, T1, 16
9D00C014  00892025   OR A0, A0, T1
9D00C018  00001821   ADDU V1, ZERO, ZERO
9D00AE38  14400006   BNE V0, ZERO, 0x9D00AE54
9D00AE3C  00000000   NOP
9D00B7C0  14400006   BNE V0, ZERO, 0x9D00B7DC
9D00B7C4  70463020   CLZ A2, V0
9D00BBFC  14C00006   BNE A2, ZERO, 0x9D00BC18
9D00BC00  71021020   CLZ V0, T0
9D00C054  14400006   BNE V0, ZERO, 0x9D00C070
9D00C058  70463020   CLZ A2, V0
9D00AE40  24020001   ADDIU V0, ZERO, 1
9D00AE44  0047001B   DIVU V0, A3
9D00AE48  00E001F4   TEQ A3, ZERO
9D00AE4C  00001012   MFLO V0, 0
9D00B7C8  24020001   ADDIU V0, ZERO, 1
9D00B7CC  0047001B   DIVU V0, A3
9D00B7D0  00E001F4   TEQ A3, ZERO
9D00B7D4  00001012   MFLO V0, 0
9D00BC04  24020001   ADDIU V0, ZERO, 1
9D00BC08  0046001B   DIVU V0, A2
9D00BC0C  00C001F4   TEQ A2, ZERO
9D00BC10  00004012   MFLO T0, 0
9D00C05C  24030001   ADDIU V1, ZERO, 1
9D00C060  0062001B   DIVU V1, V0
9D00C064  004001F4   TEQ V0, ZERO
9D00C068  00001012   MFLO V0, 0
9D00AE50  70463020   CLZ A2, V0
9D00B7D8  70463020   CLZ A2, V0
9D00BC14  71021020   CLZ V0, T0
9D00C06C  70463020   CLZ A2, V0
9D00AE54  54C0002F   BNEL A2, ZERO, 0x9D00AF14
9D00AE58  24090020   ADDIU T1, ZERO, 32
9D00B7DC  54C00030   BNEL A2, ZERO, 0x9D00B8A0
9D00B7E0  24090020   ADDIU T1, ZERO, 32
9D00BC18  5440007C   BNEL V0, ZERO, 0x9D00BE0C
9D00BC1C  24090020   ADDIU T1, ZERO, 32
9D00C070  54C00077   BNEL A2, ZERO, 0x9D00C250
9D00C074  24080020   ADDIU T0, ZERO, 32
9D00AE5C  00A22823   SUBU A1, A1, V0
9D00AE60  00021C02   SRL V1, V0, 16
9D00AE64  3047FFFF   ANDI A3, V0, -1
9D00B7E4  00A25823   SUBU T3, A1, V0
9D00B7E8  00023C02   SRL A3, V0, 16
9D00B7EC  304DFFFF   ANDI T5, V0, -1
9D00BC20  00A82823   SUBU A1, A1, T0
9D00BC24  00081C02   SRL V1, T0, 16
9D00BC28  3107FFFF   ANDI A3, T0, -1
9D00C078  00A24823   SUBU T1, A1, V0
9D00C07C  00023C02   SRL A3, V0, 16
9D00C080  304CFFFF   ANDI T4, V0, -1
9D00B7F0  24050001   ADDIU A1, ZERO, 1
9D00C084  24030001   ADDIU V1, ZERO, 1
9D00AF14  01264823   SUBU T1, T1, A2
9D00B8A0  01264823   SUBU T1, T1, A2
9D00BE0C  01224823   SUBU T1, T1, V0
9D00C254  01064023   SUBU T0, T0, A2
9D00AF18  00C21004   SLLV V0, V0, A2
9D00B8A4  00C21004   SLLV V0, V0, A2
9D00BE10  00484004   SLLV T0, T0, V0
9D00C250  00C21004   SLLV V0, V0, A2
9D00AF1C  01255806   SRLV T3, A1, T1
9D00B8A8  01255006   SRLV T2, A1, T1
9D00BE14  01253006   SRLV A2, A1, T1
9D00C258  01055006   SRLV T2, A1, T0
9D00AF30  01246806   SRLV T5, A0, T1
9D00AF34  00C52804   SLLV A1, A1, A2
9D00AF38  01A56825   OR T5, T5, A1
9D00B8BC  00C52804   SLLV A1, A1, A2
9D00B8C0  01245806   SRLV T3, A0, T1
9D00B8C8  01655825   OR T3, T3, A1
9D00BE28  01245806   SRLV T3, A0, T1
9D00BE2C  00452804   SLLV A1, A1, V0
9D00BE30  01655825   OR T3, T3, A1
9D00C268  01044006   SRLV T0, A0, T0
9D00C26C  00C52804   SLLV A1, A1, A2
9D00C274  01052825   OR A1, T0, A1
9D00AF40  00C44804   SLLV T1, A0, A2
9D00B8C4  00C44804   SLLV T1, A0, A2
9D00BE38  00444804   SLLV T1, A0, V0
9D00C278  00C44004   SLLV T0, A0, A2
9D00AF20  00021C02   SRL V1, V0, 16
9D00AF24  0163001B   DIVU T3, V1
9D00AF28  006001F4   TEQ V1, ZERO
9D00AF2C  3047FFFF   ANDI A3, V0, -1
9D00AF3C  000D2C02   SRL A1, T5, 16
9D00AF44  00006012   MFLO T4, 0
9D00AF48  00007010   MFHI T6, 0
9D00AF4C  000E2400   SLL A0, T6, 16
9D00AF50  00A42025   OR A0, A1, A0
9D00AF54  71876002   MUL T4, T4, A3
9D00AF58  008C282B   SLTU A1, A0, T4
9D00AF5C  0163001B   DIVU T3, V1
9D00AF60  006001F4   TEQ V1, ZERO
9D00AF64  50A00006   BEQL A1, ZERO, 0x9D00AF80
9D00AF68  008C2023   SUBU A0, A0, T4
9D00AF6C  00822021   ADDU A0, A0, V0
9D00AF70  0082282B   SLTU A1, A0, V0
9D00AF74  10A0006D   BEQ A1, ZERO, 0x9D00B12C
9D00AF78  008C282B   SLTU A1, A0, T4
9D00AF7C  008C2023   SUBU A0, A0, T4
9D00AF80  0083001B   DIVU A0, V1
9D00AF84  006001F4   TEQ V1, ZERO
9D00AF88  31ADFFFF   ANDI T5, T5, -1
9D00AF8C  00005812   MFLO T3, 0
9D00AF90  00002810   MFHI A1, 0
9D00AF94  00052C00   SLL A1, A1, 16
9D00AF98  00AD2825   OR A1, A1, T5
9D00AF9C  71675802   MUL T3, T3, A3
9D00AFA0  00AB602B   SLTU T4, A1, T3
9D00AFA4  0083001B   DIVU A0, V1
9D00AFA8  006001F4   TEQ V1, ZERO
9D00AFAC  5180FFAE   BEQL T4, ZERO, 0x9D00AE68
9D00AFB0  00AB2823   SUBU A1, A1, T3
9D00AFB4  00A22821   ADDU A1, A1, V0
9D00AFB8  00A2202B   SLTU A0, A1, V0
9D00AFBC  5480FFAA   BNEL A0, ZERO, 0x9D00AE68
9D00AFC0  00AB2823   SUBU A1, A1, T3
9D00AFC4  00AB202B   SLTU A0, A1, T3
9D00AFC8  70826002   MUL T4, A0, V0
9D00AFCC  01852821   ADDU A1, T4, A1
9D00AFD0  0B402B9A   J 0x9D00AE68
9D00AFD4  00AB2823   SUBU A1, A1, T3
9D00B12C  70A25802   MUL T3, A1, V0
9D00B130  0B402BDF   J 0x9D00AF7C
9D00B134  01642021   ADDU A0, T3, A0
9D00B8AC  00023C02   SRL A3, V0, 16
9D00B8B0  0147001B   DIVU T2, A3
9D00B8B4  00E001F4   TEQ A3, ZERO
9D00B8B8  304DFFFF   ANDI T5, V0, -1
9D00B8CC  000B6402   SRL T4, T3, 16
9D00B8D0  00001812   MFLO V1, 0
9D00B8D4  00007010   MFHI T6, 0
9D00B8D8  000E2400   SLL A0, T6, 16
9D00B8DC  01842025   OR A0, T4, A0
9D00B8E0  00003012   MFLO A2, 0
9D00B8E4  706D1802   MUL V1, V1, T5
9D00B8E8  0083282B   SLTU A1, A0, V1
9D00B8EC  0147001B   DIVU T2, A3
9D00B8F0  00E001F4   TEQ A3, ZERO
9D00B8F4  50A0000B   BEQL A1, ZERO, 0x9D00B924
9D00B8F8  00832023   SUBU A0, A0, V1
9D00B8FC  00822021   ADDU A0, A0, V0
9D00B900  0082282B   SLTU A1, A0, V0
9D00B904  14A00006   BNE A1, ZERO, 0x9D00B920
9D00B908  24C6FFFF   ADDIU A2, A2, -1
9D00B90C  0083282B   SLTU A1, A0, V1
9D00B910  50A00004   BEQL A1, ZERO, 0x9D00B924
9D00B914  00832023   SUBU A0, A0, V1
9D00B918  24C6FFFF   ADDIU A2, A2, -1
9D00B91C  00822021   ADDU A0, A0, V0
9D00B920  00832023   SUBU A0, A0, V1
9D00B924  0087001B   DIVU A0, A3
9D00B928  00E001F4   TEQ A3, ZERO
9D00B92C  316BFFFF   ANDI T3, T3, -1
9D00B930  00001812   MFLO V1, 0
9D00B934  00002810   MFHI A1, 0
9D00B938  00052C00   SLL A1, A1, 16
9D00B93C  00AB5825   OR T3, A1, T3
9D00B940  706D5002   MUL T2, V1, T5
9D00B944  016A282B   SLTU A1, T3, T2
9D00B948  0087001B   DIVU A0, A3
9D00B94C  00E001F4   TEQ A3, ZERO
9D00B950  50A0000B   BEQL A1, ZERO, 0x9D00B980
9D00B954  00062C00   SLL A1, A2, 16
9D00B958  01625821   ADDU T3, T3, V0
9D00B95C  0162202B   SLTU A0, T3, V0
9D00B960  14800006   BNE A0, ZERO, 0x9D00B97C
9D00B964  2463FFFF   ADDIU V1, V1, -1
9D00B968  016A202B   SLTU A0, T3, T2
9D00B96C  50800004   BEQL A0, ZERO, 0x9D00B980
9D00B970  00062C00   SLL A1, A2, 16
9D00B974  2463FFFF   ADDIU V1, V1, -1
9D00B978  01625821   ADDU T3, T3, V0
9D00B97C  00062C00   SLL A1, A2, 16
9D00B980  016A5823   SUBU T3, T3, T2
9D00B984  0B402DFD   J 0x9D00B7F4
9D00B988  00652825   OR A1, V1, A1
9D00BE18  00081C02   SRL V1, T0, 16
9D00BE1C  00C3001B   DIVU A2, V1
9D00BE20  006001F4   TEQ V1, ZERO
9D00BE24  3107FFFF   ANDI A3, T0, -1
9D00BE34  000B2C02   SRL A1, T3, 16
9D00BE3C  00005012   MFLO T2, 0
9D00BE40  00006010   MFHI T4, 0
9D00BE44  000C2400   SLL A0, T4, 16
9D00BE48  00A42025   OR A0, A1, A0
9D00BE4C  71475002   MUL T2, T2, A3
9D00BE50  008A282B   SLTU A1, A0, T2
9D00BE54  00C3001B   DIVU A2, V1
9D00BE58  006001F4   TEQ V1, ZERO
9D00BE5C  50A00006   BEQL A1, ZERO, 0x9D00BE78
9D00BE60  008A2023   SUBU A0, A0, T2
9D00BE64  00882021   ADDU A0, A0, T0
9D00BE68  0088282B   SLTU A1, A0, T0
9D00BE6C  10A00024   BEQ A1, ZERO, 0x9D00BF00
9D00BE70  008A282B   SLTU A1, A0, T2
9D00BE74  008A2023   SUBU A0, A0, T2
9D00BE78  0083001B   DIVU A0, V1
9D00BE7C  006001F4   TEQ V1, ZERO
9D00BE80  316BFFFF   ANDI T3, T3, -1
9D00BE84  00003012   MFLO A2, 0
9D00BE88  00002810   MFHI A1, 0
9D00BE8C  00052C00   SLL A1, A1, 16
9D00BE90  00AB2825   OR A1, A1, T3
9D00BE94  70C73002   MUL A2, A2, A3
9D00BE98  00A6502B   SLTU T2, A1, A2
9D00BE9C  0083001B   DIVU A0, V1
9D00BEA0  006001F4   TEQ V1, ZERO
9D00BEA4  5140FF61   BEQL T2, ZERO, 0x9D00BC2C
9D00BEA8  00A62823   SUBU A1, A1, A2
9D00BEAC  00A82821   ADDU A1, A1, T0
9D00BEB0  00A8202B   SLTU A0, A1, T0
9D00BEB4  5480FF5D   BNEL A0, ZERO, 0x9D00BC2C
9D00BEB8  00A62823   SUBU A1, A1, A2
9D00BEBC  00A6202B   SLTU A0, A1, A2
9D00BEC0  70885002   MUL T2, A0, T0
9D00BEC4  01452821   ADDU A1, T2, A1
9D00BEC8  0B402F0B   J 0x9D00BC2C
9D00BECC  00A62823   SUBU A1, A1, A2
9D00BF00  70A83002   MUL A2, A1, T0
9D00BF04  0B402F9D   J 0x9D00BE74
9D00BF08  00C42021   ADDU A0, A2, A0
9D00C25C  00023C02   SRL A3, V0, 16
9D00C260  0147001B   DIVU T2, A3
9D00C264  00E001F4   TEQ A3, ZERO
9D00C270  304CFFFF   ANDI T4, V0, -1
9D00C27C  00054C02   SRL T1, A1, 16
9D00C280  00001812   MFLO V1, 0
9D00C284  00005810   MFHI T3, 0
9D00C288  000B2400   SLL A0, T3, 16
9D00C28C  01242025   OR A0, T1, A0
9D00C290  00003012   MFLO A2, 0
9D00C294  706C1802   MUL V1, V1, T4
9D00C298  0083482B   SLTU T1, A0, V1
9D00C29C  0147001B   DIVU T2, A3
9D00C2A0  00E001F4   TEQ A3, ZERO
9D00C2A4  5120000B   BEQL T1, ZERO, 0x9D00C2D4
9D00C2A8  00832023   SUBU A0, A0, V1
9D00C2AC  00822021   ADDU A0, A0, V0
9D00C2B0  0082482B   SLTU T1, A0, V0
9D00C2B4  15200006   BNE T1, ZERO, 0x9D00C2D0
9D00C2B8  24C6FFFF   ADDIU A2, A2, -1
9D00C2BC  0083482B   SLTU T1, A0, V1
9D00C2C0  51200004   BEQL T1, ZERO, 0x9D00C2D4
9D00C2C4  00832023   SUBU A0, A0, V1
9D00C2C8  24C6FFFF   ADDIU A2, A2, -1
9D00C2CC  00822021   ADDU A0, A0, V0
9D00C2D0  00832023   SUBU A0, A0, V1
9D00C2D4  0087001B   DIVU A0, A3
9D00C2D8  00E001F4   TEQ A3, ZERO
9D00C2DC  30AAFFFF   ANDI T2, A1, -1
9D00C2E0  00001812   MFLO V1, 0
9D00C2E4  00004810   MFHI T1, 0
9D00C2E8  00094C00   SLL T1, T1, 16
9D00C2EC  012A4825   OR T1, T1, T2
9D00C2F0  706C2802   MUL A1, V1, T4
9D00C2F4  0125502B   SLTU T2, T1, A1
9D00C2F8  0087001B   DIVU A0, A3
9D00C2FC  00E001F4   TEQ A3, ZERO
9D00C300  5140000B   BEQL T2, ZERO, 0x9D00C330
9D00C304  00063400   SLL A2, A2, 16
9D00C308  01224821   ADDU T1, T1, V0
9D00C30C  0122202B   SLTU A0, T1, V0
9D00C310  14800006   BNE A0, ZERO, 0x9D00C32C
9D00C314  2463FFFF   ADDIU V1, V1, -1
9D00C318  0125202B   SLTU A0, T1, A1
9D00C31C  50800004   BEQL A0, ZERO, 0x9D00C330
9D00C320  00063400   SLL A2, A2, 16
9D00C324  2463FFFF   ADDIU V1, V1, -1
9D00C328  01224821   ADDU T1, T1, V0
9D00C32C  00063400   SLL A2, A2, 16
9D00C330  01254823   SUBU T1, T1, A1
9D00C334  0B403022   J 0x9D00C088
9D00C338  00661825   OR V1, V1, A2
9D00AE68  00A3001B   DIVU A1, V1
9D00AE6C  006001F4   TEQ V1, ZERO
9D00AE70  00096402   SRL T4, T1, 16
9D00AE74  00005812   MFLO T3, 0
9D00AE78  00002010   MFHI A0, 0
9D00AE7C  00042400   SLL A0, A0, 16
9D00AE80  008C2025   OR A0, A0, T4
9D00AE84  71675802   MUL T3, T3, A3
9D00AE88  008B602B   SLTU T4, A0, T3
9D00AE8C  00A3001B   DIVU A1, V1
9D00AE90  006001F4   TEQ V1, ZERO
9D00AE94  51800009   BEQL T4, ZERO, 0x9D00AEBC
9D00AE98  008B2023   SUBU A0, A0, T3
9D00AE9C  00822021   ADDU A0, A0, V0
9D00AEA0  0082282B   SLTU A1, A0, V0
9D00AEA4  54A00005   BNEL A1, ZERO, 0x9D00AEBC
9D00AEA8  008B2023   SUBU A0, A0, T3
9D00AEAC  008B282B   SLTU A1, A0, T3
9D00AEB0  70A26002   MUL T4, A1, V0
9D00AEB4  01842021   ADDU A0, T4, A0
9D00AEB8  008B2023   SUBU A0, A0, T3
9D00AEBC  0083001B   DIVU A0, V1
9D00AEC0  006001F4   TEQ V1, ZERO
9D00AEC4  3129FFFF   ANDI T1, T1, -1
9D00AEC8  00006012   MFLO T4, 0
9D00AECC  00002810   MFHI A1, 0
9D00AED0  00052C00   SLL A1, A1, 16
9D00AED4  00A94825   OR T1, A1, T1
9D00AED8  71873802   MUL A3, T4, A3
9D00AEDC  0127282B   SLTU A1, T1, A3
9D00AEE0  0083001B   DIVU A0, V1
9D00AEE4  006001F4   TEQ V1, ZERO
9D00AEE8  50A0FFA2   BEQL A1, ZERO, 0x9D00AD74
9D00AEEC  01274823   SUBU T1, T1, A3
9D00AEF0  01224821   ADDU T1, T1, V0
9D00AEF4  0122182B   SLTU V1, T1, V0
9D00AEF8  5460FF9E   BNEL V1, ZERO, 0x9D00AD74
9D00AEFC  01274823   SUBU T1, T1, A3
9D00AF00  0127182B   SLTU V1, T1, A3
9D00AF04  70622002   MUL A0, V1, V0
9D00AF08  00894821   ADDU T1, A0, T1
9D00AF0C  0B402B5D   J 0x9D00AD74
9D00AF10  01274823   SUBU T1, T1, A3
9D00B7F4  0167001B   DIVU T3, A3
9D00B7F8  00E001F4   TEQ A3, ZERO
9D00B7FC  00091C02   SRL V1, T1, 16
9D00B800  00006012   MFLO T4, 0
9D00B804  00005010   MFHI T2, 0
9D00B808  000A5400   SLL T2, T2, 16
9D00B80C  01435025   OR T2, T2, V1
9D00B810  718D2002   MUL A0, T4, T5
9D00B814  0144182B   SLTU V1, T2, A0
9D00B818  0167001B   DIVU T3, A3
9D00B81C  00E001F4   TEQ A3, ZERO
9D00B820  50600009   BEQL V1, ZERO, 0x9D00B848
9D00B824  01445023   SUBU T2, T2, A0
9D00B828  01425021   ADDU T2, T2, V0
9D00B82C  0142182B   SLTU V1, T2, V0
9D00B830  14600004   BNE V1, ZERO, 0x9D00B844
9D00B834  258CFFFF   ADDIU T4, T4, -1
9D00B838  0144182B   SLTU V1, T2, A0
9D00B83C  5460009F   BNEL V1, ZERO, 0x9D00BABC
9D00B840  258CFFFF   ADDIU T4, T4, -1
9D00B844  01445023   SUBU T2, T2, A0
9D00B848  0147001B   DIVU T2, A3
9D00B84C  00E001F4   TEQ A3, ZERO
9D00B850  3129FFFF   ANDI T1, T1, -1
9D00B854  00002012   MFLO A0, 0
9D00B858  00001810   MFHI V1, 0
9D00B85C  00031C00   SLL V1, V1, 16
9D00B860  00694825   OR T1, V1, T1
9D00B864  708D6802   MUL T5, A0, T5
9D00B868  012D182B   SLTU V1, T1, T5
9D00B86C  0147001B   DIVU T2, A3
9D00B870  00E001F4   TEQ A3, ZERO
9D00B874  50600008   BEQL V1, ZERO, 0x9D00B898
9D00B878  000C6400   SLL T4, T4, 16
9D00B87C  01224821   ADDU T1, T1, V0
9D00B880  0122102B   SLTU V0, T1, V0
9D00B884  14400003   BNE V0, ZERO, 0x9D00B894
9D00B888  2484FFFF   ADDIU A0, A0, -1
9D00B88C  012D682B   SLTU T5, T1, T5
9D00B890  008D2023   SUBU A0, A0, T5
9D00B894  000C6400   SLL T4, T4, 16
9D00B898  0B402DD4   J 0x9D00B750
9D00B89C  008C2025   OR A0, A0, T4
9D00BABC  0B402E11   J 0x9D00B844
9D00BAC0  01425021   ADDU T2, T2, V0
9D00BC2C  00A3001B   DIVU A1, V1
9D00BC30  006001F4   TEQ V1, ZERO
9D00BC34  00095402   SRL T2, T1, 16
9D00BC38  00002012   MFLO A0, 0
9D00BC3C  00003010   MFHI A2, 0
9D00BC40  00063400   SLL A2, A2, 16
9D00BC44  00CA3025   OR A2, A2, T2
9D00BC48  70872002   MUL A0, A0, A3
9D00BC4C  00C4502B   SLTU T2, A2, A0
9D00BC50  00A3001B   DIVU A1, V1
9D00BC54  006001F4   TEQ V1, ZERO
9D00BC58  51400009   BEQL T2, ZERO, 0x9D00BC80
9D00BC5C  00C43023   SUBU A2, A2, A0
9D00BC60  00C83021   ADDU A2, A2, T0
9D00BC64  00C8282B   SLTU A1, A2, T0
9D00BC68  54A00005   BNEL A1, ZERO, 0x9D00BC80
9D00BC6C  00C43023   SUBU A2, A2, A0
9D00BC70  00C4282B   SLTU A1, A2, A0
9D00BC74  70A85002   MUL T2, A1, T0
9D00BC78  01463021   ADDU A2, T2, A2
9D00BC7C  00C43023   SUBU A2, A2, A0
9D00BC80  00C3001B   DIVU A2, V1
9D00BC84  006001F4   TEQ V1, ZERO
9D00BC88  3129FFFF   ANDI T1, T1, -1
9D00BC8C  00005012   MFLO T2, 0
9D00BC90  00002010   MFHI A0, 0
9D00BC94  00042400   SLL A0, A0, 16
9D00BC98  00894825   OR T1, A0, T1
9D00BC9C  71473802   MUL A3, T2, A3
9D00BCA0  0127202B   SLTU A0, T1, A3
9D00BCA4  00C3001B   DIVU A2, V1
9D00BCA8  006001F4   TEQ V1, ZERO
9D00BCAC  50800009   BEQL A0, ZERO, 0x9D00BCD4
9D00BCB0  01274823   SUBU T1, T1, A3
9D00BCB4  01284821   ADDU T1, T1, T0
9D00BCB8  0128182B   SLTU V1, T1, T0
9D00BCBC  54600005   BNEL V1, ZERO, 0x9D00BCD4
9D00BCC0  01274823   SUBU T1, T1, A3
9D00BCC4  0127182B   SLTU V1, T1, A3
9D00BCC8  70682002   MUL A0, V1, T0
9D00BCCC  00894821   ADDU T1, A0, T1
9D00BCD0  01274823   SUBU T1, T1, A3
9D00C088  0127001B   DIVU T1, A3
9D00C08C  00E001F4   TEQ A3, ZERO
9D00C090  00086C02   SRL T5, T0, 16
9D00C094  00005812   MFLO T3, 0
9D00C098  00005010   MFHI T2, 0
9D00C09C  000A5400   SLL T2, T2, 16
9D00C0A0  014D5025   OR T2, T2, T5
9D00C0A4  716C2002   MUL A0, T3, T4
9D00C0A8  0144302B   SLTU A2, T2, A0
9D00C0AC  0127001B   DIVU T1, A3
9D00C0B0  00E001F4   TEQ A3, ZERO
9D00C0B4  10C00009   BEQ A2, ZERO, 0x9D00C0DC
9D00C0B8  01442823   SUBU A1, T2, A0
9D00C0BC  01425021   ADDU T2, T2, V0
9D00C0C0  0142282B   SLTU A1, T2, V0
9D00C0C4  14A00004   BNE A1, ZERO, 0x9D00C0D8
9D00C0C8  256BFFFF   ADDIU T3, T3, -1
9D00C0CC  0144282B   SLTU A1, T2, A0
9D00C0D0  54A000A2   BNEL A1, ZERO, 0x9D00C35C
9D00C0D4  256BFFFF   ADDIU T3, T3, -1
9D00C0D8  01442823   SUBU A1, T2, A0
9D00C0DC  00A7001B   DIVU A1, A3
9D00C0E0  00E001F4   TEQ A3, ZERO
9D00C0E4  3108FFFF   ANDI T0, T0, -1
9D00C0E8  00002012   MFLO A0, 0
9D00C0EC  00003010   MFHI A2, 0
9D00C0F0  00063400   SLL A2, A2, 16
9D00C0F4  00C84025   OR T0, A2, T0
9D00C0F8  708C6002   MUL T4, A0, T4
9D00C0FC  010C302B   SLTU A2, T0, T4
9D00C100  00A7001B   DIVU A1, A3
9D00C104  00E001F4   TEQ A3, ZERO
9D00C108  10C00006   BEQ A2, ZERO, 0x9D00C124
9D00C10C  01024021   ADDU T0, T0, V0
9D00C110  0102102B   SLTU V0, T0, V0
9D00C114  14400003   BNE V0, ZERO, 0x9D00C124
9D00C118  2484FFFF   ADDIU A0, A0, -1
9D00C11C  010C602B   SLTU T4, T0, T4
9D00C120  008C2023   SUBU A0, A0, T4
9D00C124  000B5C00   SLL T3, T3, 16
9D00C128  008B2025   OR A0, A0, T3
9D00C35C  0B403036   J 0x9D00C0D8
9D00C360  01425021   ADDU T2, T2, V0
9D00AD74  00C93006   SRLV A2, T1, A2
9D00BBB0  00491006   SRLV V0, T1, V0
9D00BCD4  00491006   SRLV V0, T1, V0
9D00AD78  AD060000   SW A2, 0(T0)
9D00AD7C  AD000004   SW ZERO, 4(T0)
9D00BBB4  03E00008   JR RA
9D00BBB8  00001821   ADDU V1, ZERO, ZERO
9D00BCD8  03E00008   JR RA
9D00BCDC  00001821   ADDU V1, ZERO, ZERO
9D00ADA8  00A7102B   SLTU V0, A1, A3
9D00ADAC  10400013   BEQ V0, ZERO, 0x9D00ADFC
9D00ADB0  70E94820   CLZ T1, A3
9D00B73C  00A7102B   SLTU V0, A1, A3
9D00B740  50400017   BEQL V0, ZERO, 0x9D00B7A0
9D00B744  70E31820   CLZ V1, A3
9D00B748  00002821   ADDU A1, ZERO, ZERO
9D00B74C  00002021   ADDU A0, ZERO, ZERO
9D00BBBC  00A7102B   SLTU V0, A1, A3
9D00BBC0  14400047   BNE V0, ZERO, 0x9D00BCE0
9D00BBC4  70E84020   CLZ T0, A3
9D00C024  00A7102B   SLTU V0, A1, A3
9D00C028  54400042   BNEL V0, ZERO, 0x9D00C134
9D00C02C  00002021   ADDU A0, ZERO, ZERO
9D00C134  00001821   ADDU V1, ZERO, ZERO
9D00ADB4  AFA40000   SW A0, 0(SP)
9D00BCE0  00801021   ADDU V0, A0, ZERO
9D00BCE4  03E00008   JR RA
9D00BCE8  00A01821   ADDU V1, A1, ZERO
9D00C030  70E31820   CLZ V1, A3
9D00ADFC  55200076   BNEL T1, ZERO, 0x9D00AFD8
9D00AE00  24030020   ADDIU V1, ZERO, 32
9D00B7A0  1460007A   BNE V1, ZERO, 0x9D00B98C
9D00B7A4  240C0020   ADDIU T4, ZERO, 32
9D00BBC8  15000048   BNE T0, ZERO, 0x9D00BCEC
9D00BBCC  240A0020   ADDIU T2, ZERO, 32
9D00C034  14600042   BNE V1, ZERO, 0x9D00C140
9D00C038  240B0020   ADDIU T3, ZERO, 32
9D00AE04  00E5102B   SLTU V0, A3, A1
9D00AE08  14400005   BNE V0, ZERO, 0x9D00AE20
9D00AE0C  00864823   SUBU T1, A0, A2
9D00AE10  0086102B   SLTU V0, A0, A2
9D00AE14  14400005   BNE V0, ZERO, 0x9D00AE2C
9D00AE18  00804821   ADDU T1, A0, ZERO
9D00B7A8  00E5282B   SLTU A1, A3, A1
9D00B7AC  54A000C1   BNEL A1, ZERO, 0x9D00BAB4
9D00B7B0  00002821   ADDU A1, ZERO, ZERO
9D00B7B4  0086202B   SLTU A0, A0, A2
9D00B7B8  0B402DD4   J 0x9D00B750
9D00B7BC  2C840001   SLTIU A0, A0, 1
9D00BAB4  0B402DD4   J 0x9D00B750
9D00BAB8  24040001   ADDIU A0, ZERO, 1
9D00BBD0  00E5102B   SLTU V0, A3, A1
9D00BBD4  14400005   BNE V0, ZERO, 0x9D00BBEC
9D00BBD8  00861023   SUBU V0, A0, A2
9D00BBDC  0086402B   SLTU T0, A0, A2
9D00BBE0  15000088   BNE T0, ZERO, 0x9D00BE04
9D00BBE4  00801021   ADDU V0, A0, ZERO
9D00C03C  00E5282B   SLTU A1, A3, A1
9D00C040  54A000C4   BNEL A1, ZERO, 0x9D00C354
9D00C044  00001821   ADDU V1, ZERO, ZERO
9D00C048  0086202B   SLTU A0, A0, A2
9D00C04C  0B403007   J 0x9D00C01C
9D00C050  2C840001   SLTIU A0, A0, 1
9D00C354  0B403007   J 0x9D00C01C
9D00C358  24040001   ADDIU A0, ZERO, 1
9D00AE1C  00864823   SUBU T1, A0, A2
9D00AE20  00A72823   SUBU A1, A1, A3
9D00AE24  0089202B   SLTU A0, A0, T1
9D00AE28  00A41823   SUBU V1, A1, A0
9D00BBE8  00861023   SUBU V0, A0, A2
9D00BBEC  00A71823   SUBU V1, A1, A3
9D00BBF0  0082202B   SLTU A0, A0, V0
9D00BBF4  03E00008   JR RA
9D00BBF8  00641823   SUBU V1, V1, A0
9D00AE2C  AD090000   SW T1, 0(T0)
9D00AE30  0B402B60   J 0x9D00AD80
9D00AE34  AD030004   SW V1, 4(T0)
9D00AFD8  00691823   SUBU V1, V1, T1
9D00B98C  01836023   SUBU T4, T4, V1
9D00BCEC  01485023   SUBU T2, T2, T0
9D00C140  01635823   SUBU T3, T3, V1
9D00AFDC  00661006   SRLV V0, A2, V1
9D00AFE0  01273804   SLLV A3, A3, T1
9D00AFE4  00473825   OR A3, V0, A3
9D00B990  01861006   SRLV V0, A2, T4
9D00B994  00673804   SLLV A3, A3, V1
9D00B998  00473825   OR A3, V0, A3
9D00BCF0  01461006   SRLV V0, A2, T2
9D00BCF4  01073804   SLLV A3, A3, T0
9D00BCF8  00473825   OR A3, V0, A3
9D00C144  01661006   SRLV V0, A2, T3
9D00C148  00673804   SLLV A3, A3, V1
9D00C14C  00473825   OR A3, V0, A3
9D00B00C  0126C004   SLLV T8, A2, T1
9D00BD20  01063004   SLLV A2, A2, T0
9D00AFE8  00656006   SRLV T4, A1, V1
9D00B99C  01855006   SRLV T2, A1, T4
9D00BCFC  01455806   SRLV T3, A1, T2
9D00C150  01654806   SRLV T1, A1, T3
9D00AFF8  00647806   SRLV T7, A0, V1
9D00B000  01252804   SLLV A1, A1, T1
9D00B004  01E52825   OR A1, T7, A1
9D00B9B0  01846006   SRLV T4, A0, T4
9D00B9B4  00652804   SLLV A1, A1, V1
9D00B9B8  01852825   OR A1, T4, A1
9D00BD10  01441806   SRLV V1, A0, T2
9D00BD14  01052804   SLLV A1, A1, T0
9D00BD18  00652825   OR A1, V1, A1
9D00C164  01645806   SRLV T3, A0, T3
9D00C168  00652804   SLLV A1, A1, V1
9D00C16C  01652825   OR A1, T3, A1
9D00AFEC  00071402   SRL V0, A3, 16
9D00AFF0  0182001B   DIVU T4, V0
9D00AFF4  004001F4   TEQ V0, ZERO
9D00AFFC  30EEFFFF   ANDI T6, A3, -1
9D00B008  0005CC02   SRL T9, A1, 16
9D00B010  00006812   MFLO T5, 0
9D00B014  00005810   MFHI T3, 0
9D00B018  000B5C00   SLL T3, T3, 16
9D00B01C  01795825   OR T3, T3, T9
9D00B020  71AE7802   MUL T7, T5, T6
9D00B024  016F302B   SLTU A2, T3, T7
9D00B028  0182001B   DIVU T4, V0
9D00B02C  004001F4   TEQ V0, ZERO
9D00B030  10C0000A   BEQ A2, ZERO, 0x9D00B05C
9D00B034  01242004   SLLV A0, A0, T1
9D00B038  01675821   ADDU T3, T3, A3
9D00B03C  0167302B   SLTU A2, T3, A3
9D00B040  14C00006   BNE A2, ZERO, 0x9D00B05C
9D00B044  25ADFFFF   ADDIU T5, T5, -1
9D00B048  016F302B   SLTU A2, T3, T7
9D00B04C  50C00004   BEQL A2, ZERO, 0x9D00B060
9D00B050  016F5823   SUBU T3, T3, T7
9D00B054  25ADFFFF   ADDIU T5, T5, -1
9D00B058  01675821   ADDU T3, T3, A3
9D00B05C  016F5823   SUBU T3, T3, T7
9D00B060  0162001B   DIVU T3, V0
9D00B064  004001F4   TEQ V0, ZERO
9D00B068  30A5FFFF   ANDI A1, A1, -1
9D00B06C  00006012   MFLO T4, 0
9D00B070  00003010   MFHI A2, 0
9D00B074  00063400   SLL A2, A2, 16
9D00B078  00C52825   OR A1, A2, A1
9D00B07C  718E7002   MUL T6, T4, T6
9D00B080  00AE302B   SLTU A2, A1, T6
9D00B084  0162001B   DIVU T3, V0
9D00B088  004001F4   TEQ V0, ZERO
9D00B08C  50C0000B   BEQL A2, ZERO, 0x9D00B0BC
9D00B090  000D6C00   SLL T5, T5, 16
9D00B094  00A72821   ADDU A1, A1, A3
9D00B098  00A7102B   SLTU V0, A1, A3
9D00B09C  14400006   BNE V0, ZERO, 0x9D00B0B8
9D00B0A0  258CFFFF   ADDIU T4, T4, -1
9D00B0A4  00AE102B   SLTU V0, A1, T6
9D00B0A8  50400004   BEQL V0, ZERO, 0x9D00B0BC
9D00B0AC  000D6C00   SLL T5, T5, 16
9D00B0B0  258CFFFF   ADDIU T4, T4, -1
9D00B0B4  00A72821   ADDU A1, A1, A3
9D00B0B8  000D6C00   SLL T5, T5, 16
9D00B0BC  018D6025   OR T4, T4, T5
9D00B0C4  00AE2823   SUBU A1, A1, T6
9D00B9A0  00071402   SRL V0, A3, 16
9D00B9A4  0142001B   DIVU T2, V0
9D00B9A8  004001F4   TEQ V0, ZERO
9D00B9AC  30EDFFFF   ANDI T5, A3, -1
9D00B9BC  00056402   SRL T4, A1, 16
9D00B9C0  00005812   MFLO T3, 0
9D00B9C4  00004810   MFHI T1, 0
9D00B9C8  00094C00   SLL T1, T1, 16
9D00B9CC  012C4825   OR T1, T1, T4
9D00B9D0  716D7002   MUL T6, T3, T5
9D00B9D4  012E602B   SLTU T4, T1, T6
9D00B9D8  0142001B   DIVU T2, V0
9D00B9DC  004001F4   TEQ V0, ZERO
9D00B9E0  1180000A   BEQ T4, ZERO, 0x9D00BA0C
9D00B9E4  00663004   SLLV A2, A2, V1
9D00B9E8  01274821   ADDU T1, T1, A3
9D00B9EC  0127502B   SLTU T2, T1, A3
9D00B9F0  15400006   BNE T2, ZERO, 0x9D00BA0C
9D00B9F4  256BFFFF   ADDIU T3, T3, -1
9D00B9F8  012E502B   SLTU T2, T1, T6
9D00B9FC  51400004   BEQL T2, ZERO, 0x9D00BA10
9D00BA00  012E4823   SUBU T1, T1, T6
9D00BA04  256BFFFF   ADDIU T3, T3, -1
9D00BA08  01274821   ADDU T1, T1, A3
9D00BA0C  012E4823   SUBU T1, T1, T6
9D00BA10  0122001B   DIVU T1, V0
9D00BA14  004001F4   TEQ V0, ZERO
9D00BA18  30A5FFFF   ANDI A1, A1, -1
9D00BA1C  00005012   MFLO T2, 0
9D00BA20  00006010   MFHI T4, 0
9D00BA24  000C6400   SLL T4, T4, 16
9D00BA28  01852825   OR A1, T4, A1
9D00BA2C  714D6802   MUL T5, T2, T5
9D00BA30  00AD602B   SLTU T4, A1, T5
9D00BA34  0122001B   DIVU T1, V0
9D00BA38  004001F4   TEQ V0, ZERO
9D00BA3C  5180000B   BEQL T4, ZERO, 0x9D00BA6C
9D00BA40  000B5C00   SLL T3, T3, 16
9D00BA44  00A72821   ADDU A1, A1, A3
9D00BA48  00A7102B   SLTU V0, A1, A3
9D00BA4C  14400006   BNE V0, ZERO, 0x9D00BA68
9D00BA50  254AFFFF   ADDIU T2, T2, -1
9D00BA54  00AD102B   SLTU V0, A1, T5
9D00BA58  50400004   BEQL V0, ZERO, 0x9D00BA6C
9D00BA5C  000B5C00   SLL T3, T3, 16
9D00BA60  254AFFFF   ADDIU T2, T2, -1
9D00BA64  00A72821   ADDU A1, A1, A3
9D00BA68  000B5C00   SLL T3, T3, 16
9D00BA6C  014B5025   OR T2, T2, T3
9D00BA74  00AD2823   SUBU A1, A1, T5
9D00BD00  00074C02   SRL T1, A3, 16
9D00BD04  0169001B   DIVU T3, T1
9D00BD08  012001F4   TEQ T1, ZERO
9D00BD0C  30EDFFFF   ANDI T5, A3, -1
9D00BD1C  00051C02   SRL V1, A1, 16
9D00BD24  00006012   MFLO T4, 0
9D00BD28  00001010   MFHI V0, 0
9D00BD2C  00021400   SLL V0, V0, 16
9D00BD30  00431025   OR V0, V0, V1
9D00BD34  718D7002   MUL T6, T4, T5
9D00BD38  004E182B   SLTU V1, V0, T6
9D00BD3C  0169001B   DIVU T3, T1
9D00BD40  012001F4   TEQ T1, ZERO
9D00BD44  1060000A   BEQ V1, ZERO, 0x9D00BD70
9D00BD48  01042004   SLLV A0, A0, T0
9D00BD4C  00471021   ADDU V0, V0, A3
9D00BD50  0047182B   SLTU V1, V0, A3
9D00BD54  14600006   BNE V1, ZERO, 0x9D00BD70
9D00BD58  258CFFFF   ADDIU T4, T4, -1
9D00BD5C  004E182B   SLTU V1, V0, T6
9D00BD60  50600004   BEQL V1, ZERO, 0x9D00BD74
9D00BD64  004E1023   SUBU V0, V0, T6
9D00BD68  258CFFFF   ADDIU T4, T4, -1
9D00BD6C  00471021   ADDU V0, V0, A3
9D00BD70  004E1023   SUBU V0, V0, T6
9D00BD74  0049001B   DIVU V0, T1
9D00BD78  012001F4   TEQ T1, ZERO
9D00BD7C  30A5FFFF   ANDI A1, A1, -1
9D00BD80  00005812   MFLO T3, 0
9D00BD84  00001810   MFHI V1, 0
9D00BD88  00031C00   SLL V1, V1, 16
9D00BD8C  00652825   OR A1, V1, A1
9D00BD90  716D6802   MUL T5, T3, T5
9D00BD94  00AD182B   SLTU V1, A1, T5
9D00BD98  0049001B   DIVU V0, T1
9D00BD9C  012001F4   TEQ T1, ZERO
9D00BDA0  50600006   BEQL V1, ZERO, 0x9D00BDBC
9D00BDA4  000C6400   SLL T4, T4, 16
9D00BDA8  00A72821   ADDU A1, A1, A3
9D00BDAC  00A7102B   SLTU V0, A1, A3
9D00BDB0  1040004D   BEQ V0, ZERO, 0x9D00BEE8
9D00BDB4  256BFFFF   ADDIU T3, T3, -1
9D00BDB8  000C6400   SLL T4, T4, 16
9D00BDBC  016C5825   OR T3, T3, T4
9D00BDC4  00AD2823   SUBU A1, A1, T5
9D00BEE8  00AD102B   SLTU V0, A1, T5
9D00BEEC  5040FFB3   BEQL V0, ZERO, 0x9D00BDBC
9D00BEF0  000C6400   SLL T4, T4, 16
9D00BEF4  256BFFFF   ADDIU T3, T3, -1
9D00BEF8  0B402F6E   J 0x9D00BDB8
9D00BEFC  00A72821   ADDU A1, A1, A3
9D00C154  00071402   SRL V0, A3, 16
9D00C158  0122001B   DIVU T1, V0
9D00C15C  004001F4   TEQ V0, ZERO
9D00C160  30ECFFFF   ANDI T4, A3, -1
9D00C170  00055C02   SRL T3, A1, 16
9D00C174  00005012   MFLO T2, 0
9D00C178  00004010   MFHI T0, 0
9D00C17C  00084400   SLL T0, T0, 16
9D00C180  010B4025   OR T0, T0, T3
9D00C184  714C6802   MUL T5, T2, T4
9D00C188  010D582B   SLTU T3, T0, T5
9D00C18C  0122001B   DIVU T1, V0
9D00C190  004001F4   TEQ V0, ZERO
9D00C194  1160000A   BEQ T3, ZERO, 0x9D00C1C0
9D00C198  00663004   SLLV A2, A2, V1
9D00C19C  01074021   ADDU T0, T0, A3
9D00C1A0  0107482B   SLTU T1, T0, A3
9D00C1A4  15200006   BNE T1, ZERO, 0x9D00C1C0
9D00C1A8  254AFFFF   ADDIU T2, T2, -1
9D00C1AC  010D482B   SLTU T1, T0, T5
9D00C1B0  51200004   BEQL T1, ZERO, 0x9D00C1C4
9D00C1B4  010D4023   SUBU T0, T0, T5
9D00C1B8  254AFFFF   ADDIU T2, T2, -1
9D00C1BC  01074021   ADDU T0, T0, A3
9D00C1C0  010D4023   SUBU T0, T0, T5
9D00C1C4  0102001B   DIVU T0, V0
9D00C1C8  004001F4   TEQ V0, ZERO
9D00C1CC  30A5FFFF   ANDI A1, A1, -1
9D00C1D0  00004812   MFLO T1, 0
9D00C1D4  00005810   MFHI T3, 0
9D00C1D8  000B5C00   SLL T3, T3, 16
9D00C1DC  01652825   OR A1, T3, A1
9D00C1E0  712C6002   MUL T4, T1, T4
9D00C1E4  00AC582B   SLTU T3, A1, T4
9D00C1E8  0102001B   DIVU T0, V0
9D00C1EC  004001F4   TEQ V0, ZERO
9D00C1F0  5160000B   BEQL T3, ZERO, 0x9D00C220
9D00C1F4  000A5400   SLL T2, T2, 16
9D00C1F8  00A72821   ADDU A1, A1, A3
9D00C1FC  00A7102B   SLTU V0, A1, A3
9D00C200  14400006   BNE V0, ZERO, 0x9D00C21C
9D00C204  2529FFFF   ADDIU T1, T1, -1
9D00C208  00AC102B   SLTU V0, A1, T4
9D00C20C  50400004   BEQL V0, ZERO, 0x9D00C220
9D00C210  000A5400   SLL T2, T2, 16
9D00C214  2529FFFF   ADDIU T1, T1, -1
9D00C218  00A72821   ADDU A1, A1, A3
9D00C21C  000A5400   SLL T2, T2, 16
9D00C220  012A4825   OR T1, T1, T2
9D00C228  00AC2823   SUBU A1, A1, T4
9D00B0C0  01980019   MULTU 0, T4, T8
9D00B0C8  00006810   MFHI T5, 0
9D00B0D0  01A07821   ADDU T7, T5, ZERO
9D00B0E8  0B402C41   J 0x9D00B104
9D00B0EC  0000C012   MFLO T8, 0
9D00BA70  01460019   MULTU 0, T2, A2
9D00BA78  00007810   MFHI T7, 0
9D00BDC0  01660019   MULTU 0, T3, A2
9D00BDC8  0000C810   MFHI T9, 0
9D00BDD0  03207021   ADDU T6, T9, ZERO
9D00BDE4  00001012   MFLO V0, 0
9D00C224  01260019   MULTU 0, T1, A2
9D00C22C  00005810   MFHI T3, 0
9D00B0CC  00AD702B   SLTU T6, A1, T5
9D00B0D4  15C00006   BNE T6, ZERO, 0x9D00B0F0
9D00B0D8  00005812   MFLO T3, 0
9D00B0DC  10AD0016   BEQ A1, T5, 0x9D00B138
9D00B0E0  008B102B   SLTU V0, A0, T3
9D00B0E4  00AD2823   SUBU A1, A1, T5
9D00B138  5440FFEE   BNEL V0, ZERO, 0x9D00B0F4
9D00B13C  0178C023   SUBU T8, T3, T8
9D00B140  0000C012   MFLO T8, 0
9D00B144  0B402C41   J 0x9D00B104
9D00B148  00002821   ADDU A1, ZERO, ZERO
9D00BA7C  00AF382B   SLTU A3, A1, T7
9D00BA80  14E00009   BNE A3, ZERO, 0x9D00BAA8
9D00BA84  00007012   MFLO T6, 0
9D00BA88  50AF0004   BEQL A1, T7, 0x9D00BA9C
9D00BA8C  00641804   SLLV V1, A0, V1
9D00BA90  01402021   ADDU A0, T2, ZERO
9D00BA94  0B402DD4   J 0x9D00B750
9D00BA98  00002821   ADDU A1, ZERO, ZERO
9D00BA9C  006E182B   SLTU V1, V1, T6
9D00BAA0  5060FFFC   BEQL V1, ZERO, 0x9D00BA94
9D00BAA4  01402021   ADDU A0, T2, ZERO
9D00BDCC  00B9682B   SLTU T5, A1, T9
9D00BDD4  15A0003E   BNE T5, ZERO, 0x9D00BED0
9D00BDD8  00004812   MFLO T1, 0
9D00BDDC  10B9004B   BEQ A1, T9, 0x9D00BF0C
9D00BDE0  00B91823   SUBU V1, A1, T9
9D00BF0C  0089182B   SLTU V1, A0, T1
9D00BF10  5460FFF0   BNEL V1, ZERO, 0x9D00BED4
9D00BF14  01261023   SUBU V0, T1, A2
9D00BF18  00001012   MFLO V0, 0
9D00BF1C  0B402F7A   J 0x9D00BDE8
9D00BF20  00001821   ADDU V1, ZERO, ZERO
9D00C230  00AB382B   SLTU A3, A1, T3
9D00C234  14E00044   BNE A3, ZERO, 0x9D00C348
9D00C238  00005012   MFLO T2, 0
9D00C23C  50AB003F   BEQL A1, T3, 0x9D00C33C
9D00C240  00641804   SLLV V1, A0, V1
9D00C244  01202021   ADDU A0, T1, ZERO
9D00C248  0B403007   J 0x9D00C01C
9D00C24C  00001821   ADDU V1, ZERO, ZERO
9D00C33C  006A182B   SLTU V1, V1, T2
9D00C340  1060FF36   BEQ V1, ZERO, 0x9D00C01C
9D00C344  01202021   ADDU A0, T1, ZERO
9D00BAA8  2544FFFF   ADDIU A0, T2, -1
9D00BAAC  0B402DD4   J 0x9D00B750
9D00BAB0  00002821   ADDU A1, ZERO, ZERO
9D00C348  2524FFFF   ADDIU A0, T1, -1
9D00C34C  0B403007   J 0x9D00C01C
9D00C350  00001821   ADDU V1, ZERO, ZERO
9D00B0F0  0178C023   SUBU T8, T3, T8
9D00B0F4  01E73823   SUBU A3, T7, A3
9D00B0F8  0178582B   SLTU T3, T3, T8
9D00B0FC  00EB1023   SUBU V0, A3, T3
9D00B100  00A22823   SUBU A1, A1, V0
9D00BED0  01261023   SUBU V0, T1, A2
9D00BED4  01C71823   SUBU V1, T6, A3
9D00BED8  0122482B   SLTU T1, T1, V0
9D00BEDC  00691823   SUBU V1, V1, T1
9D00BEE0  0B402F7A   J 0x9D00BDE8
9D00BEE4  00A31823   SUBU V1, A1, V1
9D00B104  00983023   SUBU A2, A0, T8
9D00B108  0086202B   SLTU A0, A0, A2
9D00B10C  00A42023   SUBU A0, A1, A0
9D00BDE8  00821023   SUBU V0, A0, V0
9D00BDEC  0082202B   SLTU A0, A0, V0
9D00BDF0  00641823   SUBU V1, V1, A0
9D00B110  00641804   SLLV V1, A0, V1
9D00B114  01263006   SRLV A2, A2, T1
9D00B118  00C31825   OR V1, A2, V1
9D00BDF4  01435004   SLLV T2, V1, T2
9D00BDF8  01021006   SRLV V0, V0, T0
9D00B11C  01242006   SRLV A0, A0, T1
9D00B120  AD030000   SW V1, 0(T0)
9D00B124  0B402B60   J 0x9D00AD80
9D00B128  AD040004   SW A0, 4(T0)
9D00BDFC  004A1025   OR V0, V0, T2
9D00BE00  01031806   SRLV V1, V1, T0
9D00B728  00801021   ADDU V0, A0, ZERO
9D00B750  00801021   ADDU V0, A0, ZERO
9D00B61C  04A00054   BLTZ A1, 0x9D00B770
9D00B620  00004021   ADDU T0, ZERO, ZERO
9D00B770  00042023   SUBU A0, ZERO, A0
9D00B774  0004102B   SLTU V0, ZERO, A0
9D00B778  00052823   SUBU A1, ZERO, A1
9D00B77C  00A22823   SUBU A1, A1, V0
9D00B624  04E20059   BLTZL A3, 0x9D00B78C
9D00B628  00063023   SUBU A2, ZERO, A2
9D00B780  04E1FFAA   BGEZ A3, 0x9D00B62C
9D00B784  2408FFFF   ADDIU T0, ZERO, -1
9D00B794  00084027   NOR T0, ZERO, T0
9D00B788  00063023   SUBU A2, ZERO, A2
9D00B78C  0006182B   SLTU V1, ZERO, A2
9D00B790  00073823   SUBU A3, ZERO, A3
9D00B798  0B402D8B   J 0x9D00B62C
9D00B79C  00E33823   SUBU A3, A3, V1
9D00B72C  1500000B   BNE T0, ZERO, 0x9D00B75C
9D00B730  00A01821   ADDU V1, A1, ZERO
9D00B754  1100FFF7   BEQ T0, ZERO, 0x9D00B734
9D00B758  00A01821   ADDU V1, A1, ZERO
9D00B75C  00041023   SUBU V0, ZERO, A0
9D00B760  0002202B   SLTU A0, ZERO, V0
9D00B764  00051823   SUBU V1, ZERO, A1
9D00B734  03E00008   JR RA
9D00B738  00000000   NOP
9D00B768  03E00008   JR RA
9D00B76C  00641823   SUBU V1, V1, A0
9D00AC70  27BDFFF8   ADDIU SP, SP, -8
9D00AC74  04A00056   BLTZ A1, 0x9D00ADD0
9D00AC78  00005021   ADDU T2, ZERO, ZERO
9D00ADD0  00042023   SUBU A0, ZERO, A0
9D00ADD4  0004102B   SLTU V0, ZERO, A0
9D00ADD8  00052823   SUBU A1, ZERO, A1
9D00ADDC  00A22823   SUBU A1, A1, V0
9D00AC7C  04E2005B   BLTZL A3, 0x9D00ADEC
9D00AC80  00063023   SUBU A2, ZERO, A2
9D00ADE0  04E1FFA8   BGEZ A3, 0x9D00AC84
9D00ADE4  240AFFFF   ADDIU T2, ZERO, -1
9D00ADE8  00063023   SUBU A2, ZERO, A2
9D00ADEC  0006182B   SLTU V1, ZERO, A2
9D00ADF0  00073823   SUBU A3, ZERO, A3
9D00ADF4  0B402B21   J 0x9D00AC84
9D00ADF8  00E33823   SUBU A3, A3, V1
9D00AC84  03A04021   ADDU T0, SP, ZERO
9D00AD80  11400010   BEQ T2, ZERO, 0x9D00ADC4
9D00AD84  8FA20000   LW V0, 0(SP)
9D00ADB8  1540FFF3   BNE T2, ZERO, 0x9D00AD88
9D00ADBC  AFA50004   SW A1, 4(SP)
9D00ADC0  8FA20000   LW V0, 0(SP)
9D00ADC4  8FA30004   LW V1, 4(SP)
9D00AD88  8FA20000   LW V0, 0(SP)
9D00AD8C  8FA30004   LW V1, 4(SP)
9D00AD94  00021023   SUBU V0, ZERO, V0
9D00AD98  0002202B   SLTU A0, ZERO, V0
9D00AD9C  00031823   SUBU V1, ZERO, V1
9D00AD90  27BD0008   ADDIU SP, SP, 8
9D00ADA0  03E00008   JR RA
9D00ADA4  00641823   SUBU V1, V1, A0
9D00ADC8  03E00008   JR RA
9D00ADCC  27BD0008   ADDIU SP, SP, 8
9D00BE04  03E00008   JR RA
9D00BE08  00000000   NOP
9D00C01C  03E00008   JR RA
9D00C020  00801021   ADDU V0, A0, ZERO
9D00C12C  03E00008   JR RA
9D00C130  00801021   ADDU V0, A0, ZERO
9D00C138  03E00008   JR RA
9D00C13C  00801021   ADDU V0, A0, ZERO
---  /Volumes/home/c11067/xc32/build/gcc/config/floatunsisf.c  ------------------------------------------
9D00F894  27BDFFE8   ADDIU SP, SP, -24
9D00F898  AFBF0014   SW RA, 20(SP)
9D00F89C  04800006   BLTZ A0, 0x9D00F8B8
9D00F8A0  00801021   ADDU V0, A0, ZERO
9D00F8B8  30420001   ANDI V0, V0, 1
9D00F8BC  00042042   SRL A0, A0, 1
9D00F8C0  0F402921   JAL sitofp
9D00F8C4  00822025   OR A0, A0, V0
9D00F8C8  00402021   ADDU A0, V0, ZERO
9D00F8CC  0F40278D   JAL fpadd
9D00F8D0  00402821   ADDU A1, V0, ZERO
9D00F8A4  0F402921   JAL sitofp
9D00F8A8  00000000   NOP
9D00F8AC  8FBF0014   LW RA, 20(SP)
9D00F8B0  03E00008   JR RA
9D00F8B4  27BD0018   ADDIU SP, SP, 24
9D00F8D4  8FBF0014   LW RA, 20(SP)
9D00F8D8  03E00008   JR RA
9D00F8DC  27BD0018   ADDIU SP, SP, 24
