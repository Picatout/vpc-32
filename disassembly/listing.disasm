Disassembly Listing for vpc-32
Generated From:
C:/Users/Jacques/Documents/GitHub/VPC-32.X/dist/default/production/VPC-32.X.production.elf
2013-09-17 13:47:01

---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/uart.h  ---------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: Constants & Data Types
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  //DOM-IGNORE-BEGIN
74:                  /****
75:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
76:                         the device file.  Also the UART register set could also be placed there
77:                  *****/
78:                  typedef struct
79:                  {
80:                  	volatile UINT	reg;
81:                  	volatile UINT	clr;
82:                  	volatile UINT	set;
83:                  	volatile UINT	inv;
84:                  }REG_SET;
85:                  
86:                  typedef struct
87:                  {
88:                  	volatile REG_SET	mode;
89:                  	volatile REG_SET	sta;
90:                  	volatile REG_SET    tx;
91:                  	volatile REG_SET	rx;
92:                  	volatile REG_SET	brg;
93:                  }UART_REGS;
94:                  
95:                  extern UART_REGS * const uartReg[];
96:                  //DOM-IGNORE-END
97:                  
98:                  // *****************************************************************************
99:                  /* UART Module
100:                 
101:                   Summary:
102:                     UART modules supported.
103:                 
104:                   Description:
105:                     This enumeration identifies the available UART modules.
106:                 */
107:                 
108:                 typedef enum
109:                 {
110:                 #if defined _UART1
111:                     // UART1 Module ID.
112:                     UART1 = 0,
113:                 #endif
114:                 #if defined _UART2
115:                     // UART2 Module ID.
116:                     UART2,
117:                 #endif
118:                 #ifdef _UART3
119:                     // UART3 Module ID.
120:                     UART3,
121:                 #endif
122:                 #ifdef _UART4
123:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
124:                     UART4,
125:                 #endif
126:                 #ifdef _UART5
127:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
128:                     UART5,
129:                 #endif
130:                 #ifdef _UART6
131:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
132:                     UART6,
133:                 #endif
134:                     // Number of available UART modules.
135:                     UART_NUMBER_OF_MODULES
136:                 
137:                 } UART_MODULE;
138:                 
139:                 
140:                 // *****************************************************************************
141:                 /* UART Enable Modes
142:                 
143:                   Summary:
144:                     Operating modes of UART.
145:                 
146:                   Description:
147:                     This enumeration defines the supported modes in which the UART may be
148:                     enabled or disbled.
149:                 
150:                   Remarks:
151:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
152:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
153:                     has been pre-loaded with data.
154:                 
155:                     The caller should not rely on the specific numbers assigned to any of these
156:                     values as they may change from one processor to the next.
157:                 */
158:                 
159:                 typedef enum
160:                 {
161:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
162:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
163:                 
164:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
165:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
166:                 
167:                 
168:                     // UART Module, receiver and transmitter functionality is not.
169:                     // enabled or disabled
170:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
171:                 
172:                     // UART Module receiver.
173:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
174:                 
175:                     // UART Module transmitter.
176:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
177:                 
178:                 
179:                 } UART_ENABLE_MODE;
180:                 
181:                 // *****************************************************************************
182:                 /* UART Enable Helper Macro
183:                 
184:                   Summary:
185:                     Macro for enabling module operating modes.
186:                 
187:                   Description:
188:                     This macro creates the proper flags for enabling operating modes of the UART module.
189:                 
190:                   Example:
191:                     <code>
192:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
193:                     </code>
194:                 
195:                   Remarks:
196:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
197:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
198:                     has been pre-loaded with data.
199:                 */
200:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
201:                 
202:                 // *****************************************************************************
203:                 /* UART Disable Helper Macro
204:                 
205:                   Summary:
206:                     Macro for disabling module operating modes.
207:                 
208:                   Description:
209:                     This macro creates the proper flags for disabling operating modes of the UART module.
210:                 
211:                   Example:
212:                     <code>
213:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
214:                     </code>
215:                 
216:                 */
217:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
218:                 
219:                 // *****************************************************************************
220:                 /* UART Configuration Settings
221:                 
222:                   Summary:
223:                     Supported configuration flags for the UART module.
224:                 
225:                   Description:
226:                     This enumeration defines the various configuration options for the UART
227:                     module.  These values can be OR'd together to create a configuration mask
228:                     passed to the UARTConfigure routine.
229:                 
230:                   Remarks:
231:                     Several of the configuration options are mutually exclusive:
232:                     * Only one of the "ENABLE_PINS" modes can be used at a time
233:                     * Only one of the "RTS_WHEN" modes can be used at a time
234:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
235:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
236:                 
237:                     The caller should not rely on the specific numbers assigned to any of these
238:                     values as they may change from one processor ot the next.
239:                 */
240:                 
241:                 typedef enum
242:                 {
243:                     // Enables high-speed range of the UART (see UARTSetBitRate).
244:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
245:                 
246:                     // Inverts polarity of data interpretation the received (RX) pin.
247:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
248:                 
249:                     // Enables UART TX-to-RX Loop-back mode.
250:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
251:                 
252:                     // Enables Wake-up of the part when a start bit is received.
253:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
254:                 
255:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
256:                     // cannot be used in bit-clock/IrDA mode).
257:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
258:                 
259:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
260:                     // cannot be used in CTS/RTS mode).
261:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
262:                 
263:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
264:                     // be used in RTS-Only mode).
265:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
266:                 
267:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
268:                     // the default mode and this parameter can be left out if it is desired).
269:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
270:                 
271:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
272:                     // is not full (i.e., the UART is ready to receive data).  This is also known
273:                     // as "RTS Flow-Control Mode".
274:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
275:                 
276:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
277:                     // is not empty (i.e., when the UART has data ready to send).  This is also
278:                     // known as "RTS Simplex Mode".
279:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
280:                 
281:                     // Enable the IrDA encoder/decoder.
282:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
283:                 
284:                     // Enables stopping of the UART operation to save power when the core has
285:                     // been put in idle mode.
286:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
287:                 
288:                     // Inverts the polarity of data sent on the transmit (TX) pin.
289:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
290:                 
291:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
292:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
293:                     // Note:  The address must still be set using UARTEnableAddressDetect
294:                     // to support IEEE-485 protocol.
295:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
296:                 
297:                 } UART_CONFIGURATION;
298:                 
299:                 
300:                 // *****************************************************************************
301:                 /* UART FIFO Modes
302:                 
303:                   Summary:
304:                     Supported FIFO modes for the UART module.
305:                 
306:                   Description:
307:                     This enumeration defines supported FIFO modes that determine when the Tx
308:                     and Rx interrupts will occur.
309:                 
310:                   Remarks:
311:                     These modes consist of two sets of mutially exclusive modes:
312:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
313:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
314:                 
315:                     The caller should not rely on the specific numbers assigned to any of these
316:                     values as they may change from one processor ot the next.
317:                 
318:                 */
319:                 
320:                 typedef enum
321:                 {
322:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
323:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
324:                 
325:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
326:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
327:                 
328:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
329:                     // full (i.e. there is space available for more data)  This is the default.
330:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
331:                 
332:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
333:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
334:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
337:                     // (three-quarter) full.
338:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
339:                 
340:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
341:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
342:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
343:                 
344:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
345:                     // data.
346:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
347:                 
348:                 } UART_FIFO_MODE;
349:                 
350:                 
351:                 // *****************************************************************************
352:                 /* UART Line Control Mode
353:                 
354:                   Summary:
355:                     UART line control mode.
356:                 
357:                   Description:
358:                     This data type defines the supported line control modes for the UART.
359:                 
360:                   Remarks:
361:                     Some of the line-control options are mutually exclusive:
362:                     * Only one of the "DATA_SIZE" options can be used at a time
363:                     * Only one of the "PARITY" options can be used at a time
364:                     * Only one of the "STOP_BITS" options can be used at a time
365:                 
366:                     The caller should not rely on the specific numbers assigned to any of these
367:                     values as they may change from one processor ot the next.
368:                 */
369:                 
370:                 typedef enum
371:                 {
372:                     // Sets the data transfer size to 8-bits per frame.
373:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
374:                 
375:                     // Sets the data transfer size to 9-bits per frame.
376:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
377:                 
378:                     // Enables parity bit generation for odd parity.
379:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
380:                 
381:                     // Enables parity bit generation for even parity.
382:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
383:                 
384:                     // Disables parity bit generation.
385:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
386:                 
387:                     // Enables generation of 2 stop bits per frame.
388:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
389:                 
390:                     // Enables generation of 1 stop bit per frame (default).
391:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
392:                 
393:                 } UART_LINE_CONTROL_MODE;
394:                 
395:                 
396:                 // *****************************************************************************
397:                 /* UART Line Status Flags
398:                 
399:                   Summary:
400:                     UART line-status bitmask flags.
401:                 
402:                   Description:
403:                     This enumeration defines the UART line-status bits.  These values are
404:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
405:                 
406:                   Remarks:
407:                     The caller should not rely on the specific numbers assigned to any of these
408:                     values as they may change from one processor ot the next.
409:                 */
410:                 
411:                 typedef enum
412:                 {
413:                     // The transmitter is able to accept data to transmit.
414:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
415:                 
416:                     // The transmitter is empty (no data is available to transmit).
417:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
418:                 
419:                     // The receiver is currently idle.
420:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
421:                 
422:                     // A received data parity error was detected.
423:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
424:                 
425:                     // Data was received that violated the framing protocol (the data word did
426:                     // not start or stop at the appropriate place).  Note:  A break condition
427:                     // will always indicate a framing error.
428:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
429:                 
430:                     // The UART has received more data than it can buffer.  Data has been lost.
431:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
432:                 
433:                     // UART data has been received and is avaiable in the FIFO.
434:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
435:                 
436:                 } UART_LINE_STATUS;
437:                 
438:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
439:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
440:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
441:                 
442:                 
443:                 
444:                 // *****************************************************************************
445:                 /* UART Data
446:                 
447:                   Summary:
448:                     UART data.
449:                 
450:                   Description:
451:                     This data type defines the supported data sizes for the UART.
452:                 */
453:                 
454:                 typedef union
455:                 {
456:                     // 8-bit data
457:                     struct
458:                     {
459:                         UINT16  data8bit    : 8;
460:                     };
461:                 
462:                     // 9-bit data
463:                     struct
464:                     {
465:                         UINT16  data9bit    : 9;
466:                     };
467:                 
468:                     UINT16 __data;
469:                 } UART_DATA;
470:                 
471:                 
472:                 // *****************************************************************************
473:                 // *****************************************************************************
474:                 // Section: UART Peripheral Library Interface Routines
475:                 // *****************************************************************************
476:                 // *****************************************************************************
477:                 
478:                 
479:                 /*******************************************************************************
480:                   Function:
481:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
482:                 
483:                   Summary:
484:                     Enables or disables the given UART module in the desired mode.
485:                 
486:                   Description:
487:                     This routine enables or disables the given UART module in the desired mode.
488:                 
489:                   Precondition:
490:                     The UART module should be appropriately configured before being enabled.
491:                 
492:                   Parameters:
493:                     id    - Identifies the desired UART module.
494:                 
495:                     mode  - Identifies the desired mode of UART operation.
496:                 
497:                   Returns:
498:                     None
499:                 
500:                   Example:
501:                     <code>
502:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
503:                     </code>
504:                 
505:                   Remarks:
506:                     Enabling UART transmissions will immediately cause a TX interrupt to
507:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
508:                     was pre-loaded with data.
509:                   *****************************************************************************/
510:                 
511:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
512:                 
513:                 
514:                 /*******************************************************************************
515:                   Function:
516:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
517:                 
518:                   Summary:
519:                     UART module configuration routine.
520:                 
521:                   Description:
522:                     This routine allows the caller to configure various features of the UART
523:                     module for desired operation.
524:                 
525:                   Precondition:
526:                     None
527:                 
528:                   Parameters:
529:                     id      - Identifies the desired UART module.
530:                 
531:                     flags   - Bit-wise OR of the desired module configuration settings.
532:                 
533:                   Returns:
534:                     None
535:                 
536:                   Example:
537:                     <code>
538:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
539:                     </code>
540:                 
541:                   Remarks:
542:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
543:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
544:                     of these values will result in a value that is not explicitly defined in
545:                     the enumeration.
546:                   *****************************************************************************/
547:                 
548:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
549:                 
550:                 
551:                 /*******************************************************************************
552:                   Function:
553:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
554:                 
555:                   Summary:
556:                     Controls UART module TX and RX FIFO operation.
557:                 
558:                   Description:
559:                     This routine allows the caller to configure when interrupts occur relative
560:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
561:                     or empty the FIFOs are).
562:                 
563:                   Precondition:
564:                     None
565:                 
566:                   Parameters:
567:                     id      - Identifies the desired UART module.
568:                 
569:                     mode    - Bit-wise OR of the desired FIFO mode values.
570:                 
571:                   Returns:
572:                     None
573:                 
574:                   Example:
575:                     <code>
576:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
577:                     </code>
578:                 
579:                   Remarks:
580:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
581:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
582:                     of these values will result in a value that is not explicitly defined in
583:                     the enumeration.
584:                   *****************************************************************************/
585:                 
586:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
587:                 
588:                 
589:                 /*******************************************************************************
590:                   Function:
591:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
592:                 
593:                   Summary:
594:                     Routine to set the UART module's desired data data rate.
595:                 
596:                   Description:
597:                     This routine allows the caller to set the desired data rate for the UART.
598:                 
599:                   Precondition:
600:                     The source clock's frequency must be operating at the frequency passed in the
601:                     "sourceClock" parameter.
602:                 
603:                   Parameters:
604:                     id          - Identifies the desired UART module.
605:                 
606:                     sourceClock - Frequency (Hz) of the source clock being provided to the
607:                                   UART module.
608:                 
609:                     dataRate     - Desired data rate (bits per second).
610:                 
611:                   Returns:
612:                     Actual bit rate selected
613:                 
614:                   Example:
615:                     <code>
616:                 	#define PERIPHERAL_CLOCK    10000000
617:                 	#define DESIRED_DATA_RATE   19200
618:                 	
619:                 	UINT32    actualDataRate;
620:                 
621:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
622:                     </code>
623:                 
624:                   Remarks:
625:                     Actual data rate selected may be slightly different than the data rate
626:                     requested due to truncation error.
627:                 
628:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
629:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
630:                     the maximum data rate is sourceClock/4.
631:                   *****************************************************************************/
632:                 
633:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
634:                 
635:                 
636:                 /*******************************************************************************
637:                   Function:
638:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
639:                 
640:                   Summary:
641:                     Routine to get the UART module's current data data rate.
642:                 
643:                   Description:
644:                     This routine allows the caller to get the current data rate for the UART module.
645:                 
646:                   Precondition:
647:                     The source clock's frequency must be operating at the frequency passed in the
648:                     "sourceClock" parameter.
649:                 
650:                   Parameters:
651:                     id          - Identifies the desired UART module.
652:                 
653:                     sourceClock - Frequency (Hz) of the source clock being provided to the
654:                                   UART module.
655:                 
656:                   Returns:
657:                     The UART's current data rate (bits per second).
658:                 
659:                   Example:
660:                     <code>
661:                 	#define PERIPHERAL_CLOCK    10000000
662:                 	
663:                 	UINT32    currentDataRate;
664:                 
665:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
666:                     </code>
667:                 
668:                   Remarks:
669:                     The current (actual) data rate returned may be slightly different than bit
670:                     rate requested due to truncation error.
671:                   *****************************************************************************/
672:                 
673:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
674:                 
675:                 
676:                 /*******************************************************************************
677:                   Function:
678:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
679:                 
680:                   Summary:
681:                     Routine to set the UART module's desired line control parameters.
682:                 
683:                   Description:
684:                     This routine allows the caller to select the desired size of the UART data
685:                     frame, the generation of parity and framing parameters (collectively
686:                     referred to as the "line control" mode).
687:                 
688:                   Precondition:
689:                 
690:                   Parameters:
691:                     id      - Identifies the desired UART module.
692:                 
693:                     mode    - This is a bit-wise OR of the desired line control mode flags.
694:                 
695:                   Returns:
696:                     None
697:                 
698:                   Example:
699:                     <code>
700:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
701:                     </code>
702:                 
703:                   Remarks:
704:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
705:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
706:                     of these values will result in a value that is not explicitly defined in
707:                     the enumeration.
708:                   *****************************************************************************/
709:                 
710:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
711:                 
712:                 
713:                 /*******************************************************************************
714:                   Function:
715:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
716:                 
717:                   Summary:
718:                     Provides current UART line status.
719:                 
720:                   Description:
721:                     This routine allows the caller to get the current line status of the UART,
722:                     indicating the current state of the transmitter and receiver buffers, and
723:                     if any errors have occurred.
724:                 
725:                   Precondition:
726:                     None
727:                 
728:                   Parameters:
729:                     id      - Identifies the desired UART module.
730:                 
731:                   Returns:
732:                     A bit-wise OR of the current line status flags.
733:                 
734:                   Example:
735:                     <code>
736:                     UART_LINE_STATUS lineStatus;
737:                 	
738:                 	lineStatus = UARTGetLineStatus(UART1);
739:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
740:                     {
741:                         // Handle receiver error
742:                     }
743:                     </code>
744:                 
745:                   Remarks:
746:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
747:                     status flag.
748:                 
749:                     The receiver line status flags are only valid when data has been received
750:                     and for the data at the top of the RX FIFO.
751:                 
752:                     Note that the bitmask resulting from the bit-wise OR of these values will
753:                     result in a value that is not explicitly defined in the enumeration.
754:                   *****************************************************************************/
755:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
756:                 {
757:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
758:                 }
759:                 
760:                 
761:                 /*******************************************************************************
762:                   Function:
763:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
764:                 
765:                   Summary:
766:                     Routine to detect if the transmitter is ready to accept data to transmit.
767:                 
768:                   Description:
769:                     This routine determines if the transmitter is ready to accept more data to
770:                     be transmitted.
771:                 
772:                   Precondition:
773:                     The UART module should have been appropriately configured and enabled.
774:                 
775:                   Parameters:
776:                     id      - Identifies the desired UART module.
777:                 
778:                   Returns:
779:                     Boolean identifying whether or not the transmitter is ready:
780:                     * TRUE    - If the transmitter is ready to accept more data
781:                     * FALSE   - If the transmitter is not ready to accept more data
782:                 
783:                   Example:
784:                     <code>
785:                     unsigned char data;
786:                 	
787:                 	data = 'a';
788:                 	
789:                 	if (UARTTransmitterIsReady(UART1))
790:                     {
791:                         UARTSendDataByte(UART1, data);
792:                     }
793:                     </code>
794:                 
795:                   Remarks:
796:                   *****************************************************************************/
797:                 
798:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
799:                 {
800:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D0085A8  00042080   SLL A0, A0, 2
9D0085AC  3C029D01   LUI V0, -25343
9D0085B0  2442A844   ADDIU V0, V0, -22460
9D0085B4  00822021   ADDU A0, A0, V0
9D0085B8  8C830000   LW V1, 0(A0)
9D0085BC  8C620010   LW V0, 16(V1)
9D0085C0  30420200   ANDI V0, V0, 512
9D008690  3C029D01   LUI V0, -25343
9D008694  2442A844   ADDIU V0, V0, -22460
9D008698  00621021   ADDU V0, V1, V0
9D00869C  8C430000   LW V1, 0(V0)
9D0086A0  8C620010   LW V0, 16(V1)
9D0086A4  30420200   ANDI V0, V0, 512
801:                 }
802:                 
803:                 
804:                 /*******************************************************************************
805:                   Function:
806:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
807:                 
808:                   Summary:
809:                     Routine to send a byte of data.
810:                 
811:                   Description:
812:                     This routine allows the caller to send a byte of data.
813:                 
814:                   Precondition:
815:                     The UART should have been appropriately configured.  The configuration must
816:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
817:                     have been ready, although not necessarily enabled yet.
818:                 
819:                   Parameters:
820:                     id      - Identifies the desired UART module.
821:                 
822:                     data    - Data byte to be sent.
823:                 
824:                   Returns:
825:                     None
826:                 
827:                   Example:
828:                     <code>
829:                 	unsigned char data;
830:                 	
831:                 	data = 'a';
832:                 	
833:                     if (UARTTransmitterIsReady(UART1))
834:                     {
835:                         UARTSendDataByte(UART1, data);
836:                     }
837:                     </code>
838:                 
839:                   Remarks:
840:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
841:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
842:                     data.
843:                   *****************************************************************************/
844:                 
845:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
846:                 {
847:                     uartReg[id]->tx.reg = data;
9D0085CC  30A500FF   ANDI A1, A1, 255
9D0085D0  AC650020   SW A1, 32(V1)
9D0086B4  30C600FF   ANDI A2, A2, 255
9D0086B8  AC660020   SW A2, 32(V1)
848:                 }
849:                 
850:                 
851:                 /*******************************************************************************
852:                   Function:
853:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
854:                 
855:                   Summary:
856:                     Routine to send data through the UART.
857:                 
858:                   Description:
859:                     This routine allows the caller to send data of any permitted size through
860:                     the UART.
861:                 
862:                   Precondition:
863:                     The UART module should have been appropriately configured.  The configuration must
864:                     have been for desired data size.  The transmitter must have been ready,
865:                     although not necessarily enabled yet.
866:                 
867:                   Parameters:
868:                     id      - Identifies the desired UART module.
869:                 
870:                     data    - Data to be sent.
871:                 
872:                   Returns:
873:                     None
874:                 
875:                   Example:
876:                     <code>
877:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
878:                 	
879:                 	if (UARTTransmitterIsReady(UART1))
880:                     {
881:                         UARTSendData(UART1, data);
882:                     }
883:                     </code>
884:                 
885:                   Remarks:
886:                     Size of the data word size depends on the current configuration (see
887:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
888:                   *****************************************************************************/
889:                 
890:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
891:                 {
892:                     uartReg[id]->tx.reg = data.__data;
893:                 }
894:                 
895:                 /*******************************************************************************
896:                   Function:
897:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
898:                 
899:                   Summary:
900:                     Routine to detect if the UART module has finshed transmitting the most recent
901:                     data.
902:                 
903:                   Description:
904:                     This routine determines if the transmitter has finished sending all
905:                     available data.
906:                 
907:                   Preconditions:
908:                     The UART module should have been appropriately configured and enabled and data
909:                     sent to the UART TX buffer.
910:                 
911:                   Parameters:
912:                     id      - Identifies the desired UART module.
913:                 
914:                   Returns:
915:                     Boolean identifying if the transmission has completed:
916:                     * TRUE    - If the transmitter has completed sending the data
917:                     * FALSE   - If the transmitter is still busy sending the data
918:                 
919:                   Example:
920:                     <code>
921:                 	if (UARTTransmissionHasCompleted(UART1))
922:                     {
923:                         // Perform any tasks necessary when all data has been sent
924:                     }
925:                     </code>
926:                 
927:                   Remarks:
928:                   *****************************************************************************/
929:                 
930:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
931:                 {
932:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
9D0086C8  00042080   SLL A0, A0, 2
9D0086CC  3C029D01   LUI V0, -25343
9D0086D0  2442A844   ADDIU V0, V0, -22460
9D0086D4  00822021   ADDU A0, A0, V0
9D0086D8  8C830000   LW V1, 0(A0)
9D0086DC  8C620010   LW V0, 16(V1)
9D0086E0  30420100   ANDI V0, V0, 256
933:                 }
934:                 
935:                 
936:                 /*******************************************************************************
937:                   Function:
938:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
939:                 
940:                   Summary:
941:                     Routine to detect if the receiver has data available.
942:                 
943:                   Description:
944:                     This routine determines if the receiver has data available to be read.
945:                 
946:                   Precondition:
947:                     The UART module must have been configured appropriately and enabled. A complete
948:                     data frame must have been sent to the UART before it will return a TRUE.
949:                 
950:                   Parameters:
951:                     id      - Identifies the desired UART module.
952:                 
953:                   Returns:
954:                     Boolean identifying whether or not data is available:
955:                     * TRUE    - If the receiver has data available
956:                     * FALSE   - If the receiver does not have data availble
957:                 
958:                   Example:
959:                     <code>
960:                     UART_DATA data;
961:                 	
962:                 	if (UARTReceivedDataIsAvailable(UART1))
963:                     {
964:                         data = UARTGetData(UART1);
965:                     }
966:                     </code>
967:                 
968:                   Remarks:
969:                     This routine provides the same information as the UART_DATA_READY line
970:                     status flag.
971:                   *****************************************************************************/
972:                 
973:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
974:                 {
975:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
9D008570  00042080   SLL A0, A0, 2
9D008574  3C029D01   LUI V0, -25343
9D008578  2442A844   ADDIU V0, V0, -22460
9D00857C  00822021   ADDU A0, A0, V0
9D008580  8C830000   LW V1, 0(A0)
9D008584  8C640010   LW A0, 16(V1)
9D008588  30840001   ANDI A0, A0, 1
9D0085F8  00048080   SLL S0, A0, 2
9D0085FC  3C029D01   LUI V0, -25343
9D008600  2442A844   ADDIU V0, V0, -22460
9D008604  02028021   ADDU S0, S0, V0
9D008608  8E030000   LW V1, 0(S0)
9D00860C  8C620010   LW V0, 16(V1)
9D008610  30420001   ANDI V0, V0, 1
9D008630  3C029D01   LUI V0, -25343
9D008634  2442A844   ADDIU V0, V0, -22460
9D008640  8C430010   LW V1, 16(V0)
9D008644  30630001   ANDI V1, V1, 1
9D008724  00041080   SLL V0, A0, 2
9D008728  3C129D01   LUI S2, -25343
9D00872C  2652A844   ADDIU S2, S2, -22460
9D008730  00529021   ADDU S2, V0, S2
9D00873C  8C430010   LW V1, 16(V0)
9D008740  30630001   ANDI V1, V1, 1
9D0087F8  00042080   SLL A0, A0, 2
9D0087FC  3C029D01   LUI V0, -25343
9D008800  2442A844   ADDIU V0, V0, -22460
9D008804  00822021   ADDU A0, A0, V0
9D008808  8C830000   LW V1, 0(A0)
9D00880C  8C640010   LW A0, 16(V1)
9D008810  30840001   ANDI A0, A0, 1
976:                 }
977:                 
978:                 
979:                 /*******************************************************************************
980:                   Function:
981:                     BYTE UARTGetDataByte ( UART_MODULE id )
982:                 
983:                   Summary:
984:                     Routine to get a byte of data received by the UART.
985:                 
986:                   Description:
987:                     This routine allows the caller to read a byte of data received by the UART.
988:                 
989:                   Precondition:
990:                     The UART module must have been appropriately configured, the configuration must
991:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
992:                     been enabled.  Also, a complete data frame must have been received by the UART.
993:                 
994:                   Parameters:
995:                     id      - Identifies the desired UART module.
996:                 
997:                   Returns:
998:                     A byte of data received by the UART.
999:                 
1000:                  Example:
1001:                    <code>
1002:                    unsigned char data;
1003:                	
1004:                	if (UARTReceivedDataIsAvailable(UART1))
1005:                    {
1006:                        data = UARTGetDataByte(UART1);
1007:                    }
1008:                    </code>
1009:                
1010:                  Remarks:
1011:                    This routine is optimized for receiving 8-bit data through the UART.
1012:                  *****************************************************************************/
1013:                
1014:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1015:                {
1016:                    return (BYTE)uartReg[id]->rx.reg;
9D008594  8C620030   LW V0, 48(V1)
9D00861C  8C620030   LW V0, 48(V1)
9D008650  8C420030   LW V0, 48(V0)
9D00874C  8C450030   LW A1, 48(V0)
9D00881C  8C630030   LW V1, 48(V1)
1017:                }
1018:                
1019:                
1020:                /*******************************************************************************
1021:                  Function:
1022:                    UART_DATA UARTGetData ( UART_MODULE id )
1023:                
1024:                  Summary:
1025:                    Routine to get data received by the UART.
1026:                
1027:                  Description:
1028:                    This routine allows the caller to read a data word received by the UART.
1029:                
1030:                  Precondition:
1031:                    The module must have been appropriately configured, the UART module must have been
1032:                    enabled, and a complete data frame must have been received by the UART.
1033:                
1034:                  Parameters:
1035:                    id      - Identifies the desired UART module.
1036:                
1037:                  Returns:
1038:                    Data received by the UART.
1039:                
1040:                  Example:
1041:                    <code>
1042:                    UART_DATA data;
1043:                	
1044:                	if (UARTReceivedDataIsAvailable(UART1))
1045:                    {
1046:                        data = UARTGetData(UART1);
1047:                    }
1048:                    </code>
1049:                
1050:                  Remarks:
1051:                    Size of the data word depends on the current configuration (see
1052:                    UARTSetLineControl).
1053:                  *****************************************************************************/
1054:                
1055:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1056:                {
1057:                    UART_DATA data;
1058:                
1059:                    data.__data = uartReg[id]->rx.reg;
1060:                
1061:                    return data;
1062:                }
1063:                
1064:                
1065:                /*******************************************************************************
1066:                  Function:
1067:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1068:                
1069:                  Summary:
1070:                    Routine to program the address for which the UART module may watch.
1071:                
1072:                  Description:
1073:                    This routine programs the 8-bit address for which the module may watch.
1074:                
1075:                  Precondition:
1076:                    None
1077:                
1078:                  Parameters:
1079:                    id      - Identifies the desired UART module.
1080:                
1081:                    address - 8-bit address for which the module will watch.
1082:                
1083:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1084:                              * TRUE - Enable address watch mode
1085:                              * FALSE - Disable address watch mode
1086:                
1087:                  Returns:
1088:                    None.
1089:                
1090:                  Example:
1091:                    <code>
1092:                    #define SLAVE_ADDRESS  0x42
1093:                	
1094:                	UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1095:                    </code>
1096:                
1097:                  Remarks:
1098:                    The module can be placed into a mode where it will ignore all data received
1099:                    until it identifies the programmed adress.  After the programmed address
1100:                    has been identified, it will begin receiving data normally.  This mode is
1101:                    particularly useful for supporting the IEEE-485 protocol.
1102:                  *****************************************************************************/
1103:                
1104:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1105:                
1106:                
1107:                /*******************************************************************************
1108:                  Function:
1109:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1110:                
1111:                  Summary:
1112:                    Routine to enable or disable recognition of the programmed address byte.
1113:                
1114:                  Description:
1115:                    This routine can enable or disable the "address watch" mode.  In this mode,
1116:                    the UART module will ignore all data until it recognizes the programmed address.
1117:                
1118:                  Precondition:
1119:                    UART should have already been enabled and set with watch address.
1120:                
1121:                  Parameters:
1122:                    id      - Identifies the desired UART module.
1123:                
1124:                    watch   - Determines if the "address watch" mode will be enabled or
1125:                              disabled.
1126:                              * TRUE - Enable address watch mode
1127:                              * FALSE - Disable address watch mode
1128:                
1129:                  Returns:
1130:                    None.
1131:                
1132:                  Example:
1133:                    <code>
1134:                    #define SLAVE_ADDRESS 0x42
1135:                	
1136:                	// Set the address, but don't enable the watch until later,
1137:                	// UART continues to receive data normally
1138:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1139:                
1140:                    // ...
1141:                
1142:                    // Now begin to ignore all UART traffic until we are addressed
1143:                    UARTWatchForAddress(UART1, TRUE);
1144:                    </code>
1145:                
1146:                  Remarks:
1147:                    The UART module can be placed into a mode where it will ignore all data received
1148:                    until it identifies the programmed address.  After the programmed address
1149:                    has been identified, it will begin receiving data normally.  This mode is
1150:                    particularly useful for supporting the IEEE-485 protocol.
1151:                  *****************************************************************************/
1152:                
1153:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1154:                
1155:                
1156:                /*******************************************************************************
1157:                  Function:
1158:                    void UARTSendBreak ( UART_MODULE id )
1159:                
1160:                  Summary:
1161:                    Routine to send a break signal from the UART.
1162:                
1163:                  Description:
1164:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1165:                
1166:                  Precondition:
1167:                    The UART should have been appropriately configured.  The transmitter should
1168:                    be idle, although not necessarily enabled yet.
1169:                
1170:                  Parameters:
1171:                    id      - Identifies the desired UART module.
1172:                
1173:                  Returns:
1174:                    None
1175:                
1176:                  Example:
1177:                    <code>
1178:                    if (UARTTransmissionHasCompleted(UART1))
1179:                    {
1180:                        UARTSendBreak(UART1);
1181:                    }
1182:                    </code>
1183:                
1184:                  Remarks:
1185:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1186:                    data may be pre-loaded into the FIFO and it will be send immediately
1187:                    following the break signal.
1188:                  *****************************************************************************/
1189:                
1190:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1191:                {
1192:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1193:                }
1194:                
1195:                
1196:                /*******************************************************************************
1197:                  Function:
1198:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1199:                
1200:                  Summary:
1201:                    Routine to automatically determine the data rate (bits-per-second) of an
1202:                    external transmitter to the UART.
1203:                
1204:                  Description:
1205:                    This routine initiates the process of automatically determining the data
1206:                    rate (bits-per-second) of an external transmitter to the UART.
1207:                
1208:                  Precondition:
1209:                    The UART should have been appropriately configured.  The transmitter should
1210:                    be idle, although not necessarily enabled yet.
1211:                
1212:                  Parameters:
1213:                    id      - Identifies the desired UART module.
1214:                
1215:                  Returns:
1216:                    None
1217:                
1218:                  Example:
1219:                    <code>
1220:                	// See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1221:                	// methods to detect a Break.
1222:                	
1223:                    if (breakDetected && useAutoRateDetect) 
1224:                    {
1225:                        UARTStartAutoDataRateDetect (UART1);
1226:                    }
1227:                    </code>
1228:                
1229:                  Remarks:
1230:                    The UART module begins measuring the data rate beginning at the next start
1231:                    bit.  The external transmitter should send an alternating pattern (0x55)
1232:                    for the byte to be measured for an effective rate detection.  To ensure
1233:                    an effective measurement sequence, this can be done immediately following
1234:                    a break reception. It is important that this UART module is not
1235:                	transmitting data while it is trying to detect RX baud rate, see the 
1236:                	"PIC32 Family Reference Manual, Sect. 21 UART".
1237:                  *****************************************************************************/
1238:                
1239:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1240:                {
1241:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1242:                }
1243:                
1244:                
1245:                
1246:                /*******************************************************************************
1247:                  Function:
1248:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1249:                
1250:                  Summary:
1251:                    Routine to identify when automatic data rate detection has completed.
1252:                
1253:                  Description:
1254:                    This routine checks to see if automatic data rate detection has completed.
1255:                
1256:                  Precondition:
1257:                    Automatic rate detection should have been previously started.
1258:                
1259:                  Parameters:
1260:                    id      - Identifies the desired UART module.
1261:                
1262:                  Returns:
1263:                    * TRUE    - Indicates that automatic rate detection has completed.
1264:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1265:                
1266:                  Example:
1267:                    <code>
1268:                    #define PERIPHERAL_CLOCK    10000000
1269:                	
1270:                	UINT32 currentRate;
1271:                	
1272:                	if (UARTDataRateDetected(UART1))
1273:                    {
1274:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1275:                    }
1276:                    </code>
1277:                
1278:                  Remarks:
1279:                    This routine returns FALSE after automatic rate detection
1280:                    has been started but before rate is detectdd, it will return TRUE
1281:                	at any other time.
1282:                  *****************************************************************************/
1283:                
1284:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1285:                {
1286:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1287:                }
1288:                
1289:                #ifdef __cplusplus
1290:                  }
1291:                #endif
1292:                
1293:                #endif // _UART_h_
1294:                
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
118:                         pb_clock >>= 1;
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
170:                     {
171:                         wait_states++;
172:                         sys_clock -= FLASH_SPEED_HZ;
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
176:                     mCheConfigure(wait_states);
177:                     INTRestoreInterrupts(int_status);
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
227:                     {
228:                         wait_states++;
229:                         sys_clock -= FLASH_SPEED_HZ;
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
233:                     mCheConfigure(wait_states);
234:                     INTRestoreInterrupts(int_status);
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
279:                 
280:                     int_status=INTDisableInterrupts();
281:                 
282:                     mBMXDisableDRMWaitState();
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
286:                     cache_status |= CHE_CONF_PF_ALL;
287:                     mCheConfigure(cache_status);
288:                     CheKseg0CacheOn();
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
9D008E90  0F402A0F   JAL INTDisableInterrupts
9D008E94  00000000   NOP
342:                 
343:                     mBMXDisableDRMWaitState();
9D008E98  24040040   ADDIU A0, ZERO, 64
9D008E9C  3C03BF88   LUI V1, -16504
9D008EA0  AC642004   SW A0, 8196(V1)
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
358:                     {
359:                         cache_status = mCheGetCon();
360:                         cache_status |= CHE_CONF_PF_ALL;
361:                         mCheConfigure(cache_status);
362:                         CheKseg0CacheOn();
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
367:                     pb_clk >>= OSCCONbits.PBDIV;
9D008EA4  3C03BF81   LUI V1, -16511
9D008EA8  8C63F000   LW V1, -4096(V1)
368:                 
369:                     INTRestoreInterrupts(int_status);
9D008EAC  0F4029F0   JAL INTRestoreInterrupts
9D008EB0  00402021   ADDU A0, V0, ZERO
370:                 
371:                     return pb_clk;
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/vpc-32.c  -----------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /* 
20:                   * File:   vpc-32.c
21:                   * Author: Jacques Deschênes
22:                   *
23:                   * Created on 26 août 2013, 07:38
24:                   */
25:                  
26:                  #include <stdio.h>
27:                  #include <stdlib.h>
28:                  #include <plib.h>
29:                  
30:                  
31:                  #include "hardware/HardwareProfile.h"
32:                  #include "hardware/ntsc.h"
33:                  #include "hardware/serial_comm.h"
34:                  #include "hardware/keyboard.h"
35:                  #include "hardware/Pinguino/diskio.h"
36:                  #include "console.h"
37:                  #include "hardware/Pinguino/ff.h"
38:                  #include "vpForth/opcodes.h"
39:                  #include "vpForth/vpForth.h"
40:                  
41:                  // PIC32MX150F128B Configuration Bit Settings
42:                  #include <xc.h>
43:                  
44:                  // DEVCFG3
45:                  // USERID = No Setting
46:                  #pragma config PMDL1WAY = OFF           // permet plusieurs configurations des périphériques.
47:                  #pragma config IOL1WAY = OFF            // permet plusieurs configuration des broches.
48:                  
49:                  // DEVCFG2
50:                  #pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
51:                  #if SYSCLK==40000000L
52:                  #pragma config FPLLMUL = MUL_16         // SYSCLK=40Mhz
53:                  #else
54:                  #pragma config FPLLMUL = MUL_15          // PLL Multiplier (15x Multiplier) SYSCLK=37,5Mhz
55:                  #endif
56:                  #pragma config FPLLODIV = DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)
57:                  
58:                  // DEVCFG1
59:                  #pragma config FNOSC = PRIPLL           // Oscillator Selection Bits (Primary Osc w/PLL (XT+,HS+,EC+PLL))
60:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
61:                  #pragma config IESO = OFF               // Internal/External Switch Over (Disabled)
62:                  #pragma config POSCMOD = HS             // Primary Oscillator Configuration (XT osc mode)
63:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
64:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
65:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
66:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
67:                  
68:                  // DEVCFG0
69:                  #pragma config JTAGEN = OFF             // JTAG Enable (JTAG Disabled)
70:                  #pragma config ICESEL = ICS_PGx1        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
71:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
72:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
73:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
74:                  
75:                  
76:                  
77:                  const char *msg1=" test video ntsc\r";
78:                  const char *msg2="01234567890123456789012345678901234567890123456789012"; // 53 caractères par ligne
79:                  
80:                  
81:                  void test_pattern(void){
9D0095D4  27BDFFE8   ADDIU SP, SP, -24
9D0095D8  AFBF0014   SW RA, 20(SP)
9D0095DC  3C06A000   LUI A2, -24576
9D0095E0  24C6007C   ADDIU A2, A2, 124
9D0095E4  00C03821   ADDU A3, A2, ZERO
9D0095E8  24C523F0   ADDIU A1, A2, 9200
9D0095EC  00C01021   ADDU V0, A2, ZERO
9D00960C  24E30028   ADDIU V1, A3, 40
9D009630  24E71AE8   ADDIU A3, A3, 6888
82:                      int i,j;
83:                      for (i=0;i<VRES;i++){
9D009604  5445FFFD   BNEL V0, A1, 0x9D0095FC
9D009608  AC440000   SW A0, 0(V0)
84:                          video_bmp[i][0]=0x80000000;
9D0095F0  3C048000   LUI A0, -32768
9D0095F8  AC440000   SW A0, 0(V0)
85:                          video_bmp[i][HRES/32-1]=1;
9D0095F4  24030001   ADDIU V1, ZERO, 1
9D0095FC  AC430024   SW V1, 36(V0)
9D009600  24420028   ADDIU V0, V0, 40
86:                      }
87:                      for (i=0;i<HRES/32;i++){
9D009620  54C3FFFD   BNEL A2, V1, 0x9D009618
9D009624  ACC20000   SW V0, 0(A2)
9D009628  3C02A000   LUI V0, -24576
9D00962C  2442096C   ADDIU V0, V0, 2412
88:                          video_bmp[0][i]=0xffffffff;
9D009610  2402FFFF   ADDIU V0, ZERO, -1
9D009614  ACC20000   SW V0, 0(A2)
89:                          video_bmp[VRES-1][i]=0xffffffff;
9D009618  ACC223C8   SW V0, 9160(A2)
9D00961C  24C60004   ADDIU A2, A2, 4
90:                      }
91:                      for (i=VRES/4;i<VRES/2+VRES/4;i++){
9D009668  5447FFFB   BNEL V0, A3, 0x9D009658
9D00966C  AC460000   SW A2, 0(V0)
92:                          video_bmp[i][2]=0xFF00FF00;
9D009634  3C06FF00   LUI A2, -256
9D009638  34C6FF00   ORI A2, A2, -256
9D009654  AC460000   SW A2, 0(V0)
93:                          video_bmp[i][3]=0xF0F0F0F0;
9D00963C  3C05F0F0   LUI A1, -3856
9D009640  34A5F0F0   ORI A1, A1, -3856
9D009658  AC450004   SW A1, 4(V0)
94:                          video_bmp[i][4]=0xcccccccc;
9D009644  3C04CCCC   LUI A0, -13108
9D009648  3484CCCC   ORI A0, A0, -13108
9D00965C  AC440008   SW A0, 8(V0)
95:                          video_bmp[i][5]=0xaaaaaaaa;
9D00964C  3C03AAAA   LUI V1, -21846
9D009650  3463AAAA   ORI V1, V1, -21846
9D009660  AC43000C   SW V1, 12(V0)
9D009664  24420028   ADDIU V0, V0, 40
96:                      }//i
97:                      print(LOCAL_CON,msg1);
9D009670  00002021   ADDU A0, ZERO, ZERO
9D009674  0F401D9C   JAL print
9D009678  8F858014   LW A1, -32748(GP)
98:                      print(LOCAL_CON,msg2);
9D00967C  00002021   ADDU A0, ZERO, ZERO
9D009680  0F401D9C   JAL print
9D009684  8F858018   LW A1, -32744(GP)
99:                  }//test_pattern()
9D009688  8FBF0014   LW RA, 20(SP)
9D00968C  03E00008   JR RA
9D009690  27BD0018   ADDIU SP, SP, 24
100:                 
101:                 
102:                 void main(void) {
9D009694  27BDFFE8   ADDIU SP, SP, -24
9D009698  AFBF0014   SW RA, 20(SP)
103:                     int code;
104:                     short key;
105:                     unsigned char buff[BLK_SIZE];
106:                     int i;
107:                     unsigned int size;
108:                 
109:                     HardwareInit();
9D00969C  0F4023A2   JAL HardwareInit
9D0096A0  00000000   NOP
110:                     UartInit(STDIO,115200,DEFAULT_LINE_CTRL);
9D0096A4  24040001   ADDIU A0, ZERO, 1
9D0096A8  3C050001   LUI A1, 1
9D0096AC  34A5C200   ORI A1, A1, -15872
9D0096B0  0F40213F   JAL UartInit
9D0096B4  00003021   ADDU A2, ZERO, ZERO
111:                     ln_cnt=0;
9D0096B8  AF808050   SW ZERO, -32688(GP)
112:                     video=0;
9D0096BC  AF80804C   SW ZERO, -32692(GP)
113:                     test_pattern();
9D0096C0  0F402575   JAL test_pattern
9D0096C4  00000000   NOP
114:                     UartPrint(STDOUT,"initialisation video\r");
9D0096C8  24040001   ADDIU A0, ZERO, 1
9D0096CC  3C059D01   LUI A1, -25343
9D0096D0  0F4021A1   JAL UartPrint
9D0096D4  24A59C7C   ADDIU A1, A1, -25476
115:                     VideoInit();
9D0096D8  0F402210   JAL VideoInit
9D0096DC  00000000   NOP
116:                     delay_ms(500);
9D0096E0  0F402417   JAL delay_ms
9D0096E4  240401F4   ADDIU A0, ZERO, 500
117:                     UartPrint(STDOUT,"initialisation clavier: ");
9D0096E8  24040001   ADDIU A0, ZERO, 1
9D0096EC  3C059D01   LUI A1, -25343
9D0096F0  0F4021A1   JAL UartPrint
9D0096F4  24A59C94   ADDIU A1, A1, -25452
118:                     if (KeyboardInit()){
9D0096F8  0F4018D9   JAL KeyboardInit
9D0096FC  00000000   NOP
9D009700  10400006   BEQ V0, ZERO, 0x9D00971C
9D009704  24040001   ADDIU A0, ZERO, 1
119:                         UartPrint(STDOUT,"OK\r");
9D009708  3C059D01   LUI A1, -25343
9D00970C  0F4021A1   JAL UartPrint
9D009710  24A59CB0   ADDIU A1, A1, -25424
120:                         comm_channel=LOCAL_CON;
9D009714  0B4025D0   J 0x9D009740
9D009718  A3808034   SB ZERO, -32716(GP)
121:                     }else{
122:                         UartPrint(STDOUT,"erreur clavier\r");
9D00971C  3C059D01   LUI A1, -25343
9D009720  0F4021A1   JAL UartPrint
9D009724  24A59CB4   ADDIU A1, A1, -25420
123:                         UartPrint(STDOUT,"Utilisation du lien sériel.\r");
9D009728  24040001   ADDIU A0, ZERO, 1
9D00972C  3C059D01   LUI A1, -25343
9D009730  0F4021A1   JAL UartPrint
9D009734  24A59CC4   ADDIU A1, A1, -25404
124:                         comm_channel=SERIAL_CON;
9D009738  24020001   ADDIU V0, ZERO, 1
9D00973C  A3828034   SB V0, -32716(GP)
125:                     }
126:                     text_coord_t cpos;
127:                     UartPrint(STDOUT,"initialisation peripherique carte SD.\r");
9D009740  24040001   ADDIU A0, ZERO, 1
9D009744  3C059D01   LUI A1, -25343
9D009748  0F4021A1   JAL UartPrint
9D00974C  24A59CE4   ADDIU A1, A1, -25372
128:                     UartPrint(STDOUT,"initialisation carte SD: ");
9D009750  24040001   ADDIU A0, ZERO, 1
9D009754  3C059D01   LUI A1, -25343
9D009758  0F4021A1   JAL UartPrint
9D00975C  24A59D0C   ADDIU A1, A1, -25332
129:                     if (!mount(0)){
9D009760  0F4022EB   JAL mount
9D009764  00002021   ADDU A0, ZERO, ZERO
9D009768  14400005   BNE V0, ZERO, 0x9D009780
9D00976C  24040001   ADDIU A0, ZERO, 1
130:                         UartPrint(STDOUT,"Echec\r");
9D009770  3C059D01   LUI A1, -25343
9D009774  0F4021A1   JAL UartPrint
9D009778  24A59D28   ADDIU A1, A1, -25304
131:                     }
132:                     UartPrint(STDOUT, "OK\r");
9D00977C  24040001   ADDIU A0, ZERO, 1
9D009780  3C059D01   LUI A1, -25343
9D009784  0F4021A1   JAL UartPrint
9D009788  24A59CB0   ADDIU A1, A1, -25424
133:                 //    FIL *fp;
134:                 //    FILINFO *fo;
135:                 //    fp=malloc(sizeof(FIL));
136:                 //    fo=malloc(sizeof(FILINFO));
137:                 //    if (!f_open(fp,"readme.txt",FA_READ)){
138:                 //        f_stat("readme.txt",fo);
139:                 //        if (!f_read(fp,buff,fo->fsize,(UINT*)&i)){
140:                 //            clear_screen();
141:                 //            buff[fo->fsize]=0;
142:                 //            print("file size: ");
143:                 //            print_int(i,10);
144:                 //            put_char('\r');
145:                 //            print(buff);
146:                 //            f_close(fp);
147:                 //            if (i==40){
148:                 //                f_open(fp,"readme.txt",FA_WRITE);
149:                 //                f_lseek(fp,i);
150:                 //                f_write(fp,"test ecriture\r",14,(UINT*)&i);
151:                 //                f_stat("readme.txt",fo);
152:                 //                print("grandeur apres ecriture: ");
153:                 //                print_int(fo->fsize,10);
154:                 //                f_close(fp);
155:                 //            }
156:                 //            free(fp);
157:                 //            free(fo);
158:                 //        }
159:                 //    }
160:                 //    UartPrint(STDOUT,"lecture du registre CSD\r");
161:                 //    clear_screen();
162:                 //    size=disk_ioctl(0,GET_SECTOR_SIZE,buff);
163:                 //    print_int(*(unsigned short *)buff,10);
164:                 //    put_char('\r');
165:                 //    size=disk_ioctl(0,GET_SECTOR_COUNT,buff);
166:                 //    print_int(*(int*)buff,10);
167:                 //    put_char('\r');
168:                 //    size=disk_ioctl(0,GET_BLOCK_SIZE,buff);
169:                 //    print_int(*(int*)buff,10);
170:                 //    put_char('\r');
171:                 //    for (i=511;i;i--){
172:                 //        buff[i]=255;
173:                 //    }
174:                 //    while (1);
175:                 //    delay_ms(2000);
176:                     tone(400,1000);
9D00978C  24040190   ADDIU A0, ZERO, 400
9D009790  0F402810   JAL tone
9D009794  240503E8   ADDIU A1, ZERO, 1000
177:                     UartPrint(STDOUT,"initialisation completee.\r");
9D009798  24040001   ADDIU A0, ZERO, 1
9D00979C  3C059D01   LUI A1, -25343
9D0097A0  0F4021A1   JAL UartPrint
9D0097A4  24A59D30   ADDIU A1, A1, -25296
178:                     set_cursor(CR_BLOCK);
9D0097A8  0F401E82   JAL set_cursor
9D0097AC  24040001   ADDIU A0, ZERO, 1
179:                     clear_screen();
9D0097B0  0F401D8E   JAL clear_screen
9D0097B4  00000000   NOP
180:                     while(1){
181:                         vpForth();
9D0097B8  0F40161F   JAL vpForth
9D0097BC  00000000   NOP
9D0097C0  0B4025EE   J 0x9D0097B8
9D0097C4  00000000   NOP
182:                     } // while(1)
183:                 } // main()
184:                 
185:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/vpForth/vpForth.c  --------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   vpForth.c
21:                   * Author: Jacques Deschênes
22:                   *
23:                   * Created on 6 juin 2013
24:                   */
25:                  
26:                  #include "../hardware/HardwareProfile.h"
27:                  #include "../hardware/serial_comm.h"
28:                  #include "../console.h"
29:                  
30:                  #include "vpForth.h"
31:                  #include "opcodes.h"
32:                  
33:                  #define TIB_SIZE 80
34:                  #define PAD_SIZE 80
35:                  #define USER_NAMES_SIZE 100
36:                  #define XT_NULL 0
37:                  #define COMPILE 1
38:                  #define IMMEDIATE 0
39:                  #define RESERVED 0
40:                  #define CELL_SIZE 4
41:                  #define HASH_BASE 68
42:                  
43:                  
44:                  // data types
45:                  typedef unsigned char BYTE ;
46:                  typedef unsigned short WORD;
47:                  typedef unsigned int name_hash;
48:                  typedef char *code_ptr;
49:                  typedef int(*compfct)();
50:                  
51:                  typedef struct{
52:                      name_hash name;
53:                      code_ptr cfa;
54:                  } dict_entry_t;
55:                  
56:                  
57:                  // variables
58:                  unsigned char ram_code[RAM_SPACE];
59:                  char state=IMMEDIATE;
60:                  int cstack[6]; // pile utilisé par le compilateur (control flow stack)
61:                  char cp=-1; //pointeur pour la pile cstack
62:                  char error=0;
63:                  code_ptr imm_code, mark;
64:                  
65:                  const name_hash vm_tokens[]= { // vm tokens hash
66:                  169559, // END
67:                  9629672, // ?KEY
68:                  11525779, // EMIT
69:                  201603, // LIT
70:                  801952535, // FCALL
71:                  229075, // RET
72:                  155956, // BRA
73:                  9588916, // ?BRA
74:                  11576354, // EXEC
75:                  0, // !
76:                  31, // @
77:                  2312, // C!
78:                  2343, // C@
79:                  229803, // RP@
80:                  229772, // RP!
81:                  3363, // R@
82:                  2021, // >R
83:                  3361, // R>
84:                  234427, // SP@
85:                  234396, // SP!
86:                  11234871, // DROP
87:                  165423, // DUP
88:                  15973519, // SWAP
89:                  14711441, // OVER
90:                  10, // +
91:                  12, // -
92:                  9, // *
93:                  14, // /
94:                  206619, // MOD
95:                  1047, // 0<
96:                  151063, // AND
97:                  3177, // OR
98:                  257497, // XOR
99:                  211259, // NOT
100:                 196712, // KEY
101:                 233765, // SFR
102:                 233699, // SET
103:                 740656049, // CLEAR
104:                 188073, // INV
105:                 10892291, // CLIT
106:                 17180931, // WLIT
107:                 885, // ."
108:                 1059157367, // READL
109:                 1058529047, // RCALL
110:                 16298208, // TYPE
111:                 759868776, // DELAY
112:                 9598383, // ?DUP
113:                 696, // +1
114:                 832, // -1
115:                 680, // +!
116:                 374718263, // 2drop
117:                 229755, // rot
118:                 5510767, // 2dup
119:                 206221, // min
120:                 205687, // max
121:                 150262, // abs
122:                 1863, // <<
123:                 2001, // >>
124:                 4608667, // /mod
125:                 652046345, // ?braz
126:                 13, // .
127:                 267015, // zsp
128:                 266947, // zrp
129:                 12432680, // here
130:                 10527660, // base
131:                 28, // =
132:                 1865, // <>
133:                 27, // <
134:                 29, // >
135:                 1864, // <=
136:                 2000, // >=
137:                 866780819 // iemit
138:                 } ;
139:                 
140:                 
141:                 // mots système enrigistrés en mémoire flash
142:                 const char space[]={ICLIT,32,IEMIT,IRET};
143:                 const char spaces[]={IDUP, IQBRA, 2, IDROP, IRET, ICLIT, 32, IEMIT, IMINUS1, IBRA, -11 };
144:                 const char cr[]={ICLIT,13,IEMIT,IRET};
145:                 
146:                 //ICLIT,SPC,IEMIT,
147:                 const char dots[]={ICLIT,SPC,IEMIT,ICLIT,'(',IEMIT,ISPFETCH,IZSP,ISUB,
148:                                    ICLIT,CELL_SIZE,IDIV,IDUP,IDOT,ICLIT,')',IEMIT,ICLIT,SPC,IEMIT,
149:                                    ITOR,IZSP,ICLIT,CELL_SIZE,IADD,IRFROM,IDUP,IQBRAZ,10,IMINUS1,
150:                                    ITOR,IDUP,IFETCH,IDOT,ICLIT,CELL_SIZE,IADD,IBRA, -14,IDDROP,IRET};
151:                 
152:                 //ICLIT,SPC,IEMIT,
153:                 const char dotr[]={ICLIT,SPC,IEMIT,ICLIT,'(',IEMIT,IRPFETCH,IZRP,ISUB,
154:                                    ICLIT,CELL_SIZE,IDIV,IDUP,IDOT,ICLIT,')',IEMIT,ICLIT,SPC,IEMIT,
155:                                    ITOR,IZRP,ICLIT,CELL_SIZE,IADD,IRFROM,IDUP,IQBRAZ,10,IMINUS1,
156:                                    ITOR,IDUP,IFETCH,IDOT,ICLIT,CELL_SIZE,IADD,IBRA, -14,IDDROP,IRET};
157:                 
158:                 //void print_integer(int n);
159:                 void compile_if();
160:                 void compile_then();
161:                 void compile_else();
162:                 void compile_repeat();
163:                 void compile_again();
164:                 void compile_while();
165:                 void compile_do();
166:                 void compile_loop();
167:                 void compile_ploop();
168:                 void compile_begin();
169:                 void compile_until();
170:                 void compile_var();
171:                 void compile_const();
172:                 int compile_token(int);
173:                 void column();
174:                 void semi_column();
175:                 
176:                 
177:                 dict_entry_t system_dict[]={
178:                     {-25,(code_ptr)column}, // :
179:                     {-26,(code_ptr)semi_column}, // ;
180:                     {-247297, (code_ptr)compile_var}, // var
181:                     {-741642187, (code_ptr)compile_const},  // const
182:                     {-2757, (code_ptr)compile_if}, // if
183:                     {-16218861, (code_ptr)compile_then}, // then
184:                     {-11521820, (code_ptr)compile_else}, // else
185:                     {-15576879, (code_ptr)compile_repeat},  //rept
186:                     {-696303181, (code_ptr)compile_again}, // again
187:                     {-1167045072, (code_ptr)compile_while}, // while
188:                     {-2426, (code_ptr)compile_do}, // do
189:                     {-13736455, (code_ptr)compile_loop}, // loop
190:                     {-227550215, (code_ptr)compile_ploop}, // +loop
191:                     {-717083437, (code_ptr)compile_begin}, // begin
192:                     {-1126219579, (code_ptr)compile_until}, // until
193:                     {934,(code_ptr)dots}, // .s
194:                     {933,(code_ptr)dotr}, // .r
195:                     {1083997420, (code_ptr)space},  // 'space'
196:                     {1084006818, (code_ptr)spaces}, // 'spces'
197:                     {2361,(code_ptr)cr},  // 'cr'
198:                 };
199:                 #define SYSTEM_COUNT 20
200:                 
201:                 
202:                 
203:                 dict_entry_t user_dict[USER_NAMES_SIZE];
204:                 char free_slot=0;
205:                 
206:                 char tib[TIB_SIZE];
207:                 char pad[PAD_SIZE];
208:                 
209:                 code_ptr cip;
210:                 
211:                 char ctib;
212:                 char first, last,current;
213:                 
214:                 
215:                 name_hash hash(){// hash le token courant.
9D004C24  3C08A000   LUI T0, -24576
9D004C28  250824BC   ADDIU T0, T0, 9404
9D004C2C  01042021   ADDU A0, T0, A0
9D004C30  25080005   ADDIU T0, T0, 5
9D004C34  01054021   ADDU T0, T0, A1
216:                     name_hash nh;
217:                     int i;
218:                     char c;
219:                     nh=0;
220:                     for (i=first;i<first+5 && tib[i]!=0;i++){
9D004BF4  83858070   LB A1, -32656(GP)
9D004BF8  24A30005   ADDIU V1, A1, 5
9D004BFC  00A3182A   SLT V1, A1, V1
9D004C00  10600023   BEQ V1, ZERO, 0x9D004C90
9D004C04  00001021   ADDU V0, ZERO, ZERO
9D004C08  3C02A000   LUI V0, -24576
9D004C0C  244224BC   ADDIU V0, V0, 9404
9D004C10  00451021   ADDU V0, V0, A1
9D004C14  80430000   LB V1, 0(V0)
9D004C18  1060001D   BEQ V1, ZERO, 0x9D004C90
9D004C1C  00001021   ADDU V0, ZERO, ZERO
9D004C20  24A40001   ADDIU A0, A1, 1
9D004C7C  10880004   BEQ A0, T0, 0x9D004C90
9D004C80  00431021   ADDU V0, V0, V1
9D004C84  80830000   LB V1, 0(A0)
9D004C88  1460FFEC   BNE V1, ZERO, 0x9D004C3C
9D004C8C  24840001   ADDIU A0, A0, 1
221:                         c = tib[i] & 127;
9D004C3C  3063007F   ANDI V1, V1, 127
222:                         if (c>='a' && c<='z') c -= 32;
9D004C40  306500FF   ANDI A1, V1, 255
9D004C44  24A6FF9F   ADDIU A2, A1, -97
9D004C48  30C600FF   ANDI A2, A2, 255
9D004C4C  2CC6001A   SLTIU A2, A2, 26
9D004C50  10C00004   BEQ A2, ZERO, 0x9D004C64
9D004C54  2866007B   SLTI A2, V1, 123
9D004C58  24A3FFE0   ADDIU V1, A1, -32
9D004C5C  0B40131D   J 0x9D004C74
9D004C60  7C031C20   SEB V1, V1
223:                         else if (c>'z') c -= 26;
9D004C64  54C00004   BNEL A2, ZERO, 0x9D004C78
9D004C68  70471002   MUL V0, V0, A3
9D004C6C  24A3FFE6   ADDIU V1, A1, -26
9D004C70  7C031C20   SEB V1, V1
224:                         nh *= HASH_BASE;
9D004C38  24070044   ADDIU A3, ZERO, 68
9D004C74  70471002   MUL V0, V0, A3
225:                         nh += c-33;
9D004C78  2442FFDF   ADDIU V0, V0, -33
226:                     }
227:                     return nh;
228:                 }//hash()
9D004C90  03E00008   JR RA
9D004C94  00000000   NOP
229:                 
230:                 void hash2str(name_hash hash, char *name){
9D004C98  27BDFFE0   ADDIU SP, SP, -32
9D004C9C  AFBF001C   SW RA, 28(SP)
9D004CE8  27A80010   ADDIU T0, SP, 16
9D004CEC  01023821   ADDU A3, T0, V0
231:                     int i,d;
232:                     char str[6];
233:                     str[5]=0;
234:                     i=4;
9D004CA8  24020004   ADDIU V0, ZERO, 4
235:                     while (hash){
9D004CA0  10800019   BEQ A0, ZERO, 0x9D004D08
9D004CA4  A3A00015   SB ZERO, 21(SP)
9D004CF4  1480FFF1   BNE A0, ZERO, 0x9D004CBC
9D004CF8  2443FFFF   ADDIU V1, V0, -1
236:                         d=hash % HASH_BASE;
9D004CAC  24060044   ADDIU A2, ZERO, 68
9D004CC0  0086001B   DIVU A0, A2
9D004CC4  00C001F4   TEQ A2, ZERO
9D004CC8  00001810   MFHI V1, 0
237:                         hash /= HASH_BASE;
9D004CB0  3C09F0F0   LUI T1, -3856
9D004CB4  0B401330   J 0x9D004CC0
9D004CB8  3529F0F1   ORI T1, T1, -3855
9D004CCC  00890019   MULTU 0, A0, T1
9D004CD0  00005810   MFHI T3, 0
9D004CD4  000B2182   SRL A0, T3, 6
238:                         d += 33;
9D004CD8  24630021   ADDIU V1, V1, 33
239:                         if (d>='a') d += 26;
9D004CDC  28680061   SLTI T0, V1, 97
9D004CE0  2467001A   ADDIU A3, V1, 26
9D004CE4  00E8180A   MOVZ V1, A3, T0
240:                         str[i--]=d;
9D004CBC  00601021   ADDU V0, V1, ZERO
9D004CF0  A0E30000   SB V1, 0(A3)
241:                     }
242:                     if (i==4) str[4]=33; else i++;
9D004CFC  24040004   ADDIU A0, ZERO, 4
9D004D00  14640005   BNE V1, A0, 0x9D004D18
9D004D04  00A02021   ADDU A0, A1, ZERO
9D004D08  24020021   ADDIU V0, ZERO, 33
9D004D0C  A3A20014   SB V0, 20(SP)
9D004D10  24020004   ADDIU V0, ZERO, 4
243:                     strcpy(name,&str[i]);
9D004D14  00A02021   ADDU A0, A1, ZERO
9D004D18  27AA0010   ADDIU T2, SP, 16
9D004D1C  0F40265B   JAL 0x9D00996C
9D004D20  01422821   ADDU A1, T2, V0
244:                 }//hashs2str()
9D004D24  8FBF001C   LW RA, 28(SP)
9D004D28  03E00008   JR RA
9D004D2C  27BD0020   ADDIU SP, SP, 32
245:                 
246:                 
247:                 void upper(){
9D004D44  3C02A000   LUI V0, -24576
9D004D48  244224BC   ADDIU V0, V0, 9404
9D004D4C  00441021   ADDU V0, V0, A0
9D004D70  2464FFFF   ADDIU A0, V1, -1
248:                     int i;
249:                     for (i=first;i<=last;i++) if (tib[i]>='a' && tib[i]<='z') tib[i] -= 32;
9D004D30  83848070   LB A0, -32656(GP)
9D004D34  8386805C   LB A2, -32676(GP)
9D004D38  00C4102A   SLT V0, A2, A0
9D004D3C  14400010   BNE V0, ZERO, 0x9D004D80
9D004D40  24830001   ADDIU V1, A0, 1
9D004D50  90440000   LBU A0, 0(V0)
9D004D54  2485FF9F   ADDIU A1, A0, -97
9D004D58  30A500FF   ANDI A1, A1, 255
9D004D5C  2CA5001A   SLTIU A1, A1, 26
9D004D60  10A00003   BEQ A1, ZERO, 0x9D004D70
9D004D64  24630001   ADDIU V1, V1, 1
9D004D68  2484FFE0   ADDIU A0, A0, -32
9D004D6C  A0440000   SB A0, 0(V0)
9D004D74  00C4202A   SLT A0, A2, A0
9D004D78  1080FFF5   BEQ A0, ZERO, 0x9D004D50
9D004D7C  24420001   ADDIU V0, V0, 1
9D004D80  03E00008   JR RA
9D004D84  00000000   NOP
250:                 }// upper()
251:                 
252:                 int word(int c){
9D004DB8  250824BC   ADDIU T0, T0, 9404
9D004DE4  24A524BC   ADDIU A1, A1, 9404
253:                     int i;
254:                     i=current;
9D004D88  83838064   LB V1, -32668(GP)
9D004D8C  00601021   ADDU V0, V1, ZERO
255:                     while  (i<ctib && tib[i]==c ) i++;
9D004D90  83878071   LB A3, -32655(GP)
9D004D94  0067282A   SLT A1, V1, A3
9D004D98  10A00010   BEQ A1, ZERO, 0x9D004DDC
9D004D9C  00E03021   ADDU A2, A3, ZERO
9D004DA0  3C05A000   LUI A1, -24576
9D004DA4  24A524BC   ADDIU A1, A1, 9404
9D004DA8  00A31821   ADDU V1, A1, V1
9D004DAC  80650000   LB A1, 0(V1)
9D004DB0  14A40023   BNE A1, A0, 0x9D004E40
9D004DB4  3C08A000   LUI T0, -24576
9D004DBC  24420001   ADDIU V0, V0, 1
9D004DC0  10470006   BEQ V0, A3, 0x9D004DDC
9D004DC4  01021821   ADDU V1, T0, V0
9D004DC8  80630000   LB V1, 0(V1)
9D004DCC  5065FFFC   BEQL V1, A1, 0x9D004DC0
9D004DD0  24420001   ADDIU V0, V0, 1
256:                     first=i;
9D004DD4  0B401391   J 0x9D004E44
9D004DD8  A3828070   SB V0, -32656(GP)
9D004DDC  0B401381   J 0x9D004E04
9D004DE0  A3828070   SB V0, -32656(GP)
9D004E40  A3828070   SB V0, -32656(GP)
257:                     while (i<ctib && tib[i]!=c) i++;
9D004DE8  24420001   ADDIU V0, V0, 1
9D004DEC  0046182A   SLT V1, V0, A2
9D004DF0  10600004   BEQ V1, ZERO, 0x9D004E04
9D004DF4  00A21821   ADDU V1, A1, V0
9D004DF8  80630000   LB V1, 0(V1)
9D004DFC  5464FFFB   BNEL V1, A0, 0x9D004DEC
9D004E00  24420001   ADDIU V0, V0, 1
9D004E44  3C03A000   LUI V1, -24576
9D004E48  246324BC   ADDIU V1, V1, 9404
9D004E4C  00431821   ADDU V1, V0, V1
9D004E50  80630000   LB V1, 0(V1)
9D004E54  5464FFE3   BNEL V1, A0, 0x9D004DE4
9D004E58  3C05A000   LUI A1, -24576
258:                     last = i-1;
9D004E04  2443FFFF   ADDIU V1, V0, -1
9D004E08  A383805C   SB V1, -32676(GP)
9D004E5C  0B401382   J 0x9D004E08
9D004E60  2443FFFF   ADDIU V1, V0, -1
9D004E64  03E00008   JR RA
9D004E68  00000000   NOP
259:                     if (tib[i]==c){tib[i]=0; i++;}
9D004E0C  3C03A000   LUI V1, -24576
9D004E10  246324BC   ADDIU V1, V1, 9404
9D004E14  00431821   ADDU V1, V0, V1
9D004E18  80630000   LB V1, 0(V1)
9D004E1C  54640011   BNEL V1, A0, 0x9D004E64
9D004E20  A3828064   SB V0, -32668(GP)
9D004E24  3C03A000   LUI V1, -24576
9D004E28  246324BC   ADDIU V1, V1, 9404
9D004E2C  00431821   ADDU V1, V0, V1
9D004E30  A0600000   SB ZERO, 0(V1)
9D004E34  24420001   ADDIU V0, V0, 1
260:                     current=i;
261:                 }// word()
9D004E38  03E00008   JR RA
9D004E3C  A3828064   SB V0, -32668(GP)
262:                 
263:                 
264:                 int try_user(name_hash nh){
9D00516C  000318C0   SLL V1, V1, 3
9D005170  3C05A000   LUI A1, -24576
9D005174  24A5250C   ADDIU A1, A1, 9484
9D005178  00A31821   ADDU V1, A1, V1
265:                     int i;
266:                     code_ptr cptr;
267:                     if (state)cptr=here; else cptr=cip;
9D0050DC  8382802E   LB V0, -32722(GP)
9D0050E0  50400002   BEQL V0, ZERO, 0x9D0050EC
9D0050E4  8F878068   LW A3, -32664(GP)
9D0050E8  8F87CBC8   LW A3, -13368(GP)
268:                     for(i=free_slot-1;i>-1;i--){
9D0050EC  83838030   LB V1, -32720(GP)
9D0050F0  2462FFFF   ADDIU V0, V1, -1
9D0050F4  04400025   BLTZ V0, 0x9D00518C
9D0050F8  3C05A000   LUI A1, -24576
9D00517C  2406FFFF   ADDIU A2, ZERO, -1
9D005180  2442FFFF   ADDIU V0, V0, -1
9D005184  5446FFE5   BNEL V0, A2, 0x9D00511C
9D005188  8C650000   LW A1, 0(V1)
269:                         if (user_dict[i].name==nh){
9D0050FC  000230C0   SLL A2, V0, 3
9D005100  24A5250C   ADDIU A1, A1, 9484
9D005104  00C52821   ADDU A1, A2, A1
9D005108  8CA50000   LW A1, 0(A1)
9D00510C  54A40017   BNEL A1, A0, 0x9D00516C
9D005110  2463FFFE   ADDIU V1, V1, -2
9D00511C  14A40018   BNE A1, A0, 0x9D005180
9D005120  2463FFF8   ADDIU V1, V1, -8
270:                             *cptr++=IRCALL;
9D005114  0B40144A   J 0x9D005128
9D005118  2403002B   ADDIU V1, ZERO, 43
9D005124  2403002B   ADDIU V1, ZERO, 43
9D005128  A0E30000   SB V1, 0(A3)
271:                             *cptr++=(int)user_dict[i].cfa;
9D00512C  000220C0   SLL A0, V0, 3
9D005130  3C03A000   LUI V1, -24576
9D005134  2463250C   ADDIU V1, V1, 9484
9D005138  00641821   ADDU V1, V1, A0
9D00513C  8C640004   LW A0, 4(V1)
9D005140  A0E40001   SB A0, 1(A3)
272:                             *cptr++=(int)user_dict[i].cfa>>8;
9D005144  8C630004   LW V1, 4(V1)
9D005148  00031A03   SRA V1, V1, 8
9D00514C  A0E30002   SB V1, 2(A3)
273:                             if (state)here=cptr;else cip=cptr;
9D005150  8383802E   LB V1, -32722(GP)
9D005154  10600003   BEQ V1, ZERO, 0x9D005164
9D005158  24E70003   ADDIU A3, A3, 3
9D00515C  0B401463   J 0x9D00518C
9D005160  AF87CBC8   SW A3, -13368(GP)
9D005164  0B401463   J 0x9D00518C
9D005168  AF878068   SW A3, -32664(GP)
274:                             break;
275:                         }
276:                     }
277:                     if (i==-1) return 0; else return 1;
9D00518C  24420001   ADDIU V0, V0, 1
278:                 }// try_user()
9D005190  03E00008   JR RA
9D005194  0002102B   SLTU V0, ZERO, V0
279:                 
280:                 int try_system(name_hash nh){
9D005198  27BDFFE8   ADDIU SP, SP, -24
9D00519C  AFBF0014   SW RA, 20(SP)
9D005220  8382802F   LB V0, -32721(GP)
9D005224  0B4014A1   J 0x9D005284
9D005228  2C420001   SLTIU V0, V0, 1
281:                     int i;
282:                     code_ptr cptr;
283:                    compfct f;
284:                    if (state) cptr=here;else cptr=cip;
9D0051A0  8382802E   LB V0, -32722(GP)
9D0051A4  50400002   BEQL V0, ZERO, 0x9D0051B0
9D0051A8  8F898068   LW T1, -32664(GP)
9D0051AC  8F89CBC8   LW T1, -13368(GP)
285:                    for(i=SYSTEM_COUNT-1;i>-1;i--){
9D0051D0  24030012   ADDIU V1, ZERO, 18
9D0051D4  2408FFFF   ADDIU T0, ZERO, -1
9D0051F8  24030013   ADDIU V1, ZERO, 19
9D005278  1468FFD7   BNE V1, T0, 0x9D0051D8
9D00527C  24A5FFF8   ADDIU A1, A1, -8
286:                         if (abs(system_dict[i].name)==nh){
9D0051B0  3C02A000   LUI V0, -24576
9D0051B4  8C424B24   LW V0, 19236(V0)
9D0051B8  00021FC3   SRA V1, V0, 31
9D0051BC  00622826   XOR A1, V1, V0
9D0051C0  00A31823   SUBU V1, A1, V1
9D0051C4  1064000C   BEQ V1, A0, 0x9D0051F8
9D0051C8  3C05A000   LUI A1, -24576
9D0051CC  24A54B1C   ADDIU A1, A1, 19228
9D0051D8  8CA20000   LW V0, 0(A1)
9D0051DC  000237C3   SRA A2, V0, 31
9D0051E0  00C23826   XOR A3, A2, V0
9D0051E4  00E63023   SUBU A2, A3, A2
9D0051E8  54C40023   BNEL A2, A0, 0x9D005278
9D0051EC  2463FFFF   ADDIU V1, V1, -1
9D0051F0  0B40147F   J 0x9D0051FC
9D0051F4  00000000   NOP
287:                             if ((int)system_dict[i].name<0){
9D0051FC  0443000B   BGEZL V0, 0x9D00522C
9D005200  24020004   ADDIU V0, ZERO, 4
288:                                 f=(compfct)system_dict[i].cfa;
9D005204  000318C0   SLL V1, V1, 3
9D005208  3C02A000   LUI V0, -24576
9D00520C  24424A8C   ADDIU V0, V0, 19084
9D005210  00431821   ADDU V1, V0, V1
289:                                 f();
9D005214  8C620004   LW V0, 4(V1)
9D005218  0040F809   JALR V0
9D00521C  00000000   NOP
290:                                 if (error) return 0;
291:                             }else{
292:                                 *cptr++=IFCALL;
9D00522C  A1220000   SB V0, 0(T1)
293:                                 *cptr++=(int)system_dict[i].cfa;
9D005230  000318C0   SLL V1, V1, 3
9D005234  3C02A000   LUI V0, -24576
9D005238  24424A8C   ADDIU V0, V0, 19084
9D00523C  00431821   ADDU V1, V0, V1
9D005240  8C620004   LW V0, 4(V1)
9D005244  A1220001   SB V0, 1(T1)
294:                                 *cptr++=(int)system_dict[i].cfa>>8;
9D005248  8C620004   LW V0, 4(V1)
9D00524C  00021203   SRA V0, V0, 8
9D005250  A1220002   SB V0, 2(T1)
295:                                 if (state) here=cptr;else cip=cptr;
9D005254  8382802E   LB V0, -32722(GP)
9D005258  10400004   BEQ V0, ZERO, 0x9D00526C
9D00525C  25290003   ADDIU T1, T1, 3
9D005260  AF89CBC8   SW T1, -13368(GP)
9D00526C  AF898068   SW T1, -32664(GP)
296:                             }
297:                             return 1;
9D005264  0B4014A1   J 0x9D005284
9D005268  24020001   ADDIU V0, ZERO, 1
9D005270  0B4014A1   J 0x9D005284
9D005274  24020001   ADDIU V0, ZERO, 1
298:                         }
299:                     }
300:                     return 0;
9D005280  00001021   ADDU V0, ZERO, ZERO
301:                 }// try_system()
9D005284  8FBF0014   LW RA, 20(SP)
9D005288  03E00008   JR RA
9D00528C  27BD0018   ADDIU SP, SP, 24
302:                 
303:                 
304:                 int try_token(name_hash nh){ // recherche le mot dans VM_TOKENS
9D0056E4  27BDFFE8   ADDIU SP, SP, -24
305:                     int i;
306:                     for (i=TOK_COUNT-1;i>-1;i--){
9D005700  24020046   ADDIU V0, ZERO, 70
9D005704  2406FFFF   ADDIU A2, ZERO, -1
9D00571C  24020047   ADDIU V0, ZERO, 71
9D005730  1446FFF5   BNE V0, A2, 0x9D005708
9D005734  2463FFFC   ADDIU V1, V1, -4
307:                         if (nh==vm_tokens[i]){
9D0056E8  3C0233AA   LUI V0, 13226
9D0056EC  24420693   ADDIU V0, V0, 1683
9D0056F0  1082000A   BEQ A0, V0, 0x9D00571C
9D0056F4  AFBF0014   SW RA, 20(SP)
9D0056F8  3C039D01   LUI V1, -25343
9D0056FC  24639560   ADDIU V1, V1, -27296
9D005708  8C650000   LW A1, 0(V1)
9D00570C  54A40008   BNEL A1, A0, 0x9D005730
9D005710  2442FFFF   ADDIU V0, V0, -1
9D005714  0B4015C8   J 0x9D005720
9D005718  00000000   NOP
308:                             return compile_token(i);
9D005720  0F40152B   JAL compile_token
9D005724  00402021   ADDU A0, V0, ZERO
9D005728  0B4015D0   J 0x9D005740
9D00572C  8FBF0014   LW RA, 20(SP)
309:                         }
310:                     }
311:                     return 0;
9D005738  00001021   ADDU V0, ZERO, ZERO
312:                 }//try_token()
9D00573C  8FBF0014   LW RA, 20(SP)
9D005740  03E00008   JR RA
9D005744  27BD0018   ADDIU SP, SP, 24
313:                 
314:                 
315:                 int parse_int(int *n){
9D005290  27BDFFE0   ADDIU SP, SP, -32
9D005294  AFBF001C   SW RA, 28(SP)
9D005298  AFB10018   SW S1, 24(SP)
9D00529C  AFB00014   SW S0, 20(SP)
9D005308  3C06A000   LUI A2, -24576
9D00530C  24C624BC   ADDIU A2, A2, 9404
9D005320  00C22021   ADDU A0, A2, V0
316:                     int i,base,sign;
317:                     upper();
9D0052A0  0F40134C   JAL upper
9D0052A4  00808021   ADDU S0, A0, ZERO
318:                     *n=0;
9D0052A8  AE000000   SW ZERO, 0(S0)
319:                     base=10;
9D0052EC  0B4014BE   J 0x9D0052F8
9D0052F0  2405000A   ADDIU A1, ZERO, 10
9D0052F4  2405000A   ADDIU A1, ZERO, 10
320:                     sign=1;
9D0052D0  24110001   ADDIU S1, ZERO, 1
321:                     i=first;
9D0052AC  83828070   LB V0, -32656(GP)
322:                     if (tib[i]=='$'){base=16;i++;} else if (tib[i]=='-'){ sign=-1;i++;}
9D0052B0  3C03A000   LUI V1, -24576
9D0052B4  246324BC   ADDIU V1, V1, 9404
9D0052B8  00431821   ADDU V1, V0, V1
9D0052BC  80630000   LB V1, 0(V1)
9D0052C0  24040024   ADDIU A0, ZERO, 36
9D0052C4  14640005   BNE V1, A0, 0x9D0052DC
9D0052C8  2404002D   ADDIU A0, ZERO, 45
9D0052CC  24420001   ADDIU V0, V0, 1
9D0052D4  0B4014BE   J 0x9D0052F8
9D0052D8  24050010   ADDIU A1, ZERO, 16
9D0052DC  54640005   BNEL V1, A0, 0x9D0052F4
9D0052E0  24110001   ADDIU S1, ZERO, 1
9D0052E4  24420001   ADDIU V0, V0, 1
9D0052E8  2411FFFF   ADDIU S1, ZERO, -1
323:                     for (;i<=last;i++){
9D0052F8  8383805C   LB V1, -32676(GP)
9D0052FC  0062182A   SLT V1, V1, V0
9D005300  54600028   BNEL V1, ZERO, 0x9D0053A4
9D005304  8E020000   LW V0, 0(S0)
9D00538C  24420001   ADDIU V0, V0, 1
9D005390  8383805C   LB V1, -32676(GP)
9D005394  0062182A   SLT V1, V1, V0
9D005398  5060FFDF   BEQL V1, ZERO, 0x9D005318
9D00539C  8E030000   LW V1, 0(S0)
324:                         *n = *n*base;
9D005314  8E030000   LW V1, 0(S0)
9D005318  70A34002   MUL T0, A1, V1
9D00531C  AE080000   SW T0, 0(S0)
325:                         if (tib[i]>='0' && tib[i]<='9') *n += tib[i]-'0';
9D005324  80830000   LB V1, 0(A0)
9D005328  2464FFD0   ADDIU A0, V1, -48
9D00532C  308400FF   ANDI A0, A0, 255
9D005330  2C84000A   SLTIU A0, A0, 10
9D005334  10800004   BEQ A0, ZERO, 0x9D005348
9D005338  2464FFD0   ADDIU A0, V1, -48
9D00533C  00881821   ADDU V1, A0, T0
9D005340  0B4014E3   J 0x9D00538C
9D005344  AE030000   SW V1, 0(S0)
326:                         else if (base==16 && tib[i]>='A' && tib[i]<='F') *n += tib[i]-'A'+10;
9D005310  24070010   ADDIU A3, ZERO, 16
9D005348  14A70008   BNE A1, A3, 0x9D00536C
9D00534C  28640041   SLTI A0, V1, 65
9D005350  14800006   BNE A0, ZERO, 0x9D00536C
9D005354  28640047   SLTI A0, V1, 71
9D005358  10800004   BEQ A0, ZERO, 0x9D00536C
9D00535C  2464FFC9   ADDIU A0, V1, -55
9D005360  00881821   ADDU V1, A0, T0
9D005364  0B4014E3   J 0x9D00538C
9D005368  AE030000   SW V1, 0(S0)
327:                         else{
328:                             error=1;
9D00536C  24020001   ADDIU V0, ZERO, 1
9D005370  A382802F   SB V0, -32721(GP)
329:                             print(comm_channel,"erreur lecture entier.\r");
9D005374  83848034   LB A0, -32716(GP)
9D005378  3C059D01   LUI A1, -25343
9D00537C  0F401D9C   JAL print
9D005380  24A593DC   ADDIU A1, A1, -27684
330:                             break;
9D005384  0B4014E9   J 0x9D0053A4
9D005388  8E020000   LW V0, 0(S0)
331:                         }
332:                     }
333:                     *n = *n * sign;
9D0053A0  8E020000   LW V0, 0(S0)
9D0053A4  70518802   MUL S1, V0, S1
9D0053A8  AE110000   SW S1, 0(S0)
334:                     return !error;
9D0053AC  8382802F   LB V0, -32721(GP)
335:                 }//parse_int()
9D0053B0  2C420001   SLTIU V0, V0, 1
9D0053B4  8FBF001C   LW RA, 28(SP)
9D0053B8  8FB10018   LW S1, 24(SP)
9D0053BC  8FB00014   LW S0, 20(SP)
9D0053C0  03E00008   JR RA
9D0053C4  27BD0020   ADDIU SP, SP, 32
336:                 
337:                 
338:                 int try_integer(){
9D0053C8  27BDFFE0   ADDIU SP, SP, -32
9D0053CC  AFBF001C   SW RA, 28(SP)
9D0053D0  AFB00018   SW S0, 24(SP)
339:                     int n;
340:                 
341:                     code_ptr cptr;
342:                     if (state) cptr=here;else cptr=cip;
9D0053D4  8382802E   LB V0, -32722(GP)
9D0053D8  50400002   BEQL V0, ZERO, 0x9D0053E4
9D0053DC  8F908068   LW S0, -32664(GP)
9D0053E0  8F90CBC8   LW S0, -13368(GP)
343:                     if (parse_int(&n)){
9D0053E4  0F4014A4   JAL parse_int
9D0053E8  27A40010   ADDIU A0, SP, 16
9D0053EC  10400029   BEQ V0, ZERO, 0x9D005494
9D0053F0  8FA20010   LW V0, 16(SP)
344:                         if (abs(n)<256){
9D0053F4  244300FF   ADDIU V1, V0, 255
9D0053F8  2C6301FF   SLTIU V1, V1, 511
9D0053FC  10600007   BEQ V1, ZERO, 0x9D00541C
9D005400  3403FFFF   ORI V1, ZERO, -1
345:                             *cptr++=ICLIT;
9D005404  24020027   ADDIU V0, ZERO, 39
9D005408  A2020000   SB V0, 0(S0)
346:                             *cptr++=n;
9D00540C  8FA20010   LW V0, 16(SP)
9D005410  A2020001   SB V0, 1(S0)
9D005414  0B401521   J 0x9D005484
9D005418  26100002   ADDIU S0, S0, 2
347:                         }else if (abs(n)<65536){
9D00541C  00431021   ADDU V0, V0, V1
9D005420  3C030001   LUI V1, 1
9D005424  3463FFFF   ORI V1, V1, -1
9D005428  0043102B   SLTU V0, V0, V1
9D00542C  1040000A   BEQ V0, ZERO, 0x9D005458
9D005430  24020003   ADDIU V0, ZERO, 3
348:                             *cptr++=IWLIT;
9D005434  24020028   ADDIU V0, ZERO, 40
9D005438  A2020000   SB V0, 0(S0)
349:                             *cptr++=n;
9D00543C  8FA20010   LW V0, 16(SP)
9D005440  A2020001   SB V0, 1(S0)
350:                             *cptr++=n>>8;
9D005444  8FA20010   LW V0, 16(SP)
9D005448  00021203   SRA V0, V0, 8
9D00544C  A2020002   SB V0, 2(S0)
9D005450  0B401521   J 0x9D005484
9D005454  26100003   ADDIU S0, S0, 3
351:                         }else{
352:                             *cptr++=ILIT;
9D005458  A2020000   SB V0, 0(S0)
353:                             *cptr++=n;
9D00545C  8FA20010   LW V0, 16(SP)
9D005460  A2020001   SB V0, 1(S0)
354:                             *cptr++=n>>8;
9D005464  8FA20010   LW V0, 16(SP)
9D005468  00021203   SRA V0, V0, 8
9D00546C  A2020002   SB V0, 2(S0)
355:                             *cptr++=n>>16;
9D005470  87A20012   LH V0, 18(SP)
9D005474  A2020003   SB V0, 3(S0)
356:                             *cptr++=n>>24;
9D005478  83A20013   LB V0, 19(SP)
9D00547C  A2020004   SB V0, 4(S0)
9D005480  26100005   ADDIU S0, S0, 5
357:                         }
358:                        if (state)here=cptr;else cip=cptr;
9D005484  8382802E   LB V0, -32722(GP)
9D005488  50400002   BEQL V0, ZERO, 0x9D005494
9D00548C  AF908068   SW S0, -32664(GP)
9D005490  AF90CBC8   SW S0, -13368(GP)
359:                     }
360:                     return !error;
9D005494  8382802F   LB V0, -32721(GP)
361:                 }// try_integer()
9D005498  2C420001   SLTIU V0, V0, 1
9D00549C  8FBF001C   LW RA, 28(SP)
9D0054A0  8FB00018   LW S0, 24(SP)
9D0054A4  03E00008   JR RA
9D0054A8  27BD0020   ADDIU SP, SP, 32
362:                 
363:                 void column(){ // ':' doit être le premier mot dans tib
9D00506C  27BDFFE8   ADDIU SP, SP, -24
9D005070  AFBF0014   SW RA, 20(SP)
364:                     name_hash nh;
365:                 
366:                     if (state || first>0){error=1;return;}
9D005074  8382802E   LB V0, -32722(GP)
9D005078  14400003   BNE V0, ZERO, 0x9D005088
9D00507C  83828070   LB V0, -32656(GP)
9D005080  18400004   BLEZ V0, 0x9D005094
9D005084  00000000   NOP
9D005088  24020001   ADDIU V0, ZERO, 1
9D00508C  0B401434   J 0x9D0050D0
9D005090  A382802F   SB V0, -32721(GP)
367:                     word(SPC);
9D005094  0F401362   JAL word
9D005098  24040020   ADDIU A0, ZERO, 32
368:                     nh=hash();
9D00509C  0F4012FD   JAL hash
9D0050A0  00000000   NOP
369:                     state=1;
9D0050A4  24030001   ADDIU V1, ZERO, 1
9D0050A8  A383802E   SB V1, -32722(GP)
370:                     mark=here;
9D0050AC  8F84CBC8   LW A0, -13368(GP)
9D0050B0  AF84806C   SW A0, -32660(GP)
371:                     user_dict[free_slot].name=nh;
9D0050B4  83858030   LB A1, -32720(GP)
9D0050B8  000528C0   SLL A1, A1, 3
9D0050BC  3C03A000   LUI V1, -24576
9D0050C0  2463250C   ADDIU V1, V1, 9484
9D0050C4  00A31821   ADDU V1, A1, V1
9D0050C8  AC620000   SW V0, 0(V1)
372:                     user_dict[free_slot].cfa=here;
9D0050CC  AC640004   SW A0, 4(V1)
373:                 }//column()
9D0050D0  8FBF0014   LW RA, 20(SP)
9D0050D4  03E00008   JR RA
9D0050D8  27BD0018   ADDIU SP, SP, 24
374:                 
375:                 void semi_column(){// ';' doit-être le dernier mot dans tib
376:                     if (!state){error=1;return;}
9D0046CC  8382802E   LB V0, -32722(GP)
9D0046D0  14400004   BNE V0, ZERO, 0x9D0046E4
9D0046D4  8F82CBC8   LW V0, -13368(GP)
9D0046D8  24020001   ADDIU V0, ZERO, 1
9D0046DC  03E00008   JR RA
9D0046E0  A382802F   SB V0, -32721(GP)
377:                     *here++=IRET;
9D0046E4  24030005   ADDIU V1, ZERO, 5
9D0046E8  A0430000   SB V1, 0(V0)
9D0046EC  24430001   ADDIU V1, V0, 1
9D0046F0  AF83CBC8   SW V1, -13368(GP)
378:                     cip=here+256;
9D0046F4  24420101   ADDIU V0, V0, 257
9D0046F8  AF828068   SW V0, -32664(GP)
379:                     state=IMMEDIATE;
9D0046FC  A380802E   SB ZERO, -32722(GP)
380:                     free_slot++;
9D004700  93828030   LBU V0, -32720(GP)
9D004704  24420001   ADDIU V0, V0, 1
9D004708  03E00008   JR RA
9D00470C  A3828030   SB V0, -32720(GP)
381:                 }//semi_column()
382:                 
383:                 void compile_var(){ // var, ne doit pas être utilisé à l'intérieur d'une définition
9D004FB4  27BDFFE8   ADDIU SP, SP, -24
9D004FB8  AFBF0014   SW RA, 20(SP)
384:                     name_hash nh;
385:                     code_ptr cfa,var;
386:                     if (state) {error=1;return;}
9D004FBC  8382802E   LB V0, -32722(GP)
9D004FC0  10400003   BEQ V0, ZERO, 0x9D004FD0
9D004FC4  24020001   ADDIU V0, ZERO, 1
9D004FC8  0B401418   J 0x9D005060
9D004FCC  A382802F   SB V0, -32721(GP)
387:                     state=COMPILE;
9D004FD0  A382802E   SB V0, -32722(GP)
388:                     word(SPC);
9D004FD4  0F401362   JAL word
9D004FD8  24040020   ADDIU A0, ZERO, 32
389:                     if (last<first){error=1;return;}
9D004FDC  8383805C   LB V1, -32676(GP)
9D004FE0  83828070   LB V0, -32656(GP)
9D004FE4  0062102A   SLT V0, V1, V0
9D004FE8  10400003   BEQ V0, ZERO, 0x9D004FF8
9D004FEC  24020001   ADDIU V0, ZERO, 1
9D004FF0  0B401418   J 0x9D005060
9D004FF4  A382802F   SB V0, -32721(GP)
390:                     nh=hash();
9D004FF8  0F4012FD   JAL hash
9D004FFC  00000000   NOP
391:                     cfa=here;
9D005000  8F83CBC8   LW V1, -13368(GP)
392:                     var = cfa+6;
9D00500C  24640006   ADDIU A0, V1, 6
393:                     *here++=ILIT;
9D005004  24040003   ADDIU A0, ZERO, 3
9D005008  A0640000   SB A0, 0(V1)
394:                     *here++=(int)var;
9D005010  A0640001   SB A0, 1(V1)
395:                     *here++=(int)var>>8;
9D005014  00042A03   SRA A1, A0, 8
9D005018  A0650002   SB A1, 2(V1)
396:                     *here++=(int)var>>16;
9D00501C  00042C03   SRA A1, A0, 16
9D005020  A0650003   SB A1, 3(V1)
397:                     *here++=(int)var>>24;
9D005024  00042603   SRA A0, A0, 24
9D005028  A0640004   SB A0, 4(V1)
398:                     *here++=IRET;
9D00502C  24040005   ADDIU A0, ZERO, 5
9D005030  A0640005   SB A0, 5(V1)
399:                     here +=CELL_SIZE;
9D005034  2464000A   ADDIU A0, V1, 10
9D005038  AF84CBC8   SW A0, -13368(GP)
400:                     user_dict[free_slot].name=nh;
9D00503C  83848030   LB A0, -32720(GP)
9D005040  000430C0   SLL A2, A0, 3
9D005044  3C05A000   LUI A1, -24576
9D005048  24A5250C   ADDIU A1, A1, 9484
9D00504C  00C52821   ADDU A1, A2, A1
9D005050  ACA20000   SW V0, 0(A1)
401:                     user_dict[free_slot].cfa=cfa;
9D005054  ACA30004   SW V1, 4(A1)
402:                     free_slot++;
9D005058  24840001   ADDIU A0, A0, 1
9D00505C  A3848030   SB A0, -32720(GP)
403:                 }// compile_var()
9D005060  8FBF0014   LW RA, 20(SP)
9D005064  03E00008   JR RA
9D005068  27BD0018   ADDIU SP, SP, 24
404:                 
405:                 void compile_const(){ // const, ne doit pas être utilisé à l'intérieur d'une définition
9D004E6C  27BDFFE8   ADDIU SP, SP, -24
9D004E70  AFBF0014   SW RA, 20(SP)
406:                     name_hash nh;
407:                     code_ptr cfa;
408:                     int n;
409:                     if (state) {error=1;return;}
9D004E74  8382802E   LB V0, -32722(GP)
9D004E78  10400003   BEQ V0, ZERO, 0x9D004E88
9D004E7C  24020001   ADDIU V0, ZERO, 1
9D004E80  0B4013EA   J 0x9D004FA8
9D004E84  A382802F   SB V0, -32721(GP)
410:                     state=COMPILE;
9D004E88  A382802E   SB V0, -32722(GP)
411:                     word(SPC);
9D004E8C  0F401362   JAL word
9D004E90  24040020   ADDIU A0, ZERO, 32
412:                     if (last<first){error=1;return;}
9D004E94  8383805C   LB V1, -32676(GP)
9D004E98  83828070   LB V0, -32656(GP)
9D004E9C  0062102A   SLT V0, V1, V0
9D004EA0  10400003   BEQ V0, ZERO, 0x9D004EB0
9D004EA4  24020001   ADDIU V0, ZERO, 1
9D004EA8  0B4013EA   J 0x9D004FA8
9D004EAC  A382802F   SB V0, -32721(GP)
413:                     nh=hash();
9D004EB0  0F4012FD   JAL hash
9D004EB4  00000000   NOP
414:                     cfa=here;
9D004EB8  8F83CBC8   LW V1, -13368(GP)
415:                     cip=here+256;
9D004EBC  24640100   ADDIU A0, V1, 256
9D004EC0  AF848068   SW A0, -32664(GP)
416:                     *here++=*cip++;
9D004EC4  90640100   LBU A0, 256(V1)
9D004EC8  A0640000   SB A0, 0(V1)
9D004ECC  24640001   ADDIU A0, V1, 1
9D004ED0  AF84CBC8   SW A0, -13368(GP)
9D004ED4  24640101   ADDIU A0, V1, 257
9D004ED8  AF848068   SW A0, -32664(GP)
417:                     *here++=*cip++;
9D004EDC  90640101   LBU A0, 257(V1)
9D004EE0  A0640001   SB A0, 1(V1)
9D004EE4  24650002   ADDIU A1, V1, 2
9D004EE8  AF85CBC8   SW A1, -13368(GP)
9D004EEC  24640102   ADDIU A0, V1, 258
9D004EF0  AF848068   SW A0, -32664(GP)
418:                     if (*(cip-2)==IWLIT){
9D004EF4  8087FFFE   LB A3, -2(A0)
9D004EF8  24060028   ADDIU A2, ZERO, 40
9D004EFC  54E60008   BNEL A3, A2, 0x9D004F20
9D004F00  80670102   LB A3, 258(V1)
419:                         *here++=*cip++;
9D004F04  90660102   LBU A2, 258(V1)
9D004F08  A0660002   SB A2, 2(V1)
9D004F0C  24A50001   ADDIU A1, A1, 1
9D004F10  AF85CBC8   SW A1, -13368(GP)
9D004F14  24840001   ADDIU A0, A0, 1
9D004F18  0B4013DC   J 0x9D004F70
9D004F1C  AF848068   SW A0, -32664(GP)
420:                     }else if (*cip-2==ILIT){
9D004F20  24060005   ADDIU A2, ZERO, 5
9D004F24  54E60013   BNEL A3, A2, 0x9D004F74
9D004F28  8F84CBC8   LW A0, -13368(GP)
421:                         *here++=*cip++;
9D004F2C  A0660002   SB A2, 2(V1)
9D004F30  24A60001   ADDIU A2, A1, 1
9D004F34  AF86CBC8   SW A2, -13368(GP)
9D004F38  24860001   ADDIU A2, A0, 1
9D004F3C  AF868068   SW A2, -32664(GP)
422:                         *here++=*cip++;
9D004F40  90860001   LBU A2, 1(A0)
9D004F44  A0A60001   SB A2, 1(A1)
9D004F48  24A60002   ADDIU A2, A1, 2
9D004F4C  AF86CBC8   SW A2, -13368(GP)
9D004F50  24860002   ADDIU A2, A0, 2
9D004F54  AF868068   SW A2, -32664(GP)
423:                         *here++=*cip++;
9D004F58  90860002   LBU A2, 2(A0)
9D004F5C  A0A60002   SB A2, 2(A1)
9D004F60  24A50003   ADDIU A1, A1, 3
9D004F64  AF85CBC8   SW A1, -13368(GP)
9D004F68  24840003   ADDIU A0, A0, 3
9D004F6C  AF848068   SW A0, -32664(GP)
424:                     }
425:                     *here++=IRET;
9D004F70  8F84CBC8   LW A0, -13368(GP)
9D004F74  24050005   ADDIU A1, ZERO, 5
9D004F78  A0850000   SB A1, 0(A0)
9D004F7C  24840001   ADDIU A0, A0, 1
9D004F80  AF84CBC8   SW A0, -13368(GP)
426:                     user_dict[free_slot].name=nh;
9D004F84  83848030   LB A0, -32720(GP)
9D004F88  000430C0   SLL A2, A0, 3
9D004F8C  3C05A000   LUI A1, -24576
9D004F90  24A5250C   ADDIU A1, A1, 9484
9D004F94  00C52821   ADDU A1, A2, A1
9D004F98  ACA20000   SW V0, 0(A1)
427:                     user_dict[free_slot].cfa=cfa;
9D004F9C  ACA30004   SW V1, 4(A1)
428:                     free_slot++;
9D004FA0  24840001   ADDIU A0, A0, 1
9D004FA4  A3848030   SB A0, -32720(GP)
429:                 }// compile_const()
9D004FA8  8FBF0014   LW RA, 20(SP)
9D004FAC  03E00008   JR RA
9D004FB0  27BD0018   ADDIU SP, SP, 24
430:                 
431:                 void compile_if(){ //if
432:                     code_ptr cptr;
433:                     if (state) cptr=here;else cptr=cip;
9D004710  8382802E   LB V0, -32722(GP)
9D004714  50400002   BEQL V0, ZERO, 0x9D004720
9D004718  8F828068   LW V0, -32664(GP)
9D00471C  8F82CBC8   LW V0, -13368(GP)
434:                     *cptr++=IQBRAZ;
9D004720  2403003B   ADDIU V1, ZERO, 59
9D004724  A0430000   SB V1, 0(V0)
9D004728  24440001   ADDIU A0, V0, 1
435:                     cstack[++cp]=(int)cptr;
9D00472C  93838011   LBU V1, -32751(GP)
9D004730  24630001   ADDIU V1, V1, 1
9D004734  7C031C20   SEB V1, V1
9D004738  A3838011   SB V1, -32751(GP)
9D00473C  00031880   SLL V1, V1, 2
9D004740  3C05A000   LUI A1, -24576
9D004744  24A5282C   ADDIU A1, A1, 10284
9D004748  00651821   ADDU V1, V1, A1
9D00474C  AC640000   SW A0, 0(V1)
436:                     cptr++; // saute  addresse de ?braz
437:                     if (state)here=cptr;else cip=cptr;
9D004750  8383802E   LB V1, -32722(GP)
9D004754  10600003   BEQ V1, ZERO, 0x9D004764
9D004758  24420002   ADDIU V0, V0, 2
9D00475C  03E00008   JR RA
9D004760  AF82CBC8   SW V0, -13368(GP)
9D004764  03E00008   JR RA
9D004768  AF828068   SW V0, -32664(GP)
438:                 }// compile_if()
439:                 
440:                 void compile_then(){ //then
441:                     char *there;
442:                     code_ptr cptr;
443:                     if (state) cptr=here;else cptr=cip;
9D00476C  8382802E   LB V0, -32722(GP)
9D004770  50400002   BEQL V0, ZERO, 0x9D00477C
9D004774  8F828068   LW V0, -32664(GP)
9D004778  8F82CBC8   LW V0, -13368(GP)
444:                     there=(char *)cstack[cp--];
9D00477C  83848011   LB A0, -32751(GP)
9D004780  00042880   SLL A1, A0, 2
9D004784  3C03A000   LUI V1, -24576
9D004788  2463282C   ADDIU V1, V1, 10284
9D00478C  00A31821   ADDU V1, A1, V1
9D004790  8C630000   LW V1, 0(V1)
9D004794  2484FFFF   ADDIU A0, A0, -1
9D004798  A3848011   SB A0, -32751(GP)
445:                     *there=cptr-there-1;
9D00479C  00032027   NOR A0, ZERO, V1
9D0047A0  00822021   ADDU A0, A0, V0
9D0047A4  A0640000   SB A0, 0(V1)
446:                     if (state)here=cptr;else cip=cptr;
9D0047A8  8383802E   LB V1, -32722(GP)
9D0047AC  50600003   BEQL V1, ZERO, 0x9D0047BC
9D0047B0  AF828068   SW V0, -32664(GP)
9D0047B4  03E00008   JR RA
9D0047B8  AF82CBC8   SW V0, -13368(GP)
9D0047BC  03E00008   JR RA
9D0047C0  00000000   NOP
447:                 }// compile_then()
448:                 
449:                 void compile_else(){ //else
450:                     char *there;
451:                     code_ptr cptr;
452:                     if (state) cptr=here;else cptr=cip;
9D0047C4  8382802E   LB V0, -32722(GP)
9D0047C8  50400002   BEQL V0, ZERO, 0x9D0047D4
9D0047CC  8F828068   LW V0, -32664(GP)
9D0047D0  8F82CBC8   LW V0, -13368(GP)
453:                     there=(char*)cstack[cp];
9D0047D4  83848011   LB A0, -32751(GP)
9D0047D8  00042080   SLL A0, A0, 2
9D0047DC  3C03A000   LUI V1, -24576
9D0047E0  2463282C   ADDIU V1, V1, 10284
9D0047E4  00832021   ADDU A0, A0, V1
9D0047E8  8C840000   LW A0, 0(A0)
454:                     *there=cptr-there+1;
9D0047EC  00442823   SUBU A1, V0, A0
9D0047F0  24A50001   ADDIU A1, A1, 1
9D0047F4  A0850000   SB A1, 0(A0)
455:                     *cptr++=IBRA;
9D0047F8  24040006   ADDIU A0, ZERO, 6
9D0047FC  A0440000   SB A0, 0(V0)
9D004800  24440001   ADDIU A0, V0, 1
456:                     cstack[cp]=(int)cptr;
9D004804  83858011   LB A1, -32751(GP)
9D004808  00052880   SLL A1, A1, 2
9D00480C  00A31821   ADDU V1, A1, V1
9D004810  AC640000   SW A0, 0(V1)
457:                     cptr++;
458:                     if (state)here=cptr;else cip=cptr;
9D004814  8383802E   LB V1, -32722(GP)
9D004818  10600003   BEQ V1, ZERO, 0x9D004828
9D00481C  24420002   ADDIU V0, V0, 2
9D004820  03E00008   JR RA
9D004824  AF82CBC8   SW V0, -13368(GP)
9D004828  03E00008   JR RA
9D00482C  AF828068   SW V0, -32664(GP)
459:                 }//compile_else(){
460:                 
461:                 void compile_do(){ // 'do'
462:                     code_ptr cptr;
463:                     if (state)cptr=here;else cptr=cip;
9D004830  8382802E   LB V0, -32722(GP)
9D004834  50400002   BEQL V0, ZERO, 0x9D004840
9D004838  8F828068   LW V0, -32664(GP)
9D00483C  8F82CBC8   LW V0, -13368(GP)
464:                     *cptr++=ITOR;
9D004840  24030010   ADDIU V1, ZERO, 16
9D004844  A0430000   SB V1, 0(V0)
465:                     *cptr++=ITOR;
9D004848  A0430001   SB V1, 1(V0)
9D00484C  24420002   ADDIU V0, V0, 2
466:                     cstack[++cp]=(int)cptr;
9D004850  93838011   LBU V1, -32751(GP)
9D004854  24630001   ADDIU V1, V1, 1
9D004858  7C031C20   SEB V1, V1
9D00485C  A3838011   SB V1, -32751(GP)
9D004860  00031880   SLL V1, V1, 2
9D004864  3C04A000   LUI A0, -24576
9D004868  2484282C   ADDIU A0, A0, 10284
9D00486C  00641821   ADDU V1, V1, A0
9D004870  AC620000   SW V0, 0(V1)
467:                     if (state) here=cptr; else cip=cptr;
9D004874  8383802E   LB V1, -32722(GP)
9D004878  50600003   BEQL V1, ZERO, 0x9D004888
9D00487C  AF828068   SW V0, -32664(GP)
9D004880  03E00008   JR RA
9D004884  AF82CBC8   SW V0, -13368(GP)
9D004888  03E00008   JR RA
9D00488C  00000000   NOP
468:                 }//compile_do()
469:                 
470:                 void compile_loop(){ //loop
471:                     code_ptr there, cptr;
472:                 
473:                     if (state) cptr=here;else cptr=cip;
9D004890  8382802E   LB V0, -32722(GP)
9D004894  50400002   BEQL V0, ZERO, 0x9D0048A0
9D004898  8F828068   LW V0, -32664(GP)
9D00489C  8F82CBC8   LW V0, -13368(GP)
474:                     there=(code_ptr)cstack[cp--];
9D0048A0  83838011   LB V1, -32751(GP)
9D0048A4  00032880   SLL A1, V1, 2
9D0048A8  3C04A000   LUI A0, -24576
9D0048AC  2484282C   ADDIU A0, A0, 10284
9D0048B0  00A42021   ADDU A0, A1, A0
9D0048B4  8C840000   LW A0, 0(A0)
9D0048B8  2463FFFF   ADDIU V1, V1, -1
9D0048BC  A3838011   SB V1, -32751(GP)
475:                     *cptr++=IRFROM;
9D0048C0  24030011   ADDIU V1, ZERO, 17
9D0048C4  A0430000   SB V1, 0(V0)
476:                     *cptr++=IPLUS1;
9D0048C8  2405002F   ADDIU A1, ZERO, 47
9D0048CC  A0450001   SB A1, 1(V0)
477:                     *cptr++=IDUP;
9D0048D0  24050015   ADDIU A1, ZERO, 21
9D0048D4  A0450002   SB A1, 2(V0)
478:                     *cptr++=IRFETCH;
9D0048D8  2405000F   ADDIU A1, ZERO, 15
9D0048DC  A0450003   SB A1, 3(V0)
479:                     *cptr++=ISWAP;
9D0048E0  24050016   ADDIU A1, ZERO, 22
9D0048E4  A0450004   SB A1, 4(V0)
480:                     *cptr++=ITOR;
9D0048E8  24050010   ADDIU A1, ZERO, 16
9D0048EC  A0450005   SB A1, 5(V0)
481:                     *cptr++=ISUB;
9D0048F0  24050019   ADDIU A1, ZERO, 25
9D0048F4  A0450006   SB A1, 6(V0)
482:                     *cptr++=IQBRA;
9D0048F8  24050007   ADDIU A1, ZERO, 7
9D0048FC  A0450007   SB A1, 7(V0)
9D004900  24450008   ADDIU A1, V0, 8
483:                     *cptr++=there-cptr-1;
9D004904  2484FFFF   ADDIU A0, A0, -1
9D004908  00852023   SUBU A0, A0, A1
9D00490C  A0440008   SB A0, 8(V0)
484:                     *cptr++=IRFROM;
9D004910  A0430009   SB V1, 9(V0)
485:                     *cptr++=IRFROM;
9D004914  A043000A   SB V1, 10(V0)
486:                     *cptr++=IDDROP;
9D004918  24030032   ADDIU V1, ZERO, 50
9D00491C  A043000B   SB V1, 11(V0)
487:                     if (state) here=cptr;else cip=cptr;
9D004920  8383802E   LB V1, -32722(GP)
9D004924  10600003   BEQ V1, ZERO, 0x9D004934
9D004928  2442000C   ADDIU V0, V0, 12
9D00492C  03E00008   JR RA
9D004930  AF82CBC8   SW V0, -13368(GP)
9D004934  03E00008   JR RA
9D004938  AF828068   SW V0, -32664(GP)
488:                 }//compile_loop()
489:                 
490:                 
491:                 void compile_ploop(){//+loop
492:                     code_ptr there, cptr;
493:                 
494:                     if (state) cptr=here;else cptr=cip;
9D00493C  8382802E   LB V0, -32722(GP)
9D004940  50400002   BEQL V0, ZERO, 0x9D00494C
9D004944  8F828068   LW V0, -32664(GP)
9D004948  8F82CBC8   LW V0, -13368(GP)
495:                     there=(code_ptr)cstack[cp--];
9D00494C  83838011   LB V1, -32751(GP)
9D004950  00032880   SLL A1, V1, 2
9D004954  3C04A000   LUI A0, -24576
9D004958  2484282C   ADDIU A0, A0, 10284
9D00495C  00A42021   ADDU A0, A1, A0
9D004960  8C840000   LW A0, 0(A0)
9D004964  2463FFFF   ADDIU V1, V1, -1
9D004968  A3838011   SB V1, -32751(GP)
496:                     *cptr++=IRFROM;
9D00496C  24030011   ADDIU V1, ZERO, 17
9D004970  A0430000   SB V1, 0(V0)
497:                     *cptr++=IADD;
9D004974  24050018   ADDIU A1, ZERO, 24
9D004978  A0450001   SB A1, 1(V0)
498:                     *cptr++=IDUP;
9D00497C  24050015   ADDIU A1, ZERO, 21
9D004980  A0450002   SB A1, 2(V0)
499:                     *cptr++=IRFETCH;
9D004984  2405000F   ADDIU A1, ZERO, 15
9D004988  A0450003   SB A1, 3(V0)
500:                     *cptr++=ISWAP;
9D00498C  24050016   ADDIU A1, ZERO, 22
9D004990  A0450004   SB A1, 4(V0)
501:                     *cptr++=ITOR;
9D004994  24050010   ADDIU A1, ZERO, 16
9D004998  A0450005   SB A1, 5(V0)
502:                     *cptr++=ISUB;
9D00499C  24050019   ADDIU A1, ZERO, 25
9D0049A0  A0450006   SB A1, 6(V0)
503:                     *cptr++=IQBRA;
9D0049A4  24050007   ADDIU A1, ZERO, 7
9D0049A8  A0450007   SB A1, 7(V0)
9D0049AC  24450008   ADDIU A1, V0, 8
504:                     *cptr++=there-cptr-1;
9D0049B0  2484FFFF   ADDIU A0, A0, -1
9D0049B4  00852023   SUBU A0, A0, A1
9D0049B8  A0440008   SB A0, 8(V0)
505:                     *cptr++=IRFROM;
9D0049BC  A0430009   SB V1, 9(V0)
506:                     *cptr++=IRFROM;
9D0049C0  A043000A   SB V1, 10(V0)
507:                     *cptr++=IDDROP;
9D0049C4  24030032   ADDIU V1, ZERO, 50
9D0049C8  A043000B   SB V1, 11(V0)
508:                     if (state) here=cptr;else cip=cptr;
9D0049CC  8383802E   LB V1, -32722(GP)
9D0049D0  10600003   BEQ V1, ZERO, 0x9D0049E0
9D0049D4  2442000C   ADDIU V0, V0, 12
9D0049D8  03E00008   JR RA
9D0049DC  AF82CBC8   SW V0, -13368(GP)
9D0049E0  03E00008   JR RA
9D0049E4  AF828068   SW V0, -32664(GP)
509:                 }//compile_ploop()
510:                 
511:                 void compile_begin(){//begin
512:                     if (state) 
9D0049E8  8382802E   LB V0, -32722(GP)
9D0049EC  1040000B   BEQ V0, ZERO, 0x9D004A1C
9D0049F0  93828011   LBU V0, -32751(GP)
513:                       cstack[++cp]=(int)here;
9D0049F4  24420001   ADDIU V0, V0, 1
9D0049F8  7C021420   SEB V0, V0
9D0049FC  A3828011   SB V0, -32751(GP)
9D004A00  00021080   SLL V0, V0, 2
9D004A04  3C03A000   LUI V1, -24576
9D004A08  2463282C   ADDIU V1, V1, 10284
9D004A0C  00431021   ADDU V0, V0, V1
9D004A10  8F83CBC8   LW V1, -13368(GP)
9D004A14  03E00008   JR RA
9D004A18  AC430000   SW V1, 0(V0)
514:                     else
515:                       cstack[++cp]=(int)cip;
9D004A1C  24420001   ADDIU V0, V0, 1
9D004A20  7C021420   SEB V0, V0
9D004A24  A3828011   SB V0, -32751(GP)
9D004A28  00021080   SLL V0, V0, 2
9D004A2C  3C03A000   LUI V1, -24576
9D004A30  2463282C   ADDIU V1, V1, 10284
9D004A34  00431021   ADDU V0, V0, V1
9D004A38  8F838068   LW V1, -32664(GP)
9D004A3C  03E00008   JR RA
9D004A40  AC430000   SW V1, 0(V0)
516:                 }//compile_begin()
517:                 
518:                 void compile_again(){//again
519:                     code_ptr there,cptr;
520:                     if (state) cptr=here;else cptr=cip;
9D004A44  8382802E   LB V0, -32722(GP)
9D004A48  50400002   BEQL V0, ZERO, 0x9D004A54
9D004A4C  8F828068   LW V0, -32664(GP)
9D004A50  8F82CBC8   LW V0, -13368(GP)
521:                     there=(code_ptr)cstack[cp--];
9D004A54  83838011   LB V1, -32751(GP)
9D004A58  00032880   SLL A1, V1, 2
9D004A5C  3C04A000   LUI A0, -24576
9D004A60  2484282C   ADDIU A0, A0, 10284
9D004A64  00A42021   ADDU A0, A1, A0
9D004A68  8C850000   LW A1, 0(A0)
9D004A6C  2463FFFF   ADDIU V1, V1, -1
9D004A70  A3838011   SB V1, -32751(GP)
522:                     *cptr++=IBRA;
9D004A74  24030006   ADDIU V1, ZERO, 6
9D004A78  A0430000   SB V1, 0(V0)
9D004A7C  24440001   ADDIU A0, V0, 1
523:                     *cptr++=there-cptr-1;
9D004A80  24A3FFFF   ADDIU V1, A1, -1
9D004A84  00641823   SUBU V1, V1, A0
9D004A88  A0430001   SB V1, 1(V0)
524:                     if (state) here=cptr;else cip=cptr;
9D004A8C  8383802E   LB V1, -32722(GP)
9D004A90  10600003   BEQ V1, ZERO, 0x9D004AA0
9D004A94  24420002   ADDIU V0, V0, 2
9D004A98  03E00008   JR RA
9D004A9C  AF82CBC8   SW V0, -13368(GP)
9D004AA0  03E00008   JR RA
9D004AA4  AF828068   SW V0, -32664(GP)
525:                 }// compile_again()
526:                 
527:                 void compile_while(){ // while
528:                     code_ptr there,cptr;
529:                     if (state) cptr=here;else cptr=cip;
9D004AA8  8382802E   LB V0, -32722(GP)
9D004AAC  50400002   BEQL V0, ZERO, 0x9D004AB8
9D004AB0  8F828068   LW V0, -32664(GP)
9D004AB4  8F82CBC8   LW V0, -13368(GP)
530:                     *cptr++=IQBRAZ;
9D004AB8  2403003B   ADDIU V1, ZERO, 59
9D004ABC  A0430000   SB V1, 0(V0)
9D004AC0  24440001   ADDIU A0, V0, 1
531:                     cstack[++cp]=(int)cptr;
9D004AC4  93838011   LBU V1, -32751(GP)
9D004AC8  24630001   ADDIU V1, V1, 1
9D004ACC  7C031C20   SEB V1, V1
9D004AD0  A3838011   SB V1, -32751(GP)
9D004AD4  00031880   SLL V1, V1, 2
9D004AD8  3C05A000   LUI A1, -24576
9D004ADC  24A5282C   ADDIU A1, A1, 10284
9D004AE0  00651821   ADDU V1, V1, A1
9D004AE4  AC640000   SW A0, 0(V1)
532:                     cptr++;
533:                     if (state) here=cptr;else cip=cptr;
9D004AE8  8383802E   LB V1, -32722(GP)
9D004AEC  10600003   BEQ V1, ZERO, 0x9D004AFC
9D004AF0  24420002   ADDIU V0, V0, 2
9D004AF4  03E00008   JR RA
9D004AF8  AF82CBC8   SW V0, -13368(GP)
9D004AFC  03E00008   JR RA
9D004B00  AF828068   SW V0, -32664(GP)
534:                 }// compile_while()
535:                 
536:                 void compile_repeat(){//rept
537:                     code_ptr there,therew,cptr;
538:                     if (state) cptr=here;else cptr=cip;
9D004B04  8382802E   LB V0, -32722(GP)
9D004B08  50400002   BEQL V0, ZERO, 0x9D004B14
9D004B0C  8F828068   LW V0, -32664(GP)
9D004B10  8F82CBC8   LW V0, -13368(GP)
539:                     therew=(code_ptr)cstack[cp--]; // while référence avant
9D004B14  83848011   LB A0, -32751(GP)
9D004B18  00042880   SLL A1, A0, 2
9D004B1C  3C03A000   LUI V1, -24576
9D004B20  2463282C   ADDIU V1, V1, 10284
9D004B24  00A32821   ADDU A1, A1, V1
9D004B28  8CA50000   LW A1, 0(A1)
9D004B2C  2484FFFF   ADDIU A0, A0, -1
9D004B30  7C042420   SEB A0, A0
540:                     there=(code_ptr)cstack[cp--]; // begin référence avant
9D004B34  00043080   SLL A2, A0, 2
9D004B38  00C31821   ADDU V1, A2, V1
9D004B3C  8C630000   LW V1, 0(V1)
9D004B40  2484FFFF   ADDIU A0, A0, -1
9D004B44  A3848011   SB A0, -32751(GP)
541:                     *cptr++=IBRA;
9D004B48  24040006   ADDIU A0, ZERO, 6
9D004B4C  A0440000   SB A0, 0(V0)
9D004B50  24440001   ADDIU A0, V0, 1
542:                     *cptr++=there-cptr-1; // saut arrière vers BEGIN
9D004B54  306300FF   ANDI V1, V1, 255
9D004B58  2466FFFF   ADDIU A2, V1, -1
9D004B5C  00C42023   SUBU A0, A2, A0
9D004B60  A0440001   SB A0, 1(V0)
9D004B64  24420002   ADDIU V0, V0, 2
543:                     *therew=cptr-there-1; // saut avant du while après rept
9D004B68  00031827   NOR V1, ZERO, V1
9D004B6C  00621821   ADDU V1, V1, V0
9D004B70  A0A30000   SB V1, 0(A1)
544:                     if (state) here=cptr;else cip=cptr;
9D004B74  8383802E   LB V1, -32722(GP)
9D004B78  50600003   BEQL V1, ZERO, 0x9D004B88
9D004B7C  AF828068   SW V0, -32664(GP)
9D004B80  03E00008   JR RA
9D004B84  AF82CBC8   SW V0, -13368(GP)
9D004B88  03E00008   JR RA
9D004B8C  00000000   NOP
545:                 }//compile_repeat()
546:                 
547:                 void compile_until(){// until
548:                     code_ptr there, cptr;
549:                     if (state) cptr=here;else cptr=cip;
9D004B90  8382802E   LB V0, -32722(GP)
9D004B94  50400002   BEQL V0, ZERO, 0x9D004BA0
9D004B98  8F828068   LW V0, -32664(GP)
9D004B9C  8F82CBC8   LW V0, -13368(GP)
550:                     there=(code_ptr)cstack[cp--];
9D004BA0  83838011   LB V1, -32751(GP)
9D004BA4  00032880   SLL A1, V1, 2
9D004BA8  3C04A000   LUI A0, -24576
9D004BAC  2484282C   ADDIU A0, A0, 10284
9D004BB0  00A42021   ADDU A0, A1, A0
9D004BB4  8C850000   LW A1, 0(A0)
9D004BB8  2463FFFF   ADDIU V1, V1, -1
9D004BBC  A3838011   SB V1, -32751(GP)
551:                     *cptr++=IQBRAZ;
9D004BC0  2403003B   ADDIU V1, ZERO, 59
9D004BC4  A0430000   SB V1, 0(V0)
9D004BC8  24440001   ADDIU A0, V0, 1
552:                     *cptr++=there-cptr-1;
9D004BCC  24A3FFFF   ADDIU V1, A1, -1
9D004BD0  00641823   SUBU V1, V1, A0
9D004BD4  A0430001   SB V1, 1(V0)
553:                     if (state) here=cptr;else cip=cptr;
9D004BD8  8383802E   LB V1, -32722(GP)
9D004BDC  10600003   BEQ V1, ZERO, 0x9D004BEC
9D004BE0  24420002   ADDIU V0, V0, 2
9D004BE4  03E00008   JR RA
9D004BE8  AF82CBC8   SW V0, -13368(GP)
9D004BEC  03E00008   JR RA
9D004BF0  AF828068   SW V0, -32664(GP)
554:                 }// compile_until()
555:                 
556:                 int compile_token(int code){
9D0054AC  27BDFFD8   ADDIU SP, SP, -40
9D0054B0  AFBF0024   SW RA, 36(SP)
9D0054B4  AFB10020   SW S1, 32(SP)
9D0054B8  AFB0001C   SW S0, 28(SP)
9D005554  3C03A000   LUI V1, -24576
9D005558  246324BC   ADDIU V1, V1, 9404
9D00555C  00621821   ADDU V1, V1, V0
557:                     int i;
558:                     code_ptr cptr;
559:                     if (state) cptr=here;else cptr=cip;
9D0054BC  8382802E   LB V0, -32722(GP)
9D0054C0  10400003   BEQ V0, ZERO, 0x9D0054D0
9D0054C4  00808021   ADDU S0, A0, ZERO
9D0054C8  0B401535   J 0x9D0054D4
9D0054CC  8F91CBC8   LW S1, -13368(GP)
9D0054D0  8F918068   LW S1, -32664(GP)
560:                     if (code==ILIT || code==ICLIT || code == IWLIT){
9D0054D4  24020003   ADDIU V0, ZERO, 3
9D0054D8  12020007   BEQ S0, V0, 0x9D0054F8
9D0054DC  00000000   NOP
9D0054E0  24020027   ADDIU V0, ZERO, 39
9D0054E4  12020004   BEQ S0, V0, 0x9D0054F8
9D0054E8  00000000   NOP
9D0054EC  24020028   ADDIU V0, ZERO, 40
9D0054F0  56020009   BNEL S0, V0, 0x9D005518
9D0054F4  24020029   ADDIU V0, ZERO, 41
561:                         word(SPC);
9D0054F8  0F401362   JAL word
9D0054FC  24040020   ADDIU A0, ZERO, 32
562:                         upper();
9D005500  0F40134C   JAL upper
9D005504  00000000   NOP
563:                         try_integer();
9D005508  0F4014F2   JAL try_integer
9D00550C  00000000   NOP
9D005510  0B4015AF   J 0x9D0056BC
9D005514  8382802E   LB V0, -32722(GP)
564:                     } else if (code==IDOTQ){
9D005518  16020047   BNE S0, V0, 0x9D005638
9D00551C  24020004   ADDIU V0, ZERO, 4
565:                         for(i=current;i<ctib && tib[i]!='"';i++);
9D005520  83888064   LB T0, -32668(GP)
9D005524  AFA80010   SW T0, 16(SP)
9D005528  83868071   LB A2, -32655(GP)
9D00552C  0106102A   SLT V0, T0, A2
9D005530  10400016   BEQ V0, ZERO, 0x9D00558C
9D005534  01002821   ADDU A1, T0, ZERO
9D005538  3C02A000   LUI V0, -24576
9D00553C  244224BC   ADDIU V0, V0, 9404
9D005540  00481021   ADDU V0, V0, T0
9D005544  80430000   LB V1, 0(V0)
9D005548  24020022   ADDIU V0, ZERO, 34
9D00554C  1062000F   BEQ V1, V0, 0x9D00558C
9D005550  25020001   ADDIU V0, T0, 1
9D005560  24070022   ADDIU A3, ZERO, 34
9D005564  0046202A   SLT A0, V0, A2
9D005568  14800003   BNE A0, ZERO, 0x9D005578
9D00556C  00402821   ADDU A1, V0, ZERO
9D005570  0B401563   J 0x9D00558C
9D005574  AFA20010   SW V0, 16(SP)
9D005578  80640000   LB A0, 0(V1)
9D00557C  24420001   ADDIU V0, V0, 1
9D005580  1487FFF8   BNE A0, A3, 0x9D005564
9D005584  24630001   ADDIU V1, V1, 1
9D005588  AFA50010   SW A1, 16(SP)
566:                         first=current;
9D00558C  A3888070   SB T0, -32656(GP)
567:                         last=i-1;
9D005590  24A2FFFF   ADDIU V0, A1, -1
9D005594  7C021420   SEB V0, V0
9D005598  A382805C   SB V0, -32676(GP)
568:                         if (tib[i]=='"') i++;
9D00559C  3C03A000   LUI V1, -24576
9D0055A0  246324BC   ADDIU V1, V1, 9404
9D0055A4  00A31821   ADDU V1, A1, V1
9D0055A8  80640000   LB A0, 0(V1)
9D0055AC  24030022   ADDIU V1, ZERO, 34
9D0055B0  14830004   BNE A0, V1, 0x9D0055C4
9D0055B4  8FA30010   LW V1, 16(SP)
9D0055B8  24A50001   ADDIU A1, A1, 1
9D0055BC  AFA50010   SW A1, 16(SP)
569:                         current=i;
9D0055C0  8FA30010   LW V1, 16(SP)
9D0055C4  A3838064   SB V1, -32668(GP)
570:                         i=last-first+1;
9D0055C8  00484023   SUBU T0, V0, T0
9D0055CC  25080001   ADDIU T0, T0, 1
571:                         if (i>0){
9D0055D0  19000039   BLEZ T0, 0x9D0056B8
9D0055D4  AFA80010   SW T0, 16(SP)
572:                             *cptr++=IDOTQ;
9D0055D8  24020029   ADDIU V0, ZERO, 41
9D0055DC  A2220000   SB V0, 0(S1)
573:                             *cptr++=i;
9D0055E0  8FA20010   LW V0, 16(SP)
9D0055E4  A2220001   SB V0, 1(S1)
574:                             for (i=first;i<=last;i++) *cptr++=tib[i];
9D0055E8  83828070   LB V0, -32656(GP)
9D0055EC  AFA20010   SW V0, 16(SP)
9D0055F0  8383805C   LB V1, -32676(GP)
9D0055F4  0062182A   SLT V1, V1, V0
9D0055F8  1460002F   BNE V1, ZERO, 0x9D0056B8
9D0055FC  26310002   ADDIU S1, S1, 2
9D005600  3C04A000   LUI A0, -24576
9D005604  248424BC   ADDIU A0, A0, 9404
9D005608  00441021   ADDU V0, V0, A0
9D00560C  90420000   LBU V0, 0(V0)
9D005610  A2220000   SB V0, 0(S1)
9D005614  8FA20010   LW V0, 16(SP)
9D005618  24420001   ADDIU V0, V0, 1
9D00561C  AFA20010   SW V0, 16(SP)
9D005620  8383805C   LB V1, -32676(GP)
9D005624  0062182A   SLT V1, V1, V0
9D005628  1060FFF7   BEQ V1, ZERO, 0x9D005608
9D00562C  26310001   ADDIU S1, S1, 1
575:                         }
576:                     } else if (code==IFCALL || code== IRCALL || code==IBRA|| code==IQBRA){
9D005638  12020007   BEQ S0, V0, 0x9D005658
9D00563C  2402002B   ADDIU V0, ZERO, 43
9D005640  12020005   BEQ S0, V0, 0x9D005658
9D005644  24020006   ADDIU V0, ZERO, 6
9D005648  12020003   BEQ S0, V0, 0x9D005658
9D00564C  24020007   ADDIU V0, ZERO, 7
9D005650  56020018   BNEL S0, V0, 0x9D0056B4
9D005654  A2300000   SB S0, 0(S1)
577:                         *cptr++=code;
9D005658  A2300000   SB S0, 0(S1)
9D00565C  26310001   ADDIU S1, S1, 1
578:                         word(SPC);
9D005660  0F401362   JAL word
9D005664  24040020   ADDIU A0, ZERO, 32
579:                         upper();
9D005668  0F40134C   JAL upper
9D00566C  00000000   NOP
580:                         if (parse_int(&i)){
9D005670  0F4014A4   JAL parse_int
9D005674  27A40010   ADDIU A0, SP, 16
9D005678  10400010   BEQ V0, ZERO, 0x9D0056BC
9D00567C  8382802E   LB V0, -32722(GP)
581:                             *cptr++=i;
9D005680  8FA20010   LW V0, 16(SP)
9D005684  A2220000   SB V0, 0(S1)
582:                             if (code==IFCALL || code==IRCALL) *cptr++= (i>>8);
9D005688  24020004   ADDIU V0, ZERO, 4
9D00568C  12020004   BEQ S0, V0, 0x9D0056A0
9D005690  26310001   ADDIU S1, S1, 1
9D005694  2402002B   ADDIU V0, ZERO, 43
9D005698  16020008   BNE S0, V0, 0x9D0056BC
9D00569C  8382802E   LB V0, -32722(GP)
9D0056A0  8FA20010   LW V0, 16(SP)
9D0056A4  00021203   SRA V0, V0, 8
9D0056A8  A2220000   SB V0, 0(S1)
9D0056AC  0B4015AE   J 0x9D0056B8
9D0056B0  26310001   ADDIU S1, S1, 1
583:                         }
584:                     }else {
585:                         *cptr++=code;
9D0056B4  26310001   ADDIU S1, S1, 1
586:                     }
587:                     if (state) here=cptr;else cip=cptr;
9D005630  0B4015AF   J 0x9D0056BC
9D005634  8382802E   LB V0, -32722(GP)
9D0056B8  8382802E   LB V0, -32722(GP)
9D0056BC  50400002   BEQL V0, ZERO, 0x9D0056C8
9D0056C0  AF918068   SW S1, -32664(GP)
9D0056C4  AF91CBC8   SW S1, -13368(GP)
588:                     return !error;
9D0056C8  8382802F   LB V0, -32721(GP)
589:                 }// compile_token()
9D0056CC  2C420001   SLTIU V0, V0, 1
9D0056D0  8FBF0024   LW RA, 36(SP)
9D0056D4  8FB10020   LW S1, 32(SP)
9D0056D8  8FB0001C   LW S0, 28(SP)
9D0056DC  03E00008   JR RA
9D0056E0  27BD0028   ADDIU SP, SP, 40
590:                 
591:                 
592:                 //void print_integer(int n){
593:                 //    int i;
594:                 //    char sign;
595:                 //    if (n<0){sign='-';n=abs(n);}else sign=' ';
596:                 //    pad[11]=0;
597:                 //    i=10;
598:                 //    while (n){
599:                 //       pad[i--]= '0'+ n%10;
600:                 //       n /=10;
601:                 //    }
602:                 //    if (i==10) pad[i]='0'; else (sign=='-')?pad[i]=sign:i++;
603:                 //    UartPrint(STDOUT,&pad[i]);
604:                 //    UartPrint(STDOUT," ");
605:                 //}// print_integer()
606:                 
607:                 void compile_run(){ // analyse le contenu de TIB
9D005748  27BDFFE0   ADDIU SP, SP, -32
9D00574C  AFBF001C   SW RA, 28(SP)
9D005750  AFB10018   SW S1, 24(SP)
9D005754  AFB00014   SW S0, 20(SP)
608:                     int code;
609:                     imm_code=here+256;
9D005758  8F82CBC8   LW V0, -13368(GP)
9D00575C  24420100   ADDIU V0, V0, 256
9D005760  AF828060   SW V0, -32672(GP)
610:                     cip=imm_code;
9D005764  AF828068   SW V0, -32664(GP)
611:                     current=0;
9D005768  A3808064   SB ZERO, -32668(GP)
612:                     name_hash nh;
613:                     state=IMMEDIATE;
9D00576C  A380802E   SB ZERO, -32722(GP)
614:                     error=0;
9D005770  A380802F   SB ZERO, -32721(GP)
615:                     while (!error && current<ctib){
9D005778  0B4015FD   J 0x9D0057F4
9D00577C  263193F4   ADDIU S1, S1, -27660
9D0057F4  8382802F   LB V0, -32721(GP)
9D0057F8  1440001B   BNE V0, ZERO, 0x9D005868
9D0057FC  83838064   LB V1, -32668(GP)
9D005800  83828071   LB V0, -32655(GP)
9D005804  0062102A   SLT V0, V1, V0
9D005808  1440FFDD   BNE V0, ZERO, 0x9D005780
9D00580C  8382802E   LB V0, -32722(GP)
9D005810  0B401618   J 0x9D005860
9D005814  00000000   NOP
616:                         word(SPC);
9D005780  0F401362   JAL word
9D005784  24040020   ADDIU A0, ZERO, 32
617:                         nh = hash();
9D005788  0F4012FD   JAL hash
9D00578C  00000000   NOP
9D005790  00408021   ADDU S0, V0, ZERO
618:                         if (!(try_user(nh)||try_system(nh)||try_token(nh)||try_integer())){
9D005794  0F401437   JAL try_user
9D005798  00402021   ADDU A0, V0, ZERO
9D00579C  14400016   BNE V0, ZERO, 0x9D0057F8
9D0057A0  8382802F   LB V0, -32721(GP)
9D0057A4  0F401466   JAL try_system
9D0057A8  02002021   ADDU A0, S0, ZERO
9D0057AC  14400012   BNE V0, ZERO, 0x9D0057F8
9D0057B0  8382802F   LB V0, -32721(GP)
9D0057B4  0F4015B9   JAL try_token
9D0057B8  02002021   ADDU A0, S0, ZERO
9D0057BC  1440000E   BNE V0, ZERO, 0x9D0057F8
9D0057C0  8382802F   LB V0, -32721(GP)
9D0057C4  0F4014F2   JAL try_integer
9D0057C8  00000000   NOP
9D0057CC  1440000A   BNE V0, ZERO, 0x9D0057F8
9D0057D0  8382802F   LB V0, -32721(GP)
619:                             print(comm_channel, "erreur de compilation, position: ");
9D005774  3C119D01   LUI S1, -25343
9D0057D4  83848034   LB A0, -32716(GP)
9D0057D8  0F401D9C   JAL print
9D0057DC  02202821   ADDU A1, S1, ZERO
620:                             print_int(comm_channel, first+1,6);
9D0057E0  83858070   LB A1, -32656(GP)
9D0057E4  83848034   LB A0, -32716(GP)
9D0057E8  24A50001   ADDIU A1, A1, 1
9D0057EC  0F401DCE   JAL print_int
9D0057F0  24060006   ADDIU A2, ZERO, 6
621:                         }
622:                     }//while (current<ctib)
623:                     if (!(error || state)){
9D005860  1040FFED   BEQ V0, ZERO, 0x9D005818
9D005864  8F828068   LW V0, -32664(GP)
624:                         *cip=IEND;
9D005818  A0400000   SB ZERO, 0(V0)
625:                         code = StackVM((const unsigned char*)imm_code);
9D00581C  0F400CB9   JAL 0x9D0032E4
9D005820  8F848060   LW A0, -32672(GP)
626:                         if (code){
9D005824  10400010   BEQ V0, ZERO, 0x9D005868
9D005828  00408021   ADDU S0, V0, ZERO
627:                             UartPrint(STDOUT,"Erreur opcode VM: ");
9D00582C  24040001   ADDIU A0, ZERO, 1
9D005830  3C059D01   LUI A1, -25343
9D005834  0F4021A1   JAL UartPrint
9D005838  24A59418   ADDIU A1, A1, -27624
628:                             print_int(SERIAL_CON,code,2);
9D00583C  24040001   ADDIU A0, ZERO, 1
9D005840  02002821   ADDU A1, S0, ZERO
9D005844  0F401DCE   JAL print_int
9D005848  24060002   ADDIU A2, ZERO, 2
629:                             UartPutch(STDOUT,'\r');
9D00584C  24040001   ADDIU A0, ZERO, 1
9D005850  0F402169   JAL UartPutch
9D005854  2405000D   ADDIU A1, ZERO, 13
630:                         }
631:                     }
632:                 }// compile_run()
9D005858  0B40161B   J 0x9D00586C
9D00585C  8FBF001C   LW RA, 28(SP)
9D005868  8FBF001C   LW RA, 28(SP)
9D00586C  8FB10018   LW S1, 24(SP)
9D005870  8FB00014   LW S0, 20(SP)
9D005874  03E00008   JR RA
9D005878  27BD0020   ADDIU SP, SP, 32
633:                 
634:                 void vpForth(){ // démarrage système forth en mode interpréteur
9D00587C  27BDFFE0   ADDIU SP, SP, -32
9D005880  AFBF001C   SW RA, 28(SP)
9D005884  AFB10018   SW S1, 24(SP)
9D005888  AFB00014   SW S0, 20(SP)
635:                     here=(unsigned char *)&ram_code;
9D00588C  3C02A000   LUI V0, -24576
9D005890  24422844   ADDIU V0, V0, 10308
9D005894  AF82CBC8   SW V0, -13368(GP)
636:                 //    comm_channel=SERIAL_CON;
637:                     print(comm_channel,SYSTEM_NAME);
9D005898  83848034   LB A0, -32716(GP)
9D00589C  3C059D01   LUI A1, -25343
9D0058A0  0F401D9C   JAL print
9D0058A4  24A5942C   ADDIU A1, A1, -27604
638:                     print(comm_channel,SYSTEM_VERSION);
9D0058A8  83848034   LB A0, -32716(GP)
9D0058AC  3C059D01   LUI A1, -25343
9D0058B0  0F401D9C   JAL print
9D0058B4  24A59438   ADDIU A1, A1, -27592
639:                     while (1){
640:                         if ((ctib=readline(comm_channel, &tib[0],TIB_SIZE-1))){
9D0058B8  3C10A000   LUI S0, -24576
9D0058BC  261024BC   ADDIU S0, S0, 9404
9D0058C8  83848034   LB A0, -32716(GP)
9D0058CC  02002821   ADDU A1, S0, ZERO
9D0058D0  0F401ED5   JAL readline
9D0058D4  2406004F   ADDIU A2, ZERO, 79
9D0058D8  7C021420   SEB V0, V0
9D0058DC  10400003   BEQ V0, ZERO, 0x9D0058EC
9D0058E0  A3828071   SB V0, -32655(GP)
641:                             //UartPrint(STDOUT,tib);
642:                             compile_run();
9D0058E4  0F4015D2   JAL compile_run
9D0058E8  00000000   NOP
643:                         }
644:                         print(comm_channel, " ok\r");
9D0058C0  3C119D01   LUI S1, -25343
9D0058C4  26319440   ADDIU S1, S1, -27584
9D0058EC  83848034   LB A0, -32716(GP)
9D0058F0  0F401D9C   JAL print
9D0058F4  02202821   ADDU A1, S1, ZERO
645:                     }// while(1)
9D0058F8  0B401633   J 0x9D0058CC
9D0058FC  83848034   LB A0, -32716(GP)
646:                 }//tForth()
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/vpForth/vm.S  -------------------------------------------
                                                  1:     /*
                                                  2:     * Copyright 2013, Jacques Deschênes
                                                  3:     * This file is part of VPC-32.
                                                  4:     *
                                                  5:     *     VPC-32 is free software: you can redistribute it and/or modify
                                                  6:     *     it under the terms of the GNU General Public License as published by
                                                  7:     *     the Free Software Foundation, either version 3 of the License, or
                                                  8:     *     (at your option) any later version.
                                                  9:     *
                                                  10:    *     VPC-32 is distributed in the hope that it will be useful,
                                                  11:    *     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                                  12:    *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                                  13:    *     GNU General Public License for more details.
                                                  14:    *
                                                  15:    *     You should have received a copy of the GNU General Public License
                                                  16:    *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
                                                  17:    */
                                                  18:    
                                                  19:    /*
                                                  20:     * File:   vm.S
                                                  21:     * Author: Jacques Deschênes
                                                  22:     *
                                                  23:     * Created on 31 mai 2013
                                                  24:     *  machine viruelle à piles qui est utilisée comme
                                                  25:     *  modèle d'exécution par vpForth.
                                                  26:     */
                                                  27:    
                                                  28:    #include <p32xxxx.h>
                                                  29:    #include "opcodes.h"
                                                  30:    
                                                  31:    .extern put_char
                                                  32:    .extern get_key
                                                  33:    .extern wait_key
                                                  34:    .extern sys_tick
                                                  35:    .extern print_int
                                                  36:    .extern print_hex
                                                  37:    .extern readline
                                                  38:    .extern comm_channel
                                                  39:    
                                                  40:    /*
                                                  41:    RAM_SEG=0xA000
                                                  42:    CODE_SEG=0x9D00
                                                  43:    SFR_SEG=0xBF88
                                                  44:    */
                                                  45:    /*
                                                  46:    #define RAM_SEG  0xA000
                                                  47:    #define CODE_SEG 0x9D00
                                                  48:    #define SFR_SEG  0xBF88
                                                  49:    */
                                                  50:    
                                                  51:    /* constantes */
                                                  52:    FLASH_SIZE=2048
                                                  53:    CELL_SIZE=4
                                                  54:    
                                                  55:    RAM_SEG=0xA000
                                                  56:    CODE_SEG=0x9D00
                                                  57:    SFR_SEG=0xBF88
                                                  58:    
                                                  59:    
                                                  60:    /* utilisation des regitres MIPS */
                                                  61:    ip=s0  /* pointeur d'instruction VM */
                                                  62:    dp=s1  /* pointeur pile de données */
                                                  63:    rp=s2  /* pointeur pile de contrôle */
                                                  64:    wp=s3 /* pointeur de travail */
                                                  65:    topd=s4 /* sommet de la pile des arguments */
                                                  66:    topr=s5 /* sommet de la pile de contrôle */
                                                  67:    
                                                  68:     # NOTE: les pointeurs de piles sont incrémentés avant l''empilement.
                                                  69:     #       et décrémenté après le dépilement.
                                                  70:    
                                                  71:        .macro _dpush  R   # empile le contenu de R
                                                  72:         addiu dp,dp, (CELL_SIZE)
                                                  73:         sw topd, 0(dp)
                                                  74:         addu topd,zero, \R
                                                  75:        .endm
                                                  76:    
                                                  77:        .macro _dpop  R=$0
                                                  78:        addu \R,zero, topd
                                                  79:        lw topd, 0(dp)
                                                  80:        addiu dp,dp,-(CELL_SIZE)
                                                  81:        .endm
                                                  82:    
                                                  83:        .macro _fetch_t R  # copie le contenu de topd dans R
                                                  84:        addu \R, topd, zero
                                                  85:        .endm
                                                  86:    
                                                  87:        .macro _store_t R  # met le contenu du registre R dans topd
                                                  88:        addu topd, \R, zero
                                                  89:        .endm
                                                  90:    
                                                  91:    
                                                  92:    
                                                  93:        .macro _fetch_n R, N  # copie le Nième élément de la pile dans R
                                                  94:        lw \R, -(\N-1)*4(dp)
                                                  95:        .endm
                                                  96:    
                                                  97:        .macro _store_n R, N  # copie R, N en N ième position de la pile
                                                  98:        sw \R, -(\N-1)*4(dp)
                                                  99:        .endm
                                                  100:   
                                                  101:   
                                                  102:       .macro _rpush   R   # empile R sur pile des retours
                                                  103:       addiu rp,rp,(CELL_SIZE)
                                                  104:       sw topr, 0(rp)
                                                  105:       addu topr, zero, \R
                                                  106:       .endm
                                                  107:   
                                                  108:       .macro _rpop  R  # dépile topr dans R
                                                  109:       addu \R, topr, zero
                                                  110:       lw topr, 0(rp)
                                                  111:       addiu rp,rp,-(CELL_SIZE)
                                                  112:       .endm
                                                  113:   
                                                  114:       .macro _fetch_r  R   # copie topr dans R
                                                  115:       addu \R, topr,zero
                                                  116:       .endm
                                                  117:   
                                                  118:       .macro _store_r R    # copie R dans topr
                                                  119:       addu topr, \R, zero
                                                  120:       .endm
                                                  121:   
                                                  122:       .macro _next        # next bytecode
                                                  123:       addiu ip,ip,1
                                                  124:       .endm
                                                  125:   
                                                  126:       .macro ld_bytecode R
                                                  127:       lb \R, 0(ip)
                                                  128:       andi \R, \R, 0xff
                                                  129:       .endm
                                                  130:   
                                                  131:   
                                                  132:       .macro _to_r    # >R
                                                  133:       _dpop t7
                                                  134:       _rpush t7
                                                  135:       .endm
                                                  136:   
                                                  137:       .macro _from_r  # R>
                                                  138:       _rpop t7
                                                  139:       _dpush t7
                                                  140:       .endm
                                                  141:   
                                                  142:   
                                                  143:       .macro _getch channel  # channel et un pointeur sur le device id.
                                                  144:       la a0, \channel
                                                  145:       jal get_key
                                                  146:       lb a0, 0(a0)
                                                  147:       .endm
                                                  148:   
                                                  149:       .macro _putch channel   # transmet le caractère qui est dans topd
                                                  150:       la a0, \channel
                                                  151:       lb a0, 0(a0)
                                                  152:       _dpop a1
                                                  153:       jal put_char
                                                  154:       nop
                                                  155:       .endm
                                                  156:   
                                                  157:       .macro ld_var R V  # charge le registre R avec le contenu du pointeur V
                                                  158:       la \R, \V
                                                  159:       lw \R, 0(\R)
                                                  160:       .endm
                                                  161:   
                                                  162:       DPRINT=1
                                                  163:   
                                                  164:       .macro _dbg_print N
                                                  165:       .if DPRINT
                                                  166:       jal dbg_print
                                                  167:       li a0, \N
                                                  168:       .endif
                                                  169:       .endm
                                                  170:   
                                                  171:       .macro _fn_enter N
                                                  172:       addiu sp, sp, -(\N)
                                                  173:       sw ra, (\N-4)(sp)
                                                  174:       .endm
                                                  175:       
                                                  176:       .macro _fn_exit N
                                                  177:       lw ra, (\N-4)(sp)
                                                  178:       j ra
                                                  179:       addiu sp,sp, \N
                                                  180:       .endm
                                                  181:   
                                                  182:   
                                                  183:   STDIO=1
                                                  184:   
                                                  185:   DSTACK_SIZE=64
                                                  186:   RSTACK_SIZE=64
                                                  187:   
                                                  188:   SFR_CLEAR=4
                                                  189:   SFR_SET=8
                                                  190:   SFR_INV=12
                                                  191:   
                                                  192:   .data
                                                  193:   .global base, dstack, rstack, here
                                                  194:   
                                                  195:   base: .word 10
                                                  196:   
                                                  197:   .section .bss
                                                  198:   dempty:  .space 1    # pile vide
                                                  199:   dstack:  .space DSTACK_SIZE
                                                  200:   rempty:  .space 1    # pile vide
                                                  201:   rstack: .space RSTACK_SIZE
                                                  202:   zsp: .word   dempty   # pile données position vide
                                                  203:   zrp: .word   rempty   # pile retour position vide
                                                  204:   here: .word  0
                                                  205:   
                                                  206:   .text
                                                  207:   .set noreorder
                                                  208:   .set macro
                                                  209:   .global StackVM,  flash_code
                                                  210:   # .global tokens
                                                  211:   .ent StackVM
                                                  212:   
                                                  213:   
                                                  214:   StackVM:
9D0032E4  27BDFFE0   ADDIU SP, SP, -32            215:       _fn_enter 32
9D0032E8  AFBF001C   SW RA, 28(SP)
9D0032EC  AFB00018   SW S0, 24(SP)                216:       sw  s0, 24(sp)
9D0032F0  AFB10014   SW S1, 20(SP)                217:       sw  s1, 20(sp)
9D0032F4  AFB20010   SW S2, 16(SP)                218:       sw  s2, 16(sp)
9D0032F8  AFB3000C   SW S3, 12(SP)                219:       sw  s3, 12(sp)
9D0032FC  AFB40008   SW S4, 8(SP)                 220:       sw  s4, 8(sp)
9D003300  AFB50004   SW S5, 4(SP)                 221:       sw  s5, 4(sp)
9D003304  00048021   ADDU S0, ZERO, A0            222:       addu ip, zero, a0  #buffer code passé en paramètre
9D003308  3C11A000   LUI S1, -24576               223:       la dp, dempty
9D00330C  26314B2C   ADDIU S1, S1, 19244
9D003310  3C12A000   LUI S2, -24576               224:       la rp, rempty
9D003314  26524B6D   ADDIU S2, S2, 19309
9D003318  3C13A000   LUI S3, -24576               225:       la wp, zsp
9D00331C  26734BB0   ADDIU S3, S3, 19376
9D003320  AE710000   SW S1, 0(S3)                 226:       sw dp, 0(wp)    // valeur de sp lorsque pile données vide.
9D003324  AE720004   SW S2, 4(S3)                 227:       sw rp, 4(wp)    // valeur de rp lorsque pile retour vide.
                                                  228:   
                                                  229:   vm:
9D003328  82080000   LB T0, 0(S0)                 230:       ld_bytecode t0
9D00332C  310800FF   ANDI T0, T0, 255
9D003330  26100001   ADDIU S0, S0, 1              231:       _next
9D003334  2509FFB8   ADDIU T1, T0, -72            232:       addiu t1,t0, IBADOP
9D003338  1D200256   BGTZ T1, 0x9D003C94          233:       bgtz  t1, badop
9D00333C  00084080   SLL T0, T0, 2                234:       sll   t0, t0, 2   
9D003340  3C099D00   LUI T1, -25344               235:       la t1, opcodes_vectors
9D003344  25293DAC   ADDIU T1, T1, 15788
9D003348  01284821   ADDU T1, T1, T0              236:       addu  t1,t1,t0
9D00334C  8D290000   LW T1, 0(T1)                 237:       lw  t1, 0(t1)
9D003350  01200008   JR T1                        238:       j   t1
9D003354  00000000   NOP                          239:       nop
                                                  240:   end:   # 'bye' ( -- ) sortie de la machine virtuelle
9D003358  00001026   XOR V0, ZERO, ZERO           241:       xor v0, zero,zero
9D00335C  1000024E   BEQ ZERO, ZERO, 0x9D003C98   242:       b exit
9D003360  00000000   NOP                          243:       nop
                                                  244:   
                                                  245:   qrx: # '?key' ( -- ch -1 | 0 )
9D003364  3C04A000   LUI A0, -24576               246:       _getch comm_channel
9D003368  24840024   ADDIU A0, A0, 36
9D00336C  0F401E95   JAL get_key
9D003370  80840000   LB A0, 0(A0)
9D003374  26310004   ADDIU S1, S1, 4              247:       _dpush v0
9D003378  AE340000   SW S4, 0(S1)
9D00337C  0002A021   ADDU S4, ZERO, V0
9D003380  1040FFE9   BEQ V0, ZERO, 0x9D003328     248:       beq v0, zero, vm
9D003384  00000000   NOP                          249:       nop
9D003388  2408FFFF   ADDIU T0, ZERO, -1           250:       addiu t0,zero,-1
9D00338C  26310004   ADDIU S1, S1, 4              251:       _dpush t0
9D003390  AE340000   SW S4, 0(S1)
9D003394  0008A021   ADDU S4, ZERO, T0
9D003398  1000FFE3   BEQ ZERO, ZERO, 0x9D003328   252:       b vm
9D00339C  00000000   NOP                          253:       nop
                                                  254:   
                                                  255:   dot:  # '.'  ( n --  ) imprime entier n
9D0033A0  3C13A000   LUI S3, -24576               256:       la wp, comm_channel
9D0033A4  26730024   ADDIU S3, S3, 36
9D0033A8  82640000   LB A0, 0(S3)                 257:       lb a0, 0(wp)
9D0033AC  24050020   ADDIU A1, ZERO, 32           258:       li a1, 32
9D0033B0  0F401D21   JAL 0x9D007484               259:       jal put_char
9D0033B4  00000000   NOP                          260:       nop
9D0033B8  82640000   LB A0, 0(S3)                 261:       lb a0,0(wp)
9D0033BC  00142821   ADDU A1, ZERO, S4            262:       _dpop a1
9D0033C0  8E340000   LW S4, 0(S1)
9D0033C4  2631FFFC   ADDIU S1, S1, -4
9D0033C8  0F401DCE   JAL 0x9D007738               263:       jal print_int
9D0033CC  24060001   ADDIU A2, ZERO, 1            264:       addiu a2,zero,1
9D0033D0  1000FFD5   BEQ ZERO, ZERO, 0x9D003328   265:       b vm
9D0033D4  00000000   NOP                          266:       nop
                                                  267:   
                                                  268:   emit:   # 'emit' ( ch -- ) transmet charactère au terminal
9D0033D8  3C04A000   LUI A0, -24576               269:       _putch comm_channel
9D0033DC  24840024   ADDIU A0, A0, 36
9D0033E0  80840000   LB A0, 0(A0)
9D0033E4  00142821   ADDU A1, ZERO, S4
9D0033E8  8E340000   LW S4, 0(S1)
9D0033EC  2631FFFC   ADDIU S1, S1, -4
9D0033F0  0F401D21   JAL put_char
9D0033F4  00000000   NOP
9D0033F8  1000FFCB   BEQ ZERO, ZERO, 0x9D003328   270:       b vm
9D0033FC  00000000   NOP                          271:       nop
                                                  272:   
                                                  273:   iemit:  # 'iemit' ( n -- ) transmet n comme 4 octet ordonné en little indian
9D003400  02802821   ADDU A1, S4, ZERO            274:       _fetch_t a1
9D003404  24080004   ADDIU T0, ZERO, 4            275:       li t0, 4
9D003408  26310004   ADDIU S1, S1, 4              276:       _dpush t0
9D00340C  AE340000   SW S4, 0(S1)
9D003410  0008A021   ADDU S4, ZERO, T0
                                                  277:   1:
9D003414  3C04A000   LUI A0, -24576               278:       la a0, comm_channel
9D003418  24840024   ADDIU A0, A0, 36
9D00341C  0F401D21   JAL 0x9D007484               279:       jal put_char
9D003420  8C840000   LW A0, 0(A0)                 280:       lw a0,0(a0)
9D003424  2694FFFF   ADDIU S4, S4, -1             281:       addiu topd,-1
9D003428  12800008   BEQ S4, ZERO, 0x9D00344C     282:       beqz topd, 2f
9D00342C  00140021   ADDU ZERO, ZERO, S4          283:       _dpop
9D003430  8E340000   LW S4, 0(S1)
9D003434  2631FFFC   ADDIU S1, S1, -4
9D003438  8E250000   LW A1, 0(S1)                 284:       _fetch_n a1, 1
9D00343C  00052A02   SRL A1, A1, 8                285:       srl a1,a1,8
9D003440  AE250000   SW A1, 0(S1)                 286:       _store_n a1, 1
9D003444  1000FFF3   BEQ ZERO, ZERO, 0x9D003414   287:       b 1b
9D003448  00000000   NOP                          288:       nop
                                                  289:   2:
9D00344C  00140021   ADDU ZERO, ZERO, S4          290:       _dpop
9D003450  8E340000   LW S4, 0(S1)
9D003454  2631FFFC   ADDIU S1, S1, -4
9D003458  1000FFB3   BEQ ZERO, ZERO, 0x9D003328   291:       b vm
9D00345C  00000000   NOP                          292:       nop
                                                  293:   
                                                  294:   lit:    # 'lit' ( -- n) empile un entier
9D003460  0F400F2F   JAL 0x9D003CBC               295:       jal fetch_int
9D003464  00000000   NOP                          296:       nop
9D003468  26310004   ADDIU S1, S1, 4              297:       _dpush v0
9D00346C  AE340000   SW S4, 0(S1)
9D003470  0002A021   ADDU S4, ZERO, V0
9D003474  1000FFAC   BEQ ZERO, ZERO, 0x9D003328   298:       b vm
9D003478  00000000   NOP                          299:       nop
                                                  300:   
                                                  301:   clit:       # 'clit' ( -- byte ) empile un octet signe étendu sur 32 bits
9D00347C  82080000   LB T0, 0(S0)                 302:       ld_bytecode t0
9D003480  310800FF   ANDI T0, T0, 255
9D003484  26100001   ADDIU S0, S0, 1              303:       _next
9D003488  26310004   ADDIU S1, S1, 4              304:       _dpush t0
9D00348C  AE340000   SW S4, 0(S1)
9D003490  0008A021   ADDU S4, ZERO, T0
9D003494  1000FFA4   BEQ ZERO, ZERO, 0x9D003328   305:       b vm
9D003498  00000000   NOP                          306:       nop
                                                  307:   
                                                  308:   wlit:       # 'wlit' ( -- w16  ) empile un mot de 16 bits
9D00349C  92080000   LBU T0, 0(S0)                309:       lbu t0, 0(ip)
9D0034A0  26100001   ADDIU S0, S0, 1              310:       _next
9D0034A4  82090000   LB T1, 0(S0)                 311:       ld_bytecode t1
9D0034A8  312900FF   ANDI T1, T1, 255
9D0034AC  26100001   ADDIU S0, S0, 1              312:       _next
9D0034B0  00094A00   SLL T1, T1, 8                313:       sll  t1,t1, 8
9D0034B4  01094025   OR T0, T0, T1                314:       or  t0,t0,t1
9D0034B8  26310004   ADDIU S1, S1, 4              315:       _dpush t0
9D0034BC  AE340000   SW S4, 0(S1)
9D0034C0  0008A021   ADDU S4, ZERO, T0
9D0034C4  1000FF98   BEQ ZERO, ZERO, 0x9D003328   316:       b vm
9D0034C8  00000000   NOP                          317:       nop
                                                  318:   
                                                  319:   fcall:   # 'fcall' (R: -- addr_ret ) appelle sous-routine VM en mémoire flash
9D0034CC  3C0A9D00   LUI T2, -25344               320:       lui t2, CODE_SEG
9D0034D0  92080000   LBU T0, 0(S0)                321:       lbu t0, 0(ip)
                                                  322:   fcall_1:
9D0034D4  26100001   ADDIU S0, S0, 1              323:       _next
9D0034D8  92090000   LBU T1, 0(S0)                324:       lbu t1, 0(ip)
9D0034DC  26100001   ADDIU S0, S0, 1              325:       _next
9D0034E0  00094A00   SLL T1, T1, 8                326:       sll t1,t1,8
9D0034E4  01094025   OR T0, T0, T1                327:       or t0,t0,t1
9D0034E8  010A4025   OR T0, T0, T2                328:       or t0,t0,t2
9D0034EC  26520004   ADDIU S2, S2, 4              329:       _rpush ip
9D0034F0  AE550000   SW S5, 0(S2)
9D0034F4  0010A821   ADDU S5, ZERO, S0
9D0034F8  1000FF8B   BEQ ZERO, ZERO, 0x9D003328   330:       b vm
9D0034FC  01008021   ADDU S0, T0, ZERO            331:       move ip, t0
                                                  332:   
                                                  333:   rcall:  # 'rcall' (R: -- addr_ret ) appelle sous-routine VM en mémoire RAM
9D003500  3C0AA000   LUI T2, -24576               334:       lui t2, RAM_SEG
9D003504  92080000   LBU T0, 0(S0)                335:       lbu t0, 0(ip)
9D003508  1000FFF2   BEQ ZERO, ZERO, 0x9D0034D4   336:       b fcall_1
9D00350C  00000000   NOP                          337:       nop
                                                  338:   
                                                  339:   ret:        # ';' (R: addr_ret -- ) sortie de sous-routine
9D003510  3C09A000   LUI T1, -24576               340:       la t1, zrp    # vérifie si la pile est vide, si c''est le cas exit.
9D003514  25294BB4   ADDIU T1, T1, 19380
9D003518  8D290000   LW T1, 0(T1)                 341:       lw t1, 0(t1)
9D00351C  113201DE   BEQ T1, S2, 0x9D003C98       342:       beq t1,rp, exit # erreur accès pile retour vide
9D003520  00000000   NOP                          343:       nop
9D003524  02A08021   ADDU S0, S5, ZERO            344:       _rpop ip
9D003528  8E550000   LW S5, 0(S2)
9D00352C  2652FFFC   ADDIU S2, S2, -4
9D003530  1000FF7D   BEQ ZERO, ZERO, 0x9D003328   345:       b vm
9D003534  00000000   NOP                          346:       nop
                                                  347:   
                                                  348:   bra:        # 'branch' ( -- ) branchement incondionnnel (adresse relative +127,-128)
9D003538  82080000   LB T0, 0(S0)                 349:       ld_bytecode t0
9D00353C  310800FF   ANDI T0, T0, 255
9D003540  26100001   ADDIU S0, S0, 1              350:       _next
9D003544  1000FF78   BEQ ZERO, ZERO, 0x9D003328   351:       b vm
9D003548  02088021   ADDU S0, S0, T0              352:       addu ip, ip, t0   # branchement relative intervale -128 à +127
                                                  353:   
                                                  354:   qbra:       # '?bra' ( t|f -- ) branche si sommet pile est vrai (topd!=0)
9D00354C  00144021   ADDU T0, ZERO, S4            355:       _dpop t0
9D003550  8E340000   LW S4, 0(S1)
9D003554  2631FFFC   ADDIU S1, S1, -4
9D003558  1100FF73   BEQ T0, ZERO, 0x9D003328     356:       beqz t0, vm
9D00355C  26100001   ADDIU S0, S0, 1              357:       _next
9D003560  8208FFFF   LB T0, -1(S0)                358:       lb t0, -1(ip)
9D003564  1000FF70   BEQ ZERO, ZERO, 0x9D003328   359:       b vm
9D003568  02088021   ADDU S0, S0, T0              360:       addu ip,ip,t0
                                                  361:   
                                                  362:   qbraz:      # '?braz' ( t|f -- ) branche si sommet pile est faux (topd==0)
9D00356C  00144021   ADDU T0, ZERO, S4            363:       _dpop t0
9D003570  8E340000   LW S4, 0(S1)
9D003574  2631FFFC   ADDIU S1, S1, -4
9D003578  1500FF6B   BNE T0, ZERO, 0x9D003328     364:       bne t0, zero, vm
9D00357C  26100001   ADDIU S0, S0, 1              365:       _next
9D003580  8208FFFF   LB T0, -1(S0)                366:       lb t0, -1(ip)
9D003584  1000FF68   BEQ ZERO, ZERO, 0x9D003328   367:       b vm
9D003588  02088021   ADDU S0, S0, T0              368:       addu ip,ip,t0
                                                  369:   
                                                  370:   exec:       # 'exec' ( addr -- ) appelle sous-routine à partir de la pile
9D00358C  26520004   ADDIU S2, S2, 4              371:       _rpush ip
9D003590  AE550000   SW S5, 0(S2)
9D003594  0010A821   ADDU S5, ZERO, S0
9D003598  00148021   ADDU S0, ZERO, S4            372:       _dpop ip
9D00359C  8E340000   LW S4, 0(S1)
9D0035A0  2631FFFC   ADDIU S1, S1, -4
9D0035A4  1000FF60   BEQ ZERO, ZERO, 0x9D003328   373:       b vm
9D0035A8  00000000   NOP                          374:       nop
                                                  375:   
                                                  376:   store:      # '!' ( n addr -- )  variable = n
9D0035AC  00144021   ADDU T0, ZERO, S4            377:       _dpop t0
9D0035B0  8E340000   LW S4, 0(S1)
9D0035B4  2631FFFC   ADDIU S1, S1, -4
9D0035B8  00144821   ADDU T1, ZERO, S4            378:       _dpop t1
9D0035BC  8E340000   LW S4, 0(S1)
9D0035C0  2631FFFC   ADDIU S1, S1, -4
9D0035C4  A1090000   SB T1, 0(T0)                 379:       sb t1, 0(t0)   # l''adresse n''est pas forcément alignée donc on y va octet par octet
9D0035C8  00094A02   SRL T1, T1, 8                380:       srl t1,t1,8
9D0035CC  A1090001   SB T1, 1(T0)                 381:       sb t1,1(t0)
9D0035D0  00094A02   SRL T1, T1, 8                382:       srl t1,t1,8
9D0035D4  A1090002   SB T1, 2(T0)                 383:       sb t1,2(t0)
9D0035D8  00094A02   SRL T1, T1, 8                384:       srl t1,t1,8
9D0035DC  A1090003   SB T1, 3(T0)                 385:       sb t1,3(t0)
9D0035E0  1000FF51   BEQ ZERO, ZERO, 0x9D003328   386:       b vm
9D0035E4  00000000   NOP                          387:       nop
                                                  388:   
                                                  389:   fetch:      # '@' ( addr -- n ) topd = variable
9D0035E8  02804021   ADDU T0, S4, ZERO            390:       _fetch_t t0
9D0035EC  91090000   LBU T1, 0(T0)                391:       lbu t1, 0(t0)   # l''adresse n''est pas forcément alignée donc on y va octet par octet
9D0035F0  910A0001   LBU T2, 1(T0)                392:       lbu t2, 1(t0)
9D0035F4  000A5200   SLL T2, T2, 8                393:       sll t2,t2,8
9D0035F8  012A4825   OR T1, T1, T2                394:       or t1,t1,t2
9D0035FC  910A0002   LBU T2, 2(T0)                395:       lbu t2, 2(t0)
9D003600  000A5400   SLL T2, T2, 16               396:       sll t2,t2,16
9D003604  012A4825   OR T1, T1, T2                397:       or t1,t1,t2
9D003608  910A0003   LBU T2, 3(T0)                398:       lbu t2, 3(t0)
9D00360C  000A5600   SLL T2, T2, 24               399:       sll t2, 24
9D003610  012A4025   OR T0, T1, T2                400:       or t0,t1,t2
9D003614  1000FF44   BEQ ZERO, ZERO, 0x9D003328   401:       b vm
9D003618  0100A021   ADDU S4, T0, ZERO            402:       _store_t t0
                                                  403:   
                                                  404:   cstore:     # 'c!' ( char addr --  ) variable = char
9D00361C  00144021   ADDU T0, ZERO, S4            405:       _dpop t0
9D003620  8E340000   LW S4, 0(S1)
9D003624  2631FFFC   ADDIU S1, S1, -4
9D003628  00144821   ADDU T1, ZERO, S4            406:       _dpop t1
9D00362C  8E340000   LW S4, 0(S1)
9D003630  2631FFFC   ADDIU S1, S1, -4
9D003634  A1090000   SB T1, 0(T0)                 407:       sb t1, 0(t0)
9D003638  1000FF3B   BEQ ZERO, ZERO, 0x9D003328   408:       b vm
9D00363C  00000000   NOP                          409:       nop
                                                  410:   
                                                  411:   cfetch:     # 'c@' ( addr -- char )  topd= char
9D003640  02804021   ADDU T0, S4, ZERO            412:       addu t0, topd, zero
9D003644  81080000   LB T0, 0(T0)                 413:       lb t0, 0(t0)
9D003648  1000FF37   BEQ ZERO, ZERO, 0x9D003328   414:       b vm
9D00364C  0100A021   ADDU S4, T0, ZERO            415:       addu topd, t0, zero
                                                  416:   
                                                  417:   rpfetch:    # 'rp@' ( -- rp ) topd = rp
9D003650  26310004   ADDIU S1, S1, 4              418:       _dpush rp
9D003654  AE340000   SW S4, 0(S1)
9D003658  0012A021   ADDU S4, ZERO, S2
9D00365C  1000FF32   BEQ ZERO, ZERO, 0x9D003328   419:       b vm
9D003660  00000000   NOP                          420:       nop
                                                  421:   
                                                  422:   rpstore:    # 'rp!' ( rp -- ) rp = topd
9D003664  00149021   ADDU S2, ZERO, S4            423:       _dpop rp
9D003668  8E340000   LW S4, 0(S1)
9D00366C  2631FFFC   ADDIU S1, S1, -4
9D003670  1000FF2D   BEQ ZERO, ZERO, 0x9D003328   424:       b vm
9D003674  00000000   NOP                          425:       nop
                                                  426:   
                                                  427:   rfetch:     # 'r@' ( -- n ) (R: n -- n )
9D003678  02A04021   ADDU T0, S5, ZERO            428:       _fetch_r t0
9D00367C  26310004   ADDIU S1, S1, 4              429:       _dpush t0
9D003680  AE340000   SW S4, 0(S1)
9D003684  0008A021   ADDU S4, ZERO, T0
9D003688  1000FF27   BEQ ZERO, ZERO, 0x9D003328   430:       b vm
9D00368C  00000000   NOP                          431:       nop
                                                  432:   
                                                  433:   tor:        # >r ( n -- ) (R: -- n )
9D003690  00144021   ADDU T0, ZERO, S4            434:       _dpop t0
9D003694  8E340000   LW S4, 0(S1)
9D003698  2631FFFC   ADDIU S1, S1, -4
9D00369C  26520004   ADDIU S2, S2, 4              435:       _rpush t0
9D0036A0  AE550000   SW S5, 0(S2)
9D0036A4  0008A821   ADDU S5, ZERO, T0
9D0036A8  1000FF1F   BEQ ZERO, ZERO, 0x9D003328   436:       b vm
9D0036AC  00000000   NOP                          437:       nop
                                                  438:   
                                                  439:   rfrom:      # 'r>' ( -- n ) (R: n -- )
9D0036B0  02A04021   ADDU T0, S5, ZERO            440:       _rpop t0
9D0036B4  8E550000   LW S5, 0(S2)
9D0036B8  2652FFFC   ADDIU S2, S2, -4
9D0036BC  26310004   ADDIU S1, S1, 4              441:       _dpush t0
9D0036C0  AE340000   SW S4, 0(S1)
9D0036C4  0008A021   ADDU S4, ZERO, T0
9D0036C8  1000FF17   BEQ ZERO, ZERO, 0x9D003328   442:       b vm
9D0036CC  00000000   NOP                          443:       nop
                                                  444:   
                                                  445:   spfetch:    #  'sp@' ( -- dp )
9D0036D0  02204021   ADDU T0, S1, ZERO            446:       move t0, dp
9D0036D4  26310004   ADDIU S1, S1, 4              447:       _dpush t0
9D0036D8  AE340000   SW S4, 0(S1)
9D0036DC  0008A021   ADDU S4, ZERO, T0
9D0036E0  1000FF11   BEQ ZERO, ZERO, 0x9D003328   448:       b vm
9D0036E4  00000000   NOP                          449:       nop
                                                  450:   
                                                  451:   spstore:    # 'sp!' ( n -- )
9D0036E8  1000FF0F   BEQ ZERO, ZERO, 0x9D003328   452:       b vm
9D0036EC  02808821   ADDU S1, S4, ZERO            453:       move dp, topd
                                                  454:   
                                                  455:   zerosp:     # 'zsp' ( -- n) position du bas de la pile données
9D0036F0  3C08A000   LUI T0, -24576               456:       la t0, zsp
9D0036F4  25084BB0   ADDIU T0, T0, 19376
9D0036F8  8D080000   LW T0, 0(T0)                 457:       lw t0, 0(t0)
9D0036FC  26310004   ADDIU S1, S1, 4              458:       _dpush t0
9D003700  AE340000   SW S4, 0(S1)
9D003704  0008A021   ADDU S4, ZERO, T0
9D003708  1000FF07   BEQ ZERO, ZERO, 0x9D003328   459:       b vm
9D00370C  00000000   NOP                          460:       nop
                                                  461:   
                                                  462:   zerorp:     # 'zrp' ( -- n ) position du base de la pile retours
9D003710  3C08A000   LUI T0, -24576               463:       la t0, zrp
9D003714  25084BB4   ADDIU T0, T0, 19380
9D003718  8D080000   LW T0, 0(T0)                 464:       lw t0, 0(t0)
9D00371C  26310004   ADDIU S1, S1, 4              465:       _dpush t0
9D003720  AE340000   SW S4, 0(S1)
9D003724  0008A021   ADDU S4, ZERO, T0
9D003728  1000FEFF   BEQ ZERO, ZERO, 0x9D003328   466:       b vm
9D00372C  00000000   NOP                          467:       nop
                                                  468:   
                                                  469:   ipfetch:        # 'ip@' ( -- ip ) empile la valeur courante du pointeur d''instructions
9D003730  26310004   ADDIU S1, S1, 4              470:       _dpush ip
9D003734  AE340000   SW S4, 0(S1)
9D003738  0010A021   ADDU S4, ZERO, S0
9D00373C  1000FEFA   BEQ ZERO, ZERO, 0x9D003328   471:       b vm
9D003740  00000000   NOP                          472:       nop
                                                  473:   
                                                  474:   ipstore:        # 'ip!' ( ip -- ) initialise le pointeur d''insturctions
9D003744  00144021   ADDU T0, ZERO, S4            475:       _dpop t0
9D003748  8E340000   LW S4, 0(S1)
9D00374C  2631FFFC   ADDIU S1, S1, -4
9D003750  1000FEF5   BEQ ZERO, ZERO, 0x9D003328   476:       b vm
9D003754  01008021   ADDU S0, T0, ZERO            477:       move ip, t0
                                                  478:   
                                                  479:   herefetch:  # 'here'  ( -- addr ) adresse de la variable here
9D003758  3C08A000   LUI T0, -24576               480:       la t0, here
9D00375C  25084BB8   ADDIU T0, T0, 19384
9D003760  8D080000   LW T0, 0(T0)                 481:       lw t0, 0(t0)
9D003764  26310004   ADDIU S1, S1, 4              482:       _dpush t0
9D003768  AE340000   SW S4, 0(S1)
9D00376C  0008A021   ADDU S4, ZERO, T0
9D003770  1000FEED   BEQ ZERO, ZERO, 0x9D003328   483:       b vm
9D003774  00000000   NOP                          484:       nop
                                                  485:   
                                                  486:   basefetch: # 'base' ( -- addr ) adresse de la variable here
9D003778  3C08A000   LUI T0, -24576               487:       la t0, base
9D00377C  25084BDC   ADDIU T0, T0, 19420
9D003780  8D080000   LW T0, 0(T0)                 488:       lw t0, 0(t0)
9D003784  26310004   ADDIU S1, S1, 4              489:       _dpush t0
9D003788  AE340000   SW S4, 0(S1)
9D00378C  0008A021   ADDU S4, ZERO, T0
9D003790  1000FEE5   BEQ ZERO, ZERO, 0x9D003328   490:       b vm
9D003794  00000000   NOP                          491:       nop
                                                  492:   
                                                  493:   drop:       # 'drop' ( n -- )
9D003798  00144021   ADDU T0, ZERO, S4            494:       _dpop t0
9D00379C  8E340000   LW S4, 0(S1)
9D0037A0  2631FFFC   ADDIU S1, S1, -4
9D0037A4  1000FEE0   BEQ ZERO, ZERO, 0x9D003328   495:       b vm
9D0037A8  00000000   NOP                          496:       nop
                                                  497:   
                                                  498:   ddrop:      # '2drop' ( n1 n2 -- )
9D0037AC  8E34FFFC   LW S4, -4(S1)                499:       lw topd, -4(dp)
9D0037B0  1000FEDD   BEQ ZERO, ZERO, 0x9D003328   500:       b vm
9D0037B4  2631FFF8   ADDIU S1, S1, -8             501:       addiu dp,dp,-8
                                                  502:   
                                                  503:   dup:        # 'dup' ( n -- n n )
9D0037B8  02804021   ADDU T0, S4, ZERO            504:       move t0, topd
9D0037BC  26310004   ADDIU S1, S1, 4              505:       _dpush t0
9D0037C0  AE340000   SW S4, 0(S1)
9D0037C4  0008A021   ADDU S4, ZERO, T0
9D0037C8  1000FED7   BEQ ZERO, ZERO, 0x9D003328   506:       b vm
9D0037CC  00000000   NOP                          507:       nop
                                                  508:   
                                                  509:   ddup:       # '2dup' ( n1 n2 -- n1 n2 n1 n2 )
9D0037D0  02804021   ADDU T0, S4, ZERO            510:       _fetch_t t0
9D0037D4  8E29FFFC   LW T1, -4(S1)                511:       _fetch_n t1, 2
9D0037D8  26310004   ADDIU S1, S1, 4              512:       _dpush t1
9D0037DC  AE340000   SW S4, 0(S1)
9D0037E0  0009A021   ADDU S4, ZERO, T1
9D0037E4  26310004   ADDIU S1, S1, 4              513:       _dpush t0
9D0037E8  AE340000   SW S4, 0(S1)
9D0037EC  0008A021   ADDU S4, ZERO, T0
9D0037F0  1000FECD   BEQ ZERO, ZERO, 0x9D003328   514:       b vm
9D0037F4  00000000   NOP                          515:       nop
                                                  516:   
                                                  517:   qdup:       # ?dup ( n -- n n | n ) duplique n si n!=0
9D0037F8  1280FECB   BEQ S4, ZERO, 0x9D003328     518:       beqz topd, vm
9D0037FC  00000000   NOP                          519:       nop
9D003800  26310004   ADDIU S1, S1, 4              520:       addiu dp, dp, (CELL_SIZE)
9D003804  1000FEC8   BEQ ZERO, ZERO, 0x9D003328   521:       b vm
9D003808  AE340000   SW S4, 0(S1)                 522:       sw topd, 0(dp)
                                                  523:   
                                                  524:   swap:       # 'swap' (n1 n2 -- n2 n1 )
9D00380C  02804021   ADDU T0, S4, ZERO            525:       _fetch_t t0
9D003810  8E340000   LW S4, 0(S1)                 526:       lw topd, 0(dp)
9D003814  1000FEC4   BEQ ZERO, ZERO, 0x9D003328   527:       b vm
9D003818  AE280000   SW T0, 0(S1)                 528:       sw t0, 0(dp)
                                                  529:   
                                                  530:   over:       # 'over' ( n1 n2 -- n1 n2 n1 )
9D00381C  8E28FFFC   LW T0, -4(S1)                531:       _fetch_n t0, 2
9D003820  26310004   ADDIU S1, S1, 4              532:       addiu dp, dp, (CELL_SIZE)
9D003824  AE340000   SW S4, 0(S1)                 533:       sw topd, 0(dp)
9D003828  1000FEBF   BEQ ZERO, ZERO, 0x9D003328   534:       b vm
9D00382C  0100A021   ADDU S4, T0, ZERO            535:       _store_t t0
                                                  536:   
                                                  537:   rot:        # rot ( n2 n1 n0 -- n1 n0 n2 )
9D003830  02804021   ADDU T0, S4, ZERO            538:       _fetch_t t0
9D003834  8E34FFFC   LW S4, -4(S1)                539:       _fetch_n topd, 2
9D003838  8E290000   LW T1, 0(S1)                 540:       _fetch_n t1, 1
9D00383C  AE29FFFC   SW T1, -4(S1)                541:       _store_n t1, 2
9D003840  AE280000   SW T0, 0(S1)                 542:       _store_n t0, 1 
9D003844  1000FEB8   BEQ ZERO, ZERO, 0x9D003328   543:       b vm
9D003848  00000000   NOP                          544:       nop
                                                  545:   
                                                  546:   plus:       # '+'   ( n1 n2 -- n1+n2 )
9D00384C  00144021   ADDU T0, ZERO, S4            547:       _dpop t0
9D003850  8E340000   LW S4, 0(S1)
9D003854  2631FFFC   ADDIU S1, S1, -4
9D003858  1000FEB3   BEQ ZERO, ZERO, 0x9D003328   548:       b vm
9D00385C  0288A021   ADDU S4, S4, T0              549:       addu topd,topd,t0
                                                  550:   
                                                  551:   plus1:      # '+1'  (n -- n+1 )
9D003860  1000FEB1   BEQ ZERO, ZERO, 0x9D003328   552:       b vm
9D003864  26940001   ADDIU S4, S4, 1              553:       addiu topd, topd, 1
                                                  554:   
                                                  555:   plusstore:  # '+!'  ( n addr -- ) *addr  = *addr+n
9D003868  00144021   ADDU T0, ZERO, S4            556:       _dpop t0
9D00386C  8E340000   LW S4, 0(S1)
9D003870  2631FFFC   ADDIU S1, S1, -4
9D003874  8D090000   LW T1, 0(T0)                 557:       lw t1, 0(t0)
9D003878  02894820   ADD T1, S4, T1               558:       add t1, topd, t1
9D00387C  AD090000   SW T1, 0(T0)                 559:       sw t1, 0(t0)
9D003880  00144021   ADDU T0, ZERO, S4            560:       _dpop t0
9D003884  8E340000   LW S4, 0(S1)
9D003888  2631FFFC   ADDIU S1, S1, -4
9D00388C  1000FEA6   BEQ ZERO, ZERO, 0x9D003328   561:       b vm
9D003890  00000000   NOP                          562:       nop
                                                  563:   
                                                  564:   minus:      # '-' ( n1 n2 -- n1-n2 )
9D003894  00144021   ADDU T0, ZERO, S4            565:       _dpop t0
9D003898  8E340000   LW S4, 0(S1)
9D00389C  2631FFFC   ADDIU S1, S1, -4
9D0038A0  0288A023   SUBU S4, S4, T0              566:       subu topd,topd,t0
9D0038A4  1000FEA0   BEQ ZERO, ZERO, 0x9D003328   567:       b vm
9D0038A8  00000000   NOP                          568:       nop
                                                  569:   
                                                  570:   minus1:     # '-1' ( n -- n-1 )
9D0038AC  1000FE9E   BEQ ZERO, ZERO, 0x9D003328   571:       b vm
9D0038B0  2694FFFF   ADDIU S4, S4, -1             572:       addiu topd, topd, -1
                                                  573:   
                                                  574:   multi:      # '*' ( n1 n2 -- n1*n2 )
9D0038B4  00144021   ADDU T0, ZERO, S4            575:       _dpop t0
9D0038B8  8E340000   LW S4, 0(S1)
9D0038BC  2631FFFC   ADDIU S1, S1, -4
9D0038C0  7288A002   MUL S4, S4, T0               576:       mul topd,topd,t0
9D0038C4  1000FE98   BEQ ZERO, ZERO, 0x9D003328   577:       b vm
9D0038C8  00000000   NOP                          578:       nop
                                                  579:   
                                                  580:   divi:      # '/' ( n1 n2 -- n1/n2 )
9D0038CC  00144021   ADDU T0, ZERO, S4            581:       _dpop t0
9D0038D0  8E340000   LW S4, 0(S1)
9D0038D4  2631FFFC   ADDIU S1, S1, -4
9D0038D8  010001F4   TEQ T0, ZERO                 582:       div topd,t0
9D0038DC  0288001A   DIV S4, T0
9D0038E0  2401FFFF   ADDIU AT, ZERO, -1
9D0038E4  15010002   BNE T0, AT, 0x9D0038F0
9D0038E8  3C018000   LUI AT, -32768
9D0038EC  028101B4   TEQ S4, AT
9D0038F0  0000A012   MFLO S4, 0
9D0038F4  1000FE8C   BEQ ZERO, ZERO, 0x9D003328   583:       b vm
9D0038F8  0000A012   MFLO S4, 0                   584:       mflo topd
                                                  585:   
                                                  586:   divmod:     # '/mod'  ( n1 n2 -- n1%n2 n1/n2 )
9D0038FC  02804021   ADDU T0, S4, ZERO            587:       _fetch_t t0
9D003900  8E290000   LW T1, 0(S1)                 588:       lw t1, 0(dp)
9D003904  010001F4   TEQ T0, ZERO                 589:       div t1, t0
9D003908  0128001A   DIV T1, T0
9D00390C  2401FFFF   ADDIU AT, ZERO, -1
9D003910  15010002   BNE T0, AT, 0x9D00391C
9D003914  3C018000   LUI AT, -32768
9D003918  012101B4   TEQ T1, AT
9D00391C  00004812   MFLO T1, 0
9D003920  0000A012   MFLO S4, 0                   590:       mflo topd
9D003924  00004810   MFHI T1, 0                   591:       mfhi t1
9D003928  AE290000   SW T1, 0(S1)                 592:       sw t1, 0(dp)
9D00392C  1000FE7E   BEQ ZERO, ZERO, 0x9D003328   593:       b vm
9D003930  00000000   NOP                          594:       nop
                                                  595:   
                                                  596:   lshift:     # '<<' ( n1 u -- n1<<u )
9D003934  00144021   ADDU T0, ZERO, S4            597:       _dpop t0
9D003938  8E340000   LW S4, 0(S1)
9D00393C  2631FFFC   ADDIU S1, S1, -4
9D003940  1000FE79   BEQ ZERO, ZERO, 0x9D003328   598:       b vm
9D003944  0114A004   SLLV S4, S4, T0              599:       sllv topd, topd, t0
                                                  600:   
                                                  601:   rshift:     # '>>'  ( n1 u -- n1>>u )
9D003948  00144021   ADDU T0, ZERO, S4            602:       _dpop t0
9D00394C  8E340000   LW S4, 0(S1)
9D003950  2631FFFC   ADDIU S1, S1, -4
9D003954  1000FE74   BEQ ZERO, ZERO, 0x9D003328   603:       b vm
9D003958  0114A006   SRLV S4, S4, T0              604:       srlv topd, topd, t0
                                                  605:   
                                                  606:   modulo:     # 'mod' ( n1 n2 -- n1%n2 )
9D00395C  00144021   ADDU T0, ZERO, S4            607:       _dpop t0
9D003960  8E340000   LW S4, 0(S1)
9D003964  2631FFFC   ADDIU S1, S1, -4
9D003968  010001F4   TEQ T0, ZERO                 608:       div topd,t0
9D00396C  0288001A   DIV S4, T0
9D003970  2401FFFF   ADDIU AT, ZERO, -1
9D003974  15010002   BNE T0, AT, 0x9D003980
9D003978  3C018000   LUI AT, -32768
9D00397C  028101B4   TEQ S4, AT
9D003980  0000A012   MFLO S4, 0
9D003984  1000FE68   BEQ ZERO, ZERO, 0x9D003328   609:       b vm
9D003988  0000A010   MFHI S4, 0                   610:       mfhi topd
                                                  611:   
                                                  612:   min:        # 'min' (n1 n2 -- min )  conserve le plus petit
9D00398C  00144021   ADDU T0, ZERO, S4            613:       _dpop t0
9D003990  8E340000   LW S4, 0(S1)
9D003994  2631FFFC   ADDIU S1, S1, -4
9D003998  02884823   SUBU T1, S4, T0              614:       subu t1,topd,t0
9D00399C  0520FE62   BLTZ T1, 0x9D003328          615:       bltz t1, vm
9D0039A0  00000000   NOP                          616:       nop
9D0039A4  1000FE60   BEQ ZERO, ZERO, 0x9D003328   617:       b vm
9D0039A8  0100A021   ADDU S4, T0, ZERO            618:       _store_t t0
                                                  619:   
                                                  620:   max:        # 'max' (n1 n2 -- max ) conserve le plus grand
9D0039AC  00144021   ADDU T0, ZERO, S4            621:       _dpop t0
9D0039B0  8E340000   LW S4, 0(S1)
9D0039B4  2631FFFC   ADDIU S1, S1, -4
9D0039B8  01144823   SUBU T1, T0, S4              622:       subu t1,t0,topd
9D0039BC  0520FE5A   BLTZ T1, 0x9D003328          623:       bltz t1, vm
9D0039C0  00000000   NOP                          624:       nop
9D0039C4  1000FE58   BEQ ZERO, ZERO, 0x9D003328   625:       b vm
9D0039C8  0100A021   ADDU S4, T0, ZERO            626:       _store_t t0
                                                  627:   
                                                  628:   abs:        # 'abs' ( n -- abs(n) )
9D0039CC  0680FE56   BLTZ S4, 0x9D003328          629:       bltz topd, vm
9D0039D0  0280A027   NOR S4, S4, ZERO             630:       not topd, topd
9D0039D4  1000FE54   BEQ ZERO, ZERO, 0x9D003328   631:       b vm
9D0039D8  00000000   NOP                          632:       nop
                                                  633:   
                                                  634:   ltz:   # '0<'  ( n -- t|f )
9D0039DC  0680FE52   BLTZ S4, 0x9D003328          635:       bltz topd, vm
9D0039E0  2414FFFF   ADDIU S4, ZERO, -1           636:       addiu topd,zero,-1
9D0039E4  1000FE50   BEQ ZERO, ZERO, 0x9D003328   637:       b vm
9D0039E8  0294A026   XOR S4, S4, S4               638:       xor topd,topd,topd
                                                  639:   
                                                  640:   bitand:     # 'and' ( n1 n2 -- n1&n2)
9D0039EC  00144021   ADDU T0, ZERO, S4            641:       _dpop t0
9D0039F0  8E340000   LW S4, 0(S1)
9D0039F4  2631FFFC   ADDIU S1, S1, -4
9D0039F8  1000FE4B   BEQ ZERO, ZERO, 0x9D003328   642:       b vm
9D0039FC  0288A024   AND S4, S4, T0               643:       and topd,topd,t0
                                                  644:   
                                                  645:   bitor:     # 'or' ( n1 n2 -- n1|n2)
9D003A00  00144021   ADDU T0, ZERO, S4            646:       _dpop t0
9D003A04  8E340000   LW S4, 0(S1)
9D003A08  2631FFFC   ADDIU S1, S1, -4
9D003A0C  1000FE46   BEQ ZERO, ZERO, 0x9D003328   647:       b vm
9D003A10  0288A025   OR S4, S4, T0                648:       or topd,topd,t0
                                                  649:   
                                                  650:   bitxor:     # 'xor' ( n1 n2 -- n1^n2)
9D003A14  00144021   ADDU T0, ZERO, S4            651:       _dpop t0
9D003A18  8E340000   LW S4, 0(S1)
9D003A1C  2631FFFC   ADDIU S1, S1, -4
9D003A20  1000FE41   BEQ ZERO, ZERO, 0x9D003328   652:       b vm
9D003A24  0288A026   XOR S4, S4, T0               653:       xor topd,topd,t0
                                                  654:   
                                                  655:   bitnot:     # 'not' ( n1 -- ~n1 )
9D003A28  1000FE3F   BEQ ZERO, ZERO, 0x9D003328   656:       b vm
9D003A2C  0280A027   NOR S4, S4, ZERO             657:       not topd, topd
                                                  658:   
                                                  659:   equal:      # '='  ( n1 n2 -- t|f ) n1==n2?
9D003A30  00144021   ADDU T0, ZERO, S4            660:       _dpop t0
9D003A34  8E340000   LW S4, 0(S1)
9D003A38  2631FFFC   ADDIU S1, S1, -4
9D003A3C  0288A026   XOR S4, S4, T0               661:       xor topd, topd, t0
9D003A40  1280FE39   BEQ S4, ZERO, 0x9D003328     662:       beqz topd, vm
9D003A44  2414FFFF   ADDIU S4, ZERO, -1           663:       addiu topd, zero, -1
9D003A48  1000FE37   BEQ ZERO, ZERO, 0x9D003328   664:       b vm
9D003A4C  0294A026   XOR S4, S4, S4               665:       xor topd, topd ,topd
                                                  666:   
                                                  667:   nequal:     # '<>' ( n1 n2 -- t|f ) n1<>n2?
9D003A50  00144021   ADDU T0, ZERO, S4            668:       _dpop t0
9D003A54  8E340000   LW S4, 0(S1)
9D003A58  2631FFFC   ADDIU S1, S1, -4
9D003A5C  02884026   XOR T0, S4, T0               669:       xor t0, topd, t0
9D003A60  1100FE31   BEQ T0, ZERO, 0x9D003328     670:       beqz t0, vm
9D003A64  0294A026   XOR S4, S4, S4               671:       xor topd, topd, topd
9D003A68  1000FE2F   BEQ ZERO, ZERO, 0x9D003328   672:       b vm
9D003A6C  2414FFFF   ADDIU S4, ZERO, -1           673:       addiu topd, zero, -1
                                                  674:   
                                                  675:   less:       # '<'  ( n1 n2 -- t|f ) n1<n2?
9D003A70  00144021   ADDU T0, ZERO, S4            676:       _dpop t0
9D003A74  8E340000   LW S4, 0(S1)
9D003A78  2631FFFC   ADDIU S1, S1, -4
9D003A7C  02884023   SUBU T0, S4, T0              677:       subu t0, topd, t0
9D003A80  0500FE29   BLTZ T0, 0x9D003328          678:       bltz t0, vm
9D003A84  2414FFFF   ADDIU S4, ZERO, -1           679:       addiu topd, zero, -1
9D003A88  1000FE27   BEQ ZERO, ZERO, 0x9D003328   680:       b vm
9D003A8C  0294A026   XOR S4, S4, S4               681:       xor topd, topd, topd
                                                  682:   
                                                  683:   greater:    # '>'  ( n1 n2 -- t|f ) n1>n2?
9D003A90  00144021   ADDU T0, ZERO, S4            684:       _dpop t0
9D003A94  8E340000   LW S4, 0(S1)
9D003A98  2631FFFC   ADDIU S1, S1, -4
9D003A9C  02884023   SUBU T0, S4, T0              685:       subu t0, topd, t0
9D003AA0  0500FE21   BLTZ T0, 0x9D003328          686:       bltz t0, vm
9D003AA4  0294A026   XOR S4, S4, S4               687:       xor topd, topd, topd
9D003AA8  1000FE1F   BEQ ZERO, ZERO, 0x9D003328   688:       b vm
9D003AAC  2414FFFF   ADDIU S4, ZERO, -1           689:       addiu topd, zero, -1
                                                  690:   
                                                  691:   ltez:        # '<=' ( n1 n2 -- t|f ) n1<=n2?
9D003AB0  00144021   ADDU T0, ZERO, S4            692:       _dpop t0
9D003AB4  8E340000   LW S4, 0(S1)
9D003AB8  2631FFFC   ADDIU S1, S1, -4
9D003ABC  02884023   SUBU T0, S4, T0              693:       subu t0, topd, t0
9D003AC0  1900FE19   BLEZ T0, 0x9D003328          694:       blez t0, vm
9D003AC4  2414FFFF   ADDIU S4, ZERO, -1           695:       addiu topd, zero, -1
9D003AC8  1000FE17   BEQ ZERO, ZERO, 0x9D003328   696:       b vm
9D003ACC  0294A026   XOR S4, S4, S4               697:       xor topd, topd, topd
                                                  698:   
                                                  699:   gtez:        # '>=' ( n1 n2 -- t|f ) n1>=n2?
9D003AD0  00144021   ADDU T0, ZERO, S4            700:       _dpop t0
9D003AD4  8E340000   LW S4, 0(S1)
9D003AD8  2631FFFC   ADDIU S1, S1, -4
9D003ADC  02884023   SUBU T0, S4, T0              701:       subu t0, topd, t0
9D003AE0  1900FE11   BLEZ T0, 0x9D003328          702:       blez t0, vm
9D003AE4  0294A026   XOR S4, S4, S4               703:       xor topd, topd, topd
9D003AE8  1000FE0F   BEQ ZERO, ZERO, 0x9D003328   704:       b vm
9D003AEC  2414FFFF   ADDIU S4, ZERO, -1           705:       addiu topd, zero, -1
                                                  706:   
                                                  707:   key:        #  ( -- char ) attend réception caractère par terminal
9D003AF0  3C04A000   LUI A0, -24576               708:       _getch comm_channel
9D003AF4  24840024   ADDIU A0, A0, 36
9D003AF8  0F401E95   JAL get_key
9D003AFC  80840000   LB A0, 0(A0)
9D003B00  26310004   ADDIU S1, S1, 4              709:       _dpush v0
9D003B04  AE340000   SW S4, 0(S1)
9D003B08  0002A021   ADDU S4, ZERO, V0
9D003B0C  1000FE06   BEQ ZERO, ZERO, 0x9D003328   710:       b vm
9D003B10  00000000   NOP                          711:       nop
                                                  712:   
                                                  713:   sfr:        # ( reg -- sfr ) transforme la valeur de registre 16 bits en addresse SFR
9D003B14  3C08BF88   LUI T0, -16504               714:       lui t0, SFR_SEG
9D003B18  3294FFFF   ANDI S4, S4, -1              715:       andi topd,topd, 65535
9D003B1C  1000FE02   BEQ ZERO, ZERO, 0x9D003328   716:       b vm
9D003B20  0288A025   OR S4, S4, T0                717:       or  topd,topd,t0
                                                  718:   
                                                  719:   set:        # ( bits sfr -- ) mets à 1 les bits du SFR
9D003B24  00144021   ADDU T0, ZERO, S4            720:       _dpop t0
9D003B28  8E340000   LW S4, 0(S1)
9D003B2C  2631FFFC   ADDIU S1, S1, -4
9D003B30  25080008   ADDIU T0, T0, 8              721:       addiu t0, t0,SFR_SET
9D003B34  00144821   ADDU T1, ZERO, S4            722:       _dpop t1
9D003B38  8E340000   LW S4, 0(S1)
9D003B3C  2631FFFC   ADDIU S1, S1, -4
9D003B40  1000FDF9   BEQ ZERO, ZERO, 0x9D003328   723:       b vm
9D003B44  AD090000   SW T1, 0(T0)                 724:       sw t1, 0(t0)
                                                  725:   
                                                  726:   clear:      # ( bits sfr -- ) met à 0 les bits du SFR
9D003B48  00144021   ADDU T0, ZERO, S4            727:       _dpop t0
9D003B4C  8E340000   LW S4, 0(S1)
9D003B50  2631FFFC   ADDIU S1, S1, -4
9D003B54  25080004   ADDIU T0, T0, 4              728:       addiu t0, t0, SFR_CLEAR
9D003B58  00144821   ADDU T1, ZERO, S4            729:       _dpop t1
9D003B5C  8E340000   LW S4, 0(S1)
9D003B60  2631FFFC   ADDIU S1, S1, -4
9D003B64  1000FDF0   BEQ ZERO, ZERO, 0x9D003328   730:       b vm
9D003B68  AD090000   SW T1, 0(T0)                 731:       sw t1, 0(t0)
                                                  732:   
                                                  733:   invert:     # ( bits sfr -- ) inverse la valeur des bits
9D003B6C  00144021   ADDU T0, ZERO, S4            734:       _dpop t0
9D003B70  8E340000   LW S4, 0(S1)
9D003B74  2631FFFC   ADDIU S1, S1, -4
9D003B78  2508000C   ADDIU T0, T0, 12             735:       addiu t0, t0,SFR_INV
9D003B7C  00144821   ADDU T1, ZERO, S4            736:       _dpop t1
9D003B80  8E340000   LW S4, 0(S1)
9D003B84  2631FFFC   ADDIU S1, S1, -4
9D003B88  1000FDE7   BEQ ZERO, ZERO, 0x9D003328   737:       b vm
9D003B8C  AD090000   SW T1, 0(T0)                 738:       sw t1, 0(t0)
                                                  739:   
                                                  740:   dotq:      # '."' ( -- ) ip pointe vers le texte, le premier octet est le compte.
9D003B90  82080000   LB T0, 0(S0)                 741:       ld_bytecode t0
9D003B94  310800FF   ANDI T0, T0, 255
9D003B98  26310004   ADDIU S1, S1, 4              742:       _dpush t0
9D003B9C  AE340000   SW S4, 0(S1)
9D003BA0  0008A021   ADDU S4, ZERO, T0
9D003BA4  26100001   ADDIU S0, S0, 1              743:       _next
                                                  744:   dotq_loop:
9D003BA8  1280000C   BEQ S4, ZERO, 0x9D003BDC     745:       beqz topd, dotq_exit
9D003BAC  2694FFFF   ADDIU S4, S4, -1             746:       addiu topd,topd,-1
9D003BB0  3C13A000   LUI S3, -24576               747:       lui wp, RAM_SEG
9D003BB4  3C04A000   LUI A0, -24576               748:       la a0, comm_channel
9D003BB8  24840024   ADDIU A0, A0, 36
9D003BBC  8C840000   LW A0, 0(A0)                 749:       lw a0, 0(a0)
9D003BC0  82050000   LB A1, 0(S0)                 750:       ld_bytecode a1
9D003BC4  30A500FF   ANDI A1, A1, 255
9D003BC8  0F401D21   JAL 0x9D007484               751:       jal put_char
9D003BCC  00000000   NOP                          752:       nop
9D003BD0  26100001   ADDIU S0, S0, 1              753:       _next
9D003BD4  1000FFF4   BEQ ZERO, ZERO, 0x9D003BA8   754:       b dotq_loop
9D003BD8  00000000   NOP                          755:       nop
                                                  756:   dotq_exit:
9D003BDC  00144021   ADDU T0, ZERO, S4            757:       _dpop t0
9D003BE0  8E340000   LW S4, 0(S1)
9D003BE4  2631FFFC   ADDIU S1, S1, -4
9D003BE8  1000FDCF   BEQ ZERO, ZERO, 0x9D003328   758:       b vm
9D003BEC  00000000   NOP                          759:       nop
                                                  760:   
                                                  761:   readln:    # 'accept' ( buff max -- count ) lecture ligne du terminal
9D003BF0  3C04A000   LUI A0, -24576               762:       la a0, comm_channel
9D003BF4  24840024   ADDIU A0, A0, 36
9D003BF8  8C840000   LW A0, 0(A0)                 763:       lw a0, 0(a0)
9D003BFC  00143021   ADDU A2, ZERO, S4            764:       _dpop a2
9D003C00  8E340000   LW S4, 0(S1)
9D003C04  2631FFFC   ADDIU S1, S1, -4
9D003C08  02802821   ADDU A1, S4, ZERO            765:       _fetch_t a1
9D003C0C  0F401ED5   JAL 0x9D007B54               766:       jal readline
9D003C10  00000000   NOP                          767:       nop
9D003C14  1000FDC4   BEQ ZERO, ZERO, 0x9D003328   768:       b vm
9D003C18  0040A021   ADDU S4, V0, ZERO            769:       _store_t v0
                                                  770:   
                                                  771:   type:   # 'type'  ( count buff -- ) envoie le texte dans buff au terminal
9D003C1C  3C04A000   LUI A0, -24576               772:       la a0, comm_channel
9D003C20  24840024   ADDIU A0, A0, 36
9D003C24  8C840000   LW A0, 0(A0)                 773:       lw a0, 0(a0)
9D003C28  00149821   ADDU S3, ZERO, S4            774:       _dpop wp
9D003C2C  8E340000   LW S4, 0(S1)
9D003C30  2631FFFC   ADDIU S1, S1, -4
                                                  775:   1:
9D003C34  0F401D21   JAL 0x9D007484               776:       jal put_char
9D003C38  82650000   LB A1, 0(S3)                 777:       lb a1,0(wp)
9D003C3C  26730001   ADDIU S3, S3, 1              778:       addiu wp, wp, 1
9D003C40  2694FFFF   ADDIU S4, S4, -1             779:       addiu topd, topd, -1
9D003C44  12800001   BEQ S4, ZERO, 0x9D003C4C     780:       beq topd, zero, 2f
9D003C48  1000FFFA   BEQ ZERO, ZERO, 0x9D003C34   781:       b 1b
                                                  782:   2:
9D003C4C  00144021   ADDU T0, ZERO, S4            783:       _dpop t0
9D003C50  8E340000   LW S4, 0(S1)
9D003C54  2631FFFC   ADDIU S1, S1, -4
9D003C58  1000FDB3   BEQ ZERO, ZERO, 0x9D003328   784:       b vm
9D003C5C  00000000   NOP                          785:       nop
                                                  786:   
                                                  787:   
                                                  788:   delay:  # 'delay' ( msec -- ) delay en millisecondes
9D003C60  3C13A000   LUI S3, -24576               789:       la wp, sys_tick
9D003C64  26730044   ADDIU S3, S3, 68
9D003C68  8E680000   LW T0, 0(S3)                 790:       lw t0, 0(wp)
9D003C6C  0288A021   ADDU S4, S4, T0              791:       addu topd, topd, t0
                                                  792:   1:
9D003C70  8E680000   LW T0, 0(S3)                 793:       lw t0, 0(wp)
9D003C74  02884023   SUBU T0, S4, T0              794:       subu t0,topd,t0
9D003C78  1500FFFD   BNE T0, ZERO, 0x9D003C70     795:       bne t0,zero, 1b
9D003C7C  00000000   NOP                          796:       nop
9D003C80  00144021   ADDU T0, ZERO, S4            797:       _dpop t0
9D003C84  8E340000   LW S4, 0(S1)
9D003C88  2631FFFC   ADDIU S1, S1, -4
9D003C8C  1000FDA6   BEQ ZERO, ZERO, 0x9D003328   798:       b vm
9D003C90  00000000   NOP                          799:       nop
                                                  800:   
                                                  801:   badop:
9D003C94  01001021   ADDU V0, T0, ZERO            802:       move v0,t0
                                                  803:   exit:
9D003C98  8FB00018   LW S0, 24(SP)                804:       lw  s0,24(sp)
9D003C9C  8FB10014   LW S1, 20(SP)                805:       lw  s1,20(sp)
9D003CA0  8FB20010   LW S2, 16(SP)                806:       lw  s2,16(sp)
9D003CA4  8FB3000C   LW S3, 12(SP)                807:       lw  s3,12(sp)
9D003CA8  8FB40008   LW S4, 8(SP)                 808:       lw  s4,8(sp)
9D003CAC  8FB50004   LW S5, 4(SP)                 809:       lw  s5,4(sp)
9D003CB0  8FBF001C   LW RA, 28(SP)                810:       _fn_exit 32
9D003CB4  03E00008   JR RA
9D003CB8  27BD0020   ADDIU SP, SP, 32
                                                  811:   .end StackVM
                                                  812:   
                                                  813:   .ent fetch_int
                                                  814:   fetch_int:  # lit un entier little indian dans espace code VM
9D003CBC  92080000   LBU T0, 0(S0)                815:       lbu t0, 0(ip)
9D003CC0  92090001   LBU T1, 1(S0)                816:       lbu t1, 1(ip)
9D003CC4  00094A00   SLL T1, T1, 8                817:       sll  t1,t1, 8
9D003CC8  920A0002   LBU T2, 2(S0)                818:       lbu t2, 2(ip)
9D003CCC  000A5400   SLL T2, T2, 16               819:       sll t2,t2, 16
9D003CD0  820B0003   LB T3, 3(S0)                 820:       lb t3, 3(ip)
9D003CD4  000B5E00   SLL T3, T3, 24               821:       sll t3,t3, 24
9D003CD8  01094025   OR T0, T0, T1                822:       or  t0,t0,t1
9D003CDC  010A4025   OR T0, T0, T2                823:       or  t0,t0,t2
9D003CE0  010B1025   OR V0, T0, T3                824:       or  v0,t0,t3
9D003CE4  26100004   ADDIU S0, S0, 4              825:       addiu ip,ip,CELL_SIZE
9D003CE8  03E00008   JR RA                        826:       j ra
9D003CEC  00000000   NOP                          827:       nop
                                                  828:   .end fetch_int
                                                  829:   
                                                  830:   .ent dbg_putch    # envoie un caratère vers UART2
                                                  831:   dbg_putch:        # a0 contient le caractère
9D003CF0  3C0EBF80   LUI T6, -16512               832:       la t6, U2STA
9D003CF4  25CE6210   ADDIU T6, T6, 25104
                                                  833:   1:
9D003CF8  8DCD0000   LW T5, 0(T6)                 834:       lw t5,0(t6)
9D003CFC  31AD0200   ANDI T5, T5, 512             835:       andi t5, _U1STA_UTXBF_MASK
9D003D00  15A0FFFD   BNE T5, ZERO, 0x9D003CF8     836:       bne t5, zero,  1b
9D003D04  00000000   NOP                          837:       nop
9D003D08  3C0EBF80   LUI T6, -16512               838:       la t6, U2TXREG
9D003D0C  25CE6220   ADDIU T6, T6, 25120
9D003D10  ADC40000   SW A0, 0(T6)                 839:       sw a0, 0(t6)
9D003D14  03E00008   JR RA                        840:       j ra
9D003D18  00000000   NOP                          841:       nop
                                                  842:   .end dbg_putch
                                                  843:   
                                                  844:   .ent dbg_print    # envoie une chaine de caractère asciiz vers UART2
                                                  845:                     # a0 contient le numéro du point de contrôle
                                                  846:   dbg_print:
9D003D1C  27BDFFFC   ADDIU SP, SP, -4             847:       _fn_enter 4
9D003D20  AFBF0000   SW RA, 0(SP)
9D003D24  26310004   ADDIU S1, S1, 4              848:       _dpush a0
9D003D28  AE340000   SW S4, 0(S1)
9D003D2C  0004A021   ADDU S4, ZERO, A0
9D003D30  3C0F9D00   LUI T7, -25344               849:       la t7, dbg_tag
9D003D34  25EF3D98   ADDIU T7, T7, 15768
9D003D38  26310004   ADDIU S1, S1, 4              850:       _dpush t7
9D003D3C  AE340000   SW S4, 0(S1)
9D003D40  000FA021   ADDU S4, ZERO, T7
                                                  851:   1:
9D003D44  82840000   LB A0, 0(S4)                 852:       lb a0, 0(topd)
9D003D48  3084007F   ANDI A0, A0, 127             853:       andi a0, a0, 0x7f
9D003D4C  10800004   BEQ A0, ZERO, 0x9D003D60     854:       beqz a0, 2f
9D003D50  0F400F3C   JAL 0x9D003CF0               855:       jal dbg_putch
9D003D54  00000000   NOP                          856:       nop
9D003D58  26940001   ADDIU S4, S4, 1              857:       addiu topd,topd,1
9D003D5C  1000FFF9   BEQ ZERO, ZERO, 0x9D003D44   858:       b 1b
                                                  859:   2:
9D003D60  00147821   ADDU T7, ZERO, S4            860:       _dpop t7
9D003D64  8E340000   LW S4, 0(S1)
9D003D68  2631FFFC   ADDIU S1, S1, -4
9D003D6C  00142021   ADDU A0, ZERO, S4            861:       _dpop a0
9D003D70  8E340000   LW S4, 0(S1)
9D003D74  2631FFFC   ADDIU S1, S1, -4
9D003D78  0F400F3C   JAL 0x9D003CF0               862:       jal dbg_putch
9D003D7C  00000000   NOP                          863:       nop
9D003D80  2404000D   ADDIU A0, ZERO, 13           864:       li a0, '\r'
9D003D84  0F400F3C   JAL 0x9D003CF0               865:       jal dbg_putch
9D003D88  00000000   NOP                          866:       nop
9D003D8C  8FBF0000   LW RA, 0(SP)                 867:       _fn_exit 4
9D003D90  03E00008   JR RA
9D003D94  27BD0004   ADDIU SP, SP, 4
9D003D98  75626564   JALX 0x95899590
9D003DA0  206B6365   ADDI T3, V1, 25445
9D003DA8  00203A74   TEQ AT, ZERO
9D003ECC  00000000   NOP
9D003ED0  00000000   NOP
9D003ED4  00000000   NOP
9D003ED8  00000000   NOP
9D003EDC  00000000   NOP
9D003EE0  00000000   NOP
9D003EE4  00000000   NOP
9D003EE8  00000000   NOP
9D003EEC  00000000   NOP
9D003EF0  00000000   NOP
9D003EF4  00000000   NOP
9D003EF8  00000000   NOP
9D003EFC  00000000   NOP
9D003F00  00000000   NOP
9D003F04  00000000   NOP
9D003F08  00000000   NOP
9D003F0C  00000000   NOP
9D003F10  00000000   NOP
9D003F14  00000000   NOP
9D003F18  00000000   NOP
9D003F1C  00000000   NOP
9D003F20  00000000   NOP
9D003F24  00000000   NOP
9D003F28  00000000   NOP
9D003F2C  00000000   NOP
9D003F30  00000000   NOP
9D003F34  00000000   NOP
9D003F38  00000000   NOP
9D003F3C  00000000   NOP
9D003F40  00000000   NOP
9D003F44  00000000   NOP
9D003F48  00000000   NOP
9D003F4C  00000000   NOP
9D003F50  00000000   NOP
9D003F54  00000000   NOP
9D003F58  00000000   NOP
9D003F5C  00000000   NOP
9D003F60  00000000   NOP
9D003F64  00000000   NOP
9D003F68  00000000   NOP
9D003F6C  00000000   NOP
9D003F70  00000000   NOP
9D003F74  00000000   NOP
9D003F78  00000000   NOP
9D003F7C  00000000   NOP
9D003F80  00000000   NOP
9D003F84  00000000   NOP
9D003F88  00000000   NOP
9D003F8C  00000000   NOP
9D003F90  00000000   NOP
9D003F94  00000000   NOP
9D003F98  00000000   NOP
9D003F9C  00000000   NOP
9D003FA0  00000000   NOP
9D003FA4  00000000   NOP
9D003FA8  00000000   NOP
9D003FAC  00000000   NOP
9D003FB0  00000000   NOP
9D003FB4  00000000   NOP
9D003FB8  00000000   NOP
9D003FBC  00000000   NOP
9D003FC0  00000000   NOP
9D003FC4  00000000   NOP
9D003FC8  00000000   NOP
9D003FCC  00000000   NOP
9D003FD0  00000000   NOP
9D003FD4  00000000   NOP
9D003FD8  00000000   NOP
9D003FDC  00000000   NOP
9D003FE0  00000000   NOP
9D003FE4  00000000   NOP
9D003FE8  00000000   NOP
9D003FEC  00000000   NOP
9D003FF0  00000000   NOP
9D003FF4  00000000   NOP
9D003FF8  00000000   NOP
9D003FFC  00000000   NOP
9D004000  00000000   NOP
9D004004  00000000   NOP
9D004008  00000000   NOP
9D00400C  00000000   NOP
9D004010  00000000   NOP
9D004014  00000000   NOP
9D004018  00000000   NOP
9D00401C  00000000   NOP
9D004020  00000000   NOP
9D004024  00000000   NOP
9D004028  00000000   NOP
9D00402C  00000000   NOP
9D004030  00000000   NOP
9D004034  00000000   NOP
9D004038  00000000   NOP
9D00403C  00000000   NOP
9D004040  00000000   NOP
9D004044  00000000   NOP
9D004048  00000000   NOP
9D00404C  00000000   NOP
9D004050  00000000   NOP
9D004054  00000000   NOP
9D004058  00000000   NOP
9D00405C  00000000   NOP
9D004060  00000000   NOP
9D004064  00000000   NOP
9D004068  00000000   NOP
9D00406C  00000000   NOP
9D004070  00000000   NOP
9D004074  00000000   NOP
9D004078  00000000   NOP
9D00407C  00000000   NOP
9D004080  00000000   NOP
9D004084  00000000   NOP
9D004088  00000000   NOP
9D00408C  00000000   NOP
9D004090  00000000   NOP
9D004094  00000000   NOP
9D004098  00000000   NOP
9D00409C  00000000   NOP
9D0040A0  00000000   NOP
9D0040A4  00000000   NOP
9D0040A8  00000000   NOP
9D0040AC  00000000   NOP
9D0040B0  00000000   NOP
9D0040B4  00000000   NOP
9D0040B8  00000000   NOP
9D0040BC  00000000   NOP
9D0040C0  00000000   NOP
9D0040C4  00000000   NOP
9D0040C8  00000000   NOP
9D0040CC  00000000   NOP
9D0040D0  00000000   NOP
9D0040D4  00000000   NOP
9D0040D8  00000000   NOP
9D0040DC  00000000   NOP
9D0040E0  00000000   NOP
9D0040E4  00000000   NOP
9D0040E8  00000000   NOP
9D0040EC  00000000   NOP
9D0040F0  00000000   NOP
9D0040F4  00000000   NOP
9D0040F8  00000000   NOP
9D0040FC  00000000   NOP
9D004100  00000000   NOP
9D004104  00000000   NOP
9D004108  00000000   NOP
9D00410C  00000000   NOP
9D004110  00000000   NOP
9D004114  00000000   NOP
9D004118  00000000   NOP
9D00411C  00000000   NOP
9D004120  00000000   NOP
9D004124  00000000   NOP
9D004128  00000000   NOP
9D00412C  00000000   NOP
9D004130  00000000   NOP
9D004134  00000000   NOP
9D004138  00000000   NOP
9D00413C  00000000   NOP
9D004140  00000000   NOP
9D004144  00000000   NOP
9D004148  00000000   NOP
9D00414C  00000000   NOP
9D004150  00000000   NOP
9D004154  00000000   NOP
9D004158  00000000   NOP
9D00415C  00000000   NOP
9D004160  00000000   NOP
9D004164  00000000   NOP
9D004168  00000000   NOP
9D00416C  00000000   NOP
9D004170  00000000   NOP
9D004174  00000000   NOP
9D004178  00000000   NOP
9D00417C  00000000   NOP
9D004180  00000000   NOP
9D004184  00000000   NOP
9D004188  00000000   NOP
9D00418C  00000000   NOP
9D004190  00000000   NOP
9D004194  00000000   NOP
9D004198  00000000   NOP
9D00419C  00000000   NOP
9D0041A0  00000000   NOP
9D0041A4  00000000   NOP
9D0041A8  00000000   NOP
9D0041AC  00000000   NOP
9D0041B0  00000000   NOP
9D0041B4  00000000   NOP
9D0041B8  00000000   NOP
9D0041BC  00000000   NOP
9D0041C0  00000000   NOP
9D0041C4  00000000   NOP
9D0041C8  00000000   NOP
9D0041CC  00000000   NOP
9D0041D0  00000000   NOP
9D0041D4  00000000   NOP
9D0041D8  00000000   NOP
9D0041DC  00000000   NOP
9D0041E0  00000000   NOP
9D0041E4  00000000   NOP
9D0041E8  00000000   NOP
9D0041EC  00000000   NOP
9D0041F0  00000000   NOP
9D0041F4  00000000   NOP
9D0041F8  00000000   NOP
9D0041FC  00000000   NOP
9D004200  00000000   NOP
9D004204  00000000   NOP
9D004208  00000000   NOP
9D00420C  00000000   NOP
9D004210  00000000   NOP
9D004214  00000000   NOP
9D004218  00000000   NOP
9D00421C  00000000   NOP
9D004220  00000000   NOP
9D004224  00000000   NOP
9D004228  00000000   NOP
9D00422C  00000000   NOP
9D004230  00000000   NOP
9D004234  00000000   NOP
9D004238  00000000   NOP
9D00423C  00000000   NOP
9D004240  00000000   NOP
9D004244  00000000   NOP
9D004248  00000000   NOP
9D00424C  00000000   NOP
9D004250  00000000   NOP
9D004254  00000000   NOP
9D004258  00000000   NOP
9D00425C  00000000   NOP
9D004260  00000000   NOP
9D004264  00000000   NOP
9D004268  00000000   NOP
9D00426C  00000000   NOP
9D004270  00000000   NOP
9D004274  00000000   NOP
9D004278  00000000   NOP
9D00427C  00000000   NOP
9D004280  00000000   NOP
9D004284  00000000   NOP
9D004288  00000000   NOP
9D00428C  00000000   NOP
9D004290  00000000   NOP
9D004294  00000000   NOP
9D004298  00000000   NOP
9D00429C  00000000   NOP
9D0042A0  00000000   NOP
9D0042A4  00000000   NOP
9D0042A8  00000000   NOP
9D0042AC  00000000   NOP
9D0042B0  00000000   NOP
9D0042B4  00000000   NOP
9D0042B8  00000000   NOP
9D0042BC  00000000   NOP
9D0042C0  00000000   NOP
9D0042C4  00000000   NOP
9D0042C8  00000000   NOP
9D0042CC  00000000   NOP
9D0042D0  00000000   NOP
9D0042D4  00000000   NOP
9D0042D8  00000000   NOP
9D0042DC  00000000   NOP
9D0042E0  00000000   NOP
9D0042E4  00000000   NOP
9D0042E8  00000000   NOP
9D0042EC  00000000   NOP
9D0042F0  00000000   NOP
9D0042F4  00000000   NOP
9D0042F8  00000000   NOP
9D0042FC  00000000   NOP
9D004300  00000000   NOP
9D004304  00000000   NOP
9D004308  00000000   NOP
9D00430C  00000000   NOP
9D004310  00000000   NOP
9D004314  00000000   NOP
9D004318  00000000   NOP
9D00431C  00000000   NOP
9D004320  00000000   NOP
9D004324  00000000   NOP
9D004328  00000000   NOP
9D00432C  00000000   NOP
9D004330  00000000   NOP
9D004334  00000000   NOP
9D004338  00000000   NOP
9D00433C  00000000   NOP
9D004340  00000000   NOP
9D004344  00000000   NOP
9D004348  00000000   NOP
9D00434C  00000000   NOP
9D004350  00000000   NOP
9D004354  00000000   NOP
9D004358  00000000   NOP
9D00435C  00000000   NOP
9D004360  00000000   NOP
9D004364  00000000   NOP
9D004368  00000000   NOP
9D00436C  00000000   NOP
9D004370  00000000   NOP
9D004374  00000000   NOP
9D004378  00000000   NOP
9D00437C  00000000   NOP
9D004380  00000000   NOP
9D004384  00000000   NOP
9D004388  00000000   NOP
9D00438C  00000000   NOP
9D004390  00000000   NOP
9D004394  00000000   NOP
9D004398  00000000   NOP
9D00439C  00000000   NOP
9D0043A0  00000000   NOP
9D0043A4  00000000   NOP
9D0043A8  00000000   NOP
9D0043AC  00000000   NOP
9D0043B0  00000000   NOP
9D0043B4  00000000   NOP
9D0043B8  00000000   NOP
9D0043BC  00000000   NOP
9D0043C0  00000000   NOP
9D0043C4  00000000   NOP
9D0043C8  00000000   NOP
9D0043CC  00000000   NOP
9D0043D0  00000000   NOP
9D0043D4  00000000   NOP
9D0043D8  00000000   NOP
9D0043DC  00000000   NOP
9D0043E0  00000000   NOP
9D0043E4  00000000   NOP
9D0043E8  00000000   NOP
9D0043EC  00000000   NOP
9D0043F0  00000000   NOP
9D0043F4  00000000   NOP
9D0043F8  00000000   NOP
9D0043FC  00000000   NOP
9D004400  00000000   NOP
9D004404  00000000   NOP
9D004408  00000000   NOP
9D00440C  00000000   NOP
9D004410  00000000   NOP
9D004414  00000000   NOP
9D004418  00000000   NOP
9D00441C  00000000   NOP
9D004420  00000000   NOP
9D004424  00000000   NOP
9D004428  00000000   NOP
9D00442C  00000000   NOP
9D004430  00000000   NOP
9D004434  00000000   NOP
9D004438  00000000   NOP
9D00443C  00000000   NOP
9D004440  00000000   NOP
9D004444  00000000   NOP
9D004448  00000000   NOP
9D00444C  00000000   NOP
9D004450  00000000   NOP
9D004454  00000000   NOP
9D004458  00000000   NOP
9D00445C  00000000   NOP
9D004460  00000000   NOP
9D004464  00000000   NOP
9D004468  00000000   NOP
9D00446C  00000000   NOP
9D004470  00000000   NOP
9D004474  00000000   NOP
9D004478  00000000   NOP
9D00447C  00000000   NOP
9D004480  00000000   NOP
9D004484  00000000   NOP
9D004488  00000000   NOP
9D00448C  00000000   NOP
9D004490  00000000   NOP
9D004494  00000000   NOP
9D004498  00000000   NOP
9D00449C  00000000   NOP
9D0044A0  00000000   NOP
9D0044A4  00000000   NOP
9D0044A8  00000000   NOP
9D0044AC  00000000   NOP
9D0044B0  00000000   NOP
9D0044B4  00000000   NOP
9D0044B8  00000000   NOP
9D0044BC  00000000   NOP
9D0044C0  00000000   NOP
9D0044C4  00000000   NOP
9D0044C8  00000000   NOP
9D0044CC  00000000   NOP
9D0044D0  00000000   NOP
9D0044D4  00000000   NOP
9D0044D8  00000000   NOP
9D0044DC  00000000   NOP
9D0044E0  00000000   NOP
9D0044E4  00000000   NOP
9D0044E8  00000000   NOP
9D0044EC  00000000   NOP
9D0044F0  00000000   NOP
9D0044F4  00000000   NOP
9D0044F8  00000000   NOP
9D0044FC  00000000   NOP
9D004500  00000000   NOP
9D004504  00000000   NOP
9D004508  00000000   NOP
9D00450C  00000000   NOP
9D004510  00000000   NOP
9D004514  00000000   NOP
9D004518  00000000   NOP
9D00451C  00000000   NOP
9D004520  00000000   NOP
9D004524  00000000   NOP
9D004528  00000000   NOP
9D00452C  00000000   NOP
9D004530  00000000   NOP
9D004534  00000000   NOP
9D004538  00000000   NOP
9D00453C  00000000   NOP
9D004540  00000000   NOP
9D004544  00000000   NOP
9D004548  00000000   NOP
9D00454C  00000000   NOP
9D004550  00000000   NOP
9D004554  00000000   NOP
9D004558  00000000   NOP
9D00455C  00000000   NOP
9D004560  00000000   NOP
9D004564  00000000   NOP
9D004568  00000000   NOP
9D00456C  00000000   NOP
9D004570  00000000   NOP
9D004574  00000000   NOP
9D004578  00000000   NOP
9D00457C  00000000   NOP
9D004580  00000000   NOP
9D004584  00000000   NOP
9D004588  00000000   NOP
9D00458C  00000000   NOP
9D004590  00000000   NOP
9D004594  00000000   NOP
9D004598  00000000   NOP
9D00459C  00000000   NOP
9D0045A0  00000000   NOP
9D0045A4  00000000   NOP
9D0045A8  00000000   NOP
9D0045AC  00000000   NOP
9D0045B0  00000000   NOP
9D0045B4  00000000   NOP
9D0045B8  00000000   NOP
9D0045BC  00000000   NOP
9D0045C0  00000000   NOP
9D0045C4  00000000   NOP
9D0045C8  00000000   NOP
9D0045CC  00000000   NOP
9D0045D0  00000000   NOP
9D0045D4  00000000   NOP
9D0045D8  00000000   NOP
9D0045DC  00000000   NOP
9D0045E0  00000000   NOP
9D0045E4  00000000   NOP
9D0045E8  00000000   NOP
9D0045EC  00000000   NOP
9D0045F0  00000000   NOP
9D0045F4  00000000   NOP
9D0045F8  00000000   NOP
9D0045FC  00000000   NOP
9D004600  00000000   NOP
9D004604  00000000   NOP
9D004608  00000000   NOP
9D00460C  00000000   NOP
9D004610  00000000   NOP
9D004614  00000000   NOP
9D004618  00000000   NOP
9D00461C  00000000   NOP
9D004620  00000000   NOP
9D004624  00000000   NOP
9D004628  00000000   NOP
9D00462C  00000000   NOP
9D004630  00000000   NOP
9D004634  00000000   NOP
9D004638  00000000   NOP
9D00463C  00000000   NOP
9D004640  00000000   NOP
9D004644  00000000   NOP
9D004648  00000000   NOP
9D00464C  00000000   NOP
9D004650  00000000   NOP
9D004654  00000000   NOP
9D004658  00000000   NOP
9D00465C  00000000   NOP
9D004660  00000000   NOP
9D004664  00000000   NOP
9D004668  00000000   NOP
9D00466C  00000000   NOP
9D004670  00000000   NOP
9D004674  00000000   NOP
9D004678  00000000   NOP
9D00467C  00000000   NOP
9D004680  00000000   NOP
9D004684  00000000   NOP
9D004688  00000000   NOP
9D00468C  00000000   NOP
9D004690  00000000   NOP
9D004694  00000000   NOP
9D004698  00000000   NOP
9D00469C  00000000   NOP
9D0046A0  00000000   NOP
9D0046A4  00000000   NOP
9D0046A8  00000000   NOP
9D0046AC  00000000   NOP
9D0046B0  00000000   NOP
9D0046B4  00000000   NOP
9D0046B8  00000000   NOP
9D0046BC  00000000   NOP
9D0046C0  00000000   NOP
9D0046C4  00000000   NOP
9D0046C8  00000000   NOP
                                                  868:   .end dbg_print
                                                  869:   
                                                  870:   dbg_tag:
                                                  871:   .string "debug check point: "
                                                  872:   
                                                  873:   
                                                  874:   opcodes_vectors:
                                                  875:   .word end,qrx,emit,lit,fcall,ret,bra,qbra,exec,store,fetch,cstore
                                                  876:   .word cfetch,rpfetch,rpstore,rfetch,tor,rfrom,spfetch,spstore,drop,dup,swap,over
                                                  877:   .word plus,minus,multi,divi,modulo,ltz,bitand,bitor,bitxor,bitnot,key
                                                  878:   .word sfr,set,clear,invert
                                                  879:   .word clit, wlit
                                                  880:   .word dotq, readln,rcall, type
                                                  881:   .word delay
                                                  882:   .word qdup, plus1, minus1,plusstore, ddrop, rot, ddup
                                                  883:   .word  min, max, abs, lshift, rshift, divmod
                                                  884:   .word qbraz, dot, zerosp, zerorp, herefetch,basefetch
                                                  885:   .word equal,nequal, less, greater,ltez,gtez, iemit
                                                  886:   
                                                  887:   flash_code: .space FLASH_SIZE
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/sound.c  ------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   sound.c
20:                   * Author: Jacques Deschênes
21:                   *
22:                   * Created on 13 septembre 2013, 20:42
23:                   */
24:                  
25:                  #include "hardware/HardwareProfile.h"
26:                  
27:                  volatile unsigned char tone_on=0;
28:                  volatile unsigned int duration;
29:                  
30:                  void tone(unsigned int freq, // fréquence en hertz
31:                            unsigned int msec){ // durée en  millisecondes
32:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
33:                      OC3CONbits.OCM = 5; //mode pwm
9D00A040  3C02BF80   LUI V0, -16512
9D00A044  8C433400   LW V1, 13312(V0)
9D00A048  24060005   ADDIU A2, ZERO, 5
9D00A04C  7CC31004   INS V1, A2, 0, 3
9D00A050  AC433400   SW V1, 13312(V0)
34:                      OC3CONbits.OCTSEL=1; // timer 3
9D00A054  8C463400   LW A2, 13312(V0)
9D00A058  24030001   ADDIU V1, ZERO, 1
9D00A05C  7C6618C4   INS A2, V1, 3, 1
9D00A060  AC463400   SW A2, 13312(V0)
35:                      T3CON=0;
9D00A064  3C06BF80   LUI A2, -16512
9D00A068  ACC00A00   SW ZERO, 2560(A2)
36:                      PR3=(SYSCLK/8/freq)-1; // rapport cyclique 50%
9D00A06C  3C060047   LUI A2, 71
9D00A070  34C6868C   ORI A2, A2, -31092
9D00A074  00C4001B   DIVU A2, A0
9D00A078  008001F4   TEQ A0, ZERO
9D00A07C  00003012   MFLO A2, 0
9D00A080  24C6FFFF   ADDIU A2, A2, -1
9D00A084  3C07BF80   LUI A3, -16512
9D00A088  ACE60A20   SW A2, 2592(A3)
37:                      OC3RS=0;
9D00A08C  3C06BF80   LUI A2, -16512
9D00A090  ACC03420   SW ZERO, 13344(A2)
38:                      OC3R=SYSCLK/16/freq;
9D00A094  3C060023   LUI A2, 35
9D00A098  34C6C346   ORI A2, A2, -15546
9D00A09C  00C4001B   DIVU A2, A0
9D00A0A0  008001F4   TEQ A0, ZERO
9D00A0A4  00003012   MFLO A2, 0
9D00A0A8  3C07BF80   LUI A3, -16512
9D00A0AC  ACE63410   SW A2, 13328(A3)
39:                      OC3CONbits.ON=1;
9D00A0B0  8C443400   LW A0, 13312(V0)
9D00A0B4  7C647BC4   INS A0, V1, 15, 1
9D00A0B8  AC443400   SW A0, 13312(V0)
40:                      duration=msec;
9D00A0BC  AF858088   SW A1, -32632(GP)
41:                      tone_on=1;
9D00A0C0  A3838044   SB V1, -32700(GP)
42:                      T3CONbits.TCKPS=3;
9D00A0C4  3C02BF80   LUI V0, -16512
9D00A0C8  8C440A00   LW A0, 2560(V0)
9D00A0CC  24050003   ADDIU A1, ZERO, 3
9D00A0D0  7CA43104   INS A0, A1, 4, 3
9D00A0D4  AC440A00   SW A0, 2560(V0)
43:                      T3CONbits.ON=1;
9D00A0D8  8C440A00   LW A0, 2560(V0)
9D00A0DC  7C647BC4   INS A0, V1, 15, 1
9D00A0E0  AC440A00   SW A0, 2560(V0)
44:                  } //tone();
9D00A0E4  03E00008   JR RA
9D00A0E8  00000000   NOP
45:                  
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/serial_comm.c  ---------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   uart.h
20:                   * Author: Jacques Deschênes
21:                   * Description: fonctions de bas niveau pour communication UART avec le PC
22:                   * Created on 17 avril 2013, 14:48
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "serial_comm.h"
27:                  #include "HardwareProfile.h"
28:                  
29:                  static char unget;
30:                  
31:                  void UartInit(UART_MODULE channel, int baudrate, UART_LINE_CONTROL_MODE LineCtrl){
9D0084FC  27BDFFE0   ADDIU SP, SP, -32
9D008500  AFBF001C   SW RA, 28(SP)
9D008504  AFB20018   SW S2, 24(SP)
9D008508  AFB10014   SW S1, 20(SP)
9D00850C  AFB00010   SW S0, 16(SP)
9D008510  00808021   ADDU S0, A0, ZERO
9D008514  00A09021   ADDU S2, A1, ZERO
9D008518  00C08821   ADDU S1, A2, ZERO
32:                  /*initialise le périphérique UART*/
33:                     // Configure UART, information dans uart.h
34:                     UARTConfigure(channel, UART_ENABLE_PINS_TX_RX_ONLY); // pas de contrôle de flux matériel.
9D00851C  0F402930   JAL UARTConfigure
9D008520  00002821   ADDU A1, ZERO, ZERO
35:                     UARTSetLineControl(channel, LineCtrl);
9D008524  02002021   ADDU A0, S0, ZERO
9D008528  0F4029BE   JAL UARTSetLineControl
9D00852C  02202821   ADDU A1, S1, ZERO
36:                     UARTSetDataRate(channel, mGetPeripheralClock(), baudrate);
9D008530  02002021   ADDU A0, S0, ZERO
9D008534  3C05023C   LUI A1, 572
9D008538  24A53460   ADDIU A1, A1, 13408
9D00853C  0F4028C4   JAL UARTSetDataRate
9D008540  02403021   ADDU A2, S2, ZERO
37:                     // activation du périphérique
38:                     UARTEnable(channel, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D008544  02002021   ADDU A0, S0, ZERO
9D008548  0F40288B   JAL UARTEnable
9D00854C  24050087   ADDIU A1, ZERO, 135
39:                     unget=-1;
9D008550  2402FFFF   ADDIU V0, ZERO, -1
9D008554  A3828024   SB V0, -32732(GP)
40:                  };
9D008558  8FBF001C   LW RA, 28(SP)
9D00855C  8FB20018   LW S2, 24(SP)
9D008560  8FB10014   LW S1, 20(SP)
9D008564  8FB00010   LW S0, 16(SP)
9D008568  03E00008   JR RA
9D00856C  27BD0020   ADDIU SP, SP, 32
41:                  
42:                  char UartGetch(UART_MODULE channel){
43:                  /*lecture d'un caractère retourne 0 si aucun disponible*/
44:                      char ch;
45:                      if (!unget==-1) {
46:                          ch=unget;
47:                          unget=-1;
48:                          return ch;
49:                      }else{
50:                          if (UARTReceivedDataIsAvailable (channel)){
9D00858C  10800003   BEQ A0, ZERO, 0x9D00859C
9D008590  00001021   ADDU V0, ZERO, ZERO
51:                                 return UARTGetDataByte(channel);
9D008598  7C021420   SEB V0, V0
52:                          }else{
53:                              return 0;
54:                          }
55:                      }
56:                  };
9D00859C  03E00008   JR RA
9D0085A0  00000000   NOP
57:                  
58:                  void UartPutch(UART_MODULE channel, char c){
9D0085A4  7C052C20   SEB A1, A1
59:                  /*Envoie d'un caractère*/
60:                      while(!UARTTransmitterIsReady(channel));
9D0085C4  1440FFFD   BNE V0, ZERO, 0x9D0085BC
9D0085C8  00000000   NOP
61:                        UARTSendDataByte(channel, c);
62:                  };
9D0085D4  03E00008   JR RA
9D0085D8  00000000   NOP
63:                  
64:                  char UartWaitch(UART_MODULE channel, int delay){
9D0085DC  27BDFFE0   ADDIU SP, SP, -32
9D0085E0  AFBF001C   SW RA, 28(SP)
9D0085E4  AFB10018   SW S1, 24(SP)
9D0085E8  AFB00014   SW S0, 20(SP)
9D0085EC  00808021   ADDU S0, A0, ZERO
65:                  /*attend un caractère pour un temps spécifié par delay
66:                  *retourne 0 si aucun reçu avant expiration du délais
67:                  */
68:                      int t;
69:                      char ch;
70:                      if (!unget==-1){
71:                          ch=unget;
72:                          unget=-1;
73:                          return unget;
74:                      }
75:                      if (!delay) while (1) if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D0085F0  14A0000D   BNE A1, ZERO, 0x9D008628
9D0085F4  00A08821   ADDU S1, A1, ZERO
9D008614  1040FFFD   BEQ V0, ZERO, 0x9D00860C
9D008618  00000000   NOP
9D008620  0B40219C   J 0x9D008670
9D008624  7C021420   SEB V0, V0
76:                      t=ticks()+delay;
9D008628  0F40240C   JAL ticks
9D00862C  00108080   SLL S0, S0, 2
77:                      while (ticks()<delay){
9D008638  0B402197   J 0x9D00865C
9D00863C  02028021   ADDU S0, S0, V0
9D00865C  0F40240C   JAL ticks
9D008660  00000000   NOP
9D008664  0051102B   SLTU V0, V0, S1
9D008668  5440FFF5   BNEL V0, ZERO, 0x9D008640
9D00866C  8E020000   LW V0, 0(S0)
78:                         if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D008648  10600004   BEQ V1, ZERO, 0x9D00865C
9D00864C  00000000   NOP
9D008654  0B40219C   J 0x9D008670
9D008658  7C021420   SEB V0, V0
79:                      }
80:                      return 0;
81:                  }
9D008670  8FBF001C   LW RA, 28(SP)
9D008674  8FB10018   LW S1, 24(SP)
9D008678  8FB00014   LW S0, 20(SP)
9D00867C  03E00008   JR RA
9D008680  27BD0020   ADDIU SP, SP, 32
82:                  
83:                  void UartPrint(UART_MODULE channel, const char* str){
84:                  /* envoie la chaine de caractère str via le UART */
85:                     while(*str != (char)0)
9D008684  80A60000   LB A2, 0(A1)
9D008688  10C0000F   BEQ A2, ZERO, 0x9D0086C8
9D00868C  00041880   SLL V1, A0, 2
9D0086BC  80A60000   LB A2, 0(A1)
9D0086C0  14C0FFF7   BNE A2, ZERO, 0x9D0086A0
9D0086C4  00000000   NOP
86:                     {
87:                        while(!UARTTransmitterIsReady(channel));
9D0086A8  1440FFFD   BNE V0, ZERO, 0x9D0086A0
9D0086AC  00000000   NOP
88:                        UARTSendDataByte(channel, *str++);
9D0086B0  24A50001   ADDIU A1, A1, 1
89:                     }
90:                     while(!UARTTransmissionHasCompleted(channel));
9D0086E4  1040FFFD   BEQ V0, ZERO, 0x9D0086DC
9D0086E8  00000000   NOP
91:                  };
9D0086EC  03E00008   JR RA
9D0086F0  00000000   NOP
92:                  
93:                  int UartReadln(UART_MODULE channel, char *buffer, int buff_len){
9D0086F4  27BDFFD0   ADDIU SP, SP, -48
9D0086F8  AFBF002C   SW RA, 44(SP)
9D0086FC  AFB50028   SW S5, 40(SP)
9D008700  AFB40024   SW S4, 36(SP)
9D008704  AFB30020   SW S3, 32(SP)
9D008708  AFB2001C   SW S2, 28(SP)
9D00870C  AFB10018   SW S1, 24(SP)
9D008710  AFB00014   SW S0, 20(SP)
9D008714  00809821   ADDU S3, A0, ZERO
9D008718  00A0A021   ADDU S4, A1, ZERO
9D00871C  00C08821   ADDU S1, A2, ZERO
94:                  /* lecture d'une chaine se terminant par '\r'
95:                   *  complète la chaine avec un zéro
96:                   *  retourne le nombre de caractère dans le buffer.
97:                   */
98:                      int count=0;
9D008720  00008021   ADDU S0, ZERO, ZERO
99:                      char c;
100:                     if (!unget==-1){
101:                         c=unget;
102:                         unget=-1;
103:                         *buffer++=c;
104:                         if (c==CR) return;
105:                     }
106:                     while (count < (buff_len-1)){
9D008734  0B4021E7   J 0x9D00879C
9D008738  3C159D01   LUI S5, -25343
9D008784  0B4021E8   J 0x9D0087A0
9D008788  2622FFFF   ADDIU V0, S1, -1
9D00879C  2622FFFF   ADDIU V0, S1, -1
9D0087A0  0202102A   SLT V0, S0, V0
9D0087A4  5440FFE5   BNEL V0, ZERO, 0x9D00873C
9D0087A8  8E420000   LW V0, 0(S2)
107:                         if (UARTReceivedDataIsAvailable(channel)){
9D008744  50600016   BEQL V1, ZERO, 0x9D0087A0
9D008748  2622FFFF   ADDIU V0, S1, -1
108:                             c = UARTGetDataByte(channel);
9D008750  7C052C20   SEB A1, A1
109:                             if (c==CR) break;
9D008754  2402000D   ADDIU V0, ZERO, 13
9D008758  10A20014   BEQ A1, V0, 0x9D0087AC
9D00875C  24020008   ADDIU V0, ZERO, 8
110:                             if (c==BS){
9D008760  54A2000A   BNEL A1, V0, 0x9D00878C
9D008764  A2850000   SB A1, 0(S4)
111:                                 if (count){
9D008768  5200000D   BEQL S0, ZERO, 0x9D0087A0
9D00876C  2622FFFF   ADDIU V0, S1, -1
112:                                     buffer--;
9D008770  2694FFFF   ADDIU S4, S4, -1
113:                                     count--;
9D008774  2610FFFF   ADDIU S0, S0, -1
114:                                     UartPrint(channel,"\b \b");
9D008778  02602021   ADDU A0, S3, ZERO
9D00877C  0F4021A1   JAL UartPrint
9D008780  26A5A864   ADDIU A1, S5, -22428
115:                                 }
116:                             }else{
117:                                 *buffer++=c;
9D00878C  26940001   ADDIU S4, S4, 1
118:                                 count++;
9D008790  26100001   ADDIU S0, S0, 1
119:                                 UartPutch(channel,c);
9D008794  0F402169   JAL UartPutch
9D008798  02602021   ADDU A0, S3, ZERO
120:                             }
121:                             
122:                         }
123:                     }
124:                     if (count) *buffer = (char)0;
9D0087AC  56000001   BNEL S0, ZERO, 0x9D0087B4
9D0087B0  A2800000   SB ZERO, 0(S4)
125:                     UartPutch(channel,'\r');
9D0087B4  02602021   ADDU A0, S3, ZERO
9D0087B8  0F402169   JAL UartPutch
9D0087BC  2405000D   ADDIU A1, ZERO, 13
126:                     return count;
127:                 }
9D0087C0  02001021   ADDU V0, S0, ZERO
9D0087C4  8FBF002C   LW RA, 44(SP)
9D0087C8  8FB50028   LW S5, 40(SP)
9D0087CC  8FB40024   LW S4, 36(SP)
9D0087D0  8FB30020   LW S3, 32(SP)
9D0087D4  8FB2001C   LW S2, 28(SP)
9D0087D8  8FB10018   LW S1, 24(SP)
9D0087DC  8FB00014   LW S0, 20(SP)
9D0087E0  03E00008   JR RA
9D0087E4  27BD0030   ADDIU SP, SP, 48
128:                 
129:                 int UartReceivedBreak(UART_MODULE channel){
130:                    char ch;
131:                    if (unget==-1 && UARTReceivedDataIsAvailable(channel)) {
9D0087E8  83858024   LB A1, -32732(GP)
9D0087EC  2403FFFF   ADDIU V1, ZERO, -1
9D0087F0  14A30011   BNE A1, V1, 0x9D008838
9D0087F4  00001021   ADDU V0, ZERO, ZERO
9D008814  10800008   BEQ A0, ZERO, 0x9D008838
9D008818  00001021   ADDU V0, ZERO, ZERO
132:                        ch=UARTGetDataByte(channel);
9D008820  7C031C20   SEB V1, V1
133:                        if (ch==ESC) return 1; else unget=ch;
9D008824  2404001B   ADDIU A0, ZERO, 27
9D008828  10640003   BEQ V1, A0, 0x9D008838
9D00882C  24020001   ADDIU V0, ZERO, 1
9D008830  A3838024   SB V1, -32732(GP)
134:                    }
135:                    return 0;
9D008834  00001021   ADDU V0, ZERO, ZERO
136:                 }
9D008838  03E00008   JR RA
9D00883C  00000000   NOP
137:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/ntsc.c  ----------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /* 
19:                   * File:   test-ntsc.c
20:                   * Author: Jacques Deschênes
21:                   * Description: test génération signal vidéo NTSC sur PIC32MX150F128B.
22:                   * Created on 20 août 2013, 08:48
23:                   */
24:                  
25:                  #include <stdio.h>
26:                  #include <stdlib.h>
27:                  #include <sys/attribs.h>
28:                  #include <plib.h>
29:                  #include "HardwareProfile.h"
30:                  #include "ntsc.h"
31:                  
32:                  /*
33:                   *  la fréqueence PBCLK influence la largeur des pixels vidéo. Comme PBCLK==SYSCLK
34:                   *  on peut allonger les pixels en diminuant la fréquence légèrement.
35:                   *  pour une résolution horizontale de 320 pixels et une fréquence de 40Mhz le
36:                   *  meilleur diviseur pour le générateur BGR du SPI est de 2 ce qui donne
37:                   *  une fréquence de pixel de  40e6/(2*(2+1)=6,67Mhz et la durée total d'une
38:                   *  ligne vidéo est donc de 320/6,67e6= 48µSec.
39:                   *  En principe pour le standard NTSC on dispose de 52µSec par ligne vidéo.
40:                   *  En pratique on est plutôt à 51µSec. Donc ici on a 3µSec inutilisées.
41:                   *  en résuidant SYSCLK à 37,5Mhz on a 51,2µSec par ligne vidéo. Les pixels
42:                   *  sont donc moins compressé horizontalement. Mais sur certains téléviseurs
43:                   *  on peut perdre quelques pixels en bout de ligne.
44:                   *  la constante SPI_DLY doit-être ajustée en fonction de PBCLK pour que les
45:                   *  320 pixels horizontals soient visibles.
46:                   */
47:                  
48:                  #define PWM_PERIOD (SYSCLK/15748)-1
49:                  #define HSYNC  (SYSCLK/212766)  // 4,7µSec
50:                  #define FIRST_LINE 27   //première ligne de scan visible
51:                  #define LAST_LINE  256  // dernière ligne de scan visible
52:                  #define BITCLK HRES * 1000000L/52 // 52µSec c'est le temps que dure 1 ligne vidéo.
53:                  #if SYSCLK==40000000L
54:                  #define SPI_DLY HSYNC+90 // délais en début de ligne avant l'envoie du signal vidéo.
55:                  #else
56:                  #define SPI_DLY HSYNC+30 // délais en début de ligne avant l'envoie du signal vidéo.
57:                  #endif
58:                  #define _enable_video_out()  SPI1CONSET =(1<<15)
59:                  #define _disable_video_out() SPI1CONCLR =(1<<15)
60:                  
61:                  unsigned int video_bmp[VRES][HRES/32]; // video bitmap 7168 octets
62:                  volatile unsigned int ln_cnt;
63:                  volatile unsigned int video;
64:                  volatile int *DmaSrc;
65:                  
66:                  
67:                  
68:                  void VideoInit(void){
9D008840  27BDFFD8   ADDIU SP, SP, -40
9D008844  AFBF0024   SW RA, 36(SP)
9D008848  AFB20020   SW S2, 32(SP)
9D00884C  AFB1001C   SW S1, 28(SP)
9D008850  AFB00018   SW S0, 24(SP)
69:                      //configuration PWM sur OC2 pour SYNC, utilisation TIMER2
70:                      T2CON = 0;
9D008854  3C02BF80   LUI V0, -16512
9D008858  AC400800   SW ZERO, 2048(V0)
71:                      PR2=PWM_PERIOD;
9D00885C  2403094C   ADDIU V1, ZERO, 2380
9D008860  3C02BF80   LUI V0, -16512
9D008864  AC430820   SW V1, 2080(V0)
72:                      OC2CONbits.OCM = 5; // mode train d'impulsion
9D008868  3C02BF80   LUI V0, -16512
9D00886C  8C433200   LW V1, 12800(V0)
9D008870  24120005   ADDIU S2, ZERO, 5
9D008874  7E431004   INS V1, S2, 0, 3
9D008878  AC433200   SW V1, 12800(V0)
73:                      OC2RS = 0; 
9D00887C  3C03BF80   LUI V1, -16512
9D008880  AC603220   SW ZERO, 12832(V1)
74:                      OC2R = HSYNC;
9D008884  240400B0   ADDIU A0, ZERO, 176
9D008888  3C03BF80   LUI V1, -16512
9D00888C  AC643210   SW A0, 12816(V1)
75:                      IFS0bits.T2IF=0;
9D008890  3C03BF88   LUI V1, -16504
9D008894  8C641030   LW A0, 4144(V1)
9D008898  7C044A44   INS A0, ZERO, 9, 1
9D00889C  AC641030   SW A0, 4144(V1)
76:                      IEC0bits.T2IE=1;
9D0088A0  3C03BF88   LUI V1, -16504
9D0088A4  8C641060   LW A0, 4192(V1)
9D0088A8  24110001   ADDIU S1, ZERO, 1
9D0088AC  7E244A44   INS A0, S1, 9, 1
9D0088B0  AC641060   SW A0, 4192(V1)
77:                      IPC2bits.T2IP=7;
9D0088B4  3C03BF88   LUI V1, -16504
9D0088B8  8C6410B0   LW A0, 4272(V1)
9D0088BC  24050007   ADDIU A1, ZERO, 7
9D0088C0  7CA42084   INS A0, A1, 2, 3
9D0088C4  AC6410B0   SW A0, 4272(V1)
78:                      IPC2bits.T2IS=3;
9D0088C8  8C6410B0   LW A0, 4272(V1)
9D0088CC  24050003   ADDIU A1, ZERO, 3
9D0088D0  7CA40804   INS A0, A1, 0, 2
9D0088D4  AC6410B0   SW A0, 4272(V1)
79:                      OC2CONbits.ON =1;  // activation
9D0088D8  8C433200   LW V1, 12800(V0)
9D0088DC  7E237BC4   INS V1, S1, 15, 1
9D0088E0  AC433200   SW V1, 12800(V0)
80:                      T2CONbits.ON=1;  // activation
9D0088E4  3C02BF80   LUI V0, -16512
9D0088E8  8C430800   LW V1, 2048(V0)
9D0088EC  7E237BC4   INS V1, S1, 15, 1
9D0088F0  AC430800   SW V1, 2048(V0)
81:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
82:                      OC1CONbits.OCM = 5; //mode train d'impulsion
9D0088F4  3C02BF80   LUI V0, -16512
9D0088F8  8C433000   LW V1, 12288(V0)
9D0088FC  7E431004   INS V1, S2, 0, 3
9D008900  AC433000   SW V1, 12288(V0)
83:                      OC1RS=0;
9D008904  3C03BF80   LUI V1, -16512
9D008908  AC603020   SW ZERO, 12320(V1)
84:                      OC1R=HSYNC+SPI_DLY;
9D00890C  2404017E   ADDIU A0, ZERO, 382
9D008910  3C03BF80   LUI V1, -16512
9D008914  AC643010   SW A0, 12304(V1)
85:                      OC1CONbits.ON=1;
9D008918  8C433000   LW V1, 12288(V0)
9D00891C  7E237BC4   INS V1, S1, 15, 1
9D008920  AC433000   SW V1, 12288(V0)
86:                      // configuration SPI pour sortie vidéo
87:                      // configure le DMA
88:                      DmaChnOpen(0,0,DMA_OPEN_DEFAULT);
9D008924  00002021   ADDU A0, ZERO, ZERO
9D008928  00002821   ADDU A1, ZERO, ZERO
9D00892C  0F4027A1   JAL DmaChnOpen
9D008930  00003021   ADDU A2, ZERO, ZERO
89:                      DmaChnSetEventControl(0,DMA_EV_START_IRQ_EN|
9D008934  00002021   ADDU A0, ZERO, ZERO
9D008938  0F402993   JAL DmaChnWriteEventControlFlags
9D00893C  24052610   ADDIU A1, ZERO, 9744
90:                                            DMA_EV_START_IRQ(_SPI1_TX_IRQ));
91:                      DmaChnSetTxfer(0,(void *)DmaSrc,(void *)&SPI1BUF,HRES/8,4,4);
9D008940  24020004   ADDIU V0, ZERO, 4
9D008944  AFA20010   SW V0, 16(SP)
9D008948  AFA20014   SW V0, 20(SP)
9D00894C  00002021   ADDU A0, ZERO, ZERO
9D008950  8F858048   LW A1, -32696(GP)
9D008954  3C06BF80   LUI A2, -16512
9D008958  24C65820   ADDIU A2, A2, 22560
9D00895C  0F402865   JAL DmaChnSetTxfer
9D008960  24070028   ADDIU A3, ZERO, 40
92:                      // configuration du SPI canal 1
93:                      SPI1CONbits.DISSDI=1; // SDI n'est pas utilisé.
9D008964  3C10BF80   LUI S0, -16512
9D008968  8E025800   LW V0, 22528(S0)
9D00896C  7E222104   INS V0, S1, 4, 1
9D008970  AE025800   SW V0, 22528(S0)
94:                      SPI1CONbits.FRMEN=1; // frame mode
9D008974  8E025800   LW V0, 22528(S0)
9D008978  7E22FFC4   INS V0, S1, 31, 1
9D00897C  AE025800   SW V0, 22528(S0)
95:                      SPI1CONbits.FRMCNT=5; // 32 octets par frame.
9D008980  8E025800   LW V0, 22528(S0)
9D008984  7E42D604   INS V0, S2, 24, 3
9D008988  AE025800   SW V0, 22528(S0)
96:                      SPI1CONbits.FRMPOL=1; // sync sur transition montante
9D00898C  8E025800   LW V0, 22528(S0)
9D008990  7E22EF44   INS V0, S1, 29, 1
9D008994  AE025800   SW V0, 22528(S0)
97:                      SPI1CONbits.FRMSYNC=1; // synchronisation esclave
9D008998  8E025800   LW V0, 22528(S0)
9D00899C  7E22F784   INS V0, S1, 30, 1
9D0089A0  AE025800   SW V0, 22528(S0)
98:                      SPI1CONbits.MSTEN=1; // SPI maître
9D0089A4  8E025800   LW V0, 22528(S0)
9D0089A8  7E222944   INS V0, S1, 5, 1
9D0089AC  AE025800   SW V0, 22528(S0)
99:                     // SPI1CONbits.SPIFE=1; // synchronisation sur clock premier bit.
100:                     SPI1CONbits.MODE32=1; // mode 32 bits
9D0089B0  8E025800   LW V0, 22528(S0)
9D0089B4  7E225AC4   INS V0, S1, 11, 1
9D0089B8  AE025800   SW V0, 22528(S0)
101:                     SPI1CONbits.STXISEL=1; // interruption sur TBE
9D0089BC  8E025800   LW V0, 22528(S0)
9D0089C0  7E221884   INS V0, S1, 2, 2
9D0089C4  AE025800   SW V0, 22528(S0)
102:                     SpiChnSetBitRate(SPI_CHANNEL1, PBCLK, BITCLK);
9D0089C8  24040001   ADDIU A0, ZERO, 1
9D0089CC  3C05023C   LUI A1, 572
9D0089D0  24A53460   ADDIU A1, A1, 13408
9D0089D4  3C06005D   LUI A2, 93
9D0089D8  0F402921   JAL SpiChnSetBitRate
9D0089DC  34C6E676   ORI A2, A2, -6538
103:                     SPI1CONbits.ON=1;
9D0089E0  8E025800   LW V0, 22528(S0)
9D0089E4  7E227BC4   INS V0, S1, 15, 1
9D0089E8  AE025800   SW V0, 22528(S0)
104:                 }//init_video()
9D0089EC  8FBF0024   LW RA, 36(SP)
9D0089F0  8FB20020   LW S2, 32(SP)
9D0089F4  8FB1001C   LW S1, 28(SP)
9D0089F8  8FB00018   LW S0, 24(SP)
9D0089FC  03E00008   JR RA
9D008A00  27BD0028   ADDIU SP, SP, 40
105:                 
106:                 
107:                 
108:                 void __ISR(_TIMER_2_VECTOR,IPL7AUTO) tmr2_isr(void){
9D008A04  415DE800   RDPGPR SP, SP
9D008A08  401B7000   MFC0 K1, EPC
9D008A0C  401A6002   MFC0 K0, SRSCtl
9D008A10  27BDFFE0   ADDIU SP, SP, -32
9D008A14  401B6000   MFC0 K1, Status
9D008A18  AFBA001C   SW K0, 28(SP)
9D008A1C  AFBB0018   SW K1, 24(SP)
9D008A20  7C1B7844   INS K1, ZERO, 1, 15
9D008A24  377B1C00   ORI K1, K1, 7168
9D008A28  409B6000   MTC0 K1, Status
9D008A2C  AFA30008   SW V1, 8(SP)
9D008A30  AFA20004   SW V0, 4(SP)
9D008A34  AFA4000C   SW A0, 12(SP)
109:                     _disable_video_out();
9D008A38  34038000   ORI V1, ZERO, -32768
9D008A3C  3C02BF80   LUI V0, -16512
9D008A40  AC435804   SW V1, 22532(V0)
110:                     ln_cnt++;
9D008A44  8F828050   LW V0, -32688(GP)
9D008A48  24420001   ADDIU V0, V0, 1
9D008A4C  AF828050   SW V0, -32688(GP)
111:                     switch (ln_cnt){
9D008A50  8F828050   LW V0, -32688(GP)
9D008A54  2403001A   ADDIU V1, ZERO, 26
9D008A58  1043001C   BEQ V0, V1, 0x9D008ACC
9D008A5C  2C43001B   SLTIU V1, V0, 27
9D008A60  10600009   BEQ V1, ZERO, 0x9D008A88
9D008A64  24030101   ADDIU V1, ZERO, 257
9D008A68  24030001   ADDIU V1, ZERO, 1
9D008A6C  1043000D   BEQ V0, V1, 0x9D008AA4
9D008A70  2403089C   ADDIU V1, ZERO, 2204
9D008A74  24030004   ADDIU V1, ZERO, 4
9D008A78  1443001D   BNE V0, V1, 0x9D008AF0
9D008A7C  240300B0   ADDIU V1, ZERO, 176
9D008A88  10430016   BEQ V0, V1, 0x9D008AE4
9D008A8C  00000000   NOP
9D008A90  24030106   ADDIU V1, ZERO, 262
9D008A94  14430016   BNE V0, V1, 0x9D008AF0
9D008A98  00000000   NOP
9D008A9C  0B4022B0   J 0x9D008AC0
9D008AA0  00000000   NOP
112:                         case 1:  // début vsync
113:                             OC2R=PWM_PERIOD-HSYNC;
9D008AA4  3C02BF80   LUI V0, -16512
9D008AA8  AC433210   SW V1, 12816(V0)
114:                             break;
9D008AAC  0B4022D1   J 0x9D008B44
9D008AB0  24030200   ADDIU V1, ZERO, 512
115:                         case 4: // fin vsync
116:                             OC2R=HSYNC;
9D008A80  0B4022AD   J 0x9D008AB4
9D008A84  3C02BF80   LUI V0, -16512
9D008AB4  AC433210   SW V1, 12816(V0)
117:                             break;
9D008AB8  0B4022D1   J 0x9D008B44
9D008ABC  24030200   ADDIU V1, ZERO, 512
118:                         case 262:  //fin du frame
119:                             ln_cnt=0;
9D008AC0  AF808050   SW ZERO, -32688(GP)
120:                             break;
9D008AC4  0B4022D1   J 0x9D008B44
9D008AC8  24030200   ADDIU V1, ZERO, 512
121:                   
122:                         case FIRST_LINE-1:
123:                             video=1;
9D008ACC  24020001   ADDIU V0, ZERO, 1
9D008AD0  AF82804C   SW V0, -32692(GP)
124:                             DmaSrc=(void*)&video_bmp[0];
9D008AD4  3C02A000   LUI V0, -24576
9D008AD8  2442007C   ADDIU V0, V0, 124
125:                             break;
9D008ADC  0B4022D0   J 0x9D008B40
9D008AE0  AF828048   SW V0, -32696(GP)
126:                         case LAST_LINE+1:
127:                             video=0;
9D008AE4  AF80804C   SW ZERO, -32692(GP)
128:                             break;
9D008AE8  0B4022D1   J 0x9D008B44
9D008AEC  24030200   ADDIU V1, ZERO, 512
129:                         default:
130:                             if (video){
9D008AF0  8F82804C   LW V0, -32692(GP)
9D008AF4  10400012   BEQ V0, ZERO, 0x9D008B40
9D008AF8  34038000   ORI V1, ZERO, -32768
131:                                 _enable_video_out();
9D008AFC  3C02BF80   LUI V0, -16512
9D008B00  AC435808   SW V1, 22536(V0)
132:                                 IFS1bits.SPI1TXIF=1;
9D008B04  3C02BF88   LUI V0, -16504
9D008B08  8C431040   LW V1, 4160(V0)
9D008B0C  24040001   ADDIU A0, ZERO, 1
9D008B10  7C833184   INS V1, A0, 6, 1
9D008B14  AC431040   SW V1, 4160(V0)
133:                                 DCH0SSA=KVA_TO_PA((void *)DmaSrc);
9D008B18  8F828048   LW V0, -32696(GP)
9D008B1C  7C44E000   EXT A0, V0, 0, 29
9D008B20  3C03BF88   LUI V1, -16504
9D008B24  AC643090   SW A0, 12432(V1)
134:                                 DmaSrc +=HRES/32;
9D008B28  24420028   ADDIU V0, V0, 40
9D008B2C  AF828048   SW V0, -32696(GP)
135:                                 DCH0CON |=128; // remplace DmaChnEnable(0); réduit le temps de latence
9D008B30  3C02BF88   LUI V0, -16504
9D008B34  8C433060   LW V1, 12384(V0)
9D008B38  34630080   ORI V1, V1, 128
9D008B3C  AC433060   SW V1, 12384(V0)
136:                             }
137:                     }//switch (ln_cnt)
138:                     mT2ClearIntFlag();
9D008B40  24030200   ADDIU V1, ZERO, 512
9D008B44  3C02BF88   LUI V0, -16504
9D008B48  AC431034   SW V1, 4148(V0)
139:                 }//tmr2_isr()
9D008B4C  8FA2001C   LW V0, 28(SP)
9D008B50  3042000F   ANDI V0, V0, 15
9D008B54  14400004   BNE V0, ZERO, 0x9D008B68
9D008B58  8FBB0018   LW K1, 24(SP)
9D008B5C  8FA4000C   LW A0, 12(SP)
9D008B60  8FA30008   LW V1, 8(SP)
9D008B64  8FA20004   LW V0, 4(SP)
9D008B68  8FBA001C   LW K0, 28(SP)
9D008B6C  27BD0020   ADDIU SP, SP, 32
9D008B70  409A6002   MTC0 K0, SRSCtl
9D008B74  41DDE800   WRPGPR SP, SP
9D008B78  409B6000   MTC0 K1, Status
9D008B7C  42000018   ERET
140:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/keyboard.c  ------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * Name: keyboard.c
20:                   * Author: Jacques Deschênes
21:                   * Description:  interface avec clavier PS/2
22:                   * Date: 2013-08-26
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "hardwareProfile.h"
27:                  #include "keyboard.h"
28:                  #include "QWERTY.h"
29:                  
30:                  #define KBD_CLK 1  // SET/CLR bit
31:                  #define KBD_DAT 2  // SET/CLR bit
32:                  
33:                  #define _wait_key() while (head==tail)
34:                  
35:                  
36:                  static  unsigned char kbd_queue[32]; // file circulaire pour les codes reçus du clavier.
37:                  volatile  static unsigned char head=0, tail=0; // tête et queue de la file
38:                  volatile  static unsigned char  in_byte=0, bit_cnt=0, parity=0;
39:                  volatile unsigned char rx_flags=0, kbd_leds=0;
40:                  volatile unsigned short key_state; // état des touches d'alteration: shift, ctrl, alt,etc.
41:                  
42:                  #define FN_COUNT 32
43:                  const short fn_keys[FN_COUNT]={CAPS_LOCK,SCROLL_LOCK,NUM_LOCK,LSHIFT,RSHIFT,LCTRL,
44:                  RCTRL,LALT,RALT,F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,PRN,PAUSE,UP_ARROW,DOWN_ARROW,
45:                  LEFT_ARROW,RIGHT_ARROW,INSERT,HOME,PGUP,PGDN,END
46:                  };
47:                  
48:                  static int KbdReset(void);
49:                  
50:                  int KeyboardInit(){ // initialisation E/S et RAZ clavier
9D006364  27BDFFE0   ADDIU SP, SP, -32
9D006368  AFBF001C   SW RA, 28(SP)
9D00636C  AFB20018   SW S2, 24(SP)
9D006370  AFB10014   SW S1, 20(SP)
51:                      unsigned char c;
52:                      unsigned int t0;
53:                      t0=ticks()+750;
9D006374  0F40240C   JAL ticks
9D006378  AFB00010   SW S0, 16(SP)
9D00637C  245002EE   ADDIU S0, V0, 750
54:                      head=0;
9D006380  A380802B   SB ZERO, -32725(GP)
55:                      tail=0;
9D006384  A3808029   SB ZERO, -32727(GP)
56:                      in_byte=0;
9D006388  A380802A   SB ZERO, -32726(GP)
57:                      bit_cnt=0;
9D00638C  A3808027   SB ZERO, -32729(GP)
58:                      parity=0;
9D006390  A3808028   SB ZERO, -32728(GP)
59:                      rx_flags=0;
9D006394  A3808025   SB ZERO, -32731(GP)
60:                      kbd_leds=0;
9D006398  A3808026   SB ZERO, -32730(GP)
61:                      key_state=0;
9D00639C  A7808058   SH ZERO, -32680(GP)
62:                      TRISASET=KBD_CLK|KBD_DAT;
9D0063A0  24040003   ADDIU A0, ZERO, 3
9D0063A4  3C02BF88   LUI V0, -16504
9D0063A8  AC446018   SW A0, 24600(V0)
63:                      INTCONbits.INT4EP=0; // interruption sur transition descendante
9D0063AC  3C02BF88   LUI V0, -16504
9D0063B0  8C431000   LW V1, 4096(V0)
9D0063B4  7C032104   INS V1, ZERO, 4, 1
9D0063B8  AC431000   SW V1, 4096(V0)
64:                      IPC4bits.INT4IP=6; // priorité 4
9D0063BC  3C02BF88   LUI V0, -16504
9D0063C0  8C4310D0   LW V1, 4304(V0)
9D0063C4  24050006   ADDIU A1, ZERO, 6
9D0063C8  7CA3E684   INS V1, A1, 26, 3
9D0063CC  AC4310D0   SW V1, 4304(V0)
65:                      IPC4bits.INT4IS=3;  // sous-priorité 3.
9D0063D0  8C4310D0   LW V1, 4304(V0)
9D0063D4  7C83CE04   INS V1, A0, 24, 2
9D0063D8  AC4310D0   SW V1, 4304(V0)
66:                      while (!PORTAbits.RA0);
9D0063DC  3C03BF88   LUI V1, -16504
9D0063E0  8C626020   LW V0, 24608(V1)
9D0063E4  30420001   ANDI V0, V0, 1
9D0063E8  1040FFFD   BEQ V0, ZERO, 0x9D0063E0
9D0063EC  3C02BF88   LUI V0, -16504
67:                      IFS0bits.INT4IF=0; // RAZ indicateur interruption
9D0063F0  8C431030   LW V1, 4144(V0)
9D0063F4  7C03BDC4   INS V1, ZERO, 23, 1
9D0063F8  AC431030   SW V1, 4144(V0)
68:                      IEC0SET = _IEC0_INT4IE_MASK; // activation interruption externe 4 (KBD_CLK)
9D0063FC  3C030080   LUI V1, 128
9D006400  3C02BF88   LUI V0, -16504
9D006404  AC431068   SW V1, 4200(V0)
69:                      while ((ticks()!=t0) && ((rx_flags & F_ERROR)==0)){
9D006408  0B401909   J 0x9D006424
9D00640C  241100AA   ADDIU S1, ZERO, 170
9D006424  0F40240C   JAL ticks
9D006428  00000000   NOP
9D00642C  10500005   BEQ V0, S0, 0x9D006444
9D006430  00000000   NOP
9D006434  93828025   LBU V0, -32731(GP)
9D006438  30420001   ANDI V0, V0, 1
9D00643C  1040FFF4   BEQ V0, ZERO, 0x9D006410
9D006440  00000000   NOP
70:                          c=KbdScancode();
9D006410  0F401767   JAL KbdScancode
9D006414  00000000   NOP
71:                          if (c==BAT_OK){
9D006418  304200FF   ANDI V0, V0, 255
9D00641C  10510026   BEQ V0, S1, 0x9D0064B8
9D006420  24020001   ADDIU V0, ZERO, 1
72:                              return 1;
73:                          }
74:                      }
75:                      if (KbdReset())
76:                          return 1;
77:                      else
78:                          return 0;
79:                  } //KeyboardInit()
9D0064B8  8FBF001C   LW RA, 28(SP)
9D0064BC  8FB20018   LW S2, 24(SP)
9D0064C0  8FB10014   LW S1, 20(SP)
9D0064C4  8FB00010   LW S0, 16(SP)
9D0064C8  03E00008   JR RA
9D0064CC  27BD0020   ADDIU SP, SP, 32
80:                  
81:                  static int KbdReset(void){
82:                      unsigned int t0;
83:                      short c;
84:                      rx_flags = 0;
9D006444  A3808025   SB ZERO, -32731(GP)
85:                      KbdSend(KBD_RESET);
9D006448  0F4016C1   JAL KbdSend
9D00644C  2404FFFF   ADDIU A0, ZERO, -1
86:                      t0=ticks()+750;
9D006450  0F40240C   JAL ticks
9D006454  00008021   ADDU S0, ZERO, ZERO
9D006458  245102EE   ADDIU S1, V0, 750
87:                      c=0;
88:                      while ((ticks()!=t0) && ((rx_flags & F_ERROR)==0) && !c){
9D006474  0F40240C   JAL ticks
9D006478  00000000   NOP
9D00647C  12220007   BEQ S1, V0, 0x9D00649C
9D006480  00000000   NOP
9D006484  93828025   LBU V0, -32731(GP)
9D006488  30420001   ANDI V0, V0, 1
9D00648C  14400003   BNE V0, ZERO, 0x9D00649C
9D006490  00000000   NOP
9D006494  1200FFF3   BEQ S0, ZERO, 0x9D006464
9D006498  00000000   NOP
89:                              c=KbdScancode();
9D006464  0F401767   JAL KbdScancode
9D006468  00000000   NOP
9D00646C  00521826   XOR V1, V0, S2
9D006470  0043800B   MOVN S0, V0, V1
90:                              if (c==KBD_ACK){
9D00645C  0B40191D   J 0x9D006474
9D006460  241200FA   ADDIU S2, ZERO, 250
91:                                  c=0;
92:                              }
93:                      }
94:                      if ((rx_flags & F_ERROR) || (c!=BAT_OK))
9D00649C  93838025   LBU V1, -32731(GP)
9D0064A0  30630001   ANDI V1, V1, 1
9D0064A4  14600003   BNE V1, ZERO, 0x9D0064B4
9D0064A8  00001021   ADDU V0, ZERO, ZERO
95:                          return 0;
9D0064AC  3A0200AA   XORI V0, S0, 170
9D0064B0  2C420001   SLTIU V0, V0, 1
9D0064B4  0002102B   SLTU V0, ZERO, V0
96:                      else
97:                          return 1;
98:                  }//KbdReset()
99:                  
100:                 typedef enum  _STATE {ST0, ST_EXT0, ST_RELEASE, ST_COMPLETED} state_t;
101:                 
102:                 short KbdScancode(){  // obtient le code clavier en tête de la file
9D005D9C  27BDFFE8   ADDIU SP, SP, -24
9D005DA0  AFBF0014   SW RA, 20(SP)
9D005DA4  AFB00010   SW S0, 16(SP)
9D006090  3C079D01   LUI A3, -25343
9D006094  24E7A444   ADDIU A3, A3, -23484
103:                 	unsigned int i, flags;
104:                         state_t state;
105:                 	short code;
106:                         if (head==tail){
9D005DA8  9383802B   LBU V1, -32725(GP)
9D005DAC  306300FF   ANDI V1, V1, 255
9D005DB0  93828029   LBU V0, -32727(GP)
9D005DB4  304200FF   ANDI V0, V0, 255
9D005DB8  1462001B   BNE V1, V0, 0x9D005E28
9D005DBC  00002021   ADDU A0, ZERO, ZERO
9D005E28  00003021   ADDU A2, ZERO, ZERO
107:                             if (rx_flags & F_ERROR){
9D005DC0  93838025   LBU V1, -32731(GP)
9D005DC4  30630001   ANDI V1, V1, 1
9D005DC8  10600162   BEQ V1, ZERO, 0x9D006354
9D005DCC  00001021   ADDU V0, ZERO, ZERO
108:                                 _status_on();
9D005DD0  3C10BF88   LUI S0, -16504
9D005DD4  8E026120   LW V0, 24864(S0)
9D005DD8  34420008   ORI V0, V0, 8
9D005DDC  AE026120   SW V0, 24864(S0)
109:                                 delay_ms(400);
9D005DE0  0F402417   JAL delay_ms
9D005DE4  24040190   ADDIU A0, ZERO, 400
110:                                 _status_off();
9D005DE8  8E036120   LW V1, 24864(S0)
9D005DEC  2402FFF7   ADDIU V0, ZERO, -9
9D005DF0  00621024   AND V0, V1, V0
9D005DF4  AE026120   SW V0, 24864(S0)
111:                                 delay_ms(400);
9D005DF8  0F402417   JAL delay_ms
9D005DFC  24040190   ADDIU A0, ZERO, 400
112:                                 rx_flags &= ~F_ERROR;
9D005E00  93828025   LBU V0, -32731(GP)
9D005E04  304200FE   ANDI V0, V0, 254
9D005E08  A3828025   SB V0, -32731(GP)
113:                                 IEC0bits.INT4IE=1;
9D005E0C  3C02BF88   LUI V0, -16504
9D005E10  8C431060   LW V1, 4192(V0)
9D005E14  24040001   ADDIU A0, ZERO, 1
9D005E18  7C83BDC4   INS V1, A0, 23, 1
9D005E1C  AC431060   SW V1, 4192(V0)
114:                             }
115:                             return 0; // tampon vide
9D005E20  0B4018D5   J 0x9D006354
9D005E24  00001021   ADDU V0, ZERO, ZERO
116:                         }
117:                 	code = 0;
118:                 	flags=0;
119:                         state=ST0;
120:                 	while (state!=ST_COMPLETED){
9D005E3C  240A0003   ADDIU T2, ZERO, 3
9D006000  148AFF91   BNE A0, T2, 0x9D005E48
9D006004  00000000   NOP
121:                             _wait_key();
9D005E48  9383802B   LBU V1, -32725(GP)
9D005E4C  306300FF   ANDI V1, V1, 255
9D005E50  93828029   LBU V0, -32727(GP)
9D005E54  304200FF   ANDI V0, V0, 255
9D005E58  1062FFFB   BEQ V1, V0, 0x9D005E48
9D005E5C  00000000   NOP
122:                             code=kbd_queue[head];
9D005E2C  3C08A000   LUI T0, -24576
9D005E30  25084BBC   ADDIU T0, T0, 19388
9D005E60  9382802B   LBU V0, -32725(GP)
9D005E64  304200FF   ANDI V0, V0, 255
9D005E68  00481021   ADDU V0, V0, T0
9D005E6C  90430000   LBU V1, 0(V0)
9D005E70  7C031620   SEH V0, V1
123:                             head++;
9D005E74  9385802B   LBU A1, -32725(GP)
9D005E78  24A50001   ADDIU A1, A1, 1
9D005E7C  30A500FF   ANDI A1, A1, 255
9D005E80  A385802B   SB A1, -32725(GP)
124:                             head &= 31;
9D005E84  9385802B   LBU A1, -32725(GP)
9D005E88  30A5001F   ANDI A1, A1, 31
9D005E8C  A385802B   SB A1, -32725(GP)
125:                             switch (state){
9D005E34  24070001   ADDIU A3, ZERO, 1
9D005E90  10870026   BEQ A0, A3, 0x9D005F2C
9D005E94  00000000   NOP
9D005E98  10800006   BEQ A0, ZERO, 0x9D005EB4
9D005E9C  00000000   NOP
9D005EA0  24030002   ADDIU V1, ZERO, 2
9D005EA4  14830056   BNE A0, V1, 0x9D006000
9D005EA8  00C02821   ADDU A1, A2, ZERO
126:                                 case ST0:
127:                                     switch (code){
9D005E40  240B00E1   ADDIU T3, ZERO, 225
9D005E44  240C00E0   ADDIU T4, ZERO, 224
9D005EB4  106B000B   BEQ V1, T3, 0x9D005EE4
9D005EB8  24040007   ADDIU A0, ZERO, 7
9D005EBC  50690005   BEQL V1, T1, 0x9D005ED4
9D005EC0  34C68000   ORI A2, A2, -32768
9D005EC4  146C004E   BNE V1, T4, 0x9D006000
9D005EC8  01402021   ADDU A0, T2, ZERO
128:                                         case KEY_REL:
129:                                             flags |= REL_BIT;
130:                                             state = ST_RELEASE;
131:                                             break;
9D005ED4  0B401792   J 0x9D005E48
9D005ED8  24040002   ADDIU A0, ZERO, 2
132:                                         case XTD_KEY:
133:                                             flags |= XT_BIT;
9D005ECC  0B4017B7   J 0x9D005EDC
9D005ED0  34C60100   ORI A2, A2, 256
134:                                             state = ST_EXT0;
135:                                             break;
9D005EDC  0B401792   J 0x9D005E48
9D005EE0  00E02021   ADDU A0, A3, ZERO
136:                                         case 0xE1:
137:                                             for (i=7;i;i--){     // touche PAUSE élimine les 7 prochains caractères
9D005F1C  1480FFF1   BNE A0, ZERO, 0x9D005EE4
9D005F20  240201E1   ADDIU V0, ZERO, 481
138:                                                     _wait_key();
9D005EE4  9383802B   LBU V1, -32725(GP)
9D005EE8  306300FF   ANDI V1, V1, 255
9D005EEC  93828029   LBU V0, -32727(GP)
9D005EF0  304200FF   ANDI V0, V0, 255
9D005EF4  1062FFFB   BEQ V1, V0, 0x9D005EE4
9D005EF8  00000000   NOP
139:                                                     head++;
9D005EFC  9382802B   LBU V0, -32725(GP)
9D005F00  24420001   ADDIU V0, V0, 1
9D005F04  304200FF   ANDI V0, V0, 255
9D005F08  A382802B   SB V0, -32725(GP)
140:                                                     head &= 31;
9D005F0C  9382802B   LBU V0, -32725(GP)
9D005F10  3042001F   ANDI V0, V0, 31
9D005F14  A382802B   SB V0, -32725(GP)
9D005F18  2484FFFF   ADDIU A0, A0, -1
141:                                             }
142:                                             code = PAUSE;
143:                                         default:
144:                                             state=ST_COMPLETED;
145:                                     }//switch(code)
146:                                     break;
147:                                 case ST_EXT0:
148:                                     if (code==KEY_REL){
9D005E38  240900F0   ADDIU T1, ZERO, 240
9D005F2C  14490004   BNE V0, T1, 0x9D005F40
9D005F30  30C30100   ANDI V1, A2, 256
149:                                         flags |= REL_BIT;
9D005F34  34C68000   ORI A2, A2, -32768
150:                                         state = ST_RELEASE;
9D005F38  0B401792   J 0x9D005E48
9D005F3C  24040002   ADDIU A0, ZERO, 2
151:                                     }else{
152:                                         if ((flags & XT_BIT) && (code==0x12)){ // touche PrtSc enfoncée.
9D005F40  10600031   BEQ V1, ZERO, 0x9D006008
9D005F44  00C02821   ADDU A1, A2, ZERO
9D005F48  24030012   ADDIU V1, ZERO, 18
9D005F4C  1443002F   BNE V0, V1, 0x9D00600C
9D005F50  3C03BF88   LUI V1, -16504
9D005F54  24040002   ADDIU A0, ZERO, 2
153:                                             for (i=2;i;i--){ // élimine les 2 codes suivants
9D005F90  1480FFF1   BNE A0, ZERO, 0x9D005F58
9D005F94  24020112   ADDIU V0, ZERO, 274
9D005F98  0B401802   J 0x9D006008
9D005F9C  00A03021   ADDU A2, A1, ZERO
154:                                                 _wait_key();
9D005F58  9383802B   LBU V1, -32725(GP)
9D005F5C  306300FF   ANDI V1, V1, 255
9D005F60  93828029   LBU V0, -32727(GP)
9D005F64  304200FF   ANDI V0, V0, 255
9D005F68  1062FFFB   BEQ V1, V0, 0x9D005F58
9D005F6C  00000000   NOP
155:                                                 head++;
9D005F70  9382802B   LBU V0, -32725(GP)
9D005F74  24420001   ADDIU V0, V0, 1
9D005F78  304200FF   ANDI V0, V0, 255
9D005F7C  A382802B   SB V0, -32725(GP)
156:                                                 head &=31;
9D005F80  9382802B   LBU V0, -32725(GP)
9D005F84  3042001F   ANDI V0, V0, 31
9D005F88  A382802B   SB V0, -32725(GP)
9D005F8C  2484FFFF   ADDIU A0, A0, -1
157:                                             }
158:                                             code = PRN;
159:                                         }
160:                                         state = ST_COMPLETED;
161:                                     }
162:                                     break;
163:                                 case ST_RELEASE:
164:                                     if ((flags & XT_BIT) && (code==0x7c)){ //touche PrtSc relâchée.
9D005EAC  0B4017E8   J 0x9D005FA0
9D005EB0  30C30100   ANDI V1, A2, 256
9D005FA0  1060001A   BEQ V1, ZERO, 0x9D00600C
9D005FA4  3C03BF88   LUI V1, -16504
9D005FA8  2403007C   ADDIU V1, ZERO, 124
9D005FAC  14430017   BNE V0, V1, 0x9D00600C
9D005FB0  3C03BF88   LUI V1, -16504
9D005FB4  24040003   ADDIU A0, ZERO, 3
165:                                         for (i=3;i;i--){ // élimine les 3 codes suivants.
9D005FF0  1480FFF1   BNE A0, ZERO, 0x9D005FB8
9D005FF4  24020112   ADDIU V0, ZERO, 274
9D005FF8  0B401802   J 0x9D006008
9D005FFC  00A03021   ADDU A2, A1, ZERO
166:                                             _wait_key();
9D005FB8  9383802B   LBU V1, -32725(GP)
9D005FBC  306300FF   ANDI V1, V1, 255
9D005FC0  93828029   LBU V0, -32727(GP)
9D005FC4  304200FF   ANDI V0, V0, 255
9D005FC8  1062FFFB   BEQ V1, V0, 0x9D005FB8
9D005FCC  00000000   NOP
167:                                             head++;
9D005FD0  9382802B   LBU V0, -32725(GP)
9D005FD4  24420001   ADDIU V0, V0, 1
9D005FD8  304200FF   ANDI V0, V0, 255
9D005FDC  A382802B   SB V0, -32725(GP)
168:                                             head &= 31;
9D005FE0  9382802B   LBU V0, -32725(GP)
9D005FE4  3042001F   ANDI V0, V0, 31
9D005FE8  A382802B   SB V0, -32725(GP)
9D005FEC  2484FFFF   ADDIU A0, A0, -1
169:                                         }
170:                                         code = PRN;
171:                                     }
172:                                     state=ST_COMPLETED;
173:                                     break;
174:                                 default:;
175:                             }//switch(state)
176:                         }//while(state...)
177:                         IEC0bits.INT4IE=0; // section critique désactive interruption
9D005F24  0B401803   J 0x9D00600C
9D005F28  3C03BF88   LUI V1, -16504
9D006008  3C03BF88   LUI V1, -16504
9D00600C  8C641060   LW A0, 4192(V1)
9D006010  7C04BDC4   INS A0, ZERO, 23, 1
9D006014  AC641060   SW A0, 4192(V1)
178:                 	if (head==tail){
9D006018  9384802B   LBU A0, -32725(GP)
9D00601C  308400FF   ANDI A0, A0, 255
9D006020  93838029   LBU V1, -32727(GP)
9D006024  306300FF   ANDI V1, V1, 255
9D006028  14830005   BNE A0, V1, 0x9D006040
9D00602C  3C03BF88   LUI V1, -16504
179:                 		rx_flags &= ~F_RCVD;
9D006030  93838025   LBU V1, -32731(GP)
9D006034  306300FD   ANDI V1, V1, 253
9D006038  A3838025   SB V1, -32731(GP)
180:                 	}
181:                         IEC0bits.INT4IE=1; // fin section critique réactive interruption
9D00603C  3C03BF88   LUI V1, -16504
9D006040  8C641060   LW A0, 4192(V1)
9D006044  24050001   ADDIU A1, ZERO, 1
9D006048  7CA4BDC4   INS A0, A1, 23, 1
9D00604C  AC641060   SW A0, 4192(V1)
182:                         if ((code==KBD_ACK)||(code==KBD_RSND)||(code==BAT_OK)||(code==BAT_ERROR)){
9D006050  240300FA   ADDIU V1, ZERO, 250
9D006054  104300BF   BEQ V0, V1, 0x9D006354
9D006058  240300FE   ADDIU V1, ZERO, 254
9D00605C  104300BD   BEQ V0, V1, 0x9D006354
9D006060  240300AA   ADDIU V1, ZERO, 170
9D006064  104300BB   BEQ V0, V1, 0x9D006354
9D006068  240300FC   ADDIU V1, ZERO, 252
9D00606C  104300B9   BEQ V0, V1, 0x9D006354
9D006070  24030058   ADDIU V1, ZERO, 88
183:                             return code;
184:                         }
185:                         code |= flags;
9D006074  00462825   OR A1, V0, A2
9D006078  30A5FFFF   ANDI A1, A1, -1
9D00607C  7C051620   SEH V0, A1
186:                         for (i=0;i<FN_COUNT;i++){
9D006340  5467FF56   BNEL V1, A3, 0x9D00609C
9D006344  84640000   LH A0, 0(V1)
187:                             if ((code&0x1ff)==fn_keys[i]){
9D006080  30A501FF   ANDI A1, A1, 511
9D006084  10A30007   BEQ A1, V1, 0x9D0060A4
9D006088  3C039D01   LUI V1, -25343
9D00608C  2463A406   ADDIU V1, V1, -23546
9D006098  84640000   LH A0, 0(V1)
9D00609C  148500A8   BNE A0, A1, 0x9D006340
9D0060A0  24630002   ADDIU V1, V1, 2
188:                                 code |= FN_BIT;
9D0060A4  34420200   ORI V0, V0, 512
9D0060A8  7C021620   SEH V0, V0
189:                                 switch (code&0x1ff){ // les touches d'alteration sont traitées ici.
9D0060AC  304301FF   ANDI V1, V0, 511
9D0060B0  24040059   ADDIU A0, ZERO, 89
9D0060B4  10640030   BEQ V1, A0, 0x9D006178
9D0060B8  2864005A   SLTI A0, V1, 90
9D0060BC  10800011   BEQ A0, ZERO, 0x9D006104
9D0060C0  2404007E   ADDIU A0, ZERO, 126
9D0060C4  24040012   ADDIU A0, ZERO, 18
9D0060C8  1064001D   BEQ V1, A0, 0x9D006140
9D0060CC  28640013   SLTI A0, V1, 19
9D0060D0  10800006   BEQ A0, ZERO, 0x9D0060EC
9D0060D4  24040014   ADDIU A0, ZERO, 20
9D0060D8  24040011   ADDIU A0, ZERO, 17
9D0060DC  1464009A   BNE V1, A0, 0x9D006348
9D0060E0  00000000   NOP
9D0060EC  10640030   BEQ V1, A0, 0x9D0061B0
9D0060F0  24040058   ADDIU A0, ZERO, 88
9D0060F4  14640094   BNE V1, A0, 0x9D006348
9D0060F8  00000000   NOP
9D006104  1064007E   BEQ V1, A0, 0x9D006300
9D006108  2864007F   SLTI A0, V1, 127
9D00610C  10800006   BEQ A0, ZERO, 0x9D006128
9D006110  24040111   ADDIU A0, ZERO, 273
9D006114  24040077   ADDIU A0, ZERO, 119
9D006118  1464008B   BNE V1, A0, 0x9D006348
9D00611C  00000000   NOP
9D006128  1064003C   BEQ V1, A0, 0x9D00621C
9D00612C  24040114   ADDIU A0, ZERO, 276
9D006130  14640085   BNE V1, A0, 0x9D006348
9D006134  00000000   NOP
190:                                     case LSHIFT:
191:                                         if (flags & REL_BIT){
9D006140  30C68000   ANDI A2, A2, -32768
9D006144  10C00006   BEQ A2, ZERO, 0x9D006160
9D006148  00000000   NOP
192:                                             key_state &=~F_LSHIFT;
9D00614C  97828058   LHU V0, -32680(GP)
9D006150  3042FFF7   ANDI V0, V0, -9
9D006154  A7828058   SH V0, -32680(GP)
9D006158  0B4018D5   J 0x9D006354
9D00615C  00001021   ADDU V0, ZERO, ZERO
193:                                         }else{
194:                                             key_state |= F_LSHIFT;
9D006160  97828058   LHU V0, -32680(GP)
9D006164  3042FFFF   ANDI V0, V0, -1
9D006168  34420008   ORI V0, V0, 8
9D00616C  A7828058   SH V0, -32680(GP)
9D006170  0B4018D5   J 0x9D006354
9D006174  00001021   ADDU V0, ZERO, ZERO
195:                                         }
196:                                         code=0;
197:                                         break;
198:                                     case RSHIFT:
199:                                         if (flags & REL_BIT){
9D006178  30C68000   ANDI A2, A2, -32768
9D00617C  10C00006   BEQ A2, ZERO, 0x9D006198
9D006180  00000000   NOP
200:                                             key_state &=~F_RSHIFT;
9D006184  97828058   LHU V0, -32680(GP)
9D006188  3042FFEF   ANDI V0, V0, -17
9D00618C  A7828058   SH V0, -32680(GP)
9D006190  0B4018D5   J 0x9D006354
9D006194  00001021   ADDU V0, ZERO, ZERO
201:                                         }else{
202:                                             key_state |= F_RSHIFT;
9D006198  97828058   LHU V0, -32680(GP)
9D00619C  3042FFFF   ANDI V0, V0, -1
9D0061A0  34420010   ORI V0, V0, 16
9D0061A4  A7828058   SH V0, -32680(GP)
9D0061A8  0B4018D5   J 0x9D006354
9D0061AC  00001021   ADDU V0, ZERO, ZERO
203:                                         }
204:                                         code=0;
205:                                         break;
206:                                     case LCTRL:
207:                                         if (flags & REL_BIT){
9D0061B0  30C68000   ANDI A2, A2, -32768
9D0061B4  10C00006   BEQ A2, ZERO, 0x9D0061D0
9D0061B8  00000000   NOP
208:                                             key_state &=~F_LCTRL;
9D0061BC  97828058   LHU V0, -32680(GP)
9D0061C0  3042FFDF   ANDI V0, V0, -33
9D0061C4  A7828058   SH V0, -32680(GP)
9D0061C8  0B4018D5   J 0x9D006354
9D0061CC  00001021   ADDU V0, ZERO, ZERO
209:                                         }else{
210:                                             key_state |= F_LCTRL;
9D0061D0  97828058   LHU V0, -32680(GP)
9D0061D4  3042FFFF   ANDI V0, V0, -1
9D0061D8  34420020   ORI V0, V0, 32
9D0061DC  A7828058   SH V0, -32680(GP)
9D0061E0  0B4018D5   J 0x9D006354
9D0061E4  00001021   ADDU V0, ZERO, ZERO
211:                                         }
212:                                         code=0;
213:                                         break;
214:                                     case RCTRL:
215:                                         if (flags & REL_BIT){
9D006138  0B40187A   J 0x9D0061E8
9D00613C  30C68000   ANDI A2, A2, -32768
9D0061E8  10C00006   BEQ A2, ZERO, 0x9D006204
9D0061EC  00000000   NOP
216:                                             key_state &=~F_RCTRL;
9D0061F0  97828058   LHU V0, -32680(GP)
9D0061F4  3042FFBF   ANDI V0, V0, -65
9D0061F8  A7828058   SH V0, -32680(GP)
9D0061FC  0B4018D5   J 0x9D006354
9D006200  00001021   ADDU V0, ZERO, ZERO
217:                                         }else{
218:                                             key_state |= F_RCTRL;
9D006204  97828058   LHU V0, -32680(GP)
9D006208  3042FFFF   ANDI V0, V0, -1
9D00620C  34420040   ORI V0, V0, 64
9D006210  A7828058   SH V0, -32680(GP)
9D006214  0B4018D5   J 0x9D006354
9D006218  00001021   ADDU V0, ZERO, ZERO
219:                                         }
220:                                         code=0;
221:                                         break;
222:                                     case RALT:
223:                                         if (flags & REL_BIT){
9D00621C  30C68000   ANDI A2, A2, -32768
9D006220  10C00006   BEQ A2, ZERO, 0x9D00623C
9D006224  00000000   NOP
224:                                             key_state &=~F_ALTCHAR;
9D006228  97828058   LHU V0, -32680(GP)
9D00622C  3042FEFF   ANDI V0, V0, -257
9D006230  A7828058   SH V0, -32680(GP)
9D006234  0B4018D5   J 0x9D006354
9D006238  00001021   ADDU V0, ZERO, ZERO
225:                                         }else{
226:                                             key_state |= F_ALTCHAR;
9D00623C  97828058   LHU V0, -32680(GP)
9D006240  3042FFFF   ANDI V0, V0, -1
9D006244  34420100   ORI V0, V0, 256
9D006248  A7828058   SH V0, -32680(GP)
9D00624C  0B4018D5   J 0x9D006354
9D006250  00001021   ADDU V0, ZERO, ZERO
227:                                         }
228:                                         code=0;
229:                                         break;
230:                                     case LALT:
231:                                         if (flags & REL_BIT){
9D0060E4  0B401895   J 0x9D006254
9D0060E8  30C68000   ANDI A2, A2, -32768
9D006254  10C00006   BEQ A2, ZERO, 0x9D006270
9D006258  00000000   NOP
232:                                             key_state &=~F_LALT;
9D00625C  97828058   LHU V0, -32680(GP)
9D006260  3042FF7F   ANDI V0, V0, -129
9D006264  A7828058   SH V0, -32680(GP)
9D006268  0B4018D5   J 0x9D006354
9D00626C  00001021   ADDU V0, ZERO, ZERO
233:                                         }else{
234:                                             key_state |= F_LALT;
9D006270  97828058   LHU V0, -32680(GP)
9D006274  3042FFFF   ANDI V0, V0, -1
9D006278  34420080   ORI V0, V0, 128
9D00627C  A7828058   SH V0, -32680(GP)
9D006280  0B4018D5   J 0x9D006354
9D006284  00001021   ADDU V0, ZERO, ZERO
235:                                         }
236:                                         code=0;
237:                                         break;
238:                                     case NUM_LOCK:
239:                                         if (flags & REL_BIT){
9D006120  0B4018A2   J 0x9D006288
9D006124  30C68000   ANDI A2, A2, -32768
9D006288  10C0002F   BEQ A2, ZERO, 0x9D006348
9D00628C  00000000   NOP
240:                                             kbd_leds ^= F_NUM;
9D006290  93828026   LBU V0, -32730(GP)
9D006294  304200FF   ANDI V0, V0, 255
9D006298  38420002   XORI V0, V0, 2
9D00629C  A3828026   SB V0, -32730(GP)
241:                                             key_state ^= F_NUM;
9D0062A0  97828058   LHU V0, -32680(GP)
9D0062A4  3042FFFF   ANDI V0, V0, -1
9D0062A8  38420002   XORI V0, V0, 2
9D0062AC  A7828058   SH V0, -32680(GP)
242:                                             SetKbdLeds(kbd_leds);
9D0062B0  93848026   LBU A0, -32730(GP)
9D0062B4  0F401732   JAL SetKbdLeds
9D0062B8  308400FF   ANDI A0, A0, 255
9D0062BC  0B4018D5   J 0x9D006354
9D0062C0  00001021   ADDU V0, ZERO, ZERO
243:                                             code=0;
244:                                         }
245:                                         break;
246:                                     case CAPS_LOCK:
247:                                         if (flags & REL_BIT){
9D0060FC  0B4018B1   J 0x9D0062C4
9D006100  30C68000   ANDI A2, A2, -32768
9D0062C4  10C00020   BEQ A2, ZERO, 0x9D006348
9D0062C8  00000000   NOP
248:                                             kbd_leds ^= F_CAPS;
9D0062CC  93828026   LBU V0, -32730(GP)
9D0062D0  304200FF   ANDI V0, V0, 255
9D0062D4  38420004   XORI V0, V0, 4
9D0062D8  A3828026   SB V0, -32730(GP)
249:                                             key_state ^= F_CAPS;
9D0062DC  97828058   LHU V0, -32680(GP)
9D0062E0  3042FFFF   ANDI V0, V0, -1
9D0062E4  38420004   XORI V0, V0, 4
9D0062E8  A7828058   SH V0, -32680(GP)
250:                                             SetKbdLeds(kbd_leds);
9D0062EC  93848026   LBU A0, -32730(GP)
9D0062F0  0F401732   JAL SetKbdLeds
9D0062F4  308400FF   ANDI A0, A0, 255
9D0062F8  0B4018D5   J 0x9D006354
9D0062FC  00001021   ADDU V0, ZERO, ZERO
251:                                             code=0;
252:                                         }
253:                                         break;
254:                                     case SCROLL_LOCK:
255:                                         if (flags & REL_BIT){
9D006300  30C68000   ANDI A2, A2, -32768
9D006304  10C00010   BEQ A2, ZERO, 0x9D006348
9D006308  00000000   NOP
256:                                             kbd_leds ^= F_SCROLL;
9D00630C  93828026   LBU V0, -32730(GP)
9D006310  304200FF   ANDI V0, V0, 255
9D006314  38420001   XORI V0, V0, 1
9D006318  A3828026   SB V0, -32730(GP)
257:                                             key_state ^= F_SCROLL;
9D00631C  97828058   LHU V0, -32680(GP)
9D006320  3042FFFF   ANDI V0, V0, -1
9D006324  38420001   XORI V0, V0, 1
9D006328  A7828058   SH V0, -32680(GP)
258:                                             SetKbdLeds(kbd_leds);
9D00632C  93848026   LBU A0, -32730(GP)
9D006330  0F401732   JAL SetKbdLeds
9D006334  308400FF   ANDI A0, A0, 255
9D006338  0B4018D5   J 0x9D006354
9D00633C  00001021   ADDU V0, ZERO, ZERO
259:                                             code=0;
260:                                         }
261:                                         break;
262:                                     default:;
263:                                 }//switch(code)
264:                                 break;
265:                             }// if
266:                         }//for
267:                         if ((code < 0) && !(code & FN_BIT)) // ne retourne pas les relâchement de touche pour les touches caractères.
9D006348  04410002   BGEZ V0, 0x9D006354
9D00634C  30430200   ANDI V1, V0, 512
268:                             return 0;
9D006350  0003100A   MOVZ V0, ZERO, V1
269:                         else
270:                             return code;
271:                 }// GetScancode()
9D006354  8FBF0014   LW RA, 20(SP)
9D006358  8FB00010   LW S0, 16(SP)
9D00635C  03E00008   JR RA
9D006360  27BD0018   ADDIU SP, SP, 24
272:                 
273:                 
274:                 short KbdKey(short scancode){  // obtient la transcription du code en ASCII
9D005900  7C042620   SEH A0, A0
275:                 	int a,i;
276:                 	a=0;
9D00596C  0B4016BC   J 0x9D005AF0
9D005970  00001021   ADDU V0, ZERO, ZERO
277:                 	if (scancode & XT_BIT){
9D005904  3086FFFF   ANDI A2, A0, -1
9D005908  30C20100   ANDI V0, A2, 256
9D00590C  10400019   BEQ V0, ZERO, 0x9D005974
9D005910  3C029D01   LUI V0, -25343
278:                 		i=0;
279:                 		while (qwerty_xt_char[i].code){
9D005914  84439C70   LH V1, -25488(V0)
9D005918  10600075   BEQ V1, ZERO, 0x9D005AF0
9D00591C  00001021   ADDU V0, ZERO, ZERO
9D005960  84430000   LH V1, 0(V0)
9D005964  1460FFF2   BNE V1, ZERO, 0x9D005930
9D005968  24A50001   ADDIU A1, A1, 1
280:                 			if (qwerty_xt_char[i].code==scancode){
9D005920  5483000D   BNEL A0, V1, 0x9D005958
9D005924  3C029D01   LUI V0, -25343
9D005928  0B401650   J 0x9D005940
9D00592C  00002821   ADDU A1, ZERO, ZERO
9D005930  1483000B   BNE A0, V1, 0x9D005960
9D005934  24420004   ADDIU V0, V0, 4
9D00595C  00002821   ADDU A1, ZERO, ZERO
281:                 				a=qwerty_xt_char[i].ascii;
9D005938  0B401651   J 0x9D005944
9D00593C  00052880   SLL A1, A1, 2
9D005940  00052880   SLL A1, A1, 2
9D005944  3C029D01   LUI V0, -25343
9D005948  24429C70   ADDIU V0, V0, -25488
9D00594C  00452821   ADDU A1, V0, A1
282:                 				break;
9D005950  0B4016BC   J 0x9D005AF0
9D005954  84A20002   LH V0, 2(A1)
9D005958  24429C74   ADDIU V0, V0, -25484
283:                 			}
284:                 			i++;
285:                 		} // while (xt_char[i].code)
286:                 	}else if (key_state & F_SHIFT){
9D005974  97828058   LHU V0, -32680(GP)
9D005978  30420018   ANDI V0, V0, 24
9D00597C  5440000A   BNEL V0, ZERO, 0x9D0059A8
9D005980  3C029D01   LUI V0, -25343
287:                 		i=0;
288:                 		while (qwerty_shifted_key[i].code){
9D0059A8  84429C1C   LH V0, -25572(V0)
9D0059AC  50400019   BEQL V0, ZERO, 0x9D005A14
9D0059B0  3C029D01   LUI V0, -25343
9D005A04  84430000   LH V1, 0(V0)
9D005A08  1460FFEF   BNE V1, ZERO, 0x9D0059C8
9D005A0C  24A50001   ADDIU A1, A1, 1
289:                 			if (qwerty_shifted_key[i].code==(scancode&0xff)){
9D0059B4  30C700FF   ANDI A3, A2, 255
9D0059B8  14470010   BNE V0, A3, 0x9D0059FC
9D0059BC  3C029D01   LUI V0, -25343
9D0059C0  0B401676   J 0x9D0059D8
9D0059C4  00002821   ADDU A1, ZERO, ZERO
9D0059C8  1467000E   BNE V1, A3, 0x9D005A04
9D0059CC  24420004   ADDIU V0, V0, 4
9D005A00  00002821   ADDU A1, ZERO, ZERO
290:                 				a=qwerty_shifted_key[i].ascii;
9D0059D0  0B401677   J 0x9D0059DC
9D0059D4  00052880   SLL A1, A1, 2
9D0059D8  00052880   SLL A1, A1, 2
9D0059DC  3C029D01   LUI V0, -25343
9D0059E0  24429C1C   ADDIU V0, V0, -25572
9D0059E4  00452821   ADDU A1, V0, A1
9D0059E8  84A20002   LH V0, 2(A1)
291:                 				break;
292:                 			}
293:                 			i++;
294:                 		}// while (shifted_key.code)
295:                 		if (!a){
9D0059EC  14400041   BNE V0, ZERO, 0x9D005AF4
9D0059F0  2403FF00   ADDIU V1, ZERO, -256
9D0059FC  24429C20   ADDIU V0, V0, -25568
296:                 			i=0;
297:                 			while (qwerty[i].code){
9D0059F4  0B401685   J 0x9D005A14
9D0059F8  3C029D01   LUI V0, -25343
9D005A10  3C029D01   LUI V0, -25343
9D005A14  84439B0C   LH V1, -25844(V0)
9D005A18  10600035   BEQ V1, ZERO, 0x9D005AF0
9D005A1C  00001021   ADDU V0, ZERO, ZERO
9D005A74  84430000   LH V1, 0(V0)
9D005A78  1460FFEE   BNE V1, ZERO, 0x9D005A34
9D005A7C  24A50001   ADDIU A1, A1, 1
9D005A80  0B4016BC   J 0x9D005AF0
9D005A84  00001021   ADDU V0, ZERO, ZERO
298:                 				if (qwerty[i].code==(scancode&0xff)){
9D005A20  30C600FF   ANDI A2, A2, 255
9D005A24  54660011   BNEL V1, A2, 0x9D005A6C
9D005A28  3C029D01   LUI V0, -25343
9D005A2C  0B401691   J 0x9D005A44
9D005A30  00002821   ADDU A1, ZERO, ZERO
9D005A34  14C3000F   BNE A2, V1, 0x9D005A74
9D005A38  24420004   ADDIU V0, V0, 4
9D005A70  00002821   ADDU A1, ZERO, ZERO
299:                 					a=qwerty[i].ascii;
9D005A3C  0B401692   J 0x9D005A48
9D005A40  00052880   SLL A1, A1, 2
9D005A44  00052880   SLL A1, A1, 2
9D005A48  3C029D01   LUI V0, -25343
9D005A4C  24429B0C   ADDIU V0, V0, -25844
9D005A50  00452821   ADDU A1, V0, A1
9D005A54  84A20002   LH V0, 2(A1)
300:                 					break;
301:                 				}
302:                 				i++;
303:                 			}// while (translate.code)
304:                 			if (a>='a' && a<='z'){
9D005A58  2445FF9F   ADDIU A1, V0, -97
9D005A5C  2CA5001A   SLTIU A1, A1, 26
9D005A6C  24429B10   ADDIU V0, V0, -25840
305:                 				a -=32;
9D005A60  2443FFE0   ADDIU V1, V0, -32
9D005A64  0B4016BC   J 0x9D005AF0
9D005A68  0065100B   MOVN V0, V1, A1
306:                 			}
307:                 		} // if (!a)
308:                 	}else{
309:                 		i=0;
310:                 		while (qwerty[i].code){
9D005984  3C029D01   LUI V0, -25343
9D005988  84439B0C   LH V1, -25844(V0)
9D00598C  10600058   BEQ V1, ZERO, 0x9D005AF0
9D005990  00001021   ADDU V0, ZERO, ZERO
9D005ACC  84430000   LH V1, 0(V0)
9D005AD0  1460FFED   BNE V1, ZERO, 0x9D005A88
9D005AD4  24A50001   ADDIU A1, A1, 1
9D005AD8  0B4016BC   J 0x9D005AF0
9D005ADC  00001021   ADDU V0, ZERO, ZERO
311:                 			if (qwerty[i].code==(scancode&0xff)){
9D005994  30C600FF   ANDI A2, A2, 255
9D005998  1466004A   BNE V1, A2, 0x9D005AC4
9D00599C  3C029D01   LUI V0, -25343
9D0059A0  0B4016A6   J 0x9D005A98
9D0059A4  00002821   ADDU A1, ZERO, ZERO
9D005A88  14660010   BNE V1, A2, 0x9D005ACC
9D005A8C  24420004   ADDIU V0, V0, 4
9D005AC8  00002821   ADDU A1, ZERO, ZERO
312:                 				a=qwerty[i].ascii;
9D005A90  0B4016A7   J 0x9D005A9C
9D005A94  00052880   SLL A1, A1, 2
9D005A98  00052880   SLL A1, A1, 2
9D005A9C  3C029D01   LUI V0, -25343
9D005AA0  24429B0C   ADDIU V0, V0, -25844
9D005AA4  00452821   ADDU A1, V0, A1
9D005AA8  84A20002   LH V0, 2(A1)
313:                 				break;
314:                 			}
315:                 			i++;
316:                 		}// while (translate.code)
317:                 		if (a>='a' && a<='z' && (key_state & F_CAPS)){
9D005AAC  2443FF9F   ADDIU V1, V0, -97
9D005AB0  2C63001A   SLTIU V1, V1, 26
9D005AB4  1460000A   BNE V1, ZERO, 0x9D005AE0
9D005AB8  2403FF00   ADDIU V1, ZERO, -256
9D005AC4  24429B10   ADDIU V0, V0, -25840
9D005AE0  97858058   LHU A1, -32680(GP)
9D005AE4  30A50004   ANDI A1, A1, 4
318:                 			a -=32;
9D005AE8  2443FFE0   ADDIU V1, V0, -32
9D005AEC  0065100B   MOVN V0, V1, A1
319:                 		}
320:                 	}
321:                 	return a|(scancode&0xff00);
9D005ABC  0B4016BE   J 0x9D005AF8
9D005AC0  00832024   AND A0, A0, V1
9D005AF0  2403FF00   ADDIU V1, ZERO, -256
9D005AF4  00832024   AND A0, A0, V1
9D005AF8  00441025   OR V0, V0, A0
322:                 } // GetKey()
9D005AFC  03E00008   JR RA
9D005B00  7C021620   SEH V0, V0
323:                 
324:                 void KbdSend(char cmd){  // envoie une commande au clavier
9D005B04  7C042420   SEB A0, A0
325:                     register unsigned int dly;
326:                         bit_cnt=0;
9D005B08  A3808027   SB ZERO, -32729(GP)
327:                 	parity=0;
9D005B0C  A3808028   SB ZERO, -32728(GP)
328:                 	IEC0CLR=_IEC0_INT4IE_MASK; // désactive les interruptions sur KBD_CLK
9D005B10  3C030080   LUI V1, 128
9D005B14  3C02BF88   LUI V0, -16504
9D005B18  AC431064   SW V1, 4196(V0)
329:                         TRISACLR = KBD_CLK; // MCU prend le contrôle de la ligne KBD_CLK
9D005B1C  24020001   ADDIU V0, ZERO, 1
9D005B20  3C03BF88   LUI V1, -16504
9D005B24  AC626014   SW V0, 24596(V1)
330:                         LATACLR = KBD_CLK; //  mis à 0  KBD_CLK
9D005B28  3C03BF88   LUI V1, -16504
9D005B2C  AC626034   SW V0, 24628(V1)
9D005B30  240204C5   ADDIU V0, ZERO, 1221
9D005B34  2442FFFF   ADDIU V0, V0, -1
331:                         // délais minimum 100µsec
332:                         for (dly=(100/3*CLK_PER_USEC);dly;dly--);
9D005B38  1440FFFF   BNE V0, ZERO, 0x9D005B38
9D005B3C  2442FFFF   ADDIU V0, V0, -1
333:                         TRISACLR = KBD_DAT;	// prend le contrôle de la ligne KBD_DAT
9D005B40  24020002   ADDIU V0, ZERO, 2
9D005B44  3C03BF88   LUI V1, -16504
9D005B48  AC626014   SW V0, 24596(V1)
334:                 	LATACLR = KBD_DAT;   	// met KBD_DAT à zéro
9D005B4C  3C03BF88   LUI V1, -16504
9D005B50  AC626034   SW V0, 24628(V1)
335:                 	TRISASET = KBD_CLK; 	// libère la ligne clock
9D005B54  24030001   ADDIU V1, ZERO, 1
9D005B58  3C02BF88   LUI V0, -16504
9D005B5C  AC436018   SW V1, 24600(V0)
336:                         while (!(PORTAbits.RA0)); // attend que la ligne revienne à 1
9D005B60  3C03BF88   LUI V1, -16504
9D005B64  8C626020   LW V0, 24608(V1)
9D005B68  30420001   ANDI V0, V0, 1
9D005B6C  1040FFFD   BEQ V0, ZERO, 0x9D005B64
9D005B70  00000000   NOP
337:                         while (bit_cnt<8){      // envoie les 8 bits, le moins significatif en premier.
9D005B74  93828027   LBU V0, -32729(GP)
9D005B78  304200FF   ANDI V0, V0, 255
9D005B7C  2C420008   SLTIU V0, V0, 8
9D005B80  1040001F   BEQ V0, ZERO, 0x9D005C00
9D005B84  3C02BF88   LUI V0, -16504
9D005BEC  93838027   LBU V1, -32729(GP)
9D005BF0  306300FF   ANDI V1, V1, 255
9D005BF4  2C630008   SLTIU V1, V1, 8
9D005BF8  1460FFE6   BNE V1, ZERO, 0x9D005B94
9D005BFC  00042043   SRA A0, A0, 1
338:                 		while (PORTAbits.RA0);   // attend clock à 0
9D005B94  8C436020   LW V1, 24608(V0)
9D005B98  30630001   ANDI V1, V1, 1
9D005B9C  1460FFFD   BNE V1, ZERO, 0x9D005B94
9D005BA0  30830001   ANDI V1, A0, 1
339:                                 if (cmd&1){
9D005BA4  10600008   BEQ V1, ZERO, 0x9D005BC8
9D005BA8  00000000   NOP
340:                 			LATASET = KBD_DAT;
9D005B90  3C06BF88   LUI A2, -16504
9D005BAC  ACC56038   SW A1, 24632(A2)
341:                 			parity++;
9D005BB0  93838028   LBU V1, -32728(GP)
9D005BB4  24630001   ADDIU V1, V1, 1
9D005BB8  306300FF   ANDI V1, V1, 255
9D005BBC  A3838028   SB V1, -32728(GP)
9D005BC0  0B4016F3   J 0x9D005BCC
9D005BC4  00000000   NOP
342:                 		}else{
343:                 			LATACLR = KBD_DAT;
9D005B88  3C07BF88   LUI A3, -16504
9D005B8C  24050002   ADDIU A1, ZERO, 2
9D005BC8  ACE56034   SW A1, 24628(A3)
344:                 		}
345:                 		cmd >>= 1;
346:                 		while (!(PORTAbits.RA0)); // attend clock à 1
9D005BCC  8C436020   LW V1, 24608(V0)
9D005BD0  30630001   ANDI V1, V1, 1
9D005BD4  1060FFFD   BEQ V1, ZERO, 0x9D005BCC
9D005BD8  00000000   NOP
347:                 		bit_cnt++;				  // un bit de plus envoyé.
9D005BDC  93838027   LBU V1, -32729(GP)
9D005BE0  24630001   ADDIU V1, V1, 1
9D005BE4  306300FF   ANDI V1, V1, 255
9D005BE8  A3838027   SB V1, -32729(GP)
348:                 	}
349:                         while (PORTAbits.RA0);   // attend clock à 0
9D005C00  3C03BF88   LUI V1, -16504
9D005C04  8C626020   LW V0, 24608(V1)
9D005C08  30420001   ANDI V0, V0, 1
9D005C0C  1440FFFD   BNE V0, ZERO, 0x9D005C04
9D005C10  00000000   NOP
350:                 	if (!(parity & 1)){
9D005C14  93828028   LBU V0, -32728(GP)
9D005C18  30420001   ANDI V0, V0, 1
9D005C1C  14400005   BNE V0, ZERO, 0x9D005C34
9D005C20  24030002   ADDIU V1, ZERO, 2
351:                 		LATASET = KBD_DAT;
9D005C24  3C02BF88   LUI V0, -16504
9D005C28  AC436038   SW V1, 24632(V0)
352:                 	}else{
353:                 		LATACLR = KBD_DAT;
9D005C34  3C02BF88   LUI V0, -16504
9D005C38  AC436034   SW V1, 24628(V0)
354:                 	}
355:                 	while (!(PORTAbits.RA0)); // attend clock à 1
9D005C2C  0B401710   J 0x9D005C40
9D005C30  3C03BF88   LUI V1, -16504
9D005C3C  3C03BF88   LUI V1, -16504
9D005C40  8C626020   LW V0, 24608(V1)
9D005C44  30420001   ANDI V0, V0, 1
9D005C48  1040FFFD   BEQ V0, ZERO, 0x9D005C40
9D005C4C  00000000   NOP
356:                 	while (PORTAbits.RA0);   // attend clock à 0
9D005C50  3C03BF88   LUI V1, -16504
9D005C54  8C626020   LW V0, 24608(V1)
9D005C58  30420001   ANDI V0, V0, 1
9D005C5C  1440FFFD   BNE V0, ZERO, 0x9D005C54
9D005C60  3C02BF88   LUI V0, -16504
357:                 	TRISASET = KBD_DAT;  		// libère la ligne data
9D005C64  24030002   ADDIU V1, ZERO, 2
9D005C68  AC436018   SW V1, 24600(V0)
358:                 	while (!(PORTAbits.RA0)); // attend clock à 1
9D005C6C  3C03BF88   LUI V1, -16504
9D005C70  8C626020   LW V0, 24608(V1)
9D005C74  30420001   ANDI V0, V0, 1
9D005C78  1040FFFD   BEQ V0, ZERO, 0x9D005C70
9D005C7C  00000000   NOP
359:                 	while (PORTA & (KBD_DAT+KBD_CLK)); 	// attend que le clavier mette data et clock à 0
9D005C80  3C03BF88   LUI V1, -16504
9D005C84  8C626020   LW V0, 24608(V1)
9D005C88  30420003   ANDI V0, V0, 3
9D005C8C  1440FFFD   BNE V0, ZERO, 0x9D005C84
9D005C90  3C04BF88   LUI A0, -16504
360:                 	while (!((PORTA & (KBD_DAT+KBD_CLK))==(KBD_DAT+KBD_CLK))); // attend que les 2 lignes reviennent à 1.
9D005C94  24030003   ADDIU V1, ZERO, 3
9D005C98  8C826020   LW V0, 24608(A0)
9D005C9C  30420003   ANDI V0, V0, 3
9D005CA0  1443FFFD   BNE V0, V1, 0x9D005C98
9D005CA4  00000000   NOP
361:                 	bit_cnt=0;
9D005CA8  A3808027   SB ZERO, -32729(GP)
362:                         IFS0CLR=_IFS0_INT4IF_MASK;
9D005CAC  3C020080   LUI V0, 128
9D005CB0  3C03BF88   LUI V1, -16504
9D005CB4  AC621034   SW V0, 4148(V1)
363:                 	IEC0SET = _IEC0_INT4IE_MASK; // réactivation interruption
9D005CB8  3C03BF88   LUI V1, -16504
9D005CBC  AC621068   SW V0, 4200(V1)
364:                 } // KbdSend()
9D005CC0  03E00008   JR RA
9D005CC4  00000000   NOP
365:                 
366:                 int SetKbdLeds(unsigned char leds_state){ // contrôle l'état des LEDS du clavier
9D005CC8  27BDFFE0   ADDIU SP, SP, -32
9D005CCC  AFBF001C   SW RA, 28(SP)
9D005CD0  AFB20018   SW S2, 24(SP)
9D005CD4  AFB10014   SW S1, 20(SP)
9D005CD8  AFB00010   SW S0, 16(SP)
367:                     unsigned int t0;
368:                     short c;
369:                     t0=ticks()+100;
9D005CDC  0F40240C   JAL ticks
9D005CE0  309200FF   ANDI S2, A0, 255
9D005CE4  24510064   ADDIU S1, V0, 100
370:                     KbdSend(KBD_LED);
9D005CE8  0F4016C1   JAL KbdSend
9D005CEC  2404FFED   ADDIU A0, ZERO, -19
371:                     c=0;
372:                     while (!(ticks()==t0) && !(rx_flags & F_ERROR) && !c){
9D005CF0  0B401741   J 0x9D005D04
9D005CF4  00008021   ADDU S0, ZERO, ZERO
9D005D04  0F40240C   JAL ticks
9D005D08  00000000   NOP
9D005D0C  10510007   BEQ V0, S1, 0x9D005D2C
9D005D10  240200FA   ADDIU V0, ZERO, 250
9D005D14  93828025   LBU V0, -32731(GP)
9D005D18  30420001   ANDI V0, V0, 1
9D005D1C  14400003   BNE V0, ZERO, 0x9D005D2C
9D005D20  240200FA   ADDIU V0, ZERO, 250
9D005D24  1200FFF4   BEQ S0, ZERO, 0x9D005CF8
9D005D28  00000000   NOP
373:                         c=KbdScancode();
9D005CF8  0F401767   JAL KbdScancode
9D005CFC  00000000   NOP
9D005D00  00408021   ADDU S0, V0, ZERO
374:                     }
375:                     if (c==KBD_ACK){
9D005D2C  16020015   BNE S0, V0, 0x9D005D84
9D005D30  24020001   ADDIU V0, ZERO, 1
376:                         t0=ticks()+100;
9D005D34  0F40240C   JAL ticks
9D005D38  00008021   ADDU S0, ZERO, ZERO
9D005D3C  24510064   ADDIU S1, V0, 100
377:                         KbdSend(leds_state);
9D005D40  0F4016C1   JAL KbdSend
9D005D44  7C122420   SEB A0, S2
378:                         c=0;
379:                         while (!(ticks()==t0) && !(rx_flags & F_ERROR) && !c){
9D005D48  0B401757   J 0x9D005D5C
9D005D4C  00000000   NOP
9D005D5C  0F40240C   JAL ticks
9D005D60  00000000   NOP
9D005D64  10510007   BEQ V0, S1, 0x9D005D84
9D005D68  24020001   ADDIU V0, ZERO, 1
9D005D6C  93828025   LBU V0, -32731(GP)
9D005D70  30420001   ANDI V0, V0, 1
9D005D74  14400003   BNE V0, ZERO, 0x9D005D84
9D005D78  24020001   ADDIU V0, ZERO, 1
9D005D7C  1200FFF4   BEQ S0, ZERO, 0x9D005D50
9D005D80  00000000   NOP
380:                             c=KbdScancode();
9D005D50  0F401767   JAL KbdScancode
9D005D54  00000000   NOP
9D005D58  00408021   ADDU S0, V0, ZERO
381:                         }
382:                     }
383:                     if (c=KBD_ACK)
384:                         return 1;
385:                     else
386:                         return 0;
387:                 } // SetKbdLeds()
9D005D84  8FBF001C   LW RA, 28(SP)
9D005D88  8FB20018   LW S2, 24(SP)
9D005D8C  8FB10014   LW S1, 20(SP)
9D005D90  8FB00010   LW S0, 16(SP)
9D005D94  03E00008   JR RA
9D005D98  27BD0020   ADDIU SP, SP, 32
388:                 
389:                 void __ISR(_EXTERNAL_4_VECTOR,IPL6SOFT) kbd_clk_isr(void){
9D0064D0  415DE800   RDPGPR SP, SP
9D0064D4  401A7000   MFC0 K0, EPC
9D0064D8  401B6000   MFC0 K1, Status
9D0064DC  27BDFFE0   ADDIU SP, SP, -32
9D0064E0  AFBA001C   SW K0, 28(SP)
9D0064E4  401A6002   MFC0 K0, SRSCtl
9D0064E8  AFBB0018   SW K1, 24(SP)
9D0064EC  AFBA0014   SW K0, 20(SP)
9D0064F0  7C1B7844   INS K1, ZERO, 1, 15
9D0064F4  377B1800   ORI K1, K1, 6144
9D0064F8  409B6000   MTC0 K1, Status
9D0064FC  AFA4000C   SW A0, 12(SP)
9D006500  AFA30008   SW V1, 8(SP)
9D006504  AFA20004   SW V0, 4(SP)
390:                 	switch (bit_cnt){
9D006508  93828027   LBU V0, -32729(GP)
9D00650C  304200FF   ANDI V0, V0, 255
9D006510  24030009   ADDIU V1, ZERO, 9
9D006514  10430010   BEQ V0, V1, 0x9D006558
9D006518  2403000A   ADDIU V1, ZERO, 10
9D00651C  10430028   BEQ V0, V1, 0x9D0065C0
9D006520  00000000   NOP
9D006524  1440003B   BNE V0, ZERO, 0x9D006614
9D006528  3C02BF88   LUI V0, -16504
391:                 	case 0:   // start bit
392:                 		if (!(PORTA & KBD_DAT)){
9D00652C  8C426020   LW V0, 24608(V0)
9D006530  30420002   ANDI V0, V0, 2
9D006534  5440004C   BNEL V0, ZERO, 0x9D006668
9D006538  3C030080   LUI V1, 128
393:                                     parity=0;
9D00653C  A3808028   SB ZERO, -32728(GP)
394:                                     bit_cnt++;
9D006540  93828027   LBU V0, -32729(GP)
9D006544  24420001   ADDIU V0, V0, 1
9D006548  304200FF   ANDI V0, V0, 255
9D00654C  A3828027   SB V0, -32729(GP)
395:                                 }
396:                 		break;
397:                 	case 9:   // paritée
398:                 		if (PORTA & KBD_DAT)
9D006558  3C02BF88   LUI V0, -16504
9D00655C  8C426020   LW V0, 24608(V0)
9D006560  30420002   ANDI V0, V0, 2
9D006564  10400005   BEQ V0, ZERO, 0x9D00657C
9D006568  00000000   NOP
399:                 			parity++;
9D00656C  93828028   LBU V0, -32728(GP)
9D006570  24420001   ADDIU V0, V0, 1
9D006574  304200FF   ANDI V0, V0, 255
9D006578  A3828028   SB V0, -32728(GP)
400:                 		if (!(parity & 1)){
9D00657C  93828028   LBU V0, -32728(GP)
9D006580  30420001   ANDI V0, V0, 1
9D006584  14400008   BNE V0, ZERO, 0x9D0065A8
9D006588  00000000   NOP
401:                 			rx_flags |= F_ERROR;
9D00658C  93828025   LBU V0, -32731(GP)
9D006590  304200FF   ANDI V0, V0, 255
9D006594  34420001   ORI V0, V0, 1
9D006598  A3828025   SB V0, -32731(GP)
402:                                         IEC0CLR = _IEC0_INT4IE_MASK; // désactive l'interruption
9D00659C  3C030080   LUI V1, 128
9D0065A0  3C02BF88   LUI V0, -16504
9D0065A4  AC431064   SW V1, 4196(V0)
403:                 		}
404:                 		bit_cnt++;
9D0065A8  93828027   LBU V0, -32729(GP)
9D0065AC  24420001   ADDIU V0, V0, 1
9D0065B0  304200FF   ANDI V0, V0, 255
9D0065B4  A3828027   SB V0, -32729(GP)
405:                 		break;
9D0065B8  0B40199A   J 0x9D006668
9D0065BC  3C030080   LUI V1, 128
406:                 	case 10:  // stop bit
407:                 		kbd_queue[tail]=in_byte;
9D0065C0  93848029   LBU A0, -32727(GP)
9D0065C4  308400FF   ANDI A0, A0, 255
9D0065C8  9383802A   LBU V1, -32726(GP)
9D0065CC  3C02A000   LUI V0, -24576
9D0065D0  24424BBC   ADDIU V0, V0, 19388
9D0065D4  00821021   ADDU V0, A0, V0
9D0065D8  A0430000   SB V1, 0(V0)
408:                 		tail++;
9D0065DC  93828029   LBU V0, -32727(GP)
9D0065E0  24420001   ADDIU V0, V0, 1
9D0065E4  304200FF   ANDI V0, V0, 255
9D0065E8  A3828029   SB V0, -32727(GP)
409:                 		tail &=31;
9D0065EC  93828029   LBU V0, -32727(GP)
9D0065F0  3042001F   ANDI V0, V0, 31
9D0065F4  A3828029   SB V0, -32727(GP)
410:                 		bit_cnt=0;
9D0065F8  A3808027   SB ZERO, -32729(GP)
411:                 		rx_flags |= F_RCVD;
9D0065FC  93828025   LBU V0, -32731(GP)
9D006600  304200FF   ANDI V0, V0, 255
9D006604  34420002   ORI V0, V0, 2
9D006608  A3828025   SB V0, -32731(GP)
412:                 		break;
9D00660C  0B40199A   J 0x9D006668
9D006610  3C030080   LUI V1, 128
413:                 	default:
414:                 		in_byte >>=1;
9D006614  9382802A   LBU V0, -32726(GP)
9D006618  7C423040   EXT V0, V0, 1, 7
9D00661C  A382802A   SB V0, -32726(GP)
415:                 		if(PORTA & KBD_DAT){
9D006620  3C02BF88   LUI V0, -16504
9D006624  8C426020   LW V0, 24608(V0)
9D006628  30420002   ANDI V0, V0, 2
9D00662C  10400009   BEQ V0, ZERO, 0x9D006654
9D006630  00000000   NOP
416:                 			in_byte |=128;
9D006634  9382802A   LBU V0, -32726(GP)
9D006638  3042007F   ANDI V0, V0, 127
9D00663C  34420080   ORI V0, V0, 128
9D006640  A382802A   SB V0, -32726(GP)
417:                 			parity++;
9D006644  93828028   LBU V0, -32728(GP)
9D006648  24420001   ADDIU V0, V0, 1
9D00664C  304200FF   ANDI V0, V0, 255
9D006650  A3828028   SB V0, -32728(GP)
418:                 		}
419:                 		bit_cnt++;
9D006654  93828027   LBU V0, -32729(GP)
9D006658  24420001   ADDIU V0, V0, 1
9D00665C  304200FF   ANDI V0, V0, 255
9D006660  A3828027   SB V0, -32729(GP)
420:                 	}
421:                         mINT4ClearIntFlag();
9D006550  0B40199A   J 0x9D006668
9D006554  3C030080   LUI V1, 128
9D006664  3C030080   LUI V1, 128
9D006668  3C02BF88   LUI V0, -16504
9D00666C  AC431034   SW V1, 4148(V0)
422:                 } // kbd_clk_isr()
9D006670  8FA4000C   LW A0, 12(SP)
9D006674  8FA30008   LW V1, 8(SP)
9D006678  8FA20004   LW V0, 4(SP)
9D00667C  41606000   DI ZERO
9D006680  000000C0   EHB
9D006684  8FBA001C   LW K0, 28(SP)
9D006688  8FBB0018   LW K1, 24(SP)
9D00668C  409A7000   MTC0 K0, EPC
9D006690  8FBA0014   LW K0, 20(SP)
9D006694  27BD0020   ADDIU SP, SP, 32
9D006698  409A6002   MTC0 K0, SRSCtl
9D00669C  41DDE800   WRPGPR SP, SP
9D0066A0  409B6000   MTC0 K1, Status
9D0066A4  42000018   ERET
423:                 
424:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/sdmmc.c  ------------------------------
1:                   /*
2:                   ** SDMMC.c SD card interface
3:                   **
4:                   ** 7/20/06 v1.4 LDJ
5:                   ** 7/14/07 v2.0 LDJ
6:                   **
7:                   [30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
8:                   ** 07 May 2012	Changes made to allow SD card library to support
9:                   **					PIC32 Pinguino and PIC32 Pinguino Micro that have neither
10:                  **					SD card presence nor WP switch detection switches.
11:                  **					see functions getCD() and getWP() below.
12:                  */
13:                  
14:                  #ifndef __SDMMC_C__
15:                  #define __SDMMC_C__
16:                  
17:                  //#include <system.c>
18:                  //#include <digitalw.c>
19:                  //#include <spi.c>        // in order to use default SPI port
20:                  #include <plib.h>
21:                  #include "sdmmc.h"
22:                  //#include "diskio.h"
23:                  //#include "ff.h"
24:                  
25:                  // send one byte of data and receive one back at the same time
26:                  unsigned char writeSPI(unsigned char b)
27:                  {
9D008198  308400FF   ANDI A0, A0, 255
28:                  
29:                  	SPI2BUF = b;						
9D00819C  3C02BF80   LUI V0, -16512
9D0081A0  AC445A20   SW A0, 23072(V0)
30:                  	while(!SPI2STATbits.SPIRBF);	// wait transfer complete
9D0081A4  3C03BF80   LUI V1, -16512
9D0081A8  8C625A10   LW V0, 23056(V1)
9D0081AC  30420001   ANDI V0, V0, 1
9D0081B0  1040FFFD   BEQ V0, ZERO, 0x9D0081A8
9D0081B4  3C02BF80   LUI V0, -16512
31:                  	return SPI2BUF;					// read the received value
9D0081B8  8C425A20   LW V0, 23072(V0)
32:                  
33:                  /*
34:                  	BUFFER = b;			            // write to buffer for TX
35:                  	while (!STATRX);		        // wait until cycle complete
36:                  	return BUFFER;			        // return with byte read
37:                   */
38:                  }	// writeSPI
9D0081BC  03E00008   JR RA
9D0081C0  304200FF   ANDI V0, V0, 255
39:                  
40:                  void initSD(void)
41:                  {
42:                  	PORTB |=SDCSEL; //digitalwrite(SDCSEL, HIGH);	// initially keep the SD card disabled
9D0081C4  3C02BF88   LUI V0, -16504
9D0081C8  8C436120   LW V1, 24864(V0)
9D0081CC  34630004   ORI V1, V1, 4
9D0081D0  AC436120   SW V1, 24864(V0)
43:                  	TRISB &=~SDCSEL; //pinmode(SDCSEL, OUTPUT);		// make Card select an output pin
9D0081D4  3C02BF88   LUI V0, -16504
9D0081D8  8C446110   LW A0, 24848(V0)
9D0081DC  2403FFFB   ADDIU V1, ZERO, -5
9D0081E0  00831824   AND V1, A0, V1
9D0081E4  AC436110   SW V1, 24848(V0)
44:                  
45:                  	// init the spi module for a slow (safe) clock speed first
46:                  
47:                  	SPI2CON = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
9D0081E8  34038120   ORI V1, ZERO, -32480
9D0081EC  3C02BF80   LUI V0, -16512
9D0081F0  AC435A00   SW V1, 23040(V0)
48:                  	SPI2BRG = (mGetPeripheralClock() / (2 * 250000)) - 1;
9D0081F4  2403004A   ADDIU V1, ZERO, 74
9D0081F8  3C02BF80   LUI V0, -16512
9D0081FC  AC435A30   SW V1, 23088(V0)
49:                  
50:                  /*
51:                  	SPICONF = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
52:                  	CLKSPD  = (GetPeripheralClock() / (2 * 250000)) - 1;
53:                  */
54:                  }   // initSD
9D008200  03E00008   JR RA
9D008204  00000000   NOP
55:                  
56:                  #define readSPI()   writeSPI(0xFF)
57:                  #define clockSPI()  writeSPI(0xFF)
58:                  
59:                  void disableSD(void)
60:                  {
9D008208  27BDFFE8   ADDIU SP, SP, -24
9D00820C  AFBF0014   SW RA, 20(SP)
61:                  
62:                         PORTB |= SDCSEL; //digitalwrite(SDCSEL, HIGH);	// Deselected = SDCSEL high
9D008210  3C02BF88   LUI V0, -16504
9D008214  8C436120   LW V1, 24864(V0)
9D008218  34630004   ORI V1, V1, 4
9D00821C  AC436120   SW V1, 24864(V0)
63:                         clockSPI();
9D008220  0F402066   JAL writeSPI
9D008224  240400FF   ADDIU A0, ZERO, 255
64:                  }
9D008228  8FBF0014   LW RA, 20(SP)
9D00822C  03E00008   JR RA
9D008230  27BD0018   ADDIU SP, SP, 24
65:                  
66:                  void enableSD(void)
67:                  {
68:                  	PORTB &= ~ SDCSEL; //digitalwrite(SDCSEL, LOW);	// Selected = SDCSEL low
9D008234  3C02BF88   LUI V0, -16504
9D008238  8C446120   LW A0, 24864(V0)
9D00823C  2403FFFB   ADDIU V1, ZERO, -5
9D008240  00831824   AND V1, A0, V1
9D008244  AC436120   SW V1, 24864(V0)
69:                  }
9D008248  03E00008   JR RA
9D00824C  00000000   NOP
70:                  
71:                  // c    command code
72:                  // a    byte address of data block
73:                  int sendSDCmd(unsigned char c, unsigned a)
74:                  {
9D008250  27BDFFE0   ADDIU SP, SP, -32
9D008254  AFBF001C   SW RA, 28(SP)
9D008258  AFB10018   SW S1, 24(SP)
9D00825C  AFB00014   SW S0, 20(SP)
9D008260  00A08821   ADDU S1, A1, ZERO
75:                  	int i, r;
76:                  
77:                  	// enable SD card
78:                  	// CS low
79:                  	enableSD();
9D008264  0F40208D   JAL enableSD
9D008268  309000FF   ANDI S0, A0, 255
80:                  
81:                  	// send a comand packet (6 bytes)
82:                  	writeSPI(c | 0x40);    // send command
9D00826C  0F402066   JAL writeSPI
9D008270  36040040   ORI A0, S0, 64
83:                  	writeSPI(a>>24);       // msb of the address
9D008274  0F402066   JAL writeSPI
9D008278  00112602   SRL A0, S1, 24
84:                  	writeSPI(a>>16);
9D00827C  0F402066   JAL writeSPI
9D008280  7E243C00   EXT A0, S1, 16, 8
85:                  	writeSPI(a>>8);
9D008284  0F402066   JAL writeSPI
9D008288  7E243A00   EXT A0, S1, 8, 8
86:                  	writeSPI(a);           // lsb
9D00828C  0F402066   JAL writeSPI
9D008290  322400FF   ANDI A0, S1, 255
87:                  
88:                  	writeSPI(0x95);        // send CMD0 CRC
9D008294  0F402066   JAL writeSPI
9D008298  24040095   ADDIU A0, ZERO, 149
9D00829C  24100008   ADDIU S0, ZERO, 8
89:                  
90:                  	// now wait for a response, allow for up to 8 bytes delay
91:                  	for(i=0; i<8; i++)
9D0082B4  1600FFFA   BNE S0, ZERO, 0x9D0082A0
9D0082B8  00000000   NOP
92:                  	{
93:                  		r = readSPI();
9D0082A0  0F402066   JAL writeSPI
9D0082A4  240400FF   ADDIU A0, ZERO, 255
94:                  		if (r != 0xFF)
9D0082A8  240300FF   ADDIU V1, ZERO, 255
9D0082AC  14430003   BNE V0, V1, 0x9D0082BC
9D0082B0  2610FFFF   ADDIU S0, S0, -1
95:                  			break;
96:                  	}
97:                  	return (r);
98:                  
99:                  	/* return response
100:                 	FF - timeout
101:                 	00 - command accepted
102:                 	01 - command received, card in idle state after RESET
103:                 
104:                 	other codes:
105:                 	bit 0 = Idle state
106:                 	bit 1 = Erase Reset
107:                 	bit 2 = Illegal command
108:                 	bit 3 = Communication CRC error
109:                 	bit 4 = Erase sequence error
110:                 	bit 5 = Address error
111:                 	bit 6 = Parameter error
112:                 	bit 7 = Always 0
113:                 	*/
114:                 	// NOTE CSCD is still low!
115:                 } // sendSDCmd
9D0082BC  8FBF001C   LW RA, 28(SP)
9D0082C0  8FB10018   LW S1, 24(SP)
9D0082C4  8FB00014   LW S0, 20(SP)
9D0082C8  03E00008   JR RA
9D0082CC  27BD0020   ADDIU SP, SP, 32
116:                 
117:                 
118:                 // returns 0 if successful
119:                 //          E_COMMAND_ACK   failed to acknowledge reset command
120:                 //          E_INIT_TIMEOUT  failed to initialize
121:                 int initMedia(void)
122:                 {
9D0082D0  27BDFFE0   ADDIU SP, SP, -32
9D0082D4  AFBF001C   SW RA, 28(SP)
9D0082D8  AFB10018   SW S1, 24(SP)
123:                 	int i, r;
124:                 
125:                 	// 1. with the card NOT selected
126:                 	// Set DI and CS high
127:                 	disableSD();
9D0082DC  0F402082   JAL disableSD
9D0082E0  AFB00014   SW S0, 20(SP)
128:                 
129:                 	// 2. send 74 or more clock cycles to start up
130:                 	// apply 74 or more clock pulses to SCLK.
131:                 	// The card will enter its native operating mode and go ready to accept native commands.
132:                 	for (i=0; i<10; i++)
9D0082E4  00008021   ADDU S0, ZERO, ZERO
9D0082E8  2411000A   ADDIU S1, ZERO, 10
9D0082F4  26100001   ADDIU S0, S0, 1
9D0082F8  1611FFFC   BNE S0, S1, 0x9D0082EC
9D0082FC  00000000   NOP
133:                 		clockSPI();
9D0082EC  0F402066   JAL writeSPI
9D0082F0  240400FF   ADDIU A0, ZERO, 255
134:                 
135:                 	// 3. now select the card
136:                 	enableSD();
9D008300  0F40208D   JAL enableSD
9D008304  00000000   NOP
137:                 
138:                 	//card detection is now in disk_initialize()
139:                 
140:                 	return 0;
141:                 } // init media
9D008308  00001021   ADDU V0, ZERO, ZERO
9D00830C  8FBF001C   LW RA, 28(SP)
9D008310  8FB10018   LW S1, 24(SP)
9D008314  8FB00014   LW S0, 20(SP)
9D008318  03E00008   JR RA
9D00831C  27BD0020   ADDIU SP, SP, 32
142:                 
143:                 
144:                 // a        LBA of sector requested
145:                 // p        pointer to sector buffer
146:                 // returns  TRUE if successful
147:                 int readSECTOR(LBA a, char *p)
148:                 {
9D008320  27BDFFD8   ADDIU SP, SP, -40
9D008324  AFBF0024   SW RA, 36(SP)
9D008328  AFB40020   SW S4, 32(SP)
9D00832C  AFB3001C   SW S3, 28(SP)
9D008330  AFB20018   SW S2, 24(SP)
9D008334  AFB10014   SW S1, 20(SP)
9D008338  AFB00010   SW S0, 16(SP)
9D00833C  00A08821   ADDU S1, A1, ZERO
149:                 	int r, i;
150:                 
151:                 	#ifdef READ_LED
152:                         _read_off();
9D008340  3C02BF88   LUI V0, -16504
9D008344  8C456120   LW A1, 24864(V0)
9D008348  2403FFF7   ADDIU V1, ZERO, -9
9D00834C  00A31824   AND V1, A1, V1
9D008350  AC436120   SW V1, 24864(V0)
153:                 	//digitalwrite(READ_LED, 0);
154:                 	#endif
155:                 
156:                 	// 1. send READ command
157:                 	r = sendSDCmd(READ_SINGLE, (a << 9));
9D008354  00042A40   SLL A1, A0, 9
9D008358  0F402094   JAL sendSDCmd
9D00835C  24040011   ADDIU A0, ZERO, 17
158:                 	if (r == 0)    // check if command was accepted
9D008360  1440001A   BNE V0, ZERO, 0x9D0083CC
9D008364  00409021   ADDU S2, V0, ZERO
9D008368  00008021   ADDU S0, ZERO, ZERO
159:                 	{
160:                 	// 2. wait for a response
161:                 	for(i=0; i<R_TIMEOUT; i++)
9D008370  241461A8   ADDIU S4, ZERO, 25000
9D008384  26100001   ADDIU S0, S0, 1
9D008388  1614FFFA   BNE S0, S4, 0x9D008374
9D00838C  00000000   NOP
9D008390  0B4020F3   J 0x9D0083CC
9D008394  00000000   NOP
162:                 	{
163:                 	r = readSPI();
9D008374  0F402066   JAL writeSPI
9D008378  240400FF   ADDIU A0, ZERO, 255
164:                 	if (r == DATA_START)
9D00836C  241300FE   ADDIU S3, ZERO, 254
9D00837C  10530006   BEQ V0, S3, 0x9D008398
9D008380  00409021   ADDU S2, V0, ZERO
165:                 	break;
166:                 	}
167:                 
168:                 	// 3. if it did not timeout, read 512 byte of data
169:                 	if (i != R_TIMEOUT)
9D008398  240261A8   ADDIU V0, ZERO, 25000
9D00839C  1202000B   BEQ S0, V0, 0x9D0083CC
9D0083A0  26300200   ADDIU S0, S1, 512
170:                 	{
171:                 		i = 512;
172:                 		do{
173:                 			*p++ = readSPI();
9D0083A4  0F402066   JAL writeSPI
9D0083A8  240400FF   ADDIU A0, ZERO, 255
9D0083AC  A2220000   SB V0, 0(S1)
9D0083B0  26310001   ADDIU S1, S1, 1
174:                 		} while (--i>0);
9D0083B4  1630FFFB   BNE S1, S0, 0x9D0083A4
9D0083B8  00000000   NOP
175:                 
176:                 		// 4. ignore CRC
177:                 		readSPI();
9D0083BC  0F402066   JAL writeSPI
9D0083C0  240400FF   ADDIU A0, ZERO, 255
178:                 		readSPI();
9D0083C4  0F402066   JAL writeSPI
9D0083C8  240400FF   ADDIU A0, ZERO, 255
179:                 
180:                 	} // data arrived
181:                 
182:                 	} // command accepted
183:                 
184:                 	// 5. remember to disable the card
185:                 	disableSD();
9D0083CC  0F402082   JAL disableSD
9D0083D0  00000000   NOP
186:                 
187:                 	#ifdef READ_LED
188:                         _read_on();
9D0083D4  3C02BF88   LUI V0, -16504
9D0083D8  8C436120   LW V1, 24864(V0)
9D0083DC  34630008   ORI V1, V1, 8
9D0083E0  AC436120   SW V1, 24864(V0)
189:                 	//digital(READ_LED, 1);
190:                 	#endif
191:                 
192:                 	return (r == DATA_START);    // return TRUE if successful
9D0083E4  3A4200FE   XORI V0, S2, 254
193:                 } // readSECTOR
9D0083E8  2C420001   SLTIU V0, V0, 1
9D0083EC  8FBF0024   LW RA, 36(SP)
9D0083F0  8FB40020   LW S4, 32(SP)
9D0083F4  8FB3001C   LW S3, 28(SP)
9D0083F8  8FB20018   LW S2, 24(SP)
9D0083FC  8FB10014   LW S1, 20(SP)
9D008400  8FB00010   LW S0, 16(SP)
9D008404  03E00008   JR RA
9D008408  27BD0028   ADDIU SP, SP, 40
194:                 
195:                 
196:                 // a        LBA of sector requested
197:                 // p        pointer to sector buffer
198:                 // returns  TRUE if successful
199:                 int writeSECTOR(LBA a, char *p)
9D008440  26110200   ADDIU S1, S0, 512
200:                 {
9D00840C  27BDFFE0   ADDIU SP, SP, -32
9D008410  AFBF001C   SW RA, 28(SP)
9D008414  AFB20018   SW S2, 24(SP)
9D008418  AFB10014   SW S1, 20(SP)
9D00841C  AFB00010   SW S0, 16(SP)
9D008420  00A08021   ADDU S0, A1, ZERO
201:                 	unsigned r, i;
202:                 
203:                 	// 0. check Write Protect
204:                 //	if (getWP())
205:                 //		return FAIL;
206:                 
207:                 	// 1. send WRITE command
208:                 	r = sendSDCmd(WRITE_SINGLE, (a << 9));
9D008424  00042A40   SLL A1, A0, 9
9D008428  0F402094   JAL sendSDCmd
9D00842C  24040018   ADDIU A0, ZERO, 24
209:                 	if (r == 0)    // check if command was accepted
9D008430  14400025   BNE V0, ZERO, 0x9D0084C8
9D008434  00409021   ADDU S2, V0, ZERO
210:                 	{
211:                 		// 2. send data
212:                 		writeSPI(DATA_START);
9D008438  0F402066   JAL writeSPI
9D00843C  240400FE   ADDIU A0, ZERO, 254
213:                 
214:                 		// send 512 bytes of data
215:                 		for(i=0; i<512; i++)
9D008450  5611FFFD   BNEL S0, S1, 0x9D008448
9D008454  92040000   LBU A0, 0(S0)
216:                 		writeSPI(*p++);
9D008444  92040000   LBU A0, 0(S0)
9D008448  0F402066   JAL writeSPI
9D00844C  26100001   ADDIU S0, S0, 1
217:                 
218:                 		// 3. send dummy CRC
219:                 		clockSPI();
9D008458  0F402066   JAL writeSPI
9D00845C  240400FF   ADDIU A0, ZERO, 255
220:                 		clockSPI();
9D008460  0F402066   JAL writeSPI
9D008464  240400FF   ADDIU A0, ZERO, 255
221:                 
222:                 		// 4. check if data accepted
223:                 		r = readSPI();
9D008468  0F402066   JAL writeSPI
9D00846C  240400FF   ADDIU A0, ZERO, 255
224:                 		if ((r & 0xf) == DATA_ACCEPT)
9D008470  3042000F   ANDI V0, V0, 15
9D008474  24030005   ADDIU V1, ZERO, 5
9D008478  14430013   BNE V0, V1, 0x9D0084C8
9D00847C  3C02BF88   LUI V0, -16504
225:                 		{
226:                 			#ifdef WRITE_LED
227:                                         _write_off();
9D008480  8C446120   LW A0, 24864(V0)
9D008484  2403FFF7   ADDIU V1, ZERO, -9
9D008488  00831824   AND V1, A0, V1
9D00848C  AC436120   SW V1, 24864(V0)
228:                 			//digitalwrite(WRITE_LED, 0);
229:                 			#endif
230:                 
231:                 			// 5. wait for write completion
232:                 			for(i=0; i<W_TIMEOUT; i++)
9D008490  00008021   ADDU S0, ZERO, ZERO
9D008494  3C110003   LUI S1, 3
9D008498  3631D090   ORI S1, S1, -12144
9D0084AC  26100001   ADDIU S0, S0, 1
9D0084B0  1611FFFA   BNE S0, S1, 0x9D00849C
9D0084B4  00000000   NOP
233:                 			{
234:                 				r = readSPI();
9D00849C  0F402066   JAL writeSPI
9D0084A0  240400FF   ADDIU A0, ZERO, 255
235:                 				if (r != 0 )
9D0084A4  14400004   BNE V0, ZERO, 0x9D0084B8
9D0084A8  00409021   ADDU S2, V0, ZERO
236:                 					break;
237:                 			}
238:                 			#ifdef WRITE_LED
239:                                         _write_on();
9D0084B8  3C02BF88   LUI V0, -16504
9D0084BC  8C436120   LW V1, 24864(V0)
9D0084C0  34630008   ORI V1, V1, 8
9D0084C4  AC436120   SW V1, 24864(V0)
240:                 			//digitalwrite(WRITE_LED, 1);
241:                 			#endif
242:                 		} // accepted
243:                 		else
244:                 		{
245:                 			r = FAIL;
246:                 		}
247:                 	} // command accepted
248:                 
249:                 	// 6. disable the card
250:                 	disableSD();
9D0084C8  0F402082   JAL disableSD
9D0084CC  00000000   NOP
251:                 
252:                 	return (r);      // return TRUE if successful
253:                 } // writeSECTOR
9D0084D0  02401021   ADDU V0, S2, ZERO
9D0084D4  8FBF001C   LW RA, 28(SP)
9D0084D8  8FB20018   LW S2, 24(SP)
9D0084DC  8FB10014   LW S1, 20(SP)
9D0084E0  8FB00010   LW S0, 16(SP)
9D0084E4  03E00008   JR RA
9D0084E8  27BD0020   ADDIU SP, SP, 32
254:                 
255:                 
256:                 // SD card connector presence detection switch
257:                 // returns  TRUE card present
258:                 //          FALSE card not present
259:                 int getCD(void)
260:                 {
261:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
262:                 // 2013-09-05 ** added support for VPC_32
263:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined (EMPEROR460) || defined(VPC_32)
264:                 	return TRUE;
265:                 #else
266:                 	return (SDCD);
267:                 #endif
268:                 }
9D0084EC  03E00008   JR RA
9D0084F0  24020001   ADDIU V0, ZERO, 1
269:                 
270:                 // card Write Protect tab detection switch
271:                 // returns  TRUE write protect tab on LOCK
272:                 //          FALSE write protection tab OPEN
273:                 int getWP(void)
274:                 {
275:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
276:                 // 2013-09-05 ** added support for VPC_32
277:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined(EMPEROR460) || defined (VPC_32)
278:                 	return FALSE;
279:                 #else
280:                 	return (SDWP);
281:                 #endif
282:                 }
9D0084F4  03E00008   JR RA
9D0084F8  00001021   ADDU V0, ZERO, ZERO
283:                 
284:                 #endif /* __SDMMC_C__ */
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/fileio.c  -----------------------------
1:                   /*	----------------------------------------------------------------------------
2:                   	FILE:			fileio.c
3:                   	PROJECT:		pinguino32
4:                   	PURPOSE:		SD Card file system functions
5:                   	AUTHORS:		Alfred Broda <alfredbroda@gmail.com>
6:                   					Mark Harper <markfh@f2s.com>
7:                   					Regis Blanchot <rblanchot@gmail.com>
8:                   	FIRST RELEASE:	23 dec. 2011
9:                   	LAST RELEASE:	06 jan. 2012
10:                  	----------------------------------------------------------------------------
11:                  	based on original code by Regis Blanchot and FatFS example for PIC24
12:                  	----------------------------------------------------------------------------
13:                   	[30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
14:                  	07 May 2012	As part of providing support for PIC32 Pinguino Micro and
15:                  					potentially other cards removed #if defined (PIC32_Pinguino) etc
16:                  					and #endif in function mount() so that SDCS is set via mount 
17:                  					for all cards.
18:                  */
19:                  
20:                  #ifndef __FILEIO_C__
21:                  #define __FILEIO_C__
22:                  
23:                  // standard C libraries used
24:                  #include <ctype.h>      		// toupper...
25:                  #include <string.h>     		// memcpy...
26:                  //#include <malloc.h>				// malloc, free?
27:                  #include <GenericTypeDefs.h>
28:                  
29:                  #include "fileio.h"
30:                  #include "sdmmc.h"
31:                  #include "ff.h"					// Fat Filesystem
32:                  #include "diskio.h"				// card access functions
33:                  #include "../serial_comm.h"
34:                  
35:                  //#define SD_DEBUG
36:                  
37:                  //#ifdef SD_DEBUG
38:                  //    #include <__cdc.c>          // USB CDC functions
39:                  //#endif
40:                  
41:                  /*	----------------------------------------------------------------------------
42:                   mount
43:                   initializes a MEDIA structure for FILEIO access
44:                   will mount only the first partition on the disk/card
45:                   --------------------------------------------------------------------------*/
46:                  
47:                  static FATFS _Fat;
48:                  
49:                  char mount(unsigned char pin) {
9D008BAC  27BDFFE0   ADDIU SP, SP, -32
9D008BB0  AFBF001C   SW RA, 28(SP)
50:                  	int flag, i;
51:                  	FRESULT r;
52:                  
53:                  	SDCS = pin;
9D008BB4  A3848084   SB A0, -32636(GP)
54:                  
55:                  	// 0. init the I/Os
56:                  #ifdef SD_DEBUG
57:                  	UartPrint(STDOUT,"Initialisation carte SD\r");
9D008BB8  24040001   ADDIU A0, ZERO, 1
9D008BBC  3C059D01   LUI A1, -25343
9D008BC0  0F4021A1   JAL UartPrint
9D008BC4  24A59D98   ADDIU A1, A1, -25192
58:                  #endif
59:                  	initSD();
9D008BC8  0F402071   JAL initSD
9D008BCC  00000000   NOP
60:                  
61:                  #ifdef SD_DEBUG
62:                  	UartPrint(STDOUT,"Looking for SD slot... ");
9D008BD0  24040001   ADDIU A0, ZERO, 1
9D008BD4  3C059D01   LUI A1, -25343
9D008BD8  0F4021A1   JAL UartPrint
9D008BDC  24A59DB4   ADDIU A1, A1, -25164
63:                  #endif
64:                  	// 1. check if the card is in the slot
65:                  	if (!getCD()) {
9D008BE0  0F40213B   JAL getCD
9D008BE4  00000000   NOP
9D008BE8  14400008   BNE V0, ZERO, 0x9D008C0C
9D008BEC  24040001   ADDIU A0, ZERO, 1
66:                  		FError = FE_NOT_PRESENT;
9D008BF0  24020002   ADDIU V0, ZERO, 2
9D008BF4  A3828078   SB V0, -32648(GP)
67:                  #ifdef SD_DEBUG
68:                  		UartPrint(STDOUT, "Échec!\r");
9D008BF8  3C059D01   LUI A1, -25343
9D008BFC  0F4021A1   JAL UartPrint
9D008C00  24A59DCC   ADDIU A1, A1, -25140
69:                  #endif
70:                  		return FALSE;
9D008C04  0B402347   J 0x9D008D1C
9D008C08  00001021   ADDU V0, ZERO, ZERO
71:                  	}
72:                  #ifdef SD_DEBUG
73:                  	UartPrint(STDOUT,"OK\r");
9D008C0C  3C059D01   LUI A1, -25343
9D008C10  0F4021A1   JAL UartPrint
9D008C14  24A59DD4   ADDIU A1, A1, -25132
74:                  #endif
75:                  
76:                  	// 2. initialize the card
77:                  #ifdef SD_DEBUG
78:                  	UartPrint(STDOUT,"Initializing SD card... ");
9D008C18  24040001   ADDIU A0, ZERO, 1
9D008C1C  3C059D01   LUI A1, -25343
9D008C20  0F4021A1   JAL UartPrint
9D008C24  24A59DD8   ADDIU A1, A1, -25128
79:                  #endif
80:                  	initMedia();
9D008C28  0F4020B4   JAL initMedia
9D008C2C  00000000   NOP
81:                          if (disk_initialize(0)==STA_NOINIT){
9D008C30  0F401A81   JAL disk_initialize
9D008C34  00002021   ADDU A0, ZERO, ZERO
9D008C38  24030001   ADDIU V1, ZERO, 1
9D008C3C  14430006   BNE V0, V1, 0x9D008C58
9D008C40  24040001   ADDIU A0, ZERO, 1
82:                  #ifdef SD_DEBUG
83:                              UartPrint(STDOUT,"Echec d'initialisation de la carte SD\r");
9D008C44  3C059D01   LUI A1, -25343
9D008C48  0F4021A1   JAL UartPrint
9D008C4C  24A59DF4   ADDIU A1, A1, -25100
84:                  #endif
85:                              return 0;
9D008C50  0B402347   J 0x9D008D1C
9D008C54  00001021   ADDU V0, ZERO, ZERO
86:                          };
87:                  #ifdef SD_DEBUG
88:                          UartPrint(STDOUT,"OK\r");
9D008C58  3C059D01   LUI A1, -25343
9D008C5C  0F4021A1   JAL UartPrint
9D008C60  24A59DD4   ADDIU A1, A1, -25132
89:                  #endif
90:                  	// We're skipping the old step 3 because there's no need for malloc
91:                  	// This takes 6k off the code size if malloc is not used elsewhere.
92:                  	// Instead, just point it to our _Fat var.
93:                  	// The FATFS struct takes only 560 bytes of mem.
94:                  	Fat = &_Fat;
9D008C64  3C02A000   LUI V0, -24576
9D008C68  2442485C   ADDIU V0, V0, 18524
9D008C6C  AF82807C   SW V0, -32644(GP)
95:                  
96:                  	// Mount media
97:                  #ifdef SD_DEBUG
98:                  	UartPrint(STDOUT,"Mounting FAT filesystem... ");
9D008C70  24040001   ADDIU A0, ZERO, 1
9D008C74  3C059D01   LUI A1, -25343
9D008C78  0F4021A1   JAL UartPrint
9D008C7C  24A59E1C   ADDIU A1, A1, -25060
99:                  #endif
100:                 	r = f_mount(0, Fat);
9D008C80  00002021   ADDU A0, ZERO, ZERO
9D008C84  0F40063D   JAL f_mount
9D008C88  8F85807C   LW A1, -32644(GP)
101:                 	if (r != FR_OK) {
9D008C8C  10400007   BEQ V0, ZERO, 0x9D008CAC
9D008C90  24040001   ADDIU A0, ZERO, 1
102:                 		FError = r;
9D008C94  A3828078   SB V0, -32648(GP)
103:                 #ifdef SD_DEBUG
104:                 		UartPrint(STDOUT,"Failed!\r");
9D008C98  3C059D01   LUI A1, -25343
9D008C9C  0F4021A1   JAL UartPrint
9D008CA0  24A59E38   ADDIU A1, A1, -25032
105:                 #endif
106:                 		//free(Fat);
107:                 		return FALSE;
9D008CA4  0B402347   J 0x9D008D1C
9D008CA8  00001021   ADDU V0, ZERO, ZERO
108:                 	}
109:                 #ifdef SD_DEBUG
110:                 	UartPrint(STDOUT, "OK\r");
9D008CAC  3C059D01   LUI A1, -25343
9D008CB0  0F4021A1   JAL UartPrint
9D008CB4  24A59DD4   ADDIU A1, A1, -25132
111:                 #endif
112:                 
113:                 #ifdef SD_DEBUG
114:                 	UartPrint(STDOUT,"Checking FAT filesystem... ");
9D008CB8  24040001   ADDIU A0, ZERO, 1
9D008CBC  3C059D01   LUI A1, -25343
9D008CC0  0F4021A1   JAL UartPrint
9D008CC4  24A59E44   ADDIU A1, A1, -25020
115:                 #endif
116:                 	const TCHAR * pth = "/";
9D008CC8  3C029D01   LUI V0, -25343
9D008CCC  24429E60   ADDIU V0, V0, -24992
9D008CD0  AFA20010   SW V0, 16(SP)
117:                 	r = chk_mounted(&pth, &Fat, 0);
9D008CD4  27A40010   ADDIU A0, SP, 16
9D008CD8  2785807C   ADDIU A1, GP, -32644
9D008CDC  0F40050B   JAL chk_mounted
9D008CE0  00003021   ADDU A2, ZERO, ZERO
118:                 	if (r != FR_OK) {
9D008CE4  10400009   BEQ V0, ZERO, 0x9D008D0C
9D008CE8  24040001   ADDIU A0, ZERO, 1
119:                 		FError = r;
9D008CEC  A3828078   SB V0, -32648(GP)
120:                 #ifdef SD_DEBUG
121:                 		UartPrint(STDOUT, "Failed!\r");
9D008CF0  3C059D01   LUI A1, -25343
9D008CF4  0F4021A1   JAL UartPrint
9D008CF8  24A59E38   ADDIU A1, A1, -25032
122:                                  //put_rc(r);
123:                 #endif
124:                 		unmount();
9D008CFC  0F4022E0   JAL unmount
9D008D00  00000000   NOP
125:                 		return FALSE;
9D008D04  0B402347   J 0x9D008D1C
9D008D08  00001021   ADDU V0, ZERO, ZERO
126:                 	}
127:                 #ifdef SD_DEBUG
128:                 	UartPrint(STDOUT, "OK\r");
9D008D0C  3C059D01   LUI A1, -25343
9D008D10  0F4021A1   JAL UartPrint
9D008D14  24A59DD4   ADDIU A1, A1, -25132
129:                 #endif
130:                 
131:                 	return TRUE;
9D008D18  24020001   ADDIU V0, ZERO, 1
132:                 } // mount
9D008D1C  8FBF001C   LW RA, 28(SP)
9D008D20  03E00008   JR RA
9D008D24  27BD0020   ADDIU SP, SP, 32
133:                 
134:                 /*	----------------------------------------------------------------------------
135:                  unmount    initializes a MEDIA structure for FILEIO access
136:                  --------------------------------------------------------------------------*/
137:                 
138:                 void unmount(void) {
9D008B80  27BDFFE8   ADDIU SP, SP, -24
9D008B84  AFBF0014   SW RA, 20(SP)
139:                 	f_mount(0, NULL);
9D008B88  00002021   ADDU A0, ZERO, ZERO
9D008B8C  0F40063D   JAL f_mount
9D008B90  00002821   ADDU A1, ZERO, ZERO
140:                 	//free(Fat);
141:                 	SPI2CONCLR = 0x8000; // SPI2 OFF
9D008B94  34038000   ORI V1, ZERO, -32768
9D008B98  3C02BF80   LUI V0, -16512
9D008B9C  AC435A04   SW V1, 23044(V0)
142:                 } // unmount
9D008BA0  8FBF0014   LW RA, 20(SP)
9D008BA4  03E00008   JR RA
9D008BA8  27BD0018   ADDIU SP, SP, 24
143:                 
144:                 /*	----------------------------------------------------------------------------
145:                  present   test if a SD card is present
146:                  --------------------------------------------------------------------------*/
147:                 
148:                 char SD_present(unsigned char pin) {
9D008D28  27BDFFE8   ADDIU SP, SP, -24
9D008D2C  AFBF0014   SW RA, 20(SP)
149:                 	if (mount(pin)) {
9D008D30  0F4022EB   JAL mount
9D008D34  308400FF   ANDI A0, A0, 255
9D008D38  10400004   BEQ V0, ZERO, 0x9D008D4C
9D008D3C  00001821   ADDU V1, ZERO, ZERO
150:                 		unmount();
9D008D40  0F4022E0   JAL unmount
9D008D44  00000000   NOP
151:                 		return TRUE;
9D008D48  24030001   ADDIU V1, ZERO, 1
152:                 	} else {
153:                 		return FALSE;
154:                 	}
155:                 }
9D008D4C  00601021   ADDU V0, V1, ZERO
9D008D50  8FBF0014   LW RA, 20(SP)
9D008D54  03E00008   JR RA
9D008D58  27BD0018   ADDIU SP, SP, 24
156:                 
157:                 /*	----------------------------------------------------------------------------
158:                  Scans the current disk and compiles a list of files with a given extension
159:                  list     array of file names max * 8
160:                  max      number of entries
161:                  ext      file extension we are searching for
162:                  return   number of files found
163:                  --------------------------------------------------------------------------*/
164:                 
165:                 //unsigned listTYPE(char *listname, long *listsize, int max, const char *ext )
166:                 unsigned listTYPE(DIRTABLE *list, int max, const char *ext)
167:                 //unsigned listTYPE(char *list, int max, const char *ext )
168:                 {
169:                 	//TODO: implement
170:                 
171:                 	return 0;
172:                 } // listTYPE
9D008D5C  03E00008   JR RA
9D008D60  00001021   ADDU V0, ZERO, ZERO
173:                 
174:                 /* Prints the directory contents */
175:                 unsigned listDir(const char *path) {
9D008D64  27BDFFC0   ADDIU SP, SP, -64
9D008D68  AFBF003C   SW RA, 60(SP)
9D008D6C  AFB10038   SW S1, 56(SP)
9D008D70  AFB00034   SW S0, 52(SP)
9D008D74  00808021   ADDU S0, A0, ZERO
176:                 	//TODO: remove all CDC references
177:                 	long p1;
178:                 	PF_BYTE res, b;
179:                 	UINT s1, s2;
180:                 	DIR dir; /* Directory object */
181:                 
182:                 	res = f_opendir(&dir, "/");
9D008D78  27A40010   ADDIU A0, SP, 16
9D008D7C  3C059D01   LUI A1, -25343
9D008D80  0F4009BB   JAL f_opendir
9D008D84  24A59E60   ADDIU A1, A1, -24992
183:                 #ifdef SD_DEBUG
184:                 	UartPrint(STDOUT,"f_opendir? ");
9D008D88  24040001   ADDIU A0, ZERO, 1
9D008D8C  3C059D01   LUI A1, -25343
9D008D90  0F4021A1   JAL UartPrint
9D008D94  24A59E64   ADDIU A1, A1, -24988
185:                 	//put_rc(res);
186:                 #endif
187:                 	p1 = s1 = s2 = 0;
9D008DB8  00008821   ADDU S1, ZERO, ZERO
188:                 	//CDCprintln("\nf_readdir('%s'): ", path);
189:                         print("\rnf_readdir('");
9D008D98  3C049D01   LUI A0, -25343
9D008D9C  0F401D9C   JAL print
9D008DA0  24849E70   ADDIU A0, A0, -24976
190:                         print(path);
9D008DA4  0F401D9C   JAL print
9D008DA8  02002021   ADDU A0, S0, ZERO
191:                         print("'):");
9D008DAC  3C049D01   LUI A0, -25343
9D008DB0  0F401D9C   JAL print
9D008DB4  24849E80   ADDIU A0, A0, -24960
192:                 	for (;;) {
193:                 		res = f_readdir(&dir, &Finfo);
9D008DBC  3C10A000   LUI S0, -24576
9D008DC0  26104844   ADDIU S0, S0, 18500
9D008DC4  27A40010   ADDIU A0, SP, 16
9D008DC8  0F4009EC   JAL f_readdir
9D008DCC  02002821   ADDU A1, S0, ZERO
194:                 #ifdef SD_DEBUG
195:                 //		put_rc(res);
196:                 #endif
197:                 		if ((res != FR_OK) || !Finfo.fname[0]) {
9D008DD0  304200FF   ANDI V0, V0, 255
9D008DD4  14400009   BNE V0, ZERO, 0x9D008DFC
9D008DD8  02201021   ADDU V0, S1, ZERO
9D008DDC  82020009   LB V0, 9(S0)
9D008DE0  10400006   BEQ V0, ZERO, 0x9D008DFC
9D008DE4  02201021   ADDU V0, S1, ZERO
198:                 			break;
199:                 		}
200:                 
201:                 		if (Finfo.fattrib & AM_DIR) {
9D008DE8  92020008   LBU V0, 8(S0)
9D008DEC  30420010   ANDI V0, V0, 16
202:                 			s2++;
203:                 		} else {
204:                 			s1++;
9D008DF0  2C420001   SLTIU V0, V0, 1
9D008DF4  0B402371   J 0x9D008DC4
9D008DF8  02228821   ADDU S1, S1, V0
205:                 			p1 += Finfo.fsize;
206:                 		}
207:                 /* what about other outputs ?
208:                 		UartPrint(STDOUT,"%c%c%c%c%c ",
209:                                 (Finfo.fattrib & AM_DIR) ? 'D' : '-',
210:                 				(Finfo.fattrib & AM_RDO) ? 'R' : '-',
211:                 				(Finfo.fattrib & AM_HID) ? 'H' : '-',
212:                 				(Finfo.fattrib & AM_SYS) ? 'S' : '-',
213:                 				(Finfo.fattrib & AM_ARC) ? 'A' : '-');
214:                 		UartPrint(STDOUT,"%u/%02u/%02u %02u:%02u ",
215:                                 (Finfo.fdate >> 9) + 1980,
216:                 				(Finfo.fdate >> 5) & 15, Finfo.fdate & 31, (Finfo.ftime >> 11),
217:                 				(Finfo.ftime >> 5) & 63);
218:                 		UartPrint(STDOUT," %9u ", Finfo.fsize);
219:                 		UartPrint(STDOUT, " %-12s %s", Finfo.fname,
220:                 #if _USE_LFN
221:                 				Lfname);
222:                 #else
223:                 				"");
224:                 #endif
225:                 */
226:                 	}
227:                 
228:                 	return s1;
229:                 } // listDir
9D008DFC  8FBF003C   LW RA, 60(SP)
9D008E00  8FB10038   LW S1, 56(SP)
9D008E04  8FB00034   LW S0, 52(SP)
9D008E08  03E00008   JR RA
9D008E0C  27BD0040   ADDIU SP, SP, 64
230:                 
231:                 char isDirectory(FILINFO file) {
9D008E10  AFA40000   SW A0, 0(SP)
9D008E14  AFA50004   SW A1, 4(SP)
9D008E18  AFA60008   SW A2, 8(SP)
9D008E1C  AFA7000C   SW A3, 12(SP)
232:                 	if (file.fattrib & AM_DIR) {
233:                 		return TRUE;
234:                 	} else {
235:                 		return FALSE;
236:                 	}
237:                 }
9D008E20  03E00008   JR RA
9D008E24  7CC20100   EXT V0, A2, 4, 1
238:                 
239:                 char isReadOnly(FILINFO file) {
9D008E28  AFA40000   SW A0, 0(SP)
9D008E2C  AFA50004   SW A1, 4(SP)
9D008E30  AFA60008   SW A2, 8(SP)
9D008E34  AFA7000C   SW A3, 12(SP)
240:                 	if (file.fattrib & AM_RDO) {
241:                 		return TRUE;
242:                 	} else {
243:                 		return FALSE;
244:                 	}
245:                 }
9D008E38  03E00008   JR RA
9D008E3C  30C20001   ANDI V0, A2, 1
246:                 
247:                 char isHidden(FILINFO file) {
9D008E40  AFA40000   SW A0, 0(SP)
9D008E44  AFA50004   SW A1, 4(SP)
9D008E48  AFA60008   SW A2, 8(SP)
9D008E4C  AFA7000C   SW A3, 12(SP)
248:                 	if (file.fattrib & AM_HID) {
249:                 		return TRUE;
250:                 	} else {
251:                 		return FALSE;
252:                 	}
253:                 }
9D008E50  03E00008   JR RA
9D008E54  7CC20040   EXT V0, A2, 1, 1
254:                 
255:                 char isSystem(FILINFO file) {
9D008E58  AFA40000   SW A0, 0(SP)
9D008E5C  AFA50004   SW A1, 4(SP)
9D008E60  AFA60008   SW A2, 8(SP)
9D008E64  AFA7000C   SW A3, 12(SP)
256:                 	if (file.fattrib & AM_SYS) {
257:                 		return TRUE;
258:                 	} else {
259:                 		return FALSE;
260:                 	}
261:                 }
9D008E68  03E00008   JR RA
9D008E6C  7CC20080   EXT V0, A2, 2, 1
262:                 
263:                 char isArchive(FILINFO file) {
9D008E70  AFA40000   SW A0, 0(SP)
9D008E74  AFA50004   SW A1, 4(SP)
9D008E78  AFA60008   SW A2, 8(SP)
9D008E7C  AFA7000C   SW A3, 12(SP)
264:                 	if (file.fattrib & AM_ARC) {
265:                 		return TRUE;
266:                 	} else {
267:                 		return FALSE;
268:                 	}
269:                 }
9D008E80  03E00008   JR RA
9D008E84  7CC20140   EXT V0, A2, 5, 1
270:                 #endif /* __FILEIO_C__ */
271:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/ff.c  ---------------------------------
1:                   /*----------------------------------------------------------------------------/
2:                    /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
3:                    /-----------------------------------------------------------------------------/
4:                    / FatFs module is a generic FAT file system module for small embedded systems.
5:                    / This is a free software that opened for education, research and commercial
6:                    / developments under license policy of following terms.
7:                    /
8:                    /  Copyright (C) 2011, ChaN, all right reserved.
9:                    /
10:                   / * The FatFs module is a free software and there is NO WARRANTY.
11:                   / * No restriction on use. You can use, modify and redistribute it for
12:                   /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
13:                   / * Redistributions of source code must retain the above copyright notice.
14:                   /
15:                   /-----------------------------------------------------------------------------/
16:                   / Feb 26,'06 R0.00  Prototype.
17:                   /
18:                   / Apr 29,'06 R0.01  First stable version.
19:                   /
20:                   / Jun 01,'06 R0.02  Added FAT12 support.
21:                   /                   Removed unbuffered mode.
22:                   /                   Fixed a problem on small (<32M) partition.
23:                   / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
24:                   /
25:                   / Sep 22,'06 R0.03  Added f_rename().
26:                   /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
27:                   / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
28:                   /                   Fixed f_mkdir() creates incorrect directory on FAT32.
29:                   /
30:                   / Feb 04,'07 R0.04  Supported multiple drive system.
31:                   /                   Changed some interfaces for multiple drive system.
32:                   /                   Changed f_mountdrv() to f_mount().
33:                   /                   Added f_mkfs().
34:                   / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
35:                   /                   Added a capability of extending file size to f_lseek().
36:                   /                   Added minimization level 3.
37:                   /                   Fixed an endian sensitive code in f_mkfs().
38:                   / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
39:                   /                   Added FSInfo support.
40:                   /                   Fixed DBCS name can result FR_INVALID_NAME.
41:                   /                   Fixed short seek (<= csize) collapses the file object.
42:                   /
43:                   / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
44:                   /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
45:                   /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
46:                   / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
47:                   /                   Fixed off by one error at FAT sub-type determination.
48:                   /                   Fixed btr in f_read() can be mistruncated.
49:                   /                   Fixed cached sector is not flushed when create and close without write.
50:                   /
51:                   / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
52:                   /                   Improved performance of f_lseek() on moving to the same or following cluster.
53:                   /
54:                   / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
55:                   /                   Added long file name feature.
56:                   /                   Added multiple code page feature.
57:                   /                   Added re-entrancy for multitask operation.
58:                   /                   Added auto cluster size selection to f_mkfs().
59:                   /                   Added rewind option to f_readdir().
60:                   /                   Changed result code of critical errors.
61:                   /                   Renamed string functions to avoid name collision.
62:                   / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
63:                   /                   Added multiple sector size feature.
64:                   / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
65:                   /                   Fixed wrong cache control in f_lseek().
66:                   /                   Added relative path feature.
67:                   /                   Added f_chdir() and f_chdrive().
68:                   /                   Added proper case conversion to extended char.
69:                   / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
70:                   /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
71:                   /                   Fixed name matching error on the 13 char boundary.
72:                   /                   Added a configuration option, _LFN_UNICODE.
73:                   /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
74:                   /
75:                   / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
76:                   /                   Added file lock feature. (_FS_SHARE)
77:                   /                   Added fast seek feature. (_USE_FASTSEEK)
78:                   /                   Changed some types on the API, XCHAR->TCHAR.
79:                   /                   Changed fname member in the FILINFO structure on Unicode cfg.
80:                   /                   String functions support UTF-8 encoding files on Unicode cfg.
81:                   / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
82:                   /                   Added sector erase feature. (_USE_ERASE)
83:                   /                   Moved file lock semaphore table from fs object to the bss.
84:                   /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
85:                   /                   Fixed f_mkfs() creates wrong FAT32 volume.
86:                   / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
87:                   /                   f_lseek() reports required table size on creating CLMP.
88:                   /                   Extended format syntax of f_printf function.
89:                   /                   Ignores duplicated directory separators in given path names.
90:                   /
91:                   / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
92:                   /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
93:                   /---------------------------------------------------------------------------
94:                   / 2011-12 Alfred Broda <alfredbroda@gmail.com> adapted for Pinguno Project
95:                   / BYTE and WORD were changed to PF_BYTE and PF_WORD because of a conflict.
96:                   ---------------------------------------------------------------------------*/
97:                  
98:                  #include "ff.h"			/* FatFs configurations and declarations */
99:                  #include "diskio.h"		/* Declarations of low level disk I/O functions */
100:                 
101:                 /*--------------------------------------------------------------------------
102:                 
103:                  Module Private Definitions
104:                 
105:                  ---------------------------------------------------------------------------*/
106:                 
107:                 #if _FATFS != 6502	/* Revision ID */
108:                 #error Wrong include file (ff.h).
109:                 #endif
110:                 
111:                 /* Definitions on sector size */
112:                 #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
113:                 #error Wrong sector size.
114:                 #endif
115:                 #if _MAX_SS != 512
116:                 #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
117:                 #else
118:                 #define	SS(fs)	512U			/* Fixed sector size */
119:                 #endif
120:                 
121:                 /* Reentrancy related */
122:                 #if _FS_REENTRANT
123:                 #if _USE_LFN == 1
124:                 #error Static LFN work area must not be used in re-entrant configuration.
125:                 #endif
126:                 #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
127:                 #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
128:                 #else
129:                 #define	ENTER_FF(fs)
130:                 #define LEAVE_FF(fs, res)	return res
131:                 #endif
132:                 
133:                 #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
134:                 
135:                 /* File shareing feature */
136:                 #if _FS_SHARE
137:                 #if _FS_READONLY
138:                 #error _FS_SHARE must be 0 on read-only cfg.
139:                 #endif
140:                 typedef struct {
141:                 	FATFS *fs; /* File ID 1, volume (NULL:blank entry) */
142:                 	DWORD clu; /* File ID 2, directory */
143:                 	PF_WORD idx; /* File ID 3, directory index */
144:                 	PF_WORD ctr; /* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
145:                 }FILESEM;
146:                 #endif
147:                 
148:                 /* Misc definitions */
149:                 #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
150:                 #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
151:                 
152:                 /* DBCS code ranges and SBCS extend char conversion table */
153:                 
154:                 #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
155:                 #define _DF1S	0x81	/* DBC 1st byte range 1 start */
156:                 #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
157:                 #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
158:                 #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
159:                 #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
160:                 #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
161:                 #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
162:                 #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
163:                 
164:                 #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
165:                 #define _DF1S	0x81
166:                 #define _DF1E	0xFE
167:                 #define _DS1S	0x40
168:                 #define _DS1E	0x7E
169:                 #define _DS2S	0x80
170:                 #define _DS2E	0xFE
171:                 
172:                 #elif _CODE_PAGE == 949	/* Korean */
173:                 #define _DF1S	0x81
174:                 #define _DF1E	0xFE
175:                 #define _DS1S	0x41
176:                 #define _DS1E	0x5A
177:                 #define _DS2S	0x61
178:                 #define _DS2E	0x7A
179:                 #define _DS3S	0x81
180:                 #define _DS3E	0xFE
181:                 
182:                 #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
183:                 #define _DF1S	0x81
184:                 #define _DF1E	0xFE
185:                 #define _DS1S	0x40
186:                 #define _DS1E	0x7E
187:                 #define _DS2S	0xA1
188:                 #define _DS2E	0xFE
189:                 
190:                 #elif _CODE_PAGE == 437	/* U.S. (OEM) */
191:                 #define _DF1S	0
192:                 #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
193:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
194:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
195:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
196:                 
197:                 #elif _CODE_PAGE == 720	/* Arabic (OEM) */
198:                 #define _DF1S	0
199:                 #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
200:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
201:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
202:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
203:                 
204:                 #elif _CODE_PAGE == 737	/* Greek (OEM) */
205:                 #define _DF1S	0
206:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
207:                 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
208:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
209:                 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
210:                 
211:                 #elif _CODE_PAGE == 775	/* Baltic (OEM) */
212:                 #define _DF1S	0
213:                 #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
214:                 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
215:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
216:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
217:                 
218:                 #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
219:                 #define _DF1S	0
220:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
221:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
222:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
223:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
224:                 
225:                 #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
226:                 #define _DF1S	0
227:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
228:                 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
229:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
230:                 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
231:                 
232:                 #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
233:                 #define _DF1S	0
234:                 #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
235:                 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
236:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
237:                 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
238:                 
239:                 #elif _CODE_PAGE == 857	/* Turkish (OEM) */
240:                 #define _DF1S	0
241:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
242:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
243:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
244:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
245:                 
246:                 #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
247:                 #define _DF1S	0
248:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
249:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
250:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
251:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
252:                 
253:                 #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
254:                 #define _DF1S	0
255:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
256:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
257:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
258:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
259:                 
260:                 #elif _CODE_PAGE == 866	/* Russian (OEM) */
261:                 #define _DF1S	0
262:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
263:                 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
264:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
265:                 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
266:                 
267:                 #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
268:                 #define _DF1S	0
269:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
270:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
271:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
272:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
273:                 
274:                 #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
275:                 #define _DF1S	0
276:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
277:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
278:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
279:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
280:                 
281:                 #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
282:                 #define _DF1S	0
283:                 #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
284:                 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
285:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
286:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
287:                 
288:                 #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
289:                 #define _DF1S	0
290:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
291:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
292:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
293:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
294:                 
295:                 #elif _CODE_PAGE == 1253 /* Greek (Windows) */
296:                 #define _DF1S	0
297:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
298:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
299:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
300:                 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
301:                 
302:                 #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
303:                 #define _DF1S	0
304:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
305:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
306:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
307:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
308:                 
309:                 #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
310:                 #define _DF1S	0
311:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
312:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
313:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
314:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
315:                 
316:                 #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
317:                 #define _DF1S	0
318:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
319:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
320:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
321:                 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
322:                 
323:                 #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
324:                 #define _DF1S	0
325:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
326:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
327:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
328:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
329:                 
330:                 #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
331:                 #define _DF1S	0
332:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
333:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
334:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
335:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
336:                 
337:                 #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
338:                 #if _USE_LFN
339:                 #error Cannot use LFN feature without valid code page.
340:                 #endif
341:                 #define _DF1S	0
342:                 
343:                 #else
344:                 #error Unknown code page
345:                 
346:                 #endif
347:                 
348:                 /* Character code support macros */
349:                 #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
350:                 #define IsLower(c)	(((c)>='a')&&((c)<='z'))
351:                 #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
352:                 
353:                 #if _DF1S		/* Code page is DBCS */
354:                 
355:                 #ifdef _DF2S	/* Two 1st byte areas */
356:                 #define IsDBCS1(c)	(((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E) || ((PF_BYTE)(c) >= _DF2S && (PF_BYTE)(c) <= _DF2E))
357:                 #else			/* One 1st byte area */
358:                 #define IsDBCS1(c)	((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E)
359:                 #endif
360:                 
361:                 #ifdef _DS3S	/* Three 2nd byte areas */
362:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E) || ((PF_BYTE)(c) >= _DS3S && (PF_BYTE)(c) <= _DS3E))
363:                 #else			/* Two 2nd byte areas */
364:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E))
365:                 #endif
366:                 
367:                 #else			/* Code page is SBCS */
368:                 
369:                 #define IsDBCS1(c)	0
370:                 #define IsDBCS2(c)	0
371:                 
372:                 #endif /* _DF1S */
373:                 
374:                 /* Name status flags */
375:                 #define NS			11		/* Index of name status byte in fn[] */
376:                 #define NS_LOSS		0x01	/* Out of 8.3 format */
377:                 #define NS_LFN		0x02	/* Force to create LFN entry */
378:                 #define NS_LAST		0x04	/* Last segment */
379:                 #define NS_BODY		0x08	/* Lower case flag (body) */
380:                 #define NS_EXT		0x10	/* Lower case flag (ext) */
381:                 #define NS_DOT		0x20	/* Dot entry */
382:                 
383:                 /* FAT sub-type boundaries */
384:                 /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
385:                 #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
386:                 #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
387:                 
388:                 /* FatFs refers the members in the FAT structures as byte array instead of
389:                  / structure member because the structure is not binary compatible between
390:                  / different platforms */
391:                 
392:                 #define BS_jmpBoot			0	/* Jump instruction (3) */
393:                 #define BS_OEMName			3	/* OEM name (8) */
394:                 #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
395:                 #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
396:                 #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
397:                 #define BPB_NumFATs			16	/* Number of FAT copies (1) */
398:                 #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
399:                 #define BPB_TotSec16		19	/* Volume size [sector] (2) */
400:                 #define BPB_Media			21	/* Media descriptor (1) */
401:                 #define BPB_FATSz16			22	/* FAT size [sector] (2) */
402:                 #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
403:                 #define BPB_NumHeads		26	/* Number of heads (2) */
404:                 #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
405:                 #define BPB_TotSec32		32	/* Volume size [sector] (4) */
406:                 #define BS_DrvNum			36	/* Physical drive number (2) */
407:                 #define BS_BootSig			38	/* Extended boot signature (1) */
408:                 #define BS_VolID			39	/* Volume serial number (4) */
409:                 #define BS_VolLab			43	/* Volume label (8) */
410:                 #define BS_FilSysType		54	/* File system type (1) */
411:                 #define BPB_FATSz32			36	/* FAT size [sector] (4) */
412:                 #define BPB_ExtFlags		40	/* Extended flags (2) */
413:                 #define BPB_FSVer			42	/* File system version (2) */
414:                 #define BPB_RootClus		44	/* Root dir first cluster (4) */
415:                 #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
416:                 #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
417:                 #define BS_DrvNum32			64	/* Physical drive number (2) */
418:                 #define BS_BootSig32		66	/* Extended boot signature (1) */
419:                 #define BS_VolID32			67	/* Volume serial number (4) */
420:                 #define BS_VolLab32			71	/* Volume label (8) */
421:                 #define BS_FilSysType32		82	/* File system type (1) */
422:                 #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
423:                 #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
424:                 #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
425:                 #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
426:                 #define MBR_Table			446	/* MBR: Partition table offset (2) */
427:                 #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
428:                 #define BS_55AA				510	/* Boot sector signature (2) */
429:                 
430:                 #define	DIR_Name			0	/* Short file name (11) */
431:                 #define	DIR_Attr			11	/* Attribute (1) */
432:                 #define	DIR_NTres			12	/* NT flag (1) */
433:                 #define	DIR_CrtTime			14	/* Created time (2) */
434:                 #define	DIR_CrtDate			16	/* Created date (2) */
435:                 #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
436:                 #define	DIR_WrtTime			22	/* Modified time (2) */
437:                 #define	DIR_WrtDate			24	/* Modified date (2) */
438:                 #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
439:                 #define	DIR_FileSize		28	/* File size (4) */
440:                 #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
441:                 #define	LDIR_Attr			11	/* LFN attribute (1) */
442:                 #define	LDIR_Type			12	/* LFN type (1) */
443:                 #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
444:                 #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
445:                 #define	SZ_DIR				32		/* Size of a directory entry */
446:                 #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
447:                 #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
448:                 #define	NDDE				0x05	/* Replacement of a character collides with DDE */
449:                 
450:                 /*------------------------------------------------------------*/
451:                 /* Module private work area                                   */
452:                 /*------------------------------------------------------------*/
453:                 /* Note that uninitialized variables with static duration are
454:                  /  zeroed/nulled at start-up. If not, the compiler or start-up
455:                  /  routine is out of ANSI-C standard.
456:                  */
457:                 
458:                 #if _VOLUMES
459:                 static FATFS *FatFs[_VOLUMES]; /* Pointer to the file system objects (logical drives) */
460:                 #else
461:                 #error Number of volumes must not be 0.
462:                 #endif
463:                 
464:                 static PF_WORD Fsid; /* File system mount ID */
465:                 
466:                 #if _FS_RPATH
467:                 static
468:                 PF_BYTE CurrVol; /* Current drive */
469:                 #endif
470:                 
471:                 #if _FS_SHARE
472:                 static
473:                 FILESEM Files[_FS_SHARE]; /* File lock semaphores */
474:                 #endif
475:                 
476:                 #if _USE_LFN == 0			/* No LFN feature */
477:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
478:                 #define INIT_BUF(dobj)		(dobj).fn = sfn
479:                 #define	FREE_BUF()
480:                 
481:                 #elif _USE_LFN == 1			/* LFN feature with static working buffer */
482:                 static WCHAR LfnBuf[_MAX_LFN+1];
483:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
484:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
485:                 #define	FREE_BUF()
486:                 
487:                 #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
488:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
489:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
490:                 #define	FREE_BUF()
491:                 
492:                 #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
493:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR *lfn
494:                 #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
495:                 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
496:                 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
497:                 #define	FREE_BUF()			ff_memfree(lfn)
498:                 
499:                 #else
500:                 #error Wrong LFN configuration.
501:                 #endif
502:                 
503:                 /*--------------------------------------------------------------------------
504:                 
505:                  Module Private Functions
506:                 
507:                  ---------------------------------------------------------------------------*/
508:                 
509:                 /*-----------------------------------------------------------------------*/
510:                 /* String functions                                                      */
511:                 /*-----------------------------------------------------------------------*/
512:                 
513:                 /* Copy memory to memory */
514:                 static
515:                 void mem_cpy(void* dst, const void* src, UINT cnt) {
9D000028  00862021   ADDU A0, A0, A2
516:                 	PF_BYTE *d = (PF_BYTE*) dst;
517:                 	const PF_BYTE *s = (const PF_BYTE*) src;
518:                 
519:                 #if _WORD_ACCESS == 1
520:                 	while (cnt >= sizeof(int)) {
521:                 		*(int*) d = *(int*) s;
522:                 		d += sizeof(int);
523:                 		s += sizeof(int);
524:                 		cnt -= sizeof(int);
525:                 	}
526:                 #endif
527:                 	while (cnt--)
9D000020  10C00007   BEQ A2, ZERO, 0x9D000040
9D000024  00801021   ADDU V0, A0, ZERO
9D000038  1444FFFC   BNE V0, A0, 0x9D00002C
9D00003C  24A50001   ADDIU A1, A1, 1
9D000040  03E00008   JR RA
9D000044  00000000   NOP
528:                 		*d++ = *s++;
9D00002C  90A30000   LBU V1, 0(A1)
9D000030  A0430000   SB V1, 0(V0)
9D000034  24420001   ADDIU V0, V0, 1
529:                 }
530:                 
531:                 /* Fill memory */
532:                 static
533:                 void mem_set(void* dst, int val, UINT cnt) {
9D000050  00862021   ADDU A0, A0, A2
534:                 	PF_BYTE *d = (PF_BYTE*) dst;
535:                 
536:                 	while (cnt--)
9D000048  10C00006   BEQ A2, ZERO, 0x9D000064
9D00004C  00801021   ADDU V0, A0, ZERO
9D00005C  5444FFFE   BNEL V0, A0, 0x9D000058
9D000060  A0450000   SB A1, 0(V0)
9D000064  03E00008   JR RA
9D000068  00000000   NOP
537:                 		*d++ = (PF_BYTE) val;
9D000054  A0450000   SB A1, 0(V0)
9D000058  24420001   ADDIU V0, V0, 1
538:                 }
539:                 
540:                 /* Compare memory to memory */
541:                 static
542:                 int mem_cmp(const void* dst, const void* src, UINT cnt) {
543:                 	const PF_BYTE *d = (const PF_BYTE *) dst, *s = (const PF_BYTE *) src;
9D0010C0  01402021   ADDU A0, T2, ZERO
544:                 	int r = 0;
545:                 
546:                 	while (cnt-- && (r = *d++ - *s++) == 0)
9D0010CC  50680037   BEQL V1, T0, 0x9D0011AC
9D0010D0  9143000B   LBU V1, 11(T2)
9D0010D4  90660000   LBU A2, 0(V1)
9D0010D8  90850000   LBU A1, 0(A0)
9D0010DC  24630001   ADDIU V1, V1, 1
9D0010E0  10C5FFFA   BEQ A2, A1, 0x9D0010CC
9D0010E4  24840001   ADDIU A0, A0, 1
547:                 		;
548:                 	return r;
549:                 }
550:                 
551:                 /* Check if chr is contained in the string */
552:                 static
553:                 int chk_chr(const char* str, int chr) {
554:                 	while (*str && *str != chr)
9D000E8C  24160022   ADDIU S6, ZERO, 34
9D000E90  3C179D01   LUI S7, -25343
9D000FA4  10560071   BEQ V0, S6, 0x9D00116C
9D000FA8  00405021   ADDU T2, V0, ZERO
9D000FAC  26E5A808   ADDIU A1, S7, -22520
9D000FB4  80A70000   LB A3, 0(A1)
9D000FB8  50E00005   BEQL A3, ZERO, 0x9D000FD0
9D000FBC  2445FFBF   ADDIU A1, V0, -65
9D000FC0  5547FFFC   BNEL T2, A3, 0x9D000FB4
9D000FC4  24A50001   ADDIU A1, A1, 1
9D000FC8  0B40045E   J 0x9D001178
9D000FCC  24020006   ADDIU V0, ZERO, 6
9D00116C  0B40045E   J 0x9D001178
9D001170  24020006   ADDIU V0, ZERO, 6
9D001174  24020006   ADDIU V0, ZERO, 6
555:                 		str++;
9D000FB0  24A50001   ADDIU A1, A1, 1
556:                 	return *str;
557:                 }
558:                 
559:                 /*-----------------------------------------------------------------------*/
560:                 /* Request/Release grant to access the volume                            */
561:                 /*-----------------------------------------------------------------------*/
562:                 #if _FS_REENTRANT
563:                 
564:                 static
565:                 int lock_fs (
566:                 		FATFS *fs /* File system object */
567:                 )
568:                 {
569:                 	return ff_req_grant(fs->sobj);
570:                 }
571:                 
572:                 static
573:                 void unlock_fs (
574:                 		FATFS *fs, /* File system object */
575:                 		FRESULT res /* Result code to be returned */
576:                 )
577:                 {
578:                 	if (res != FR_NOT_ENABLED &&
579:                 			res != FR_INVALID_DRIVE &&
580:                 			res != FR_INVALID_OBJECT &&
581:                 			res != FR_TIMEOUT) {
582:                 		ff_rel_grant(fs->sobj);
583:                 	}
584:                 }
585:                 #endif
586:                 
587:                 /*-----------------------------------------------------------------------*/
588:                 /* File shareing control functions                                       */
589:                 /*-----------------------------------------------------------------------*/
590:                 #if _FS_SHARE
591:                 
592:                 static
593:                 FRESULT chk_lock ( /* Check if the file can be accessed */
594:                 		DIR* dj, /* Directory object pointing the file to be checked */
595:                 		int acc /* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
596:                 )
597:                 {
598:                 	UINT i, be;
599:                 
600:                 	/* Search file semaphore table */
601:                 	for (i = be = 0; i < _FS_SHARE; i++) {
602:                 		if (Files[i].fs) { /* Existing entry */
603:                 			if (Files[i].fs == dj->fs && /* Check if the file matched with an open file */
604:                 					Files[i].clu == dj->sclust &&
605:                 					Files[i].idx == dj->index) break;
606:                 		} else { /* Blank entry */
607:                 			be++;
608:                 		}
609:                 	}
610:                 	if (i == _FS_SHARE) /* The file is not opened */
611:                 	return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES; /* Is there a blank entry for new file? */
612:                 
613:                 	/* The file has been opened. Reject any open against writing file and all write mode open */
614:                 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
615:                 }
616:                 
617:                 static
618:                 int enq_lock (void) /* Check if an entry is available for a new file */
619:                 {
620:                 	UINT i;
621:                 
622:                 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
623:                 	return (i == _FS_SHARE) ? 0 : 1;
624:                 }
625:                 
626:                 static
627:                 UINT inc_lock ( /* Increment file open counter and returns its index (0:int error) */
628:                 		DIR* dj, /* Directory object pointing the file to register or increment */
629:                 		int acc /* Desired access mode (0:Read, !0:Write) */
630:                 )
631:                 {
632:                 	UINT i;
633:                 
634:                 	for (i = 0; i < _FS_SHARE; i++) { /* Find the file */
635:                 		if (Files[i].fs == dj->fs &&
636:                 				Files[i].clu == dj->sclust &&
637:                 				Files[i].idx == dj->index) break;
638:                 	}
639:                 
640:                 	if (i == _FS_SHARE) { /* Not opened. Register it as new. */
641:                 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
642:                 		if (i == _FS_SHARE) return 0; /* No space to register (int err) */
643:                 		Files[i].fs = dj->fs;
644:                 		Files[i].clu = dj->sclust;
645:                 		Files[i].idx = dj->index;
646:                 		Files[i].ctr = 0;
647:                 	}
648:                 
649:                 	if (acc && Files[i].ctr) return 0; /* Access violation (int err) */
650:                 
651:                 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1; /* Set semaphore value */
652:                 
653:                 	return i + 1;
654:                 }
655:                 
656:                 static
657:                 FRESULT dec_lock ( /* Decrement file open counter */
658:                 		UINT i /* Semaphore index */
659:                 )
660:                 {
661:                 	PF_WORD n;
662:                 	FRESULT res;
663:                 
664:                 	if (--i < _FS_SHARE) {
665:                 		n = Files[i].ctr;
666:                 		if (n == 0x100) n = 0;
667:                 		if (n) n--;
668:                 		Files[i].ctr = n;
669:                 		if (!n) Files[i].fs = 0;
670:                 		res = FR_OK;
671:                 	} else {
672:                 		res = FR_INT_ERR;
673:                 	}
674:                 	return res;
675:                 }
676:                 
677:                 static
678:                 void clear_lock ( /* Clear lock entries of the volume */
679:                 		FATFS *fs
680:                 )
681:                 {
682:                 	UINT i;
683:                 
684:                 	for (i = 0; i < _FS_SHARE; i++) {
685:                 		if (Files[i].fs == fs) Files[i].fs = 0;
686:                 	}
687:                 }
688:                 #endif
689:                 
690:                 /*-----------------------------------------------------------------------*/
691:                 /* Change window offset                                                  */
692:                 /*-----------------------------------------------------------------------*/
693:                 
694:                 static FRESULT move_window(FATFS *fs, /* File system object */
695:                 DWORD sector /* Sector number to make appearance in the fs->win[] */
696:                 ) /* Move to zero only writes back dirty window */
697:                 {
9D000208  27BDFFD8   ADDIU SP, SP, -40
9D00020C  AFBF0024   SW RA, 36(SP)
9D000210  AFB40020   SW S4, 32(SP)
9D000214  AFB3001C   SW S3, 28(SP)
9D000218  AFB20018   SW S2, 24(SP)
9D00021C  AFB10014   SW S1, 20(SP)
9D000220  AFB00010   SW S0, 16(SP)
9D000224  00808021   ADDU S0, A0, ZERO
9D000228  00A09021   ADDU S2, A1, ZERO
698:                 	DWORD wsect;
699:                 
700:                 	wsect = fs->winsect;
9D00022C  8C91002C   LW S1, 44(A0)
701:                 	if (wsect != sector) { /* Changed current window */
9D000230  1225002D   BEQ S1, A1, 0x9D0002E8
9D000234  00001821   ADDU V1, ZERO, ZERO
702:                 #if !_FS_READONLY
703:                 		if (fs->wflag) { /* Write back dirty window if needed */
9D000238  90820004   LBU V0, 4(A0)
9D00023C  1040001F   BEQ V0, ZERO, 0x9D0002BC
9D000240  02203021   ADDU A2, S1, ZERO
704:                 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
9D000244  24940030   ADDIU S4, A0, 48
9D000248  90840001   LBU A0, 1(A0)
9D00024C  02802821   ADDU A1, S4, ZERO
9D000250  0F401B4F   JAL disk_write
9D000254  24070001   ADDIU A3, ZERO, 1
9D000258  14400023   BNE V0, ZERO, 0x9D0002E8
9D00025C  24030001   ADDIU V1, ZERO, 1
705:                 				return FR_DISK_ERR;
706:                 			fs->wflag = 0;
9D000260  A2000004   SB ZERO, 4(S0)
707:                 			if (wsect < (fs->fatbase + fs->fsize)) { /* In FAT area */
9D000264  8E03001C   LW V1, 28(S0)
9D000268  8E020020   LW V0, 32(S0)
9D00026C  00621021   ADDU V0, V1, V0
9D000270  0222102B   SLTU V0, S1, V0
9D000274  10400011   BEQ V0, ZERO, 0x9D0002BC
9D000278  00000000   NOP
708:                 				PF_BYTE nf;
709:                 				for (nf = fs->n_fats; nf > 1; nf--) { /* Reflect the change to all FAT copies */
9D00027C  92130003   LBU S3, 3(S0)
9D000280  2E620002   SLTIU V0, S3, 2
9D000284  1440000D   BNE V0, ZERO, 0x9D0002BC
9D000288  00000000   NOP
9D0002A8  2673FFFF   ADDIU S3, S3, -1
9D0002AC  327300FF   ANDI S3, S3, 255
9D0002B0  24020001   ADDIU V0, ZERO, 1
9D0002B4  5662FFF6   BNEL S3, V0, 0x9D000290
9D0002B8  8E02001C   LW V0, 28(S0)
710:                 					wsect += fs->fsize;
9D00028C  8E02001C   LW V0, 28(S0)
9D000290  02228821   ADDU S1, S1, V0
711:                 					disk_write(fs->drv, fs->win, wsect, 1);
9D000294  92040001   LBU A0, 1(S0)
9D000298  02802821   ADDU A1, S4, ZERO
9D00029C  02203021   ADDU A2, S1, ZERO
9D0002A0  0F401B4F   JAL disk_write
9D0002A4  24070001   ADDIU A3, ZERO, 1
712:                 				}
713:                 			}
714:                 		}
715:                 #endif
716:                 		if (sector) {
9D0002BC  1240000A   BEQ S2, ZERO, 0x9D0002E8
9D0002C0  00001821   ADDU V1, ZERO, ZERO
717:                 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
9D0002C4  92040001   LBU A0, 1(S0)
9D0002C8  26050030   ADDIU A1, S0, 48
9D0002CC  02403021   ADDU A2, S2, ZERO
9D0002D0  0F401B19   JAL disk_read
9D0002D4  24070001   ADDIU A3, ZERO, 1
9D0002D8  14400003   BNE V0, ZERO, 0x9D0002E8
9D0002DC  24030001   ADDIU V1, ZERO, 1
718:                 				return FR_DISK_ERR;
719:                 			fs->winsect = sector;
9D0002E0  AE12002C   SW S2, 44(S0)
720:                 		}
721:                 	}
722:                 
723:                 	return FR_OK;
9D0002E4  00001821   ADDU V1, ZERO, ZERO
724:                 }
9D0002E8  00601021   ADDU V0, V1, ZERO
9D0002EC  8FBF0024   LW RA, 36(SP)
9D0002F0  8FB40020   LW S4, 32(SP)
9D0002F4  8FB3001C   LW S3, 28(SP)
9D0002F8  8FB20018   LW S2, 24(SP)
9D0002FC  8FB10014   LW S1, 20(SP)
9D000300  8FB00010   LW S0, 16(SP)
9D000304  03E00008   JR RA
9D000308  27BD0028   ADDIU SP, SP, 40
725:                 
726:                 /*-----------------------------------------------------------------------*/
727:                 /* Clean-up cached data                                                  */
728:                 /*-----------------------------------------------------------------------*/
729:                 #if !_FS_READONLY
730:                 static FRESULT sync( /* FR_OK: successful, FR_DISK_ERR: failed */
731:                 FATFS *fs /* File system object */
732:                 ) {
9D0003E4  27BDFFE0   ADDIU SP, SP, -32
9D0003E8  AFBF001C   SW RA, 28(SP)
9D0003EC  AFB20018   SW S2, 24(SP)
9D0003F0  AFB10014   SW S1, 20(SP)
9D0003F4  AFB00010   SW S0, 16(SP)
9D0003F8  00808821   ADDU S1, A0, ZERO
733:                 	FRESULT res;
734:                 
735:                 	res = move_window(fs, 0);
9D0003FC  0F400082   JAL 0x9D000208
9D000400  00002821   ADDU A1, ZERO, ZERO
736:                 	if (res == FR_OK) {
9D000404  1440003A   BNE V0, ZERO, 0x9D0004F0
9D000408  00408021   ADDU S0, V0, ZERO
737:                 		/* Update FSInfo sector if needed */
738:                 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
9D00040C  92230000   LBU V1, 0(S1)
9D000410  24020003   ADDIU V0, ZERO, 3
9D000414  54620031   BNEL V1, V0, 0x9D0004DC
9D000418  92240001   LBU A0, 1(S1)
9D00041C  92220005   LBU V0, 5(S1)
9D000420  5040002E   BEQL V0, ZERO, 0x9D0004DC
9D000424  92240001   LBU A0, 1(S1)
739:                 			fs->winsect = 0;
9D000428  AE20002C   SW ZERO, 44(S1)
740:                 			/* Create FSInfo structure */
741:                 			mem_set(fs->win, 0, 512);
9D00042C  26320030   ADDIU S2, S1, 48
9D000430  02402021   ADDU A0, S2, ZERO
9D000434  00002821   ADDU A1, ZERO, ZERO
9D000438  0F400012   JAL 0x9D000048
9D00043C  24060200   ADDIU A2, ZERO, 512
742:                 			ST_WORD(fs->win+BS_55AA, 0xAA55);
9D000440  24020055   ADDIU V0, ZERO, 85
9D000444  A222022E   SB V0, 558(S1)
9D000448  2402FFAA   ADDIU V0, ZERO, -86
9D00044C  A222022F   SB V0, 559(S1)
743:                 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
9D000450  24020052   ADDIU V0, ZERO, 82
9D000454  A2220030   SB V0, 48(S1)
9D000458  A2220031   SB V0, 49(S1)
9D00045C  24020061   ADDIU V0, ZERO, 97
9D000460  A2220032   SB V0, 50(S1)
9D000464  24030041   ADDIU V1, ZERO, 65
9D000468  A2230033   SB V1, 51(S1)
744:                 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
9D00046C  24040072   ADDIU A0, ZERO, 114
9D000470  A2240214   SB A0, 532(S1)
9D000474  A2240215   SB A0, 533(S1)
9D000478  A2230216   SB V1, 534(S1)
9D00047C  A2220217   SB V0, 535(S1)
745:                 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
9D000480  8E220010   LW V0, 16(S1)
9D000484  A2220218   SB V0, 536(S1)
9D000488  7C433A00   EXT V1, V0, 8, 8
9D00048C  A2230219   SB V1, 537(S1)
9D000490  00021C02   SRL V1, V0, 16
9D000494  A223021A   SB V1, 538(S1)
9D000498  00021602   SRL V0, V0, 24
9D00049C  A222021B   SB V0, 539(S1)
746:                 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
9D0004A0  8E22000C   LW V0, 12(S1)
9D0004A4  A222021C   SB V0, 540(S1)
9D0004A8  7C433A00   EXT V1, V0, 8, 8
9D0004AC  A223021D   SB V1, 541(S1)
9D0004B0  00021C02   SRL V1, V0, 16
9D0004B4  A223021E   SB V1, 542(S1)
9D0004B8  00021602   SRL V0, V0, 24
9D0004BC  A222021F   SB V0, 543(S1)
747:                 			/* Write it into the FSInfo sector */
748:                 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
9D0004C0  92240001   LBU A0, 1(S1)
9D0004C4  02402821   ADDU A1, S2, ZERO
9D0004C8  8E260014   LW A2, 20(S1)
9D0004CC  0F401B4F   JAL disk_write
9D0004D0  24070001   ADDIU A3, ZERO, 1
749:                 			fs->fsi_flag = 0;
9D0004D4  A2200005   SB ZERO, 5(S1)
750:                 		}
751:                 		/* Make sure that no pending write process in the physical drive */
752:                 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
9D0004D8  92240001   LBU A0, 1(S1)
9D0004DC  00002821   ADDU A1, ZERO, ZERO
9D0004E0  0F401B94   JAL disk_ioctl
9D0004E4  00003021   ADDU A2, ZERO, ZERO
753:                 			res = FR_DISK_ERR;
9D0004E8  24030001   ADDIU V1, ZERO, 1
9D0004EC  0062800B   MOVN S0, V1, V0
754:                 	}
755:                 
756:                 	return res;
757:                 }
9D0004F0  02001021   ADDU V0, S0, ZERO
9D0004F4  8FBF001C   LW RA, 28(SP)
9D0004F8  8FB20018   LW S2, 24(SP)
9D0004FC  8FB10014   LW S1, 20(SP)
9D000500  8FB00010   LW S0, 16(SP)
9D000504  03E00008   JR RA
9D000508  27BD0020   ADDIU SP, SP, 32
758:                 #endif
759:                 
760:                 /*-----------------------------------------------------------------------*/
761:                 /* Get sector# from cluster#                                             */
762:                 /*-----------------------------------------------------------------------*/
763:                 
764:                 DWORD clust2sect( /* !=0: Sector number, 0: Failed - invalid cluster# */
765:                 FATFS *fs, /* File system object */
766:                 DWORD clst /* Cluster# to be converted */
767:                 ) {
768:                 	clst -= 2;
9D000558  24A5FFFE   ADDIU A1, A1, -2
769:                 	if (clst >= (fs->n_fatent - 2))
9D00055C  8C830018   LW V1, 24(A0)
9D000560  2463FFFE   ADDIU V1, V1, -2
9D000564  00A3182B   SLTU V1, A1, V1
9D000568  10600005   BEQ V1, ZERO, 0x9D000580
9D00056C  00001021   ADDU V0, ZERO, ZERO
770:                 		return 0; /* Invalid cluster# */
771:                 	return clst * fs->csize + fs->database;
9D000570  90820002   LBU V0, 2(A0)
9D000574  8C830028   LW V1, 40(A0)
9D000578  70A22002   MUL A0, A1, V0
9D00057C  00831021   ADDU V0, A0, V1
772:                 }
9D000580  03E00008   JR RA
9D000584  00000000   NOP
773:                 
774:                 /*-----------------------------------------------------------------------*/
775:                 /* FAT access - Read value of a FAT entry                                */
776:                 /*-----------------------------------------------------------------------*/
777:                 
778:                 DWORD get_fat( /* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
779:                 FATFS *fs, /* File system object */
780:                 DWORD clst /* Cluster# to get the link information */
781:                 ) {
9D000588  27BDFFD8   ADDIU SP, SP, -40
9D00058C  AFBF0024   SW RA, 36(SP)
9D000590  AFB30020   SW S3, 32(SP)
9D000594  AFB2001C   SW S2, 28(SP)
9D000598  AFB10018   SW S1, 24(SP)
9D00059C  AFB00014   SW S0, 20(SP)
9D0005A0  00808021   ADDU S0, A0, ZERO
9D0005A4  00A08821   ADDU S1, A1, ZERO
782:                 	UINT wc, bc;
783:                 	PF_BYTE *p;
784:                 
785:                 	if (clst < 2 || clst >= fs->n_fatent) /* Chack range */
9D0005A8  2CA20002   SLTIU V0, A1, 2
9D0005AC  1440004F   BNE V0, ZERO, 0x9D0006EC
9D0005B0  24030001   ADDIU V1, ZERO, 1
9D0005B4  8C820018   LW V0, 24(A0)
9D0005B8  00A2102B   SLTU V0, A1, V0
9D0005BC  1040004C   BEQ V0, ZERO, 0x9D0006F0
9D0005C0  00601021   ADDU V0, V1, ZERO
786:                 		return 1;
787:                 
788:                 	switch (fs->fs_type) {
9D0005C4  90820000   LBU V0, 0(A0)
9D0005C8  24030002   ADDIU V1, ZERO, 2
9D0005CC  50430025   BEQL V0, V1, 0x9D000664
9D0005D0  00052A02   SRL A1, A1, 8
9D0005D4  24030003   ADDIU V1, ZERO, 3
9D0005D8  5043002F   BEQL V0, V1, 0x9D000698
9D0005DC  000529C2   SRL A1, A1, 7
9D0005E0  24030001   ADDIU V1, ZERO, 1
9D0005E4  54430041   BNEL V0, V1, 0x9D0006EC
9D0005E8  2403FFFF   ADDIU V1, ZERO, -1
789:                 	case FS_FAT12:
790:                 		bc = (UINT) clst;
791:                 		bc += bc / 2;
9D0005EC  00059042   SRL S2, A1, 1
9D0005F0  02459021   ADDU S2, S2, A1
792:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D0005F4  00122A42   SRL A1, S2, 9
9D0005F8  8C820020   LW V0, 32(A0)
9D0005FC  0F400082   JAL 0x9D000208
9D000600  00A22821   ADDU A1, A1, V0
9D000604  14400039   BNE V0, ZERO, 0x9D0006EC
9D000608  2403FFFF   ADDIU V1, ZERO, -1
793:                 			break;
794:                 		wc = fs->win[bc % SS(fs)];
9D00060C  324201FF   ANDI V0, S2, 511
9D000610  02021021   ADDU V0, S0, V0
9D000614  90530030   LBU S3, 48(V0)
795:                 		bc++;
9D000618  26520001   ADDIU S2, S2, 1
796:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D00061C  00122A42   SRL A1, S2, 9
9D000620  8E020020   LW V0, 32(S0)
9D000624  02002021   ADDU A0, S0, ZERO
9D000628  0F400082   JAL 0x9D000208
9D00062C  00A22821   ADDU A1, A1, V0
9D000630  1440002E   BNE V0, ZERO, 0x9D0006EC
9D000634  2403FFFF   ADDIU V1, ZERO, -1
797:                 			break;
798:                 		wc |= fs->win[bc % SS(fs)] << 8;
9D000638  325201FF   ANDI S2, S2, 511
9D00063C  02128021   ADDU S0, S0, S2
9D000640  92030030   LBU V1, 48(S0)
9D000644  00031A00   SLL V1, V1, 8
9D000648  00739825   OR S3, V1, S3
799:                 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
9D00064C  32310001   ANDI S1, S1, 1
9D000650  00131102   SRL V0, S3, 4
9D000654  32730FFF   ANDI S3, S3, 4095
9D000658  00401821   ADDU V1, V0, ZERO
9D00065C  0B4001BB   J 0x9D0006EC
9D000660  0271180A   MOVZ V1, S3, S1
800:                 
801:                 	case FS_FAT16:
802:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))))
9D000664  8C820020   LW V0, 32(A0)
9D000668  0F400082   JAL 0x9D000208
9D00066C  00A22821   ADDU A1, A1, V0
9D000670  1440001E   BNE V0, ZERO, 0x9D0006EC
9D000674  2403FFFF   ADDIU V1, ZERO, -1
803:                 			break;
804:                 		p = &fs->win[clst * 2 % SS(fs)];
9D000678  00118840   SLL S1, S1, 1
9D00067C  323101FF   ANDI S1, S1, 511
805:                 		return LD_WORD(p);
9D000680  02111021   ADDU V0, S0, S1
9D000684  90430031   LBU V1, 49(V0)
9D000688  00031A00   SLL V1, V1, 8
9D00068C  90420030   LBU V0, 48(V0)
9D000690  0B4001BB   J 0x9D0006EC
9D000694  00621825   OR V1, V1, V0
806:                 
807:                 	case FS_FAT32:
808:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))))
9D000698  8C820020   LW V0, 32(A0)
9D00069C  0F400082   JAL 0x9D000208
9D0006A0  00A22821   ADDU A1, A1, V0
9D0006A4  14400011   BNE V0, ZERO, 0x9D0006EC
9D0006A8  2403FFFF   ADDIU V1, ZERO, -1
809:                 			break;
810:                 		p = &fs->win[clst * 4 % SS(fs)];
9D0006AC  00118880   SLL S1, S1, 2
9D0006B0  323101FF   ANDI S1, S1, 511
9D0006B4  26220030   ADDIU V0, S1, 48
9D0006B8  02021021   ADDU V0, S0, V0
811:                 		return LD_DWORD(p) & 0x0FFFFFFF;
9D0006BC  90440002   LBU A0, 2(V0)
9D0006C0  00042400   SLL A0, A0, 16
9D0006C4  90430003   LBU V1, 3(V0)
9D0006C8  00031E00   SLL V1, V1, 24
9D0006CC  00831825   OR V1, A0, V1
9D0006D0  90420001   LBU V0, 1(V0)
9D0006D4  00021200   SLL V0, V0, 8
9D0006D8  00621825   OR V1, V1, V0
9D0006DC  02118021   ADDU S0, S0, S1
9D0006E0  92020030   LBU V0, 48(S0)
9D0006E4  00621825   OR V1, V1, V0
9D0006E8  7C63D800   EXT V1, V1, 0, 28
812:                 	}
813:                 
814:                 	return 0xFFFFFFFF; /* An error occurred at the disk I/O layer */
815:                 }
9D0006EC  00601021   ADDU V0, V1, ZERO
9D0006F0  8FBF0024   LW RA, 36(SP)
9D0006F4  8FB30020   LW S3, 32(SP)
9D0006F8  8FB2001C   LW S2, 28(SP)
9D0006FC  8FB10018   LW S1, 24(SP)
9D000700  8FB00014   LW S0, 20(SP)
9D000704  03E00008   JR RA
9D000708  27BD0028   ADDIU SP, SP, 40
816:                 
817:                 /*-----------------------------------------------------------------------*/
818:                 /* FAT access - Change value of a FAT entry                              */
819:                 /*-----------------------------------------------------------------------*/
820:                 #if !_FS_READONLY
821:                 
822:                 FRESULT put_fat(FATFS *fs, /* File system object */
823:                 DWORD clst, /* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
824:                 DWORD val /* New value to mark the cluster */
825:                 ) {
9D0008C8  27BDFFD8   ADDIU SP, SP, -40
9D0008CC  AFBF0024   SW RA, 36(SP)
9D0008D0  AFB30020   SW S3, 32(SP)
9D0008D4  AFB2001C   SW S2, 28(SP)
9D0008D8  AFB10018   SW S1, 24(SP)
9D0008DC  AFB00014   SW S0, 20(SP)
9D0008E0  00808021   ADDU S0, A0, ZERO
9D0008E4  00A08821   ADDU S1, A1, ZERO
9D0008E8  00C09021   ADDU S2, A2, ZERO
826:                 	UINT bc;
827:                 	PF_BYTE *p;
828:                 	FRESULT res;
829:                 
830:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D0008EC  2CA30002   SLTIU V1, A1, 2
9D0008F0  1460005D   BNE V1, ZERO, 0x9D000A68
9D0008F4  24020002   ADDIU V0, ZERO, 2
9D0008F8  8C830018   LW V1, 24(A0)
9D0008FC  00A3182B   SLTU V1, A1, V1
9D000900  10600059   BEQ V1, ZERO, 0x9D000A68
9D000904  24030002   ADDIU V1, ZERO, 2
831:                 		res = FR_INT_ERR;
832:                 
833:                 	} else {
834:                 		switch (fs->fs_type) {
9D000908  90820000   LBU V0, 0(A0)
9D00090C  10430030   BEQ V0, V1, 0x9D0009D0
9D000910  24030003   ADDIU V1, ZERO, 3
9D000914  1043003B   BEQ V0, V1, 0x9D000A04
9D000918  24030001   ADDIU V1, ZERO, 1
9D00091C  14430050   BNE V0, V1, 0x9D000A60
9D000920  24020002   ADDIU V0, ZERO, 2
835:                 		case FS_FAT12:
836:                 			bc = clst;
837:                 			bc += bc / 2;
9D000924  00059842   SRL S3, A1, 1
9D000928  02659821   ADDU S3, S3, A1
838:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D00092C  00132A42   SRL A1, S3, 9
9D000930  8C820020   LW V0, 32(A0)
9D000934  0F400082   JAL 0x9D000208
9D000938  00A22821   ADDU A1, A1, V0
839:                 			if (res != FR_OK)
9D00093C  14400049   BNE V0, ZERO, 0x9D000A64
9D000940  24030001   ADDIU V1, ZERO, 1
840:                 				break;
841:                 			p = &fs->win[bc % SS(fs)];
9D000944  326301FF   ANDI V1, S3, 511
842:                 			*p = (clst & 1) ? ((*p & 0x0F) | ((PF_BYTE) val << 4))
9D000948  32310001   ANDI S1, S1, 1
9D00094C  12200008   BEQ S1, ZERO, 0x9D000970
9D000950  324200FF   ANDI V0, S2, 255
9D000954  02031021   ADDU V0, S0, V1
9D000958  90440030   LBU A0, 48(V0)
9D00095C  3084000F   ANDI A0, A0, 15
9D000960  324200FF   ANDI V0, S2, 255
9D000964  00021100   SLL V0, V0, 4
9D000968  00821025   OR V0, A0, V0
9D00096C  304200FF   ANDI V0, V0, 255
9D000970  02031821   ADDU V1, S0, V1
9D000974  A0620030   SB V0, 48(V1)
843:                 					: (PF_BYTE) val;
844:                 			bc++;
9D000978  26730001   ADDIU S3, S3, 1
845:                 			fs->wflag = 1;
9D00097C  24020001   ADDIU V0, ZERO, 1
9D000980  A2020004   SB V0, 4(S0)
846:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D000984  00132A42   SRL A1, S3, 9
9D000988  8E020020   LW V0, 32(S0)
9D00098C  02002021   ADDU A0, S0, ZERO
9D000990  0F400082   JAL 0x9D000208
9D000994  00A22821   ADDU A1, A1, V0
847:                 			if (res != FR_OK)
9D000998  14400032   BNE V0, ZERO, 0x9D000A64
9D00099C  24030001   ADDIU V1, ZERO, 1
848:                 				break;
849:                 			p = &fs->win[bc % SS(fs)];
850:                 			*p = (clst & 1) ? (PF_BYTE) (val >> 4) : ((*p & 0xF0)
9D0009A0  12200003   BEQ S1, ZERO, 0x9D0009B0
9D0009A4  327301FF   ANDI S3, S3, 511
9D0009A8  0B400271   J 0x9D0009C4
9D0009AC  7E523900   EXT S2, S2, 4, 8
9D0009B0  02131821   ADDU V1, S0, S3
9D0009B4  90630030   LBU V1, 48(V1)
9D0009B8  306300F0   ANDI V1, V1, 240
9D0009BC  7E521A00   EXT S2, S2, 8, 4
9D0009C0  00729025   OR S2, V1, S2
9D0009C4  02139821   ADDU S3, S0, S3
851:                 					| ((PF_BYTE) (val >> 8) & 0x0F));
852:                 			break;
9D0009C8  0B400298   J 0x9D000A60
9D0009CC  A2720030   SB S2, 48(S3)
853:                 
854:                 		case FS_FAT16:
855:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
9D0009D0  00052A02   SRL A1, A1, 8
9D0009D4  8C820020   LW V0, 32(A0)
9D0009D8  0F400082   JAL 0x9D000208
9D0009DC  00A22821   ADDU A1, A1, V0
856:                 			if (res != FR_OK)
9D0009E0  14400020   BNE V0, ZERO, 0x9D000A64
9D0009E4  24030001   ADDIU V1, ZERO, 1
857:                 				break;
858:                 			p = &fs->win[clst * 2 % SS(fs)];
9D0009E8  00118840   SLL S1, S1, 1
9D0009EC  323101FF   ANDI S1, S1, 511
859:                 			ST_WORD(p, (PF_WORD)val)
9D0009F0  02111821   ADDU V1, S0, S1
9D0009F4  A0720030   SB S2, 48(V1)
9D0009F8  7E523A00   EXT S2, S2, 8, 8
860:                 			;
861:                 			break;
9D0009FC  0B400298   J 0x9D000A60
9D000A00  A0720031   SB S2, 49(V1)
862:                 
863:                 		case FS_FAT32:
864:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
9D000A04  000529C2   SRL A1, A1, 7
9D000A08  8C820020   LW V0, 32(A0)
9D000A0C  0F400082   JAL 0x9D000208
9D000A10  00A22821   ADDU A1, A1, V0
865:                 			if (res != FR_OK)
9D000A14  14400013   BNE V0, ZERO, 0x9D000A64
9D000A18  24030001   ADDIU V1, ZERO, 1
866:                 				break;
867:                 			p = &fs->win[clst * 4 % SS(fs)];
9D000A1C  00118880   SLL S1, S1, 2
9D000A20  323101FF   ANDI S1, S1, 511
9D000A24  26230030   ADDIU V1, S1, 48
9D000A28  02031821   ADDU V1, S0, V1
868:                 			val |= LD_DWORD(p) & 0xF0000000;
9D000A2C  90640003   LBU A0, 3(V1)
9D000A30  00042600   SLL A0, A0, 24
9D000A34  02118821   ADDU S1, S0, S1
9D000A38  3C05F000   LUI A1, -4096
9D000A3C  00852024   AND A0, A0, A1
9D000A40  00929025   OR S2, A0, S2
869:                 			ST_DWORD(p, val)
9D000A44  A2320030   SB S2, 48(S1)
9D000A48  7E443A00   EXT A0, S2, 8, 8
9D000A4C  A0640001   SB A0, 1(V1)
9D000A50  00122402   SRL A0, S2, 16
9D000A54  A0640002   SB A0, 2(V1)
9D000A58  00129602   SRL S2, S2, 24
9D000A5C  A0720003   SB S2, 3(V1)
870:                 			;
871:                 			break;
872:                 
873:                 		default:
874:                 			res = FR_INT_ERR;
875:                 		}
876:                 		fs->wflag = 1;
9D000A60  24030001   ADDIU V1, ZERO, 1
9D000A64  A2030004   SB V1, 4(S0)
877:                 	}
878:                 
879:                 	return res;
880:                 }
9D000A68  8FBF0024   LW RA, 36(SP)
9D000A6C  8FB30020   LW S3, 32(SP)
9D000A70  8FB2001C   LW S2, 28(SP)
9D000A74  8FB10018   LW S1, 24(SP)
9D000A78  8FB00014   LW S0, 20(SP)
9D000A7C  03E00008   JR RA
9D000A80  27BD0028   ADDIU SP, SP, 40
881:                 #endif /* !_FS_READONLY */
882:                 
883:                 /*-----------------------------------------------------------------------*/
884:                 /* FAT handling - Remove a cluster chain                                 */
885:                 /*-----------------------------------------------------------------------*/
886:                 #if !_FS_READONLY
887:                 static FRESULT remove_chain(FATFS *fs, /* File system object */
888:                 DWORD clst /* Cluster# to remove a chain from */
889:                 ) {
9D001344  27BDFFD0   ADDIU SP, SP, -48
9D001348  AFBF002C   SW RA, 44(SP)
9D00134C  AFB50028   SW S5, 40(SP)
9D001350  AFB40024   SW S4, 36(SP)
9D001354  AFB30020   SW S3, 32(SP)
9D001358  AFB2001C   SW S2, 28(SP)
9D00135C  AFB10018   SW S1, 24(SP)
9D001360  AFB00014   SW S0, 20(SP)
9D001364  00808821   ADDU S1, A0, ZERO
9D001368  00A09021   ADDU S2, A1, ZERO
890:                 	FRESULT res;
891:                 	DWORD nxt;
892:                 #if _USE_ERASE
893:                 	DWORD scl = clst, ecl = clst, resion[2];
894:                 #endif
895:                 
896:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D00136C  2CA30002   SLTIU V1, A1, 2
9D001370  14600025   BNE V1, ZERO, 0x9D001408
9D001374  24020002   ADDIU V0, ZERO, 2
9D001378  8C830018   LW V1, 24(A0)
9D00137C  00A3182B   SLTU V1, A1, V1
9D001380  14600003   BNE V1, ZERO, 0x9D001390
9D001384  24140001   ADDIU S4, ZERO, 1
897:                 		res = FR_INT_ERR;
898:                 
899:                 	} else {
900:                 		res = FR_OK;
901:                 		while (clst < fs->n_fatent) { /* Not a last link? */
9D0013E4  8E230018   LW V1, 24(S1)
9D0013E8  0203182B   SLTU V1, S0, V1
9D0013EC  1460FFEA   BNE V1, ZERO, 0x9D001398
9D0013F0  02009021   ADDU S2, S0, ZERO
902:                 			nxt = get_fat(fs, clst); /* Get cluster status */
9D001398  02202021   ADDU A0, S1, ZERO
9D00139C  0F400162   JAL get_fat
9D0013A0  02402821   ADDU A1, S2, ZERO
903:                 			if (nxt == 0)
9D0013A4  10400015   BEQ V0, ZERO, 0x9D0013FC
9D0013A8  00408021   ADDU S0, V0, ZERO
9D0013FC  0B400502   J 0x9D001408
9D001400  00001021   ADDU V0, ZERO, ZERO
904:                 				break; /* Empty cluster? */
905:                 			if (nxt == 1) {
9D0013AC  50540016   BEQL V0, S4, 0x9D001408
9D0013B0  24020002   ADDIU V0, ZERO, 2
906:                 				res = FR_INT_ERR;
907:                 				break;
908:                 			} /* Internal error? */
909:                 			if (nxt == 0xFFFFFFFF) {
9D001390  2413FFFF   ADDIU S3, ZERO, -1
9D0013B4  10530013   BEQ V0, S3, 0x9D001404
9D0013B8  02202021   ADDU A0, S1, ZERO
910:                 				res = FR_DISK_ERR;
9D001404  24020001   ADDIU V0, ZERO, 1
911:                 				break;
912:                 			} /* Disk error? */
913:                 			res = put_fat(fs, clst, 0); /* Mark the cluster "empty" */
9D0013BC  02402821   ADDU A1, S2, ZERO
9D0013C0  0F400232   JAL put_fat
9D0013C4  00003021   ADDU A2, ZERO, ZERO
914:                 			if (res != FR_OK)
9D0013C8  14400010   BNE V0, ZERO, 0x9D00140C
9D0013CC  8FBF002C   LW RA, 44(SP)
915:                 				break;
916:                 			if (fs->free_clust != 0xFFFFFFFF) { /* Update FSInfo */
9D0013D0  8E230010   LW V1, 16(S1)
9D0013D4  10730003   BEQ V1, S3, 0x9D0013E4
9D0013D8  24630001   ADDIU V1, V1, 1
917:                 				fs->free_clust++;
9D0013DC  AE230010   SW V1, 16(S1)
918:                 				fs->fsi_flag = 1;
9D001394  24150001   ADDIU S5, ZERO, 1
9D0013E0  A2350005   SB S5, 5(S1)
919:                 			}
920:                 #if _USE_ERASE
921:                 			if (ecl + 1 == nxt) { /* Next cluster is contiguous */
922:                 				ecl = nxt;
923:                 			} else { /* End of contiguous clusters */
924:                 				resion[0] = clust2sect(fs, scl); /* Start sector */
925:                 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1; /* End sector */
926:                 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion); /* Erase the block */
927:                 				scl = ecl = nxt;
928:                 			}
929:                 #endif
930:                 			clst = nxt; /* Next cluster */
931:                 		}
932:                 	}
933:                 
934:                 	return res;
935:                 }
9D001388  0B400503   J 0x9D00140C
9D00138C  8FBF002C   LW RA, 44(SP)
9D0013F4  0B400503   J 0x9D00140C
9D0013F8  8FBF002C   LW RA, 44(SP)
9D001408  8FBF002C   LW RA, 44(SP)
9D00140C  8FB50028   LW S5, 40(SP)
9D001410  8FB40024   LW S4, 36(SP)
9D001414  8FB30020   LW S3, 32(SP)
9D001418  8FB2001C   LW S2, 28(SP)
9D00141C  8FB10018   LW S1, 24(SP)
9D001420  8FB00014   LW S0, 20(SP)
9D001424  03E00008   JR RA
9D001428  27BD0030   ADDIU SP, SP, 48
936:                 #endif
937:                 
938:                 /*-----------------------------------------------------------------------*/
939:                 /* FAT handling - Stretch or Create a cluster chain                      */
940:                 /*-----------------------------------------------------------------------*/
941:                 #if !_FS_READONLY
942:                 static DWORD create_chain( /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
943:                 FATFS *fs, /* File system object */
944:                 DWORD clst /* Cluster# to stretch. 0 means create a new chain. */
945:                 ) {
9D000A84  27BDFFD0   ADDIU SP, SP, -48
9D000A88  AFBF002C   SW RA, 44(SP)
9D000A8C  AFB60028   SW S6, 40(SP)
9D000A90  AFB50024   SW S5, 36(SP)
9D000A94  AFB40020   SW S4, 32(SP)
9D000A98  AFB3001C   SW S3, 28(SP)
9D000A9C  AFB20018   SW S2, 24(SP)
9D000AA0  AFB10014   SW S1, 20(SP)
9D000AA4  AFB00010   SW S0, 16(SP)
9D000AA8  00808821   ADDU S1, A0, ZERO
946:                 	DWORD cs, ncl, scl;
947:                 	FRESULT res;
948:                 
949:                 	if (clst == 0) { /* Create a new chain */
9D000AAC  14A00009   BNE A1, ZERO, 0x9D000AD4
9D000AB0  00A0B021   ADDU S6, A1, ZERO
950:                 		scl = fs->last_clust; /* Get suggested start point */
9D000AB4  8C92000C   LW S2, 12(A0)
951:                 		if (!scl || scl >= fs->n_fatent)
9D000AB8  52400011   BEQL S2, ZERO, 0x9D000B00
9D000ABC  24120001   ADDIU S2, ZERO, 1
9D000AC0  8C830018   LW V1, 24(A0)
9D000AC4  0243182B   SLTU V1, S2, V1
952:                 			scl = 1;
9D000AC8  24020001   ADDIU V0, ZERO, 1
9D000ACC  0B4002C0   J 0x9D000B00
9D000AD0  0043900A   MOVZ S2, V0, V1
953:                 	} else { /* Stretch the current chain */
954:                 		cs = get_fat(fs, clst); /* Check the cluster status */
9D000AD4  0F400162   JAL get_fat
9D000AD8  00000000   NOP
955:                 		if (cs < 2)
9D000ADC  2C430002   SLTIU V1, V0, 2
9D000AE0  5460003F   BNEL V1, ZERO, 0x9D000BE0
9D000AE4  24020001   ADDIU V0, ZERO, 1
956:                 			return 1; /* It is an invalid cluster */
957:                 		if (cs < fs->n_fatent)
9D000AE8  8E230018   LW V1, 24(S1)
9D000AEC  0043182B   SLTU V1, V0, V1
9D000AF0  10600003   BEQ V1, ZERO, 0x9D000B00
9D000AF4  02C09021   ADDU S2, S6, ZERO
958:                 			return cs; /* It is already followed by next cluster */
959:                 		scl = clst;
960:                 	}
961:                 
962:                 	ncl = scl; /* Start cluster */
9D000B00  02408021   ADDU S0, S2, ZERO
963:                 	for (;;) {
964:                 		ncl++; /* Next cluster */
9D000B10  26100001   ADDIU S0, S0, 1
965:                 		if (ncl >= fs->n_fatent) { /* Wrap around */
9D000B14  8E220018   LW V0, 24(S1)
9D000B18  0202102B   SLTU V0, S0, V0
9D000B1C  14400004   BNE V0, ZERO, 0x9D000B30
9D000B20  02202021   ADDU A0, S1, ZERO
966:                 			ncl = 2;
967:                 			if (ncl > scl)
9D000B04  2E550002   SLTIU S5, S2, 2
9D000B24  16A0002D   BNE S5, ZERO, 0x9D000BDC
9D000B28  24100002   ADDIU S0, ZERO, 2
968:                 				return 0; /* No free cluster */
969:                 		}
970:                 		cs = get_fat(fs, ncl); /* Get the cluster status */
9D000B2C  02202021   ADDU A0, S1, ZERO
9D000B30  0F400162   JAL get_fat
9D000B34  02002821   ADDU A1, S0, ZERO
971:                 		if (cs == 0)
9D000B38  50400009   BEQL V0, ZERO, 0x9D000B60
9D000B3C  02009021   ADDU S2, S0, ZERO
972:                 			break; /* Found a free cluster */
973:                 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
9D000B08  2413FFFF   ADDIU S3, ZERO, -1
9D000B0C  24140001   ADDIU S4, ZERO, 1
9D000B40  10530028   BEQ V0, S3, 0x9D000BE4
9D000B44  8FBF002C   LW RA, 44(SP)
9D000B48  50540027   BEQL V0, S4, 0x9D000BE8
9D000B4C  8FB60028   LW S6, 40(SP)
974:                 			return cs;
975:                 		if (ncl == scl)
9D000B50  1612FFF0   BNE S0, S2, 0x9D000B14
9D000B54  26100001   ADDIU S0, S0, 1
976:                 			return 0; /* No free cluster */
9D000B58  0B4002F8   J 0x9D000BE0
9D000B5C  00001021   ADDU V0, ZERO, ZERO
977:                 	}
978:                 
979:                 	res = put_fat(fs, ncl, 0x0FFFFFFF); /* Mark the new cluster "last link" */
9D000B60  02202021   ADDU A0, S1, ZERO
9D000B64  02002821   ADDU A1, S0, ZERO
9D000B68  3C060FFF   LUI A2, 4095
9D000B6C  0F400232   JAL put_fat
9D000B70  34C6FFFF   ORI A2, A2, -1
980:                 	if (res == FR_OK && clst != 0) {
9D000B74  54400014   BNEL V0, ZERO, 0x9D000BC8
9D000B78  38420001   XORI V0, V0, 1
9D000B7C  52C00008   BEQL S6, ZERO, 0x9D000BA0
9D000B80  AE32000C   SW S2, 12(S1)
981:                 		res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
9D000B84  02202021   ADDU A0, S1, ZERO
9D000B88  02C02821   ADDU A1, S6, ZERO
9D000B8C  0F400232   JAL put_fat
9D000B90  02003021   ADDU A2, S0, ZERO
982:                 	}
983:                 	if (res == FR_OK) {
9D000B94  5440000C   BNEL V0, ZERO, 0x9D000BC8
9D000B98  38420001   XORI V0, V0, 1
984:                 		fs->last_clust = ncl; /* Update FSINFO */
9D000B9C  AE32000C   SW S2, 12(S1)
985:                 		if (fs->free_clust != 0xFFFFFFFF) {
9D000BA0  8E230010   LW V1, 16(S1)
9D000BA4  2404FFFF   ADDIU A0, ZERO, -1
9D000BA8  1064000D   BEQ V1, A0, 0x9D000BE0
9D000BAC  02001021   ADDU V0, S0, ZERO
986:                 			fs->free_clust--;
9D000BB0  2463FFFF   ADDIU V1, V1, -1
9D000BB4  AE230010   SW V1, 16(S1)
987:                 			fs->fsi_flag = 1;
9D000BB8  24020001   ADDIU V0, ZERO, 1
9D000BBC  A2220005   SB V0, 5(S1)
9D000BC0  0B4002F8   J 0x9D000BE0
9D000BC4  02001021   ADDU V0, S0, ZERO
988:                 		}
989:                 	} else {
990:                 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
9D000BC8  2403FFFF   ADDIU V1, ZERO, -1
9D000BCC  24040001   ADDIU A0, ZERO, 1
9D000BD0  0082180B   MOVN V1, A0, V0
9D000BD4  0B4002F8   J 0x9D000BE0
9D000BD8  00601021   ADDU V0, V1, ZERO
9D000BDC  00001021   ADDU V0, ZERO, ZERO
991:                 	}
992:                 
993:                 	return ncl; /* Return new cluster number or error code */
994:                 }
9D000AF8  0B4002F9   J 0x9D000BE4
9D000AFC  8FBF002C   LW RA, 44(SP)
9D000BE0  8FBF002C   LW RA, 44(SP)
9D000BE4  8FB60028   LW S6, 40(SP)
9D000BE8  8FB50024   LW S5, 36(SP)
9D000BEC  8FB40020   LW S4, 32(SP)
9D000BF0  8FB3001C   LW S3, 28(SP)
9D000BF4  8FB20018   LW S2, 24(SP)
9D000BF8  8FB10014   LW S1, 20(SP)
9D000BFC  8FB00010   LW S0, 16(SP)
9D000C00  03E00008   JR RA
9D000C04  27BD0030   ADDIU SP, SP, 48
995:                 #endif /* !_FS_READONLY */
996:                 
997:                 /*-----------------------------------------------------------------------*/
998:                 /* FAT handling - Convert offset into cluster with link map table        */
999:                 /*-----------------------------------------------------------------------*/
1000:                
1001:                #if _USE_FASTSEEK
1002:                static DWORD clmt_clust( /* <2:Error, >=2:Cluster number */
1003:                FIL* fp, /* Pointer to the file object */
1004:                DWORD ofs /* File offset to be converted to cluster# */
1005:                ) {
1006:                	DWORD cl, ncl, *tbl;
1007:                
1008:                	tbl = fp->cltbl + 1; /* Top of CLMT */
9D00006C  8C820024   LW V0, 36(A0)
9D000070  24470004   ADDIU A3, V0, 4
1009:                	cl = ofs / SS(fp->fs) / fp->fs->csize; /* Cluster order from top of the file */
9D000074  8C860000   LW A2, 0(A0)
9D000078  90C30002   LBU V1, 2(A2)
9D000088  00052A42   SRL A1, A1, 9
9D00008C  00A3001B   DIVU A1, V1
9D000090  006001F4   TEQ V1, ZERO
9D000094  00001812   MFLO V1, 0
9D000098  00001012   MFLO V0, 0
1010:                	for (;;) {
1011:                		ncl = *tbl++; /* Number of cluters in the fragment */
9D00007C  8C460004   LW A2, 4(V0)
9D0000B0  00603021   ADDU A2, V1, ZERO
9D0000C0  8C830004   LW V1, 4(A0)
1012:                		if (!ncl)
9D000080  10C00017   BEQ A2, ZERO, 0x9D0000E0
9D000084  00001021   ADDU V0, ZERO, ZERO
9D0000C4  5460FFFA   BNEL V1, ZERO, 0x9D0000B0
9D0000C8  00461023   SUBU V0, V0, A2
1013:                			return 0; /* End of table? (error) */
9D0000CC  03E00008   JR RA
9D0000D0  00001021   ADDU V0, ZERO, ZERO
1014:                		if (cl < ncl)
9D00009C  0066182B   SLTU V1, V1, A2
9D0000A0  10600007   BEQ V1, ZERO, 0x9D0000C0
9D0000A4  24E40004   ADDIU A0, A3, 4
9D0000B4  0043182B   SLTU V1, V0, V1
9D0000B8  14600006   BNE V1, ZERO, 0x9D0000D4
9D0000BC  24840008   ADDIU A0, A0, 8
1015:                			break; /* In this fragment? */
1016:                		cl -= ncl;
1017:                		tbl++; /* Next fragment */
1018:                	}
1019:                	return cl + *tbl; /* Return the cluster number */
9D0000A8  0B400036   J 0x9D0000D8
9D0000AC  8C830000   LW V1, 0(A0)
9D0000D4  8C830000   LW V1, 0(A0)
9D0000D8  03E00008   JR RA
9D0000DC  00431021   ADDU V0, V0, V1
1020:                }
9D0000E0  03E00008   JR RA
9D0000E4  00000000   NOP
1021:                #endif	/* _USE_FASTSEEK */
1022:                
1023:                /*-----------------------------------------------------------------------*/
1024:                /* Directory handling - Set directory index                              */
1025:                /*-----------------------------------------------------------------------*/
1026:                
1027:                static FRESULT dir_sdi(DIR *dj, /* Pointer to directory object */
9D0007B4  3294FFFF   ANDI S4, S4, -1
9D0007B8  02328823   SUBU S1, S1, S2
9D0007BC  3231FFFF   ANDI S1, S1, -1
9D0007C0  2413FFFF   ADDIU S3, ZERO, -1
1028:                PF_WORD idx /* Directory index number */
1029:                ) {
9D00070C  27BDFFD8   ADDIU SP, SP, -40
9D000710  AFBF0024   SW RA, 36(SP)
9D000714  AFB40020   SW S4, 32(SP)
9D000718  AFB3001C   SW S3, 28(SP)
9D00071C  AFB20018   SW S2, 24(SP)
9D000720  AFB10014   SW S1, 20(SP)
9D000724  AFB00010   SW S0, 16(SP)
9D000728  00808021   ADDU S0, A0, ZERO
9D00072C  00A08821   ADDU S1, A1, ZERO
1030:                	DWORD clst;
1031:                	PF_WORD ic;
1032:                
1033:                	dj->index = idx;
9D000730  A4850006   SH A1, 6(A0)
1034:                	clst = dj->sclust;
9D000734  8C850008   LW A1, 8(A0)
1035:                	if (clst == 1 || clst >= dj->fs->n_fatent) /* Check start cluster range */
9D000738  24030001   ADDIU V1, ZERO, 1
9D00073C  10A30044   BEQ A1, V1, 0x9D000850
9D000740  24020002   ADDIU V0, ZERO, 2
9D000744  8C830000   LW V1, 0(A0)
9D000748  8C640018   LW A0, 24(V1)
9D00074C  00A4202B   SLTU A0, A1, A0
9D000750  50800040   BEQL A0, ZERO, 0x9D000854
9D000754  8FBF0024   LW RA, 36(SP)
1036:                		return FR_INT_ERR;
1037:                	if (!clst && dj->fs->fs_type == FS_FAT32) /* Replace cluster# 0 with root cluster# if in FAT32 */
9D000758  54A00012   BNEL A1, ZERO, 0x9D0007A4
9D00075C  90720002   LBU S2, 2(V1)
9D000760  90640000   LBU A0, 0(V1)
9D000764  24020003   ADDIU V0, ZERO, 3
9D000768  54820005   BNEL A0, V0, 0x9D000780
9D00076C  AE00000C   SW ZERO, 12(S0)
1038:                		clst = dj->fs->dirbase;
9D000770  8C650024   LW A1, 36(V1)
1039:                
1040:                	if (clst == 0) { /* Static table (root-dir in FAT12/16) */
9D000774  54A0000B   BNEL A1, ZERO, 0x9D0007A4
9D000778  90720002   LBU S2, 2(V1)
1041:                		dj->clust = clst;
9D00077C  AE00000C   SW ZERO, 12(S0)
1042:                		if (idx >= dj->fs->n_rootdir) /* Index is out of range */
9D000780  94640008   LHU A0, 8(V1)
9D000784  0224202B   SLTU A0, S1, A0
9D000788  10800031   BEQ A0, ZERO, 0x9D000850
9D00078C  24020002   ADDIU V0, ZERO, 2
1043:                			return FR_INT_ERR;
1044:                		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D000790  7E247900   EXT A0, S1, 4, 16
9D000794  8C620024   LW V0, 36(V1)
9D000798  00821021   ADDU V0, A0, V0
9D00079C  0B400209   J 0x9D000824
9D0007A0  AE020010   SW V0, 16(S0)
1045:                	} else { /* Dynamic table (sub-dirs or root-dir in FAT32) */
1046:                		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize; /* Entries per cluster */
9D0007A4  00129100   SLL S2, S2, 4
1047:                		while (idx >= ic) { /* Follow cluster chain */
9D0007A8  0232102B   SLTU V0, S1, S2
9D0007AC  14400017   BNE V0, ZERO, 0x9D00080C
9D0007B0  0012A023   SUBU S4, ZERO, S2
9D0007F8  00521821   ADDU V1, V0, S2
9D0007FC  3063FFFF   ANDI V1, V1, -1
9D000800  0072182B   SLTU V1, V1, S2
9D000804  5060FFEF   BEQL V1, ZERO, 0x9D0007C4
9D000808  00408821   ADDU S1, V0, ZERO
1048:                			clst = get_fat(dj->fs, clst); /* Get next cluster */
9D0007C4  0F400162   JAL get_fat
9D0007C8  8E040000   LW A0, 0(S0)
1049:                			if (clst == 0xFFFFFFFF)
9D0007CC  1053001D   BEQ V0, S3, 0x9D000844
9D0007D0  00402821   ADDU A1, V0, ZERO
1050:                				return FR_DISK_ERR; /* Disk error */
9D000844  0B400214   J 0x9D000850
9D000848  24020001   ADDIU V0, ZERO, 1
1051:                			if (clst < 2 || clst >= dj->fs->n_fatent) /* Reached to end of table or int error */
9D0007D4  2C420002   SLTIU V0, V0, 2
9D0007D8  1440001D   BNE V0, ZERO, 0x9D000850
9D0007DC  24020002   ADDIU V0, ZERO, 2
9D0007E0  8E020000   LW V0, 0(S0)
9D0007E4  8C420018   LW V0, 24(V0)
9D0007E8  00A2102B   SLTU V0, A1, V0
9D0007EC  10400017   BEQ V0, ZERO, 0x9D00084C
9D0007F0  02341021   ADDU V0, S1, S4
9D0007F4  3042FFFF   ANDI V0, V0, -1
1052:                				return FR_INT_ERR;
9D00084C  24020002   ADDIU V0, ZERO, 2
1053:                			idx -= ic;
1054:                		}
1055:                		dj->clust = clst;
9D00080C  AE05000C   SW A1, 12(S0)
1056:                		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D000810  0F400156   JAL clust2sect
9D000814  8E040000   LW A0, 0(S0)
9D000818  7E237900   EXT V1, S1, 4, 16
9D00081C  00621021   ADDU V0, V1, V0
9D000820  AE020010   SW V0, 16(S0)
1057:                	}
1058:                
1059:                	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR; /* Ptr to the entry in the sector */
9D000824  8E020000   LW V0, 0(S0)
9D000828  24420030   ADDIU V0, V0, 48
9D00082C  3231000F   ANDI S1, S1, 15
9D000830  00118940   SLL S1, S1, 5
9D000834  00518821   ADDU S1, V0, S1
9D000838  AE110014   SW S1, 20(S0)
1060:                
1061:                	return FR_OK; /* Seek succeeded */
9D00083C  0B400214   J 0x9D000850
9D000840  00001021   ADDU V0, ZERO, ZERO
1062:                }
9D000850  8FBF0024   LW RA, 36(SP)
9D000854  8FB40020   LW S4, 32(SP)
9D000858  8FB3001C   LW S3, 28(SP)
9D00085C  8FB20018   LW S2, 24(SP)
9D000860  8FB10014   LW S1, 20(SP)
9D000864  8FB00010   LW S0, 16(SP)
9D000868  03E00008   JR RA
9D00086C  27BD0028   ADDIU SP, SP, 40
1063:                
1064:                /*-----------------------------------------------------------------------*/
1065:                /* Directory handling - Move directory index next                        */
1066:                /*-----------------------------------------------------------------------*/
1067:                
1068:                static FRESULT dir_next( /* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
1069:                DIR *dj, /* Pointer to directory object */
1070:                int stretch /* 0: Do not stretch table, 1: Stretch table if needed */
1071:                ) {
9D000C08  27BDFFD8   ADDIU SP, SP, -40
9D000C0C  AFBF0024   SW RA, 36(SP)
9D000C10  AFB40020   SW S4, 32(SP)
9D000C14  AFB3001C   SW S3, 28(SP)
9D000C18  AFB20018   SW S2, 24(SP)
9D000C1C  AFB10014   SW S1, 20(SP)
9D000C20  AFB00010   SW S0, 16(SP)
9D000C24  00808821   ADDU S1, A0, ZERO
9D000C28  00A08021   ADDU S0, A1, ZERO
1072:                	DWORD clst;
1073:                	PF_WORD i;
1074:                
1075:                	stretch = stretch; /* To suppress warning on read-only cfg. */
1076:                	i = dj->index + 1;
9D000C2C  94920006   LHU S2, 6(A0)
9D000C30  26520001   ADDIU S2, S2, 1
9D000C34  3252FFFF   ANDI S2, S2, -1
1077:                	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
9D000C38  1240006C   BEQ S2, ZERO, 0x9D000DEC
9D000C3C  24030004   ADDIU V1, ZERO, 4
9D000C40  8C820010   LW V0, 16(A0)
9D000C44  5040006A   BEQL V0, ZERO, 0x9D000DF0
9D000C48  00601021   ADDU V0, V1, ZERO
1078:                		return FR_NO_FILE;
1079:                
1080:                	if (!(i % (SS(dj->fs) / SZ_DIR))) { /* Sector changed? */
9D000C4C  3243000F   ANDI V1, S2, 15
9D000C50  5460005D   BNEL V1, ZERO, 0x9D000DC8
9D000C54  A6320006   SH S2, 6(S1)
1081:                		dj->sect++; /* Next sector */
9D000C58  24420001   ADDIU V0, V0, 1
9D000C5C  AC820010   SW V0, 16(A0)
1082:                
1083:                		if (dj->clust == 0) { /* Static table */
9D000C60  8C85000C   LW A1, 12(A0)
9D000C64  54A00008   BNEL A1, ZERO, 0x9D000C88
9D000C68  8C840000   LW A0, 0(A0)
1084:                			if (i >= dj->fs->n_rootdir) /* Report EOT when end of table */
9D000C6C  8C820000   LW V0, 0(A0)
9D000C70  94420008   LHU V0, 8(V0)
9D000C74  0242102B   SLTU V0, S2, V0
9D000C78  14400052   BNE V0, ZERO, 0x9D000DC4
9D000C7C  24030004   ADDIU V1, ZERO, 4
1085:                				return FR_NO_FILE;
1086:                		} else { /* Dynamic table */
1087:                			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) { /* Cluster changed? */
9D000C88  90820002   LBU V0, 2(A0)
9D000C8C  2442FFFF   ADDIU V0, V0, -1
9D000C90  00121902   SRL V1, S2, 4
9D000C94  00431024   AND V0, V0, V1
9D000C98  5440004B   BNEL V0, ZERO, 0x9D000DC8
9D000C9C  A6320006   SH S2, 6(S1)
1088:                				clst = get_fat(dj->fs, dj->clust); /* Get next cluster */
9D000CA0  0F400162   JAL get_fat
9D000CA4  00000000   NOP
9D000CA8  00409821   ADDU S3, V0, ZERO
1089:                				if (clst <= 1)
9D000CAC  2C420002   SLTIU V0, V0, 2
9D000CB0  1440004E   BNE V0, ZERO, 0x9D000DEC
9D000CB4  24030002   ADDIU V1, ZERO, 2
1090:                					return FR_INT_ERR;
1091:                				if (clst == 0xFFFFFFFF)
9D000CB8  2402FFFF   ADDIU V0, ZERO, -1
9D000CBC  1262004B   BEQ S3, V0, 0x9D000DEC
9D000CC0  24030001   ADDIU V1, ZERO, 1
1092:                					return FR_DISK_ERR;
1093:                				if (clst >= dj->fs->n_fatent) { /* When it reached end of dynamic table */
9D000CC4  8E240000   LW A0, 0(S1)
9D000CC8  8C820018   LW V0, 24(A0)
9D000CCC  0262102B   SLTU V0, S3, V0
9D000CD0  54400038   BNEL V0, ZERO, 0x9D000DB4
9D000CD4  AE33000C   SW S3, 12(S1)
1094:                #if !_FS_READONLY
1095:                					PF_BYTE c;
1096:                					if (!stretch)
9D000CD8  12000044   BEQ S0, ZERO, 0x9D000DEC
9D000CDC  24030004   ADDIU V1, ZERO, 4
1097:                						return FR_NO_FILE; /* When do not stretch, report EOT */
1098:                					clst = create_chain(dj->fs, dj->clust); /* Stretch cluster chain */
9D000CE0  0F4002A1   JAL 0x9D000A84
9D000CE4  8E25000C   LW A1, 12(S1)
9D000CE8  00409821   ADDU S3, V0, ZERO
1099:                					if (clst == 0)
9D000CEC  1040003F   BEQ V0, ZERO, 0x9D000DEC
9D000CF0  24030007   ADDIU V1, ZERO, 7
1100:                						return FR_DENIED; /* No free cluster */
1101:                					if (clst == 1)
9D000CF4  24020001   ADDIU V0, ZERO, 1
9D000CF8  1262003C   BEQ S3, V0, 0x9D000DEC
9D000CFC  24030002   ADDIU V1, ZERO, 2
1102:                						return FR_INT_ERR;
1103:                					if (clst == 0xFFFFFFFF)
9D000D00  2402FFFF   ADDIU V0, ZERO, -1
9D000D04  12620039   BEQ S3, V0, 0x9D000DEC
9D000D08  24030001   ADDIU V1, ZERO, 1
1104:                						return FR_DISK_ERR;
1105:                					/* Clean-up stretched table */
1106:                					if (move_window(dj->fs, 0))
9D000D0C  8E240000   LW A0, 0(S1)
9D000D10  0F400082   JAL 0x9D000208
9D000D14  00002821   ADDU A1, ZERO, ZERO
9D000D18  14400034   BNE V0, ZERO, 0x9D000DEC
9D000D1C  24030001   ADDIU V1, ZERO, 1
1107:                						return FR_DISK_ERR; /* Flush active window */
1108:                					mem_set(dj->fs->win, 0, SS(dj->fs)); /* Clear window buffer */
9D000D20  8E240000   LW A0, 0(S1)
9D000D24  24840030   ADDIU A0, A0, 48
9D000D28  00002821   ADDU A1, ZERO, ZERO
9D000D2C  0F400012   JAL 0x9D000048
9D000D30  24060200   ADDIU A2, ZERO, 512
1109:                					dj->fs->winsect = clust2sect(dj->fs, clst); /* Cluster start sector */
9D000D34  8E300000   LW S0, 0(S1)
9D000D38  02002021   ADDU A0, S0, ZERO
9D000D3C  0F400156   JAL clust2sect
9D000D40  02602821   ADDU A1, S3, ZERO
9D000D44  AE02002C   SW V0, 44(S0)
1110:                					for (c = 0; c < dj->fs->csize; c++) { /* Fill the new cluster with 0 */
9D000D48  8E220000   LW V0, 0(S1)
9D000D4C  90430002   LBU V1, 2(V0)
9D000D50  10600014   BEQ V1, ZERO, 0x9D000DA4
9D000D54  00008021   ADDU S0, ZERO, ZERO
9D000D84  321000FF   ANDI S0, S0, 255
9D000D88  8E220000   LW V0, 0(S1)
9D000D8C  90430002   LBU V1, 2(V0)
9D000D90  0203182B   SLTU V1, S0, V1
9D000D94  5460FFF2   BNEL V1, ZERO, 0x9D000D60
9D000D98  A0540004   SB S4, 4(V0)
1111:                						dj->fs->wflag = 1;
9D000D58  24140001   ADDIU S4, ZERO, 1
9D000D5C  A0540004   SB S4, 4(V0)
1112:                						if (move_window(dj->fs, 0))
9D000D60  8E240000   LW A0, 0(S1)
9D000D64  0F400082   JAL 0x9D000208
9D000D68  00002821   ADDU A1, ZERO, ZERO
9D000D6C  1440001E   BNE V0, ZERO, 0x9D000DE8
9D000D70  26100001   ADDIU S0, S0, 1
1113:                							return FR_DISK_ERR;
9D000DE8  24030001   ADDIU V1, ZERO, 1
1114:                						dj->fs->winsect++;
9D000D74  8E220000   LW V0, 0(S1)
9D000D78  8C43002C   LW V1, 44(V0)
9D000D7C  24630001   ADDIU V1, V1, 1
9D000D80  AC43002C   SW V1, 44(V0)
1115:                					}
1116:                					dj->fs->winsect -= c; /* Rewind window address */
9D000D9C  0B40036A   J 0x9D000DA8
9D000DA0  8C43002C   LW V1, 44(V0)
9D000DA4  8C43002C   LW V1, 44(V0)
9D000DA8  00708023   SUBU S0, V1, S0
9D000DAC  AC50002C   SW S0, 44(V0)
1117:                #else
1118:                					return FR_NO_FILE; /* Report EOT */
1119:                #endif
1120:                				}
1121:                				dj->clust = clst; /* Initialize data for new cluster */
9D000DB0  AE33000C   SW S3, 12(S1)
1122:                				dj->sect = clust2sect(dj->fs, clst);
9D000DB4  8E240000   LW A0, 0(S1)
9D000DB8  0F400156   JAL clust2sect
9D000DBC  02602821   ADDU A1, S3, ZERO
9D000DC0  AE220010   SW V0, 16(S1)
1123:                			}
1124:                		}
1125:                	}
1126:                
1127:                	dj->index = i;
9D000DC4  A6320006   SH S2, 6(S1)
1128:                	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
9D000DC8  8E220000   LW V0, 0(S1)
9D000DCC  24420030   ADDIU V0, V0, 48
9D000DD0  3252000F   ANDI S2, S2, 15
9D000DD4  00129140   SLL S2, S2, 5
9D000DD8  00529021   ADDU S2, V0, S2
9D000DDC  AE320014   SW S2, 20(S1)
1129:                
1130:                	return FR_OK;
9D000DE0  0B40037B   J 0x9D000DEC
9D000DE4  00001821   ADDU V1, ZERO, ZERO
1131:                }
9D000C80  0B40037C   J 0x9D000DF0
9D000C84  00601021   ADDU V0, V1, ZERO
9D000DEC  00601021   ADDU V0, V1, ZERO
9D000DF0  8FBF0024   LW RA, 36(SP)
9D000DF4  8FB40020   LW S4, 32(SP)
9D000DF8  8FB3001C   LW S3, 28(SP)
9D000DFC  8FB20018   LW S2, 24(SP)
9D000E00  8FB10014   LW S1, 20(SP)
9D000E04  8FB00010   LW S0, 16(SP)
9D000E08  03E00008   JR RA
9D000E0C  27BD0028   ADDIU SP, SP, 40
1132:                
1133:                /*-----------------------------------------------------------------------*/
1134:                /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
1135:                /*-----------------------------------------------------------------------*/
1136:                #if _USE_LFN
1137:                static
1138:                const PF_BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30}; /* Offset of LFN chars in the directory entry */
1139:                
1140:                static
1141:                int cmp_lfn ( /* 1:Matched, 0:Not matched */
1142:                		WCHAR *lfnbuf, /* Pointer to the LFN to be compared */
1143:                		PF_BYTE *dir /* Pointer to the directory entry containing a part of LFN */
1144:                )
1145:                {
1146:                	UINT i, s;
1147:                	WCHAR wc, uc;
1148:                
1149:                	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13; /* Get offset in the LFN buffer */
1150:                	s = 0; wc = 1;
1151:                	do {
1152:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1153:                		if (wc) { /* Last char has not been processed */
1154:                			wc = ff_wtoupper(uc); /* Convert it to upper case */
1155:                			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++])) /* Compare it */
1156:                			return 0; /* Not matched */
1157:                		} else {
1158:                			if (uc != 0xFFFF) return 0; /* Check filler */
1159:                		}
1160:                	}while (++s < 13); /* Repeat until all chars in the entry are checked */
1161:                
1162:                	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i]) /* Last segment matched but different length */
1163:                	return 0;
1164:                
1165:                	return 1; /* The part of LFN matched */
1166:                }
1167:                
1168:                static
1169:                int pick_lfn ( /* 1:Succeeded, 0:Buffer overflow */
1170:                		WCHAR *lfnbuf, /* Pointer to the Unicode-LFN buffer */
1171:                		PF_BYTE *dir /* Pointer to the directory entry */
1172:                )
1173:                {
1174:                	UINT i, s;
1175:                	WCHAR wc, uc;
1176:                
1177:                	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13; /* Offset in the LFN buffer */
1178:                
1179:                	s = 0; wc = 1;
1180:                	do {
1181:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1182:                		if (wc) { /* Last char has not been processed */
1183:                			if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1184:                			lfnbuf[i++] = wc = uc; /* Store it */
1185:                		} else {
1186:                			if (uc != 0xFFFF) return 0; /* Check filler */
1187:                		}
1188:                	}while (++s < 13); /* Read all character in the entry */
1189:                
1190:                	if (dir[LDIR_Ord] & LLE) { /* Put terminator if it is the last LFN part */
1191:                		if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1192:                		lfnbuf[i] = 0;
1193:                	}
1194:                
1195:                	return 1;
1196:                }
1197:                
1198:                #if !_FS_READONLY
1199:                static
1200:                void fit_lfn (
1201:                		const WCHAR *lfnbuf, /* Pointer to the LFN buffer */
1202:                		PF_BYTE *dir, /* Pointer to the directory entry */
1203:                		PF_BYTE ord, /* LFN order (1-20) */
1204:                		PF_BYTE sum /* SFN sum */
1205:                )
1206:                {
1207:                	UINT i, s;
1208:                	WCHAR wc;
1209:                
1210:                	dir[LDIR_Chksum] = sum; /* Set check sum */
1211:                	dir[LDIR_Attr] = AM_LFN; /* Set attribute. LFN entry */
1212:                	dir[LDIR_Type] = 0;
1213:                	ST_WORD(dir+LDIR_FstClusLO, 0);
1214:                
1215:                	i = (ord - 1) * 13; /* Get offset in the LFN buffer */
1216:                	s = wc = 0;
1217:                	do {
1218:                		if (wc != 0xFFFF) wc = lfnbuf[i++]; /* Get an effective char */
1219:                		ST_WORD(dir+LfnOfs[s], wc); /* Put it */
1220:                		if (!wc) wc = 0xFFFF; /* Padding chars following last char */
1221:                	}while (++s < 13);
1222:                	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE; /* Bottom LFN part is the start of LFN sequence */
1223:                	dir[LDIR_Ord] = ord; /* Set the LFN order */
1224:                }
1225:                
1226:                #endif
1227:                #endif
1228:                
1229:                /*-----------------------------------------------------------------------*/
1230:                /* Create numbered name                                                  */
1231:                /*-----------------------------------------------------------------------*/
1232:                #if _USE_LFN
1233:                void gen_numname (
1234:                		PF_BYTE *dst, /* Pointer to generated SFN */
1235:                		const PF_BYTE *src, /* Pointer to source SFN to be modified */
1236:                		const WCHAR *lfn, /* Pointer to LFN */
1237:                		PF_WORD seq /* Sequence number */
1238:                )
1239:                {
1240:                	PF_BYTE ns[8], c;
1241:                	UINT i, j;
1242:                
1243:                	mem_cpy(dst, src, 11);
1244:                
1245:                	if (seq > 5) { /* On many collisions, generate a hash number instead of sequential number */
1246:                		do seq = (seq >> 1) + (seq << 15) + (PF_WORD)*lfn++; while (*lfn);
1247:                	}
1248:                
1249:                	/* itoa (hexdecimal) */
1250:                	i = 7;
1251:                	do {
1252:                		c = (seq % 16) + '0';
1253:                		if (c > '9') c += 7;
1254:                		ns[i--] = c;
1255:                		seq /= 16;
1256:                	}while (seq);
1257:                	ns[i] = '~';
1258:                
1259:                	/* Append the number */
1260:                	for (j = 0; j < i && dst[j] != ' '; j++) {
1261:                		if (IsDBCS1(dst[j])) {
1262:                			if (j == i - 1) break;
1263:                			j++;
1264:                		}
1265:                	}
1266:                	do {
1267:                		dst[j++] = (i < 8) ? ns[i++] : ' ';
1268:                	}while (j < 8);
1269:                }
1270:                #endif
1271:                
1272:                /*-----------------------------------------------------------------------*/
1273:                /* Calculate sum of an SFN                                               */
1274:                /*-----------------------------------------------------------------------*/
1275:                #if _USE_LFN
1276:                static
1277:                PF_BYTE sum_sfn (
1278:                		const PF_BYTE *dir /* Ptr to directory entry */
1279:                )
1280:                {
1281:                	PF_BYTE sum = 0;
1282:                	UINT n = 11;
1283:                
1284:                	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
1285:                	return sum;
1286:                }
1287:                #endif
1288:                
1289:                /*-----------------------------------------------------------------------*/
1290:                /* Directory handling - Find an object in the directory                  */
1291:                /*-----------------------------------------------------------------------*/
1292:                
1293:                static FRESULT dir_find(DIR *dj /* Pointer to the directory object linked to the file name */
1294:                ) {
1295:                	FRESULT res;
1296:                	PF_BYTE c, *dir;
1297:                #if _USE_LFN
1298:                	PF_BYTE a, ord, sum;
1299:                #endif
1300:                
1301:                	res = dir_sdi(dj, 0); /* Rewind directory object */
9D001074  02402021   ADDU A0, S2, ZERO
9D001078  0F4001C3   JAL 0x9D00070C
9D00107C  00002821   ADDU A1, ZERO, ZERO
1302:                	if (res != FR_OK)
9D001080  5440001F   BNEL V0, ZERO, 0x9D001100
9D001084  8E430018   LW V1, 24(S2)
1303:                		return res;
1304:                
1305:                #if _USE_LFN
1306:                	ord = sum = 0xFF;
1307:                #endif
1308:                	do {
1309:                		res = move_window(dj->fs, dj->sect);
9D001088  8E440000   LW A0, 0(S2)
9D00108C  0F400082   JAL 0x9D000208
9D001090  8E450010   LW A1, 16(S2)
1310:                		if (res != FR_OK)
9D001094  5440001A   BNEL V0, ZERO, 0x9D001100
9D001098  8E430018   LW V1, 24(S2)
1311:                			break;
1312:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D00109C  8E470014   LW A3, 20(S2)
1313:                		c = dir[DIR_Name];
1314:                		if (c == 0) {
9D0010A0  90E30000   LBU V1, 0(A3)
9D0010A4  50600046   BEQL V1, ZERO, 0x9D0011C0
9D0010A8  8E420018   LW V0, 24(S2)
1315:                			res = FR_NO_FILE;
1316:                			break;
1317:                		} /* Reached to end of table */
1318:                #if _USE_LFN	/* LFN configuration */
1319:                		a = dir[DIR_Attr] & AM_MASK;
1320:                		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1321:                			ord = 0xFF;
1322:                		} else {
1323:                			if (a == AM_LFN) { /* An LFN entry is found */
1324:                				if (dj->lfn) {
1325:                					if (c & LLE) { /* Is it start of LFN sequence? */
1326:                						sum = dir[LDIR_Chksum];
1327:                						c &= ~LLE; ord = c; /* LFN start order */
1328:                						dj->lfn_idx = dj->index;
1329:                					}
1330:                					/* Check validity of the LFN entry and compare it with given name */
1331:                					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1332:                				}
1333:                			} else { /* An SFN entry is found */
1334:                				if (!ord && sum == sum_sfn(dir)) break; /* LFN matched? */
1335:                				ord = 0xFF; dj->lfn_idx = 0xFFFF; /* Reset LFN sequence */
1336:                				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break; /* SFN matched? */
1337:                			}
1338:                		}
1339:                #else		/* Non LFN configuration */
1340:                		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
9D0010AC  90E9000B   LBU T1, 11(A3)
9D0010B0  31230008   ANDI V1, T1, 8
9D0010B4  1460000C   BNE V1, ZERO, 0x9D0010E8
9D0010B8  00E01821   ADDU V1, A3, ZERO
9D0010BC  8E4A0018   LW T2, 24(S2)
1341:                			break;
1342:                #endif
1343:                		res = dir_next(dj, 0); /* Next entry */
9D0010E8  02402021   ADDU A0, S2, ZERO
9D0010EC  0F400302   JAL 0x9D000C08
9D0010F0  00002821   ADDU A1, ZERO, ZERO
1344:                	} while (res == FR_OK);
9D0010F4  5040FFE5   BEQL V0, ZERO, 0x9D00108C
9D0010F8  8E440000   LW A0, 0(S2)
1345:                
1346:                	return res;
1347:                }
1348:                
1349:                /*-----------------------------------------------------------------------*/
1350:                /* Read an object from the directory                                     */
1351:                /*-----------------------------------------------------------------------*/
1352:                #if _FS_MINIMIZE <= 1
1353:                static FRESULT dir_read(DIR *dj /* Pointer to the directory object that pointing the entry to be read */
1354:                ) {
9D00129C  27BDFFE0   ADDIU SP, SP, -32
9D0012A0  AFBF001C   SW RA, 28(SP)
9D0012A4  AFB20018   SW S2, 24(SP)
9D0012A8  AFB10014   SW S1, 20(SP)
9D0012AC  AFB00010   SW S0, 16(SP)
9D0012B0  00808021   ADDU S0, A0, ZERO
1355:                	FRESULT res;
1356:                	PF_BYTE c, *dir;
1357:                #if _USE_LFN
1358:                	PF_BYTE a, ord = 0xFF, sum = 0xFF;
1359:                #endif
1360:                
1361:                	res = FR_NO_FILE;
9D0012B4  24020004   ADDIU V0, ZERO, 4
1362:                	while (dj->sect) {
9D0012BC  0B4004C5   J 0x9D001314
9D0012C0  2412002E   ADDIU S2, ZERO, 46
9D001314  8E050010   LW A1, 16(S0)
9D001318  14A0FFEA   BNE A1, ZERO, 0x9D0012C4
9D00131C  00000000   NOP
1363:                		res = move_window(dj->fs, dj->sect);
9D0012C4  0F400082   JAL 0x9D000208
9D0012C8  8E040000   LW A0, 0(S0)
1364:                		if (res != FR_OK)
9D0012CC  54400017   BNEL V0, ZERO, 0x9D00132C
9D0012D0  AE000010   SW ZERO, 16(S0)
1365:                			break;
1366:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D0012D4  8E040014   LW A0, 20(S0)
1367:                		c = dir[DIR_Name];
9D0012D8  90830000   LBU V1, 0(A0)
1368:                		if (c == 0) {
9D0012DC  50600012   BEQL V1, ZERO, 0x9D001328
9D0012E0  24020004   ADDIU V0, ZERO, 4
1369:                			res = FR_NO_FILE;
1370:                			break;
1371:                		} /* Reached to end of table */
1372:                #if _USE_LFN	/* LFN configuration */
1373:                		a = dir[DIR_Attr] & AM_MASK;
1374:                		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1375:                			ord = 0xFF;
1376:                		} else {
1377:                			if (a == AM_LFN) { /* An LFN entry is found */
1378:                				if (c & LLE) { /* Is it start of LFN sequence? */
1379:                					sum = dir[LDIR_Chksum];
1380:                					c &= ~LLE; ord = c;
1381:                					dj->lfn_idx = dj->index;
1382:                				}
1383:                				/* Check LFN validity and capture it */
1384:                				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1385:                			} else { /* An SFN entry is found */
1386:                				if (ord || sum != sum_sfn(dir)) /* Is there a valid LFN? */
1387:                				dj->lfn_idx = 0xFFFF; /* It has no LFN. */
1388:                				break;
1389:                			}
1390:                		}
1391:                #else		/* Non LFN configuration */
1392:                		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL)) /* Is it a valid entry? */
9D0012B8  241100E5   ADDIU S1, ZERO, 229
9D0012E4  50710007   BEQL V1, S1, 0x9D001304
9D0012E8  02002021   ADDU A0, S0, ZERO
9D0012EC  50720005   BEQL V1, S2, 0x9D001304
9D0012F0  02002021   ADDU A0, S0, ZERO
9D0012F4  9083000B   LBU V1, 11(A0)
9D0012F8  30630008   ANDI V1, V1, 8
9D0012FC  1060000B   BEQ V1, ZERO, 0x9D00132C
9D001300  02002021   ADDU A0, S0, ZERO
1393:                			break;
1394:                #endif
1395:                		res = dir_next(dj, 0); /* Next entry */
9D001304  0F400302   JAL 0x9D000C08
9D001308  00002821   ADDU A1, ZERO, ZERO
1396:                		if (res != FR_OK)
9D00130C  54400007   BNEL V0, ZERO, 0x9D00132C
9D001310  AE000010   SW ZERO, 16(S0)
1397:                			break;
1398:                	}
1399:                
1400:                	if (res != FR_OK)
9D001320  10400003   BEQ V0, ZERO, 0x9D001330
9D001324  8FBF001C   LW RA, 28(SP)
1401:                		dj->sect = 0;
9D001328  AE000010   SW ZERO, 16(S0)
1402:                
1403:                	return res;
1404:                }
9D00132C  8FBF001C   LW RA, 28(SP)
9D001330  8FB20018   LW S2, 24(SP)
9D001334  8FB10014   LW S1, 20(SP)
9D001338  8FB00010   LW S0, 16(SP)
9D00133C  03E00008   JR RA
9D001340  27BD0020   ADDIU SP, SP, 32
1405:                #endif
1406:                
1407:                /*-----------------------------------------------------------------------*/
1408:                /* Register an object to the directory                                   */
1409:                /*-----------------------------------------------------------------------*/
1410:                #if !_FS_READONLY
1411:                static FRESULT dir_register( /* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
1412:                DIR *dj /* Target directory with object name to be created */
1413:                ) {
9D0011C8  27BDFFE0   ADDIU SP, SP, -32
9D0011CC  AFBF001C   SW RA, 28(SP)
9D0011D0  AFB20018   SW S2, 24(SP)
9D0011D4  AFB10014   SW S1, 20(SP)
9D0011D8  AFB00010   SW S0, 16(SP)
9D0011DC  00808821   ADDU S1, A0, ZERO
1414:                	FRESULT res;
1415:                	PF_BYTE c, *dir;
1416:                #if _USE_LFN	/* LFN configuration */
1417:                	PF_WORD n, ne, is;
1418:                	PF_BYTE sn[12], *fn, sum;
1419:                	WCHAR *lfn;
1420:                
1421:                	fn = dj->fn; lfn = dj->lfn;
1422:                	mem_cpy(sn, fn, 12);
1423:                
1424:                	if (_FS_RPATH && (sn[NS] & NS_DOT)) /* Cannot create dot entry */
1425:                	return FR_INVALID_NAME;
1426:                
1427:                	if (sn[NS] & NS_LOSS) { /* When LFN is out of 8.3 format, generate a numbered name */
1428:                		fn[NS] = 0; dj->lfn = 0; /* Find only SFN */
1429:                		for (n = 1; n < 100; n++) {
1430:                			gen_numname(fn, sn, lfn, n); /* Generate a numbered name */
1431:                			res = dir_find(dj); /* Check if the name collides with existing SFN */
1432:                			if (res != FR_OK) break;
1433:                		}
1434:                		if (n == 100) return FR_DENIED; /* Abort if too many collisions */
1435:                		if (res != FR_NO_FILE) return res; /* Abort if the result is other than 'not collided' */
1436:                		fn[NS] = sn[NS]; dj->lfn = lfn;
1437:                	}
1438:                
1439:                	if (sn[NS] & NS_LFN) { /* When LFN is to be created, reserve an SFN + LFN entries. */
1440:                		for (ne = 0; lfn[ne]; ne++);
1441:                		ne = (ne + 25) / 13;
1442:                	} else { /* Otherwise reserve only an SFN entry. */
1443:                		ne = 1;
1444:                	}
1445:                
1446:                	/* Reserve contiguous entries */
1447:                	res = dir_sdi(dj, 0);
1448:                	if (res != FR_OK) return res;
1449:                	n = is = 0;
1450:                	do {
1451:                		res = move_window(dj->fs, dj->sect);
1452:                		if (res != FR_OK) break;
1453:                		c = *dj->dir; /* Check the entry status */
1454:                		if (c == DDE || c == 0) { /* Is it a blank entry? */
1455:                			if (n == 0) is = dj->index; /* First index of the contiguous entry */
1456:                			if (++n == ne) break; /* A contiguous entry that required count is found */
1457:                		} else {
1458:                			n = 0; /* Not a blank entry. Restart to search */
1459:                		}
1460:                		res = dir_next(dj, 1); /* Next entry with table stretch */
1461:                	}while (res == FR_OK);
1462:                
1463:                	if (res == FR_OK && ne > 1) { /* Initialize LFN entry if needed */
1464:                		res = dir_sdi(dj, is);
1465:                		if (res == FR_OK) {
1466:                			sum = sum_sfn(dj->fn); /* Sum of the SFN tied to the LFN */
1467:                			ne--;
1468:                			do { /* Store LFN entries in bottom first */
1469:                				res = move_window(dj->fs, dj->sect);
1470:                				if (res != FR_OK) break;
1471:                				fit_lfn(dj->lfn, dj->dir, (PF_BYTE)ne, sum);
1472:                				dj->fs->wflag = 1;
1473:                				res = dir_next(dj, 0); /* Next entry */
1474:                			}while (res == FR_OK && --ne);
1475:                		}
1476:                	}
1477:                
1478:                #else	/* Non LFN configuration */
1479:                	res = dir_sdi(dj, 0);
9D0011E0  0F4001C3   JAL 0x9D00070C
9D0011E4  00002821   ADDU A1, ZERO, ZERO
1480:                	if (res == FR_OK) {
9D0011E8  1440001E   BNE V0, ZERO, 0x9D001264
9D0011EC  00408021   ADDU S0, V0, ZERO
1481:                		do { /* Find a blank entry for the SFN */
1482:                			res = move_window(dj->fs, dj->sect);
9D0011F4  8E240000   LW A0, 0(S1)
9D0011F8  0F400082   JAL 0x9D000208
9D0011FC  8E250010   LW A1, 16(S1)
1483:                			if (res != FR_OK)
9D001200  14400018   BNE V0, ZERO, 0x9D001264
9D001204  00408021   ADDU S0, V0, ZERO
1484:                				break;
1485:                			c = *dj->dir;
9D001208  8E220014   LW V0, 20(S1)
9D00120C  90420000   LBU V0, 0(V0)
1486:                			if (c == DDE || c == 0)
9D0011F0  241200E5   ADDIU S2, ZERO, 229
9D001210  5052001C   BEQL V0, S2, 0x9D001284
9D001214  8E240000   LW A0, 0(S1)
9D001218  10400019   BEQ V0, ZERO, 0x9D001280
9D00121C  02202021   ADDU A0, S1, ZERO
1487:                				break; /* Is it a blank entry? */
1488:                			res = dir_next(dj, 1); /* Next entry with table stretch */
9D001220  0F400302   JAL 0x9D000C08
9D001224  24050001   ADDIU A1, ZERO, 1
1489:                		} while (res == FR_OK);
9D001228  1040FFF2   BEQ V0, ZERO, 0x9D0011F4
9D00122C  00408021   ADDU S0, V0, ZERO
1490:                	}
1491:                #endif
1492:                
1493:                	if (res == FR_OK) { /* Initialize the SFN entry */
1494:                		res = move_window(dj->fs, dj->sect);
9D001280  8E240000   LW A0, 0(S1)
9D001284  0F400082   JAL 0x9D000208
9D001288  8E250010   LW A1, 16(S1)
1495:                		if (res == FR_OK) {
9D00128C  1440FFF5   BNE V0, ZERO, 0x9D001264
9D001290  00408021   ADDU S0, V0, ZERO
1496:                			dir = dj->dir;
9D001294  0B40048E   J 0x9D001238
9D001298  8E320014   LW S2, 20(S1)
1497:                			mem_set(dir, 0, SZ_DIR); /* Clean the entry */
9D001238  02402021   ADDU A0, S2, ZERO
9D00123C  00002821   ADDU A1, ZERO, ZERO
9D001240  0F400012   JAL 0x9D000048
9D001244  24060020   ADDIU A2, ZERO, 32
1498:                			mem_cpy(dir, dj->fn, 11); /* Put SFN */
9D001248  02402021   ADDU A0, S2, ZERO
9D00124C  8E250018   LW A1, 24(S1)
9D001250  0F400008   JAL 0x9D000020
9D001254  2406000B   ADDIU A2, ZERO, 11
1499:                #if _USE_LFN
1500:                			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT); /* Put NT flag */
1501:                #endif
1502:                			dj->fs->wflag = 1;
9D001258  8E220000   LW V0, 0(S1)
9D00125C  24030001   ADDIU V1, ZERO, 1
9D001260  A0430004   SB V1, 4(V0)
1503:                		}
1504:                	}
1505:                
1506:                	return res;
1507:                }
9D001230  0B40049A   J 0x9D001268
9D001234  02001021   ADDU V0, S0, ZERO
9D001264  02001021   ADDU V0, S0, ZERO
9D001268  8FBF001C   LW RA, 28(SP)
9D00126C  8FB20018   LW S2, 24(SP)
9D001270  8FB10014   LW S1, 20(SP)
9D001274  8FB00010   LW S0, 16(SP)
9D001278  03E00008   JR RA
9D00127C  27BD0020   ADDIU SP, SP, 32
1508:                #endif /* !_FS_READONLY */
1509:                
1510:                /*-----------------------------------------------------------------------*/
1511:                /* Remove an object from the directory                                   */
1512:                /*-----------------------------------------------------------------------*/
1513:                #if !_FS_READONLY && !_FS_MINIMIZE
1514:                static FRESULT dir_remove( /* FR_OK: Successful, FR_DISK_ERR: A disk error */
1515:                DIR *dj /* Directory object pointing the entry to be removed */
1516:                ) {
9D000870  27BDFFE8   ADDIU SP, SP, -24
9D000874  AFBF0014   SW RA, 20(SP)
9D000878  AFB00010   SW S0, 16(SP)
9D00087C  00808021   ADDU S0, A0, ZERO
1517:                	FRESULT res;
1518:                #if _USE_LFN	/* LFN configuration */
1519:                	PF_WORD i;
1520:                
1521:                	i = dj->index; /* SFN index */
1522:                	res = dir_sdi(dj, (PF_WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx)); /* Goto the SFN or top of the LFN entries */
1523:                	if (res == FR_OK) {
1524:                		do {
1525:                			res = move_window(dj->fs, dj->sect);
1526:                			if (res != FR_OK) break;
1527:                			*dj->dir = DDE; /* Mark the entry "deleted" */
1528:                			dj->fs->wflag = 1;
1529:                			if (dj->index >= i) break; /* When reached SFN, all entries of the object has been deleted. */
1530:                			res = dir_next(dj, 0); /* Next entry */
1531:                		}while (res == FR_OK);
1532:                		if (res == FR_NO_FILE) res = FR_INT_ERR;
1533:                	}
1534:                
1535:                #else			/* Non LFN configuration */
1536:                	res = dir_sdi(dj, dj->index);
9D000880  0F4001C3   JAL 0x9D00070C
9D000884  94850006   LHU A1, 6(A0)
1537:                	if (res == FR_OK) {
9D000888  1440000C   BNE V0, ZERO, 0x9D0008BC
9D00088C  8FBF0014   LW RA, 20(SP)
1538:                		res = move_window(dj->fs, dj->sect);
9D000890  8E040000   LW A0, 0(S0)
9D000894  0F400082   JAL 0x9D000208
9D000898  8E050010   LW A1, 16(S0)
1539:                		if (res == FR_OK) {
9D00089C  14400006   BNE V0, ZERO, 0x9D0008B8
9D0008A0  2404FFE5   ADDIU A0, ZERO, -27
1540:                			*dj->dir = DDE; /* Mark the entry "deleted" */
9D0008A4  8E030014   LW V1, 20(S0)
9D0008A8  A0640000   SB A0, 0(V1)
1541:                			dj->fs->wflag = 1;
9D0008AC  8E030000   LW V1, 0(S0)
9D0008B0  24040001   ADDIU A0, ZERO, 1
9D0008B4  A0640004   SB A0, 4(V1)
1542:                		}
1543:                	}
1544:                #endif
1545:                
1546:                	return res;
1547:                }
9D0008B8  8FBF0014   LW RA, 20(SP)
9D0008BC  8FB00010   LW S0, 16(SP)
9D0008C0  03E00008   JR RA
9D0008C4  27BD0018   ADDIU SP, SP, 24
1548:                #endif /* !_FS_READONLY */
1549:                
1550:                /*-----------------------------------------------------------------------*/
1551:                /* Pick a segment and create the object name in directory form           */
1552:                /*-----------------------------------------------------------------------*/
1553:                
1554:                static FRESULT create_name(DIR *dj, /* Pointer to the directory object */
1555:                const TCHAR **path /* Pointer to pointer to the segment in the path string */
1556:                ) {
1557:                #ifdef _EXCVT
1558:                	static const PF_BYTE excvt[] = _EXCVT; /* Upper conversion table for extended chars */
1559:                #endif
1560:                
1561:                #if _USE_LFN	/* LFN configuration */
1562:                	PF_BYTE b, cf;
1563:                	WCHAR w, *lfn;
1564:                	UINT i, ni, si, di;
1565:                	const TCHAR *p;
1566:                
1567:                	/* Create LFN in Unicode */
1568:                	for (p = *path; *p == '/' || *p == '\\'; p++); /* Strip duplicated separator */
1569:                	lfn = dj->lfn;
1570:                	si = di = 0;
1571:                	for (;;) {
1572:                		w = p[si++]; /* Get a character */
1573:                		if (w < ' ' || w == '/' || w == '\\') break; /* Break on end of segment */
1574:                		if (di >= _MAX_LFN) /* Reject too long name */
1575:                		return FR_INVALID_NAME;
1576:                #if !_LFN_UNICODE
1577:                		w &= 0xFF;
1578:                		if (IsDBCS1(w)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1579:                			b = (PF_BYTE)p[si++]; /* Get 2nd byte */
1580:                			if (!IsDBCS2(b))
1581:                			return FR_INVALID_NAME; /* Reject invalid sequence */
1582:                			w = (w << 8) + b; /* Create a DBC */
1583:                		}
1584:                		w = ff_convert(w, 1); /* Convert ANSI/OEM to Unicode */
1585:                		if (!w) return FR_INVALID_NAME; /* Reject invalid code */
1586:                #endif
1587:                		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
1588:                		return FR_INVALID_NAME;
1589:                		lfn[di++] = w; /* Store the Unicode char */
1590:                	}
1591:                	*path = &p[si]; /* Return pointer to the next segment */
1592:                	cf = (w < ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
1593:                #if _FS_RPATH
1594:                	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
1595:                			(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
1596:                		lfn[di] = 0;
1597:                		for (i = 0; i < 11; i++)
1598:                		dj->fn[i] = (i < di) ? '.' : ' ';
1599:                		dj->fn[i] = cf | NS_DOT; /* This is a dot entry */
1600:                		return FR_OK;
1601:                	}
1602:                #endif
1603:                	while (di) { /* Strip trailing spaces and dots */
1604:                		w = lfn[di-1];
1605:                		if (w != ' ' && w != '.') break;
1606:                		di--;
1607:                	}
1608:                	if (!di) return FR_INVALID_NAME; /* Reject nul string */
1609:                
1610:                	lfn[di] = 0; /* LFN is created */
1611:                
1612:                	/* Create SFN in directory form */
1613:                	mem_set(dj->fn, ' ', 11);
1614:                	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++); /* Strip leading spaces and dots */
1615:                	if (si) cf |= NS_LOSS | NS_LFN;
1616:                	while (di && lfn[di - 1] != '.') di--; /* Find extension (di<=si: no extension) */
1617:                
1618:                	b = i = 0; ni = 8;
1619:                	for (;;) {
1620:                		w = lfn[si++]; /* Get an LFN char */
1621:                		if (!w) break; /* Break on end of the LFN */
1622:                		if (w == ' ' || (w == '.' && si != di)) { /* Remove spaces and dots */
1623:                			cf |= NS_LOSS | NS_LFN; continue;
1624:                		}
1625:                
1626:                		if (i >= ni || si == di) { /* Extension or end of SFN */
1627:                			if (ni == 11) { /* Long extension */
1628:                				cf |= NS_LOSS | NS_LFN; break;
1629:                			}
1630:                			if (si != di) cf |= NS_LOSS | NS_LFN; /* Out of 8.3 format */
1631:                			if (si > di) break; /* No extension */
1632:                			si = di; i = 8; ni = 11; /* Enter extension section */
1633:                			b <<= 2; continue;
1634:                		}
1635:                
1636:                		if (w >= 0x80) { /* Non ASCII char */
1637:                #ifdef _EXCVT
1638:                			w = ff_convert(w, 0); /* Unicode -> OEM code */
1639:                			if (w) w = excvt[w - 0x80]; /* Convert extended char to upper (SBCS) */
1640:                #else
1641:                			w = ff_convert(ff_wtoupper(w), 0); /* Upper converted Unicode -> OEM code */
1642:                #endif
1643:                			cf |= NS_LFN; /* Force create LFN entry */
1644:                		}
1645:                
1646:                		if (_DF1S && w >= 0x100) { /* Double byte char (always false on SBCS cfg) */
1647:                			if (i >= ni - 1) {
1648:                				cf |= NS_LOSS | NS_LFN; i = ni; continue;
1649:                			}
1650:                			dj->fn[i++] = (PF_BYTE)(w >> 8);
1651:                		} else { /* Single byte char */
1652:                			if (!w || chk_chr("+,;=[]", w)) { /* Replace illegal chars for SFN */
1653:                				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
1654:                			} else {
1655:                				if (IsUpper(w)) { /* ASCII large capital */
1656:                					b |= 2;
1657:                				} else {
1658:                					if (IsLower(w)) { /* ASCII small capital */
1659:                						b |= 1; w -= 0x20;
1660:                					}
1661:                				}
1662:                			}
1663:                		}
1664:                		dj->fn[i++] = (PF_BYTE)w;
1665:                	}
1666:                
1667:                	if (dj->fn[0] == DDE) dj->fn[0] = NDDE; /* If the first char collides with deleted mark, replace it with 0x05 */
1668:                
1669:                	if (ni == 8) b <<= 2;
1670:                	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) /* Create LFN entry when there are composite capitals */
1671:                	cf |= NS_LFN;
1672:                	if (!(cf & NS_LFN)) { /* When LFN is in 8.3 format without extended char, NT flags are created */
1673:                		if ((b & 0x03) == 0x01) cf |= NS_EXT; /* NT flag (Extension has only small capital) */
1674:                		if ((b & 0x0C) == 0x04) cf |= NS_BODY; /* NT flag (Filename has only small capital) */
1675:                	}
1676:                
1677:                	dj->fn[NS] = cf; /* SFN is created */
1678:                
1679:                	return FR_OK;
1680:                
1681:                #else	/* Non-LFN configuration */
1682:                	PF_BYTE b, c, d, *sfn;
1683:                	UINT ni, si, i;
1684:                	const char *p;
1685:                
1686:                	/* Create file name in directory form */
1687:                	for (p = *path; *p == '/' || *p == '\\'; p++)
9D000E84  2413005C   ADDIU S3, ZERO, 92
9D000E94  82020000   LB V0, 0(S0)
9D000E98  5051FFFE   BEQL V0, S1, 0x9D000E94
9D000E9C  26100001   ADDIU S0, S0, 1
9D000EA0  5053FFFC   BEQL V0, S3, 0x9D000E94
9D000EA4  26100001   ADDIU S0, S0, 1
1688:                		; /* Strip duplicated separator */
1689:                	sfn = dj->fn;
9D000EA8  8E550018   LW S5, 24(S2)
1690:                	mem_set(sfn, ' ', 11);
9D000EAC  02A02021   ADDU A0, S5, ZERO
9D000EB0  24050020   ADDIU A1, ZERO, 32
9D000EB4  0F400012   JAL 0x9D000048
9D000EB8  2406000B   ADDIU A2, ZERO, 11
1691:                	si = i = b = 0;
9D000EBC  00003021   ADDU A2, ZERO, ZERO
9D000EC0  00001821   ADDU V1, ZERO, ZERO
9D000EC8  00004021   ADDU T0, ZERO, ZERO
1692:                	ni = 8;
9D000EC4  24040008   ADDIU A0, ZERO, 8
1693:                #if _FS_RPATH
1694:                	if (p[si] == '.') { /* Is this a dot entry? */
1695:                		for (;;) {
1696:                			c = (PF_BYTE)p[si++];
1697:                			if (c != '.' || si >= 3) break;
1698:                			sfn[i++] = c;
1699:                		}
1700:                		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
1701:                		*path = &p[si]; /* Return pointer to the next segment */
1702:                		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT; /* Set last segment flag if end of path */
1703:                		return FR_OK;
1704:                	}
1705:                #endif
1706:                	for (;;) {
1707:                		c = (PF_BYTE) p[si++];
9D000ED0  02031021   ADDU V0, S0, V1
9D000ED4  80450000   LB A1, 0(V0)
9D000ED8  30A200FF   ANDI V0, A1, 255
1708:                		if (c <= ' ' || c == '/' || c == '\\')
9D000EDC  2C470021   SLTIU A3, V0, 33
9D000EE0  14E0004C   BNE A3, ZERO, 0x9D001014
9D000EE4  24630001   ADDIU V1, V1, 1
9D000EE8  505100AE   BEQL V0, S1, 0x9D0011A4
9D000EEC  02038021   ADDU S0, S0, V1
9D000EF0  505300AC   BEQL V0, S3, 0x9D0011A4
9D000EF4  02038021   ADDU S0, S0, V1
1709:                			break; /* Break on end of segment */
1710:                		if (c == '.' || i >= ni) {
9D000E88  2414002E   ADDIU S4, ZERO, 46
9D000EF8  10540003   BEQ V0, S4, 0x9D000F08
9D000EFC  00C4382B   SLTU A3, A2, A0
9D000F00  14E0000A   BNE A3, ZERO, 0x9D000F2C
9D000F04  35070003   ORI A3, T0, 3
1711:                			if (ni != 8 || c != '.')
9D000ECC  24090008   ADDIU T1, ZERO, 8
9D000F08  5489009B   BNEL A0, T1, 0x9D001178
9D000F0C  24020006   ADDIU V0, ZERO, 6
9D000F10  14540099   BNE V0, S4, 0x9D001178
9D000F14  24020006   ADDIU V0, ZERO, 6
1712:                				return FR_INVALID_NAME;
1713:                			i = 8;
9D000F20  01203021   ADDU A2, T1, ZERO
1714:                			ni = 11;
9D000F24  0B4003B4   J 0x9D000ED0
9D000F28  2404000B   ADDIU A0, ZERO, 11
1715:                			b <<= 2;
9D000F18  00084080   SLL T0, T0, 2
9D000F1C  310800FF   ANDI T0, T0, 255
1716:                			continue;
1717:                		}
1718:                		if (c >= 0x80) { /* Extended char? */
1719:                			b |= 3; /* Eliminate NT flag */
9D000F2C  28A50000   SLTI A1, A1, 0
9D000F30  00E5400B   MOVN T0, A3, A1
1720:                #ifdef _EXCVT
1721:                			c = excvt[c-0x80]; /* Upper conversion (SBCS) */
1722:                #else
1723:                #if !_DF1S	/* ASCII only cfg */
1724:                			return FR_INVALID_NAME;
1725:                #endif
1726:                #endif
1727:                		}
1728:                		if (IsDBCS1(c)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
9D000F34  2445007F   ADDIU A1, V0, 127
9D000F38  30A500FF   ANDI A1, A1, 255
9D000F3C  2CA5001F   SLTIU A1, A1, 31
9D000F40  14A00006   BNE A1, ZERO, 0x9D000F5C
9D000F44  02032821   ADDU A1, S0, V1
9D000F48  24450020   ADDIU A1, V0, 32
9D000F4C  30A500FF   ANDI A1, A1, 255
9D000F50  2CA5001D   SLTIU A1, A1, 29
9D000F54  10A00013   BEQ A1, ZERO, 0x9D000FA4
9D000F58  02032821   ADDU A1, S0, V1
1729:                			d = (PF_BYTE) p[si++]; /* Get 2nd byte */
9D000F5C  90A50000   LBU A1, 0(A1)
1730:                			if (!IsDBCS2(d) || i >= ni - 1) /* Reject invalid DBC */
9D000F60  24A7FFC0   ADDIU A3, A1, -64
9D000F64  30E700FF   ANDI A3, A3, 255
9D000F68  2CE7003F   SLTIU A3, A3, 63
9D000F6C  14E00005   BNE A3, ZERO, 0x9D000F84
9D000F70  2487FFFF   ADDIU A3, A0, -1
9D000F74  38A70080   XORI A3, A1, 128
9D000F78  2CE7007D   SLTIU A3, A3, 125
9D000F7C  10E00077   BEQ A3, ZERO, 0x9D00115C
9D000F80  2487FFFF   ADDIU A3, A0, -1
9D000F84  00C7382B   SLTU A3, A2, A3
9D000F88  10E00076   BEQ A3, ZERO, 0x9D001164
9D000F8C  24630001   ADDIU V1, V1, 1
9D00115C  0B40045E   J 0x9D001178
9D001160  24020006   ADDIU V0, ZERO, 6
9D001164  0B40045E   J 0x9D001178
9D001168  24020006   ADDIU V0, ZERO, 6
1731:                				return FR_INVALID_NAME;
1732:                			sfn[i++] = c;
9D000F90  02A63821   ADDU A3, S5, A2
9D000F94  A0E20000   SB V0, 0(A3)
1733:                			sfn[i++] = d;
9D000F98  A0E50001   SB A1, 1(A3)
9D000F9C  0B4003B4   J 0x9D000ED0
9D000FA0  24C60002   ADDIU A2, A2, 2
1734:                		} else { /* Single byte code */
1735:                			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) /* Reject illegal chrs for SFN */
1736:                				return FR_INVALID_NAME;
1737:                			if (IsUpper(c)) { /* ASCII large capital? */
9D000FD0  30A500FF   ANDI A1, A1, 255
9D000FD4  2CA5001A   SLTIU A1, A1, 26
9D000FD8  10A00003   BEQ A1, ZERO, 0x9D000FE8
9D000FDC  2445FF9F   ADDIU A1, V0, -97
1738:                				b |= 2;
9D000FE0  0B400401   J 0x9D001004
9D000FE4  35080002   ORI T0, T0, 2
1739:                			} else {
1740:                				if (IsLower(c)) { /* ASCII small capital? */
9D000FE8  30A500FF   ANDI A1, A1, 255
9D000FEC  2CA5001A   SLTIU A1, A1, 26
9D000FF0  10A00005   BEQ A1, ZERO, 0x9D001008
9D000FF4  02A62821   ADDU A1, S5, A2
1741:                					b |= 1;
9D000FF8  35080001   ORI T0, T0, 1
1742:                					c -= 0x20;
9D000FFC  2442FFE0   ADDIU V0, V0, -32
9D001000  304200FF   ANDI V0, V0, 255
1743:                				}
1744:                			}
1745:                			sfn[i++] = c;
9D001004  02A62821   ADDU A1, S5, A2
9D001008  A0A20000   SB V0, 0(A1)
9D00100C  0B4003B4   J 0x9D000ED0
9D001010  24C60001   ADDIU A2, A2, 1
1746:                		}
1747:                	}
1748:                	*path = &p[si]; /* Return pointer to the next segment */
9D001014  02038021   ADDU S0, S0, V1
1749:                	c = (c <= ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
9D001018  24020004   ADDIU V0, ZERO, 4
9D0011A4  0B400407   J 0x9D00101C
9D0011A8  00001021   ADDU V0, ZERO, ZERO
1750:                
1751:                	if (!i)
9D00101C  10C00055   BEQ A2, ZERO, 0x9D001174
9D001020  240300E5   ADDIU V1, ZERO, 229
1752:                		return FR_INVALID_NAME; /* Reject nul string */
1753:                	if (sfn[0] == DDE)
9D001024  92A50000   LBU A1, 0(S5)
9D001028  14A30004   BNE A1, V1, 0x9D00103C
9D00102C  24030008   ADDIU V1, ZERO, 8
1754:                		sfn[0] = NDDE; /* When first char collides with DDE, replace it with 0x05 */
9D001030  24030005   ADDIU V1, ZERO, 5
9D001034  A2A30000   SB V1, 0(S5)
1755:                
1756:                	if (ni == 8)
9D001038  24030008   ADDIU V1, ZERO, 8
9D00103C  14830004   BNE A0, V1, 0x9D001050
9D001040  01002021   ADDU A0, T0, ZERO
1757:                		b <<= 2;
9D001044  00084080   SLL T0, T0, 2
9D001048  310800FF   ANDI T0, T0, 255
1758:                	if ((b & 0x03) == 0x01)
9D00104C  01002021   ADDU A0, T0, ZERO
9D001050  31080003   ANDI T0, T0, 3
1759:                		c |= NS_EXT; /* NT flag (Name extension has only small capital) */
9D001054  34430010   ORI V1, V0, 16
9D001058  39080001   XORI T0, T0, 1
9D00105C  0068100A   MOVZ V0, V1, T0
1760:                	if ((b & 0x0C) == 0x04)
9D001060  3084000C   ANDI A0, A0, 12
1761:                		c |= NS_BODY; /* NT flag (Name body has only small capital) */
9D001064  34430008   ORI V1, V0, 8
9D001068  38840004   XORI A0, A0, 4
9D00106C  0064100A   MOVZ V0, V1, A0
1762:                
1763:                	sfn[NS] = c; /* Store NT flag, File name is created */
9D001070  A2A2000B   SB V0, 11(S5)
1764:                
1765:                	return FR_OK;
1766:                #endif
1767:                }
1768:                
1769:                /*-----------------------------------------------------------------------*/
1770:                /* Get file information from directory entry                             */
1771:                /*-----------------------------------------------------------------------*/
1772:                #if _FS_MINIMIZE <= 1
1773:                static
1774:                void get_fileinfo( /* No return code */
9D00011C  00C41021   ADDU V0, A2, A0
1775:                DIR *dj, /* Pointer to the directory object */
1776:                FILINFO *fno /* Pointer to the file information to be filled */
1777:                ) {
1778:                	UINT i;
1779:                	PF_BYTE nt, *dir;
1780:                	TCHAR *p, c;
1781:                
1782:                	p = fno->fname;
1783:                	if (dj->sect) {
9D0000E8  8C820010   LW V0, 16(A0)
9D0000EC  10400039   BEQ V0, ZERO, 0x9D0001D4
9D0000F0  24A30009   ADDIU V1, A1, 9
1784:                		dir = dj->dir;
9D0000F4  8C860014   LW A2, 20(A0)
1785:                		nt = dir[DIR_NTres]; /* NT flag */
1786:                		for (i = 0; i < 8; i++) { /* Copy name body */
9D000110  24080008   ADDIU T0, ZERO, 8
9D000138  24840001   ADDIU A0, A0, 1
9D00013C  1488FFF7   BNE A0, T0, 0x9D00011C
9D000140  24630001   ADDIU V1, V1, 1
1787:                			c = dir[i];
9D0000F8  80C20000   LB V0, 0(A2)
9D000120  80420000   LB V0, 0(V0)
1788:                			if (c == ' ')
9D0000FC  24040020   ADDIU A0, ZERO, 32
9D000100  10440010   BEQ V0, A0, 0x9D000144
9D000104  00002021   ADDU A0, ZERO, ZERO
9D000114  0B40004B   J 0x9D00012C
9D000118  240B0020   ADDIU T3, ZERO, 32
9D000124  504B0008   BEQL V0, T3, 0x9D000148
9D000128  90C40008   LBU A0, 8(A2)
1789:                				break;
1790:                			if (c == NDDE)
9D000108  240A0005   ADDIU T2, ZERO, 5
1791:                				c = (TCHAR) DDE;
9D00010C  2409FFE5   ADDIU T1, ZERO, -27
9D00012C  004A3826   XOR A3, V0, T2
9D000130  0127100A   MOVZ V0, T1, A3
1792:                			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c))
1793:                				c += 0x20;
1794:                #if _LFN_UNICODE
1795:                			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
1796:                			c = (c << 8) | dir[++i];
1797:                			c = ff_convert(c, 1);
1798:                			if (!c) c = '?';
1799:                #endif
1800:                			*p++ = c;
9D000134  A0620000   SB V0, 0(V1)
1801:                		}
1802:                		if (dir[8] != ' ') { /* Copy name extension */
9D000144  90C40008   LBU A0, 8(A2)
9D000148  24020020   ADDIU V0, ZERO, 32
9D00014C  1082000A   BEQ A0, V0, 0x9D000178
9D000150  2402002E   ADDIU V0, ZERO, 46
1803:                			*p++ = '.';
9D000154  A0620000   SB V0, 0(V1)
1804:                			for (i = 8; i < 11; i++) {
1805:                				c = dir[i];
9D000158  80C20008   LB V0, 8(A2)
9D0001E0  80C20009   LB V0, 9(A2)
9D0001F4  80C2000A   LB V0, 10(A2)
1806:                				if (c == ' ')
9D00015C  24040020   ADDIU A0, ZERO, 32
9D000160  1444001E   BNE V0, A0, 0x9D0001DC
9D000164  24630001   ADDIU V1, V1, 1
9D0001E4  24040020   ADDIU A0, ZERO, 32
9D0001E8  1044FFE3   BEQ V0, A0, 0x9D000178
9D0001EC  24630001   ADDIU V1, V1, 1
9D0001F8  1444FFDD   BNE V0, A0, 0x9D000170
9D0001FC  24630001   ADDIU V1, V1, 1
1807:                					break;
1808:                				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c))
1809:                					c += 0x20;
1810:                #if _LFN_UNICODE
1811:                				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
1812:                				c = (c << 8) | dir[++i];
1813:                				c = ff_convert(c, 1);
1814:                				if (!c) c = '?';
1815:                #endif
1816:                				*p++ = c;
9D000170  A0620000   SB V0, 0(V1)
9D000174  24630001   ADDIU V1, V1, 1
9D0001DC  A0620000   SB V0, 0(V1)
9D0001F0  A0620000   SB V0, 0(V1)
1817:                			}
1818:                		}
1819:                		fno->fattrib = dir[DIR_Attr]; /* Attribute */
9D000168  0B40005F   J 0x9D00017C
9D00016C  90C2000B   LBU V0, 11(A2)
9D000178  90C2000B   LBU V0, 11(A2)
9D00017C  A0A20008   SB V0, 8(A1)
9D000200  0B40005F   J 0x9D00017C
9D000204  90C2000B   LBU V0, 11(A2)
1820:                		fno->fsize = LD_DWORD(dir+DIR_FileSize); /* Size */
9D000180  90C4001F   LBU A0, 31(A2)
9D000184  00042600   SLL A0, A0, 24
9D000188  90C2001E   LBU V0, 30(A2)
9D00018C  00021400   SLL V0, V0, 16
9D000190  00821025   OR V0, A0, V0
9D000194  90C4001C   LBU A0, 28(A2)
9D000198  00441025   OR V0, V0, A0
9D00019C  90C4001D   LBU A0, 29(A2)
9D0001A0  00042200   SLL A0, A0, 8
9D0001A4  00441025   OR V0, V0, A0
9D0001A8  ACA20000   SW V0, 0(A1)
1821:                		fno->fdate = LD_WORD(dir+DIR_WrtDate); /* Date */
9D0001AC  90C20019   LBU V0, 25(A2)
9D0001B0  00021200   SLL V0, V0, 8
9D0001B4  90C40018   LBU A0, 24(A2)
9D0001B8  00441025   OR V0, V0, A0
9D0001BC  A4A20004   SH V0, 4(A1)
1822:                		fno->ftime = LD_WORD(dir+DIR_WrtTime); /* Time */
9D0001C0  90C20017   LBU V0, 23(A2)
9D0001C4  00021200   SLL V0, V0, 8
9D0001C8  90C40016   LBU A0, 22(A2)
9D0001CC  00441025   OR V0, V0, A0
9D0001D0  A4A20006   SH V0, 6(A1)
1823:                	}
1824:                	*p = 0; /* Terminate SFN str by a \0 */
1825:                
1826:                #if _USE_LFN
1827:                	if (fno->lfname && fno->lfsize) {
1828:                		TCHAR *tp = fno->lfname;
1829:                		WCHAR w, *lfn;
1830:                
1831:                		i = 0;
1832:                		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
1833:                			lfn = dj->lfn;
1834:                			while ((w = *lfn++) != 0) { /* Get an LFN char */
1835:                #if !_LFN_UNICODE
1836:                				w = ff_convert(w, 0); /* Unicode -> OEM conversion */
1837:                				if (!w) {i = 0; break;} /* Could not convert, no LFN */
1838:                				if (_DF1S && w >= 0x100) /* Put 1st byte if it is a DBC (always false on SBCS cfg) */
1839:                				tp[i++] = (TCHAR)(w >> 8);
1840:                #endif
1841:                				if (i >= fno->lfsize - 1) {i = 0; break;} /* Buffer overflow, no LFN */
1842:                				tp[i++] = (TCHAR)w;
1843:                			}
1844:                		}
1845:                		tp[i] = 0; /* Terminate the LFN str by a \0 */
1846:                	}
1847:                #endif
1848:                }
9D0001D4  03E00008   JR RA
9D0001D8  A0600000   SB ZERO, 0(V1)
1849:                #endif /* _FS_MINIMIZE <= 1 */
1850:                
1851:                /*-----------------------------------------------------------------------*/
1852:                /* Follow a file path                                                    */
1853:                /*-----------------------------------------------------------------------*/
1854:                
1855:                static FRESULT follow_path( /* FR_OK(0): successful, !=0: error code */
9D0010C4  0B400435   J 0x9D0010D4
9D0010C8  24E8000B   ADDIU T0, A3, 11
1856:                DIR *dj, /* Directory object to return last directory and found object */
1857:                const TCHAR *path /* Full-path string to find a file or directory */
1858:                ) {
9D000E10  27BDFFC8   ADDIU SP, SP, -56
9D000E14  AFBF0034   SW RA, 52(SP)
9D000E18  AFB70030   SW S7, 48(SP)
9D000E1C  AFB6002C   SW S6, 44(SP)
9D000E20  AFB50028   SW S5, 40(SP)
9D000E24  AFB40024   SW S4, 36(SP)
9D000E28  AFB30020   SW S3, 32(SP)
9D000E2C  AFB2001C   SW S2, 28(SP)
9D000E30  AFB10018   SW S1, 24(SP)
9D000E34  AFB00014   SW S0, 20(SP)
9D000E38  00809021   ADDU S2, A0, ZERO
1859:                	FRESULT res;
1860:                	PF_BYTE *dir, ns;
1861:                
1862:                #if _FS_RPATH
1863:                	if (*path == '/' || *path == '\\') { /* There is a heading separator */
1864:                		path++; dj->sclust = 0; /* Strip it and start from the root dir */
1865:                	} else { /* No heading separator */
1866:                		dj->sclust = dj->fs->cdir; /* Start from the current dir */
1867:                	}
1868:                #else
1869:                	if (*path == '/' || *path == '\\') /* Strip heading separator if exist */
9D000E3C  80A20000   LB V0, 0(A1)
9D000E40  2403002F   ADDIU V1, ZERO, 47
9D000E44  10430004   BEQ V0, V1, 0x9D000E58
9D000E48  00A08021   ADDU S0, A1, ZERO
9D000E4C  2403005C   ADDIU V1, ZERO, 92
9D000E50  54430003   BNEL V0, V1, 0x9D000E60
9D000E54  AE400008   SW ZERO, 8(S2)
1870:                		path++;
9D000E58  26100001   ADDIU S0, S0, 1
1871:                	dj->sclust = 0; /* Start from the root dir */
9D000E5C  AE400008   SW ZERO, 8(S2)
1872:                #endif
1873:                
1874:                	if ((UINT) *path < ' ') { /* Nul path means the start directory itself */
9D000E60  92020000   LBU V0, 0(S0)
9D000E64  2C420020   SLTIU V0, V0, 32
9D000E68  10400006   BEQ V0, ZERO, 0x9D000E84
9D000E6C  2411002F   ADDIU S1, ZERO, 47
1875:                		res = dir_sdi(dj, 0);
9D000E70  02402021   ADDU A0, S2, ZERO
9D000E74  0F4001C3   JAL 0x9D00070C
9D000E78  00002821   ADDU A1, ZERO, ZERO
1876:                		dj->dir = 0;
9D000E7C  0B40045E   J 0x9D001178
9D000E80  AE400014   SW ZERO, 20(S2)
1877:                
1878:                	} else { /* Follow path */
1879:                		for (;;) {
1880:                			res = create_name(dj, &path); /* Get a segment */
1881:                			if (res != FR_OK)
1882:                				break;
1883:                			res = dir_find(dj); /* Find it */
9D001114  24030004   ADDIU V1, ZERO, 4
9D001118  24020005   ADDIU V0, ZERO, 5
9D00111C  0B40045E   J 0x9D001178
9D001120  0064100B   MOVN V0, V1, A0
1884:                			ns = *(dj->fn + NS);
9D0010FC  8E430018   LW V1, 24(S2)
9D001100  9064000B   LBU A0, 11(V1)
9D0011C0  0B400444   J 0x9D001110
9D0011C4  9044000B   LBU A0, 11(V0)
1885:                			if (res != FR_OK) { /* Failed to find the object */
1886:                				if (res != FR_NO_FILE)
9D001104  24030004   ADDIU V1, ZERO, 4
9D001108  1443001C   BNE V0, V1, 0x9D00117C
9D00110C  8FBF0034   LW RA, 52(SP)
1887:                					break; /* Abort if any hard error occured */
1888:                				/* Object not found */
1889:                				if (_FS_RPATH && (ns & NS_DOT)) { /* If dot entry is not exit */
1890:                					dj->sclust = 0;
1891:                					dj->dir = 0; /* It is the root dir */
1892:                					res = FR_OK;
1893:                					if (!(ns & NS_LAST))
1894:                						continue;
1895:                				} else { /* Could not find the object */
1896:                					if (!(ns & NS_LAST))
9D001110  30840004   ANDI A0, A0, 4
1897:                						res = FR_NO_PATH;
1898:                				}
1899:                				break;
1900:                			}
1901:                			if (ns & NS_LAST)
9D0011AC  30630004   ANDI V1, V1, 4
9D0011B0  5060FFDC   BEQL V1, ZERO, 0x9D001124
9D0011B4  31290010   ANDI T1, T1, 16
1902:                				break; /* Last segment match. Function completed. */
1903:                			dir = dj->dir; /* There is next segment. Follow the sub directory */
1904:                			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
9D001124  11200014   BEQ T1, ZERO, 0x9D001178
9D001128  24020005   ADDIU V0, ZERO, 5
1905:                				res = FR_NO_PATH;
1906:                				break;
1907:                			}
1908:                			dj->sclust = LD_CLUST(dir);
9D00112C  90E30015   LBU V1, 21(A3)
9D001130  00031A00   SLL V1, V1, 8
9D001134  90E20014   LBU V0, 20(A3)
9D001138  00621825   OR V1, V1, V0
9D00113C  00031C00   SLL V1, V1, 16
9D001140  90E2001B   LBU V0, 27(A3)
9D001144  00021200   SLL V0, V0, 8
9D001148  90E4001A   LBU A0, 26(A3)
9D00114C  00441025   OR V0, V0, A0
9D001150  00621025   OR V0, V1, V0
9D001154  0B4003A5   J 0x9D000E94
9D001158  AE420008   SW V0, 8(S2)
1909:                		}
1910:                	}
1911:                
1912:                	return res;
1913:                }
9D001178  8FBF0034   LW RA, 52(SP)
9D00117C  8FB70030   LW S7, 48(SP)
9D001180  8FB6002C   LW S6, 44(SP)
9D001184  8FB50028   LW S5, 40(SP)
9D001188  8FB40024   LW S4, 36(SP)
9D00118C  8FB30020   LW S3, 32(SP)
9D001190  8FB2001C   LW S2, 28(SP)
9D001194  8FB10018   LW S1, 24(SP)
9D001198  8FB00014   LW S0, 20(SP)
9D00119C  03E00008   JR RA
9D0011A0  27BD0038   ADDIU SP, SP, 56
9D0011B8  0B40045F   J 0x9D00117C
9D0011BC  8FBF0034   LW RA, 52(SP)
1914:                
1915:                /*-----------------------------------------------------------------------*/
1916:                /* Load a sector and check if it is an FAT Volume Boot Record            */
1917:                /*-----------------------------------------------------------------------*/
1918:                
1919:                static PF_BYTE check_fs( /* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
1920:                FATFS *fs, /* File system object */
1921:                DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
1922:                ) {
9D00030C  27BDFFE8   ADDIU SP, SP, -24
9D000310  AFBF0014   SW RA, 20(SP)
9D000314  AFB00010   SW S0, 16(SP)
9D000318  00808021   ADDU S0, A0, ZERO
9D00031C  00A03021   ADDU A2, A1, ZERO
1923:                	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK) /* Load boot record */
9D000320  90840001   LBU A0, 1(A0)
9D000324  26050030   ADDIU A1, S0, 48
9D000328  0F401B19   JAL disk_read
9D00032C  24070001   ADDIU A3, ZERO, 1
9D000330  14400027   BNE V0, ZERO, 0x9D0003D0
9D000334  24030003   ADDIU V1, ZERO, 3
1924:                		return 3;
9D0003C0  3C02FFAB   LUI V0, -85
9D0003C4  3442BEBA   ORI V0, V0, -16710
9D0003C8  00621821   ADDU V1, V1, V0
9D0003CC  0003182B   SLTU V1, ZERO, V1
1925:                	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55) /* Check record signature (always placed at offset 510 even if the sector size is >512) */
9D000338  9204022F   LBU A0, 559(S0)
9D00033C  00042200   SLL A0, A0, 8
9D000340  9202022E   LBU V0, 558(S0)
9D000344  00822025   OR A0, A0, V0
9D000348  7C042620   SEH A0, A0
9D00034C  2402AA55   ADDIU V0, ZERO, -21931
9D000350  1482001F   BNE A0, V0, 0x9D0003D0
9D000354  24030002   ADDIU V1, ZERO, 2
1926:                		return 2;
1927:                
1928:                	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) /* Check "FAT" string */
9D000358  92040069   LBU A0, 105(S0)
9D00035C  00042600   SLL A0, A0, 24
9D000360  92020068   LBU V0, 104(S0)
9D000364  00021400   SLL V0, V0, 16
9D000368  00822025   OR A0, A0, V0
9D00036C  92020066   LBU V0, 102(S0)
9D000370  00822025   OR A0, A0, V0
9D000374  92020067   LBU V0, 103(S0)
9D000378  00021200   SLL V0, V0, 8
9D00037C  00822025   OR A0, A0, V0
9D000380  7C84B800   EXT A0, A0, 0, 24
9D000384  3C020054   LUI V0, 84
9D000388  24424146   ADDIU V0, V0, 16710
9D00038C  10820010   BEQ A0, V0, 0x9D0003D0
9D000390  00001821   ADDU V1, ZERO, ZERO
1929:                		return 0;
1930:                	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
9D000394  92030085   LBU V1, 133(S0)
9D000398  00031E00   SLL V1, V1, 24
9D00039C  92020084   LBU V0, 132(S0)
9D0003A0  00021400   SLL V0, V0, 16
9D0003A4  00621825   OR V1, V1, V0
9D0003A8  92020082   LBU V0, 130(S0)
9D0003AC  00621825   OR V1, V1, V0
9D0003B0  92020083   LBU V0, 131(S0)
9D0003B4  00021200   SLL V0, V0, 8
9D0003B8  00621825   OR V1, V1, V0
9D0003BC  7C63B800   EXT V1, V1, 0, 24
1931:                		return 0;
1932:                
1933:                	return 1;
1934:                }
9D0003D0  00601021   ADDU V0, V1, ZERO
9D0003D4  8FBF0014   LW RA, 20(SP)
9D0003D8  8FB00010   LW S0, 16(SP)
9D0003DC  03E00008   JR RA
9D0003E0  27BD0018   ADDIU SP, SP, 24
1935:                
1936:                /*-----------------------------------------------------------------------*/
1937:                /* Check if the file system object is valid or not                       */
1938:                /*-----------------------------------------------------------------------*/
1939:                
1940:                FRESULT chk_mounted( /* FR_OK(0): successful, !=0: any error occurred */
1941:                                            const TCHAR **path, /* Pointer to pointer to the path name (drive number) */
1942:                                            FATFS **rfs, /* Pointer to pointer to the found file system object */
1943:                                            PF_BYTE chk_wp /* !=0: Check media write protection for write access */
1944:                                            ) {
9D00142C  27BDFFE0   ADDIU SP, SP, -32
9D001430  AFBF001C   SW RA, 28(SP)
9D001434  AFB20018   SW S2, 24(SP)
9D001438  AFB10014   SW S1, 20(SP)
9D00143C  AFB00010   SW S0, 16(SP)
9D001440  30D100FF   ANDI S1, A2, 255
1945:                	PF_BYTE fmt, b, pi, *tbl;
1946:                	UINT vol;
1947:                	DSTATUS stat;
1948:                	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
1949:                	PF_WORD nrsv;
1950:                	const TCHAR *p = *path;
9D001444  8C820000   LW V0, 0(A0)
1951:                	FATFS *fs;
1952:                
1953:                	/* Get logical drive number from the path name */
1954:                	vol = p[0] - '0'; /* Is there a drive number? */
9D001448  80430000   LB V1, 0(V0)
9D00144C  2463FFD0   ADDIU V1, V1, -48
1955:                	if (vol <= 9 && p[1] == ':') { /* Found a drive number, get and strip it */
9D001450  2C66000A   SLTIU A2, V1, 10
9D001454  10C0000A   BEQ A2, ZERO, 0x9D001480
9D001458  8F90803C   LW S0, -32708(GP)
9D00145C  80470001   LB A3, 1(V0)
9D001460  2406003A   ADDIU A2, ZERO, 58
9D001464  54E60007   BNEL A3, A2, 0x9D001484
9D001468  ACB00000   SW S0, 0(A1)
1956:                		p += 2;
9D00146C  24420002   ADDIU V0, V0, 2
1957:                		*path = p; /* Return pointer to the path name */
9D001470  AC820000   SW V0, 0(A0)
1958:                	} else { /* No drive number is given */
1959:                #if _FS_RPATH
1960:                		vol = CurrVol; /* Use current drive */
1961:                #else
1962:                		vol = 0; /* Use drive 0 */
1963:                #endif
1964:                	}
1965:                
1966:                	/* Check if the file system object is valid or not */
1967:                	if (vol >= _VOLUMES) /* Is the drive number valid? */
9D001474  14600112   BNE V1, ZERO, 0x9D0018C0
9D001478  2402000B   ADDIU V0, ZERO, 11
1968:                		return FR_INVALID_DRIVE;
1969:                	*rfs = fs = FatFs[vol]; /* Return pointer to the corresponding file system object */
9D00147C  8F90803C   LW S0, -32708(GP)
9D001480  ACB00000   SW S0, 0(A1)
1970:                	if (!fs)
9D001484  1200010E   BEQ S0, ZERO, 0x9D0018C0
9D001488  2402000C   ADDIU V0, ZERO, 12
1971:                		return FR_NOT_ENABLED; /* Is the file system object available? */
1972:                
1973:                	ENTER_FF(fs); /* Lock file system */
1974:                
1975:                	if (fs->fs_type) { /* If the logical drive has been mounted */
9D00148C  92020000   LBU V0, 0(S0)
9D001490  5040000D   BEQL V0, ZERO, 0x9D0014C8
9D001494  A2000000   SB ZERO, 0(S0)
1976:                		stat = disk_status(fs->drv);
9D001498  0F401B12   JAL disk_status
9D00149C  92040001   LBU A0, 1(S0)
9D0014A0  00401821   ADDU V1, V0, ZERO
1977:                		if (!(stat & STA_NOINIT)) { /* and the physical drive is kept initialized (has not been changed), */
9D0014A4  30420001   ANDI V0, V0, 1
9D0014A8  54400007   BNEL V0, ZERO, 0x9D0014C8
9D0014AC  A2000000   SB ZERO, 0(S0)
1978:                			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check write protection if needed */
9D0014B0  12200103   BEQ S1, ZERO, 0x9D0018C0
9D0014B4  2404000A   ADDIU A0, ZERO, 10
9D0014B8  30620004   ANDI V0, V1, 4
1979:                				return FR_WRITE_PROTECTED;
1980:                			return FR_OK; /* The file system object is valid */
9D0014BC  0002200A   MOVZ A0, ZERO, V0
9D0014C0  0B400630   J 0x9D0018C0
9D0014C4  00801021   ADDU V0, A0, ZERO
1981:                		}
1982:                	}
1983:                
1984:                	/* The file system object is not valid. */
1985:                	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
1986:                
1987:                	fs->fs_type = 0; /* Clear the file system object */
1988:                	fs->drv = LD2PD(vol); /* Bind the logical drive and a physical drive */
9D0014C8  A2000001   SB ZERO, 1(S0)
1989:                	stat = disk_initialize(fs->drv); /* Initialize low level disk I/O layer */
9D0014CC  0F401A81   JAL disk_initialize
9D0014D0  00002021   ADDU A0, ZERO, ZERO
9D0014D4  00401821   ADDU V1, V0, ZERO
1990:                	if (stat & STA_NOINIT) /* Check if the initialization succeeded */
9D0014D8  30440001   ANDI A0, V0, 1
9D0014DC  148000F8   BNE A0, ZERO, 0x9D0018C0
9D0014E0  24020003   ADDIU V0, ZERO, 3
1991:                		return FR_NOT_READY; /* Failed to initialize due to no media or hard error */
1992:                	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check disk write protection if needed */
9D0014E4  12200003   BEQ S1, ZERO, 0x9D0014F4
9D0014E8  30630004   ANDI V1, V1, 4
9D0014EC  146000F4   BNE V1, ZERO, 0x9D0018C0
9D0014F0  2402000A   ADDIU V0, ZERO, 10
1993:                		return FR_WRITE_PROTECTED;
1994:                #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
1995:                	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
1996:                	return FR_DISK_ERR;
1997:                #endif
1998:                	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
1999:                	fmt = check_fs(fs, bsect = 0); /* Load sector 0 and check if it is an FAT-VBR (in SFD) */
9D0014F4  02002021   ADDU A0, S0, ZERO
9D0014F8  0F4000C3   JAL 0x9D00030C
9D0014FC  00002821   ADDU A1, ZERO, ZERO
9D001500  00401821   ADDU V1, V0, ZERO
2000:                	if (LD2PT(vol) && !fmt)
2001:                		fmt = 1; /* Force non-SFD if the volume is forced partition */
2002:                	if (fmt == 1) { /* Not an FAT-VBR, the physical drive can be partitioned */
9D001504  24020001   ADDIU V0, ZERO, 1
9D001508  14620012   BNE V1, V0, 0x9D001554
9D00150C  00008821   ADDU S1, ZERO, ZERO
2003:                		/* Check the partition listed in the partition table */
2004:                		pi = LD2PT(vol);
2005:                		if (pi)
2006:                			pi--;
2007:                		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
2008:                		if (tbl[4]) { /* Is the partition existing? */
9D001510  920301F2   LBU V1, 498(S0)
9D001514  106000EA   BEQ V1, ZERO, 0x9D0018C0
9D001518  2402000D   ADDIU V0, ZERO, 13
2009:                			bsect = LD_DWORD(&tbl[8]); /* Partition offset in LBA */
9D00151C  921101F9   LBU S1, 505(S0)
9D001520  00118E00   SLL S1, S1, 24
9D001524  920201F8   LBU V0, 504(S0)
9D001528  00021400   SLL V0, V0, 16
9D00152C  02228825   OR S1, S1, V0
9D001530  920201F6   LBU V0, 502(S0)
9D001534  02228825   OR S1, S1, V0
9D001538  920201F7   LBU V0, 503(S0)
9D00153C  00021200   SLL V0, V0, 8
9D001540  02228825   OR S1, S1, V0
2010:                			fmt = check_fs(fs, bsect); /* Check the partition */
9D001544  02002021   ADDU A0, S0, ZERO
9D001548  0F4000C3   JAL 0x9D00030C
9D00154C  02202821   ADDU A1, S1, ZERO
9D001550  00401821   ADDU V1, V0, ZERO
2011:                		}
2012:                	}
2013:                	if (fmt == 3)
9D001554  24040003   ADDIU A0, ZERO, 3
9D001558  106400D9   BEQ V1, A0, 0x9D0018C0
9D00155C  24020001   ADDIU V0, ZERO, 1
2014:                		return FR_DISK_ERR;
2015:                	if (fmt)
9D001560  146000D7   BNE V1, ZERO, 0x9D0018C0
9D001564  2402000D   ADDIU V0, ZERO, 13
2016:                		return FR_NO_FILESYSTEM; /* No FAT volume is found */
2017:                
2018:                	/* An FAT volume is found. Following code initializes the file system object */
2019:                
2020:                	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs)) /* (BPB_BytsPerSec must be equal to the physical sector size) */
9D001568  9204003C   LBU A0, 60(S0)
9D00156C  00042200   SLL A0, A0, 8
9D001570  9202003B   LBU V0, 59(S0)
9D001574  00822025   OR A0, A0, V0
9D001578  7C042620   SEH A0, A0
9D00157C  24030200   ADDIU V1, ZERO, 512
9D001580  148300CF   BNE A0, V1, 0x9D0018C0
9D001584  2402000D   ADDIU V0, ZERO, 13
2021:                		return FR_NO_FILESYSTEM;
2022:                
2023:                	fasize = LD_WORD(fs->win+BPB_FATSz16); /* Number of sectors per FAT */
9D001588  92030047   LBU V1, 71(S0)
9D00158C  00031A00   SLL V1, V1, 8
9D001590  92020046   LBU V0, 70(S0)
9D001594  00621825   OR V1, V1, V0
2024:                	if (!fasize)
9D001598  5460000C   BNEL V1, ZERO, 0x9D0015CC
9D00159C  AE03001C   SW V1, 28(S0)
2025:                		fasize = LD_DWORD(fs->win+BPB_FATSz32);
9D0015A0  92030057   LBU V1, 87(S0)
9D0015A4  00031E00   SLL V1, V1, 24
9D0015A8  92020056   LBU V0, 86(S0)
9D0015AC  00021400   SLL V0, V0, 16
9D0015B0  00621825   OR V1, V1, V0
9D0015B4  92020054   LBU V0, 84(S0)
9D0015B8  00621825   OR V1, V1, V0
9D0015BC  92020055   LBU V0, 85(S0)
9D0015C0  00021200   SLL V0, V0, 8
9D0015C4  00621825   OR V1, V1, V0
2026:                	fs->fsize = fasize;
9D0015C8  AE03001C   SW V1, 28(S0)
2027:                
2028:                	fs->n_fats = b = fs->win[BPB_NumFATs]; /* Number of FAT copies */
9D0015CC  92040040   LBU A0, 64(S0)
9D0015D0  A2040003   SB A0, 3(S0)
2029:                	if (b != 1 && b != 2)
9D0015D4  2485FFFF   ADDIU A1, A0, -1
9D0015D8  30A500FF   ANDI A1, A1, 255
9D0015DC  2CA50002   SLTIU A1, A1, 2
9D0015E0  10A000B7   BEQ A1, ZERO, 0x9D0018C0
9D0015E4  2402000D   ADDIU V0, ZERO, 13
2030:                		return FR_NO_FILESYSTEM; /* (Must be 1 or 2) */
2031:                	fasize *= b; /* Number of sectors for FAT area */
9D001678  70642002   MUL A0, V1, A0
2032:                
2033:                	fs->csize = b = fs->win[BPB_SecPerClus]; /* Number of sectors per cluster */
9D0015E8  9205003D   LBU A1, 61(S0)
2034:                	if (!b || (b & (b - 1)))
9D0015EC  10A000B4   BEQ A1, ZERO, 0x9D0018C0
9D0015F0  A2050002   SB A1, 2(S0)
9D0015F4  24A6FFFF   ADDIU A2, A1, -1
9D0015F8  00C53024   AND A2, A2, A1
9D0015FC  14C000B1   BNE A2, ZERO, 0x9D0018C4
9D001600  8FBF001C   LW RA, 28(SP)
2035:                		return FR_NO_FILESYSTEM; /* (Must be power of 2) */
2036:                
2037:                	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt); /* Number of root directory entries */
9D001604  92060042   LBU A2, 66(S0)
9D001608  00063200   SLL A2, A2, 8
9D00160C  92020041   LBU V0, 65(S0)
9D001610  00C23025   OR A2, A2, V0
9D001614  A6060008   SH A2, 8(S0)
2038:                	if (fs->n_rootdir % (SS(fs) / SZ_DIR))
9D001618  30C7000F   ANDI A3, A2, 15
9D00161C  14E000A8   BNE A3, ZERO, 0x9D0018C0
9D001620  2402000D   ADDIU V0, ZERO, 13
2039:                		return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be sector aligned) */
2040:                
2041:                	tsect = LD_WORD(fs->win+BPB_TotSec16); /* Number of sectors on the volume */
9D001624  92070044   LBU A3, 68(S0)
9D001628  00073A00   SLL A3, A3, 8
9D00162C  92020043   LBU V0, 67(S0)
9D001630  00E23825   OR A3, A3, V0
2042:                	if (!tsect)
9D001634  14E0000B   BNE A3, ZERO, 0x9D001664
9D001638  9208003F   LBU T0, 63(S0)
2043:                		tsect = LD_DWORD(fs->win+BPB_TotSec32);
9D00163C  92070053   LBU A3, 83(S0)
9D001640  00073E00   SLL A3, A3, 24
9D001644  92020052   LBU V0, 82(S0)
9D001648  00021400   SLL V0, V0, 16
9D00164C  00E23825   OR A3, A3, V0
9D001650  92020050   LBU V0, 80(S0)
9D001654  00E23825   OR A3, A3, V0
9D001658  92020051   LBU V0, 81(S0)
9D00165C  00021200   SLL V0, V0, 8
9D001660  00E23825   OR A3, A3, V0
2044:                
2045:                	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt); /* Number of reserved sectors */
9D001664  00084200   SLL T0, T0, 8
9D001668  9202003E   LBU V0, 62(S0)
9D00166C  01024025   OR T0, T0, V0
2046:                	if (!nrsv)
9D001670  11000093   BEQ T0, ZERO, 0x9D0018C0
9D001674  2402000D   ADDIU V0, ZERO, 13
2047:                		return FR_NO_FILESYSTEM; /* (BPB_RsvdSecCnt must not be 0) */
2048:                
2049:                	/* Determine the FAT sub type */
2050:                	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR); /* RSV+FAT+DIR */
9D00167C  00064902   SRL T1, A2, 4
9D001680  01284821   ADDU T1, T1, T0
9D001684  01244821   ADDU T1, T1, A0
2051:                	if (tsect < sysect)
9D001688  00E9502B   SLTU T2, A3, T1
9D00168C  1540008D   BNE T2, ZERO, 0x9D0018C4
9D001690  8FBF001C   LW RA, 28(SP)
2052:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2053:                	nclst = (tsect - sysect) / fs->csize; /* Number of clusters */
9D001694  00E93823   SUBU A3, A3, T1
9D001698  00E5001B   DIVU A3, A1
9D00169C  00A001F4   TEQ A1, ZERO
9D0016A0  00002812   MFLO A1, 0
2054:                	if (!nclst)
9D0016A4  10A00086   BEQ A1, ZERO, 0x9D0018C0
9D0016A8  2CB20FF6   SLTIU S2, A1, 4086
2055:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2056:                	fmt = FS_FAT12;
9D0016AC  24020001   ADDIU V0, ZERO, 1
9D0016B0  240A0002   ADDIU T2, ZERO, 2
9D0016B4  0152100A   MOVZ V0, T2, S2
9D0016B8  00409021   ADDU S2, V0, ZERO
2057:                	if (nclst >= MIN_FAT16)
2058:                		fmt = FS_FAT16;
2059:                	if (nclst >= MIN_FAT32)
9D0016BC  3402FFF6   ORI V0, ZERO, -10
9D0016C0  00A2102B   SLTU V0, A1, V0
9D0016C4  10400084   BEQ V0, ZERO, 0x9D0018D8
9D0016C8  24A50002   ADDIU A1, A1, 2
2060:                		fmt = FS_FAT32;
9D0018EC  0B4005BA   J 0x9D0016E8
9D0018F0  24120003   ADDIU S2, ZERO, 3
2061:                
2062:                	/* Boundaries and Limits */
2063:                	fs->n_fatent = nclst + 2; /* Number of FAT entries */
9D0016CC  AE050018   SW A1, 24(S0)
9D0018D8  AE050018   SW A1, 24(S0)
2064:                	fs->database = bsect + sysect; /* Data start sector */
9D0016D0  02294821   ADDU T1, S1, T1
9D0016D4  AE090028   SW T1, 40(S0)
9D0018DC  02294821   ADDU T1, S1, T1
9D0018E0  AE090028   SW T1, 40(S0)
2065:                	fs->fatbase = bsect + nrsv; /* FAT start sector */
9D0016D8  02284021   ADDU T0, S1, T0
9D0018E4  02284021   ADDU T0, S1, T0
9D0018E8  AE080020   SW T0, 32(S0)
2066:                	if (fmt == FS_FAT32) {
9D0016DC  24020003   ADDIU V0, ZERO, 3
9D0016E0  16420010   BNE S2, V0, 0x9D001724
9D0016E4  AE080020   SW T0, 32(S0)
2067:                		if (fs->n_rootdir)
9D0016E8  14C00075   BNE A2, ZERO, 0x9D0018C0
9D0016EC  2402000D   ADDIU V0, ZERO, 13
2068:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be 0) */
2069:                		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
9D0016F0  9204005F   LBU A0, 95(S0)
9D0016F4  00042600   SLL A0, A0, 24
9D0016F8  9202005E   LBU V0, 94(S0)
9D0016FC  00021400   SLL V0, V0, 16
9D001700  00822025   OR A0, A0, V0
9D001704  9202005C   LBU V0, 92(S0)
9D001708  00822025   OR A0, A0, V0
9D00170C  9202005D   LBU V0, 93(S0)
9D001710  00021200   SLL V0, V0, 8
9D001714  00821025   OR V0, A0, V0
9D001718  AE020024   SW V0, 36(S0)
2070:                		szbfat = fs->n_fatent * 4; /* (Required FAT size) */
9D00171C  0B4005D6   J 0x9D001758
9D001720  00052880   SLL A1, A1, 2
2071:                	} else {
2072:                		if (!fs->n_rootdir)
9D001724  10C00066   BEQ A2, ZERO, 0x9D0018C0
9D001728  2402000D   ADDIU V0, ZERO, 13
2073:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must not be 0) */
2074:                		fs->dirbase = fs->fatbase + fasize; /* Root directory start sector */
9D00172C  00882021   ADDU A0, A0, T0
2075:                		szbfat = (fmt == FS_FAT16) ? /* (Required FAT size) */
2076:                		fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
9D001730  24020002   ADDIU V0, ZERO, 2
9D001734  16420003   BNE S2, V0, 0x9D001744
9D001738  AE040024   SW A0, 36(S0)
9D00173C  0B4005D6   J 0x9D001758
9D001740  00052840   SLL A1, A1, 1
9D001744  24020003   ADDIU V0, ZERO, 3
9D001748  70A21002   MUL V0, A1, V0
9D00174C  00021042   SRL V0, V0, 1
9D001750  30A50001   ANDI A1, A1, 1
9D001754  00452821   ADDU A1, V0, A1
2077:                	}
2078:                	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) /* (BPB_FATSz must not be less than required) */
9D001758  24A501FF   ADDIU A1, A1, 511
9D00175C  00052A42   SRL A1, A1, 9
9D001760  0065182B   SLTU V1, V1, A1
9D001764  14600056   BNE V1, ZERO, 0x9D0018C0
9D001768  2402000D   ADDIU V0, ZERO, 13
2079:                		return FR_NO_FILESYSTEM;
2080:                
2081:                #if !_FS_READONLY
2082:                	/* Initialize cluster allocation information */
2083:                	fs->free_clust = 0xFFFFFFFF;
9D00176C  2402FFFF   ADDIU V0, ZERO, -1
9D001770  AE020010   SW V0, 16(S0)
2084:                	fs->last_clust = 0;
2085:                
2086:                	/* Get fsinfo if available */
2087:                	if (fmt == FS_FAT32) {
9D001774  24020003   ADDIU V0, ZERO, 3
9D001778  16420048   BNE S2, V0, 0x9D00189C
9D00177C  AE00000C   SW ZERO, 12(S0)
2088:                		fs->fsi_flag = 0;
9D001780  A2000005   SB ZERO, 5(S0)
2089:                		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
9D001784  92060061   LBU A2, 97(S0)
9D001788  00063200   SLL A2, A2, 8
9D00178C  92020060   LBU V0, 96(S0)
9D001790  00C23025   OR A2, A2, V0
9D001794  02263021   ADDU A2, S1, A2
9D001798  AE060014   SW A2, 20(S0)
2090:                		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK
9D00179C  92040001   LBU A0, 1(S0)
9D0017A0  26050030   ADDIU A1, S0, 48
9D0017A4  0F401B19   JAL disk_read
9D0017A8  24070001   ADDIU A3, ZERO, 1
9D0017AC  5440003C   BNEL V0, ZERO, 0x9D0018A0
9D0017B0  A2120000   SB S2, 0(S0)
2091:                				&& LD_WORD(fs->win+BS_55AA) == 0xAA55
9D0017B4  9203022F   LBU V1, 559(S0)
9D0017B8  00031A00   SLL V1, V1, 8
9D0017BC  9202022E   LBU V0, 558(S0)
9D0017C0  00621825   OR V1, V1, V0
9D0017C4  7C031E20   SEH V1, V1
9D0017C8  2402AA55   ADDIU V0, ZERO, -21931
9D0017CC  54620034   BNEL V1, V0, 0x9D0018A0
9D0017D0  A2120000   SB S2, 0(S0)
2092:                				&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
9D0017D4  92030033   LBU V1, 51(S0)
9D0017D8  00031E00   SLL V1, V1, 24
9D0017DC  92020032   LBU V0, 50(S0)
9D0017E0  00021400   SLL V0, V0, 16
9D0017E4  00621825   OR V1, V1, V0
9D0017E8  92020030   LBU V0, 48(S0)
9D0017EC  00621825   OR V1, V1, V0
9D0017F0  92020031   LBU V0, 49(S0)
9D0017F4  00021200   SLL V0, V0, 8
9D0017F8  00621825   OR V1, V1, V0
9D0017FC  3C024161   LUI V0, 16737
9D001800  24425252   ADDIU V0, V0, 21074
9D001804  54620026   BNEL V1, V0, 0x9D0018A0
9D001808  A2120000   SB S2, 0(S0)
2093:                				&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
9D00180C  92030217   LBU V1, 535(S0)
9D001810  00031E00   SLL V1, V1, 24
9D001814  92020216   LBU V0, 534(S0)
9D001818  00021400   SLL V0, V0, 16
9D00181C  00621825   OR V1, V1, V0
9D001820  92020214   LBU V0, 532(S0)
9D001824  00621825   OR V1, V1, V0
9D001828  92020215   LBU V0, 533(S0)
9D00182C  00021200   SLL V0, V0, 8
9D001830  00621825   OR V1, V1, V0
9D001834  3C026141   LUI V0, 24897
9D001838  24427272   ADDIU V0, V0, 29298
9D00183C  54620018   BNEL V1, V0, 0x9D0018A0
9D001840  A2120000   SB S2, 0(S0)
2094:                			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
9D001844  9203021F   LBU V1, 543(S0)
9D001848  00031E00   SLL V1, V1, 24
9D00184C  9202021E   LBU V0, 542(S0)
9D001850  00021400   SLL V0, V0, 16
9D001854  00621825   OR V1, V1, V0
9D001858  9202021C   LBU V0, 540(S0)
9D00185C  00621825   OR V1, V1, V0
9D001860  9202021D   LBU V0, 541(S0)
9D001864  00021200   SLL V0, V0, 8
9D001868  00621025   OR V0, V1, V0
9D00186C  AE02000C   SW V0, 12(S0)
2095:                			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
9D001870  9203021B   LBU V1, 539(S0)
9D001874  00031E00   SLL V1, V1, 24
9D001878  9202021A   LBU V0, 538(S0)
9D00187C  00021400   SLL V0, V0, 16
9D001880  00621825   OR V1, V1, V0
9D001884  92020218   LBU V0, 536(S0)
9D001888  00621825   OR V1, V1, V0
9D00188C  92020219   LBU V0, 537(S0)
9D001890  00021200   SLL V0, V0, 8
9D001894  00621025   OR V0, V1, V0
9D001898  AE020010   SW V0, 16(S0)
2096:                		}
2097:                	}
2098:                #endif
2099:                	fs->fs_type = fmt; /* FAT sub-type */
9D00189C  A2120000   SB S2, 0(S0)
2100:                	fs->id = ++Fsid; /* File system mount ID */
9D0018A0  97828040   LHU V0, -32704(GP)
9D0018A4  24420001   ADDIU V0, V0, 1
9D0018A8  3042FFFF   ANDI V0, V0, -1
9D0018AC  A7828040   SH V0, -32704(GP)
9D0018B0  A6020006   SH V0, 6(S0)
2101:                	fs->winsect = 0; /* Invalidate sector cache */
9D0018B4  AE00002C   SW ZERO, 44(S0)
2102:                	fs->wflag = 0;
9D0018B8  A2000004   SB ZERO, 4(S0)
2103:                #if _FS_RPATH
2104:                	fs->cdir = 0; /* Current directory (root dir) */
2105:                #endif
2106:                #if _FS_SHARE				/* Clear file lock semaphores */
2107:                	clear_lock(fs);
2108:                #endif
2109:                
2110:                	return FR_OK;
9D0018BC  00001021   ADDU V0, ZERO, ZERO
2111:                }
9D0018C0  8FBF001C   LW RA, 28(SP)
9D0018C4  8FB20018   LW S2, 24(SP)
9D0018C8  8FB10014   LW S1, 20(SP)
9D0018CC  8FB00010   LW S0, 16(SP)
9D0018D0  03E00008   JR RA
9D0018D4  27BD0020   ADDIU SP, SP, 32
2112:                
2113:                /*-----------------------------------------------------------------------*/
2114:                /* Check if the file/dir object is valid or not                          */
2115:                /*-----------------------------------------------------------------------*/
2116:                
2117:                static FRESULT validate( /* FR_OK(0): The object is valid, !=0: Invalid */
2118:                FATFS *fs, /* Pointer to the file system object */
2119:                PF_WORD id /* Member id of the target object to be checked */
2120:                ) {
9D00050C  27BDFFE8   ADDIU SP, SP, -24
9D000510  AFBF0014   SW RA, 20(SP)
2121:                	if (!fs || !fs->fs_type || fs->id != id)
9D000514  1080000D   BEQ A0, ZERO, 0x9D00054C
9D000518  24020009   ADDIU V0, ZERO, 9
9D00051C  90830000   LBU V1, 0(A0)
9D000520  1060000B   BEQ V1, ZERO, 0x9D000550
9D000524  8FBF0014   LW RA, 20(SP)
9D000528  94830006   LHU V1, 6(A0)
9D00052C  14650008   BNE V1, A1, 0x9D000550
9D000530  00000000   NOP
2122:                		return FR_INVALID_OBJECT;
2123:                
2124:                	ENTER_FF(fs); /* Lock file system */
2125:                
2126:                	if (disk_status(fs->drv) & STA_NOINIT)
9D000534  0F401B12   JAL disk_status
9D000538  90840001   LBU A0, 1(A0)
9D00053C  30420001   ANDI V0, V0, 1
2127:                		return FR_NOT_READY;
9D000540  24030003   ADDIU V1, ZERO, 3
9D000544  0002180A   MOVZ V1, ZERO, V0
9D000548  00601021   ADDU V0, V1, ZERO
2128:                
2129:                	return FR_OK;
2130:                }
9D00054C  8FBF0014   LW RA, 20(SP)
9D000550  03E00008   JR RA
9D000554  27BD0018   ADDIU SP, SP, 24
2131:                
2132:                /*--------------------------------------------------------------------------
2133:                
2134:                 Public Functions
2135:                
2136:                 --------------------------------------------------------------------------*/
2137:                
2138:                /*-----------------------------------------------------------------------*/
2139:                /* Mount/Unmount a Logical Drive                                         */
2140:                /*-----------------------------------------------------------------------*/
2141:                
2142:                FRESULT f_mount(PF_BYTE vol, /* Logical drive number to be mounted/unmounted */
2143:                                FATFS *fs /* Pointer to new file system object (NULL for unmount)*/
2144:                                ) {
9D0018F4  308400FF   ANDI A0, A0, 255
2145:                	FATFS *rfs;
2146:                
2147:                	if (vol >= _VOLUMES) {/* Check if the drive number is valid */
9D0018F8  14800008   BNE A0, ZERO, 0x9D00191C
9D0018FC  2402000B   ADDIU V0, ZERO, 11
2148:                		return FR_INVALID_DRIVE;
2149:                	}
2150:                	rfs = FatFs[vol]; /* Get current fs object */
9D001900  8F82803C   LW V0, -32708(GP)
2151:                
2152:                	if (rfs) {
9D001904  54400001   BNEL V0, ZERO, 0x9D00190C
9D001908  A0400000   SB ZERO, 0(V0)
2153:                #if _FS_SHARE
2154:                		clear_lock(rfs);
2155:                #endif
2156:                #if _FS_REENTRANT				/* Discard sync object of the current volume */
2157:                		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2158:                #endif
2159:                		rfs->fs_type = 0; /* Clear old fs object */
2160:                	}
2161:                
2162:                	if (fs) {
9D00190C  54A00001   BNEL A1, ZERO, 0x9D001914
9D001910  A0A00000   SB ZERO, 0(A1)
2163:                		fs->fs_type = 0; /* Clear new fs object */
2164:                #if _FS_REENTRANT				/* Create sync object for the new volume */
2165:                		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2166:                #endif
2167:                	}
2168:                	FatFs[vol] = fs; /* Register new fs object */
9D001914  AF85803C   SW A1, -32708(GP)
2169:                
2170:                	return FR_OK;
9D001918  00001021   ADDU V0, ZERO, ZERO
2171:                }
9D00191C  03E00008   JR RA
9D001920  00000000   NOP
2172:                
2173:                /*-----------------------------------------------------------------------*/
2174:                /* Open or Create a File                                                 */
2175:                /*-----------------------------------------------------------------------*/
2176:                
2177:                FRESULT f_open(FIL *fp, /* Pointer to the blank file object */
2178:                                const TCHAR *path, /* Pointer to the file name */
2179:                                PF_BYTE mode /* Access mode and file open mode flags */
2180:                                ) {
9D001924  27BDFFB0   ADDIU SP, SP, -80
9D001928  AFBF004C   SW RA, 76(SP)
9D00192C  AFB40048   SW S4, 72(SP)
9D001930  AFB30044   SW S3, 68(SP)
9D001934  AFB20040   SW S2, 64(SP)
9D001938  AFB1003C   SW S1, 60(SP)
9D00193C  AFB00038   SW S0, 56(SP)
9D001940  00808821   ADDU S1, A0, ZERO
9D001944  AFA50054   SW A1, 84(SP)
2181:                	FRESULT res;
2182:                	DIR dj;
2183:                	PF_BYTE *dir;
2184:                	DEF_NAMEBUF;
2185:                
2186:                	fp->fs = 0; /* Clear file object */
9D001948  AC800000   SW ZERO, 0(A0)
2187:                
2188:                #if !_FS_READONLY
2189:                	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS
9D00194C  30D2001F   ANDI S2, A2, 31
2190:                			| FA_CREATE_NEW;
2191:                	res = chk_mounted(&path, &dj.fs, (PF_BYTE) (mode & ~FA_READ));
9D001950  02409821   ADDU S3, S2, ZERO
9D001954  27A40054   ADDIU A0, SP, 84
9D001958  27A50010   ADDIU A1, SP, 16
9D00195C  0F40050B   JAL chk_mounted
9D001960  3246001E   ANDI A2, S2, 30
2192:                #else
2193:                	mode &= FA_READ;
2194:                	res = chk_mounted(&path, &dj.fs, 0);
2195:                #endif
2196:                	INIT_BUF(dj);
9D001964  27A3002C   ADDIU V1, SP, 44
2197:                	if (res == FR_OK)
9D001968  14400086   BNE V0, ZERO, 0x9D001B84
9D00196C  AFA30028   SW V1, 40(SP)
2198:                		res = follow_path(&dj, path); /* Follow the file path */
9D001970  27A40010   ADDIU A0, SP, 16
9D001974  0F400384   JAL 0x9D000E10
9D001978  8FA50054   LW A1, 84(SP)
2199:                	dir = dj.dir;
9D001B84  0B400663   J 0x9D00198C
9D001B88  8FB00024   LW S0, 36(SP)
2200:                
2201:                #if !_FS_READONLY	/* R/W configuration */
2202:                	if (res == FR_OK) {
9D00197C  14400003   BNE V0, ZERO, 0x9D00198C
9D001980  8FB00024   LW S0, 36(SP)
2203:                		if (!dir) /* Current dir itself */
2204:                			res = FR_INVALID_NAME;
9D001984  24030006   ADDIU V1, ZERO, 6
9D001988  0070100A   MOVZ V0, V1, S0
2205:                #if _FS_SHARE
2206:                		else
2207:                		res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2208:                #endif
2209:                	}
2210:                	/* Create or Open a file */
2211:                	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
9D00198C  3263001C   ANDI V1, S3, 28
9D001990  10600044   BEQ V1, ZERO, 0x9D001AA4
9D001994  00000000   NOP
2212:                		DWORD dw, cl;
2213:                
2214:                		if (res != FR_OK) { /* No file, create new */
9D001998  5040000B   BEQL V0, ZERO, 0x9D0019C8
9D00199C  9203000B   LBU V1, 11(S0)
2215:                			if (res == FR_NO_FILE) /* There is no file to open, create a new entry */
9D0019A0  24030004   ADDIU V1, ZERO, 4
9D0019A4  14430070   BNE V0, V1, 0x9D001B68
9D0019A8  8FBF004C   LW RA, 76(SP)
2216:                #if _FS_SHARE
2217:                				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
2218:                #else
2219:                				res = dir_register(&dj);
9D0019AC  0F400472   JAL 0x9D0011C8
9D0019B0  27A40010   ADDIU A0, SP, 16
2220:                #endif
2221:                			mode |= FA_CREATE_ALWAYS; /* File is created */
2222:                			dir = dj.dir; /* New entry */
9D0019B4  8FB00024   LW S0, 36(SP)
2223:                		} else { /* Any object is already existing */
2224:                			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) { /* Cannot overwrite it (R/O or DIR) */
9D0019C8  30630011   ANDI V1, V1, 17
9D0019CC  14600065   BNE V1, ZERO, 0x9D001B64
9D0019D0  24020007   ADDIU V0, ZERO, 7
2225:                				res = FR_DENIED;
2226:                			} else {
2227:                				if (mode & FA_CREATE_NEW) /* Cannot create as new file */
9D0019D4  32730004   ANDI S3, S3, 4
9D0019D8  16600062   BNE S3, ZERO, 0x9D001B64
9D0019DC  24020008   ADDIU V0, ZERO, 8
2228:                					res = FR_EXIST;
2229:                			}
2230:                		}
2231:                		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) { /* Truncate it if overwrite mode */
9D0019B8  10400009   BEQ V0, ZERO, 0x9D0019E0
9D0019BC  36520008   ORI S2, S2, 8
9D0019E0  32420008   ANDI V0, S2, 8
9D0019E4  1040003F   BEQ V0, ZERO, 0x9D001AE4
9D0019E8  8FA30010   LW V1, 16(SP)
2232:                			dw = get_fattime(); /* Created time */
9D0019EC  0F401C74   JAL get_fattime
9D0019F0  00000000   NOP
2233:                			ST_DWORD(dir+DIR_CrtTime, dw);
9D0019F4  A202000E   SB V0, 14(S0)
9D0019F8  7C433A00   EXT V1, V0, 8, 8
9D0019FC  A203000F   SB V1, 15(S0)
9D001A00  00021C02   SRL V1, V0, 16
9D001A04  A2030010   SB V1, 16(S0)
9D001A08  00021602   SRL V0, V0, 24
9D001A0C  A2020011   SB V0, 17(S0)
2234:                			dir[DIR_Attr] = 0; /* Reset attribute */
9D001A10  A200000B   SB ZERO, 11(S0)
2235:                			ST_DWORD(dir+DIR_FileSize, 0); /* size = 0 */
9D001A14  A200001C   SB ZERO, 28(S0)
9D001A18  A200001D   SB ZERO, 29(S0)
9D001A1C  A200001E   SB ZERO, 30(S0)
9D001A20  A200001F   SB ZERO, 31(S0)
2236:                			cl = LD_CLUST(dir); /* Get start cluster */
9D001A24  92020015   LBU V0, 21(S0)
9D001A28  00021200   SLL V0, V0, 8
9D001A2C  92030014   LBU V1, 20(S0)
9D001A30  00431025   OR V0, V0, V1
9D001A34  00021400   SLL V0, V0, 16
9D001A38  9213001B   LBU S3, 27(S0)
9D001A3C  00139A00   SLL S3, S3, 8
9D001A40  9203001A   LBU V1, 26(S0)
9D001A44  02639825   OR S3, S3, V1
9D001A48  00539825   OR S3, V0, S3
2237:                			ST_CLUST(dir, 0); /* cluster = 0 */
9D001A4C  A200001A   SB ZERO, 26(S0)
9D001A50  A200001B   SB ZERO, 27(S0)
9D001A54  A2000014   SB ZERO, 20(S0)
9D001A58  A2000015   SB ZERO, 21(S0)
2238:                			dj.fs->wflag = 1;
9D001A5C  8FA40010   LW A0, 16(SP)
9D001A60  24020001   ADDIU V0, ZERO, 1
2239:                			if (cl) { /* Remove the cluster chain if exist */
9D001A64  12600049   BEQ S3, ZERO, 0x9D001B8C
9D001A68  A0820004   SB V0, 4(A0)
2240:                				dw = dj.fs->winsect;
9D001A6C  8C94002C   LW S4, 44(A0)
2241:                				res = remove_chain(dj.fs, cl);
9D001A70  0F4004D1   JAL 0x9D001344
9D001A74  02602821   ADDU A1, S3, ZERO
2242:                				if (res == FR_OK) {
9D001A78  1440003B   BNE V0, ZERO, 0x9D001B68
9D001A7C  8FBF004C   LW RA, 76(SP)
2243:                					dj.fs->last_clust = cl - 1; /* Reuse the cluster hole */
9D001A80  8FA40010   LW A0, 16(SP)
9D001A84  2673FFFF   ADDIU S3, S3, -1
9D001A88  AC93000C   SW S3, 12(A0)
2244:                					res = move_window(dj.fs, dw);
9D001A8C  0F400082   JAL 0x9D000208
9D001A90  02802821   ADDU A1, S4, ZERO
2245:                				}
2246:                			}
2247:                		}
2248:                	} else { /* Open an existing file */
2249:                		if (res == FR_OK) { /* Follow succeeded */
9D001AA4  14400030   BNE V0, ZERO, 0x9D001B68
9D001AA8  8FBF004C   LW RA, 76(SP)
2250:                			if (dir[DIR_Attr] & AM_DIR) { /* It is a directory */
9D001AAC  9203000B   LBU V1, 11(S0)
9D001AB0  30640010   ANDI A0, V1, 16
9D001AB4  1480002B   BNE A0, ZERO, 0x9D001B64
9D001AB8  24020004   ADDIU V0, ZERO, 4
2251:                				res = FR_NO_FILE;
2252:                			} else {
2253:                				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
9D001ABC  32730002   ANDI S3, S3, 2
9D001AC0  12600033   BEQ S3, ZERO, 0x9D001B90
9D001AC4  32420008   ANDI V0, S2, 8
9D001AC8  30630001   ANDI V1, V1, 1
9D001ACC  14600025   BNE V1, ZERO, 0x9D001B64
9D001AD0  24020007   ADDIU V0, ZERO, 7
2254:                					res = FR_DENIED;
2255:                			}
2256:                		}
2257:                	}
2258:                	if (res == FR_OK) {
9D001A94  10400012   BEQ V0, ZERO, 0x9D001AE0
9D001A98  36520020   ORI S2, S2, 32
2259:                		if (mode & FA_CREATE_ALWAYS) /* Set file change flag if created or overwritten */
9D001AD4  0B4006E4   J 0x9D001B90
9D001AD8  32420008   ANDI V0, S2, 8
9D001B8C  32420008   ANDI V0, S2, 8
9D001B90  1040FFD4   BEQ V0, ZERO, 0x9D001AE4
9D001B94  8FA30010   LW V1, 16(SP)
9D001B98  0B4006B7   J 0x9D001ADC
9D001B9C  00001021   ADDU V0, ZERO, ZERO
2260:                			mode |= FA__WRITTEN;
9D001ADC  36520020   ORI S2, S2, 32
2261:                		fp->dir_sect = dj.fs->winsect; /* Pointer to the directory entry */
9D001AE0  8FA30010   LW V1, 16(SP)
9D001AE4  8C64002C   LW A0, 44(V1)
9D001AE8  AE24001C   SW A0, 28(S1)
2262:                		fp->dir_ptr = dir;
9D001AEC  AE300020   SW S0, 32(S1)
2263:                #if _FS_SHARE
2264:                		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2265:                		if (!fp->lockid) res = FR_INT_ERR;
2266:                #endif
2267:                	}
2268:                
2269:                #else				/* R/O configuration */
2270:                	if (res == FR_OK) { /* Follow succeeded */
2271:                		if (!dir) { /* Current dir itself */
2272:                			res = FR_INVALID_NAME;
2273:                		} else {
2274:                			if (dir[DIR_Attr] & AM_DIR) /* It is a directory */
2275:                			res = FR_NO_FILE;
2276:                		}
2277:                	}
2278:                #endif
2279:                	FREE_BUF();
2280:                
2281:                	if (res == FR_OK) {
2282:                		fp->flag = mode; /* File access mode */
9D001AF0  A2320006   SB S2, 6(S1)
2283:                		fp->sclust = LD_CLUST(dir); /* File start cluster */
9D001AF4  92050015   LBU A1, 21(S0)
9D001AF8  00052A00   SLL A1, A1, 8
9D001AFC  92060014   LBU A2, 20(S0)
9D001B00  00A62825   OR A1, A1, A2
9D001B04  00052C00   SLL A1, A1, 16
9D001B08  9204001B   LBU A0, 27(S0)
9D001B0C  00042200   SLL A0, A0, 8
9D001B10  9206001A   LBU A2, 26(S0)
9D001B14  00862025   OR A0, A0, A2
9D001B18  00A42025   OR A0, A1, A0
9D001B1C  AE240010   SW A0, 16(S1)
2284:                		fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
9D001B20  9205001F   LBU A1, 31(S0)
9D001B24  00052E00   SLL A1, A1, 24
9D001B28  9204001E   LBU A0, 30(S0)
9D001B2C  00042400   SLL A0, A0, 16
9D001B30  00A42025   OR A0, A1, A0
9D001B34  9205001C   LBU A1, 28(S0)
9D001B38  00852025   OR A0, A0, A1
9D001B3C  9205001D   LBU A1, 29(S0)
9D001B40  00052A00   SLL A1, A1, 8
9D001B44  00852025   OR A0, A0, A1
9D001B48  AE24000C   SW A0, 12(S1)
2285:                		fp->fptr = 0; /* File pointer */
9D001B4C  AE200008   SW ZERO, 8(S1)
2286:                		fp->dsect = 0;
9D001B50  AE200018   SW ZERO, 24(S1)
2287:                #if _USE_FASTSEEK
2288:                		fp->cltbl = 0; /* Normal seek mode */
9D001B54  AE200024   SW ZERO, 36(S1)
2289:                #endif
2290:                		fp->fs = dj.fs;
9D001B58  AE230000   SW V1, 0(S1)
2291:                		fp->id = dj.fs->id; /* Validate file object */
9D001B5C  94630006   LHU V1, 6(V1)
9D001B60  A6230004   SH V1, 4(S1)
2292:                	}
2293:                
2294:                	LEAVE_FF(dj.fs, res);
2295:                }
9D0019C0  0B4006DA   J 0x9D001B68
9D0019C4  8FBF004C   LW RA, 76(SP)
9D001A9C  0B4006DA   J 0x9D001B68
9D001AA0  8FBF004C   LW RA, 76(SP)
9D001B64  8FBF004C   LW RA, 76(SP)
9D001B68  8FB40048   LW S4, 72(SP)
9D001B6C  8FB30044   LW S3, 68(SP)
9D001B70  8FB20040   LW S2, 64(SP)
9D001B74  8FB1003C   LW S1, 60(SP)
9D001B78  8FB00038   LW S0, 56(SP)
9D001B7C  03E00008   JR RA
9D001B80  27BD0050   ADDIU SP, SP, 80
2296:                
2297:                /*-----------------------------------------------------------------------*/
2298:                /* Read File                                                             */
2299:                /*-----------------------------------------------------------------------*/
2300:                
2301:                FRESULT f_read(FIL *fp, /* Pointer to the file object */
2302:                                void *buff, /* Pointer to data buffer */
2303:                                UINT btr, /* Number of bytes to read */
2304:                                UINT *br /* Pointer to number of bytes read */
2305:                                ) {
9D001BA0  27BDFFC8   ADDIU SP, SP, -56
9D001BA4  AFBF0034   SW RA, 52(SP)
9D001BA8  AFBE0030   SW S8, 48(SP)
9D001BAC  AFB7002C   SW S7, 44(SP)
9D001BB0  AFB60028   SW S6, 40(SP)
9D001BB4  AFB50024   SW S5, 36(SP)
9D001BB8  AFB40020   SW S4, 32(SP)
9D001BBC  AFB3001C   SW S3, 28(SP)
9D001BC0  AFB20018   SW S2, 24(SP)
9D001BC4  AFB10014   SW S1, 20(SP)
9D001BC8  AFB00010   SW S0, 16(SP)
9D001BCC  00808021   ADDU S0, A0, ZERO
9D001BD0  00A0A021   ADDU S4, A1, ZERO
9D001BD4  00C08821   ADDU S1, A2, ZERO
9D001BD8  00E09821   ADDU S3, A3, ZERO
2306:                	FRESULT res;
2307:                	DWORD clst, sect, remain;
2308:                	UINT rcnt, cc;
2309:                	PF_BYTE csect, *rbuff = buff;
2310:                
2311:                	*br = 0; /* Initialize byte counter */
9D001BDC  ACE00000   SW ZERO, 0(A3)
2312:                
2313:                	res = validate(fp->fs, fp->id); /* Check validity */
9D001BE0  8C840000   LW A0, 0(A0)
9D001BE4  0F400143   JAL 0x9D00050C
9D001BE8  96050004   LHU A1, 4(S0)
2314:                	if (res != FR_OK)
9D001BEC  1440008A   BNE V0, ZERO, 0x9D001E18
9D001BF0  0040B821   ADDU S7, V0, ZERO
2315:                		LEAVE_FF(fp->fs, res);
2316:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D001BF4  92020006   LBU V0, 6(S0)
9D001BF8  7C021C20   SEB V1, V0
9D001BFC  04600085   BLTZ V1, 0x9D001E14
9D001C00  30420001   ANDI V0, V0, 1
2317:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2318:                	if (!(fp->flag & FA_READ)) /* Check access mode */
9D001C04  50400084   BEQL V0, ZERO, 0x9D001E18
9D001C08  24170007   ADDIU S7, ZERO, 7
9D001C18  0251102B   SLTU V0, S2, S1
9D001C1C  0222900A   MOVZ S2, S1, V0
2319:                		LEAVE_FF(fp->fs, FR_DENIED);
2320:                	remain = fp->fsize - fp->fptr;
9D001C0C  8E12000C   LW S2, 12(S0)
9D001C10  8E020008   LW V0, 8(S0)
9D001C14  02429023   SUBU S2, S2, V0
2321:                	if (btr > remain)
2322:                		btr = (UINT) remain; /* Truncate btr by remaining bytes */
2323:                
2324:                	for (; btr; /* Repeat until all data read */
9D001C20  1240007E   BEQ S2, ZERO, 0x9D001E1C
9D001C24  02E01021   ADDU V0, S7, ZERO
9D001E04  12400004   BEQ S2, ZERO, 0x9D001E18
9D001E08  AE620000   SW V0, 0(S3)
2325:                	rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
9D001DEC  8E020008   LW V0, 8(S0)
9D001DF0  00511021   ADDU V0, V0, S1
9D001DF4  AE020008   SW V0, 8(S0)
9D001DF8  8E620000   LW V0, 0(S3)
9D001DFC  00511021   ADDU V0, V0, S1
9D001E00  02519023   SUBU S2, S2, S1
9D001E0C  0B40070A   J 0x9D001C28
9D001E10  0291A021   ADDU S4, S4, S1
9D001E14  24170002   ADDIU S7, ZERO, 2
2326:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D001C28  8E050008   LW A1, 8(S0)
9D001C2C  30A201FF   ANDI V0, A1, 511
9D001C30  54400057   BNEL V0, ZERO, 0x9D001D90
9D001C34  8E110008   LW S1, 8(S0)
2327:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D001C38  8E040000   LW A0, 0(S0)
9D001C3C  00051242   SRL V0, A1, 9
9D001C40  90950002   LBU S5, 2(A0)
9D001C44  26B5FFFF   ADDIU S5, S5, -1
9D001C48  0055A824   AND S5, V0, S5
9D001C4C  32B500FF   ANDI S5, S5, 255
2328:                			if (!csect) { /* On the cluster boundary? */
9D001C50  56A0001F   BNEL S5, ZERO, 0x9D001CD0
9D001C54  8E160000   LW S6, 0(S0)
2329:                				if (fp->fptr == 0) { /* On the top of the file? */
9D001C58  54A00003   BNEL A1, ZERO, 0x9D001C68
9D001C5C  8E020024   LW V0, 36(S0)
2330:                					clst = fp->sclust; /* Follow from the origin */
9D001C60  0B400722   J 0x9D001C88
9D001C64  8E020010   LW V0, 16(S0)
2331:                				} else { /* Middle or end of the file */
2332:                #if _USE_FASTSEEK
2333:                					if (fp->cltbl)
9D001C68  10400005   BEQ V0, ZERO, 0x9D001C80
9D001C6C  00000000   NOP
2334:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D001C70  0F40001B   JAL 0x9D00006C
9D001C74  02002021   ADDU A0, S0, ZERO
2335:                					else
2336:                #endif
2337:                						clst = get_fat(fp->fs, fp->clust); /* Follow cluster chain on the FAT */
9D001C80  0F400162   JAL get_fat
9D001C84  8E050014   LW A1, 20(S0)
2338:                				}
2339:                				if (clst < 2)
9D001C78  0B400723   J 0x9D001C8C
9D001C7C  2C430002   SLTIU V1, V0, 2
9D001C88  2C430002   SLTIU V1, V0, 2
9D001C8C  10600007   BEQ V1, ZERO, 0x9D001CAC
9D001C90  2403FFFF   ADDIU V1, ZERO, -1
2340:                					ABORT(fp->fs, FR_INT_ERR);
9D001C94  92030006   LBU V1, 6(S0)
9D001C98  2402FF80   ADDIU V0, ZERO, -128
9D001C9C  00621025   OR V0, V1, V0
9D001CA0  A2020006   SB V0, 6(S0)
9D001CA4  0B400786   J 0x9D001E18
9D001CA8  24170002   ADDIU S7, ZERO, 2
2341:                				if (clst == 0xFFFFFFFF)
9D001CAC  54430007   BNEL V0, V1, 0x9D001CCC
9D001CB0  AE020014   SW V0, 20(S0)
2342:                					ABORT(fp->fs, FR_DISK_ERR);
9D001CB4  92030006   LBU V1, 6(S0)
9D001CB8  2402FF80   ADDIU V0, ZERO, -128
9D001CBC  00621025   OR V0, V1, V0
9D001CC0  A2020006   SB V0, 6(S0)
9D001CC4  0B400786   J 0x9D001E18
9D001CC8  24170001   ADDIU S7, ZERO, 1
2343:                				fp->clust = clst; /* Update current cluster */
2344:                			}
2345:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D001CCC  8E160000   LW S6, 0(S0)
9D001CD0  02C02021   ADDU A0, S6, ZERO
9D001CD4  0F400156   JAL clust2sect
9D001CD8  8E050014   LW A1, 20(S0)
2346:                			if (!sect)
9D001CDC  14400007   BNE V0, ZERO, 0x9D001CFC
9D001CE0  00128A42   SRL S1, S2, 9
2347:                				ABORT(fp->fs, FR_INT_ERR);
9D001CE4  92030006   LBU V1, 6(S0)
9D001CE8  2402FF80   ADDIU V0, ZERO, -128
9D001CEC  00621025   OR V0, V1, V0
9D001CF0  A2020006   SB V0, 6(S0)
9D001CF4  0B400786   J 0x9D001E18
9D001CF8  24170002   ADDIU S7, ZERO, 2
2348:                			sect += csect;
2349:                			cc = btr / SS(fp->fs); /* When remaining bytes >= sector size, */
2350:                			if (cc) { /* Read maximum contiguous sectors directly */
9D001CFC  12200022   BEQ S1, ZERO, 0x9D001D88
9D001D00  0055F021   ADDU S8, V0, S5
2351:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D001D04  92C20002   LBU V0, 2(S6)
9D001D08  02351821   ADDU V1, S1, S5
9D001D0C  0043182B   SLTU V1, V0, V1
2352:                					cc = fp->fs->csize - csect;
9D001D10  0055A823   SUBU S5, V0, S5
9D001D14  02A3880B   MOVN S1, S5, V1
2353:                				if (disk_read(fp->fs->drv, rbuff, sect, (PF_BYTE) cc) != RES_OK)
9D001D18  92C40001   LBU A0, 1(S6)
9D001D1C  02802821   ADDU A1, S4, ZERO
9D001D20  03C03021   ADDU A2, S8, ZERO
9D001D24  0F401B19   JAL disk_read
9D001D28  322700FF   ANDI A3, S1, 255
9D001D2C  50400007   BEQL V0, ZERO, 0x9D001D4C
9D001D30  8E050000   LW A1, 0(S0)
2354:                					ABORT(fp->fs, FR_DISK_ERR);
9D001D34  92030006   LBU V1, 6(S0)
9D001D38  2402FF80   ADDIU V0, ZERO, -128
9D001D3C  00621025   OR V0, V1, V0
9D001D40  A2020006   SB V0, 6(S0)
9D001D44  0B400786   J 0x9D001E18
9D001D48  24170001   ADDIU S7, ZERO, 1
2355:                #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
2356:                #if _FS_TINY
2357:                				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
9D001D4C  90A20004   LBU V0, 4(A1)
9D001D50  50400026   BEQL V0, ZERO, 0x9D001DEC
9D001D54  00118A40   SLL S1, S1, 9
9D001D58  8CA2002C   LW V0, 44(A1)
9D001D5C  005EF023   SUBU S8, V0, S8
9D001D60  03D1102B   SLTU V0, S8, S1
9D001D64  50400021   BEQL V0, ZERO, 0x9D001DEC
9D001D68  00118A40   SLL S1, S1, 9
2358:                				mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
9D001D6C  001EF240   SLL S8, S8, 9
9D001D70  029E2021   ADDU A0, S4, S8
9D001D74  24A50030   ADDIU A1, A1, 48
9D001D78  0F400008   JAL 0x9D000020
9D001D7C  24060200   ADDIU A2, ZERO, 512
2359:                #else
2360:                				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
2361:                					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf,
2362:                							SS(fp->fs));
2363:                #endif
2364:                #endif
2365:                				rcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2366:                				continue;
9D001D80  0B40077B   J 0x9D001DEC
9D001D84  00118A40   SLL S1, S1, 9
2367:                			}
2368:                #if !_FS_TINY
2369:                			if (fp->dsect != sect) { /* Load data sector if not in cache */
2370:                #if !_FS_READONLY
2371:                				if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2372:                					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2373:                							!= RES_OK)
2374:                						ABORT(fp->fs, FR_DISK_ERR);
2375:                					fp->flag &= ~FA__DIRTY;
2376:                				}
2377:                #endif
2378:                				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK) /* Fill sector cache */
2379:                					ABORT(fp->fs, FR_DISK_ERR);
2380:                			}
2381:                #endif
2382:                			fp->dsect = sect;
9D001D88  AE1E0018   SW S8, 24(S0)
2383:                		}
2384:                		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs)); /* Get partial sector data from sector buffer */
9D001D8C  8E110008   LW S1, 8(S0)
9D001DBC  24020200   ADDIU V0, ZERO, 512
9D001DC0  00518823   SUBU S1, V0, S1
9D001DC4  0232102B   SLTU V0, S1, S2
9D001DC8  0242880A   MOVZ S1, S2, V0
2385:                		if (rcnt > btr)
2386:                			rcnt = btr;
2387:                #if _FS_TINY
2388:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D001D90  8E040000   LW A0, 0(S0)
9D001D94  0F400082   JAL 0x9D000208
9D001D98  8E050018   LW A1, 24(S0)
9D001D9C  10400007   BEQ V0, ZERO, 0x9D001DBC
9D001DA0  323101FF   ANDI S1, S1, 511
2389:                		ABORT(fp->fs, FR_DISK_ERR);
9D001DA4  92030006   LBU V1, 6(S0)
9D001DA8  2402FF80   ADDIU V0, ZERO, -128
9D001DAC  00621025   OR V0, V1, V0
9D001DB0  A2020006   SB V0, 6(S0)
9D001DB4  0B400786   J 0x9D001E18
9D001DB8  24170001   ADDIU S7, ZERO, 1
2390:                		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
9D001DCC  8E050000   LW A1, 0(S0)
9D001DD0  24A50030   ADDIU A1, A1, 48
9D001DD4  8E020008   LW V0, 8(S0)
9D001DD8  304201FF   ANDI V0, V0, 511
9D001DDC  02802021   ADDU A0, S4, ZERO
9D001DE0  00A22821   ADDU A1, A1, V0
9D001DE4  0F400008   JAL 0x9D000020
9D001DE8  02203021   ADDU A2, S1, ZERO
2391:                #else
2392:                		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
2393:                #endif
2394:                	}
2395:                
2396:                	LEAVE_FF(fp->fs, FR_OK);
2397:                }
9D001E18  02E01021   ADDU V0, S7, ZERO
9D001E1C  8FBF0034   LW RA, 52(SP)
9D001E20  8FBE0030   LW S8, 48(SP)
9D001E24  8FB7002C   LW S7, 44(SP)
9D001E28  8FB60028   LW S6, 40(SP)
9D001E2C  8FB50024   LW S5, 36(SP)
9D001E30  8FB40020   LW S4, 32(SP)
9D001E34  8FB3001C   LW S3, 28(SP)
9D001E38  8FB20018   LW S2, 24(SP)
9D001E3C  8FB10014   LW S1, 20(SP)
9D001E40  8FB00010   LW S0, 16(SP)
9D001E44  03E00008   JR RA
9D001E48  27BD0038   ADDIU SP, SP, 56
2398:                
2399:                #if !_FS_READONLY
2400:                /*-----------------------------------------------------------------------*/
2401:                /* Write File                                                            */
2402:                /*-----------------------------------------------------------------------*/
2403:                
2404:                FRESULT f_write(FIL *fp, /* Pointer to the file object */
2405:                                const void *buff, /* Pointer to the data to be written */
2406:                                UINT btw, /* Number of bytes to write */
2407:                                UINT *bw /* Pointer to number of bytes written */
2408:                                ) {
9D001E4C  27BDFFC8   ADDIU SP, SP, -56
9D001E50  AFBF0034   SW RA, 52(SP)
9D001E54  AFBE0030   SW S8, 48(SP)
9D001E58  AFB7002C   SW S7, 44(SP)
9D001E5C  AFB60028   SW S6, 40(SP)
9D001E60  AFB50024   SW S5, 36(SP)
9D001E64  AFB40020   SW S4, 32(SP)
9D001E68  AFB3001C   SW S3, 28(SP)
9D001E6C  AFB20018   SW S2, 24(SP)
9D001E70  AFB10014   SW S1, 20(SP)
9D001E74  AFB00010   SW S0, 16(SP)
9D001E78  00808021   ADDU S0, A0, ZERO
9D001E7C  00A0A021   ADDU S4, A1, ZERO
9D001E80  00C08821   ADDU S1, A2, ZERO
9D001E84  00E09821   ADDU S3, A3, ZERO
2409:                	FRESULT res;
2410:                	DWORD clst, sect;
2411:                	UINT wcnt, cc;
2412:                	const PF_BYTE *wbuff = buff;
2413:                	PF_BYTE csect;
2414:                
2415:                	*bw = 0; /* Initialize byte counter */
9D001E88  ACE00000   SW ZERO, 0(A3)
2416:                
2417:                	res = validate(fp->fs, fp->id); /* Check validity */
9D001E8C  8C840000   LW A0, 0(A0)
9D001E90  0F400143   JAL 0x9D00050C
9D001E94  96050004   LHU A1, 4(S0)
2418:                	if (res != FR_OK)
9D001E98  144000BA   BNE V0, ZERO, 0x9D002184
9D001E9C  0040B821   ADDU S7, V0, ZERO
2419:                		LEAVE_FF(fp->fs, res);
2420:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D001EA0  92020006   LBU V0, 6(S0)
9D001EA4  7C021C20   SEB V1, V0
9D001EA8  046000B5   BLTZ V1, 0x9D002180
9D001EAC  30420002   ANDI V0, V0, 2
2421:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2422:                	if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D001EB0  504000B4   BEQL V0, ZERO, 0x9D002184
9D001EB4  24170007   ADDIU S7, ZERO, 7
2423:                		LEAVE_FF(fp->fs, FR_DENIED);
2424:                	if ((DWORD) (fp->fsize + btw) < fp->fsize)
9D001EB8  8E02000C   LW V0, 12(S0)
9D001EBC  02221821   ADDU V1, S1, V0
9D001EC0  0062102B   SLTU V0, V1, V0
9D001EC4  544000A6   BNEL V0, ZERO, 0x9D002160
9D001EC8  8E020008   LW V0, 8(S0)
2425:                		btw = 0; /* File size cannot reach 4GB */
2426:                
2427:                	for (; btw; /* Repeat until all data written */
9D001ECC  522000A4   BEQL S1, ZERO, 0x9D002160
9D001ED0  8E020008   LW V0, 8(S0)
9D00214C  12200003   BEQ S1, ZERO, 0x9D00215C
9D002150  AE620000   SW V0, 0(S3)
2428:                	wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
9D002134  8E020008   LW V0, 8(S0)
9D002138  00521021   ADDU V0, V0, S2
9D00213C  AE020008   SW V0, 8(S0)
9D002140  8E620000   LW V0, 0(S3)
9D002144  00521021   ADDU V0, V0, S2
9D002148  02328823   SUBU S1, S1, S2
9D002154  0B4007B5   J 0x9D001ED4
9D002158  0292A021   ADDU S4, S4, S2
2429:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D001ED4  8E050008   LW A1, 8(S0)
9D001ED8  30A201FF   ANDI V0, A1, 511
9D001EDC  5440007B   BNEL V0, ZERO, 0x9D0020CC
9D001EE0  8E120008   LW S2, 8(S0)
2430:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D001EE4  8E040000   LW A0, 0(S0)
9D001EE8  00051242   SRL V0, A1, 9
9D001EEC  90950002   LBU S5, 2(A0)
9D001EF0  26B5FFFF   ADDIU S5, S5, -1
9D001EF4  0055A824   AND S5, V0, S5
9D001EF8  32B500FF   ANDI S5, S5, 255
2431:                			if (!csect) { /* On the cluster boundary? */
9D001EFC  56A00026   BNEL S5, ZERO, 0x9D001F98
9D001F00  8C83002C   LW V1, 44(A0)
2432:                				if (fp->fptr == 0) { /* On the top of the file? */
9D001F04  54A00008   BNEL A1, ZERO, 0x9D001F28
9D001F08  8E020024   LW V0, 36(S0)
2433:                					clst = fp->sclust; /* Follow from the origin */
9D001F0C  8E020010   LW V0, 16(S0)
2434:                					if (clst == 0) /* When no cluster is allocated, */
9D001F10  1440000F   BNE V0, ZERO, 0x9D001F50
9D001F14  24030001   ADDIU V1, ZERO, 1
2435:                						fp->sclust = clst = create_chain(fp->fs, 0); /* Create a new cluster chain */
9D001F18  0F4002A1   JAL 0x9D000A84
9D001F1C  00000000   NOP
9D001F20  0B4007D2   J 0x9D001F48
9D001F24  AE020010   SW V0, 16(S0)
2436:                				} else { /* Middle or end of the file */
2437:                #if _USE_FASTSEEK
2438:                					if (fp->cltbl)
9D001F28  10400005   BEQ V0, ZERO, 0x9D001F40
9D001F2C  00000000   NOP
2439:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D001F30  0F40001B   JAL 0x9D00006C
9D001F34  02002021   ADDU A0, S0, ZERO
9D001F38  0B4007D2   J 0x9D001F48
9D001F3C  00000000   NOP
2440:                					else
2441:                #endif
2442:                						clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
9D001F40  0F4002A1   JAL 0x9D000A84
9D001F44  8E050014   LW A1, 20(S0)
2443:                				}
2444:                				if (clst == 0)
9D001F48  10400084   BEQ V0, ZERO, 0x9D00215C
9D001F4C  24030001   ADDIU V1, ZERO, 1
2445:                					break; /* Could not allocate a new cluster (disk full) */
2446:                				if (clst == 1)
9D001F50  14430007   BNE V0, V1, 0x9D001F70
9D001F54  2403FFFF   ADDIU V1, ZERO, -1
2447:                					ABORT(fp->fs, FR_INT_ERR);
9D001F58  92030006   LBU V1, 6(S0)
9D001F5C  2402FF80   ADDIU V0, ZERO, -128
9D001F60  00621025   OR V0, V1, V0
9D001F64  A2020006   SB V0, 6(S0)
9D001F68  0B400861   J 0x9D002184
9D001F6C  24170002   ADDIU S7, ZERO, 2
2448:                				if (clst == 0xFFFFFFFF)
9D001F70  54430007   BNEL V0, V1, 0x9D001F90
9D001F74  AE020014   SW V0, 20(S0)
2449:                					ABORT(fp->fs, FR_DISK_ERR);
9D001F78  92030006   LBU V1, 6(S0)
9D001F7C  2402FF80   ADDIU V0, ZERO, -128
9D001F80  00621025   OR V0, V1, V0
9D001F84  A2020006   SB V0, 6(S0)
9D001F88  0B400861   J 0x9D002184
9D001F8C  24170001   ADDIU S7, ZERO, 1
2450:                				fp->clust = clst; /* Update current cluster */
2451:                			}
2452:                #if _FS_TINY
2453:                			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0)) /* Write-back sector cache */
9D001F90  8E040000   LW A0, 0(S0)
9D001F94  8C83002C   LW V1, 44(A0)
9D001F98  8E020018   LW V0, 24(S0)
9D001F9C  5462000B   BNEL V1, V0, 0x9D001FCC
9D001FA0  8E160000   LW S6, 0(S0)
9D001FA4  0F400082   JAL 0x9D000208
9D001FA8  00002821   ADDU A1, ZERO, ZERO
9D001FAC  50400007   BEQL V0, ZERO, 0x9D001FCC
9D001FB0  8E160000   LW S6, 0(S0)
2454:                			ABORT(fp->fs, FR_DISK_ERR);
9D001FB4  92030006   LBU V1, 6(S0)
9D001FB8  2402FF80   ADDIU V0, ZERO, -128
9D001FBC  00621025   OR V0, V1, V0
9D001FC0  A2020006   SB V0, 6(S0)
9D001FC4  0B400861   J 0x9D002184
9D001FC8  24170001   ADDIU S7, ZERO, 1
2455:                #else
2456:                			if (fp->flag & FA__DIRTY) { /* Write-back sector cache */
2457:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2458:                					ABORT(fp->fs, FR_DISK_ERR);
2459:                				fp->flag &= ~FA__DIRTY;
2460:                			}
2461:                #endif
2462:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D001FCC  02C02021   ADDU A0, S6, ZERO
9D001FD0  0F400156   JAL clust2sect
9D001FD4  8E050014   LW A1, 20(S0)
2463:                			if (!sect)
9D001FD8  14400007   BNE V0, ZERO, 0x9D001FF8
9D001FDC  00119242   SRL S2, S1, 9
2464:                				ABORT(fp->fs, FR_INT_ERR);
9D001FE0  92030006   LBU V1, 6(S0)
9D001FE4  2402FF80   ADDIU V0, ZERO, -128
9D001FE8  00621025   OR V0, V1, V0
9D001FEC  A2020006   SB V0, 6(S0)
9D001FF0  0B400861   J 0x9D002184
9D001FF4  24170002   ADDIU S7, ZERO, 2
2465:                			sect += csect;
2466:                			cc = btw / SS(fp->fs); /* When remaining bytes >= sector size, */
2467:                			if (cc) { /* Write maximum contiguous sectors directly */
9D001FF8  12400021   BEQ S2, ZERO, 0x9D002080
9D001FFC  0055F021   ADDU S8, V0, S5
2468:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D002000  92C20002   LBU V0, 2(S6)
9D002004  02551821   ADDU V1, S2, S5
9D002008  0043182B   SLTU V1, V0, V1
2469:                					cc = fp->fs->csize - csect;
9D00200C  0055A823   SUBU S5, V0, S5
9D002010  02A3900B   MOVN S2, S5, V1
2470:                				if (disk_write(fp->fs->drv, wbuff, sect, (PF_BYTE) cc)
9D002014  92C40001   LBU A0, 1(S6)
9D002018  02802821   ADDU A1, S4, ZERO
9D00201C  03C03021   ADDU A2, S8, ZERO
9D002020  0F401B4F   JAL disk_write
9D002024  324700FF   ANDI A3, S2, 255
9D002028  50400007   BEQL V0, ZERO, 0x9D002048
9D00202C  8E040000   LW A0, 0(S0)
2471:                						!= RES_OK)
2472:                					ABORT(fp->fs, FR_DISK_ERR);
9D002030  92030006   LBU V1, 6(S0)
9D002034  2402FF80   ADDIU V0, ZERO, -128
9D002038  00621025   OR V0, V1, V0
9D00203C  A2020006   SB V0, 6(S0)
9D002040  0B400861   J 0x9D002184
9D002044  24170001   ADDIU S7, ZERO, 1
2473:                #if _FS_TINY
2474:                				if (fp->fs->winsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
9D002048  8C82002C   LW V0, 44(A0)
9D00204C  005EF023   SUBU S8, V0, S8
9D002050  03D2102B   SLTU V0, S8, S2
9D002054  50400037   BEQL V0, ZERO, 0x9D002134
9D002058  00129240   SLL S2, S2, 9
2475:                					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
9D00205C  001EF240   SLL S8, S8, 9
9D002060  24840030   ADDIU A0, A0, 48
9D002064  029E2821   ADDU A1, S4, S8
9D002068  0F400008   JAL 0x9D000020
9D00206C  24060200   ADDIU A2, ZERO, 512
2476:                					fp->fs->wflag = 0;
9D002070  8E020000   LW V0, 0(S0)
9D002074  A0400004   SB ZERO, 4(V0)
2477:                				}
2478:                #else
2479:                				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
2480:                					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)),
2481:                							SS(fp->fs));
2482:                					fp->flag &= ~FA__DIRTY;
2483:                				}
2484:                #endif
2485:                				wcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2486:                				continue;
9D002078  0B40084D   J 0x9D002134
9D00207C  00129240   SLL S2, S2, 9
2487:                			}
2488:                #if _FS_TINY
2489:                			if (fp->fptr >= fp->fsize) { /* Avoid silly cache filling at growing edge */
9D002080  8E030008   LW V1, 8(S0)
9D002084  8E02000C   LW V0, 12(S0)
9D002088  0062102B   SLTU V0, V1, V0
9D00208C  5440000E   BNEL V0, ZERO, 0x9D0020C8
9D002090  AE1E0018   SW S8, 24(S0)
2490:                				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
9D002094  02C02021   ADDU A0, S6, ZERO
9D002098  0F400082   JAL 0x9D000208
9D00209C  00002821   ADDU A1, ZERO, ZERO
9D0020A0  50400007   BEQL V0, ZERO, 0x9D0020C0
9D0020A4  8E020000   LW V0, 0(S0)
9D0020A8  92030006   LBU V1, 6(S0)
9D0020AC  2402FF80   ADDIU V0, ZERO, -128
9D0020B0  00621025   OR V0, V1, V0
9D0020B4  A2020006   SB V0, 6(S0)
9D0020B8  0B400861   J 0x9D002184
9D0020BC  24170001   ADDIU S7, ZERO, 1
2491:                				fp->fs->winsect = sect;
9D0020C0  AC5E002C   SW S8, 44(V0)
2492:                			}
2493:                #else
2494:                			if (fp->dsect != sect) { /* Fill sector cache with file data */
2495:                				if (fp->fptr < fp->fsize && disk_read(fp->fs->drv, fp->buf,
2496:                						sect, 1) != RES_OK)
2497:                					ABORT(fp->fs, FR_DISK_ERR);
2498:                			}
2499:                #endif
2500:                			fp->dsect = sect;
9D0020C4  AE1E0018   SW S8, 24(S0)
2501:                		}
2502:                		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
9D0020C8  8E120008   LW S2, 8(S0)
9D0020F8  24020200   ADDIU V0, ZERO, 512
9D0020FC  00529023   SUBU S2, V0, S2
9D002100  0251102B   SLTU V0, S2, S1
9D002104  0222900A   MOVZ S2, S1, V0
2503:                		if (wcnt > btw)
2504:                			wcnt = btw;
2505:                #if _FS_TINY
2506:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D0020CC  8E040000   LW A0, 0(S0)
9D0020D0  0F400082   JAL 0x9D000208
9D0020D4  8E050018   LW A1, 24(S0)
9D0020D8  10400007   BEQ V0, ZERO, 0x9D0020F8
9D0020DC  325201FF   ANDI S2, S2, 511
2507:                		ABORT(fp->fs, FR_DISK_ERR);
9D0020E0  92030006   LBU V1, 6(S0)
9D0020E4  2402FF80   ADDIU V0, ZERO, -128
9D0020E8  00621025   OR V0, V1, V0
9D0020EC  A2020006   SB V0, 6(S0)
9D0020F0  0B400861   J 0x9D002184
9D0020F4  24170001   ADDIU S7, ZERO, 1
2508:                		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
9D002108  8E040000   LW A0, 0(S0)
9D00210C  24840030   ADDIU A0, A0, 48
9D002110  8E020008   LW V0, 8(S0)
9D002114  304201FF   ANDI V0, V0, 511
9D002118  00822021   ADDU A0, A0, V0
9D00211C  02802821   ADDU A1, S4, ZERO
9D002120  0F400008   JAL 0x9D000020
9D002124  02403021   ADDU A2, S2, ZERO
2509:                		fp->fs->wflag = 1;
9D002128  8E020000   LW V0, 0(S0)
9D00212C  24030001   ADDIU V1, ZERO, 1
9D002130  A0430004   SB V1, 4(V0)
2510:                #else
2511:                		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
2512:                		fp->flag |= FA__DIRTY;
2513:                #endif
2514:                	}
2515:                
2516:                	if (fp->fptr > fp->fsize)
9D00215C  8E020008   LW V0, 8(S0)
9D002160  8E03000C   LW V1, 12(S0)
9D002164  0062182B   SLTU V1, V1, V0
9D002168  54600001   BNEL V1, ZERO, 0x9D002170
9D00216C  AE02000C   SW V0, 12(S0)
2517:                		fp->fsize = fp->fptr; /* Update file size if needed */
2518:                	fp->flag |= FA__WRITTEN; /* Set file change flag */
9D002170  92020006   LBU V0, 6(S0)
9D002174  34420020   ORI V0, V0, 32
2519:                
2520:                	LEAVE_FF(fp->fs, FR_OK);
9D002178  0B400861   J 0x9D002184
9D00217C  A2020006   SB V0, 6(S0)
9D002180  24170002   ADDIU S7, ZERO, 2
2521:                }
9D002184  02E01021   ADDU V0, S7, ZERO
9D002188  8FBF0034   LW RA, 52(SP)
9D00218C  8FBE0030   LW S8, 48(SP)
9D002190  8FB7002C   LW S7, 44(SP)
9D002194  8FB60028   LW S6, 40(SP)
9D002198  8FB50024   LW S5, 36(SP)
9D00219C  8FB40020   LW S4, 32(SP)
9D0021A0  8FB3001C   LW S3, 28(SP)
9D0021A4  8FB20018   LW S2, 24(SP)
9D0021A8  8FB10014   LW S1, 20(SP)
9D0021AC  8FB00010   LW S0, 16(SP)
9D0021B0  03E00008   JR RA
9D0021B4  27BD0038   ADDIU SP, SP, 56
2522:                
2523:                /*-----------------------------------------------------------------------*/
2524:                /* Synchronize the File Object                                           */
2525:                /*-----------------------------------------------------------------------*/
2526:                
2527:                FRESULT f_sync(FIL *fp /* Pointer to the file object */
2528:                ) {
9D0021B8  27BDFFE0   ADDIU SP, SP, -32
9D0021BC  AFBF001C   SW RA, 28(SP)
9D0021C0  AFB10018   SW S1, 24(SP)
9D0021C4  AFB00014   SW S0, 20(SP)
9D0021C8  00808021   ADDU S0, A0, ZERO
2529:                	FRESULT res;
2530:                	DWORD tim;
2531:                	PF_BYTE *dir;
2532:                
2533:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D0021CC  8C840000   LW A0, 0(A0)
9D0021D0  0F400143   JAL 0x9D00050C
9D0021D4  96050004   LHU A1, 4(S0)
2534:                	if (res == FR_OK) {
9D0021D8  14400032   BNE V0, ZERO, 0x9D0022A4
9D0021DC  8FBF001C   LW RA, 28(SP)
2535:                		if (fp->flag & FA__WRITTEN) { /* Has the file been written? */
9D0021E0  92030006   LBU V1, 6(S0)
9D0021E4  30630020   ANDI V1, V1, 32
9D0021E8  1060002F   BEQ V1, ZERO, 0x9D0022A8
9D0021EC  8FB10018   LW S1, 24(SP)
2536:                #if !_FS_TINY	/* Write-back dirty buffer */
2537:                			if (fp->flag & FA__DIRTY) {
2538:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2539:                					LEAVE_FF(fp->fs, FR_DISK_ERR);
2540:                				fp->flag &= ~FA__DIRTY;
2541:                			}
2542:                #endif
2543:                			/* Update the directory entry */
2544:                			res = move_window(fp->fs, fp->dir_sect);
9D0021F0  8E040000   LW A0, 0(S0)
9D0021F4  0F400082   JAL 0x9D000208
9D0021F8  8E05001C   LW A1, 28(S0)
2545:                			if (res == FR_OK) {
9D0021FC  14400029   BNE V0, ZERO, 0x9D0022A4
9D002200  8FBF001C   LW RA, 28(SP)
2546:                				dir = fp->dir_ptr;
9D002204  8E110020   LW S1, 32(S0)
2547:                				dir[DIR_Attr] |= AM_ARC; /* Set archive bit */
9D002208  9222000B   LBU V0, 11(S1)
9D00220C  34420020   ORI V0, V0, 32
9D002210  A222000B   SB V0, 11(S1)
2548:                				ST_DWORD(dir+DIR_FileSize, fp->fsize); /* Update file size */
9D002214  8E02000C   LW V0, 12(S0)
9D002218  A222001C   SB V0, 28(S1)
9D00221C  9602000C   LHU V0, 12(S0)
9D002220  00021202   SRL V0, V0, 8
9D002224  A222001D   SB V0, 29(S1)
9D002228  9602000E   LHU V0, 14(S0)
9D00222C  A222001E   SB V0, 30(S1)
9D002230  9202000F   LBU V0, 15(S0)
9D002234  A222001F   SB V0, 31(S1)
2549:                				ST_CLUST(dir, fp->sclust); /* Update start cluster */
9D002238  8E020010   LW V0, 16(S0)
9D00223C  A222001A   SB V0, 26(S1)
9D002240  96020010   LHU V0, 16(S0)
9D002244  00021202   SRL V0, V0, 8
9D002248  A222001B   SB V0, 27(S1)
9D00224C  96020012   LHU V0, 18(S0)
9D002250  A2220014   SB V0, 20(S1)
9D002254  96020012   LHU V0, 18(S0)
9D002258  00021202   SRL V0, V0, 8
2550:                				tim = get_fattime(); /* Update updated time */
9D00225C  0F401C74   JAL get_fattime
9D002260  A2220015   SB V0, 21(S1)
2551:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D002264  A2220016   SB V0, 22(S1)
9D002268  7C433A00   EXT V1, V0, 8, 8
9D00226C  A2230017   SB V1, 23(S1)
9D002270  00021C02   SRL V1, V0, 16
9D002274  A2230018   SB V1, 24(S1)
9D002278  00021602   SRL V0, V0, 24
9D00227C  A2220019   SB V0, 25(S1)
2552:                				fp->flag &= ~FA__WRITTEN;
9D002280  92020006   LBU V0, 6(S0)
9D002284  304200DF   ANDI V0, V0, 223
9D002288  A2020006   SB V0, 6(S0)
2553:                				fp->fs->wflag = 1;
9D00228C  8E020000   LW V0, 0(S0)
9D002290  24030001   ADDIU V1, ZERO, 1
9D002294  A0430004   SB V1, 4(V0)
2554:                				res = sync(fp->fs);
9D002298  0F4000F9   JAL 0x9D0003E4
9D00229C  8E040000   LW A0, 0(S0)
2555:                			}
2556:                		}
2557:                	}
2558:                
2559:                	LEAVE_FF(fp->fs, res);
2560:                }
9D0022A0  8FBF001C   LW RA, 28(SP)
9D0022A4  8FB10018   LW S1, 24(SP)
9D0022A8  8FB00014   LW S0, 20(SP)
9D0022AC  03E00008   JR RA
9D0022B0  27BD0020   ADDIU SP, SP, 32
2561:                
2562:                #endif /* !_FS_READONLY */
2563:                
2564:                /*-----------------------------------------------------------------------*/
2565:                /* Close File                                                            */
2566:                /*-----------------------------------------------------------------------*/
2567:                
2568:                FRESULT f_close(FIL *fp /* Pointer to the file object to be closed */
2569:                ) {
9D0022B4  27BDFFE8   ADDIU SP, SP, -24
9D0022B8  AFBF0014   SW RA, 20(SP)
9D0022BC  AFB00010   SW S0, 16(SP)
2570:                	FRESULT res;
2571:                
2572:                #if _FS_READONLY
2573:                	FATFS *fs = fp->fs;
2574:                	res = validate(fs, fp->id);
2575:                	if (res == FR_OK) fp->fs = 0; /* Discard file object */
2576:                	LEAVE_FF(fs, res);
2577:                
2578:                #else
2579:                	res = f_sync(fp); /* Flush cached data */
9D0022C0  0F40086E   JAL f_sync
9D0022C4  00808021   ADDU S0, A0, ZERO
2580:                #if _FS_SHARE
2581:                	if (res == FR_OK) { /* Decrement open counter */
2582:                #if _FS_REENTRANT
2583:                		res = validate(fp->fs, fp->id);
2584:                		if (res == FR_OK) {
2585:                			res = dec_lock(fp->lockid);
2586:                			unlock_fs(fp->fs, FR_OK);
2587:                		}
2588:                #else
2589:                		res = dec_lock(fp->lockid);
2590:                #endif
2591:                	}
2592:                #endif
2593:                	if (res == FR_OK)
9D0022C8  50400001   BEQL V0, ZERO, 0x9D0022D0
9D0022CC  AE000000   SW ZERO, 0(S0)
2594:                		fp->fs = 0; /* Discard file object */
2595:                	return res;
2596:                #endif
2597:                }
9D0022D0  8FBF0014   LW RA, 20(SP)
9D0022D4  8FB00010   LW S0, 16(SP)
9D0022D8  03E00008   JR RA
9D0022DC  27BD0018   ADDIU SP, SP, 24
2598:                
2599:                /*-----------------------------------------------------------------------*/
2600:                /* Current Drive/Directory Handlings                                     */
2601:                /*-----------------------------------------------------------------------*/
2602:                
2603:                #if _FS_RPATH >= 1
2604:                
2605:                FRESULT f_chdrive (
2606:                		PF_BYTE drv /* Drive number */
2607:                )
2608:                {
2609:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
2610:                
2611:                	CurrVol = drv;
2612:                
2613:                	return FR_OK;
2614:                }
2615:                
2616:                FRESULT f_chdir (
2617:                		const TCHAR *path /* Pointer to the directory path */
2618:                )
2619:                {
2620:                	FRESULT res;
2621:                	DIR dj;
2622:                	DEF_NAMEBUF;
2623:                
2624:                	res = chk_mounted(&path, &dj.fs, 0);
2625:                	if (res == FR_OK) {
2626:                		INIT_BUF(dj);
2627:                		res = follow_path(&dj, path); /* Follow the path */
2628:                		FREE_BUF();
2629:                		if (res == FR_OK) { /* Follow completed */
2630:                			if (!dj.dir) {
2631:                				dj.fs->cdir = dj.sclust; /* Start directory itself */
2632:                			} else {
2633:                				if (dj.dir[DIR_Attr] & AM_DIR) /* Reached to the directory */
2634:                				dj.fs->cdir = LD_CLUST(dj.dir);
2635:                				else
2636:                				res = FR_NO_PATH; /* Reached but a file */
2637:                			}
2638:                		}
2639:                		if (res == FR_NO_FILE) res = FR_NO_PATH;
2640:                	}
2641:                
2642:                	LEAVE_FF(dj.fs, res);
2643:                }
2644:                
2645:                #if _FS_RPATH >= 2
2646:                FRESULT f_getcwd (
2647:                		TCHAR *path, /* Pointer to the directory path */
2648:                		UINT sz_path /* Size of path */
2649:                )
2650:                {
2651:                	FRESULT res;
2652:                	DIR dj;
2653:                	UINT i, n;
2654:                	DWORD ccl;
2655:                	TCHAR *tp;
2656:                	FILINFO fno;
2657:                	DEF_NAMEBUF;
2658:                
2659:                	*path = 0;
2660:                	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0); /* Get current volume */
2661:                	if (res == FR_OK) {
2662:                		INIT_BUF(dj);
2663:                		i = sz_path; /* Bottom of buffer (dir stack base) */
2664:                		dj.sclust = dj.fs->cdir; /* Start to follow upper dir from current dir */
2665:                		while ((ccl = dj.sclust) != 0) { /* Repeat while current dir is a sub-dir */
2666:                			res = dir_sdi(&dj, 1); /* Get parent dir */
2667:                			if (res != FR_OK) break;
2668:                			res = dir_read(&dj);
2669:                			if (res != FR_OK) break;
2670:                			dj.sclust = LD_CLUST(dj.dir); /* Goto parent dir */
2671:                			res = dir_sdi(&dj, 0);
2672:                			if (res != FR_OK) break;
2673:                			do { /* Find the entry links to the child dir */
2674:                				res = dir_read(&dj);
2675:                				if (res != FR_OK) break;
2676:                				if (ccl == LD_CLUST(dj.dir)) break; /* Found the entry */
2677:                				res = dir_next(&dj, 0);
2678:                			}while (res == FR_OK);
2679:                			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
2680:                			if (res != FR_OK) break;
2681:                #if _USE_LFN
2682:                			fno.lfname = path;
2683:                			fno.lfsize = i;
2684:                #endif
2685:                			get_fileinfo(&dj, &fno); /* Get the dir name and push it to the buffer */
2686:                			tp = fno.fname;
2687:                			if (_USE_LFN && *path) tp = path;
2688:                			for (n = 0; tp[n]; n++);
2689:                			if (i < n + 3) {
2690:                				res = FR_NOT_ENOUGH_CORE; break;
2691:                			}
2692:                			while (n) path[--i] = tp[--n];
2693:                			path[--i] = '/';
2694:                		}
2695:                		tp = path;
2696:                		if (res == FR_OK) {
2697:                			*tp++ = '0' + CurrVol; /* Put drive number */
2698:                			*tp++ = ':';
2699:                			if (i == sz_path) { /* Root-dir */
2700:                				*tp++ = '/';
2701:                			} else { /* Sub-dir */
2702:                				do /* Add stacked path str */
2703:                				*tp++ = path[i++];
2704:                				while (i < sz_path);
2705:                			}
2706:                		}
2707:                		*tp = 0;
2708:                		FREE_BUF();
2709:                	}
2710:                
2711:                	LEAVE_FF(dj.fs, res);
2712:                }
2713:                #endif /* _FS_RPATH >= 2 */
2714:                #endif /* _FS_RPATH >= 1 */
2715:                
2716:                #if _FS_MINIMIZE <= 2
2717:                /*-----------------------------------------------------------------------*/
2718:                /* Seek File R/W Pointer                                                 */
2719:                /*-----------------------------------------------------------------------*/
2720:                
2721:                FRESULT f_lseek(FIL *fp, /* Pointer to the file object */
9D00257C  02539023   SUBU S2, S2, S3
9D002580  2414FFFF   ADDIU S4, ZERO, -1
2722:                                DWORD ofs /* File pointer from top of file */
2723:                                ) {
9D0022E0  27BDFFC8   ADDIU SP, SP, -56
9D0022E4  AFBF0034   SW RA, 52(SP)
9D0022E8  AFBE0030   SW S8, 48(SP)
9D0022EC  AFB7002C   SW S7, 44(SP)
9D0022F0  AFB60028   SW S6, 40(SP)
9D0022F4  AFB50024   SW S5, 36(SP)
9D0022F8  AFB40020   SW S4, 32(SP)
9D0022FC  AFB3001C   SW S3, 28(SP)
9D002300  AFB20018   SW S2, 24(SP)
9D002304  AFB10014   SW S1, 20(SP)
9D002308  AFB00010   SW S0, 16(SP)
9D00230C  00808021   ADDU S0, A0, ZERO
9D002310  00A09021   ADDU S2, A1, ZERO
2724:                	FRESULT res;
2725:                
2726:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D002314  8C840000   LW A0, 0(A0)
9D002318  0F400143   JAL 0x9D00050C
9D00231C  96050004   LHU A1, 4(S0)
2727:                	if (res != FR_OK)
9D002320  144000E5   BNE V0, ZERO, 0x9D0026B8
9D002324  00408821   ADDU S1, V0, ZERO
2728:                		LEAVE_FF(fp->fs, res);
2729:                	if (fp->flag & FA__ERROR) /* Check abort flag */
9D002328  92130006   LBU S3, 6(S0)
9D00232C  7C131420   SEB V0, S3
9D002330  044200E1   BLTZL V0, 0x9D0026B8
9D002334  24110002   ADDIU S1, ZERO, 2
2730:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2731:                
2732:                #if _USE_FASTSEEK
2733:                	if (fp->cltbl) { /* Fast seek */
9D002338  8E170024   LW S7, 36(S0)
9D00233C  12E00055   BEQ S7, ZERO, 0x9D002494
9D002340  2402FFFF   ADDIU V0, ZERO, -1
2734:                		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
2735:                
2736:                		if (ofs == CREATE_LINKMAP) { /* Create CLMT */
9D002344  56420034   BNEL S2, V0, 0x9D002418
9D002348  8E02000C   LW V0, 12(S0)
2737:                			tbl = fp->cltbl;
2738:                			tlen = *tbl++;
9D00234C  8EFE0000   LW S8, 0(S7)
9D002350  26F70004   ADDIU S7, S7, 4
2739:                			ulen = 2; /* Given table size and required table size */
9D002358  24150002   ADDIU S5, ZERO, 2
2740:                			cl = fp->sclust; /* Top of the chain */
9D002354  8E160010   LW S6, 16(S0)
2741:                			if (cl) {
9D00235C  16C00003   BNE S6, ZERO, 0x9D00236C
9D002360  2414FFFF   ADDIU S4, ZERO, -1
2742:                				do {
2743:                					/* Get a fragment */
2744:                					tcl = cl;
2745:                					ncl = 0;
9D002370  00009821   ADDU S3, ZERO, ZERO
2746:                					ulen += 2; /* Top, length and used items */
9D0023CC  26B50002   ADDIU S5, S5, 2
2747:                					do {
2748:                						pcl = cl;
2749:                						ncl++;
2750:                						cl = get_fat(fp->fs, cl);
9D00236C  02C09021   ADDU S2, S6, ZERO
9D002374  8E040000   LW A0, 0(S0)
9D002378  0F400162   JAL get_fat
9D00237C  02402821   ADDU A1, S2, ZERO
2751:                						if (cl <= 1)
9D002380  2C430002   SLTIU V1, V0, 2
9D002384  10600007   BEQ V1, ZERO, 0x9D0023A4
9D002388  00000000   NOP
2752:                							ABORT(fp->fs, FR_INT_ERR);
9D00238C  92030006   LBU V1, 6(S0)
9D002390  2402FF80   ADDIU V0, ZERO, -128
9D002394  00621025   OR V0, V1, V0
9D002398  A2020006   SB V0, 6(S0)
9D00239C  0B4009AE   J 0x9D0026B8
9D0023A0  24110002   ADDIU S1, ZERO, 2
2753:                						if (cl == 0xFFFFFFFF)
9D0023A4  14540007   BNE V0, S4, 0x9D0023C4
9D0023A8  26520001   ADDIU S2, S2, 1
2754:                							ABORT(fp->fs, FR_DISK_ERR);
9D0023AC  92030006   LBU V1, 6(S0)
9D0023B0  2402FF80   ADDIU V0, ZERO, -128
9D0023B4  00621025   OR V0, V1, V0
9D0023B8  A2020006   SB V0, 6(S0)
9D0023BC  0B4009AE   J 0x9D0026B8
9D0023C0  24110001   ADDIU S1, ZERO, 1
2755:                					} while (cl == pcl + 1);
9D0023C4  1242FFEB   BEQ S2, V0, 0x9D002374
9D0023C8  26730001   ADDIU S3, S3, 1
2756:                					if (ulen <= tlen) { /* Store the length and top of the fragment */
9D0023D0  03D5182B   SLTU V1, S8, S5
9D0023D4  54600005   BNEL V1, ZERO, 0x9D0023EC
9D0023D8  8E030000   LW V1, 0(S0)
2757:                						*tbl++ = ncl;
9D0023DC  AEF30000   SW S3, 0(S7)
2758:                						*tbl++ = tcl;
9D0023E0  AEF60004   SW S6, 4(S7)
9D0023E4  26F70008   ADDIU S7, S7, 8
2759:                					}
2760:                				} while (cl < fp->fs->n_fatent); /* Repeat until end of chain */
9D0023E8  8E030000   LW V1, 0(S0)
9D0023EC  8C630018   LW V1, 24(V1)
9D0023F0  0043182B   SLTU V1, V0, V1
9D0023F4  1460FFDD   BNE V1, ZERO, 0x9D00236C
9D0023F8  0040B021   ADDU S6, V0, ZERO
2761:                			}
2762:                			*fp->cltbl = ulen; /* Number of items used */
9D002364  0B400900   J 0x9D002400
9D002368  8E020024   LW V0, 36(S0)
9D0023FC  8E020024   LW V0, 36(S0)
9D002400  AC550000   SW S5, 0(V0)
2763:                			if (ulen <= tlen)
9D002404  03D5A82B   SLTU S5, S8, S5
9D002408  56A000AB   BNEL S5, ZERO, 0x9D0026B8
9D00240C  24110011   ADDIU S1, ZERO, 17
2764:                				*tbl = 0; /* Terminate table */
9D002410  0B4009AE   J 0x9D0026B8
9D002414  AEE00000   SW ZERO, 0(S7)
9D002418  0052182B   SLTU V1, V0, S2
9D00241C  0043900B   MOVN S2, V0, V1
2765:                			else
2766:                				res = FR_NOT_ENOUGH_CORE; /* Given table size is smaller than required */
2767:                
2768:                		} else { /* Fast seek */
2769:                			if (ofs > fp->fsize) /* Clip offset at the file size */
2770:                				ofs = fp->fsize;
2771:                			fp->fptr = ofs; /* Set file pointer */
2772:                			if (ofs) {
9D002420  124000A5   BEQ S2, ZERO, 0x9D0026B8
9D002424  AE120008   SW S2, 8(S0)
2773:                				fp->clust = clmt_clust(fp, ofs - 1);
9D002428  2655FFFF   ADDIU S5, S2, -1
9D00242C  02002021   ADDU A0, S0, ZERO
9D002430  0F40001B   JAL 0x9D00006C
9D002434  02A02821   ADDU A1, S5, ZERO
9D002438  AE020014   SW V0, 20(S0)
2774:                				dsc = clust2sect(fp->fs, fp->clust);
9D00243C  8E140000   LW S4, 0(S0)
9D002440  02802021   ADDU A0, S4, ZERO
9D002444  0F400156   JAL clust2sect
9D002448  00402821   ADDU A1, V0, ZERO
2775:                				if (!dsc)
9D00244C  14400006   BNE V0, ZERO, 0x9D002468
9D002450  325201FF   ANDI S2, S2, 511
2776:                					ABORT(fp->fs, FR_INT_ERR);
9D002454  2402FF80   ADDIU V0, ZERO, -128
9D002458  02629825   OR S3, S3, V0
9D00245C  A2130006   SB S3, 6(S0)
9D002460  0B4009AE   J 0x9D0026B8
9D002464  24110002   ADDIU S1, ZERO, 2
2777:                				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
9D002470  0015AA42   SRL S5, S5, 9
9D002474  2463FFFF   ADDIU V1, V1, -1
9D002478  02A31824   AND V1, S5, V1
9D00247C  00431021   ADDU V0, V0, V1
2778:                				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) { /* Refill sector cache if needed */
9D002468  12400093   BEQ S2, ZERO, 0x9D0026B8
9D00246C  92830002   LBU V1, 2(S4)
9D002480  8E030018   LW V1, 24(S0)
9D002484  5462008C   BNEL V1, V0, 0x9D0026B8
9D002488  AE020018   SW V0, 24(S0)
2779:                #if !_FS_TINY
2780:                #if !_FS_READONLY
2781:                					if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2782:                						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2783:                								!= RES_OK)
2784:                							ABORT(fp->fs, FR_DISK_ERR);
2785:                						fp->flag &= ~FA__DIRTY;
2786:                					}
2787:                #endif
2788:                					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK) /* Load current sector */
2789:                						ABORT(fp->fs, FR_DISK_ERR);
2790:                #endif
2791:                					fp->dsect = dsc;
2792:                				}
2793:                			}
2794:                		}
2795:                	} else
2796:                #endif
2797:                
2798:                	/* Normal Seek */
2799:                	{
2800:                		DWORD clst, bcs, nsect, ifptr;
2801:                
2802:                		if (ofs > fp->fsize /* In read-only mode, clip offset with the file size */
9D002494  8E02000C   LW V0, 12(S0)
9D002498  0052182B   SLTU V1, V0, S2
9D00249C  50600004   BEQL V1, ZERO, 0x9D0024B0
9D0024A0  8E020008   LW V0, 8(S0)
2803:                #if !_FS_READONLY
2804:                				&& !(fp->flag & FA_WRITE)
9D0024A4  32730002   ANDI S3, S3, 2
2805:                #endif
2806:                		)
2807:                			ofs = fp->fsize;
9D0024A8  0053900A   MOVZ S2, V0, S3
2808:                
2809:                		ifptr = fp->fptr;
9D0024AC  8E020008   LW V0, 8(S0)
2810:                		fp->fptr = nsect = 0;
2811:                		if (ofs) {
9D0024B0  12400081   BEQ S2, ZERO, 0x9D0026B8
9D0024B4  AE000008   SW ZERO, 8(S0)
2812:                			bcs = (DWORD) fp->fs->csize * SS(fp->fs); /* Cluster size (byte) */
9D0024B8  8E040000   LW A0, 0(S0)
9D0024BC  90930002   LBU S3, 2(A0)
2813:                			if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
9D0024C0  10400012   BEQ V0, ZERO, 0x9D00250C
9D0024C4  00139A40   SLL S3, S3, 9
9D0024C8  2442FFFF   ADDIU V0, V0, -1
9D0024CC  2643FFFF   ADDIU V1, S2, -1
9D0024D0  0073001B   DIVU V1, S3
9D0024D4  026001F4   TEQ S3, ZERO
9D0024D8  00001812   MFLO V1, 0
9D0024DC  0053001B   DIVU V0, S3
9D0024E0  026001F4   TEQ S3, ZERO
9D0024E4  00002812   MFLO A1, 0
9D0024E8  0065182B   SLTU V1, V1, A1
9D0024EC  54600008   BNEL V1, ZERO, 0x9D002510
9D0024F0  8E020010   LW V0, 16(S0)
2814:                				fp->fptr = (ifptr - 1) & ~(bcs - 1); /* start from the current cluster */
9D0024F4  00131823   SUBU V1, ZERO, S3
9D0024F8  00621024   AND V0, V1, V0
9D0024FC  AE020008   SW V0, 8(S0)
2815:                				ofs -= fp->fptr;
9D002500  02429023   SUBU S2, S2, V0
2816:                				clst = fp->clust;
9D002504  0B40095A   J 0x9D002568
9D002508  8E020014   LW V0, 20(S0)
2817:                			} else { /* When seek to back cluster, */
2818:                				clst = fp->sclust; /* start from the first cluster */
9D00250C  8E020010   LW V0, 16(S0)
2819:                #if !_FS_READONLY
2820:                				if (clst == 0) { /* If no cluster chain, create a new chain */
9D002510  54400015   BNEL V0, ZERO, 0x9D002568
9D002514  AE020014   SW V0, 20(S0)
2821:                					clst = create_chain(fp->fs, 0);
9D002518  0F4002A1   JAL 0x9D000A84
9D00251C  00002821   ADDU A1, ZERO, ZERO
2822:                					if (clst == 1)
9D002520  24030001   ADDIU V1, ZERO, 1
9D002524  14430007   BNE V0, V1, 0x9D002544
9D002528  2403FFFF   ADDIU V1, ZERO, -1
2823:                						ABORT(fp->fs, FR_INT_ERR);
9D00252C  92030006   LBU V1, 6(S0)
9D002530  2402FF80   ADDIU V0, ZERO, -128
9D002534  00621025   OR V0, V1, V0
9D002538  A2020006   SB V0, 6(S0)
9D00253C  0B4009AE   J 0x9D0026B8
9D002540  24110002   ADDIU S1, ZERO, 2
2824:                					if (clst == 0xFFFFFFFF)
9D002544  54430007   BNEL V0, V1, 0x9D002564
9D002548  AE020010   SW V0, 16(S0)
2825:                						ABORT(fp->fs, FR_DISK_ERR);
9D00254C  92030006   LBU V1, 6(S0)
9D002550  2402FF80   ADDIU V0, ZERO, -128
9D002554  00621025   OR V0, V1, V0
9D002558  A2020006   SB V0, 6(S0)
9D00255C  0B4009AE   J 0x9D0026B8
9D002560  24110001   ADDIU S1, ZERO, 1
2826:                					fp->sclust = clst;
2827:                				}
2828:                #endif
2829:                				fp->clust = clst;
9D002564  AE020014   SW V0, 20(S0)
2830:                			}
2831:                			if (clst != 0) {
9D002568  10400043   BEQ V0, ZERO, 0x9D002678
9D00256C  00001821   ADDU V1, ZERO, ZERO
2832:                				while (ofs > bcs) { /* Cluster following loop */
9D002570  0272182B   SLTU V1, S3, S2
9D002574  1060002E   BEQ V1, ZERO, 0x9D002630
9D002578  0013A823   SUBU S5, ZERO, S3
9D002618  00732021   ADDU A0, V1, S3
9D00261C  0264202B   SLTU A0, S3, A0
9D002620  5480FFD8   BNEL A0, ZERO, 0x9D002584
9D002624  00609021   ADDU S2, V1, ZERO
2833:                #if !_FS_READONLY
2834:                					if (fp->flag & FA_WRITE) { /* Check if in write mode or not */
9D002584  92030006   LBU V1, 6(S0)
9D002588  30630002   ANDI V1, V1, 2
9D00258C  10600007   BEQ V1, ZERO, 0x9D0025AC
9D002590  8E040000   LW A0, 0(S0)
2835:                						clst = create_chain(fp->fs, clst); /* Force stretch if in write mode */
9D002594  0F4002A1   JAL 0x9D000A84
9D002598  00402821   ADDU A1, V0, ZERO
2836:                						if (clst == 0) { /* When disk gets full, clip file size */
9D00259C  14400005   BNE V0, ZERO, 0x9D0025B4
9D0025A0  00000000   NOP
2837:                							ofs = bcs;
9D0025A4  0B40098C   J 0x9D002630
9D0025A8  02609021   ADDU S2, S3, ZERO
2838:                							break;
2839:                						}
2840:                					} else
2841:                #endif
2842:                						clst = get_fat(fp->fs, clst); /* Follow cluster chain if not in write mode */
9D0025AC  0F400162   JAL get_fat
9D0025B0  00402821   ADDU A1, V0, ZERO
2843:                					if (clst == 0xFFFFFFFF)
9D0025B4  14540007   BNE V0, S4, 0x9D0025D4
9D0025B8  2C430002   SLTIU V1, V0, 2
2844:                						ABORT(fp->fs, FR_DISK_ERR);
9D0025BC  92030006   LBU V1, 6(S0)
9D0025C0  2402FF80   ADDIU V0, ZERO, -128
9D0025C4  00621025   OR V0, V1, V0
9D0025C8  A2020006   SB V0, 6(S0)
9D0025CC  0B4009AE   J 0x9D0026B8
9D0025D0  24110001   ADDIU S1, ZERO, 1
2845:                					if (clst <= 1 || clst >= fp->fs->n_fatent)
9D0025D4  54600007   BNEL V1, ZERO, 0x9D0025F4
9D0025D8  92030006   LBU V1, 6(S0)
9D0025DC  8E030000   LW V1, 0(S0)
9D0025E0  8C630018   LW V1, 24(V1)
9D0025E4  0043182B   SLTU V1, V0, V1
9D0025E8  54600007   BNEL V1, ZERO, 0x9D002608
9D0025EC  AE020014   SW V0, 20(S0)
2846:                						ABORT(fp->fs, FR_INT_ERR);
9D0025F0  92030006   LBU V1, 6(S0)
9D0025F4  2402FF80   ADDIU V0, ZERO, -128
9D0025F8  00621025   OR V0, V1, V0
9D0025FC  A2020006   SB V0, 6(S0)
9D002600  0B4009AE   J 0x9D0026B8
9D002604  24110002   ADDIU S1, ZERO, 2
2847:                					fp->clust = clst;
2848:                					fp->fptr += bcs;
9D002608  8E030008   LW V1, 8(S0)
9D00260C  00731821   ADDU V1, V1, S3
9D002610  AE030008   SW V1, 8(S0)
9D002614  02551821   ADDU V1, S2, S5
2849:                					ofs -= bcs;
2850:                				}
2851:                				fp->fptr += ofs;
9D002628  0B40098D   J 0x9D002634
9D00262C  8E030008   LW V1, 8(S0)
9D002630  8E030008   LW V1, 8(S0)
9D002634  00721821   ADDU V1, V1, S2
9D002638  AE030008   SW V1, 8(S0)
2852:                				if (ofs % SS(fp->fs)) {
9D00263C  324401FF   ANDI A0, S2, 511
9D002640  1080000D   BEQ A0, ZERO, 0x9D002678
9D002644  00001821   ADDU V1, ZERO, ZERO
2853:                					nsect = clust2sect(fp->fs, clst); /* Current sector */
9D002648  8E040000   LW A0, 0(S0)
9D00264C  0F400156   JAL clust2sect
9D002650  00402821   ADDU A1, V0, ZERO
2854:                					if (!nsect)
9D002654  14400007   BNE V0, ZERO, 0x9D002674
9D002658  00121A42   SRL V1, S2, 9
2855:                						ABORT(fp->fs, FR_INT_ERR);
9D00265C  92030006   LBU V1, 6(S0)
9D002660  2402FF80   ADDIU V0, ZERO, -128
9D002664  00621025   OR V0, V1, V0
9D002668  A2020006   SB V0, 6(S0)
9D00266C  0B4009AE   J 0x9D0026B8
9D002670  24110002   ADDIU S1, ZERO, 2
2856:                					nsect += ofs / SS(fp->fs);
9D002674  00431821   ADDU V1, V0, V1
2857:                				}
2858:                			}
2859:                		}
2860:                		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) { /* Fill sector cache if needed */
9D002678  8E020008   LW V0, 8(S0)
9D00267C  304201FF   ANDI V0, V0, 511
9D002680  50400005   BEQL V0, ZERO, 0x9D002698
9D002684  8E020008   LW V0, 8(S0)
9D002688  8E020018   LW V0, 24(S0)
9D00268C  54430001   BNEL V0, V1, 0x9D002694
9D002690  AE030018   SW V1, 24(S0)
2861:                #if !_FS_TINY
2862:                #if !_FS_READONLY
2863:                			if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2864:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2865:                					ABORT(fp->fs, FR_DISK_ERR);
2866:                				fp->flag &= ~FA__DIRTY;
2867:                			}
2868:                #endif
2869:                			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK) /* Fill sector cache */
2870:                				ABORT(fp->fs, FR_DISK_ERR);
2871:                #endif
2872:                			fp->dsect = nsect;
2873:                		}
2874:                #if !_FS_READONLY
2875:                		if (fp->fptr > fp->fsize) { /* Set file change flag if the file size is extended */
9D002694  8E020008   LW V0, 8(S0)
9D002698  8E03000C   LW V1, 12(S0)
9D00269C  0062182B   SLTU V1, V1, V0
9D0026A0  50600006   BEQL V1, ZERO, 0x9D0026BC
9D0026A4  02201021   ADDU V0, S1, ZERO
2876:                			fp->fsize = fp->fptr;
9D0026A8  AE02000C   SW V0, 12(S0)
2877:                			fp->flag |= FA__WRITTEN;
9D0026AC  92020006   LBU V0, 6(S0)
9D0026B0  34420020   ORI V0, V0, 32
9D0026B4  A2020006   SB V0, 6(S0)
2878:                		}
2879:                #endif
2880:                	}
2881:                
2882:                	LEAVE_FF(fp->fs, res);
2883:                }
9D00248C  0B4009AF   J 0x9D0026BC
9D002490  02201021   ADDU V0, S1, ZERO
9D0026B8  02201021   ADDU V0, S1, ZERO
9D0026BC  8FBF0034   LW RA, 52(SP)
9D0026C0  8FBE0030   LW S8, 48(SP)
9D0026C4  8FB7002C   LW S7, 44(SP)
9D0026C8  8FB60028   LW S6, 40(SP)
9D0026CC  8FB50024   LW S5, 36(SP)
9D0026D0  8FB40020   LW S4, 32(SP)
9D0026D4  8FB3001C   LW S3, 28(SP)
9D0026D8  8FB20018   LW S2, 24(SP)
9D0026DC  8FB10014   LW S1, 20(SP)
9D0026E0  8FB00010   LW S0, 16(SP)
9D0026E4  03E00008   JR RA
9D0026E8  27BD0038   ADDIU SP, SP, 56
2884:                
2885:                #if _FS_MINIMIZE <= 1
2886:                /*-----------------------------------------------------------------------*/
2887:                /* Create a Directroy Object                                             */
2888:                /*-----------------------------------------------------------------------*/
2889:                
2890:                FRESULT f_opendir(DIR *dj, /* Pointer to directory object to create */
2891:                const TCHAR *path /* Pointer to the directory path */
2892:                ) {
9D0026EC  27BDFFD8   ADDIU SP, SP, -40
9D0026F0  AFBF0024   SW RA, 36(SP)
9D0026F4  AFB00020   SW S0, 32(SP)
9D0026F8  00808021   ADDU S0, A0, ZERO
9D0026FC  AFA5002C   SW A1, 44(SP)
2893:                	FRESULT res;
2894:                	DEF_NAMEBUF;
2895:                
2896:                	res = chk_mounted(&path, &dj->fs, 0);
9D002700  27A4002C   ADDIU A0, SP, 44
9D002704  02002821   ADDU A1, S0, ZERO
9D002708  0F40050B   JAL chk_mounted
9D00270C  00003021   ADDU A2, ZERO, ZERO
2897:                	if (res == FR_OK) {
9D002710  14400024   BNE V0, ZERO, 0x9D0027A4
9D002714  8FBF0024   LW RA, 36(SP)
2898:                		INIT_BUF(*dj);
9D002718  27A20010   ADDIU V0, SP, 16
9D00271C  AE020018   SW V0, 24(S0)
2899:                		res = follow_path(dj, path); /* Follow the path to the directory */
9D002720  02002021   ADDU A0, S0, ZERO
9D002724  0F400384   JAL 0x9D000E10
9D002728  8FA5002C   LW A1, 44(SP)
2900:                		FREE_BUF();
2901:                		if (res == FR_OK) { /* Follow completed */
9D00272C  1440001A   BNE V0, ZERO, 0x9D002798
9D002730  38440004   XORI A0, V0, 4
2902:                			if (dj->dir) { /* It is not the root dir */
9D002734  8E030014   LW V1, 20(S0)
9D002738  50600011   BEQL V1, ZERO, 0x9D002780
9D00273C  8E020000   LW V0, 0(S0)
2903:                				if (dj->dir[DIR_Attr] & AM_DIR) { /* The object is a directory */
9D002740  9064000B   LBU A0, 11(V1)
9D002744  30840010   ANDI A0, A0, 16
9D002748  10800015   BEQ A0, ZERO, 0x9D0027A0
9D00274C  24020005   ADDIU V0, ZERO, 5
2904:                					dj->sclust = LD_CLUST(dj->dir);
9D002750  90640015   LBU A0, 21(V1)
9D002754  00042200   SLL A0, A0, 8
9D002758  90620014   LBU V0, 20(V1)
9D00275C  00822025   OR A0, A0, V0
9D002760  00042400   SLL A0, A0, 16
9D002764  9062001B   LBU V0, 27(V1)
9D002768  00021200   SLL V0, V0, 8
9D00276C  9063001A   LBU V1, 26(V1)
9D002770  00431025   OR V0, V0, V1
9D002774  00821025   OR V0, A0, V0
9D002778  AE020008   SW V0, 8(S0)
2905:                				} else { /* The object is not a directory */
2906:                					res = FR_NO_PATH;
2907:                				}
2908:                			}
2909:                			if (res == FR_OK) {
2910:                				dj->id = dj->fs->id;
9D00277C  8E020000   LW V0, 0(S0)
9D002780  94420006   LHU V0, 6(V0)
9D002784  A6020004   SH V0, 4(S0)
2911:                				res = dir_sdi(dj, 0); /* Rewind dir */
9D002788  02002021   ADDU A0, S0, ZERO
9D00278C  0F4001C3   JAL 0x9D00070C
9D002790  00002821   ADDU A1, ZERO, ZERO
2912:                			}
2913:                		}
2914:                		if (res == FR_NO_FILE)
2915:                			res = FR_NO_PATH;
9D002794  38440004   XORI A0, V0, 4
9D002798  24030005   ADDIU V1, ZERO, 5
9D00279C  0064100A   MOVZ V0, V1, A0
2916:                	}
2917:                
2918:                	LEAVE_FF(dj->fs, res);
2919:                }
9D0027A0  8FBF0024   LW RA, 36(SP)
9D0027A4  8FB00020   LW S0, 32(SP)
9D0027A8  03E00008   JR RA
9D0027AC  27BD0028   ADDIU SP, SP, 40
2920:                
2921:                /*-----------------------------------------------------------------------*/
2922:                /* Read Directory Entry in Sequense                                      */
2923:                /*-----------------------------------------------------------------------*/
2924:                
2925:                FRESULT f_readdir(DIR *dj, /* Pointer to the open directory object */
2926:                FILINFO *fno /* Pointer to file information to return */
2927:                ) {
9D0027B0  27BDFFD0   ADDIU SP, SP, -48
9D0027B4  AFBF002C   SW RA, 44(SP)
9D0027B8  AFB20028   SW S2, 40(SP)
9D0027BC  AFB10024   SW S1, 36(SP)
9D0027C0  AFB00020   SW S0, 32(SP)
9D0027C4  00808821   ADDU S1, A0, ZERO
9D0027C8  00A09021   ADDU S2, A1, ZERO
2928:                	FRESULT res;
2929:                	DEF_NAMEBUF;
2930:                
2931:                	res = validate(dj->fs, dj->id); /* Check validity of the object */
9D0027CC  8C840000   LW A0, 0(A0)
9D0027D0  0F400143   JAL 0x9D00050C
9D0027D4  96250004   LHU A1, 4(S1)
2932:                	if (res == FR_OK) {
9D0027D8  1440001C   BNE V0, ZERO, 0x9D00284C
9D0027DC  00408021   ADDU S0, V0, ZERO
2933:                		if (!fno) {
9D0027E0  16400006   BNE S2, ZERO, 0x9D0027FC
9D0027E4  27A20010   ADDIU V0, SP, 16
2934:                			res = dir_sdi(dj, 0); /* Rewind the directory object */
9D0027E8  02202021   ADDU A0, S1, ZERO
9D0027EC  0F4001C3   JAL 0x9D00070C
9D0027F0  00002821   ADDU A1, ZERO, ZERO
9D0027F4  0B400A13   J 0x9D00284C
9D0027F8  00408021   ADDU S0, V0, ZERO
2935:                		} else {
2936:                			INIT_BUF(*dj);
9D0027FC  AE220018   SW V0, 24(S1)
2937:                			res = dir_read(dj); /* Read an directory item */
9D002800  0F4004A7   JAL 0x9D00129C
9D002804  02202021   ADDU A0, S1, ZERO
2938:                			if (res == FR_NO_FILE) { /* Reached end of dir */
9D002808  24030004   ADDIU V1, ZERO, 4
9D00280C  14430003   BNE V0, V1, 0x9D00281C
9D002810  00000000   NOP
2939:                				dj->sect = 0;
9D002814  0B400A09   J 0x9D002824
9D002818  AE200010   SW ZERO, 16(S1)
2940:                				res = FR_OK;
2941:                			}
2942:                			if (res == FR_OK) { /* A valid entry is found */
9D00281C  5440000B   BNEL V0, ZERO, 0x9D00284C
9D002820  00408021   ADDU S0, V0, ZERO
2943:                				get_fileinfo(dj, fno); /* Get the object information */
9D002824  02202021   ADDU A0, S1, ZERO
9D002828  0F40003A   JAL 0x9D0000E8
9D00282C  02402821   ADDU A1, S2, ZERO
2944:                				res = dir_next(dj, 0); /* Increment index for next */
9D002830  02202021   ADDU A0, S1, ZERO
9D002834  0F400302   JAL 0x9D000C08
9D002838  00002821   ADDU A1, ZERO, ZERO
2945:                				if (res == FR_NO_FILE) {
9D00283C  24030004   ADDIU V1, ZERO, 4
9D002840  54430002   BNEL V0, V1, 0x9D00284C
9D002844  00408021   ADDU S0, V0, ZERO
9D002848  AE200010   SW ZERO, 16(S1)
2946:                					dj->sect = 0;
2947:                					res = FR_OK;
2948:                				}
2949:                			} FREE_BUF();
2950:                		}
2951:                	}
2952:                
2953:                	LEAVE_FF(dj->fs, res);
2954:                }
9D00284C  02001021   ADDU V0, S0, ZERO
9D002850  8FBF002C   LW RA, 44(SP)
9D002854  8FB20028   LW S2, 40(SP)
9D002858  8FB10024   LW S1, 36(SP)
9D00285C  8FB00020   LW S0, 32(SP)
9D002860  03E00008   JR RA
9D002864  27BD0030   ADDIU SP, SP, 48
2955:                
2956:                #if _FS_MINIMIZE == 0
2957:                /*-----------------------------------------------------------------------*/
2958:                /* Get File Status                                                       */
2959:                /*-----------------------------------------------------------------------*/
2960:                
2961:                FRESULT f_stat(const TCHAR *path, /* Pointer to the file path */
2962:                                FILINFO *fno /* Pointer to file information to return */
2963:                                ) {
9D002868  27BDFFB8   ADDIU SP, SP, -72
9D00286C  AFBF0044   SW RA, 68(SP)
9D002870  AFB10040   SW S1, 64(SP)
9D002874  AFB0003C   SW S0, 60(SP)
9D002878  AFA40048   SW A0, 72(SP)
9D00287C  00A08821   ADDU S1, A1, ZERO
2964:                	FRESULT res;
2965:                	DIR dj;
2966:                	DEF_NAMEBUF;
2967:                
2968:                	res = chk_mounted(&path, &dj.fs, 0);
9D002880  27A40048   ADDIU A0, SP, 72
9D002884  27A50010   ADDIU A1, SP, 16
9D002888  0F40050B   JAL chk_mounted
9D00288C  00003021   ADDU A2, ZERO, ZERO
2969:                	if (res == FR_OK) {
9D002890  14400010   BNE V0, ZERO, 0x9D0028D4
9D002894  00408021   ADDU S0, V0, ZERO
2970:                		INIT_BUF(dj);
9D002898  27A2002C   ADDIU V0, SP, 44
9D00289C  AFA20028   SW V0, 40(SP)
2971:                		res = follow_path(&dj, path); /* Follow the file path */
9D0028A0  27A40010   ADDIU A0, SP, 16
9D0028A4  0F400384   JAL 0x9D000E10
9D0028A8  8FA50048   LW A1, 72(SP)
2972:                		if (res == FR_OK) { /* Follow completed */
9D0028AC  14400009   BNE V0, ZERO, 0x9D0028D4
9D0028B0  00408021   ADDU S0, V0, ZERO
2973:                			if (dj.dir) /* Found an object */
9D0028B4  8FA20024   LW V0, 36(SP)
9D0028B8  10400005   BEQ V0, ZERO, 0x9D0028D0
9D0028BC  27A40010   ADDIU A0, SP, 16
2974:                				get_fileinfo(&dj, fno);
9D0028C0  0F40003A   JAL 0x9D0000E8
9D0028C4  02202821   ADDU A1, S1, ZERO
2975:                			else
2976:                				/* It is root dir */
2977:                				res = FR_INVALID_NAME;
9D0028D0  24100006   ADDIU S0, ZERO, 6
2978:                		}FREE_BUF();
2979:                	}
2980:                
2981:                	LEAVE_FF(dj.fs, res);
2982:                }
9D0028C8  0B400A36   J 0x9D0028D8
9D0028CC  02001021   ADDU V0, S0, ZERO
9D0028D4  02001021   ADDU V0, S0, ZERO
9D0028D8  8FBF0044   LW RA, 68(SP)
9D0028DC  8FB10040   LW S1, 64(SP)
9D0028E0  8FB0003C   LW S0, 60(SP)
9D0028E4  03E00008   JR RA
9D0028E8  27BD0048   ADDIU SP, SP, 72
2983:                
2984:                #if !_FS_READONLY
2985:                /*-----------------------------------------------------------------------*/
2986:                /* Get Number of Free Clusters                                           */
2987:                /*-----------------------------------------------------------------------*/
2988:                
2989:                FRESULT f_getfree(const TCHAR *path, /* Pointer to the logical drive number (root dir) */
2990:                DWORD *nclst, /* Pointer to the variable to return number of free clusters */
2991:                FATFS **fatfs /* Pointer to pointer to corresponding file system object to return */
2992:                ) {
9D0028EC  27BDFFC8   ADDIU SP, SP, -56
9D0028F0  AFBF0034   SW RA, 52(SP)
9D0028F4  AFB70030   SW S7, 48(SP)
9D0028F8  AFB6002C   SW S6, 44(SP)
9D0028FC  AFB50028   SW S5, 40(SP)
9D002900  AFB40024   SW S4, 36(SP)
9D002904  AFB30020   SW S3, 32(SP)
9D002908  AFB2001C   SW S2, 28(SP)
9D00290C  AFB10018   SW S1, 24(SP)
9D002910  AFB00014   SW S0, 20(SP)
9D002914  AFA40038   SW A0, 56(SP)
9D002918  00A0B821   ADDU S7, A1, ZERO
9D00291C  00C09021   ADDU S2, A2, ZERO
2993:                	FRESULT res;
2994:                	DWORD n, clst, sect, stat;
2995:                	UINT i;
2996:                	PF_BYTE fat, *p;
2997:                
2998:                	/* Get drive number */
2999:                	res = chk_mounted(&path, fatfs, 0);
9D002920  27A40038   ADDIU A0, SP, 56
9D002924  00C02821   ADDU A1, A2, ZERO
9D002928  0F40050B   JAL chk_mounted
9D00292C  00003021   ADDU A2, ZERO, ZERO
3000:                	if (res == FR_OK) {
9D002930  1440005A   BNE V0, ZERO, 0x9D002A9C
9D002934  00408021   ADDU S0, V0, ZERO
3001:                		/* If free_clust is valid, return it without full cluster scan */
3002:                		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
9D002938  8E420000   LW V0, 0(S2)
9D00293C  8C430010   LW V1, 16(V0)
9D002940  8C510018   LW S1, 24(V0)
9D002944  2624FFFE   ADDIU A0, S1, -2
9D002948  0083202B   SLTU A0, A0, V1
9D00294C  54800003   BNEL A0, ZERO, 0x9D00295C
9D002950  90540000   LBU S4, 0(V0)
3003:                			*nclst = (*fatfs)->free_clust;
9D002954  0B400AA7   J 0x9D002A9C
9D002958  AEE30000   SW V1, 0(S7)
3004:                		} else {
3005:                			/* Get number of free clusters */
3006:                			fat = (*fatfs)->fs_type;
3007:                			n = 0;
9D0029C0  00009821   ADDU S3, ZERO, ZERO
3008:                			if (fat == FS_FAT12) {
9D00295C  24030001   ADDIU V1, ZERO, 1
9D002960  56830015   BNEL S4, V1, 0x9D0029B8
9D002964  8C560020   LW S6, 32(V0)
9D002968  24110002   ADDIU S1, ZERO, 2
9D00296C  00009821   ADDU S3, ZERO, ZERO
3009:                				clst = 2;
3010:                				do {
3011:                					stat = get_fat(*fatfs, clst);
9D002978  8E440000   LW A0, 0(S2)
9D00297C  0F400162   JAL get_fat
9D002980  02202821   ADDU A1, S1, ZERO
3012:                					if (stat == 0xFFFFFFFF) {
9D002970  2415FFFF   ADDIU S5, ZERO, -1
9D002984  5055003C   BEQL V0, S5, 0x9D002A78
9D002988  24100001   ADDIU S0, ZERO, 1
3013:                						res = FR_DISK_ERR;
3014:                						break;
3015:                					}
3016:                					if (stat == 1) {
9D002974  24160001   ADDIU S6, ZERO, 1
9D00298C  10560037   BEQ V0, S6, 0x9D002A6C
9D002990  2C420001   SLTIU V0, V0, 1
3017:                						res = FR_INT_ERR;
9D002A6C  0B400A9E   J 0x9D002A78
9D002A70  24100002   ADDIU S0, ZERO, 2
3018:                						break;
3019:                					}
3020:                					if (stat == 0)
3021:                						n++;
9D002994  02629821   ADDU S3, S3, V0
3022:                				} while (++clst < (*fatfs)->n_fatent);
9D002998  26310001   ADDIU S1, S1, 1
9D00299C  8E420000   LW V0, 0(S2)
9D0029A0  8C430018   LW V1, 24(V0)
9D0029A4  0223182B   SLTU V1, S1, V1
9D0029A8  5460FFF4   BNEL V1, ZERO, 0x9D00297C
9D0029AC  8E440000   LW A0, 0(S2)
3023:                			} else {
3024:                				clst = (*fatfs)->n_fatent;
3025:                				sect = (*fatfs)->fatbase;
3026:                				i = 0;
9D0029BC  00001821   ADDU V1, ZERO, ZERO
3027:                				p = 0;
9D0029B8  00001021   ADDU V0, ZERO, ZERO
3028:                				do {
3029:                					if (!i) {
9D0029C8  14600009   BNE V1, ZERO, 0x9D0029F0
9D0029CC  00000000   NOP
3030:                						res = move_window(*fatfs, sect++);
9D0029D0  8E440000   LW A0, 0(S2)
9D0029D4  0F400082   JAL 0x9D000208
9D0029D8  02C02821   ADDU A1, S6, ZERO
9D002A74  00408021   ADDU S0, V0, ZERO
3031:                						if (res != FR_OK)
9D0029DC  14400025   BNE V0, ZERO, 0x9D002A74
9D0029E0  26D60001   ADDIU S6, S6, 1
3032:                							break;
3033:                						p = (*fatfs)->win;
9D0029E4  8E420000   LW V0, 0(S2)
9D0029E8  24420030   ADDIU V0, V0, 48
3034:                						i = SS(*fatfs);
9D0029EC  24030200   ADDIU V1, ZERO, 512
3035:                					}
3036:                					if (fat == FS_FAT16) {
9D0029C4  24150002   ADDIU S5, ZERO, 2
9D0029F0  5695000B   BNEL S4, S5, 0x9D002A20
9D0029F4  90450003   LBU A1, 3(V0)
3037:                						if (LD_WORD(p) == 0)
9D0029F8  90440001   LBU A0, 1(V0)
9D0029FC  00042200   SLL A0, A0, 8
9D002A00  90450000   LBU A1, 0(V0)
9D002A04  00852025   OR A0, A0, A1
9D002A08  7C042620   SEH A0, A0
3038:                							n++;
9D002A0C  2C840001   SLTIU A0, A0, 1
9D002A10  02649821   ADDU S3, S3, A0
3039:                						p += 2;
9D002A14  24420002   ADDIU V0, V0, 2
3040:                						i -= 2;
9D002A18  0B400A96   J 0x9D002A58
9D002A1C  2463FFFE   ADDIU V1, V1, -2
3041:                					} else {
3042:                						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0)
9D002A20  00052E00   SLL A1, A1, 24
9D002A24  90440002   LBU A0, 2(V0)
9D002A28  00042400   SLL A0, A0, 16
9D002A2C  00A42025   OR A0, A1, A0
9D002A30  90450000   LBU A1, 0(V0)
9D002A34  00852025   OR A0, A0, A1
9D002A38  90450001   LBU A1, 1(V0)
9D002A3C  00052A00   SLL A1, A1, 8
9D002A40  00852025   OR A0, A0, A1
9D002A44  7C84D800   EXT A0, A0, 0, 28
3043:                							n++;
9D002A48  2C840001   SLTIU A0, A0, 1
9D002A4C  02649821   ADDU S3, S3, A0
3044:                						p += 4;
9D002A50  24420004   ADDIU V0, V0, 4
3045:                						i -= 4;
9D002A54  2463FFFC   ADDIU V1, V1, -4
3046:                					}
3047:                				} while (--clst);
9D002A58  2631FFFF   ADDIU S1, S1, -1
9D002A5C  1620FFDA   BNE S1, ZERO, 0x9D0029C8
9D002A60  00000000   NOP
3048:                			}
3049:                			(*fatfs)->free_clust = n;
9D0029B0  0B400AA6   J 0x9D002A98
9D0029B4  AC530010   SW S3, 16(V0)
9D002A64  0B400A9F   J 0x9D002A7C
9D002A68  8E420000   LW V0, 0(S2)
9D002A78  8E420000   LW V0, 0(S2)
9D002A7C  AC530010   SW S3, 16(V0)
3050:                			if (fat == FS_FAT32)
9D002A80  24020003   ADDIU V0, ZERO, 3
9D002A84  56820005   BNEL S4, V0, 0x9D002A9C
9D002A88  AEF30000   SW S3, 0(S7)
3051:                				(*fatfs)->fsi_flag = 1;
9D002A8C  8E420000   LW V0, 0(S2)
9D002A90  24030001   ADDIU V1, ZERO, 1
9D002A94  A0430005   SB V1, 5(V0)
3052:                			*nclst = n;
9D002A98  AEF30000   SW S3, 0(S7)
3053:                		}
3054:                	}
3055:                	LEAVE_FF(*fatfs, res);
3056:                }
9D002A9C  02001021   ADDU V0, S0, ZERO
9D002AA0  8FBF0034   LW RA, 52(SP)
9D002AA4  8FB70030   LW S7, 48(SP)
9D002AA8  8FB6002C   LW S6, 44(SP)
9D002AAC  8FB50028   LW S5, 40(SP)
9D002AB0  8FB40024   LW S4, 36(SP)
9D002AB4  8FB30020   LW S3, 32(SP)
9D002AB8  8FB2001C   LW S2, 28(SP)
9D002ABC  8FB10018   LW S1, 24(SP)
9D002AC0  8FB00014   LW S0, 20(SP)
9D002AC4  03E00008   JR RA
9D002AC8  27BD0038   ADDIU SP, SP, 56
3057:                
3058:                /*-----------------------------------------------------------------------*/
3059:                /* Truncate File                                                         */
3060:                /*-----------------------------------------------------------------------*/
3061:                
3062:                FRESULT f_truncate(FIL *fp /* Pointer to the file object */
3063:                ) {
9D002ACC  27BDFFE0   ADDIU SP, SP, -32
9D002AD0  AFBF001C   SW RA, 28(SP)
9D002AD4  AFB10018   SW S1, 24(SP)
9D002AD8  AFB00014   SW S0, 20(SP)
9D002ADC  00808021   ADDU S0, A0, ZERO
3064:                	FRESULT res;
3065:                	DWORD ncl;
3066:                
3067:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D002AE0  8C840000   LW A0, 0(A0)
9D002AE4  0F400143   JAL 0x9D00050C
9D002AE8  96050004   LHU A1, 4(S0)
3068:                	if (res == FR_OK) {
9D002AEC  14400033   BNE V0, ZERO, 0x9D002BBC
9D002AF0  8FBF001C   LW RA, 28(SP)
3069:                		if (fp->flag & FA__ERROR) { /* Check abort flag */
9D002AF4  92030006   LBU V1, 6(S0)
9D002AF8  7C032420   SEB A0, V1
9D002AFC  04800005   BLTZ A0, 0x9D002B14
9D002B00  30640002   ANDI A0, V1, 2
3070:                			res = FR_INT_ERR;
9D002B14  0B400AEE   J 0x9D002BB8
9D002B18  24020002   ADDIU V0, ZERO, 2
3071:                		} else {
3072:                			if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D002B04  54800031   BNEL A0, ZERO, 0x9D002BCC
9D002B08  8E040008   LW A0, 8(S0)
3073:                				res = FR_DENIED;
9D002B0C  0B400AEE   J 0x9D002BB8
9D002B10  24020007   ADDIU V0, ZERO, 7
3074:                		}
3075:                	}
3076:                	if (res == FR_OK) {
3077:                		if (fp->fsize > fp->fptr) {
9D002BCC  8E05000C   LW A1, 12(S0)
9D002BD0  0085282B   SLTU A1, A0, A1
9D002BD4  54A0FFD1   BNEL A1, ZERO, 0x9D002B1C
9D002BD8  AE04000C   SW A0, 12(S0)
3078:                			fp->fsize = fp->fptr; /* Set file size to current R/W point */
3079:                			fp->flag |= FA__WRITTEN;
9D002B1C  34630020   ORI V1, V1, 32
3080:                			if (fp->fptr == 0) { /* When set file size to zero, remove entire cluster chain */
9D002B20  14800006   BNE A0, ZERO, 0x9D002B3C
9D002B24  A2030006   SB V1, 6(S0)
3081:                				res = remove_chain(fp->fs, fp->sclust);
9D002B28  8E040000   LW A0, 0(S0)
9D002B2C  0F4004D1   JAL 0x9D001344
9D002B30  8E050010   LW A1, 16(S0)
3082:                				fp->sclust = 0;
9D002B34  0B400AE8   J 0x9D002BA0
9D002B38  AE000010   SW ZERO, 16(S0)
3083:                			} else { /* When truncate a part of the file, remove remaining clusters */
3084:                				ncl = get_fat(fp->fs, fp->clust);
9D002B3C  8E040000   LW A0, 0(S0)
9D002B40  0F400162   JAL get_fat
9D002B44  8E050014   LW A1, 20(S0)
9D002B48  00408821   ADDU S1, V0, ZERO
3085:                				res = FR_OK;
9D002B58  26220001   ADDIU V0, S1, 1
9D002B5C  2C420001   SLTIU V0, V0, 1
3086:                				if (ncl == 0xFFFFFFFF)
3087:                					res = FR_DISK_ERR;
3088:                				if (ncl == 1)
9D002B4C  24020001   ADDIU V0, ZERO, 1
9D002B50  12220015   BEQ S1, V0, 0x9D002BA8
9D002B54  24020002   ADDIU V0, ZERO, 2
3089:                					res = FR_INT_ERR;
3090:                				if (res == FR_OK && ncl < fp->fs->n_fatent) {
9D002B60  54400012   BNEL V0, ZERO, 0x9D002BAC
9D002B64  92040006   LBU A0, 6(S0)
9D002B68  8E040000   LW A0, 0(S0)
9D002B6C  8C830018   LW V1, 24(A0)
9D002B70  0223182B   SLTU V1, S1, V1
9D002B74  10600011   BEQ V1, ZERO, 0x9D002BBC
9D002B78  8FBF001C   LW RA, 28(SP)
3091:                					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
9D002B7C  8E050014   LW A1, 20(S0)
9D002B80  3C060FFF   LUI A2, 4095
9D002B84  0F400232   JAL put_fat
9D002B88  34C6FFFF   ORI A2, A2, -1
3092:                					if (res == FR_OK)
9D002B8C  54400007   BNEL V0, ZERO, 0x9D002BAC
9D002B90  92040006   LBU A0, 6(S0)
3093:                						res = remove_chain(fp->fs, ncl);
9D002B94  8E040000   LW A0, 0(S0)
9D002B98  0F4004D1   JAL 0x9D001344
9D002B9C  02202821   ADDU A1, S1, ZERO
3094:                				}
3095:                			}
3096:                		}
3097:                		if (res != FR_OK)
9D002BA0  10400006   BEQ V0, ZERO, 0x9D002BBC
9D002BA4  8FBF001C   LW RA, 28(SP)
3098:                			fp->flag |= FA__ERROR;
9D002BA8  92040006   LBU A0, 6(S0)
9D002BAC  2403FF80   ADDIU V1, ZERO, -128
9D002BB0  00831825   OR V1, A0, V1
9D002BB4  A2030006   SB V1, 6(S0)
3099:                	}
3100:                
3101:                	LEAVE_FF(fp->fs, res);
3102:                }
9D002BB8  8FBF001C   LW RA, 28(SP)
9D002BBC  8FB10018   LW S1, 24(SP)
9D002BC0  8FB00014   LW S0, 20(SP)
9D002BC4  03E00008   JR RA
9D002BC8  27BD0020   ADDIU SP, SP, 32
9D002BDC  0B400AEF   J 0x9D002BBC
9D002BE0  8FBF001C   LW RA, 28(SP)
3103:                
3104:                /*-----------------------------------------------------------------------*/
3105:                /* Delete a File or Directory                                            */
3106:                /*-----------------------------------------------------------------------*/
3107:                
3108:                FRESULT f_unlink(const TCHAR *path /* Pointer to the file or directory path */
3109:                ) {
9D002BE4  27BDFFA0   ADDIU SP, SP, -96
9D002BE8  AFBF005C   SW RA, 92(SP)
9D002BEC  AFB00058   SW S0, 88(SP)
9D002BF0  AFA40060   SW A0, 96(SP)
3110:                	FRESULT res;
3111:                	DIR dj, sdj;
3112:                	PF_BYTE *dir;
3113:                	DWORD dclst;
3114:                	DEF_NAMEBUF;
3115:                
3116:                	res = chk_mounted(&path, &dj.fs, 1);
9D002BF4  27A40060   ADDIU A0, SP, 96
9D002BF8  27A50010   ADDIU A1, SP, 16
9D002BFC  0F40050B   JAL chk_mounted
9D002C00  24060001   ADDIU A2, ZERO, 1
3117:                	if (res == FR_OK) {
9D002C04  1440002E   BNE V0, ZERO, 0x9D002CC0
9D002C08  8FBF005C   LW RA, 92(SP)
3118:                		INIT_BUF(dj);
9D002C0C  27A20048   ADDIU V0, SP, 72
9D002C10  AFA20028   SW V0, 40(SP)
3119:                		res = follow_path(&dj, path); /* Follow the file path */
9D002C14  27A40010   ADDIU A0, SP, 16
9D002C18  0F400384   JAL 0x9D000E10
9D002C1C  8FA50060   LW A1, 96(SP)
3120:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3121:                			res = FR_INVALID_NAME; /* Cannot remove dot entry */
3122:                #if _FS_SHARE
3123:                		if (res == FR_OK) res = chk_lock(&dj, 2); /* Cannot remove open file */
3124:                #endif
3125:                		if (res == FR_OK) { /* The object is accessible */
9D002C20  14400026   BNE V0, ZERO, 0x9D002CBC
9D002C24  8FA30024   LW V1, 36(SP)
3126:                			dir = dj.dir;
3127:                			if (!dir) {
9D002C28  10600024   BEQ V1, ZERO, 0x9D002CBC
9D002C2C  24020006   ADDIU V0, ZERO, 6
3128:                				res = FR_INVALID_NAME; /* Cannot remove the start directory */
3129:                			} else {
3130:                				if (dir[DIR_Attr] & AM_RDO)
9D002C30  9062000B   LBU V0, 11(V1)
9D002C34  30420001   ANDI V0, V0, 1
9D002C38  5040002A   BEQL V0, ZERO, 0x9D002CE4
9D002C3C  90620015   LBU V0, 21(V1)
3131:                					res = FR_DENIED; /* Cannot remove R/O object */
9D002C40  0B400B2F   J 0x9D002CBC
9D002C44  24020007   ADDIU V0, ZERO, 7
3132:                			}
3133:                			dclst = LD_CLUST(dir);
9D002CE4  00021200   SLL V0, V0, 8
9D002CE8  90640014   LBU A0, 20(V1)
9D002CEC  00441025   OR V0, V0, A0
9D002CF0  00021400   SLL V0, V0, 16
9D002CF4  9070001B   LBU S0, 27(V1)
9D002CF8  00108200   SLL S0, S0, 8
9D002CFC  9064001A   LBU A0, 26(V1)
9D002D00  02048025   OR S0, S0, A0
9D002D04  00508025   OR S0, V0, S0
3134:                			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) { /* Is it a sub-dir? */
9D002D08  9062000B   LBU V0, 11(V1)
9D002D0C  30420010   ANDI V0, V0, 16
9D002D10  1440FFCD   BNE V0, ZERO, 0x9D002C48
9D002D14  2E030002   SLTIU V1, S0, 2
9D002D18  0B400B33   J 0x9D002CCC
9D002D1C  00000000   NOP
3135:                				if (dclst < 2) {
9D002C48  1460001C   BNE V1, ZERO, 0x9D002CBC
9D002C4C  24020002   ADDIU V0, ZERO, 2
3136:                					res = FR_INT_ERR;
3137:                				} else {
3138:                					mem_cpy(&sdj, &dj, sizeof(DIR)); /* Check if the sub-dir is empty or not */
9D002C50  27A4002C   ADDIU A0, SP, 44
9D002C54  27A50010   ADDIU A1, SP, 16
9D002C58  0F400008   JAL 0x9D000020
9D002C5C  2406001C   ADDIU A2, ZERO, 28
3139:                					sdj.sclust = dclst;
9D002C60  AFB00034   SW S0, 52(SP)
3140:                					res = dir_sdi(&sdj, 2); /* Exclude dot entries */
9D002C64  27A4002C   ADDIU A0, SP, 44
9D002C68  0F4001C3   JAL 0x9D00070C
9D002C6C  24050002   ADDIU A1, ZERO, 2
3141:                					if (res == FR_OK) {
9D002C70  14400013   BNE V0, ZERO, 0x9D002CC0
9D002C74  8FBF005C   LW RA, 92(SP)
3142:                						res = dir_read(&sdj);
9D002C78  0F4004A7   JAL 0x9D00129C
9D002C7C  27A4002C   ADDIU A0, SP, 44
3143:                						if (res == FR_OK /* Not empty dir */
9D002C80  5040000E   BEQL V0, ZERO, 0x9D002CBC
9D002C84  24020007   ADDIU V0, ZERO, 7
3144:                #if _FS_RPATH
3145:                							|| dclst == sdj.fs->cdir /* Current dir */
3146:                #endif
3147:                							) res = FR_DENIED;
3148:                						if (res == FR_NO_FILE)
9D002C88  24030004   ADDIU V1, ZERO, 4
9D002C8C  1043000F   BEQ V0, V1, 0x9D002CCC
9D002C90  8FBF005C   LW RA, 92(SP)
3149:                							res = FR_OK; /* Empty */
3150:                					}
3151:                				}
3152:                			}
3153:                			if (res == FR_OK) {
3154:                				res = dir_remove(&dj); /* Remove the directory entry */
9D002CCC  0F40021C   JAL 0x9D000870
9D002CD0  27A40010   ADDIU A0, SP, 16
3155:                				if (res == FR_OK) {
9D002CD4  1040FFF1   BEQ V0, ZERO, 0x9D002C9C
9D002CD8  8FBF005C   LW RA, 92(SP)
3156:                					if (dclst) /* Remove the cluster chain if exist */
9D002C9C  12000005   BEQ S0, ZERO, 0x9D002CB4
9D002CA0  8FA40010   LW A0, 16(SP)
3157:                						res = remove_chain(dj.fs, dclst);
9D002CA4  0F4004D1   JAL 0x9D001344
9D002CA8  02002821   ADDU A1, S0, ZERO
3158:                					if (res == FR_OK)
9D002CAC  14400004   BNE V0, ZERO, 0x9D002CC0
9D002CB0  8FBF005C   LW RA, 92(SP)
3159:                						res = sync(dj.fs);
9D002CB4  0F4000F9   JAL 0x9D0003E4
9D002CB8  8FA40010   LW A0, 16(SP)
3160:                				}
3161:                			}
3162:                		}FREE_BUF();
3163:                	}
3164:                	LEAVE_FF(dj.fs, res);
3165:                }
9D002C94  0B400B31   J 0x9D002CC4
9D002C98  8FB00058   LW S0, 88(SP)
9D002CBC  8FBF005C   LW RA, 92(SP)
9D002CC0  8FB00058   LW S0, 88(SP)
9D002CC4  03E00008   JR RA
9D002CC8  27BD0060   ADDIU SP, SP, 96
9D002CDC  0B400B31   J 0x9D002CC4
9D002CE0  8FB00058   LW S0, 88(SP)
3166:                
3167:                /*-----------------------------------------------------------------------*/
3168:                /* Create a Directory                                                    */
3169:                /*-----------------------------------------------------------------------*/
3170:                
3171:                FRESULT f_mkdir(const TCHAR *path /* Pointer to the directory path */
9D002EE4  32B500FF   ANDI S5, S5, 255
9D002EE8  26B50001   ADDIU S5, S5, 1
9D002EEC  02B2A821   ADDU S5, S5, S2
3172:                ) {
9D002D20  27BDFF88   ADDIU SP, SP, -120
9D002D24  AFBF0074   SW RA, 116(SP)
9D002D28  AFBE0070   SW S8, 112(SP)
9D002D2C  AFB7006C   SW S7, 108(SP)
9D002D30  AFB60068   SW S6, 104(SP)
9D002D34  AFB50064   SW S5, 100(SP)
9D002D38  AFB40060   SW S4, 96(SP)
9D002D3C  AFB3005C   SW S3, 92(SP)
9D002D40  AFB20058   SW S2, 88(SP)
9D002D44  AFB10054   SW S1, 84(SP)
9D002D48  AFB00050   SW S0, 80(SP)
3173:                	FRESULT res;
3174:                	DIR dj;
3175:                	PF_BYTE *dir, n;
3176:                	DWORD dsc, dcl, pcl, tim = get_fattime();
9D002D4C  0F401C74   JAL get_fattime
9D002D50  AFA40078   SW A0, 120(SP)
9D002D54  00408821   ADDU S1, V0, ZERO
3177:                	DEF_NAMEBUF;
3178:                
3179:                	res = chk_mounted(&path, &dj.fs, 1);
9D002D58  27A40078   ADDIU A0, SP, 120
9D002D5C  27A50010   ADDIU A1, SP, 16
9D002D60  0F40050B   JAL chk_mounted
9D002D64  24060001   ADDIU A2, ZERO, 1
3180:                	if (res == FR_OK) {
9D002D68  1440008C   BNE V0, ZERO, 0x9D002F9C
9D002D6C  00408021   ADDU S0, V0, ZERO
3181:                		INIT_BUF(dj);
9D002D70  27A2002C   ADDIU V0, SP, 44
9D002D74  AFA20028   SW V0, 40(SP)
3182:                		res = follow_path(&dj, path); /* Follow the file path */
9D002D78  27A40010   ADDIU A0, SP, 16
9D002D7C  0F400384   JAL 0x9D000E10
9D002D80  8FA50078   LW A1, 120(SP)
3183:                		if (res == FR_OK)
9D002D84  50400085   BEQL V0, ZERO, 0x9D002F9C
9D002D88  24100008   ADDIU S0, ZERO, 8
3184:                			res = FR_EXIST; /* Any object with same name is already existing */
3185:                		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
3186:                			res = FR_INVALID_NAME;
3187:                		if (res == FR_NO_FILE) { /* Can create a new directory */
9D002D8C  24030004   ADDIU V1, ZERO, 4
9D002D90  54430082   BNEL V0, V1, 0x9D002F9C
9D002D94  00408021   ADDU S0, V0, ZERO
3188:                			dcl = create_chain(dj.fs, 0); /* Allocate a cluster for the new directory table */
9D002D98  8FA40010   LW A0, 16(SP)
9D002D9C  0F4002A1   JAL 0x9D000A84
9D002DA0  00002821   ADDU A1, ZERO, ZERO
3189:                			res = FR_OK;
3190:                			if (dcl == 0)
9D002DA4  10400009   BEQ V0, ZERO, 0x9D002DCC
9D002DA8  00409821   ADDU S3, V0, ZERO
3191:                				res = FR_DENIED; /* No space to allocate a new cluster */
9D002DCC  24100007   ADDIU S0, ZERO, 7
3192:                			if (dcl == 1)
9D002DAC  24020001   ADDIU V0, ZERO, 1
9D002DB0  52620060   BEQL S3, V0, 0x9D002F34
9D002DB4  24100002   ADDIU S0, ZERO, 2
3193:                				res = FR_INT_ERR;
3194:                			if (dcl == 0xFFFFFFFF)
9D002DB8  2402FFFF   ADDIU V0, ZERO, -1
9D002DBC  5262005D   BEQL S3, V0, 0x9D002F34
9D002DC0  24100001   ADDIU S0, ZERO, 1
9D002DC4  0B400B74   J 0x9D002DD0
9D002DC8  00000000   NOP
3195:                				res = FR_DISK_ERR;
3196:                			if (res == FR_OK) /* Flush FAT */
9D002DD0  16000058   BNE S0, ZERO, 0x9D002F34
9D002DD4  8FA40010   LW A0, 16(SP)
3197:                				res = move_window(dj.fs, 0);
9D002DD8  0F400082   JAL 0x9D000208
9D002DDC  00002821   ADDU A1, ZERO, ZERO
3198:                			if (res == FR_OK) { /* Initialize the new directory table */
9D002DE0  14400054   BNE V0, ZERO, 0x9D002F34
9D002DE4  00408021   ADDU S0, V0, ZERO
3199:                				dsc = clust2sect(dj.fs, dcl);
9D002DE8  8FB00010   LW S0, 16(SP)
9D002DEC  02002021   ADDU A0, S0, ZERO
9D002DF0  0F400156   JAL clust2sect
9D002DF4  02602821   ADDU A1, S3, ZERO
9D002DF8  00409021   ADDU S2, V0, ZERO
3200:                				dir = dj.fs->win;
9D002DFC  26140030   ADDIU S4, S0, 48
3201:                				mem_set(dir, 0, SS(dj.fs));
9D002E00  02802021   ADDU A0, S4, ZERO
9D002E04  00002821   ADDU A1, ZERO, ZERO
9D002E08  0F400012   JAL 0x9D000048
9D002E0C  24060200   ADDIU A2, ZERO, 512
3202:                				mem_set(dir + DIR_Name, ' ', 8 + 3); /* Create "." entry */
9D002E10  02802021   ADDU A0, S4, ZERO
9D002E14  24050020   ADDIU A1, ZERO, 32
9D002E18  0F400012   JAL 0x9D000048
9D002E1C  2406000B   ADDIU A2, ZERO, 11
3203:                				dir[DIR_Name] = '.';
9D002E20  2415002E   ADDIU S5, ZERO, 46
9D002E24  A2150030   SB S5, 48(S0)
3204:                				dir[DIR_Attr] = AM_DIR;
9D002E28  24020010   ADDIU V0, ZERO, 16
9D002E2C  A202003B   SB V0, 59(S0)
3205:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D002E30  322200FF   ANDI V0, S1, 255
9D002E34  AFA20038   SW V0, 56(SP)
9D002E38  A2020046   SB V0, 70(S0)
9D002E3C  00111A02   SRL V1, S1, 8
9D002E40  A3A30048   SB V1, 72(SP)
9D002E44  A2030047   SB V1, 71(S0)
9D002E48  7E223C00   EXT V0, S1, 16, 8
9D002E4C  AFA2003C   SW V0, 60(SP)
9D002E50  A2020048   SB V0, 72(S0)
9D002E54  00118E02   SRL S1, S1, 24
9D002E58  AFB10040   SW S1, 64(SP)
9D002E5C  A2110049   SB S1, 73(S0)
3206:                				ST_CLUST(dir, dcl);
9D002E60  326300FF   ANDI V1, S3, 255
9D002E64  AFA30044   SW V1, 68(SP)
9D002E68  A203004A   SB V1, 74(S0)
9D002E6C  0013BA02   SRL S7, S3, 8
9D002E70  A217004B   SB S7, 75(S0)
9D002E74  0013B402   SRL S6, S3, 16
9D002E78  32DE00FF   ANDI S8, S6, 255
9D002E7C  A21E0044   SB S8, 68(S0)
9D002E80  0016B202   SRL S6, S6, 8
9D002E84  A2160045   SB S6, 69(S0)
3207:                				mem_cpy(dir + SZ_DIR, dir, SZ_DIR); /* Create ".." entry */
9D002E88  26040050   ADDIU A0, S0, 80
9D002E8C  02802821   ADDU A1, S4, ZERO
9D002E90  0F400008   JAL 0x9D000020
9D002E94  24060020   ADDIU A2, ZERO, 32
3208:                				dir[33] = '.';
9D002E98  A2150051   SB S5, 81(S0)
3209:                				pcl = dj.sclust;
3210:                				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
9D002E9C  8FA30010   LW V1, 16(SP)
9D002EA0  90650000   LBU A1, 0(V1)
9D002EA4  24040003   ADDIU A0, ZERO, 3
9D002EA8  14A40004   BNE A1, A0, 0x9D002EBC
9D002EAC  8FA20018   LW V0, 24(SP)
9D002EB0  8C640024   LW A0, 36(V1)
3211:                					pcl = 0;
9D002EB4  00822026   XOR A0, A0, V0
9D002EB8  0004100A   MOVZ V0, ZERO, A0
3212:                				ST_CLUST(dir+SZ_DIR, pcl);
9D002EBC  A202006A   SB V0, 106(S0)
9D002EC0  7C443A00   EXT A0, V0, 8, 8
9D002EC4  A204006B   SB A0, 107(S0)
9D002EC8  00021402   SRL V0, V0, 16
9D002ECC  A2020064   SB V0, 100(S0)
9D002ED0  00021202   SRL V0, V0, 8
9D002ED4  A2020065   SB V0, 101(S0)
3213:                				for (n = dj.fs->csize; n; n--) { /* Write dot entries and clear following sectors */
9D002ED8  90620002   LBU V0, 2(V1)
9D002EDC  1040003C   BEQ V0, ZERO, 0x9D002FD0
9D002EE0  2455FFFF   ADDIU S5, V0, -1
9D002F24  1655FFF4   BNE S2, S5, 0x9D002EF8
9D002F28  8FA40010   LW A0, 16(SP)
9D002F2C  0B400BF4   J 0x9D002FD0
9D002F30  00000000   NOP
3214:                					dj.fs->winsect = dsc++;
9D002EF4  8FA40010   LW A0, 16(SP)
9D002EF8  AC92002C   SW S2, 44(A0)
9D002EFC  26520001   ADDIU S2, S2, 1
3215:                					dj.fs->wflag = 1;
9D002EF0  24110001   ADDIU S1, ZERO, 1
9D002F00  A0910004   SB S1, 4(A0)
3216:                					res = move_window(dj.fs, 0);
9D002F04  0F400082   JAL 0x9D000208
9D002F08  00002821   ADDU A1, ZERO, ZERO
3217:                					if (res != FR_OK)
9D002F0C  14400009   BNE V0, ZERO, 0x9D002F34
9D002F10  00408021   ADDU S0, V0, ZERO
3218:                						break;
3219:                					mem_set(dir, 0, SS(dj.fs));
9D002F14  02802021   ADDU A0, S4, ZERO
9D002F18  00002821   ADDU A1, ZERO, ZERO
9D002F1C  0F400012   JAL 0x9D000048
9D002F20  24060200   ADDIU A2, ZERO, 512
3220:                				}
3221:                			}
3222:                			if (res == FR_OK)
3223:                				res = dir_register(&dj); /* Register the object to the directoy */
9D002FD0  0F400472   JAL 0x9D0011C8
9D002FD4  27A40010   ADDIU A0, SP, 16
3224:                			if (res != FR_OK) {
9D002FD8  1040FFDB   BEQ V0, ZERO, 0x9D002F48
9D002FDC  00408021   ADDU S0, V0, ZERO
3225:                				remove_chain(dj.fs, dcl); /* Could not register, remove cluster chain */
9D002F34  8FA40010   LW A0, 16(SP)
9D002F38  0F4004D1   JAL 0x9D001344
9D002F3C  02602821   ADDU A1, S3, ZERO
9D002FE0  0B400BCE   J 0x9D002F38
9D002FE4  8FA40010   LW A0, 16(SP)
3226:                			} else {
3227:                				dir = dj.dir;
9D002F48  8FA20024   LW V0, 36(SP)
3228:                				dir[DIR_Attr] = AM_DIR; /* Attribute */
9D002F4C  24030010   ADDIU V1, ZERO, 16
9D002F50  A043000B   SB V1, 11(V0)
3229:                				ST_DWORD(dir+DIR_WrtTime, tim); /* Created time */
9D002F54  8FA30038   LW V1, 56(SP)
9D002F58  A0430016   SB V1, 22(V0)
9D002F5C  93A30048   LBU V1, 72(SP)
9D002F60  A0430017   SB V1, 23(V0)
9D002F64  8FA3003C   LW V1, 60(SP)
9D002F68  A0430018   SB V1, 24(V0)
9D002F6C  8FA30040   LW V1, 64(SP)
9D002F70  A0430019   SB V1, 25(V0)
3230:                				ST_CLUST(dir, dcl); /* Table start cluster */
9D002F74  8FA30044   LW V1, 68(SP)
9D002F78  A043001A   SB V1, 26(V0)
9D002F7C  A057001B   SB S7, 27(V0)
9D002F80  A05E0014   SB S8, 20(V0)
9D002F84  A0560015   SB S6, 21(V0)
3231:                				dj.fs->wflag = 1;
9D002F88  8FA40010   LW A0, 16(SP)
9D002F8C  24020001   ADDIU V0, ZERO, 1
3232:                				res = sync(dj.fs);
9D002F90  0F4000F9   JAL 0x9D0003E4
9D002F94  A0820004   SB V0, 4(A0)
9D002F98  00408021   ADDU S0, V0, ZERO
3233:                			}
3234:                		}FREE_BUF();
3235:                	}
3236:                
3237:                	LEAVE_FF(dj.fs, res);
3238:                }
9D002F40  0B400BE8   J 0x9D002FA0
9D002F44  02001021   ADDU V0, S0, ZERO
9D002F9C  02001021   ADDU V0, S0, ZERO
9D002FA0  8FBF0074   LW RA, 116(SP)
9D002FA4  8FBE0070   LW S8, 112(SP)
9D002FA8  8FB7006C   LW S7, 108(SP)
9D002FAC  8FB60068   LW S6, 104(SP)
9D002FB0  8FB50064   LW S5, 100(SP)
9D002FB4  8FB40060   LW S4, 96(SP)
9D002FB8  8FB3005C   LW S3, 92(SP)
9D002FBC  8FB20058   LW S2, 88(SP)
9D002FC0  8FB10054   LW S1, 84(SP)
9D002FC4  8FB00050   LW S0, 80(SP)
9D002FC8  03E00008   JR RA
9D002FCC  27BD0078   ADDIU SP, SP, 120
3239:                
3240:                /*-----------------------------------------------------------------------*/
3241:                /* Change Attribute                                                      */
3242:                /*-----------------------------------------------------------------------*/
3243:                
3244:                FRESULT f_chmod(const TCHAR *path, /* Pointer to the file path */
3245:                PF_BYTE value, /* Attribute bits */
3246:                PF_BYTE mask /* Attribute mask to change */
3247:                ) {
9D002FE8  27BDFFB8   ADDIU SP, SP, -72
9D002FEC  AFBF0044   SW RA, 68(SP)
9D002FF0  AFB10040   SW S1, 64(SP)
9D002FF4  AFB0003C   SW S0, 60(SP)
9D002FF8  AFA40048   SW A0, 72(SP)
9D002FFC  30B100FF   ANDI S1, A1, 255
9D003000  30D000FF   ANDI S0, A2, 255
3248:                	FRESULT res;
3249:                	DIR dj;
3250:                	PF_BYTE *dir;
3251:                	DEF_NAMEBUF;
3252:                
3253:                	res = chk_mounted(&path, &dj.fs, 1);
9D003004  27A40048   ADDIU A0, SP, 72
9D003008  27A50010   ADDIU A1, SP, 16
9D00300C  0F40050B   JAL chk_mounted
9D003010  24060001   ADDIU A2, ZERO, 1
3254:                	if (res == FR_OK) {
9D003014  14400016   BNE V0, ZERO, 0x9D003070
9D003018  8FBF0044   LW RA, 68(SP)
3255:                		INIT_BUF(dj);
9D00301C  27A2002C   ADDIU V0, SP, 44
9D003020  AFA20028   SW V0, 40(SP)
3256:                		res = follow_path(&dj, path); /* Follow the file path */
9D003024  27A40010   ADDIU A0, SP, 16
9D003028  0F400384   JAL 0x9D000E10
9D00302C  8FA50048   LW A1, 72(SP)
3257:                		FREE_BUF();
3258:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3259:                			res = FR_INVALID_NAME;
3260:                		if (res == FR_OK) {
9D003030  1440000E   BNE V0, ZERO, 0x9D00306C
9D003034  8FA30024   LW V1, 36(SP)
3261:                			dir = dj.dir;
3262:                			if (!dir) { /* Is it a root directory? */
9D003038  1060000C   BEQ V1, ZERO, 0x9D00306C
9D00303C  24020006   ADDIU V0, ZERO, 6
3263:                				res = FR_INVALID_NAME;
3264:                			} else { /* File or sub directory */
3265:                				mask &= AM_RDO | AM_HID | AM_SYS | AM_ARC; /* Valid attribute mask */
9D003040  32100027   ANDI S0, S0, 39
3266:                				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr]
9D003048  9062000B   LBU V0, 11(V1)
9D00304C  00821024   AND V0, A0, V0
9D003050  02118024   AND S0, S0, S1
9D003054  00508025   OR S0, V0, S0
9D003058  A070000B   SB S0, 11(V1)
3267:                						& (PF_BYTE) ~mask); /* Apply attribute change */
9D003044  00102027   NOR A0, ZERO, S0
3268:                				dj.fs->wflag = 1;
9D00305C  8FA40010   LW A0, 16(SP)
9D003060  24020001   ADDIU V0, ZERO, 1
3269:                				res = sync(dj.fs);
9D003064  0F4000F9   JAL 0x9D0003E4
9D003068  A0820004   SB V0, 4(A0)
3270:                			}
3271:                		}
3272:                	}
3273:                
3274:                	LEAVE_FF(dj.fs, res);
3275:                }
9D00306C  8FBF0044   LW RA, 68(SP)
9D003070  8FB10040   LW S1, 64(SP)
9D003074  8FB0003C   LW S0, 60(SP)
9D003078  03E00008   JR RA
9D00307C  27BD0048   ADDIU SP, SP, 72
3276:                
3277:                /*-----------------------------------------------------------------------*/
3278:                /* Change Timestamp                                                      */
3279:                /*-----------------------------------------------------------------------*/
3280:                
3281:                FRESULT f_utime(const TCHAR *path, /* Pointer to the file/directory name */
3282:                const FILINFO *fno /* Pointer to the time stamp to be set */
3283:                ) {
9D003080  27BDFFC0   ADDIU SP, SP, -64
9D003084  AFBF003C   SW RA, 60(SP)
9D003088  AFB00038   SW S0, 56(SP)
9D00308C  AFA40040   SW A0, 64(SP)
9D003090  00A08021   ADDU S0, A1, ZERO
3284:                	FRESULT res;
3285:                	DIR dj;
3286:                	PF_BYTE *dir;
3287:                	DEF_NAMEBUF;
3288:                
3289:                	res = chk_mounted(&path, &dj.fs, 1);
9D003094  27A40040   ADDIU A0, SP, 64
9D003098  27A50010   ADDIU A1, SP, 16
9D00309C  0F40050B   JAL chk_mounted
9D0030A0  24060001   ADDIU A2, ZERO, 1
3290:                	if (res == FR_OK) {
9D0030A4  14400019   BNE V0, ZERO, 0x9D00310C
9D0030A8  8FBF003C   LW RA, 60(SP)
3291:                		INIT_BUF(dj);
9D0030AC  27A2002C   ADDIU V0, SP, 44
9D0030B0  AFA20028   SW V0, 40(SP)
3292:                		res = follow_path(&dj, path); /* Follow the file path */
9D0030B4  27A40010   ADDIU A0, SP, 16
9D0030B8  0F400384   JAL 0x9D000E10
9D0030BC  8FA50040   LW A1, 64(SP)
3293:                		FREE_BUF();
3294:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3295:                			res = FR_INVALID_NAME;
3296:                		if (res == FR_OK) {
9D0030C0  14400011   BNE V0, ZERO, 0x9D003108
9D0030C4  8FA30024   LW V1, 36(SP)
3297:                			dir = dj.dir;
3298:                			if (!dir) { /* Root directory */
9D0030C8  1060000F   BEQ V1, ZERO, 0x9D003108
9D0030CC  24020006   ADDIU V0, ZERO, 6
3299:                				res = FR_INVALID_NAME;
3300:                			} else { /* File or sub-directory */
3301:                				ST_WORD(dir+DIR_WrtTime, fno->ftime);
9D0030D0  96020006   LHU V0, 6(S0)
9D0030D4  A0620016   SB V0, 22(V1)
9D0030D8  96020006   LHU V0, 6(S0)
9D0030DC  00021202   SRL V0, V0, 8
9D0030E0  A0620017   SB V0, 23(V1)
3302:                				ST_WORD(dir+DIR_WrtDate, fno->fdate);
9D0030E4  96020004   LHU V0, 4(S0)
9D0030E8  A0620018   SB V0, 24(V1)
9D0030EC  96020004   LHU V0, 4(S0)
9D0030F0  00021202   SRL V0, V0, 8
9D0030F4  A0620019   SB V0, 25(V1)
3303:                				dj.fs->wflag = 1;
9D0030F8  8FA40010   LW A0, 16(SP)
9D0030FC  24020001   ADDIU V0, ZERO, 1
3304:                				res = sync(dj.fs);
9D003100  0F4000F9   JAL 0x9D0003E4
9D003104  A0820004   SB V0, 4(A0)
3305:                			}
3306:                		}
3307:                	}
3308:                
3309:                	LEAVE_FF(dj.fs, res);
3310:                }
9D003108  8FBF003C   LW RA, 60(SP)
9D00310C  8FB00038   LW S0, 56(SP)
9D003110  03E00008   JR RA
9D003114  27BD0040   ADDIU SP, SP, 64
3311:                
3312:                /*-----------------------------------------------------------------------*/
3313:                /* Rename File/Directory                                                 */
3314:                /*-----------------------------------------------------------------------*/
3315:                
3316:                FRESULT f_rename(const TCHAR *path_old, /* Pointer to the old name */
3317:                const TCHAR *path_new /* Pointer to the new name */
3318:                ) {
9D003118  27BDFF80   ADDIU SP, SP, -128
9D00311C  AFBF007C   SW RA, 124(SP)
9D003120  AFB10078   SW S1, 120(SP)
9D003124  AFB00074   SW S0, 116(SP)
9D003128  AFA40080   SW A0, 128(SP)
9D00312C  00A08021   ADDU S0, A1, ZERO
3319:                	FRESULT res;
3320:                	DIR djo, djn;
3321:                	PF_BYTE buf[21], *dir;
3322:                	DWORD dw;
3323:                	DEF_NAMEBUF;
3324:                
3325:                	res = chk_mounted(&path_old, &djo.fs, 1);
9D003130  27A40080   ADDIU A0, SP, 128
9D003134  27A50010   ADDIU A1, SP, 16
9D003138  0F40050B   JAL chk_mounted
9D00313C  24060001   ADDIU A2, ZERO, 1
3326:                	if (res == FR_OK) {
9D003140  14400064   BNE V0, ZERO, 0x9D0032D4
9D003144  8FBF007C   LW RA, 124(SP)
3327:                		djn.fs = djo.fs;
9D003148  8FA20010   LW V0, 16(SP)
9D00314C  AFA2002C   SW V0, 44(SP)
3328:                		INIT_BUF(djo);
9D003150  27A20060   ADDIU V0, SP, 96
9D003154  AFA20028   SW V0, 40(SP)
3329:                		res = follow_path(&djo, path_old); /* Check old object */
9D003158  27A40010   ADDIU A0, SP, 16
9D00315C  0F400384   JAL 0x9D000E10
9D003160  8FA50080   LW A1, 128(SP)
3330:                		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
3331:                			res = FR_INVALID_NAME;
3332:                #if _FS_SHARE
3333:                		if (res == FR_OK) res = chk_lock(&djo, 2);
3334:                #endif
3335:                		if (res == FR_OK) { /* Old object is found */
9D003164  1440005A   BNE V0, ZERO, 0x9D0032D0
9D003168  8FA50024   LW A1, 36(SP)
3336:                			if (!djo.dir) { /* Is root dir? */
9D00316C  10A00058   BEQ A1, ZERO, 0x9D0032D0
9D003170  24020004   ADDIU V0, ZERO, 4
3337:                				res = FR_NO_FILE;
3338:                			} else {
3339:                				mem_cpy(buf, djo.dir + DIR_Attr, 21); /* Save the object information except for name */
9D003174  27A40048   ADDIU A0, SP, 72
9D003178  24A5000B   ADDIU A1, A1, 11
9D00317C  0F400008   JAL 0x9D000020
9D003180  24060015   ADDIU A2, ZERO, 21
3340:                				mem_cpy(&djn, &djo, sizeof(DIR)); /* Check new object */
9D003184  27A4002C   ADDIU A0, SP, 44
9D003188  27A50010   ADDIU A1, SP, 16
9D00318C  0F400008   JAL 0x9D000020
9D003190  2406001C   ADDIU A2, ZERO, 28
3341:                				res = follow_path(&djn, path_new);
9D003194  27A4002C   ADDIU A0, SP, 44
9D003198  0F400384   JAL 0x9D000E10
9D00319C  02002821   ADDU A1, S0, ZERO
3342:                				if (res == FR_OK)
9D0031A0  5040004B   BEQL V0, ZERO, 0x9D0032D0
9D0031A4  24020008   ADDIU V0, ZERO, 8
3343:                					res = FR_EXIST; /* The new object name is already existing */
3344:                				if (res == FR_NO_FILE) { /* Is it a valid path and no name collision? */
9D0031A8  24030004   ADDIU V1, ZERO, 4
9D0031AC  14430049   BNE V0, V1, 0x9D0032D4
9D0031B0  8FBF007C   LW RA, 124(SP)
3345:                					/* Start critical section that any interruption or error can cause cross-link */
3346:                					res = dir_register(&djn); /* Register the new entry */
9D0031B4  0F400472   JAL 0x9D0011C8
9D0031B8  27A4002C   ADDIU A0, SP, 44
3347:                					if (res == FR_OK) {
9D0031BC  14400045   BNE V0, ZERO, 0x9D0032D4
9D0031C0  8FBF007C   LW RA, 124(SP)
3348:                						dir = djn.dir; /* Copy object information except for name */
9D0031C4  8FB00040   LW S0, 64(SP)
3349:                						mem_cpy(dir + 13, buf + 2, 19);
9D0031C8  2604000D   ADDIU A0, S0, 13
9D0031CC  27A5004A   ADDIU A1, SP, 74
9D0031D0  0F400008   JAL 0x9D000020
9D0031D4  24060013   ADDIU A2, ZERO, 19
3350:                						dir[DIR_Attr] = buf[0] | AM_ARC;
9D0031D8  93A20048   LBU V0, 72(SP)
9D0031DC  34420020   ORI V0, V0, 32
9D0031E0  A202000B   SB V0, 11(S0)
3351:                						djo.fs->wflag = 1;
9D0031E4  24030001   ADDIU V1, ZERO, 1
9D0031E8  8FA20010   LW V0, 16(SP)
9D0031EC  A0430004   SB V1, 4(V0)
3352:                						if (djo.sclust != djn.sclust
9D0031F0  8FA20034   LW V0, 52(SP)
9D0031F4  8FA30018   LW V1, 24(SP)
9D0031F8  1062002D   BEQ V1, V0, 0x9D0032B0
9D0031FC  00000000   NOP
3353:                								&& (dir[DIR_Attr] & AM_DIR)) { /* Update .. entry in the directory if needed */
9D003200  9202000B   LBU V0, 11(S0)
9D003204  30420010   ANDI V0, V0, 16
9D003208  10400029   BEQ V0, ZERO, 0x9D0032B0
9D00320C  8FB1002C   LW S1, 44(SP)
3354:                							dw = clust2sect(djn.fs, LD_CLUST(dir));
9D003210  92050015   LBU A1, 21(S0)
9D003214  00052A00   SLL A1, A1, 8
9D003218  92020014   LBU V0, 20(S0)
9D00321C  00A22825   OR A1, A1, V0
9D003220  00052C00   SLL A1, A1, 16
9D003224  9203001B   LBU V1, 27(S0)
9D003228  00031A00   SLL V1, V1, 8
9D00322C  9202001A   LBU V0, 26(S0)
9D003230  00621025   OR V0, V1, V0
9D003234  02202021   ADDU A0, S1, ZERO
9D003238  0F400156   JAL clust2sect
9D00323C  00A22825   OR A1, A1, V0
9D003240  00402821   ADDU A1, V0, ZERO
3355:                							if (!dw) {
9D003244  10A00022   BEQ A1, ZERO, 0x9D0032D0
9D003248  24020002   ADDIU V0, ZERO, 2
3356:                								res = FR_INT_ERR;
3357:                							} else {
3358:                								res = move_window(djn.fs, dw);
9D00324C  0F400082   JAL 0x9D000208
9D003250  02202021   ADDU A0, S1, ZERO
3359:                								dir = djn.fs->win + SZ_DIR; /* .. entry */
3360:                								if (res == FR_OK && dir[1] == '.') {
9D003254  1440001E   BNE V0, ZERO, 0x9D0032D0
9D003258  8FA3002C   LW V1, 44(SP)
9D00325C  90640051   LBU A0, 81(V1)
9D003260  2402002E   ADDIU V0, ZERO, 46
9D003264  14820012   BNE A0, V0, 0x9D0032B0
9D003268  24020003   ADDIU V0, ZERO, 3
3361:                									dw
3362:                											= (djn.fs->fs_type == FS_FAT32
3363:                													&& djn.sclust
3364:                															== djn.fs->dirbase) ? 0
3365:                													: djn.sclust;
9D00326C  90640000   LBU A0, 0(V1)
9D003270  14820006   BNE A0, V0, 0x9D00328C
9D003274  8FA20034   LW V0, 52(SP)
9D003278  8C640024   LW A0, 36(V1)
9D00327C  8FA50034   LW A1, 52(SP)
9D003280  10A40002   BEQ A1, A0, 0x9D00328C
9D003284  00001021   ADDU V0, ZERO, ZERO
9D003288  8FA20034   LW V0, 52(SP)
3366:                									ST_CLUST(dir, dw);
9D00328C  A062006A   SB V0, 106(V1)
9D003290  7C443A00   EXT A0, V0, 8, 8
9D003294  A064006B   SB A0, 107(V1)
9D003298  00021402   SRL V0, V0, 16
9D00329C  A0620064   SB V0, 100(V1)
9D0032A0  00021202   SRL V0, V0, 8
9D0032A4  A0620065   SB V0, 101(V1)
3367:                									djn.fs->wflag = 1;
9D0032A8  24020001   ADDIU V0, ZERO, 1
9D0032AC  A0620004   SB V0, 4(V1)
3368:                								}
3369:                							}
3370:                						}
3371:                						if (res == FR_OK) {
3372:                							res = dir_remove(&djo); /* Remove old entry */
9D0032B0  0F40021C   JAL 0x9D000870
9D0032B4  27A40010   ADDIU A0, SP, 16
3373:                							if (res == FR_OK)
9D0032B8  54400006   BNEL V0, ZERO, 0x9D0032D4
9D0032BC  8FBF007C   LW RA, 124(SP)
3374:                								res = sync(djo.fs);
9D0032C0  0F4000F9   JAL 0x9D0003E4
9D0032C4  8FA40010   LW A0, 16(SP)
3375:                						}
3376:                					}
3377:                					/* End critical section */
3378:                				}
3379:                			}
3380:                		}FREE_BUF();
3381:                	}
3382:                	LEAVE_FF(djo.fs, res);
3383:                }
9D0032C8  0B400CB5   J 0x9D0032D4
9D0032CC  8FBF007C   LW RA, 124(SP)
9D0032D0  8FBF007C   LW RA, 124(SP)
9D0032D4  8FB10078   LW S1, 120(SP)
9D0032D8  8FB00074   LW S0, 116(SP)
9D0032DC  03E00008   JR RA
9D0032E0  27BD0080   ADDIU SP, SP, 128
3384:                
3385:                #endif /* !_FS_READONLY */
3386:                #endif /* _FS_MINIMIZE == 0 */
3387:                #endif /* _FS_MINIMIZE <= 1 */
3388:                #endif /* _FS_MINIMIZE <= 2 */
3389:                
3390:                /*-----------------------------------------------------------------------*/
3391:                /* Forward data to the stream directly (available on only tiny cfg)      */
3392:                /*-----------------------------------------------------------------------*/
3393:                #if _USE_FORWARD && _FS_TINY
3394:                
3395:                FRESULT f_forward (
3396:                		FIL *fp, /* Pointer to the file object */
3397:                		UINT (*func)(const PF_BYTE*,UINT), /* Pointer to the streaming function */
3398:                		UINT btr, /* Number of bytes to forward */
3399:                		UINT *bf /* Pointer to number of bytes forwarded */
3400:                )
3401:                {
3402:                	FRESULT res;
3403:                	DWORD remain, clst, sect;
3404:                	UINT rcnt;
3405:                	PF_BYTE csect;
3406:                
3407:                	*bf = 0; /* Initialize byte counter */
3408:                
3409:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
3410:                	if (res != FR_OK) LEAVE_FF(fp->fs, res);
3411:                	if (fp->flag & FA__ERROR) /* Check error flag */
3412:                	LEAVE_FF(fp->fs, FR_INT_ERR);
3413:                	if (!(fp->flag & FA_READ)) /* Check access mode */
3414:                	LEAVE_FF(fp->fs, FR_DENIED);
3415:                
3416:                	remain = fp->fsize - fp->fptr;
3417:                	if (btr > remain) btr = (UINT)remain; /* Truncate btr by remaining bytes */
3418:                
3419:                	for (; btr && (*func)(0, 0); /* Repeat until all data transferred or stream becomes busy */
3420:                			fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
3421:                		csect = (PF_BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
3422:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
3423:                			if (!csect) { /* On the cluster boundary? */
3424:                				clst = (fp->fptr == 0) ? /* On the top of the file? */
3425:                				fp->sclust : get_fat(fp->fs, fp->clust);
3426:                				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
3427:                				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
3428:                				fp->clust = clst; /* Update current cluster */
3429:                			}
3430:                		}
3431:                		sect = clust2sect(fp->fs, fp->clust); /* Get current data sector */
3432:                		if (!sect) ABORT(fp->fs, FR_INT_ERR);
3433:                		sect += csect;
3434:                		if (move_window(fp->fs, sect)) /* Move sector window */
3435:                		ABORT(fp->fs, FR_DISK_ERR);
3436:                		fp->dsect = sect;
3437:                		rcnt = SS(fp->fs) - (PF_WORD)(fp->fptr % SS(fp->fs)); /* Forward data from sector window */
3438:                		if (rcnt > btr) rcnt = btr;
3439:                		rcnt = (*func)(&fp->fs->win[(PF_WORD)fp->fptr % SS(fp->fs)], rcnt);
3440:                		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
3441:                	}
3442:                
3443:                	LEAVE_FF(fp->fs, FR_OK);
3444:                }
3445:                #endif /* _USE_FORWARD */
3446:                
3447:                #if _USE_MKFS && !_FS_READONLY
3448:                /*-----------------------------------------------------------------------*/
3449:                /* Create File System on the Drive                                       */
3450:                /*-----------------------------------------------------------------------*/
3451:                #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
3452:                #define N_FATS		1		/* Number of FAT copies (1 or 2) */
3453:                
3454:                FRESULT f_mkfs (
3455:                		PF_BYTE drv, /* Logical drive number */
3456:                		PF_BYTE sfd, /* Partitioning rule 0:FDISK, 1:SFD */
3457:                		UINT au /* Allocation unit size [bytes] */
3458:                )
3459:                {
3460:                	static const PF_WORD vst[] = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0};
3461:                	static const PF_WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
3462:                	PF_BYTE fmt, md, sys, *tbl, pdrv, part;
3463:                	DWORD n_clst, vs, n, wsect;
3464:                	UINT i;
3465:                	DWORD b_vol, b_fat, b_dir, b_data; /* LBA */
3466:                	DWORD n_vol, n_rsv, n_fat, n_dir; /* Size */
3467:                	FATFS *fs;
3468:                	DSTATUS stat;
3469:                
3470:                	/* Check mounted drive and clear work area */
3471:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
3472:                	if (sfd > 1) return FR_INVALID_PARAMETER;
3473:                	if (au & (au - 1)) return FR_INVALID_PARAMETER;
3474:                	fs = FatFs[drv];
3475:                	if (!fs) return FR_NOT_ENABLED;
3476:                	fs->fs_type = 0;
3477:                	pdrv = LD2PD(drv); /* Physical drive */
3478:                	part = LD2PT(drv); /* Partition (0:auto detect, 1-4:get from partition table)*/
3479:                
3480:                	/* Get disk statics */
3481:                	stat = disk_initialize(pdrv);
3482:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3483:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3484:                #if _MAX_SS != 512					/* Get disk sector size */
3485:                	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
3486:                	return FR_DISK_ERR;
3487:                #endif
3488:                	if (_MULTI_PARTITION && part) {
3489:                		/* Get partition information from partition table in the MBR */
3490:                		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3491:                		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
3492:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3493:                		if (!tbl[4]) return FR_MKFS_ABORTED; /* No partition? */
3494:                		b_vol = LD_DWORD(tbl+8); /* Volume start sector */
3495:                		n_vol = LD_DWORD(tbl+12); /* Volume size */
3496:                	} else {
3497:                		/* Create a partition in this function */
3498:                		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
3499:                		return FR_DISK_ERR;
3500:                		b_vol = (sfd) ? 0 : 63; /* Volume start sector */
3501:                		n_vol -= b_vol; /* Volume size */
3502:                	}
3503:                
3504:                	if (!au) { /* AU auto selection */
3505:                		vs = n_vol / (2000 / (SS(fs) / 512));
3506:                		for (i = 0; vs < vst[i]; i++);
3507:                		au = cst[i];
3508:                	}
3509:                	au /= SS(fs); /* Number of sectors per cluster */
3510:                	if (au == 0) au = 1;
3511:                	if (au > 128) au = 128;
3512:                
3513:                	/* Pre-compute number of clusters and FAT syb-type */
3514:                	n_clst = n_vol / au;
3515:                	fmt = FS_FAT12;
3516:                	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
3517:                	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
3518:                
3519:                	/* Determine offset and size of FAT structure */
3520:                	if (fmt == FS_FAT32) {
3521:                		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
3522:                		n_rsv = 32;
3523:                		n_dir = 0;
3524:                	} else {
3525:                		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
3526:                		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
3527:                		n_rsv = 1;
3528:                		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
3529:                	}
3530:                	b_fat = b_vol + n_rsv; /* FAT area start sector */
3531:                	b_dir = b_fat + n_fat * N_FATS; /* Directory area start sector */
3532:                	b_data = b_dir + n_dir; /* Data area start sector */
3533:                	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED; /* Too small volume */
3534:                
3535:                	/* Align data start sector to erase block boundary (for flash memory media) */
3536:                	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
3537:                	n = (b_data + n - 1) & ~(n - 1); /* Next nearest erase block from current data start */
3538:                	n = (n - b_data) / N_FATS;
3539:                	if (fmt == FS_FAT32) { /* FAT32: Move FAT offset */
3540:                		n_rsv += n;
3541:                		b_fat += n;
3542:                	} else { /* FAT12/16: Expand FAT size */
3543:                		n_fat += n;
3544:                	}
3545:                
3546:                	/* Determine number of clusters and final check of validity of the FAT sub-type */
3547:                	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
3548:                	if ( (fmt == FS_FAT16 && n_clst < MIN_FAT16)
3549:                			|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
3550:                	return FR_MKFS_ABORTED;
3551:                
3552:                	switch (fmt) { /* Determine system ID for partition table */
3553:                		case FS_FAT12: sys = 0x01; break;
3554:                		case FS_FAT16: sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
3555:                		default: sys = 0x0C;
3556:                	}
3557:                
3558:                	if (_MULTI_PARTITION && part) {
3559:                		/* Update system ID in the partition table */
3560:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3561:                		tbl[4] = sys;
3562:                		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3563:                		md = 0xF8;
3564:                	} else {
3565:                		if (sfd) { /* No patition table (SFD) */
3566:                			md = 0xF0;
3567:                		} else { /* Create partition table (FDISK) */
3568:                			mem_set(fs->win, 0, SS(fs));
3569:                			tbl = fs->win+MBR_Table; /* Create partiton table for single partition in the drive */
3570:                			tbl[1] = 1; /* Partition start head */
3571:                			tbl[2] = 1; /* Partition start sector */
3572:                			tbl[3] = 0; /* Partition start cylinder */
3573:                			tbl[4] = sys; /* System type */
3574:                			tbl[5] = 254; /* Partition end head */
3575:                			n = (b_vol + n_vol) / 63 / 255;
3576:                			tbl[6] = (PF_BYTE)((n >> 2) | 63); /* Partiiton end sector */
3577:                			tbl[7] = (PF_BYTE)n; /* End cylinder */
3578:                			ST_DWORD(tbl+8, 63); /* Partition start in LBA */
3579:                			ST_DWORD(tbl+12, n_vol); /* Partition size in LBA */
3580:                			ST_WORD(fs->win+BS_55AA, 0xAA55); /* MBR signature */
3581:                			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) /* Write it to the MBR sector */
3582:                			return FR_DISK_ERR;
3583:                			md = 0xF8;
3584:                		}
3585:                	}
3586:                
3587:                	/* Create BPB in the VBR */
3588:                	tbl = fs->win; /* Clear sector */
3589:                	mem_set(tbl, 0, SS(fs));
3590:                	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
3591:                	i = SS(fs); /* Sector size */
3592:                	ST_WORD(tbl+BPB_BytsPerSec, i);
3593:                	tbl[BPB_SecPerClus] = (PF_BYTE)au; /* Sectors per cluster */
3594:                	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv); /* Reserved sectors */
3595:                	tbl[BPB_NumFATs] = N_FATS; /* Number of FATs */
3596:                	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR; /* Number of rootdir entries */
3597:                	ST_WORD(tbl+BPB_RootEntCnt, i);
3598:                	if (n_vol < 0x10000) { /* Number of total sectors */
3599:                		ST_WORD(tbl+BPB_TotSec16, n_vol);
3600:                	} else {
3601:                		ST_DWORD(tbl+BPB_TotSec32, n_vol);
3602:                	}
3603:                	tbl[BPB_Media] = md; /* Media descriptor */
3604:                	ST_WORD(tbl+BPB_SecPerTrk, 63); /* Number of sectors per track */
3605:                	ST_WORD(tbl+BPB_NumHeads, 255); /* Number of heads */
3606:                	ST_DWORD(tbl+BPB_HiddSec, b_vol); /* Hidden sectors */
3607:                	n = get_fattime(); /* Use current time as VSN */
3608:                	if (fmt == FS_FAT32) {
3609:                		ST_DWORD(tbl+BS_VolID32, n); /* VSN */
3610:                		ST_DWORD(tbl+BPB_FATSz32, n_fat); /* Number of sectors per FAT */
3611:                		ST_DWORD(tbl+BPB_RootClus, 2); /* Root directory start cluster (2) */
3612:                		ST_WORD(tbl+BPB_FSInfo, 1); /* FSInfo record offset (VBR+1) */
3613:                		ST_WORD(tbl+BPB_BkBootSec, 6); /* Backup boot record offset (VBR+6) */
3614:                		tbl[BS_DrvNum32] = 0x80; /* Drive number */
3615:                		tbl[BS_BootSig32] = 0x29; /* Extended boot signature */
3616:                		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19); /* Volume label, FAT signature */
3617:                	} else {
3618:                		ST_DWORD(tbl+BS_VolID, n); /* VSN */
3619:                		ST_WORD(tbl+BPB_FATSz16, n_fat); /* Number of sectors per FAT */
3620:                		tbl[BS_DrvNum] = 0x80; /* Drive number */
3621:                		tbl[BS_BootSig] = 0x29; /* Extended boot signature */
3622:                		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19); /* Volume label, FAT signature */
3623:                	}
3624:                	ST_WORD(tbl+BS_55AA, 0xAA55); /* Signature (Offset is fixed here regardless of sector size) */
3625:                	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK) /* Write it to the VBR sector */
3626:                	return FR_DISK_ERR;
3627:                	if (fmt == FS_FAT32) /* Write backup VBR if needed (VBR+6) */
3628:                	disk_write(pdrv, tbl, b_vol + 6, 1);
3629:                
3630:                	/* Initialize FAT area */
3631:                	wsect = b_fat;
3632:                	for (i = 0; i < N_FATS; i++) { /* Initialize each FAT copy */
3633:                		mem_set(tbl, 0, SS(fs)); /* 1st sector of the FAT  */
3634:                		n = md; /* Media descriptor byte */
3635:                		if (fmt != FS_FAT32) {
3636:                			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
3637:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT12/16) */
3638:                		} else {
3639:                			n |= 0xFFFFFF00;
3640:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT32) */
3641:                			ST_DWORD(tbl+4, 0xFFFFFFFF);
3642:                			ST_DWORD(tbl+8, 0x0FFFFFFF); /* Reserve cluster #2 for root dir */
3643:                		}
3644:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3645:                		return FR_DISK_ERR;
3646:                		mem_set(tbl, 0, SS(fs)); /* Fill following FAT entries with zero */
3647:                		for (n = 1; n < n_fat; n++) { /* This loop may take a time on FAT32 volume due to many single sector writes */
3648:                			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3649:                			return FR_DISK_ERR;
3650:                		}
3651:                	}
3652:                
3653:                	/* Initialize root directory */
3654:                	i = (fmt == FS_FAT32) ? au : n_dir;
3655:                	do {
3656:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3657:                		return FR_DISK_ERR;
3658:                	}while (--i);
3659:                
3660:                #if _USE_ERASE	/* Erase data area if needed */
3661:                	{
3662:                		DWORD eb[2];
3663:                
3664:                		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
3665:                		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
3666:                	}
3667:                #endif
3668:                
3669:                	/* Create FSInfo if needed */
3670:                	if (fmt == FS_FAT32) {
3671:                		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
3672:                		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
3673:                		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1); /* Number of free clusters */
3674:                		ST_DWORD(tbl+FSI_Nxt_Free, 2); /* Last allocated cluster# */
3675:                		ST_WORD(tbl+BS_55AA, 0xAA55);
3676:                		disk_write(pdrv, tbl, b_vol + 1, 1); /* Write original (VBR+1) */
3677:                		disk_write(pdrv, tbl, b_vol + 7, 1); /* Write backup (VBR+7) */
3678:                	}
3679:                
3680:                	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
3681:                }
3682:                
3683:                #if _MULTI_PARTITION == 2
3684:                /*-----------------------------------------------------------------------*/
3685:                /* Divide Physical Drive                                                 */
3686:                /*-----------------------------------------------------------------------*/
3687:                
3688:                FRESULT f_fdisk (
3689:                		PF_BYTE pdrv, /* Physical drive number */
3690:                		const DWORD szt[], /* Pointer to the size table for each partitions */
3691:                		void* work /* Pointer to the working buffer */
3692:                )
3693:                {
3694:                	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
3695:                	PF_BYTE s_hd, e_hd, *p, *buf = (PF_BYTE*)work;
3696:                	DSTATUS stat;
3697:                	DWORD sz_disk, sz_part, s_part;
3698:                
3699:                	stat = disk_initialize(pdrv);
3700:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3701:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3702:                	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
3703:                
3704:                	/* Determine CHS in the table regardless of the drive geometry */
3705:                	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2);
3706:                	if (n == 256) n--;
3707:                	e_hd = n - 1;
3708:                	sz_cyl = 63 * n;
3709:                	tot_cyl = sz_disk / sz_cyl;
3710:                
3711:                	/* Create partition table */
3712:                	mem_set(buf, 0, _MAX_SS);
3713:                	p = buf + MBR_Table; b_cyl = 0;
3714:                	for (i = 0; i < 4; i++, p += SZ_PTE) {
3715:                		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
3716:                		if (!p_cyl) continue;
3717:                		s_part = (DWORD)sz_cyl * b_cyl;
3718:                		sz_part = (DWORD)sz_cyl * p_cyl;
3719:                		if (i == 0) { /* Exclude first track of cylinder 0 */
3720:                			s_hd = 1;
3721:                			s_part += 63; sz_part -= 63;
3722:                		} else {
3723:                			s_hd = 0;
3724:                		}
3725:                		e_cyl = b_cyl + p_cyl - 1;
3726:                		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
3727:                
3728:                		/* Set partition table */
3729:                		p[1] = s_hd; /* Start head */
3730:                		p[2] = (PF_BYTE)((b_cyl >> 2) + 1); /* Start sector */
3731:                		p[3] = (PF_BYTE)b_cyl; /* Start cylinder */
3732:                		p[4] = 0x06; /* System type (temporary setting) */
3733:                		p[5] = e_hd; /* End head */
3734:                		p[6] = (PF_BYTE)((e_cyl >> 2) + 63); /* End sector */
3735:                		p[7] = (PF_BYTE)e_cyl; /* End cylinder */
3736:                		ST_DWORD(p + 8, s_part); /* Start sector in LBA */
3737:                		ST_DWORD(p + 12, sz_part); /* Partition size */
3738:                
3739:                		/* Next partition */
3740:                		b_cyl += p_cyl;
3741:                	}
3742:                	ST_WORD(p, 0xAA55);
3743:                
3744:                	/* Write it to the MBR */
3745:                	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
3746:                }
3747:                
3748:                #endif /* _MULTI_PARTITION == 2 */
3749:                #endif /* _USE_MKFS && !_FS_READONLY */
3750:                
3751:                #if _USE_STRFUNC
3752:                /*-----------------------------------------------------------------------*/
3753:                /* Get a string from the file                                            */
3754:                /*-----------------------------------------------------------------------*/
3755:                TCHAR* f_gets (
3756:                		TCHAR* buff, /* Pointer to the string buffer to read */
3757:                		int len, /* Size of string buffer (characters) */
3758:                		FIL* fil /* Pointer to the file object */
3759:                )
3760:                {
3761:                	int n = 0;
3762:                	TCHAR c, *p = buff;
3763:                	PF_BYTE s[2];
3764:                	UINT rc;
3765:                
3766:                	while (n < len - 1) { /* Read bytes until buffer gets filled */
3767:                		f_read(fil, s, 1, &rc);
3768:                		if (rc != 1) break; /* Break on EOF or error */
3769:                		c = s[0];
3770:                #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
3771:                		if (c >= 0x80) {
3772:                			if (c < 0xC0) continue; /* Skip stray trailer */
3773:                			if (c < 0xE0) { /* Two-byte sequense */
3774:                				f_read(fil, s, 1, &rc);
3775:                				if (rc != 1) break;
3776:                				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
3777:                				if (c < 0x80) c = '?';
3778:                			} else {
3779:                				if (c < 0xF0) { /* Three-byte sequense */
3780:                					f_read(fil, s, 2, &rc);
3781:                					if (rc != 2) break;
3782:                					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
3783:                					if (c < 0x800) c = '?';
3784:                				} else { /* Reject four-byte sequense */
3785:                					c = '?';
3786:                				}
3787:                			}
3788:                		}
3789:                #endif
3790:                #if _USE_STRFUNC >= 2
3791:                		if (c == '\r') continue; /* Strip '\r' */
3792:                #endif
3793:                		*p++ = c;
3794:                		n++;
3795:                		if (c == '\n') break; /* Break on EOL */
3796:                	}
3797:                	*p = 0;
3798:                	return n ? buff : 0; /* When no data read (eof or error), return with error. */
3799:                }
3800:                
3801:                #if !_FS_READONLY
3802:                #include <stdarg.h>
3803:                /*-----------------------------------------------------------------------*/
3804:                /* Put a character to the file                                           */
3805:                /*-----------------------------------------------------------------------*/
3806:                int f_putc (
3807:                		TCHAR c, /* A character to be output */
3808:                		FIL* fil /* Pointer to the file object */
3809:                )
3810:                {
3811:                	UINT bw, btw;
3812:                	PF_BYTE s[3];
3813:                
3814:                #if _USE_STRFUNC >= 2
3815:                	if (c == '\n') f_putc ('\r', fil); /* LF -> CRLF conversion */
3816:                #endif
3817:                
3818:                #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
3819:                	if (c < 0x80) { /* 7-bit */
3820:                		s[0] = (PF_BYTE)c;
3821:                		btw = 1;
3822:                	} else {
3823:                		if (c < 0x800) { /* 11-bit */
3824:                			s[0] = (PF_BYTE)(0xC0 | (c >> 6));
3825:                			s[1] = (PF_BYTE)(0x80 | (c & 0x3F));
3826:                			btw = 2;
3827:                		} else { /* 16-bit */
3828:                			s[0] = (PF_BYTE)(0xE0 | (c >> 12));
3829:                			s[1] = (PF_BYTE)(0x80 | ((c >> 6) & 0x3F));
3830:                			s[2] = (PF_BYTE)(0x80 | (c & 0x3F));
3831:                			btw = 3;
3832:                		}
3833:                	}
3834:                #else				/* Write the character without conversion */
3835:                	s[0] = (PF_BYTE)c;
3836:                	btw = 1;
3837:                #endif
3838:                	f_write(fil, s, btw, &bw); /* Write the char to the file */
3839:                	return (bw == btw) ? 1 : EOF; /* Return the result */
3840:                }
3841:                
3842:                /*-----------------------------------------------------------------------*/
3843:                /* Put a string to the file                                              */
3844:                /*-----------------------------------------------------------------------*/
3845:                int f_puts (
3846:                		const TCHAR* str, /* Pointer to the string to be output */
3847:                		FIL* fil /* Pointer to the file object */
3848:                )
3849:                {
3850:                	int n;
3851:                
3852:                	for (n = 0; *str; str++, n++) {
3853:                		if (f_putc(*str, fil) == EOF) return EOF;
3854:                	}
3855:                	return n;
3856:                }
3857:                
3858:                /*-----------------------------------------------------------------------*/
3859:                /* Put a formatted string to the file                                    */
3860:                /*-----------------------------------------------------------------------*/
3861:                int f_printf (
3862:                		FIL* fil, /* Pointer to the file object */
3863:                		const TCHAR* str, /* Pointer to the format string */
3864:                		... /* Optional arguments... */
3865:                )
3866:                {
3867:                	va_list arp;
3868:                	PF_BYTE f, r;
3869:                	UINT i, j, w;
3870:                	ULONG v;
3871:                	TCHAR c, d, s[16], *p;
3872:                	int res, chc, cc;
3873:                
3874:                	va_start(arp, str);
3875:                
3876:                	for (cc = res = 0; cc != EOF; res += cc) {
3877:                		c = *str++;
3878:                		if (c == 0) break; /* End of string */
3879:                		if (c != '%') { /* Non escape character */
3880:                			cc = f_putc(c, fil);
3881:                			if (cc != EOF) cc = 1;
3882:                			continue;
3883:                		}
3884:                		w = f = 0;
3885:                		c = *str++;
3886:                		if (c == '0') { /* Flag: '0' padding */
3887:                			f = 1; c = *str++;
3888:                		} else {
3889:                			if (c == '-') { /* Flag: left justified */
3890:                				f = 2; c = *str++;
3891:                			}
3892:                		}
3893:                		while (IsDigit(c)) { /* Precision */
3894:                			w = w * 10 + c - '0';
3895:                			c = *str++;
3896:                		}
3897:                		if (c == 'l' || c == 'L') { /* Prefix: Size is long int */
3898:                			f |= 4; c = *str++;
3899:                		}
3900:                		if (!c) break;
3901:                		d = c;
3902:                		if (IsLower(d)) d -= 0x20;
3903:                		switch (d) { /* Type is... */
3904:                			case 'S' : /* String */
3905:                			p = va_arg(arp, TCHAR*);
3906:                			for (j = 0; p[j]; j++);
3907:                			chc = 0;
3908:                			if (!(f & 2)) {
3909:                				while (j++ < w) chc += (cc = f_putc(' ', fil));
3910:                			}
3911:                			chc += (cc = f_puts(p, fil));
3912:                			while (j++ < w) chc += (cc = f_putc(' ', fil));
3913:                			if (cc != EOF) cc = chc;
3914:                			continue;
3915:                			case 'C' : /* Character */
3916:                			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
3917:                			case 'B' : /* Binary */
3918:                			r = 2; break;
3919:                			case 'O' : /* Octal */
3920:                			r = 8; break;
3921:                			case 'D' : /* Signed decimal */
3922:                			case 'U' : /* Unsigned decimal */
3923:                			r = 10; break;
3924:                			case 'X' : /* Hexdecimal */
3925:                			r = 16; break;
3926:                			default: /* Unknown type (passthrough) */
3927:                			cc = f_putc(c, fil); continue;
3928:                		}
3929:                
3930:                		/* Get an argument and put it in numeral */
3931:                		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
3932:                		if (d == 'D' && (v & 0x80000000)) {
3933:                			v = 0 - v;
3934:                			f |= 8;
3935:                		}
3936:                		i = 0;
3937:                		do {
3938:                			d = (TCHAR)(v % r); v /= r;
3939:                			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
3940:                			s[i++] = d + '0';
3941:                		}while (v && i < sizeof(s) / sizeof(s[0]));
3942:                		if (f & 8) s[i++] = '-';
3943:                		j = i; d = (f & 1) ? '0' : ' ';
3944:                		res = 0;
3945:                		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
3946:                		do res += (cc = f_putc(s[--i], fil)); while(i);
3947:                		while (j++ < w) res += (cc = f_putc(' ', fil));
3948:                		if (cc != EOF) cc = res;
3949:                	}
3950:                
3951:                	va_end(arp);
3952:                	return (cc == EOF) ? cc : res;
3953:                }
3954:                
3955:                #endif /* !_FS_READONLY */
3956:                #endif /* _USE_STRFUNC */
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/diskio.c  -----------------------------
1:                   /*------------------------------------------------------------------------/
2:                    /  MMCv3/SDv1/SDv2 (in SPI mode) control module
3:                    /-------------------------------------------------------------------------/
4:                    /
5:                    /  Copyright (C) 2010, ChaN, all right reserved.
6:                    /
7:                    / * This software is a free software and there is NO WARRANTY.
8:                    / * No restriction on use. You can use, modify and redistribute it for
9:                    /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
10:                   / * Redistributions of source code must retain the above copyright notice.
11:                   /
12:                   /-------------------------------------------------------------------------*/
13:                  
14:                  // 07 May 2012 Changes made to allow SD card library to support
15:                  //					PIC32 Pinguino Micro and potentially other cards that
16:                  //					do not support the use of the RTCC library.
17:                  // 25 May 2012 Added includes for delay.c and digitalw.c
18:                  
19:                  //#include "ff.h"
20:                  #include "diskio.h"
21:                  //#include <delay.c>
22:                  //#include <digitalw.c>
23:                  #include "../HardwareProfile.h"
24:                  #include "sdmmc.h"
25:                  
26:                  // For boards known to support the RTCC library ***Added 07 May 2012
27:                  // to allow SD Library to support PIC32 Pinguino Micro, which
28:                  // which does not have a RTCC crystal and associated components,
29:                  // and would not operate if #include <rtcc.c> is included.
30:                  // See also changes to get_fattime() below.
31:                  
32:                  #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
33:                  	#include <rtcc.c>
34:                  #endif
35:                  
36:                  /* Definitions for MMC/SDC command */
37:                  #define CMD0   (0)			/* GO_IDLE_STATE */
38:                  #define CMD1   (1)			/* SEND_OP_COND */
39:                  #define ACMD41 (41|0x80)	/* SEND_OP_COND (SDC) */
40:                  #define CMD8   (8)			/* SEND_IF_COND */
41:                  #define CMD9   (9)			/* SEND_CSD */
42:                  #define CMD10  (10)			/* SEND_CID */
43:                  #define CMD12  (12)			/* STOP_TRANSMISSION */
44:                  #define ACMD13 (13|0x80)	/* SD_STATUS (SDC) */
45:                  #define CMD16  (16)			/* SET_BLOCKLEN */
46:                  #define CMD17  (17)			/* READ_SINGLE_BLOCK */
47:                  #define CMD18  (18)			/* READ_MULTIPLE_BLOCK */
48:                  #define CMD23  (23)			/* SET_BLOCK_COUNT */
49:                  #define ACMD23 (23|0x80)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
50:                  #define CMD24  (24)			/* WRITE_BLOCK */
51:                  #define CMD25  (25)			/* WRITE_MULTIPLE_BLOCK */
52:                  #define CMD41  (41)			/* SEND_OP_COND (ACMD) */
53:                  #define CMD55  (55)			/* APP_CMD */
54:                  #define CMD58  (58)			/* READ_OCR */
55:                  
56:                  /* Port Controls  (Platform dependent) */
57:                  //#define SOCKPORT	PORTB		/* Socket contact port */
58:                  //#define SOCKWP	(1<<10)		/* Write protect switch (RB10) */
59:                  //#define SOCKINS	(1<<11)		/* Card detect switch (RB11) */
60:                  
61:                  //#define	FCLK_SLOW()			/* Set slow clock (100k-400k) */
62:                  //#define	FCLK_FAST()			/* Set fast clock (depends on the CSD) */
63:                  
64:                  
65:                  /*--------------------------------------------------------------------------
66:                  
67:                   Module Private Functions
68:                  
69:                   ---------------------------------------------------------------------------*/
70:                  
71:                  static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
72:                  
73:                  static volatile UINT16 Timer1, Timer2; /* 1000Hz decrement timer */
74:                  
75:                  static UINT16 CardType;
76:                  
77:                  /*-----------------------------------------------------------------------*/
78:                  /* Exchange a byte between PIC and MMC via SPI  (Platform dependent)     */
79:                  /*-----------------------------------------------------------------------*/
80:                  
81:                  #define xmit_spi(dat) 	writeSPI(dat)
82:                  #define rcvr_spi()	writeSPI(0xFF)
83:                  #define rcvr_spi_m(p)	SPI2BUF = 0xFF; while (!SPI2STATbits.SPIRBF); *(p) = (PF_BYTE)SPI2BUF;
84:                  #define xchg_spi (dat)  writeSPI(dat)
85:                  #define DLY_US(i)	delay_us(i)
86:                  #define CS_H()		(PORTB|=SDCSEL)//digitalwrite(SDCS, HIGH)
87:                  #define CS_L()		(PORTB&=~SDCSEL)//digitalwrite(SDCS, LOW)
88:                  
89:                  /*-----------------------------------------------------------------------*/
90:                  /* Wait for card ready                                                   */
91:                  /*-----------------------------------------------------------------------*/
92:                  
93:                  static
94:                  int wait_ready(void) {
9D0066A8  27BDFFE0   ADDIU SP, SP, -32
9D0066AC  AFBF001C   SW RA, 28(SP)
9D0066B0  AFB10018   SW S1, 24(SP)
9D0066B4  AFB00014   SW S0, 20(SP)
9D0066B8  24111388   ADDIU S1, ZERO, 5000
95:                  	PF_BYTE d;
96:                  	UINT16 tmr;
97:                  
98:                  	for (tmr = 5000; tmr; tmr--) { /* Wait for ready in timeout of 500ms */
9D0066E4  1620FFF5   BNE S1, ZERO, 0x9D0066BC
9D0066E8  3A0200FF   XORI V0, S0, 255
99:                  		d = rcvr_spi();
9D0066BC  0F402066   JAL writeSPI
9D0066C0  240400FF   ADDIU A0, ZERO, 255
9D0066C4  00408021   ADDU S0, V0, ZERO
100:                 		if (d == 0xFF)
9D0066C8  240200FF   ADDIU V0, ZERO, 255
9D0066CC  12020007   BEQ S0, V0, 0x9D0066EC
9D0066D0  3A0200FF   XORI V0, S0, 255
101:                 			break;
102:                 		DLY_US(100);
9D0066D4  0F40240F   JAL delay_us
9D0066D8  24040064   ADDIU A0, ZERO, 100
9D0066DC  2631FFFF   ADDIU S1, S1, -1
9D0066E0  3231FFFF   ANDI S1, S1, -1
103:                 	}
104:                 
105:                 	return (d == 0xFF) ? 1 : 0;
106:                 }
9D0066EC  2C420001   SLTIU V0, V0, 1
9D0066F0  8FBF001C   LW RA, 28(SP)
9D0066F4  8FB10018   LW S1, 24(SP)
9D0066F8  8FB00014   LW S0, 20(SP)
9D0066FC  03E00008   JR RA
9D006700  27BD0020   ADDIU SP, SP, 32
107:                 
108:                 /*-----------------------------------------------------------------------*/
109:                 /* Deselect the card and release SPI bus                                 */
110:                 /*-----------------------------------------------------------------------*/
111:                 
112:                 #define deselect() disableSD();
113:                 
114:                 /*-----------------------------------------------------------------------*/
115:                 /* Select the card and wait ready                                        */
116:                 /*-----------------------------------------------------------------------*/
117:                 
118:                 static int select(void) /* 1:Successful, 0:Timeout */
119:                 {
9D006704  27BDFFE8   ADDIU SP, SP, -24
9D006708  AFBF0014   SW RA, 20(SP)
120:                 	enableSD();
9D00670C  0F40208D   JAL enableSD
9D006710  00000000   NOP
121:                 	rcvr_spi(); /* Dummy clock (force DO enabled) */
9D006714  0F402066   JAL writeSPI
9D006718  240400FF   ADDIU A0, ZERO, 255
122:                 
123:                 	if (wait_ready())
9D00671C  0F4019AA   JAL 0x9D0066A8
9D006720  00000000   NOP
9D006724  14400004   BNE V0, ZERO, 0x9D006738
9D006728  24030001   ADDIU V1, ZERO, 1
124:                 		return 1; /* OK */
125:                 	deselect();
9D00672C  0F402082   JAL disableSD
9D006730  00000000   NOP
126:                 	return 0; /* Timeout */
9D006734  00001821   ADDU V1, ZERO, ZERO
127:                 }
9D006738  00601021   ADDU V0, V1, ZERO
9D00673C  8FBF0014   LW RA, 20(SP)
9D006740  03E00008   JR RA
9D006744  27BD0018   ADDIU SP, SP, 24
128:                 
129:                 /*-----------------------------------------------------------------------*/
130:                 /* Receive a data packet from MMC                                        */
131:                 /*-----------------------------------------------------------------------*/
132:                 
133:                 static int rcvr_datablock( /* 1:OK, 0:Failed */
9D0069CC  0B401A54   J 0x9D006950
9D0069D0  26310004   ADDIU S1, S1, 4
134:                                           PF_BYTE *buff, /* Data buffer to store received data */
135:                                           UINT16 btr /* Byte count (must be multiple of 4) */
136:                                           ) {
9D0068E8  27BDFFE0   ADDIU SP, SP, -32
9D0068EC  AFBF001C   SW RA, 28(SP)
9D0068F0  AFB20018   SW S2, 24(SP)
9D0068F4  AFB10014   SW S1, 20(SP)
9D0068F8  AFB00010   SW S0, 16(SP)
9D0068FC  00808821   ADDU S1, A0, ZERO
9D006900  00A09021   ADDU S2, A1, ZERO
9D006904  241003E8   ADDIU S0, ZERO, 1000
137:                 	PF_BYTE d;
138:                 	UINT16 tmr;
139:                 
140:                 	for (tmr = 1000; tmr; tmr--) { /* Wait for data packet in timeout of 100ms */
9D00692C  1600FFF6   BNE S0, ZERO, 0x9D006908
9D006930  00001821   ADDU V1, ZERO, ZERO
141:                 		d = rcvr_spi();
9D006908  0F402066   JAL writeSPI
9D00690C  240400FF   ADDIU A0, ZERO, 255
142:                 		if (d != 0xFF)
9D006910  240300FF   ADDIU V1, ZERO, 255
9D006914  14430009   BNE V0, V1, 0x9D00693C
9D006918  240400FE   ADDIU A0, ZERO, 254
143:                 			break;
144:                 		DLY_US(100);
9D00691C  0F40240F   JAL delay_us
9D006920  24040064   ADDIU A0, ZERO, 100
9D006924  2610FFFF   ADDIU S0, S0, -1
9D006928  3210FFFF   ANDI S0, S0, -1
145:                 	}
146:                 	if (d != 0xFE)
9D00693C  1444002A   BNE V0, A0, 0x9D0069E8
9D006940  00001821   ADDU V1, ZERO, ZERO
147:                 		return 0; /* If not valid data token, return with error */
148:                 
149:                 	do { /* Receive the data block into buffer */
150:                 		rcvr_spi_m(buff++);
9D006944  3C04BF80   LUI A0, -16512
9D006948  240500FF   ADDIU A1, ZERO, 255
9D00694C  3C02BF80   LUI V0, -16512
9D006950  AC855A20   SW A1, 23072(A0)
9D006954  8C435A10   LW V1, 23056(V0)
9D006958  30630001   ANDI V1, V1, 1
9D00695C  1060FFFD   BEQ V1, ZERO, 0x9D006954
9D006960  00000000   NOP
9D006964  8C835A20   LW V1, 23072(A0)
9D006968  A2230000   SB V1, 0(S1)
151:                 		rcvr_spi_m(buff++);
9D00696C  AC855A20   SW A1, 23072(A0)
9D006970  8C435A10   LW V1, 23056(V0)
9D006974  30630001   ANDI V1, V1, 1
9D006978  1060FFFD   BEQ V1, ZERO, 0x9D006970
9D00697C  00000000   NOP
9D006980  8C835A20   LW V1, 23072(A0)
9D006984  A2230001   SB V1, 1(S1)
152:                 		rcvr_spi_m(buff++);
9D006988  AC855A20   SW A1, 23072(A0)
9D00698C  8C435A10   LW V1, 23056(V0)
9D006990  30630001   ANDI V1, V1, 1
9D006994  1060FFFD   BEQ V1, ZERO, 0x9D00698C
9D006998  00000000   NOP
9D00699C  8C835A20   LW V1, 23072(A0)
9D0069A0  A2230002   SB V1, 2(S1)
153:                 		rcvr_spi_m(buff++);
9D0069A4  AC855A20   SW A1, 23072(A0)
9D0069A8  8C435A10   LW V1, 23056(V0)
9D0069AC  30630001   ANDI V1, V1, 1
9D0069B0  1060FFFD   BEQ V1, ZERO, 0x9D0069A8
9D0069B4  00000000   NOP
9D0069B8  8C835A20   LW V1, 23072(A0)
154:                 	} while (btr -= 4);
9D0069BC  2652FFFC   ADDIU S2, S2, -4
9D0069C0  3252FFFF   ANDI S2, S2, -1
9D0069C4  12400003   BEQ S2, ZERO, 0x9D0069D4
9D0069C8  A2230003   SB V1, 3(S1)
155:                 	rcvr_spi(); /* Discard CRC */
9D0069D4  0F402066   JAL writeSPI
9D0069D8  240400FF   ADDIU A0, ZERO, 255
156:                 	rcvr_spi();
9D0069DC  0F402066   JAL writeSPI
9D0069E0  240400FF   ADDIU A0, ZERO, 255
157:                 
158:                 	return 1; /* Return with success */
9D0069E4  24030001   ADDIU V1, ZERO, 1
159:                 }
9D006934  0B401A7B   J 0x9D0069EC
9D006938  00601021   ADDU V0, V1, ZERO
9D0069E8  00601021   ADDU V0, V1, ZERO
9D0069EC  8FBF001C   LW RA, 28(SP)
9D0069F0  8FB20018   LW S2, 24(SP)
9D0069F4  8FB10014   LW S1, 20(SP)
9D0069F8  8FB00010   LW S0, 16(SP)
9D0069FC  03E00008   JR RA
9D006A00  27BD0020   ADDIU SP, SP, 32
160:                 
161:                 /*-----------------------------------------------------------------------*/
162:                 /* Send a data packet to MMC                                             */
163:                 /*-----------------------------------------------------------------------*/
164:                 
165:                 #if _READONLY == 0
166:                 static int xmit_datablock( /* 1:OK, 0:Failed */
9D00688C  26110200   ADDIU S1, S0, 512
9D0068C8  38630005   XORI V1, V1, 5
9D0068CC  2C630001   SLTIU V1, V1, 1
167:                                           const PF_BYTE *buff, /* 512 byte data block to be transmitted */
168:                                           PF_BYTE token /* Data token */
169:                                           ) {
9D006854  27BDFFE0   ADDIU SP, SP, -32
9D006858  AFBF001C   SW RA, 28(SP)
9D00685C  AFB10018   SW S1, 24(SP)
9D006860  AFB00014   SW S0, 20(SP)
9D006864  00808021   ADDU S0, A0, ZERO
170:                 	PF_BYTE resp;
171:                 	UINT16 bc = BLK_SIZE;
172:                 
173:                 	if (!wait_ready())
9D006868  0F4019AA   JAL 0x9D0066A8
9D00686C  00A08821   ADDU S1, A1, ZERO
9D006870  10400017   BEQ V0, ZERO, 0x9D0068D0
9D006874  00001821   ADDU V1, ZERO, ZERO
174:                 		return 0;
175:                 
176:                 	xmit_spi(token); /* Xmit a token */
9D006878  0F402066   JAL writeSPI
9D00687C  02202021   ADDU A0, S1, ZERO
177:                 	if (token != 0xFD) { /* Not StopTran token */
9D006880  240200FD   ADDIU V0, ZERO, 253
9D006884  12220012   BEQ S1, V0, 0x9D0068D0
9D006888  24030001   ADDIU V1, ZERO, 1
178:                 		do { /* Xmit the 512 byte data block to the MMC */
179:                 			xmit_spi(*buff++);
9D006890  0F402066   JAL writeSPI
9D006894  92040000   LBU A0, 0(S0)
180:                 			xmit_spi(*buff++);
9D006898  92040001   LBU A0, 1(S0)
9D00689C  0F402066   JAL writeSPI
9D0068A0  26100002   ADDIU S0, S0, 2
181:                 		} while (bc -= 2);
9D0068A4  1630FFFA   BNE S1, S0, 0x9D006890
9D0068A8  00000000   NOP
182:                 		xmit_spi(0xFF); /* CRC (Dummy) */
9D0068AC  0F402066   JAL writeSPI
9D0068B0  240400FF   ADDIU A0, ZERO, 255
183:                 		xmit_spi(0xFF);
9D0068B4  0F402066   JAL writeSPI
9D0068B8  240400FF   ADDIU A0, ZERO, 255
184:                 		resp = rcvr_spi(); /* Receive a data response */
9D0068BC  0F402066   JAL writeSPI
9D0068C0  240400FF   ADDIU A0, ZERO, 255
185:                 		if ((resp & 0x1F) != 0x05) /* If not accepted, return with error */
9D0068C4  3043001F   ANDI V1, V0, 31
186:                 			return 0;
187:                 	}
188:                 
189:                 	return 1;
190:                 }
9D0068D0  00601021   ADDU V0, V1, ZERO
9D0068D4  8FBF001C   LW RA, 28(SP)
9D0068D8  8FB10018   LW S1, 24(SP)
9D0068DC  8FB00014   LW S0, 20(SP)
9D0068E0  03E00008   JR RA
9D0068E4  27BD0020   ADDIU SP, SP, 32
191:                 #endif	/* _READONLY */
192:                 
193:                 /*-----------------------------------------------------------------------*/
194:                 /* Send a command packet to MMC                                          */
195:                 /*-----------------------------------------------------------------------*/
196:                 
197:                 static PF_BYTE send_cmd(PF_BYTE cmd, /* Command byte */
198:                                         DWORD arg /* Argument */
199:                                         ) {
9D006748  27BDFFE0   ADDIU SP, SP, -32
9D00674C  AFBF001C   SW RA, 28(SP)
9D006750  AFB10018   SW S1, 24(SP)
9D006754  AFB00014   SW S0, 20(SP)
9D006758  00A08821   ADDU S1, A1, ZERO
9D0067F4  2410000A   ADDIU S0, ZERO, 10
9D00683C  0B4019FE   J 0x9D0067F8
9D006840  2410000A   ADDIU S0, ZERO, 10
9D00684C  0B4019FE   J 0x9D0067F8
9D006850  2410000A   ADDIU S0, ZERO, 10
200:                 	PF_BYTE n, res;
201:                 
202:                 	if (cmd & 0x80) { /* ACMD<n> is the command sequense of CMD55-CMD<n> */
9D00675C  7C041420   SEB V0, A0
9D006760  04410009   BGEZ V0, 0x9D006788
9D006764  00808021   ADDU S0, A0, ZERO
203:                 		cmd &= 0x7F;
9D006784  3210007F   ANDI S0, S0, 127
204:                 		res = send_cmd(CMD55, 0);
9D006768  24040037   ADDIU A0, ZERO, 55
9D00676C  0F4019D2   JAL 0x9D006748
9D006770  00002821   ADDU A1, ZERO, ZERO
9D006774  00401821   ADDU V1, V0, ZERO
205:                 		if (res > 1)
9D006778  2C420002   SLTIU V0, V0, 2
9D00677C  10400028   BEQ V0, ZERO, 0x9D006820
9D006780  00601021   ADDU V0, V1, ZERO
206:                 			return res;
207:                 	}
208:                 
209:                 	/* Select the card and wait for ready */
210:                 	deselect();
9D006788  0F402082   JAL disableSD
9D00678C  00000000   NOP
211:                 	if (!select())
9D006790  0F4019C1   JAL 0x9D006704
9D006794  00000000   NOP
9D006798  10400020   BEQ V0, ZERO, 0x9D00681C
9D00679C  240300FF   ADDIU V1, ZERO, 255
212:                 		return 0xFF;
213:                 
214:                 	/* Send command packet */
215:                 	xmit_spi(0x40 | cmd); /* Start + Command index */
9D0067A0  0F402066   JAL writeSPI
9D0067A4  36040040   ORI A0, S0, 64
216:                 	xmit_spi((PF_BYTE)(arg >> 24)); /* Argument[31..24] */
9D0067A8  0F402066   JAL writeSPI
9D0067AC  00112602   SRL A0, S1, 24
217:                 	xmit_spi((PF_BYTE)(arg >> 16)); /* Argument[23..16] */
9D0067B0  0F402066   JAL writeSPI
9D0067B4  7E243C00   EXT A0, S1, 16, 8
218:                 	xmit_spi((PF_BYTE)(arg >> 8)); /* Argument[15..8] */
9D0067B8  0F402066   JAL writeSPI
9D0067BC  7E243A00   EXT A0, S1, 8, 8
219:                 	xmit_spi((PF_BYTE)arg); /* Argument[7..0] */
9D0067C0  0F402066   JAL writeSPI
9D0067C4  322400FF   ANDI A0, S1, 255
220:                 	n = 0x01; /* Dummy CRC + Stop */
221:                 	if (cmd == CMD0)
9D0067C8  1200001E   BEQ S0, ZERO, 0x9D006844
9D0067CC  24020008   ADDIU V0, ZERO, 8
222:                 		n = 0x95; /* Valid CRC for CMD0(0) */
223:                 	if (cmd == CMD8)
9D0067D0  12020018   BEQ S0, V0, 0x9D006834
9D0067D4  00000000   NOP
224:                 		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
225:                 	xmit_spi(n);
9D0067D8  0F402066   JAL writeSPI
9D0067DC  24040001   ADDIU A0, ZERO, 1
9D006834  0F402066   JAL writeSPI
9D006838  24040087   ADDIU A0, ZERO, 135
9D006844  0F402066   JAL writeSPI
9D006848  24040095   ADDIU A0, ZERO, 149
226:                 
227:                 	/* Receive command response */
228:                 	if (cmd == CMD12)
9D0067E0  2402000C   ADDIU V0, ZERO, 12
9D0067E4  16020004   BNE S0, V0, 0x9D0067F8
9D0067E8  2410000A   ADDIU S0, ZERO, 10
229:                 		rcvr_spi(); /* Skip a stuff byte when stop reading */
9D0067EC  0F402066   JAL writeSPI
9D0067F0  240400FF   ADDIU A0, ZERO, 255
230:                 	n = 10; /* Wait for a valid response in timeout of 10 attempts */
231:                 	do
232:                 		res = rcvr_spi();
9D0067F8  0F402066   JAL writeSPI
9D0067FC  240400FF   ADDIU A0, ZERO, 255
9D006800  00401821   ADDU V1, V0, ZERO
233:                 	while ((res & 0x80) && --n);
9D006804  7C021420   SEB V0, V0
9D006808  04410004   BGEZ V0, 0x9D00681C
9D00680C  2610FFFF   ADDIU S0, S0, -1
9D006810  321000FF   ANDI S0, S0, 255
9D006814  1600FFF8   BNE S0, ZERO, 0x9D0067F8
9D006818  00000000   NOP
234:                 
235:                 	return res; /* Return with the response value */
236:                 }
9D00681C  00601021   ADDU V0, V1, ZERO
9D006820  8FBF001C   LW RA, 28(SP)
9D006824  8FB10018   LW S1, 24(SP)
9D006828  8FB00014   LW S0, 20(SP)
9D00682C  03E00008   JR RA
9D006830  27BD0020   ADDIU SP, SP, 32
237:                 
238:                 /*--------------------------------------------------------------------------
239:                 
240:                  Public Functions
241:                 
242:                  ---------------------------------------------------------------------------*/
243:                 
244:                 /*-----------------------------------------------------------------------*/
245:                 /* Initialize Disk Drive                                                 */
246:                 /*-----------------------------------------------------------------------*/
247:                 
248:                 DSTATUS disk_initialize(PF_BYTE drv /* Physical drive number (0) */
9D006AB4  27B10014   ADDIU S1, SP, 20
9D006B50  27A40010   ADDIU A0, SP, 16
9D006B54  00901821   ADDU V1, A0, S0
249:                                         ) {
9D006A04  27BDFFD8   ADDIU SP, SP, -40
9D006A08  AFBF0024   SW RA, 36(SP)
9D006A0C  AFB10020   SW S1, 32(SP)
9D006A10  AFB0001C   SW S0, 28(SP)
9D006A14  308400FF   ANDI A0, A0, 255
250:                 	PF_BYTE n, ty, cmd, buf[4];
251:                 	UINT16 tmr;
252:                 	DSTATUS s = 0;
253:                 	if (drv)
9D006A18  14800084   BNE A0, ZERO, 0x9D006C2C
9D006A1C  24020001   ADDIU V0, ZERO, 1
254:                 		return STA_NOINIT; /* Supports only single drive */
255:                 	if (Stat & STA_NODISK)
9D006A20  93828010   LBU V0, -32752(GP)
9D006A24  30420002   ANDI V0, V0, 2
9D006A28  10400004   BEQ V0, ZERO, 0x9D006A3C
9D006A2C  00000000   NOP
256:                 		return Stat; /* No card in the socket */
9D006A30  93828010   LBU V0, -32752(GP)
9D006A34  0B401B0B   J 0x9D006C2C
9D006A38  304200FF   ANDI V0, V0, 255
257:                 
258:                 	deselect(); /* Force socket power on */
9D006A3C  0F402082   JAL disableSD
9D006A40  2410000A   ADDIU S0, ZERO, 10
259:                 	//FCLK_SLOW();
260:                 	for (n = 10; n; n--)
9D006A54  1600FFFB   BNE S0, ZERO, 0x9D006A44
9D006A58  3C02BF88   LUI V0, -16504
261:                 		rcvr_spi(); /* 80 dummy clocks */
9D006A44  0F402066   JAL writeSPI
9D006A48  240400FF   ADDIU A0, ZERO, 255
9D006A4C  2610FFFF   ADDIU S0, S0, -1
9D006A50  321000FF   ANDI S0, S0, 255
262:                 	CS_H();
9D006A5C  8C436120   LW V1, 24864(V0)
9D006A60  34630004   ORI V1, V1, 4
9D006A64  AC436120   SW V1, 24864(V0)
9D006A68  2410000A   ADDIU S0, ZERO, 10
263:                 	for (n = 10; n; n--)
9D006A7C  1600FFFB   BNE S0, ZERO, 0x9D006A6C
9D006A80  00002021   ADDU A0, ZERO, ZERO
264:                 		rcvr_spi(); /* 80 dummy clocks */
9D006A6C  0F402066   JAL writeSPI
9D006A70  240400FF   ADDIU A0, ZERO, 255
9D006A74  2610FFFF   ADDIU S0, S0, -1
9D006A78  321000FF   ANDI S0, S0, 255
265:                 
266:                 	ty = 0;
267:                 	if (send_cmd(CMD0, 0) == 1) { /* Enter Idle state */
9D006A84  0F4019D2   JAL 0x9D006748
9D006A88  00002821   ADDU A1, ZERO, ZERO
9D006A8C  24030001   ADDIU V1, ZERO, 1
9D006A90  5443006B   BNEL V0, V1, 0x9D006C40
9D006A94  A780802C   SH ZERO, -32724(GP)
268:                 		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2? */
9D006A98  24040008   ADDIU A0, ZERO, 8
9D006A9C  0F4019D2   JAL 0x9D006748
9D006AA0  240501AA   ADDIU A1, ZERO, 426
9D006AA4  24030001   ADDIU V1, ZERO, 1
9D006AA8  14430035   BNE V0, V1, 0x9D006B80
9D006AAC  240400A9   ADDIU A0, ZERO, 169
9D006AB0  27B00010   ADDIU S0, SP, 16
269:                 			for (n = 0; n < 4; n++)
9D006AC8  1611FFFB   BNE S0, S1, 0x9D006AB8
9D006ACC  93A30012   LBU V1, 18(SP)
270:                 				buf[n] = rcvr_spi(); /* Get trailing return value of R7 resp */
9D006AB8  0F402066   JAL writeSPI
9D006ABC  240400FF   ADDIU A0, ZERO, 255
9D006AC0  A2020000   SB V0, 0(S0)
9D006AC4  26100001   ADDIU S0, S0, 1
271:                 			if (buf[2] == 0x01 && buf[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
9D006AD0  24020001   ADDIU V0, ZERO, 1
9D006AD4  54620050   BNEL V1, V0, 0x9D006C18
9D006AD8  A780802C   SH ZERO, -32724(GP)
9D006ADC  93A30013   LBU V1, 19(SP)
9D006AE0  240200AA   ADDIU V0, ZERO, 170
9D006AE4  54620056   BNEL V1, V0, 0x9D006C40
9D006AE8  A780802C   SH ZERO, -32724(GP)
9D006AEC  241003E8   ADDIU S0, ZERO, 1000
272:                 				for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state (ACMD41 with HCS bit) */
9D006B0C  2610FFFF   ADDIU S0, S0, -1
9D006B10  3210FFFF   ANDI S0, S0, -1
9D006B14  1600FFF7   BNE S0, ZERO, 0x9D006AF4
9D006B18  240400A9   ADDIU A0, ZERO, 169
273:                 					if (send_cmd(ACMD41, 1UL << 30) == 0)
9D006AF0  240400A9   ADDIU A0, ZERO, 169
9D006AF4  0F4019D2   JAL 0x9D006748
9D006AF8  3C054000   LUI A1, 16384
9D006AFC  10400009   BEQ V0, ZERO, 0x9D006B24
9D006B00  00000000   NOP
274:                 						break;
275:                 					DLY_US(1000);
9D006B04  0F40240F   JAL delay_us
9D006B08  240403E8   ADDIU A0, ZERO, 1000
276:                 				}
277:                 				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
9D006B24  52000046   BEQL S0, ZERO, 0x9D006C40
9D006B28  A780802C   SH ZERO, -32724(GP)
9D006B2C  2404003A   ADDIU A0, ZERO, 58
9D006B30  0F4019D2   JAL 0x9D006748
9D006B34  00002821   ADDU A1, ZERO, ZERO
9D006B38  54400041   BNEL V0, ZERO, 0x9D006C40
9D006B3C  A780802C   SH ZERO, -32724(GP)
9D006B40  00008021   ADDU S0, ZERO, ZERO
278:                 					for (n = 0; n < 4; n++)
9D006B44  24110004   ADDIU S1, ZERO, 4
9D006B5C  1611FFFA   BNE S0, S1, 0x9D006B48
9D006B60  A0620000   SB V0, 0(V1)
279:                 						buf[n] = rcvr_spi();
9D006B48  0F402066   JAL writeSPI
9D006B4C  240400FF   ADDIU A0, ZERO, 255
9D006B58  26100001   ADDIU S0, S0, 1
280:                 					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 */
9D006B64  93A40010   LBU A0, 16(SP)
9D006B68  30840040   ANDI A0, A0, 64
9D006B6C  24030004   ADDIU V1, ZERO, 4
9D006B70  2402000C   ADDIU V0, ZERO, 12
9D006B74  0064100A   MOVZ V0, V1, A0
281:                 				}
282:                 			}
283:                 		} else { /* SDv1 or MMCv3 */
284:                 			if (send_cmd(ACMD41, 0) <= 1) {
9D006B80  0F4019D2   JAL 0x9D006748
9D006B84  00002821   ADDU A1, ZERO, ZERO
9D006B88  2C420002   SLTIU V0, V0, 2
285:                 				ty = CT_SD1;
9D006B8C  24030002   ADDIU V1, ZERO, 2
9D006B90  24040001   ADDIU A0, ZERO, 1
9D006B94  00608821   ADDU S1, V1, ZERO
9D006B98  0082880A   MOVZ S1, A0, V0
286:                 				cmd = ACMD41; /* SDv1 */
287:                 			} else {
288:                 				ty = CT_MMC;
289:                 				cmd = CMD1; /* MMCv3 */
290:                 			}
291:                 			for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state */
9D006B9C  241003E8   ADDIU S0, ZERO, 1000
9D006BBC  2610FFFF   ADDIU S0, S0, -1
9D006BC0  3210FFFF   ANDI S0, S0, -1
9D006BC4  1600FFF7   BNE S0, ZERO, 0x9D006BA4
9D006BC8  240400A9   ADDIU A0, ZERO, 169
292:                 				if (send_cmd(ACMD41, 0) == 0)
9D006BA0  240400A9   ADDIU A0, ZERO, 169
9D006BA4  0F4019D2   JAL 0x9D006748
9D006BA8  00002821   ADDU A1, ZERO, ZERO
9D006BAC  10400009   BEQ V0, ZERO, 0x9D006BD4
9D006BB0  00000000   NOP
293:                 					break;
294:                 				DLY_US(1000);
9D006BB4  0F40240F   JAL delay_us
9D006BB8  240403E8   ADDIU A0, ZERO, 1000
295:                 			}
296:                 			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
9D006BD4  5200001A   BEQL S0, ZERO, 0x9D006C40
9D006BD8  A780802C   SH ZERO, -32724(GP)
9D006BDC  24040010   ADDIU A0, ZERO, 16
9D006BE0  0F4019D2   JAL 0x9D006748
9D006BE4  24050200   ADDIU A1, ZERO, 512
9D006BE8  54400015   BNEL V0, ZERO, 0x9D006C40
9D006BEC  A780802C   SH ZERO, -32724(GP)
297:                 				ty = 0;
298:                 		}
299:                 	}
300:                 	CardType = ty;
9D006B1C  0B401B10   J 0x9D006C40
9D006B20  A780802C   SH ZERO, -32724(GP)
9D006B78  0B401AFF   J 0x9D006BFC
9D006B7C  A782802C   SH V0, -32724(GP)
9D006BCC  0B401B10   J 0x9D006C40
9D006BD0  A780802C   SH ZERO, -32724(GP)
9D006BF0  A791802C   SH S1, -32724(GP)
301:                 	if (ty) {/* Initialization succeded */
9D006BF4  12200008   BEQ S1, ZERO, 0x9D006C18
9D006BF8  24020001   ADDIU V0, ZERO, 1
302:                 		s &= ~STA_NOINIT;
9D006C14  00001021   ADDU V0, ZERO, ZERO
303:                 		// 6. increase speed
304:                 		SPI2CON = 0; // disable the SPI2 module
9D006BFC  3C02BF80   LUI V0, -16512
9D006C00  AC405A00   SW ZERO, 23040(V0)
305:                 		SPI2BRG = 0; // maximum possible baud rate = Fpb/2
9D006C04  3C03BF80   LUI V1, -16512
9D006C08  AC605A30   SW ZERO, 23088(V1)
306:                 		SPI2CON = 0x8120; // re-enable the SPI2 module
9D006C0C  34038120   ORI V1, ZERO, -32480
9D006C10  AC435A00   SW V1, 23040(V0)
307:                 	} else {
308:                 		/* Initialization failed */
309:                 		s |= STA_NOINIT;
9D006C40  0B401B06   J 0x9D006C18
9D006C44  24020001   ADDIU V0, ZERO, 1
310:                 	}
311:                 	Stat = s;
9D006C18  A3828010   SB V0, -32752(GP)
312:                 
313:                 	deselect();
9D006C1C  0F402082   JAL disableSD
9D006C20  00000000   NOP
314:                 
315:                 	return Stat;
9D006C24  93828010   LBU V0, -32752(GP)
9D006C28  304200FF   ANDI V0, V0, 255
316:                 }
9D006C2C  8FBF0024   LW RA, 36(SP)
9D006C30  8FB10020   LW S1, 32(SP)
9D006C34  8FB0001C   LW S0, 28(SP)
9D006C38  03E00008   JR RA
9D006C3C  27BD0028   ADDIU SP, SP, 40
317:                 
318:                 /*-----------------------------------------------------------------------*/
319:                 /* Get Disk Status                                                       */
320:                 /*-----------------------------------------------------------------------*/
321:                 
322:                 DSTATUS disk_status(PF_BYTE drv /* Physical drive number (0) */
323:                 ) {
9D006C48  308400FF   ANDI A0, A0, 255
324:                 	if (drv)
9D006C4C  14800003   BNE A0, ZERO, 0x9D006C5C
9D006C50  24020001   ADDIU V0, ZERO, 1
325:                 		return STA_NOINIT; /* Supports only single drive */
326:                 	return Stat;
9D006C54  93828010   LBU V0, -32752(GP)
9D006C58  304200FF   ANDI V0, V0, 255
327:                 }
9D006C5C  03E00008   JR RA
9D006C60  00000000   NOP
328:                 
329:                 /*-----------------------------------------------------------------------*/
330:                 /* Read Sector(s)                                                        */
331:                 /*-----------------------------------------------------------------------*/
332:                 
333:                 DRESULT disk_read(PF_BYTE drv, /* Physical drive nmuber (0) */
334:                                   PF_BYTE *buff, /* Pointer to the data buffer to store read data */
335:                                   DWORD sector, /* Start sector number (LBA) */
336:                                   PF_BYTE count /* Sector count (1..255) */
337:                                   ) {
9D006C64  27BDFFE0   ADDIU SP, SP, -32
9D006C68  AFBF001C   SW RA, 28(SP)
9D006C6C  AFB10018   SW S1, 24(SP)
9D006C70  AFB00014   SW S0, 20(SP)
9D006C74  00A08821   ADDU S1, A1, ZERO
9D006C78  308400FF   ANDI A0, A0, 255
9D006C7C  30F000FF   ANDI S0, A3, 255
338:                 	if (drv || !count)
9D006C80  14800029   BNE A0, ZERO, 0x9D006D28
9D006C84  24020004   ADDIU V0, ZERO, 4
9D006C88  52000028   BEQL S0, ZERO, 0x9D006D2C
9D006C8C  8FBF001C   LW RA, 28(SP)
339:                 		return RES_PARERR;
340:                 	if (Stat & STA_NOINIT)
9D006C90  93838010   LBU V1, -32752(GP)
9D006C94  30630001   ANDI V1, V1, 1
9D006C98  14600023   BNE V1, ZERO, 0x9D006D28
9D006C9C  24020003   ADDIU V0, ZERO, 3
341:                 		return RES_NOTRDY;
342:                 
343:                 	if (!(CardType & CT_BLOCK))
9D006CA0  9783802C   LHU V1, -32724(GP)
9D006CA4  30630008   ANDI V1, V1, 8
344:                 		sector *= BLK_SIZE; /* Convert to byte address if needed */
9D006CA8  00061240   SLL V0, A2, 9
9D006CAC  0043300A   MOVZ A2, V0, V1
345:                 
346:                 	if (count == 1) { /* Single block read */
9D006CB0  24020001   ADDIU V0, ZERO, 1
9D006CB4  1602000A   BNE S0, V0, 0x9D006CE0
9D006CB8  24040012   ADDIU A0, ZERO, 18
347:                 		if ((send_cmd(CMD17, sector) == 0) /* READ_SINGLE_BLOCK */
9D006CBC  24040011   ADDIU A0, ZERO, 17
9D006CC0  0F4019D2   JAL 0x9D006748
9D006CC4  00C02821   ADDU A1, A2, ZERO
9D006CC8  14400014   BNE V0, ZERO, 0x9D006D1C
9D006CCC  02202021   ADDU A0, S1, ZERO
348:                 		&& rcvr_datablock(buff, BLK_SIZE))
9D006CD0  0F401A3A   JAL 0x9D0068E8
9D006CD4  24050200   ADDIU A1, ZERO, 512
349:                 			count = 0;
9D006CD8  0B401B47   J 0x9D006D1C
9D006CDC  0002800B   MOVN S0, ZERO, V0
350:                 	} else { /* Multiple block read */
351:                 		if (send_cmd(CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
9D006CE0  0F4019D2   JAL 0x9D006748
9D006CE4  00C02821   ADDU A1, A2, ZERO
9D006CE8  1440000C   BNE V0, ZERO, 0x9D006D1C
9D006CEC  00000000   NOP
352:                 			do {
353:                 				if (!rcvr_datablock(buff, BLK_SIZE))
9D006CF0  02202021   ADDU A0, S1, ZERO
9D006CF4  0F401A3A   JAL 0x9D0068E8
9D006CF8  24050200   ADDIU A1, ZERO, 512
9D006CFC  10400005   BEQ V0, ZERO, 0x9D006D14
9D006D00  2404000C   ADDIU A0, ZERO, 12
354:                 					break;
355:                 				buff += BLK_SIZE;
356:                 			} while (--count);
9D006D04  2610FFFF   ADDIU S0, S0, -1
9D006D08  321000FF   ANDI S0, S0, 255
9D006D0C  1600FFF8   BNE S0, ZERO, 0x9D006CF0
9D006D10  26310200   ADDIU S1, S1, 512
357:                 			send_cmd(CMD12, 0); /* STOP_TRANSMISSION */
9D006D14  0F4019D2   JAL 0x9D006748
9D006D18  00002821   ADDU A1, ZERO, ZERO
358:                 		}
359:                 	}
360:                 	deselect();
9D006D1C  0F402082   JAL disableSD
9D006D20  00000000   NOP
361:                 
362:                 	return count ? RES_ERROR : RES_OK;
9D006D24  0010102B   SLTU V0, ZERO, S0
363:                 }
9D006D28  8FBF001C   LW RA, 28(SP)
9D006D2C  8FB10018   LW S1, 24(SP)
9D006D30  8FB00014   LW S0, 20(SP)
9D006D34  03E00008   JR RA
9D006D38  27BD0020   ADDIU SP, SP, 32
364:                 
365:                 /*-----------------------------------------------------------------------*/
366:                 /* Write Sector(s)                                                       */
367:                 /*-----------------------------------------------------------------------*/
368:                 
369:                 #if _READONLY == 0
370:                 DRESULT disk_write(PF_BYTE drv, /* Physical drive number (0) */
371:                                    const PF_BYTE *buff, /* Pointer to the data to be written */
372:                                    DWORD sector, /* Start sector number (LBA) */
373:                                    PF_BYTE count /* Sector count (1..255) */
374:                                    ) {
9D006D3C  27BDFFE0   ADDIU SP, SP, -32
9D006D40  AFBF001C   SW RA, 28(SP)
9D006D44  AFB20018   SW S2, 24(SP)
9D006D48  AFB10014   SW S1, 20(SP)
9D006D4C  AFB00010   SW S0, 16(SP)
9D006D50  00A08821   ADDU S1, A1, ZERO
9D006D54  00C08021   ADDU S0, A2, ZERO
9D006D58  308400FF   ANDI A0, A0, 255
9D006D5C  30F200FF   ANDI S2, A3, 255
375:                 	if (drv || !count)
9D006D60  14800035   BNE A0, ZERO, 0x9D006E38
9D006D64  24020004   ADDIU V0, ZERO, 4
9D006D68  52400034   BEQL S2, ZERO, 0x9D006E3C
9D006D6C  8FBF001C   LW RA, 28(SP)
376:                 		return RES_PARERR;
377:                 	if (Stat & STA_NOINIT)
9D006D70  93838010   LBU V1, -32752(GP)
9D006D74  30630001   ANDI V1, V1, 1
9D006D78  1460002F   BNE V1, ZERO, 0x9D006E38
9D006D7C  24020003   ADDIU V0, ZERO, 3
378:                 		return RES_NOTRDY;
379:                 	if (Stat & STA_PROTECT)
9D006D80  93838010   LBU V1, -32752(GP)
9D006D84  30630004   ANDI V1, V1, 4
9D006D88  1460002B   BNE V1, ZERO, 0x9D006E38
9D006D8C  24020002   ADDIU V0, ZERO, 2
380:                 		return RES_WRPRT;
381:                 
382:                 	if (!(CardType & CT_BLOCK))
9D006D90  9782802C   LHU V0, -32724(GP)
9D006D94  30440008   ANDI A0, V0, 8
383:                 		sector *= 512; /* Convert to byte address if needed */
9D006D98  00061A40   SLL V1, A2, 9
9D006D9C  0064800A   MOVZ S0, V1, A0
384:                 
385:                 	if (count == 1) { /* Single block write */
9D006DA0  24030001   ADDIU V1, ZERO, 1
9D006DA4  1643000A   BNE S2, V1, 0x9D006DD0
9D006DA8  30420006   ANDI V0, V0, 6
386:                 		if ((send_cmd(CMD24, sector) == 0) /* WRITE_BLOCK */
9D006DAC  24040018   ADDIU A0, ZERO, 24
9D006DB0  0F4019D2   JAL 0x9D006748
9D006DB4  02002821   ADDU A1, S0, ZERO
9D006DB8  1440001C   BNE V0, ZERO, 0x9D006E2C
9D006DBC  02202021   ADDU A0, S1, ZERO
387:                 		&& xmit_datablock(buff, 0xFE))
9D006DC0  0F401A15   JAL 0x9D006854
9D006DC4  240500FE   ADDIU A1, ZERO, 254
388:                 			count = 0;
9D006DC8  0B401B8B   J 0x9D006E2C
9D006DCC  0002900B   MOVN S2, ZERO, V0
389:                 	} else { /* Multiple block write */
390:                 		if (CardType & CT_SDC)
9D006DD0  10400005   BEQ V0, ZERO, 0x9D006DE8
9D006DD4  24040019   ADDIU A0, ZERO, 25
391:                 			send_cmd(ACMD23, count);
9D006DD8  24040097   ADDIU A0, ZERO, 151
9D006DDC  0F4019D2   JAL 0x9D006748
9D006DE0  02402821   ADDU A1, S2, ZERO
392:                 		if (send_cmd(CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
9D006DE4  24040019   ADDIU A0, ZERO, 25
9D006DE8  0F4019D2   JAL 0x9D006748
9D006DEC  02002821   ADDU A1, S0, ZERO
9D006DF0  1440000E   BNE V0, ZERO, 0x9D006E2C
9D006DF4  00000000   NOP
393:                 			do {
394:                 				if (!xmit_datablock(buff, 0xFC))
9D006DF8  02202021   ADDU A0, S1, ZERO
9D006DFC  0F401A15   JAL 0x9D006854
9D006E00  240500FC   ADDIU A1, ZERO, 252
9D006E04  10400005   BEQ V0, ZERO, 0x9D006E1C
9D006E08  00002021   ADDU A0, ZERO, ZERO
395:                 					break;
396:                 				buff += 512;
397:                 			} while (--count);
9D006E0C  2652FFFF   ADDIU S2, S2, -1
9D006E10  325200FF   ANDI S2, S2, 255
9D006E14  1640FFF8   BNE S2, ZERO, 0x9D006DF8
9D006E18  26310200   ADDIU S1, S1, 512
398:                 			if (!xmit_datablock(0, 0xFD)) /* STOP_TRAN token */
9D006E1C  0F401A15   JAL 0x9D006854
9D006E20  240500FD   ADDIU A1, ZERO, 253
399:                 				count = 1;
9D006E24  24030001   ADDIU V1, ZERO, 1
9D006E28  0062900A   MOVZ S2, V1, V0
400:                 		}
401:                 	}
402:                 	deselect();
9D006E2C  0F402082   JAL disableSD
9D006E30  00000000   NOP
403:                 
404:                 	return count ? RES_ERROR : RES_OK;
9D006E34  0012102B   SLTU V0, ZERO, S2
405:                 }
9D006E38  8FBF001C   LW RA, 28(SP)
9D006E3C  8FB20018   LW S2, 24(SP)
9D006E40  8FB10014   LW S1, 20(SP)
9D006E44  8FB00010   LW S0, 16(SP)
9D006E48  03E00008   JR RA
9D006E4C  27BD0020   ADDIU SP, SP, 32
406:                 #endif /* _READONLY */
407:                 
408:                 /*-----------------------------------------------------------------------*/
409:                 /* Miscellaneous Functions                                               */
410:                 /*-----------------------------------------------------------------------*/
411:                 
412:                 DRESULT disk_ioctl(PF_BYTE drv, /* Physical drive number (0) */
9D007154  26300004   ADDIU S0, S1, 4
413:                                    PF_BYTE ctrl, /* Control code */
414:                                    void *buff /* Buffer to send/receive data block */
415:                                    ) {
9D006E50  27BDFFD0   ADDIU SP, SP, -48
9D006E54  AFBF002C   SW RA, 44(SP)
9D006E58  AFB20028   SW S2, 40(SP)
9D006E5C  AFB10024   SW S1, 36(SP)
9D006E60  AFB00020   SW S0, 32(SP)
9D006E64  00C08821   ADDU S1, A2, ZERO
9D006E68  308400FF   ANDI A0, A0, 255
9D006E6C  30A500FF   ANDI A1, A1, 255
416:                 	DRESULT res;
417:                 	PF_BYTE n, csd[16], *ptr = buff;
418:                 	DWORD csize;
419:                 
420:                 	if (drv)
9D006E70  148000D0   BNE A0, ZERO, 0x9D0071B4
9D006E74  24100004   ADDIU S0, ZERO, 4
421:                 		return RES_PARERR;
422:                 	if (Stat & STA_NOINIT)
9D006E78  93828010   LBU V0, -32752(GP)
9D006E7C  30420001   ANDI V0, V0, 1
9D006E80  144000CC   BNE V0, ZERO, 0x9D0071B4
9D006E84  24100003   ADDIU S0, ZERO, 3
423:                 		return RES_NOTRDY;
424:                 
425:                 	res = RES_ERROR;
9D00710C  0B401C6B   J 0x9D0071AC
9D007110  2C500001   SLTIU S0, V0, 1
9D007134  0B401C6B   J 0x9D0071AC
9D007138  2C500001   SLTIU S0, V0, 1
9D0071A0  0B401C6B   J 0x9D0071AC
9D0071A4  2C500001   SLTIU S0, V0, 1
426:                 	switch (ctrl) {
9D006E88  2CA2000F   SLTIU V0, A1, 15
9D006E8C  504000C7   BEQL V0, ZERO, 0x9D0071AC
9D006E90  24100004   ADDIU S0, ZERO, 4
9D006E94  00052880   SLL A1, A1, 2
9D006E98  3C029D00   LUI V0, -25344
9D006E9C  24426EB0   ADDIU V0, V0, 28336
9D006EA0  00452821   ADDU A1, V0, A1
9D006EA4  8CA20000   LW V0, 0(A1)
9D006EA8  00400008   JR V0
9D006EAC  00000000   NOP
427:                 	case CTRL_SYNC: /* Flush dirty buffer if present */
428:                 		if (select()) {
9D006EEC  0F4019C1   JAL 0x9D006704
9D006EF0  24100001   ADDIU S0, ZERO, 1
9D006EF4  104000AD   BEQ V0, ZERO, 0x9D0071AC
9D006EF8  00000000   NOP
429:                 			deselect();
9D006EFC  0F402082   JAL disableSD
9D006F00  00008021   ADDU S0, ZERO, ZERO
9D006F04  0B401C6B   J 0x9D0071AC
9D006F08  00000000   NOP
430:                 			res = RES_OK;
431:                 		}
432:                 		break;
433:                 
434:                 	case GET_SECTOR_COUNT: /* Get number of sectors on the disk (WORD) */
435:                 		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
9D006F0C  24040009   ADDIU A0, ZERO, 9
9D006F10  0F4019D2   JAL 0x9D006748
9D006F14  00002821   ADDU A1, ZERO, ZERO
9D006F18  144000A4   BNE V0, ZERO, 0x9D0071AC
9D006F1C  24100001   ADDIU S0, ZERO, 1
9D006F20  27A40010   ADDIU A0, SP, 16
9D006F24  0F401A3A   JAL 0x9D0068E8
9D006F28  24050010   ADDIU A1, ZERO, 16
9D006F2C  1040009F   BEQ V0, ZERO, 0x9D0071AC
9D006F30  93A30010   LBU V1, 16(SP)
436:                 			if ((csd[0] >> 6) == 1) { /* SDv2? */
9D006F34  00031982   SRL V1, V1, 6
9D006F38  24020001   ADDIU V0, ZERO, 1
9D006F3C  1462000A   BNE V1, V0, 0x9D006F68
9D006F40  93A30018   LBU V1, 24(SP)
437:                 				csize = csd[9] + ((WORD) csd[8] << 8) + 1;
9D006F44  93A30019   LBU V1, 25(SP)
9D006F48  24630001   ADDIU V1, V1, 1
9D006F4C  93A20018   LBU V0, 24(SP)
9D006F50  00021200   SLL V0, V0, 8
9D006F54  00621021   ADDU V0, V1, V0
438:                 				*(DWORD*) buff = (DWORD) csize << 10;
9D006F58  00021280   SLL V0, V0, 10
9D006F5C  AE220000   SW V0, 0(S1)
439:                 			} else { /* SDv1 or MMCv2 */
440:                 				n = (csd[5] & 15) + ((csd[10] & 128) >> 7)
9D006F8C  93A40015   LBU A0, 21(SP)
9D006F90  3084000F   ANDI A0, A0, 15
9D006F94  93A2001A   LBU V0, 26(SP)
9D006F98  000211C2   SRL V0, V0, 7
9D006F9C  00822021   ADDU A0, A0, V0
9D006FA0  93A20019   LBU V0, 25(SP)
9D006FA4  30420003   ANDI V0, V0, 3
9D006FA8  00021040   SLL V0, V0, 1
441:                 						+ ((csd[9] & 3) << 1) + 2;
442:                 				csize = (csd[8] >> 6) + ((WORD) csd[7] << 2) + ((WORD) (csd[6]
9D006F68  00031982   SRL V1, V1, 6
9D006F6C  93A20017   LBU V0, 23(SP)
9D006F70  00021080   SLL V0, V0, 2
9D006F74  00621821   ADDU V1, V1, V0
9D006F78  24630001   ADDIU V1, V1, 1
443:                 						& 3) << 10) + 1;
9D006F7C  93A20016   LBU V0, 22(SP)
9D006F80  30420003   ANDI V0, V0, 3
9D006F84  00021280   SLL V0, V0, 10
9D006F88  00621821   ADDU V1, V1, V0
444:                 				*(DWORD*) buff = (DWORD) csize << (n - 9);
9D006FAC  00821021   ADDU V0, A0, V0
9D006FB0  2442FFF9   ADDIU V0, V0, -7
9D006FB4  00431004   SLLV V0, V1, V0
9D006FB8  AE220000   SW V0, 0(S1)
445:                 			}
446:                 			res = RES_OK;
9D006F60  0B401C6B   J 0x9D0071AC
9D006F64  00008021   ADDU S0, ZERO, ZERO
9D006FBC  0B401C6B   J 0x9D0071AC
9D006FC0  00008021   ADDU S0, ZERO, ZERO
447:                 		}
448:                 		break;
449:                 
450:                 	case GET_SECTOR_SIZE: /* Get sectors on the disk (WORD) */
451:                 		*(WORD*) buff = 512;
9D006FC4  24020200   ADDIU V0, ZERO, 512
9D006FC8  A4C20000   SH V0, 0(A2)
452:                 		res = RES_OK;
453:                 		break;
9D006FCC  0B401C6B   J 0x9D0071AC
9D006FD0  00008021   ADDU S0, ZERO, ZERO
454:                 
455:                 	case GET_BLOCK_SIZE: /* Get erase block size in unit of sectors (DWORD) */
456:                 		if (CardType & CT_SD2) { /* SDv2? */
9D006FD4  9782802C   LHU V0, -32724(GP)
9D006FD8  30420004   ANDI V0, V0, 4
9D006FDC  10400019   BEQ V0, ZERO, 0x9D007044
9D006FE0  24040009   ADDIU A0, ZERO, 9
457:                 			if (send_cmd(ACMD13, 0) == 0) { /* Read SD status */
9D006FE4  2404008D   ADDIU A0, ZERO, 141
9D006FE8  0F4019D2   JAL 0x9D006748
9D006FEC  00002821   ADDU A1, ZERO, ZERO
9D006FF0  1440006E   BNE V0, ZERO, 0x9D0071AC
9D006FF4  24100001   ADDIU S0, ZERO, 1
458:                 				rcvr_spi();
9D006FF8  0F402066   JAL writeSPI
9D006FFC  240400FF   ADDIU A0, ZERO, 255
459:                 				if (rcvr_datablock(csd, 16)) { /* Read partial block */
9D007000  27A40010   ADDIU A0, SP, 16
9D007004  0F401A3A   JAL 0x9D0068E8
9D007008  24050010   ADDIU A1, ZERO, 16
9D00700C  10400067   BEQ V0, ZERO, 0x9D0071AC
9D007010  00000000   NOP
9D007014  24100030   ADDIU S0, ZERO, 48
460:                 					for (n = 64 - 16; n; n--)
9D007020  2610FFFF   ADDIU S0, S0, -1
9D007024  321000FF   ANDI S0, S0, 255
9D007028  1600FFFB   BNE S0, ZERO, 0x9D007018
9D00702C  93A2001A   LBU V0, 26(SP)
461:                 						rcvr_spi(); /* Purge trailing data */
9D007018  0F402066   JAL writeSPI
9D00701C  240400FF   ADDIU A0, ZERO, 255
462:                 					*(DWORD*) buff = 16UL << (csd[10] >> 4);
9D007030  00021102   SRL V0, V0, 4
9D007034  24030010   ADDIU V1, ZERO, 16
9D007038  00431004   SLLV V0, V1, V0
9D00703C  0B401C6B   J 0x9D0071AC
9D007040  AE220000   SW V0, 0(S1)
463:                 					res = RES_OK;
464:                 				}
465:                 			}
466:                 		} else { /* SDv1 or MMCv3 */
467:                 			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) { /* Read CSD */
9D007044  0F4019D2   JAL 0x9D006748
9D007048  00002821   ADDU A1, ZERO, ZERO
9D00704C  14400057   BNE V0, ZERO, 0x9D0071AC
9D007050  24100001   ADDIU S0, ZERO, 1
9D007054  27A40010   ADDIU A0, SP, 16
9D007058  0F401A3A   JAL 0x9D0068E8
9D00705C  24050010   ADDIU A1, ZERO, 16
9D007060  10400052   BEQ V0, ZERO, 0x9D0071AC
9D007064  9782802C   LHU V0, -32724(GP)
468:                 				if (CardType & CT_SD1) { /* SDv1 */
9D007068  30420002   ANDI V0, V0, 2
9D00706C  1040000F   BEQ V0, ZERO, 0x9D0070AC
9D007070  93A2001B   LBU V0, 27(SP)
469:                 					*(DWORD*) buff = (((csd[10] & 63) << 1) + ((WORD) (csd[11]
9D00707C  24630001   ADDIU V1, V1, 1
9D007080  93A2001A   LBU V0, 26(SP)
9D007084  3042003F   ANDI V0, V0, 63
9D007088  00021040   SLL V0, V0, 1
9D0070A0  AE220000   SW V0, 0(S1)
470:                 							& 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
9D007074  93A3001B   LBU V1, 27(SP)
9D007078  000319C2   SRL V1, V1, 7
9D00708C  00621821   ADDU V1, V1, V0
9D007090  93A2001D   LBU V0, 29(SP)
9D007094  00021182   SRL V0, V0, 6
9D007098  2442FFFF   ADDIU V0, V0, -1
9D00709C  00431004   SLLV V0, V1, V0
471:                 				} else { /* MMCv3 */
472:                 					*(DWORD*) buff = ((WORD) ((csd[10] & 124) >> 2) + 1)
9D0070AC  93A3001A   LBU V1, 26(SP)
9D0070B0  7C632080   EXT V1, V1, 2, 5
9D0070B4  24630001   ADDIU V1, V1, 1
9D0070D0  AE220000   SW V0, 0(S1)
473:                 							* (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5)
9D0070B8  00022142   SRL A0, V0, 5
9D0070BC  24840001   ADDIU A0, A0, 1
9D0070C0  30420003   ANDI V0, V0, 3
9D0070C4  000210C0   SLL V0, V0, 3
9D0070CC  70621002   MUL V0, V1, V0
474:                 									+ 1);
9D0070C8  00821021   ADDU V0, A0, V0
475:                 				}
476:                 				res = RES_OK;
9D0070A4  0B401C6B   J 0x9D0071AC
9D0070A8  00008021   ADDU S0, ZERO, ZERO
9D0070D4  0B401C6B   J 0x9D0071AC
9D0070D8  00008021   ADDU S0, ZERO, ZERO
477:                 			}
478:                 		}
479:                 		break;
480:                 
481:                 	case MMC_GET_TYPE: /* Get card type flags (1 byte) */
482:                 		*ptr = CardType;
9D0070DC  9782802C   LHU V0, -32724(GP)
9D0070E0  A0C20000   SB V0, 0(A2)
483:                 		res = RES_OK;
484:                 		break;
9D0070E4  0B401C6B   J 0x9D0071AC
9D0070E8  00008021   ADDU S0, ZERO, ZERO
485:                 
486:                 	case MMC_GET_CSD: /* Receive CSD as a data block (16 bytes) */
487:                 		if ((send_cmd(CMD9, 0) == 0) /* READ_CSD */
9D0070EC  24040009   ADDIU A0, ZERO, 9
9D0070F0  0F4019D2   JAL 0x9D006748
9D0070F4  00002821   ADDU A1, ZERO, ZERO
9D0070F8  1440002C   BNE V0, ZERO, 0x9D0071AC
9D0070FC  24100001   ADDIU S0, ZERO, 1
488:                 		&& rcvr_datablock(buff, 16))
9D007100  02202021   ADDU A0, S1, ZERO
9D007104  0F401A3A   JAL 0x9D0068E8
9D007108  24050010   ADDIU A1, ZERO, 16
489:                 			res = RES_OK;
490:                 		break;
491:                 
492:                 	case MMC_GET_CID: /* Receive CID as a data block (16 bytes) */
493:                 		if ((send_cmd(CMD10, 0) == 0) /* READ_CID */
9D007114  2404000A   ADDIU A0, ZERO, 10
9D007118  0F4019D2   JAL 0x9D006748
9D00711C  00002821   ADDU A1, ZERO, ZERO
9D007120  14400022   BNE V0, ZERO, 0x9D0071AC
9D007124  24100001   ADDIU S0, ZERO, 1
494:                 		&& rcvr_datablock(buff, 16))
9D007128  02202021   ADDU A0, S1, ZERO
9D00712C  0F401A3A   JAL 0x9D0068E8
9D007130  24050010   ADDIU A1, ZERO, 16
495:                 			res = RES_OK;
496:                 		break;
497:                 
498:                 	case MMC_GET_OCR: /* Receive OCR as an R3 resp (4 bytes) */
499:                 		if (send_cmd(CMD58, 0) == 0) { /* READ_OCR */
9D00713C  2404003A   ADDIU A0, ZERO, 58
9D007140  0F4019D2   JAL 0x9D006748
9D007144  00002821   ADDU A1, ZERO, ZERO
9D007148  14400018   BNE V0, ZERO, 0x9D0071AC
9D00714C  24100001   ADDIU S0, ZERO, 1
9D007150  02209021   ADDU S2, S1, ZERO
500:                 			for (n = 0; n < 4; n++)
9D007168  1650FFFB   BNE S2, S0, 0x9D007158
9D00716C  00000000   NOP
501:                 				*((PF_BYTE*) buff + n) = rcvr_spi();
9D007158  0F402066   JAL writeSPI
9D00715C  240400FF   ADDIU A0, ZERO, 255
9D007160  A2420000   SB V0, 0(S2)
9D007164  26520001   ADDIU S2, S2, 1
502:                 			res = RES_OK;
9D007170  0B401C6B   J 0x9D0071AC
9D007174  00008021   ADDU S0, ZERO, ZERO
503:                 		}
504:                 		break;
505:                 
506:                 	case MMC_GET_SDSTAT: /* Receive SD status as a data block (64 bytes) */
507:                 		if (send_cmd(ACMD13, 0) == 0) { /* SD_STATUS */
9D007178  2404008D   ADDIU A0, ZERO, 141
9D00717C  0F4019D2   JAL 0x9D006748
9D007180  00002821   ADDU A1, ZERO, ZERO
9D007184  14400009   BNE V0, ZERO, 0x9D0071AC
9D007188  24100001   ADDIU S0, ZERO, 1
508:                 			rcvr_spi();
9D00718C  0F402066   JAL writeSPI
9D007190  240400FF   ADDIU A0, ZERO, 255
509:                 			if (rcvr_datablock(buff, 64))
9D007194  02202021   ADDU A0, S1, ZERO
9D007198  0F401A3A   JAL 0x9D0068E8
9D00719C  24050040   ADDIU A1, ZERO, 64
510:                 				res = RES_OK;
511:                 		}
512:                 		break;
513:                 
514:                 	default:
515:                 		res = RES_PARERR;
9D0071A8  24100004   ADDIU S0, ZERO, 4
516:                 	}
517:                 
518:                 	deselect();
9D0071AC  0F402082   JAL disableSD
9D0071B0  00000000   NOP
519:                 
520:                 	return res;
521:                 }
9D0071B4  02001021   ADDU V0, S0, ZERO
9D0071B8  8FBF002C   LW RA, 44(SP)
9D0071BC  8FB20028   LW S2, 40(SP)
9D0071C0  8FB10024   LW S1, 36(SP)
9D0071C4  8FB00020   LW S0, 32(SP)
9D0071C8  03E00008   JR RA
9D0071CC  27BD0030   ADDIU SP, SP, 48
522:                 
523:                 /*-----------------------------------------------------------------------*/
524:                 /* Device Timer Interrupt Procedure  (Platform dependent)                */
525:                 /*-----------------------------------------------------------------------*/
526:                 /* This function must be called in period of 1ms                         */
527:                 /*
528:                 void disk_timerproc(void) {
529:                 	static WORD pv;
530:                 	WORD p;
531:                 	PF_BYTE s;
532:                 	UINT16 n;
533:                 
534:                 	n = Timer1; // 1000Hz decrement timer
535:                 	if (n)
536:                 		Timer1 = --n;
537:                 	n = Timer2;
538:                 	if (n)
539:                 		Timer2 = --n;
540:                 
541:                 	p = pv;
542:                 	pv = getCD() & getWP(); // Sample socket switch
543:                 
544:                 	if (p == pv) { // Have contacts stabled?
545:                 		s = Stat;
546:                 
547:                 		if (p & getWP()) // WP is H (write protected)
548:                 			s |= STA_PROTECT;
549:                 		else
550:                 			//* WP is L (write enabled)
551:                 			s &= ~STA_PROTECT;
552:                 
553:                 		if (p & getCD()) // INS = H (Socket empty)
554:                 			s |= (STA_NODISK | STA_NOINIT);
555:                 		else
556:                 			// INS = L (Card inserted)
557:                 			s &= ~STA_NODISK;
558:                 
559:                 		Stat = s;
560:                 	}
561:                 }
562:                 */
563:                 
564:                 /*---------------------------------------------------------*/
565:                 /* User Provided RTC Function for FatFs module             */
566:                 /*---------------------------------------------------------*/
567:                 /* This is a real time clock service to be called from     */
568:                 /* FatFs module. Any valid time must be returned even if   */
569:                 /* the system does not support an RTC.                     */
570:                 /* This function is not required in read-only cfg.         */
571:                 
572:                 /*	The current time is returned packed into a DWORD
573:                 	(32 bit) value. The bit fields are as follows:
574:                 		bits 31:25	Year from 1980 (0..127)
575:                 		bits 24:21	Month (1..12)
576:                 		bits 20:16	Day in month (1..31)
577:                 		bits 15:11	Hour (0..23)
578:                 		bits 10:05	Minute (0..59)
579:                 		bits 04:00	Second / 2 (0..29)						*/
580:                 
581:                 DWORD get_fattime(void) {
582:                 	DWORD tmr = 0;
583:                 
584:                 // Pre-processor commands added so only use RTCC if the board is known
585:                 // to support the RTCC ** Added 07 May 2012
586:                 
587:                 // For boards known to support the RTCC library
588:                 
589:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
590:                 	rtccTime pTm, cTm;
591:                 	rtccDate pDt, cDt;
592:                 
593:                 	RTCC_GetTimeDate(&pTm, &pDt);	// get time and date from RTC
594:                 											// assumes RTC has been set and is running
595:                 											// OK - could be expanded to check that RTC
596:                 											// is running and that a valid value is
597:                 											// being returned by the RTC
598:                 	cTm = RTCC_ConvertTime(&pTm);	// convert time from bcd to decimal format
599:                 	cDt = RTCC_ConvertDate(&pDt);	// convert date from bcd to decimal format
600:                 
601:                 	/* Pack date and time into a DWORD variable */
602:                 //	tmr = (((DWORD) pDt.year - 80)) | ((DWORD) pDt.mon) | ((DWORD) pDt.mday)
603:                 //			| (WORD) (pTm.hour) | (WORD) (pTm.min) | (WORD) (pTm.sec);
604:                 	tmr = cDt.year + 20;
605:                    
606:                   // Correction according to a newer rtcc library, with diff struct members.
607:                   
608:                 	 tmr = (tmr << 4) | cDt.month;		// shifts left 4 bits and adds monthth
609:                 	tmr = (tmr << 5) | cDt.dayofmonth;		// shifts left 5 bits and adds m.day
610:                 	tmr = (tmr << 5) | cTm.hours;		// shifts left 5 bits and adds hour
611:                 	tmr = (tmr << 6) | cTm.minutes;		// shift left 6 bits and adds minutes
612:                 	tmr = (tmr << 5) | (cTm.seconds/2);	// shifts left 5 bits and adds seconds/2
613:                 
614:                 //	For other boards use a fixed date and time of 01 Jan 2012 12:00:00
615:                 #else
616:                      tmr = 12 + 20;
617:                      tmr = (tmr << 4) | 1;       // shifts left 4 bits and adds month
618:                      tmr = (tmr << 5) | 1;    	// shifts left 5 bits and adds m.day
619:                      tmr = (tmr << 5) | 12;    	// shifts left 5 bits and adds hour
620:                      tmr = (tmr << 6) | 0;       // shift left 6 bits and adds minutes
621:                      tmr = (tmr << 5) | (0/2);   // shifts left 5 bits and adds seconds/2
622:                 #endif
623:                 
624:                 	return tmr;
625:                 }
9D0071D0  3C024021   LUI V0, 16417
9D0071D4  03E00008   JR RA
9D0071D8  24426000   ADDIU V0, V0, 24576
626:                 
627:                 void put_rc(FRESULT rc) {
628:                 	const char *str =
629:                                         "OK\0" "DISK_ERR\0" "INT_ERR\0" "NOT_READY\0" "NO_FILE\0" "NO_PATH\0"
630:                                                 "INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
631:                                                 "INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
632:                                                 "LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0";
633:                 	FRESULT i;
634:                 
635:                 	for (i = 0; i != rc && *str; i++) {
636:                 		while (*str++)
637:                 			;
638:                 	}
639:                 	//CDCprintln("rc=%u FR_%s", (UINT16) rc, str);
640:                         print("rc=");
641:                         print_int(rc,5);
642:                         cursor_right();
643:                         print(str);
644:                         put_char('\r');
645:                 }
646:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/HardwareProfile.c  -----------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   HardwareProfile.h
21:                   * Author: Jacques Deschênes
22:                   * Description: configuration hardware spécifique, assignation des périphériques
23:                   *     UART2 assigné à PB10,PB11
24:                   * Created on 17 avril 2013, 14:41
25:                   *
26:                   */
27:                  
28:                  #include "HardwareProfile.h"
29:                  #include <plib.h>
30:                  #include "../sound.h"
31:                  
32:                  volatile unsigned int  sys_tick; // compteur pour les milli-secondes
33:                  
34:                  
35:                  void HardwareInit(){
9D008E88  27BDFFE8   ADDIU SP, SP, -24
9D008E8C  AFBF0014   SW RA, 20(SP)
36:                     SYSTEMConfig(mGetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
37:                     INTEnableSystemMultiVectoredInt();
9D008EB4  0F402986   JAL INTEnableSystemMultiVectoredInt
9D008EB8  00000000   NOP
38:                     // activation du PROXIMITY TIMER pour les interruption inférieures à IPL=7
39:                  //   INTCONbits.TPC=0;
40:                  //   IPTMRCLR=0xFFFFFFFF;
41:                  //   INTCONbits.TPC=7;
42:                  //   IPTMR=CORE_TICK_RATE/2;
43:                      // configure coretimer pour le sys_tick
44:                  #ifdef USE_CORE_TIMER
45:                     OpenCoreTimer(CORE_TICK_RATE);
9D008EBC  0F402A06   JAL OpenCoreTimer
9D008EC0  2404493E   ADDIU A0, ZERO, 18750
46:                     mConfigIntCoreTimer((CT_INT_ON | CT_INT_PRIOR_1 | CT_INT_SUB_PRIOR_0));
9D008EC4  24020001   ADDIU V0, ZERO, 1
9D008EC8  3C03BF88   LUI V1, -16504
9D008ECC  AC621034   SW V0, 4148(V1)
9D008ED0  3C06BF88   LUI A2, -16504
9D008ED4  2403001C   ADDIU V1, ZERO, 28
9D008ED8  ACC31094   SW V1, 4244(A2)
9D008EDC  3C05BF88   LUI A1, -16504
9D008EE0  24030004   ADDIU V1, ZERO, 4
9D008EE4  ACA31098   SW V1, 4248(A1)
9D008EE8  24040003   ADDIU A0, ZERO, 3
9D008EEC  ACC41094   SW A0, 4244(A2)
9D008EF0  ACA01098   SW ZERO, 4248(A1)
9D008EF4  3C05BF88   LUI A1, -16504
9D008EF8  ACA21064   SW V0, 4196(A1)
9D008EFC  3C05BF88   LUI A1, -16504
9D008F00  ACA21068   SW V0, 4200(A1)
47:                  #endif
48:                     // désactivation de toutes les entrée analogiques.
49:                     ANSELBCLR=0xFFFFFFFF;
9D008F04  3C05BF88   LUI A1, -16504
9D008F08  2406FFFF   ADDIU A2, ZERO, -1
9D008F0C  ACA66104   SW A2, 24836(A1)
50:                     ANSELACLR=0xFFFFFFFF;
9D008F10  3C07BF88   LUI A3, -16504
9D008F14  ACE66004   SW A2, 24580(A3)
51:                      // configuration PB10 sortie et PB11 entrée
52:                     mPORTBSetBits(TX); // mettre à Vdd pour ne pas généré un faux start bit.
9D008F18  24060400   ADDIU A2, ZERO, 1024
9D008F1C  3C07BF88   LUI A3, -16504
9D008F20  ACE66138   SW A2, 24888(A3)
53:                     mPORTBSetPinsDigitalOut(TX);      // sortie PB10(Tx), transmission UART2
9D008F24  3C07BF88   LUI A3, -16504
9D008F28  ACE66114   SW A2, 24852(A3)
9D008F2C  ACA66104   SW A2, 24836(A1)
54:                     mPORTBSetPinsDigitalIn (RX);      // entrée PB11(Rx), réception UART2
9D008F30  24060800   ADDIU A2, ZERO, 2048
9D008F34  3C08BF88   LUI T0, -16504
9D008F38  AD066118   SW A2, 24856(T0)
9D008F3C  ACA66104   SW A2, 24836(A1)
55:                     // assignation des périphériques aux broches
56:                     // l'information se trouve dans pps.h
57:                     PPSUnLock;                     // déverrouillage configuration assignation périphérique
58:                     //clavier
59:                     I2C1CONbits.DISSLW=1; // voir pic32mx1xxx/2xxx-errata.pdf rev. E, point 9
9D008F40  3C05BF80   LUI A1, -16512
9D008F44  8CA65000   LW A2, 20480(A1)
9D008F48  7C464A44   INS A2, V0, 9, 1
9D008F4C  ACA65000   SW A2, 20480(A1)
60:                     RPA0R=0;  // pas de périphérique sur RA0 (keyboard clock)
9D008F50  3C02BF81   LUI V0, -16511
9D008F54  AC40FB00   SW ZERO, -1280(V0)
61:                     RPA1R=0;  // pas de périphérique sur RA1 (keyboard data)
9D008F58  3C02BF81   LUI V0, -16511
9D008F5C  AC40FB04   SW ZERO, -1276(V0)
62:                     RPB3R=0; //  pas de périphérique sur RB3 (status LED)
9D008F60  3C02BF81   LUI V0, -16511
9D008F64  AC40FB38   SW ZERO, -1224(V0)
63:                     RPB15R=0; // pad de périphérique sur RB15
9D008F68  3C02BF81   LUI V0, -16511
9D008F6C  AC40FB68   SW ZERO, -1176(V0)
64:                     TRISBCLR=STATUS_LED; // broche status LED en sortie
9D008F70  24020008   ADDIU V0, ZERO, 8
9D008F74  ACE26114   SW V0, 24852(A3)
65:                     _status_off();
9D008F78  3C02BF88   LUI V0, -16504
9D008F7C  8C466120   LW A2, 24864(V0)
9D008F80  2405FFF7   ADDIU A1, ZERO, -9
9D008F84  00C52824   AND A1, A2, A1
9D008F88  AC456120   SW A1, 24864(V0)
66:                     PPSOutput(4, RPB10, U2TX);  // assignation U2TX sur PB10, (groupe, pin, fonction)
9D008F8C  3C02BF81   LUI V0, -16511
9D008F90  8C46FB54   LW A2, -1196(V0)
9D008F94  24050002   ADDIU A1, ZERO, 2
9D008F98  7CA61804   INS A2, A1, 0, 4
9D008F9C  AC46FB54   SW A2, -1196(V0)
67:                     PPSInput (2, U2RX, RPB11);  // assignation U2RX sur PB11, (groupe, fonction, pin)
9D008FA0  3C02BF81   LUI V0, -16511
9D008FA4  8C46FA58   LW A2, -1448(V0)
9D008FA8  7C861804   INS A2, A0, 0, 4
9D008FAC  AC46FA58   SW A2, -1448(V0)
68:                     PPSOutput(2,RPB5,OC2); // 5=OC2  sur PB5 sortie synchronistaiton ntsc
9D008FB0  3C06BF81   LUI A2, -16511
9D008FB4  8CC7FB40   LW A3, -1216(A2)
9D008FB8  24020005   ADDIU V0, ZERO, 5
9D008FBC  7C471804   INS A3, V0, 0, 4
9D008FC0  ACC7FB40   SW A3, -1216(A2)
69:                     PPSOutput(1,RPB4,OC1);  // 5=OC1 impulsion déclenchant SPI , Fsync vidéo
9D008FC4  3C06BF81   LUI A2, -16511
9D008FC8  8CC7FB3C   LW A3, -1220(A2)
9D008FCC  7C471804   INS A3, V0, 0, 4
9D008FD0  ACC7FB3C   SW A3, -1220(A2)
70:                     PPSOutput(3,RPB6,SDO1); // 3=SDO1 sortie SPI1 (vidéo)
9D008FD4  3C06BF81   LUI A2, -16511
9D008FD8  8CC7FB44   LW A3, -1212(A2)
9D008FDC  7C871804   INS A3, A0, 0, 4
9D008FE0  ACC7FB44   SW A3, -1212(A2)
71:                     PPSOutput(4,RPB9,OC3); // OC3 sortie audio.
9D008FE4  3C04BF81   LUI A0, -16511
9D008FE8  8C86FB50   LW A2, -1200(A0)
9D008FEC  7C461804   INS A2, V0, 0, 4
9D008FF0  AC86FB50   SW A2, -1200(A0)
72:                     PPSInput(1,SS1,RPB7); // entrée Fsync sur RPB7
9D008FF4  3C02BF81   LUI V0, -16511
9D008FF8  8C44FA88   LW A0, -1400(V0)
9D008FFC  7C641804   INS A0, V1, 0, 4
9D009000  AC44FA88   SW A0, -1400(V0)
73:                     PPSInput(3,SDI2,RPA4); // entrée SDI pour carte SD
9D009004  3C02BF81   LUI V0, -16511
9D009008  8C44FA90   LW A0, -1392(V0)
9D00900C  7CA41804   INS A0, A1, 0, 4
9D009010  AC44FA90   SW A0, -1392(V0)
74:                     PPSOutput(2,RPB8,SDO2); // sortie commande carte SD
9D009014  3C02BF81   LUI V0, -16511
9D009018  8C44FB4C   LW A0, -1204(V0)
9D00901C  7C641804   INS A0, V1, 0, 4
9D009020  AC44FB4C   SW A0, -1204(V0)
75:                     PPSLock;                       // reverrouille pour éviter assignation accidentelle.
76:                  }
9D009024  8FBF0014   LW RA, 20(SP)
9D009028  03E00008   JR RA
9D00902C  27BD0018   ADDIU SP, SP, 24
77:                  
78:                  inline unsigned int ticks(void){
79:                      return sys_tick;
9D009030  8F828054   LW V0, -32684(GP)
80:                  } //ticks()
9D009034  03E00008   JR RA
9D009038  00000000   NOP
81:                  
82:                  inline void delay_us(unsigned int usec){
83:                      for (usec=usec*(CLK_PER_USEC/3);usec;usec--);
9D00903C  2402000C   ADDIU V0, ZERO, 12
9D009040  70821002   MUL V0, A0, V0
9D009044  10400003   BEQ V0, ZERO, 0x9D009054
9D009048  2442FFFF   ADDIU V0, V0, -1
9D00904C  1440FFFF   BNE V0, ZERO, 0x9D00904C
9D009050  2442FFFF   ADDIU V0, V0, -1
9D009054  03E00008   JR RA
9D009058  00000000   NOP
84:                  }//delay_us()
85:                  
86:                  void delay_ms(unsigned int msec){
87:                  #ifdef USE_CORE_TIMER
88:                      unsigned int t0;
89:                      t0=sys_tick+msec;
9D00905C  8F828054   LW V0, -32684(GP)
9D009060  00821021   ADDU V0, A0, V0
90:                      while (sys_tick!=t0);
9D009064  8F838054   LW V1, -32684(GP)
9D009068  1462FFFE   BNE V1, V0, 0x9D009064
9D00906C  00000000   NOP
91:                  #else
92:                      while (msec--)
93:                          delay_us(1000);
94:                  #endif
95:                  } // delay_ms()
9D009070  03E00008   JR RA
9D009074  00000000   NOP
96:                  
97:                  #ifdef USE_CORE_TIMER
98:                    //déclaration du gestionnaire d'interruption
99:                     void __ISR(_CORE_TIMER_VECTOR, IPL1SOFT)  CoreTimerHandler(void){
9D009078  415DE800   RDPGPR SP, SP
9D00907C  401A7000   MFC0 K0, EPC
9D009080  401B6000   MFC0 K1, Status
9D009084  27BDFFE8   ADDIU SP, SP, -24
9D009088  AFBA0014   SW K0, 20(SP)
9D00908C  401A6002   MFC0 K0, SRSCtl
9D009090  AFBB0010   SW K1, 16(SP)
9D009094  AFBA000C   SW K0, 12(SP)
9D009098  7C1B7844   INS K1, ZERO, 1, 15
9D00909C  377B0400   ORI K1, K1, 1024
9D0090A0  409B6000   MTC0 K1, Status
9D0090A4  AFA30004   SW V1, 4(SP)
9D0090A8  AFA20000   SW V0, 0(SP)
100:                        sys_tick++;
9D0090AC  8F828054   LW V0, -32684(GP)
9D0090B0  24420001   ADDIU V0, V0, 1
9D0090B4  AF828054   SW V0, -32684(GP)
101:                        __asm__("mfc0 $v0, $11");
9D0090B8  40025800   MFC0 V0, Compare
102:                        __asm__("addiu $v0,$v0,%0"::"I"(CORE_TICK_RATE));
9D0090BC  2442493E   ADDIU V0, V0, 18750
103:                        __asm__("mtc0 $v0, $11");
9D0090C0  40825800   MTC0 V0, Compare
104:                        if (tone_on && !(--duration)){
9D0090C4  93828044   LBU V0, -32700(GP)
9D0090C8  304200FF   ANDI V0, V0, 255
9D0090CC  1040000C   BEQ V0, ZERO, 0x9D009100
9D0090D0  24030001   ADDIU V1, ZERO, 1
9D0090D4  8F828088   LW V0, -32632(GP)
9D0090D8  2442FFFF   ADDIU V0, V0, -1
9D0090DC  AF828088   SW V0, -32632(GP)
9D0090E0  8F828088   LW V0, -32632(GP)
9D0090E4  14400005   BNE V0, ZERO, 0x9D0090FC
9D0090E8  3C02BF80   LUI V0, -16512
105:                                mTone_off();
9D0090EC  8C433400   LW V1, 13312(V0)
9D0090F0  7C037BC4   INS V1, ZERO, 15, 1
9D0090F4  AC433400   SW V1, 13312(V0)
106:                                tone_on=0;
9D0090F8  A3808044   SB ZERO, -32700(GP)
107:                        }
108:                        mCTClearIntFlag();
9D0090FC  24030001   ADDIU V1, ZERO, 1
9D009100  3C02BF88   LUI V0, -16504
9D009104  AC431034   SW V1, 4148(V0)
109:                    };
9D009108  8FA30004   LW V1, 4(SP)
9D00910C  8FA20000   LW V0, 0(SP)
9D009110  41606000   DI ZERO
9D009114  000000C0   EHB
9D009118  8FBA0014   LW K0, 20(SP)
9D00911C  8FBB0010   LW K1, 16(SP)
9D009120  409A7000   MTC0 K0, EPC
9D009124  8FBA000C   LW K0, 12(SP)
9D009128  27BD0018   ADDIU SP, SP, 24
9D00912C  409A6002   MTC0 K0, SRSCtl
9D009130  41DDE800   WRPGPR SP, SP
9D009134  409B6000   MTC0 K1, Status
9D009138  42000018   ERET
110:                 #endif
111:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/console.c  ----------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   *  Name: console.c
21:                   *  Description: text console for NTSC video output
22:                   *  Author: Jacques Deschênes
23:                   *  Date Created: 2013-09-06
24:                   */
25:                  
26:                  #include "console.h"
27:                  #include "hardware/HardwareProfile.h"
28:                  #include "hardware/serial_comm.h"
29:                  #include "hardware/keyboard.h"
30:                  
31:                  #define X_OFS  ((HRES%CWIDTH)/2)  // offset vidéo position curseur x
32:                  #define Y_OFS  ((VRES%CHEIGHT)/2)  // offset vidéo position curseur y
33:                  
34:                  // indicateurs booléens
35:                  #define CUR_SHOW 1  // curseur actif
36:                  #define CUR_VIS  2  // curseur visible
37:                  
38:                  
39:                  static unsigned short cx=X_OFS, cy=Y_OFS;  // coordonnée courante du curseur texte en pixels.
40:                  static unsigned char tab_width=TAB_WIDTH;
41:                  static cursor_t cur_shape=CR_UNDER;
42:                  static unsigned short flags=0;
43:                  
44:                  unsigned char comm_channel=LOCAL_CON;
45:                  
46:                  
47:                  void scroll_up(void){
9D007298  27BDFFE8   ADDIU SP, SP, -24
9D00729C  AFBF0014   SW RA, 20(SP)
9D0072A0  AFB00010   SW S0, 16(SP)
48:                      char *src, *dst;
49:                      dst = (char*)video_bmp+Y_OFS*HRES/8;
9D0072A4  3C10A000   LUI S0, -24576
9D0072A8  2610007C   ADDIU S0, S0, 124
50:                      src = (char*)video_bmp +(CHEIGHT+Y_OFS)*HRES/8;
51:                      memmove(dst,src,(LINE_PER_SCREEN-1)*CHEIGHT*HRES/8);
9D0072AC  26040078   ADDIU A0, S0, 120
9D0072B0  260501B8   ADDIU A1, S0, 440
9D0072B4  0F4028AB   JAL memmove
9D0072B8  240621C0   ADDIU A2, ZERO, 8640
52:                      dst= (char*)video_bmp+(CHEIGHT*(LINE_PER_SCREEN-1)+Y_OFS)*HRES/8;
53:                      memset(dst,0,HRES/8*CHEIGHT);
9D0072BC  26042238   ADDIU A0, S0, 8760
9D0072C0  00002821   ADDU A1, ZERO, ZERO
9D0072C4  0F40283B   JAL 0x9D00A0EC
9D0072C8  24060140   ADDIU A2, ZERO, 320
54:                  }//scroll_up();
9D0072CC  8FBF0014   LW RA, 20(SP)
9D0072D0  8FB00010   LW S0, 16(SP)
9D0072D4  03E00008   JR RA
9D0072D8  27BD0018   ADDIU SP, SP, 24
55:                  
56:                  void scroll_down(void){
9D0072DC  27BDFFE8   ADDIU SP, SP, -24
9D0072E0  AFBF0014   SW RA, 20(SP)
9D0072E4  AFB00010   SW S0, 16(SP)
57:                      char *src, *dst;
58:                      src = (char*)video_bmp+Y_OFS*HRES/8;
9D0072E8  3C04A000   LUI A0, -24576
9D0072EC  2484007C   ADDIU A0, A0, 124
9D0072F0  24900078   ADDIU S0, A0, 120
59:                      dst = (char*)video_bmp+(CHEIGHT+Y_OFS)*HRES/8;
60:                      memmove(dst,src,(LINE_PER_SCREEN-1)*CHEIGHT*HRES/8);
9D0072F4  248401B8   ADDIU A0, A0, 440
9D0072F8  02002821   ADDU A1, S0, ZERO
9D0072FC  0F4028AB   JAL memmove
9D007300  240621C0   ADDIU A2, ZERO, 8640
61:                      dst=(char*)video_bmp+Y_OFS*HRES/8;
62:                      memset(dst,0,HRES/8*CHEIGHT);
9D007304  02002021   ADDU A0, S0, ZERO
9D007308  00002821   ADDU A1, ZERO, ZERO
9D00730C  0F40283B   JAL 0x9D00A0EC
9D007310  24060140   ADDIU A2, ZERO, 320
63:                  }//scroll_down()
9D007314  8FBF0014   LW RA, 20(SP)
9D007318  8FB00010   LW S0, 16(SP)
9D00731C  03E00008   JR RA
9D007320  27BD0018   ADDIU SP, SP, 24
64:                  
65:                  
66:                  void cursor_right(void){
9D007324  27BDFFE8   ADDIU SP, SP, -24
9D007328  AFBF0014   SW RA, 20(SP)
67:                      cx += CWIDTH;
9D00732C  9782801C   LHU V0, -32740(GP)
9D007330  24420006   ADDIU V0, V0, 6
9D007334  3042FFFF   ANDI V0, V0, -1
9D007338  A782801C   SH V0, -32740(GP)
68:                      if (cx>(CHAR_PER_LINE*CWIDTH)){
9D00733C  2C42013F   SLTIU V0, V0, 319
9D007340  1440000E   BNE V0, ZERO, 0x9D00737C
9D007344  24020001   ADDIU V0, ZERO, 1
69:                          cx = X_OFS;
9D007348  A782801C   SH V0, -32740(GP)
70:                          cy += CHEIGHT;
9D00734C  9782801E   LHU V0, -32738(GP)
9D007350  24420008   ADDIU V0, V0, 8
9D007354  3042FFFF   ANDI V0, V0, -1
9D007358  A782801E   SH V0, -32738(GP)
71:                          if (cy>(LINE_PER_SCREEN*CHEIGHT)){
9D00735C  2C4200E1   SLTIU V0, V0, 225
9D007360  14400007   BNE V0, ZERO, 0x9D007380
9D007364  8FBF0014   LW RA, 20(SP)
72:                              scroll_up();
9D007368  0F401CA6   JAL scroll_up
9D00736C  00000000   NOP
73:                              cy -= CHEIGHT;
9D007370  9782801E   LHU V0, -32738(GP)
9D007374  2442FFF8   ADDIU V0, V0, -8
9D007378  A782801E   SH V0, -32738(GP)
74:                          }
75:                      }
76:                  } // cursor_right()
9D00737C  8FBF0014   LW RA, 20(SP)
9D007380  03E00008   JR RA
9D007384  27BD0018   ADDIU SP, SP, 24
77:                  
78:                  void cursor_left(void){
9D007388  27BDFFE8   ADDIU SP, SP, -24
9D00738C  AFBF0014   SW RA, 20(SP)
79:                      if (cx>=(X_OFS+CWIDTH)){
9D007390  9782801C   LHU V0, -32740(GP)
9D007394  2C430007   SLTIU V1, V0, 7
9D007398  54600004   BNEL V1, ZERO, 0x9D0073AC
9D00739C  24020139   ADDIU V0, ZERO, 313
80:                          cx -= CWIDTH;
9D0073A0  2442FFFA   ADDIU V0, V0, -6
9D0073A4  0B401CF4   J 0x9D0073D0
9D0073A8  A782801C   SH V0, -32740(GP)
81:                      }else{
82:                          cx = X_OFS+CWIDTH*(CHAR_PER_LINE-1);
9D0073AC  A782801C   SH V0, -32740(GP)
83:                          if (cy>=(Y_OFS+CHEIGHT)){
9D0073B0  9782801E   LHU V0, -32738(GP)
9D0073B4  2C43000B   SLTIU V1, V0, 11
9D0073B8  14600003   BNE V1, ZERO, 0x9D0073C8
9D0073BC  2442FFF8   ADDIU V0, V0, -8
84:                              cy -= CHEIGHT;
9D0073C0  0B401CF4   J 0x9D0073D0
9D0073C4  A782801E   SH V0, -32738(GP)
85:                          }else{
86:                              scroll_down();
9D0073C8  0F401CB7   JAL scroll_down
9D0073CC  00000000   NOP
87:                          }
88:                      }
89:                  }// cursor_left()
9D0073D0  8FBF0014   LW RA, 20(SP)
9D0073D4  03E00008   JR RA
9D0073D8  27BD0018   ADDIU SP, SP, 24
90:                  
91:                  void cursor_up(void){
9D0073DC  27BDFFE8   ADDIU SP, SP, -24
9D0073E0  AFBF0014   SW RA, 20(SP)
92:                      if (cy>=(Y_OFS+CHEIGHT)){
9D0073E4  9782801E   LHU V0, -32738(GP)
9D0073E8  2C43000B   SLTIU V1, V0, 11
9D0073EC  14600003   BNE V1, ZERO, 0x9D0073FC
9D0073F0  2442FFF8   ADDIU V0, V0, -8
93:                          cy -= CHEIGHT;
9D0073F4  0B401D01   J 0x9D007404
9D0073F8  A782801E   SH V0, -32738(GP)
94:                      }else{
95:                          scroll_down();
9D0073FC  0F401CB7   JAL scroll_down
9D007400  00000000   NOP
96:                      }
97:                  }// cursor_up()
9D007404  8FBF0014   LW RA, 20(SP)
9D007408  03E00008   JR RA
9D00740C  27BD0018   ADDIU SP, SP, 24
98:                  
99:                  void cursor_down(void){
9D007410  27BDFFE8   ADDIU SP, SP, -24
9D007414  AFBF0014   SW RA, 20(SP)
100:                     if (cy<=(Y_OFS+(CHEIGHT*(LINE_PER_SCREEN-2)))){
9D007418  9782801E   LHU V0, -32738(GP)
9D00741C  2C4300D4   SLTIU V1, V0, 212
9D007420  10600003   BEQ V1, ZERO, 0x9D007430
9D007424  24420008   ADDIU V0, V0, 8
101:                         cy += CHEIGHT;
9D007428  0B401D0E   J 0x9D007438
9D00742C  A782801E   SH V0, -32738(GP)
102:                     }else{
103:                         scroll_up();
9D007430  0F401CA6   JAL scroll_up
9D007434  00000000   NOP
104:                     }
105:                 }//cursor_down()
9D007438  8FBF0014   LW RA, 20(SP)
9D00743C  03E00008   JR RA
9D007440  27BD0018   ADDIU SP, SP, 24
106:                 
107:                 void crlf(void){
9D007444  27BDFFE8   ADDIU SP, SP, -24
9D007448  AFBF0014   SW RA, 20(SP)
108:                     cx=X_OFS;
9D00744C  24020001   ADDIU V0, ZERO, 1
9D007450  A782801C   SH V0, -32740(GP)
109:                     if (cy==(Y_OFS+(LINE_PER_SCREEN-1)*CHEIGHT)){
9D007454  9782801E   LHU V0, -32738(GP)
9D007458  240300DB   ADDIU V1, ZERO, 219
9D00745C  14430005   BNE V0, V1, 0x9D007474
9D007460  24420008   ADDIU V0, V0, 8
110:                         scroll_up();
9D007464  0F401CA6   JAL scroll_up
9D007468  00000000   NOP
111:                     }else{
112:                         cy += CHEIGHT;
9D007474  A782801E   SH V0, -32738(GP)
113:                     }
114:                 }//crlf()
9D00746C  0B401D1F   J 0x9D00747C
9D007470  8FBF0014   LW RA, 20(SP)
9D007478  8FBF0014   LW RA, 20(SP)
9D00747C  03E00008   JR RA
9D007480  27BD0018   ADDIU SP, SP, 24
115:                 
116:                 void put_char(dev_t channel, char c){
9D007484  27BDFFE8   ADDIU SP, SP, -24
9D007488  AFBF0014   SW RA, 20(SP)
9D00748C  7C042420   SEB A0, A0
9D007490  7C052C20   SEB A1, A1
9D007584  24660001   ADDIU A2, V1, 1
9D007588  2404000A   ADDIU A0, ZERO, 10
9D00758C  70644802   MUL T1, V1, A0
9D007590  01282021   ADDU A0, T1, T0
9D007594  00044080   SLL T0, A0, 2
9D007598  3C04A000   LUI A0, -24576
9D00759C  2484007C   ADDIU A0, A0, 124
9D0075A0  00882021   ADDU A0, A0, T0
9D0075A4  3C089D01   LUI T0, -25343
9D0075A8  2509913C   ADDIU T1, T0, -28356
9D0075AC  24080007   ADDIU T0, ZERO, 7
9D0075B0  70A85002   MUL T2, A1, T0
9D0075B4  01492821   ADDU A1, T2, T1
9D0075B8  24630008   ADDIU V1, V1, 8
117:                     register int i,l,r,b,x,y;
118:                     x=cx;
9D007494  9782801C   LHU V0, -32740(GP)
119:                     y=cy;
120:                     if (channel==LOCAL_CON){
9D007498  14800062   BNE A0, ZERO, 0x9D007624
9D00749C  9783801E   LHU V1, -32738(GP)
121:                         switch (c){
9D0074A0  24040009   ADDIU A0, ZERO, 9
9D0074A4  10A4000B   BEQ A1, A0, 0x9D0074D4
9D0074A8  2404000D   ADDIU A0, ZERO, 13
9D0074AC  10A40005   BEQ A1, A0, 0x9D0074C4
9D0074B0  24040008   ADDIU A0, ZERO, 8
9D0074B4  14A4001F   BNE A1, A0, 0x9D007534
9D0074B8  28A40020   SLTI A0, A1, 32
9D0074BC  0B401D49   J 0x9D007524
9D0074C0  00000000   NOP
122:                             case CR:
123:                                 crlf();
9D0074C4  0F401D11   JAL crlf
9D0074C8  00000000   NOP
124:                                 break;
9D0074CC  0B401D8C   J 0x9D007630
9D0074D0  8FBF0014   LW RA, 20(SP)
125:                             case TAB:
126:                                 cx += (cx%tab_width);
9D0074D4  93848020   LBU A0, -32736(GP)
9D0074D8  0044001A   DIV V0, A0
9D0074DC  008001F4   TEQ A0, ZERO
9D0074E0  00002010   MFHI A0, 0
9D0074E4  00441021   ADDU V0, V0, A0
9D0074E8  3042FFFF   ANDI V0, V0, -1
9D0074EC  A782801C   SH V0, -32740(GP)
127:                                 if (cx>=(X_OFS+CHAR_PER_LINE*CWIDTH)){
9D0074F0  2C42013F   SLTIU V0, V0, 319
9D0074F4  1440004D   BNE V0, ZERO, 0x9D00762C
9D0074F8  24020001   ADDIU V0, ZERO, 1
128:                                     cx = X_OFS;
9D0074FC  A782801C   SH V0, -32740(GP)
129:                                     if (cy==(Y_OFS+(LINE_PER_SCREEN-1)*CHEIGHT)){
9D007500  240200DB   ADDIU V0, ZERO, 219
9D007504  14620005   BNE V1, V0, 0x9D00751C
9D007508  24630008   ADDIU V1, V1, 8
130:                                         scroll_up();
9D00750C  0F401CA6   JAL scroll_up
9D007510  00000000   NOP
131:                                     }else{
132:                                         cy += CHEIGHT;
9D00751C  0B401D8B   J 0x9D00762C
9D007520  A783801E   SH V1, -32738(GP)
133:                                     }
134:                                 }
135:                                 break;
136:                             case '\b':
137:                                 cursor_left();
9D007524  0F401CE2   JAL cursor_left
9D007528  00000000   NOP
138:                                 break;
9D00752C  0B401D8C   J 0x9D007630
9D007530  8FBF0014   LW RA, 20(SP)
139:                             default:
140:                                 if ((c<32) || (c>(FONT_SIZE+32))) break;
9D007534  1480003D   BNE A0, ZERO, 0x9D00762C
9D007538  24A5FFE0   ADDIU A1, A1, -32
141:                                 c -=32;
9D00753C  7C052C20   SEB A1, A1
142:                                 b=x>>5;
9D007540  00024143   SRA T0, V0, 5
143:                                 r=0;
144:                                 l=27-(x&0x1f);
9D007544  3042001F   ANDI V0, V0, 31
9D007548  2406001B   ADDIU A2, ZERO, 27
9D00754C  00C21023   SUBU V0, A2, V0
145:                                 if (l<0){
146:                                     r=-l;
9D007550  00023023   SUBU A2, ZERO, V0
9D007554  28470000   SLTI A3, V0, 0
9D007558  0007300A   MOVZ A2, ZERO, A3
9D00755C  00C03821   ADDU A3, A2, ZERO
147:                                 }
148:                                 for (i=0;i<7;i++){
9D00760C  14C3FFEB   BNE A2, V1, 0x9D0075BC
9D007610  24A50001   ADDIU A1, A1, 1
149:                                     if (r){
9D0075BC  10E0000C   BEQ A3, ZERO, 0x9D0075F0
9D0075C0  8C890000   LW T1, 0(A0)
150:                                         video_bmp[y][b] &= ~(0x1f>>r);
9D007560  240C001F   ADDIU T4, ZERO, 31
9D007564  00CC7007   SRAV T6, T4, A2
9D007568  000E7027   NOR T6, ZERO, T6
9D0075C8  01C94824   AND T1, T6, T1
151:                                         video_bmp[y][b] |= font5x7[c][i]>>r;
9D0075C4  90A80000   LBU T0, 0(A1)
9D0075CC  00E85007   SRAV T2, T0, A3
9D0075D0  012A4825   OR T1, T1, T2
9D0075D4  AC890000   SW T1, 0(A0)
152:                                         video_bmp[y][b+1] &= ~(0x1f<<32-r);
9D00756C  240B0020   ADDIU T3, ZERO, 32
9D007570  01665823   SUBU T3, T3, A2
9D007574  016C6804   SLLV T5, T4, T3
9D007578  000D6827   NOR T5, ZERO, T5
9D0075D8  8C890004   LW T1, 4(A0)
9D0075DC  01A94824   AND T1, T5, T1
153:                                         video_bmp[y][b+1] |= font5x7[c][i]<<(32-r);
9D0075E0  01684004   SLLV T0, T0, T3
9D0075E4  01284025   OR T0, T1, T0
9D0075E8  0B401D81   J 0x9D007604
9D0075EC  AC880004   SW T0, 4(A0)
154:                                         y++;
155:                                     } else{
156:                                         video_bmp[y][b] &= ~(0x1f<<l);
9D00757C  004C6004   SLLV T4, T4, V0
9D007580  000C6027   NOR T4, ZERO, T4
9D0075F0  01894824   AND T1, T4, T1
157:                                         video_bmp[y++][b] |= font5x7[c][i]<<l;
9D0075F4  90A80000   LBU T0, 0(A1)
9D0075F8  00484004   SLLV T0, T0, V0
9D0075FC  01284025   OR T0, T1, T0
9D007600  AC880000   SW T0, 0(A0)
9D007604  24C60001   ADDIU A2, A2, 1
9D007608  24840028   ADDIU A0, A0, 40
158:                                     }
159:                                 }
160:                                 cursor_right();
9D007614  0F401CC9   JAL cursor_right
9D007618  00000000   NOP
161:                         }//switch(c)
162:                     }else{
163:                         UartPutch(channel,c);
9D007624  0F402169   JAL UartPutch
9D007628  00000000   NOP
164:                     }
165:                 }//put_char()
9D007514  0B401D8C   J 0x9D007630
9D007518  8FBF0014   LW RA, 20(SP)
9D00761C  0B401D8C   J 0x9D007630
9D007620  8FBF0014   LW RA, 20(SP)
9D00762C  8FBF0014   LW RA, 20(SP)
9D007630  03E00008   JR RA
9D007634  27BD0018   ADDIU SP, SP, 24
166:                 
167:                 void clear_screen(){
9D007638  27BDFFE8   ADDIU SP, SP, -24
9D00763C  AFBF0014   SW RA, 20(SP)
168:                     memset(video_bmp,0,HRES/8*VRES);
9D007640  3C04A000   LUI A0, -24576
9D007644  2484007C   ADDIU A0, A0, 124
9D007648  00002821   ADDU A1, ZERO, ZERO
9D00764C  0F40283B   JAL 0x9D00A0EC
9D007650  240623F0   ADDIU A2, ZERO, 9200
169:                     cx=X_OFS;
9D007654  24020001   ADDIU V0, ZERO, 1
9D007658  A782801C   SH V0, -32740(GP)
170:                     cy=Y_OFS;
9D00765C  24020003   ADDIU V0, ZERO, 3
9D007660  A782801E   SH V0, -32738(GP)
171:                 } // clear_screen()
9D007664  8FBF0014   LW RA, 20(SP)
9D007668  03E00008   JR RA
9D00766C  27BD0018   ADDIU SP, SP, 24
172:                 
173:                 void print(dev_t channel, const char *text){
9D007670  27BDFFE8   ADDIU SP, SP, -24
9D007674  AFBF0014   SW RA, 20(SP)
9D007678  AFB00010   SW S0, 16(SP)
9D00767C  7C042420   SEB A0, A0
174:                     if (channel==LOCAL_CON){
9D007680  1480000C   BNE A0, ZERO, 0x9D0076B4
9D007684  00A08021   ADDU S0, A1, ZERO
175:                         while (*text){
9D007688  80A50000   LB A1, 0(A1)
9D00768C  10A0000C   BEQ A1, ZERO, 0x9D0076C0
9D007690  8FBF0014   LW RA, 20(SP)
9D0076A0  82050000   LB A1, 0(S0)
9D0076A4  14A0FFFC   BNE A1, ZERO, 0x9D007698
9D0076A8  26100001   ADDIU S0, S0, 1
176:                             put_char(channel, *text++);
9D007694  26100001   ADDIU S0, S0, 1
9D007698  0F401D21   JAL put_char
9D00769C  00002021   ADDU A0, ZERO, ZERO
177:                         }
178:                     }else{
179:                         UartPrint(channel,text);
9D0076B4  0F4021A1   JAL UartPrint
9D0076B8  00000000   NOP
180:                     }
181:                 }// print()
9D0076AC  0B401DB0   J 0x9D0076C0
9D0076B0  8FBF0014   LW RA, 20(SP)
9D0076BC  8FBF0014   LW RA, 20(SP)
9D0076C0  8FB00010   LW S0, 16(SP)
9D0076C4  03E00008   JR RA
9D0076C8  27BD0018   ADDIU SP, SP, 24
182:                 
183:                 void print_hex(dev_t channel, unsigned int hex, unsigned char width){
9D0076CC  27BDFFD8   ADDIU SP, SP, -40
9D0076D0  AFBF0024   SW RA, 36(SP)
9D0076D4  7C042420   SEB A0, A0
184:                     char c[12], *d;
185:                     int i;
186:                     c[11]=0;
9D0076D8  A3A0001B   SB ZERO, 27(SP)
187:                     d= &c[10];
188:                     for(i=width;i>=0||hex;i--){
9D0076DC  30C600FF   ANDI A2, A2, 255
9D0076E0  0B401DC5   J 0x9D007714
9D0076E4  27A2001A   ADDIU V0, SP, 26
9D007710  24C6FFFF   ADDIU A2, A2, -1
9D007714  04C1FFF4   BGEZ A2, 0x9D0076E8
9D007718  30A3000F   ANDI V1, A1, 15
9D00771C  14A0FFF3   BNE A1, ZERO, 0x9D0076EC
9D007720  2867000A   SLTI A3, V1, 10
189:                         *d=(hex%16);
190:                         if (*d<10)
9D0076E8  2867000A   SLTI A3, V1, 10
9D0076EC  10E00004   BEQ A3, ZERO, 0x9D007700
9D0076F0  A0430000   SB V1, 0(V0)
191:                             *d += '0';
9D0076F4  24630030   ADDIU V1, V1, 48
9D0076F8  0B401DC2   J 0x9D007708
9D0076FC  A0430000   SB V1, 0(V0)
192:                         else
193:                             *d += 'A'-10;
9D007700  24630037   ADDIU V1, V1, 55
9D007704  A0430000   SB V1, 0(V0)
194:                         hex /=16;
9D007708  00052902   SRL A1, A1, 4
195:                         d--;
9D00770C  2442FFFF   ADDIU V0, V0, -1
196:                     }
197:                     print(channel, ++d);
9D007724  0F401D9C   JAL print
9D007728  24450001   ADDIU A1, V0, 1
198:                 } // print_hex()
9D00772C  8FBF0024   LW RA, 36(SP)
9D007730  03E00008   JR RA
9D007734  27BD0028   ADDIU SP, SP, 40
199:                 
200:                 void print_int(dev_t channel, int number, unsigned short width){ // imprime entier,width inclus le signe
9D007738  27BDFFD8   ADDIU SP, SP, -40
9D00773C  AFBF0024   SW RA, 36(SP)
9D007740  7C042420   SEB A0, A0
9D007744  30C3FFFF   ANDI V1, A2, -1
201:                     int sign=0, i;
202:                     char str[14], *d;
203:                     str[13]=0;
9D007748  A3A0001D   SB ZERO, 29(SP)
204:                     d=&str[12];
9D007764  27A2001C   ADDIU V0, SP, 28
205:                     if (number<0){
9D00774C  04A10003   BGEZ A1, 0x9D00775C
9D007750  00004021   ADDU T0, ZERO, ZERO
206:                         sign=1;
9D007758  24080001   ADDIU T0, ZERO, 1
207:                         number = -number;
9D007754  00052823   SUBU A1, ZERO, A1
208:                     }
209:                     for (i=--width;i>=0||number;i--){
9D00775C  2463FFFF   ADDIU V1, V1, -1
9D007760  3063FFFF   ANDI V1, V1, -1
9D007768  0B401DE4   J 0x9D007790
9D00776C  2406000A   ADDIU A2, ZERO, 10
9D00778C  2463FFFF   ADDIU V1, V1, -1
9D007790  0461FFF7   BGEZ V1, 0x9D007770
9D007794  00000000   NOP
9D007798  14A0FFF5   BNE A1, ZERO, 0x9D007770
9D00779C  00000000   NOP
210:                         *d--=(number%10)+'0';
9D007770  00A6001A   DIV A1, A2
9D007774  00C001F4   TEQ A2, ZERO
9D007778  00003810   MFHI A3, 0
9D00777C  00002812   MFLO A1, 0
9D007780  24E70030   ADDIU A3, A3, 48
9D007784  A0470000   SB A3, 0(V0)
9D007788  2442FFFF   ADDIU V0, V0, -1
211:                         number /= 10;
212:                     }
213:                     if (sign){*d='-';}else{*d='+';}
9D0077A0  11000004   BEQ T0, ZERO, 0x9D0077B4
9D0077A4  2403002B   ADDIU V1, ZERO, 43
9D0077A8  2403002D   ADDIU V1, ZERO, 45
9D0077AC  0B401DEE   J 0x9D0077B8
9D0077B0  A0430000   SB V1, 0(V0)
9D0077B4  A0430000   SB V1, 0(V0)
214:                     print(channel, d);
9D0077B8  0F401D9C   JAL print
9D0077BC  00402821   ADDU A1, V0, ZERO
215:                 }// print_int()
9D0077C0  8FBF0024   LW RA, 36(SP)
9D0077C4  03E00008   JR RA
9D0077C8  27BD0028   ADDIU SP, SP, 40
216:                 
217:                 void set_tab_width(unsigned char width){
218:                     tab_width=width;
219:                 }// set_tab_width()
9D0077CC  03E00008   JR RA
9D0077D0  A3848020   SB A0, -32736(GP)
220:                 
221:                 void clear_eol(void){
9D0077D4  27BDFFE0   ADDIU SP, SP, -32
9D0077D8  AFBF001C   SW RA, 28(SP)
9D0077DC  AFB10018   SW S1, 24(SP)
9D0077E0  AFB00014   SW S0, 20(SP)
222:                     int x,y;
223:                     x=cx;
9D0077E4  9790801C   LHU S0, -32740(GP)
224:                     y=cy;
225:                     while (cx<(X_OFS+CWIDTH*(CHAR_PER_LINE-1))){
9D0077E8  2E020139   SLTIU V0, S0, 313
9D0077EC  1040000A   BEQ V0, ZERO, 0x9D007818
9D0077F0  9791801E   LHU S1, -32738(GP)
9D007808  9782801C   LHU V0, -32740(GP)
9D00780C  2C420139   SLTIU V0, V0, 313
9D007810  1440FFF9   BNE V0, ZERO, 0x9D0077F8
9D007814  00002021   ADDU A0, ZERO, ZERO
226:                         put_char(LOCAL_CON, 32);
9D0077F4  00002021   ADDU A0, ZERO, ZERO
9D0077F8  0F401D21   JAL put_char
9D0077FC  24050020   ADDIU A1, ZERO, 32
227:                         cursor_right();
9D007800  0F401CC9   JAL cursor_right
9D007804  00000000   NOP
228:                     }
229:                     put_char(LOCAL_CON, 32);
9D007818  00002021   ADDU A0, ZERO, ZERO
9D00781C  0F401D21   JAL put_char
9D007820  24050020   ADDIU A1, ZERO, 32
230:                     cx=x;
9D007824  A790801C   SH S0, -32740(GP)
231:                     cy=y;
9D007828  A791801E   SH S1, -32738(GP)
232:                 }// clear_eol()
9D00782C  8FBF001C   LW RA, 28(SP)
9D007830  8FB10018   LW S1, 24(SP)
9D007834  8FB00014   LW S0, 20(SP)
9D007838  03E00008   JR RA
9D00783C  27BD0020   ADDIU SP, SP, 32
233:                 
234:                 text_coord_t get_curpos(){
9D007840  00801021   ADDU V0, A0, ZERO
235:                     text_coord_t cpos;
236:                     cpos.x = (cx-X_OFS)/CWIDTH;
9D00785C  9783801C   LHU V1, -32740(GP)
9D007860  2463FFFF   ADDIU V1, V1, -1
9D007864  3C052AAA   LUI A1, 10922
9D007868  34A5AAAB   ORI A1, A1, -21845
9D00786C  00650018   MULT 0, V1, A1
9D007870  00031FC3   SRA V1, V1, 31
9D007874  00003810   MFHI A3, 0
9D007878  00E31823   SUBU V1, A3, V1
9D00787C  A4430000   SH V1, 0(V0)
237:                     cpos.y = (cy-Y_OFS)/CHEIGHT;
9D007844  9784801E   LHU A0, -32738(GP)
9D007848  2483FFFD   ADDIU V1, A0, -3
9D00784C  24840004   ADDIU A0, A0, 4
9D007850  28650000   SLTI A1, V1, 0
9D007854  0065200A   MOVZ A0, V1, A1
9D007858  7C8478C0   EXT A0, A0, 3, 16
238:                     return cpos;
239:                 } // get_cursor_pos()
9D007880  03E00008   JR RA
9D007884  A4440002   SH A0, 2(V0)
240:                 
241:                 void set_curpos(unsigned short x, unsigned short y){// {x,y} coordonnée caractère
9D007888  3084FFFF   ANDI A0, A0, -1
242:                     if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
9D00788C  2C820035   SLTIU V0, A0, 53
9D007890  1040000A   BEQ V0, ZERO, 0x9D0078BC
9D007894  30A5FFFF   ANDI A1, A1, -1
9D007898  2CA2001C   SLTIU V0, A1, 28
9D00789C  10400007   BEQ V0, ZERO, 0x9D0078BC
9D0078A0  24020006   ADDIU V0, ZERO, 6
243:                         return;
244:                     cx=x*CWIDTH+X_OFS;
9D0078A4  70822002   MUL A0, A0, V0
9D0078A8  24840001   ADDIU A0, A0, 1
9D0078AC  A784801C   SH A0, -32740(GP)
245:                     cy=y*CHEIGHT+Y_OFS;
9D0078B0  000528C0   SLL A1, A1, 3
9D0078B4  24A50003   ADDIU A1, A1, 3
9D0078B8  A785801E   SH A1, -32738(GP)
9D0078BC  03E00008   JR RA
9D0078C0  00000000   NOP
246:                 }//set_curpos()
247:                 
248:                 void invert_char(void){// inverse vidéo du caractère à la position courante
9D007900  24A30001   ADDIU V1, A1, 1
9D007904  2402000A   ADDIU V0, ZERO, 10
9D007908  70A25002   MUL T2, A1, V0
9D00790C  01461021   ADDU V0, T2, A2
9D007910  00023080   SLL A2, V0, 2
9D007914  3C02A000   LUI V0, -24576
9D007918  2442007C   ADDIU V0, V0, 124
9D00791C  00461021   ADDU V0, V0, A2
9D007920  24A50009   ADDIU A1, A1, 9
249:                     register int i,l,r,b,x,y;
250:                     x=cx;
9D0078C4  9787801C   LHU A3, -32740(GP)
251:                     y=cy;
9D0078C8  9785801E   LHU A1, -32738(GP)
252:                     b=x>>5;
9D0078CC  00073143   SRA A2, A3, 5
253:                     r=0;
254:                     l=27-(x&0x1f);
9D0078D0  30E7001F   ANDI A3, A3, 31
9D0078D4  2403001B   ADDIU V1, ZERO, 27
9D0078D8  00673823   SUBU A3, V1, A3
255:                     if (l<0){
256:                         r=-l;
9D0078DC  00071823   SUBU V1, ZERO, A3
9D0078E0  28E40000   SLTI A0, A3, 0
9D0078E4  0004180A   MOVZ V1, ZERO, A0
9D0078E8  00602021   ADDU A0, V1, ZERO
257:                     }
258:                     for (i=8;i;i--){
9D007950  1465FFF4   BNE V1, A1, 0x9D007924
9D007954  24420028   ADDIU V0, V0, 40
259:                         if (r){
9D007924  10800007   BEQ A0, ZERO, 0x9D007944
9D007928  8C460000   LW A2, 0(V0)
260:                             video_bmp[y][b] ^= (0x1f>>r);
9D0078EC  2403001F   ADDIU V1, ZERO, 31
9D0078F0  00834807   SRAV T1, V1, A0
9D00792C  00C93026   XOR A2, A2, T1
9D007930  AC460000   SW A2, 0(V0)
261:                             video_bmp[y][b+1] ^= (0x1f<<32-r);
9D0078F4  00044023   SUBU T0, ZERO, A0
9D0078F8  01034004   SLLV T0, V1, T0
9D007934  8C460004   LW A2, 4(V0)
9D007938  00C83026   XOR A2, A2, T0
9D00793C  0B401E53   J 0x9D00794C
9D007940  AC460004   SW A2, 4(V0)
262:                             y++;
263:                         } else{
264:                             video_bmp[y++][b] ^= (0x1f<<l);
9D0078FC  00E33804   SLLV A3, V1, A3
9D007944  00C73026   XOR A2, A2, A3
9D007948  AC460000   SW A2, 0(V0)
9D00794C  24630001   ADDIU V1, V1, 1
265:                         }
266:                     }
267:                 }//invert_char()
9D007958  03E00008   JR RA
9D00795C  00000000   NOP
268:                 
269:                 static void toggle_underscore(void){
270:                     register int l,r,b,x;
271:                     x=cx;
9D0071DC  9782801C   LHU V0, -32740(GP)
272:                     b=x>>5;
9D0071E0  00025143   SRA T2, V0, 5
273:                     r=0;
274:                     l=27-(x&0x1f);
9D0071E4  3042001F   ANDI V0, V0, 31
9D0071E8  2403001B   ADDIU V1, ZERO, 27
9D0071EC  00621023   SUBU V0, V1, V0
275:                     if (l<0){
9D0071F0  0441001B   BGEZ V0, 0x9D007260
9D0071F4  9783801E   LHU V1, -32738(GP)
276:                         r=-l;
9D0071F8  00022023   SUBU A0, ZERO, V0
277:                     }
278:                     if (r){
9D0071FC  10800018   BEQ A0, ZERO, 0x9D007260
9D007200  2405000A   ADDIU A1, ZERO, 10
279:                         video_bmp[cy+CHEIGHT-1][b] ^= (0x1f>>r);
9D007204  9782801E   LHU V0, -32738(GP)
9D007208  24420007   ADDIU V0, V0, 7
9D00720C  70451002   MUL V0, V0, A1
9D007210  004A3821   ADDU A3, V0, T2
9D007214  00073880   SLL A3, A3, 2
9D007218  3C06A000   LUI A2, -24576
9D00721C  24C6007C   ADDIU A2, A2, 124
9D007220  00E63821   ADDU A3, A3, A2
9D007224  2405001F   ADDIU A1, ZERO, 31
9D007228  00854807   SRAV T1, A1, A0
9D00722C  8CE80000   LW T0, 0(A3)
9D007230  01284026   XOR T0, T1, T0
9D007234  ACE80000   SW T0, 0(A3)
280:                         video_bmp[cy+CHEIGHT-1][b+1] ^= (0x1f<<32-r);
9D007238  25430001   ADDIU V1, T2, 1
9D00723C  00431021   ADDU V0, V0, V1
9D007240  00021080   SLL V0, V0, 2
9D007244  00461021   ADDU V0, V0, A2
9D007248  00042023   SUBU A0, ZERO, A0
9D00724C  00852804   SLLV A1, A1, A0
9D007250  8C430000   LW V1, 0(V0)
9D007254  00A32826   XOR A1, A1, V1
9D007258  03E00008   JR RA
9D00725C  AC450000   SW A1, 0(V0)
281:                     } else{
282:                         video_bmp[cy+CHEIGHT-1][b] ^= (0x1f<<l);
9D007260  24630007   ADDIU V1, V1, 7
9D007264  2404000A   ADDIU A0, ZERO, 10
9D007268  70642802   MUL A1, V1, A0
9D00726C  00AA1821   ADDU V1, A1, T2
9D007270  00031880   SLL V1, V1, 2
9D007274  3C04A000   LUI A0, -24576
9D007278  2484007C   ADDIU A0, A0, 124
9D00727C  00641821   ADDU V1, V1, A0
9D007280  2404001F   ADDIU A0, ZERO, 31
9D007284  00441004   SLLV V0, A0, V0
9D007288  8C640000   LW A0, 0(V1)
9D00728C  00441026   XOR V0, V0, A0
9D007290  03E00008   JR RA
9D007294  AC620000   SW V0, 0(V1)
283:                     }
284:                 }//toggle_underscore()
285:                 
286:                 void show_cursor(BOOL show){
9D007960  27BDFFE8   ADDIU SP, SP, -24
9D007964  AFBF0014   SW RA, 20(SP)
287:                     if (show){
9D007968  10800011   BEQ A0, ZERO, 0x9D0079B0
9D00796C  AFB00010   SW S0, 16(SP)
288:                         flags |= CUR_SHOW;
9D007970  97828036   LHU V0, -32714(GP)
9D007974  34420001   ORI V0, V0, 1
289:                         flags ^= CUR_VIS;
9D007978  38420002   XORI V0, V0, 2
9D00797C  A7828036   SH V0, -32714(GP)
290:                         if (cur_shape==CR_BLOCK){
9D007980  24020001   ADDIU V0, ZERO, 1
9D007984  8F838038   LW V1, -32712(GP)
9D007988  14620005   BNE V1, V0, 0x9D0079A0
9D00798C  00000000   NOP
291:                             invert_char();
9D007990  0F401E31   JAL invert_char
9D007994  00000000   NOP
292:                         }else{
293:                             toggle_underscore();
9D0079A0  0F401C77   JAL 0x9D0071DC
9D0079A4  00000000   NOP
294:                         }
295:                     }else{
296:                         if (flags & CUR_VIS){
9D0079B0  97908036   LHU S0, -32714(GP)
9D0079B4  32020002   ANDI V0, S0, 2
9D0079B8  1040000D   BEQ V0, ZERO, 0x9D0079F0
9D0079BC  97828036   LHU V0, -32714(GP)
297:                             if (cur_shape==CR_BLOCK){
9D0079C0  24020001   ADDIU V0, ZERO, 1
9D0079C4  8F838038   LW V1, -32712(GP)
9D0079C8  14620005   BNE V1, V0, 0x9D0079E0
9D0079CC  00000000   NOP
298:                                 invert_char();
9D0079D0  0F401E31   JAL invert_char
9D0079D4  3210FFFD   ANDI S0, S0, -3
299:                             }else{
300:                                 toggle_underscore();
9D0079E0  0F401C77   JAL 0x9D0071DC
9D0079E4  3210FFFD   ANDI S0, S0, -3
301:                             }
302:                             flags &= ~CUR_VIS;
9D0079D8  0B401E7B   J 0x9D0079EC
9D0079DC  A7908036   SH S0, -32714(GP)
9D0079E8  A7908036   SH S0, -32714(GP)
303:                         }
304:                         flags &= ~CUR_SHOW;
9D0079EC  97828036   LHU V0, -32714(GP)
9D0079F0  3042FFFE   ANDI V0, V0, -2
9D0079F4  A7828036   SH V0, -32714(GP)
305:                     }
306:                 
307:                 }// show_cursor()
9D007998  0B401E7F   J 0x9D0079FC
9D00799C  8FBF0014   LW RA, 20(SP)
9D0079A8  0B401E7F   J 0x9D0079FC
9D0079AC  8FBF0014   LW RA, 20(SP)
9D0079F8  8FBF0014   LW RA, 20(SP)
9D0079FC  8FB00010   LW S0, 16(SP)
9D007A00  03E00008   JR RA
9D007A04  27BD0018   ADDIU SP, SP, 24
308:                 
309:                 void set_cursor(cursor_t shape){
9D007A08  27BDFFE8   ADDIU SP, SP, -24
9D007A0C  AFBF0014   SW RA, 20(SP)
9D007A10  AFB00010   SW S0, 16(SP)
310:                     if (flags & CUR_VIS){
9D007A14  97828036   LHU V0, -32714(GP)
9D007A18  30420002   ANDI V0, V0, 2
9D007A1C  10400008   BEQ V0, ZERO, 0x9D007A40
9D007A20  00808021   ADDU S0, A0, ZERO
311:                         show_cursor(FALSE);
9D007A24  0F401E58   JAL show_cursor
9D007A28  00002021   ADDU A0, ZERO, ZERO
312:                         cur_shape=shape;
9D007A2C  AF908038   SW S0, -32712(GP)
313:                         show_cursor(TRUE);
9D007A30  0F401E58   JAL show_cursor
9D007A34  24040001   ADDIU A0, ZERO, 1
314:                     }else{
315:                         cur_shape=shape;
9D007A40  AF848038   SW A0, -32712(GP)
316:                     }
317:                 }// set_cursor()
9D007A38  0B401E92   J 0x9D007A48
9D007A3C  8FBF0014   LW RA, 20(SP)
9D007A44  8FBF0014   LW RA, 20(SP)
9D007A48  8FB00010   LW S0, 16(SP)
9D007A4C  03E00008   JR RA
9D007A50  27BD0018   ADDIU SP, SP, 24
318:                 
319:                 unsigned short get_key(dev_t channel){ // lecture touche clavier, retourne 0 s'il n'y a pas de touche ou touche relâchée.
9D007A54  27BDFFE8   ADDIU SP, SP, -24
9D007A58  7C042420   SEB A0, A0
320:                     unsigned short code;
321:                     if (channel==LOCAL_CON){
9D007A5C  1480000C   BNE A0, ZERO, 0x9D007A90
9D007A60  AFBF0014   SW RA, 20(SP)
322:                         code=  KbdScancode();
9D007A64  0F401767   JAL KbdScancode
9D007A68  00000000   NOP
9D007A6C  00402021   ADDU A0, V0, ZERO
9D007A70  3042FFFF   ANDI V0, V0, -1
323:                         if (!(code & FN_BIT)){
9D007A74  30430200   ANDI V1, V0, 512
9D007A78  14600009   BNE V1, ZERO, 0x9D007AA0
9D007A7C  8FBF0014   LW RA, 20(SP)
324:                             code = KbdKey(code);
9D007A80  0F401640   JAL KbdKey
9D007A84  00000000   NOP
9D007A88  0B401EA7   J 0x9D007A9C
9D007A8C  3042FFFF   ANDI V0, V0, -1
325:                         }
326:                     }else{
327:                         code=UartGetch(STDIN);
9D007A90  0F40215C   JAL UartGetch
9D007A94  24040001   ADDIU A0, ZERO, 1
9D007A98  3042FFFF   ANDI V0, V0, -1
328:                         if (code==-1){
329:                             code=0;
330:                         }
331:                     }
332:                     return code;
333:                 }//get_key()
9D007A9C  8FBF0014   LW RA, 20(SP)
9D007AA0  03E00008   JR RA
9D007AA4  27BD0018   ADDIU SP, SP, 24
334:                 
335:                 unsigned short wait_key(dev_t channel){ // attend qu'une touche soit enfoncée et retourne sa valeur.
9D007AA8  27BDFFE0   ADDIU SP, SP, -32
9D007AAC  AFBF001C   SW RA, 28(SP)
9D007AB0  AFB10018   SW S1, 24(SP)
9D007AB4  AFB00014   SW S0, 20(SP)
336:                     unsigned short key;
337:                     unsigned int t0;
338:                     t0=ticks()+500;
9D007AB8  0F40240C   JAL ticks
9D007ABC  7C048420   SEB S0, A0
339:                     if (channel==LOCAL_CON){
9D007AC0  12000013   BEQ S0, ZERO, 0x9D007B10
9D007AC4  245101F4   ADDIU S1, V0, 500
340:                         while (!(key=get_key(channel))){
9D007B10  0F401E95   JAL get_key
9D007B14  00002021   ADDU A0, ZERO, ZERO
9D007B18  1040FFED   BEQ V0, ZERO, 0x9D007AD0
9D007B1C  00408021   ADDU S0, V0, ZERO
341:                             if (ticks()==t0){
9D007AD0  0F40240C   JAL ticks
9D007AD4  00000000   NOP
9D007AD8  1451000D   BNE V0, S1, 0x9D007B10
9D007ADC  97828036   LHU V0, -32714(GP)
342:                                 if (flags & CUR_SHOW){
9D007AE0  30420001   ANDI V0, V0, 1
9D007AE4  10400005   BEQ V0, ZERO, 0x9D007AFC
9D007AE8  00000000   NOP
343:                                     show_cursor(FALSE);
9D007AEC  0F401E58   JAL show_cursor
9D007AF0  00002021   ADDU A0, ZERO, ZERO
9D007AF4  0B401EC1   J 0x9D007B04
9D007AF8  00000000   NOP
344:                                 }else{
345:                                     show_cursor(TRUE);
9D007AFC  0F401E58   JAL show_cursor
9D007B00  24040001   ADDIU A0, ZERO, 1
346:                                 }
347:                                 t0=ticks()+500;
9D007B04  0F40240C   JAL ticks
9D007B08  00000000   NOP
9D007B0C  245101F4   ADDIU S1, V0, 500
348:                             }
349:                         };
350:                         show_cursor(FALSE);
9D007B20  0F401E58   JAL show_cursor
9D007B24  00002021   ADDU A0, ZERO, ZERO
351:                     }else{
352:                         key=UartWaitch(STDIN,0);
9D007AC8  0B401ECC   J 0x9D007B30
9D007ACC  24040001   ADDIU A0, ZERO, 1
9D007B30  0F402177   JAL UartWaitch
9D007B34  00002821   ADDU A1, ZERO, ZERO
9D007B38  3050FFFF   ANDI S0, V0, -1
353:                     }
354:                     return key;
355:                 }//wait_key()
9D007B28  0B401ED0   J 0x9D007B40
9D007B2C  02001021   ADDU V0, S0, ZERO
9D007B3C  02001021   ADDU V0, S0, ZERO
9D007B40  8FBF001C   LW RA, 28(SP)
9D007B44  8FB10018   LW S1, 24(SP)
9D007B48  8FB00014   LW S0, 20(SP)
9D007B4C  03E00008   JR RA
9D007B50  27BD0020   ADDIU SP, SP, 32
356:                 
357:                 unsigned char readline(dev_t channel, unsigned char *ibuff,unsigned char max_char){ // lit une ligne au clavier, retourne la longueur de texte.
9D007B54  27BDFFD0   ADDIU SP, SP, -48
9D007B58  AFBF002C   SW RA, 44(SP)
9D007B5C  AFB50028   SW S5, 40(SP)
9D007B60  AFB40024   SW S4, 36(SP)
9D007B64  AFB30020   SW S3, 32(SP)
9D007B68  AFB2001C   SW S2, 28(SP)
9D007B6C  AFB10018   SW S1, 24(SP)
9D007B70  AFB00014   SW S0, 20(SP)
9D007B74  00A08821   ADDU S1, A1, ZERO
9D007B78  7C042420   SEB A0, A0
358:                     unsigned char c=0, count=0;
359:                     if (channel==LOCAL_CON){
9D007B7C  14800022   BNE A0, ZERO, 0x9D007C08
9D007B80  30D400FF   ANDI S4, A2, 255
9D007B84  00008021   ADDU S0, ZERO, ZERO
360:                         while ((c!='\r') && (count<=max_char)){
9D007BCC  0B401EFC   J 0x9D007BF0
9D007BD0  0290102B   SLTU V0, S4, S0
9D007BEC  0290102B   SLTU V0, S4, S0
9D007BF0  1040FFE9   BEQ V0, ZERO, 0x9D007B98
9D007BF4  00000000   NOP
361:                             c=wait_key(channel);
9D007B98  0F401EAA   JAL wait_key
9D007B9C  00002021   ADDU A0, ZERO, ZERO
9D007BA0  304200FF   ANDI V0, V0, 255
362:                             if (c==CR){
9D007B88  2412000D   ADDIU S2, ZERO, 13
9D007BA4  10520014   BEQ V0, S2, 0x9D007BF8
9D007BA8  00000000   NOP
363:                                 break;
364:                             }else if (c==BS){
9D007B8C  24130008   ADDIU S3, ZERO, 8
9D007BAC  54530009   BNEL V0, S3, 0x9D007BD4
9D007BB0  A2220000   SB V0, 0(S1)
365:                                 ibuff--;
9D007BB4  2631FFFF   ADDIU S1, S1, -1
366:                                 count--;
9D007BB8  2610FFFF   ADDIU S0, S0, -1
9D007BBC  321000FF   ANDI S0, S0, 255
367:                                 print(channel,"\b \b");
9D007B90  3C159D01   LUI S5, -25343
9D007B94  26B5A868   ADDIU S5, S5, -22424
9D007BC0  00002021   ADDU A0, ZERO, ZERO
9D007BC4  0F401D9C   JAL print
9D007BC8  02A02821   ADDU A1, S5, ZERO
368:                             }else if ((c & FN_BIT)==0){
369:                                 *ibuff++=c;
9D007BD4  26310001   ADDIU S1, S1, 1
370:                                 count++;
9D007BD8  26100001   ADDIU S0, S0, 1
9D007BDC  321000FF   ANDI S0, S0, 255
371:                                 put_char(channel, c);
9D007BE0  00002021   ADDU A0, ZERO, ZERO
9D007BE4  0F401D21   JAL put_char
9D007BE8  7C022C20   SEB A1, V0
372:                             }
373:                         }// while
374:                         if (count){
9D007BF8  56000007   BNEL S0, ZERO, 0x9D007C18
9D007BFC  A2200000   SB ZERO, 0(S1)
375:                             *ibuff=(char)0;
376:                         }
377:                     }else{
378:                         count=UartReadln(STDIN,ibuff,max_char);
9D007C08  24040001   ADDIU A0, ZERO, 1
9D007C0C  0F4021BD   JAL UartReadln
9D007C10  02803021   ADDU A2, S4, ZERO
9D007C14  305000FF   ANDI S0, V0, 255
379:                     }
380:                     return count;
381:                 } // readline()
9D007C00  0B401F07   J 0x9D007C1C
9D007C04  02001021   ADDU V0, S0, ZERO
9D007C18  02001021   ADDU V0, S0, ZERO
9D007C1C  8FBF002C   LW RA, 44(SP)
9D007C20  8FB50028   LW S5, 40(SP)
9D007C24  8FB40024   LW S4, 36(SP)
9D007C28  8FB30020   LW S3, 32(SP)
9D007C2C  8FB2001C   LW S2, 28(SP)
9D007C30  8FB10018   LW S1, 24(SP)
9D007C34  8FB00014   LW S0, 20(SP)
9D007C38  03E00008   JR RA
9D007C3C  27BD0030   ADDIU SP, SP, 48
