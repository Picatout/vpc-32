Disassembly Listing for vpc-32
Generated From:
C:/Users/Jacques/Documents/GitHub/VPC-32.X/dist/default/production/VPC-32.X.production.elf
2013-09-19 14:43:08

---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/uart.h  ---------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: Constants & Data Types
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  //DOM-IGNORE-BEGIN
74:                  /****
75:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
76:                         the device file.  Also the UART register set could also be placed there
77:                  *****/
78:                  typedef struct
79:                  {
80:                  	volatile UINT	reg;
81:                  	volatile UINT	clr;
82:                  	volatile UINT	set;
83:                  	volatile UINT	inv;
84:                  }REG_SET;
85:                  
86:                  typedef struct
87:                  {
88:                  	volatile REG_SET	mode;
89:                  	volatile REG_SET	sta;
90:                  	volatile REG_SET    tx;
91:                  	volatile REG_SET	rx;
92:                  	volatile REG_SET	brg;
93:                  }UART_REGS;
94:                  
95:                  extern UART_REGS * const uartReg[];
96:                  //DOM-IGNORE-END
97:                  
98:                  // *****************************************************************************
99:                  /* UART Module
100:                 
101:                   Summary:
102:                     UART modules supported.
103:                 
104:                   Description:
105:                     This enumeration identifies the available UART modules.
106:                 */
107:                 
108:                 typedef enum
109:                 {
110:                 #if defined _UART1
111:                     // UART1 Module ID.
112:                     UART1 = 0,
113:                 #endif
114:                 #if defined _UART2
115:                     // UART2 Module ID.
116:                     UART2,
117:                 #endif
118:                 #ifdef _UART3
119:                     // UART3 Module ID.
120:                     UART3,
121:                 #endif
122:                 #ifdef _UART4
123:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
124:                     UART4,
125:                 #endif
126:                 #ifdef _UART5
127:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
128:                     UART5,
129:                 #endif
130:                 #ifdef _UART6
131:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
132:                     UART6,
133:                 #endif
134:                     // Number of available UART modules.
135:                     UART_NUMBER_OF_MODULES
136:                 
137:                 } UART_MODULE;
138:                 
139:                 
140:                 // *****************************************************************************
141:                 /* UART Enable Modes
142:                 
143:                   Summary:
144:                     Operating modes of UART.
145:                 
146:                   Description:
147:                     This enumeration defines the supported modes in which the UART may be
148:                     enabled or disbled.
149:                 
150:                   Remarks:
151:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
152:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
153:                     has been pre-loaded with data.
154:                 
155:                     The caller should not rely on the specific numbers assigned to any of these
156:                     values as they may change from one processor to the next.
157:                 */
158:                 
159:                 typedef enum
160:                 {
161:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
162:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
163:                 
164:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
165:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
166:                 
167:                 
168:                     // UART Module, receiver and transmitter functionality is not.
169:                     // enabled or disabled
170:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
171:                 
172:                     // UART Module receiver.
173:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
174:                 
175:                     // UART Module transmitter.
176:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
177:                 
178:                 
179:                 } UART_ENABLE_MODE;
180:                 
181:                 // *****************************************************************************
182:                 /* UART Enable Helper Macro
183:                 
184:                   Summary:
185:                     Macro for enabling module operating modes.
186:                 
187:                   Description:
188:                     This macro creates the proper flags for enabling operating modes of the UART module.
189:                 
190:                   Example:
191:                     <code>
192:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
193:                     </code>
194:                 
195:                   Remarks:
196:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
197:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
198:                     has been pre-loaded with data.
199:                 */
200:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
201:                 
202:                 // *****************************************************************************
203:                 /* UART Disable Helper Macro
204:                 
205:                   Summary:
206:                     Macro for disabling module operating modes.
207:                 
208:                   Description:
209:                     This macro creates the proper flags for disabling operating modes of the UART module.
210:                 
211:                   Example:
212:                     <code>
213:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
214:                     </code>
215:                 
216:                 */
217:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
218:                 
219:                 // *****************************************************************************
220:                 /* UART Configuration Settings
221:                 
222:                   Summary:
223:                     Supported configuration flags for the UART module.
224:                 
225:                   Description:
226:                     This enumeration defines the various configuration options for the UART
227:                     module.  These values can be OR'd together to create a configuration mask
228:                     passed to the UARTConfigure routine.
229:                 
230:                   Remarks:
231:                     Several of the configuration options are mutually exclusive:
232:                     * Only one of the "ENABLE_PINS" modes can be used at a time
233:                     * Only one of the "RTS_WHEN" modes can be used at a time
234:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
235:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
236:                 
237:                     The caller should not rely on the specific numbers assigned to any of these
238:                     values as they may change from one processor ot the next.
239:                 */
240:                 
241:                 typedef enum
242:                 {
243:                     // Enables high-speed range of the UART (see UARTSetBitRate).
244:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
245:                 
246:                     // Inverts polarity of data interpretation the received (RX) pin.
247:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
248:                 
249:                     // Enables UART TX-to-RX Loop-back mode.
250:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
251:                 
252:                     // Enables Wake-up of the part when a start bit is received.
253:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
254:                 
255:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
256:                     // cannot be used in bit-clock/IrDA mode).
257:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
258:                 
259:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
260:                     // cannot be used in CTS/RTS mode).
261:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
262:                 
263:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
264:                     // be used in RTS-Only mode).
265:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
266:                 
267:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
268:                     // the default mode and this parameter can be left out if it is desired).
269:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
270:                 
271:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
272:                     // is not full (i.e., the UART is ready to receive data).  This is also known
273:                     // as "RTS Flow-Control Mode".
274:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
275:                 
276:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
277:                     // is not empty (i.e., when the UART has data ready to send).  This is also
278:                     // known as "RTS Simplex Mode".
279:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
280:                 
281:                     // Enable the IrDA encoder/decoder.
282:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
283:                 
284:                     // Enables stopping of the UART operation to save power when the core has
285:                     // been put in idle mode.
286:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
287:                 
288:                     // Inverts the polarity of data sent on the transmit (TX) pin.
289:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
290:                 
291:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
292:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
293:                     // Note:  The address must still be set using UARTEnableAddressDetect
294:                     // to support IEEE-485 protocol.
295:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
296:                 
297:                 } UART_CONFIGURATION;
298:                 
299:                 
300:                 // *****************************************************************************
301:                 /* UART FIFO Modes
302:                 
303:                   Summary:
304:                     Supported FIFO modes for the UART module.
305:                 
306:                   Description:
307:                     This enumeration defines supported FIFO modes that determine when the Tx
308:                     and Rx interrupts will occur.
309:                 
310:                   Remarks:
311:                     These modes consist of two sets of mutially exclusive modes:
312:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
313:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
314:                 
315:                     The caller should not rely on the specific numbers assigned to any of these
316:                     values as they may change from one processor ot the next.
317:                 
318:                 */
319:                 
320:                 typedef enum
321:                 {
322:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
323:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
324:                 
325:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
326:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
327:                 
328:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
329:                     // full (i.e. there is space available for more data)  This is the default.
330:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
331:                 
332:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
333:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
334:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
337:                     // (three-quarter) full.
338:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
339:                 
340:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
341:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
342:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
343:                 
344:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
345:                     // data.
346:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
347:                 
348:                 } UART_FIFO_MODE;
349:                 
350:                 
351:                 // *****************************************************************************
352:                 /* UART Line Control Mode
353:                 
354:                   Summary:
355:                     UART line control mode.
356:                 
357:                   Description:
358:                     This data type defines the supported line control modes for the UART.
359:                 
360:                   Remarks:
361:                     Some of the line-control options are mutually exclusive:
362:                     * Only one of the "DATA_SIZE" options can be used at a time
363:                     * Only one of the "PARITY" options can be used at a time
364:                     * Only one of the "STOP_BITS" options can be used at a time
365:                 
366:                     The caller should not rely on the specific numbers assigned to any of these
367:                     values as they may change from one processor ot the next.
368:                 */
369:                 
370:                 typedef enum
371:                 {
372:                     // Sets the data transfer size to 8-bits per frame.
373:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
374:                 
375:                     // Sets the data transfer size to 9-bits per frame.
376:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
377:                 
378:                     // Enables parity bit generation for odd parity.
379:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
380:                 
381:                     // Enables parity bit generation for even parity.
382:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
383:                 
384:                     // Disables parity bit generation.
385:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
386:                 
387:                     // Enables generation of 2 stop bits per frame.
388:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
389:                 
390:                     // Enables generation of 1 stop bit per frame (default).
391:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
392:                 
393:                 } UART_LINE_CONTROL_MODE;
394:                 
395:                 
396:                 // *****************************************************************************
397:                 /* UART Line Status Flags
398:                 
399:                   Summary:
400:                     UART line-status bitmask flags.
401:                 
402:                   Description:
403:                     This enumeration defines the UART line-status bits.  These values are
404:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
405:                 
406:                   Remarks:
407:                     The caller should not rely on the specific numbers assigned to any of these
408:                     values as they may change from one processor ot the next.
409:                 */
410:                 
411:                 typedef enum
412:                 {
413:                     // The transmitter is able to accept data to transmit.
414:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
415:                 
416:                     // The transmitter is empty (no data is available to transmit).
417:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
418:                 
419:                     // The receiver is currently idle.
420:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
421:                 
422:                     // A received data parity error was detected.
423:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
424:                 
425:                     // Data was received that violated the framing protocol (the data word did
426:                     // not start or stop at the appropriate place).  Note:  A break condition
427:                     // will always indicate a framing error.
428:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
429:                 
430:                     // The UART has received more data than it can buffer.  Data has been lost.
431:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
432:                 
433:                     // UART data has been received and is avaiable in the FIFO.
434:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
435:                 
436:                 } UART_LINE_STATUS;
437:                 
438:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
439:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
440:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
441:                 
442:                 
443:                 
444:                 // *****************************************************************************
445:                 /* UART Data
446:                 
447:                   Summary:
448:                     UART data.
449:                 
450:                   Description:
451:                     This data type defines the supported data sizes for the UART.
452:                 */
453:                 
454:                 typedef union
455:                 {
456:                     // 8-bit data
457:                     struct
458:                     {
459:                         UINT16  data8bit    : 8;
460:                     };
461:                 
462:                     // 9-bit data
463:                     struct
464:                     {
465:                         UINT16  data9bit    : 9;
466:                     };
467:                 
468:                     UINT16 __data;
469:                 } UART_DATA;
470:                 
471:                 
472:                 // *****************************************************************************
473:                 // *****************************************************************************
474:                 // Section: UART Peripheral Library Interface Routines
475:                 // *****************************************************************************
476:                 // *****************************************************************************
477:                 
478:                 
479:                 /*******************************************************************************
480:                   Function:
481:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
482:                 
483:                   Summary:
484:                     Enables or disables the given UART module in the desired mode.
485:                 
486:                   Description:
487:                     This routine enables or disables the given UART module in the desired mode.
488:                 
489:                   Precondition:
490:                     The UART module should be appropriately configured before being enabled.
491:                 
492:                   Parameters:
493:                     id    - Identifies the desired UART module.
494:                 
495:                     mode  - Identifies the desired mode of UART operation.
496:                 
497:                   Returns:
498:                     None
499:                 
500:                   Example:
501:                     <code>
502:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
503:                     </code>
504:                 
505:                   Remarks:
506:                     Enabling UART transmissions will immediately cause a TX interrupt to
507:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
508:                     was pre-loaded with data.
509:                   *****************************************************************************/
510:                 
511:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
512:                 
513:                 
514:                 /*******************************************************************************
515:                   Function:
516:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
517:                 
518:                   Summary:
519:                     UART module configuration routine.
520:                 
521:                   Description:
522:                     This routine allows the caller to configure various features of the UART
523:                     module for desired operation.
524:                 
525:                   Precondition:
526:                     None
527:                 
528:                   Parameters:
529:                     id      - Identifies the desired UART module.
530:                 
531:                     flags   - Bit-wise OR of the desired module configuration settings.
532:                 
533:                   Returns:
534:                     None
535:                 
536:                   Example:
537:                     <code>
538:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
539:                     </code>
540:                 
541:                   Remarks:
542:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
543:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
544:                     of these values will result in a value that is not explicitly defined in
545:                     the enumeration.
546:                   *****************************************************************************/
547:                 
548:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
549:                 
550:                 
551:                 /*******************************************************************************
552:                   Function:
553:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
554:                 
555:                   Summary:
556:                     Controls UART module TX and RX FIFO operation.
557:                 
558:                   Description:
559:                     This routine allows the caller to configure when interrupts occur relative
560:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
561:                     or empty the FIFOs are).
562:                 
563:                   Precondition:
564:                     None
565:                 
566:                   Parameters:
567:                     id      - Identifies the desired UART module.
568:                 
569:                     mode    - Bit-wise OR of the desired FIFO mode values.
570:                 
571:                   Returns:
572:                     None
573:                 
574:                   Example:
575:                     <code>
576:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
577:                     </code>
578:                 
579:                   Remarks:
580:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
581:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
582:                     of these values will result in a value that is not explicitly defined in
583:                     the enumeration.
584:                   *****************************************************************************/
585:                 
586:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
587:                 
588:                 
589:                 /*******************************************************************************
590:                   Function:
591:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
592:                 
593:                   Summary:
594:                     Routine to set the UART module's desired data data rate.
595:                 
596:                   Description:
597:                     This routine allows the caller to set the desired data rate for the UART.
598:                 
599:                   Precondition:
600:                     The source clock's frequency must be operating at the frequency passed in the
601:                     "sourceClock" parameter.
602:                 
603:                   Parameters:
604:                     id          - Identifies the desired UART module.
605:                 
606:                     sourceClock - Frequency (Hz) of the source clock being provided to the
607:                                   UART module.
608:                 
609:                     dataRate     - Desired data rate (bits per second).
610:                 
611:                   Returns:
612:                     Actual bit rate selected
613:                 
614:                   Example:
615:                     <code>
616:                 	#define PERIPHERAL_CLOCK    10000000
617:                 	#define DESIRED_DATA_RATE   19200
618:                 	
619:                 	UINT32    actualDataRate;
620:                 
621:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
622:                     </code>
623:                 
624:                   Remarks:
625:                     Actual data rate selected may be slightly different than the data rate
626:                     requested due to truncation error.
627:                 
628:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
629:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
630:                     the maximum data rate is sourceClock/4.
631:                   *****************************************************************************/
632:                 
633:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
634:                 
635:                 
636:                 /*******************************************************************************
637:                   Function:
638:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
639:                 
640:                   Summary:
641:                     Routine to get the UART module's current data data rate.
642:                 
643:                   Description:
644:                     This routine allows the caller to get the current data rate for the UART module.
645:                 
646:                   Precondition:
647:                     The source clock's frequency must be operating at the frequency passed in the
648:                     "sourceClock" parameter.
649:                 
650:                   Parameters:
651:                     id          - Identifies the desired UART module.
652:                 
653:                     sourceClock - Frequency (Hz) of the source clock being provided to the
654:                                   UART module.
655:                 
656:                   Returns:
657:                     The UART's current data rate (bits per second).
658:                 
659:                   Example:
660:                     <code>
661:                 	#define PERIPHERAL_CLOCK    10000000
662:                 	
663:                 	UINT32    currentDataRate;
664:                 
665:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
666:                     </code>
667:                 
668:                   Remarks:
669:                     The current (actual) data rate returned may be slightly different than bit
670:                     rate requested due to truncation error.
671:                   *****************************************************************************/
672:                 
673:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
674:                 
675:                 
676:                 /*******************************************************************************
677:                   Function:
678:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
679:                 
680:                   Summary:
681:                     Routine to set the UART module's desired line control parameters.
682:                 
683:                   Description:
684:                     This routine allows the caller to select the desired size of the UART data
685:                     frame, the generation of parity and framing parameters (collectively
686:                     referred to as the "line control" mode).
687:                 
688:                   Precondition:
689:                 
690:                   Parameters:
691:                     id      - Identifies the desired UART module.
692:                 
693:                     mode    - This is a bit-wise OR of the desired line control mode flags.
694:                 
695:                   Returns:
696:                     None
697:                 
698:                   Example:
699:                     <code>
700:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
701:                     </code>
702:                 
703:                   Remarks:
704:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
705:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
706:                     of these values will result in a value that is not explicitly defined in
707:                     the enumeration.
708:                   *****************************************************************************/
709:                 
710:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
711:                 
712:                 
713:                 /*******************************************************************************
714:                   Function:
715:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
716:                 
717:                   Summary:
718:                     Provides current UART line status.
719:                 
720:                   Description:
721:                     This routine allows the caller to get the current line status of the UART,
722:                     indicating the current state of the transmitter and receiver buffers, and
723:                     if any errors have occurred.
724:                 
725:                   Precondition:
726:                     None
727:                 
728:                   Parameters:
729:                     id      - Identifies the desired UART module.
730:                 
731:                   Returns:
732:                     A bit-wise OR of the current line status flags.
733:                 
734:                   Example:
735:                     <code>
736:                     UART_LINE_STATUS lineStatus;
737:                 	
738:                 	lineStatus = UARTGetLineStatus(UART1);
739:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
740:                     {
741:                         // Handle receiver error
742:                     }
743:                     </code>
744:                 
745:                   Remarks:
746:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
747:                     status flag.
748:                 
749:                     The receiver line status flags are only valid when data has been received
750:                     and for the data at the top of the RX FIFO.
751:                 
752:                     Note that the bitmask resulting from the bit-wise OR of these values will
753:                     result in a value that is not explicitly defined in the enumeration.
754:                   *****************************************************************************/
755:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
756:                 {
757:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
758:                 }
759:                 
760:                 
761:                 /*******************************************************************************
762:                   Function:
763:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
764:                 
765:                   Summary:
766:                     Routine to detect if the transmitter is ready to accept data to transmit.
767:                 
768:                   Description:
769:                     This routine determines if the transmitter is ready to accept more data to
770:                     be transmitted.
771:                 
772:                   Precondition:
773:                     The UART module should have been appropriately configured and enabled.
774:                 
775:                   Parameters:
776:                     id      - Identifies the desired UART module.
777:                 
778:                   Returns:
779:                     Boolean identifying whether or not the transmitter is ready:
780:                     * TRUE    - If the transmitter is ready to accept more data
781:                     * FALSE   - If the transmitter is not ready to accept more data
782:                 
783:                   Example:
784:                     <code>
785:                     unsigned char data;
786:                 	
787:                 	data = 'a';
788:                 	
789:                 	if (UARTTransmitterIsReady(UART1))
790:                     {
791:                         UARTSendDataByte(UART1, data);
792:                     }
793:                     </code>
794:                 
795:                   Remarks:
796:                   *****************************************************************************/
797:                 
798:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
799:                 {
800:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D0086EC  00042080   SLL A0, A0, 2
9D0086F0  3C029D01   LUI V0, -25343
9D0086F4  2442ADCC   ADDIU V0, V0, -21044
9D0086F8  00822021   ADDU A0, A0, V0
9D0086FC  8C830000   LW V1, 0(A0)
9D008700  8C620010   LW V0, 16(V1)
9D008704  30420200   ANDI V0, V0, 512
9D0087D4  3C029D01   LUI V0, -25343
9D0087D8  2442ADCC   ADDIU V0, V0, -21044
9D0087DC  00621021   ADDU V0, V1, V0
9D0087E0  8C430000   LW V1, 0(V0)
9D0087E4  8C620010   LW V0, 16(V1)
9D0087E8  30420200   ANDI V0, V0, 512
801:                 }
802:                 
803:                 
804:                 /*******************************************************************************
805:                   Function:
806:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
807:                 
808:                   Summary:
809:                     Routine to send a byte of data.
810:                 
811:                   Description:
812:                     This routine allows the caller to send a byte of data.
813:                 
814:                   Precondition:
815:                     The UART should have been appropriately configured.  The configuration must
816:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
817:                     have been ready, although not necessarily enabled yet.
818:                 
819:                   Parameters:
820:                     id      - Identifies the desired UART module.
821:                 
822:                     data    - Data byte to be sent.
823:                 
824:                   Returns:
825:                     None
826:                 
827:                   Example:
828:                     <code>
829:                 	unsigned char data;
830:                 	
831:                 	data = 'a';
832:                 	
833:                     if (UARTTransmitterIsReady(UART1))
834:                     {
835:                         UARTSendDataByte(UART1, data);
836:                     }
837:                     </code>
838:                 
839:                   Remarks:
840:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
841:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
842:                     data.
843:                   *****************************************************************************/
844:                 
845:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
846:                 {
847:                     uartReg[id]->tx.reg = data;
9D008710  30A500FF   ANDI A1, A1, 255
9D008714  AC650020   SW A1, 32(V1)
9D0087F8  30C600FF   ANDI A2, A2, 255
9D0087FC  AC660020   SW A2, 32(V1)
848:                 }
849:                 
850:                 
851:                 /*******************************************************************************
852:                   Function:
853:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
854:                 
855:                   Summary:
856:                     Routine to send data through the UART.
857:                 
858:                   Description:
859:                     This routine allows the caller to send data of any permitted size through
860:                     the UART.
861:                 
862:                   Precondition:
863:                     The UART module should have been appropriately configured.  The configuration must
864:                     have been for desired data size.  The transmitter must have been ready,
865:                     although not necessarily enabled yet.
866:                 
867:                   Parameters:
868:                     id      - Identifies the desired UART module.
869:                 
870:                     data    - Data to be sent.
871:                 
872:                   Returns:
873:                     None
874:                 
875:                   Example:
876:                     <code>
877:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
878:                 	
879:                 	if (UARTTransmitterIsReady(UART1))
880:                     {
881:                         UARTSendData(UART1, data);
882:                     }
883:                     </code>
884:                 
885:                   Remarks:
886:                     Size of the data word size depends on the current configuration (see
887:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
888:                   *****************************************************************************/
889:                 
890:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
891:                 {
892:                     uartReg[id]->tx.reg = data.__data;
893:                 }
894:                 
895:                 /*******************************************************************************
896:                   Function:
897:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
898:                 
899:                   Summary:
900:                     Routine to detect if the UART module has finshed transmitting the most recent
901:                     data.
902:                 
903:                   Description:
904:                     This routine determines if the transmitter has finished sending all
905:                     available data.
906:                 
907:                   Preconditions:
908:                     The UART module should have been appropriately configured and enabled and data
909:                     sent to the UART TX buffer.
910:                 
911:                   Parameters:
912:                     id      - Identifies the desired UART module.
913:                 
914:                   Returns:
915:                     Boolean identifying if the transmission has completed:
916:                     * TRUE    - If the transmitter has completed sending the data
917:                     * FALSE   - If the transmitter is still busy sending the data
918:                 
919:                   Example:
920:                     <code>
921:                 	if (UARTTransmissionHasCompleted(UART1))
922:                     {
923:                         // Perform any tasks necessary when all data has been sent
924:                     }
925:                     </code>
926:                 
927:                   Remarks:
928:                   *****************************************************************************/
929:                 
930:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
931:                 {
932:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
9D00880C  00042080   SLL A0, A0, 2
9D008810  3C029D01   LUI V0, -25343
9D008814  2442ADCC   ADDIU V0, V0, -21044
9D008818  00822021   ADDU A0, A0, V0
9D00881C  8C830000   LW V1, 0(A0)
9D008820  8C620010   LW V0, 16(V1)
9D008824  30420100   ANDI V0, V0, 256
933:                 }
934:                 
935:                 
936:                 /*******************************************************************************
937:                   Function:
938:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
939:                 
940:                   Summary:
941:                     Routine to detect if the receiver has data available.
942:                 
943:                   Description:
944:                     This routine determines if the receiver has data available to be read.
945:                 
946:                   Precondition:
947:                     The UART module must have been configured appropriately and enabled. A complete
948:                     data frame must have been sent to the UART before it will return a TRUE.
949:                 
950:                   Parameters:
951:                     id      - Identifies the desired UART module.
952:                 
953:                   Returns:
954:                     Boolean identifying whether or not data is available:
955:                     * TRUE    - If the receiver has data available
956:                     * FALSE   - If the receiver does not have data availble
957:                 
958:                   Example:
959:                     <code>
960:                     UART_DATA data;
961:                 	
962:                 	if (UARTReceivedDataIsAvailable(UART1))
963:                     {
964:                         data = UARTGetData(UART1);
965:                     }
966:                     </code>
967:                 
968:                   Remarks:
969:                     This routine provides the same information as the UART_DATA_READY line
970:                     status flag.
971:                   *****************************************************************************/
972:                 
973:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
974:                 {
975:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
9D0086B4  00042080   SLL A0, A0, 2
9D0086B8  3C029D01   LUI V0, -25343
9D0086BC  2442ADCC   ADDIU V0, V0, -21044
9D0086C0  00822021   ADDU A0, A0, V0
9D0086C4  8C830000   LW V1, 0(A0)
9D0086C8  8C640010   LW A0, 16(V1)
9D0086CC  30840001   ANDI A0, A0, 1
9D00873C  00048080   SLL S0, A0, 2
9D008740  3C029D01   LUI V0, -25343
9D008744  2442ADCC   ADDIU V0, V0, -21044
9D008748  02028021   ADDU S0, S0, V0
9D00874C  8E030000   LW V1, 0(S0)
9D008750  8C620010   LW V0, 16(V1)
9D008754  30420001   ANDI V0, V0, 1
9D008774  3C029D01   LUI V0, -25343
9D008778  2442ADCC   ADDIU V0, V0, -21044
9D008784  8C430010   LW V1, 16(V0)
9D008788  30630001   ANDI V1, V1, 1
9D008868  00041080   SLL V0, A0, 2
9D00886C  3C129D01   LUI S2, -25343
9D008870  2652ADCC   ADDIU S2, S2, -21044
9D008874  00529021   ADDU S2, V0, S2
9D008880  8C430010   LW V1, 16(V0)
9D008884  30630001   ANDI V1, V1, 1
9D008950  00042080   SLL A0, A0, 2
9D008954  3C029D01   LUI V0, -25343
9D008958  2442ADCC   ADDIU V0, V0, -21044
9D00895C  00822021   ADDU A0, A0, V0
9D008960  8C830000   LW V1, 0(A0)
9D008964  8C640010   LW A0, 16(V1)
9D008968  30840001   ANDI A0, A0, 1
976:                 }
977:                 
978:                 
979:                 /*******************************************************************************
980:                   Function:
981:                     BYTE UARTGetDataByte ( UART_MODULE id )
982:                 
983:                   Summary:
984:                     Routine to get a byte of data received by the UART.
985:                 
986:                   Description:
987:                     This routine allows the caller to read a byte of data received by the UART.
988:                 
989:                   Precondition:
990:                     The UART module must have been appropriately configured, the configuration must
991:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
992:                     been enabled.  Also, a complete data frame must have been received by the UART.
993:                 
994:                   Parameters:
995:                     id      - Identifies the desired UART module.
996:                 
997:                   Returns:
998:                     A byte of data received by the UART.
999:                 
1000:                  Example:
1001:                    <code>
1002:                    unsigned char data;
1003:                	
1004:                	if (UARTReceivedDataIsAvailable(UART1))
1005:                    {
1006:                        data = UARTGetDataByte(UART1);
1007:                    }
1008:                    </code>
1009:                
1010:                  Remarks:
1011:                    This routine is optimized for receiving 8-bit data through the UART.
1012:                  *****************************************************************************/
1013:                
1014:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1015:                {
1016:                    return (BYTE)uartReg[id]->rx.reg;
9D0086D8  8C620030   LW V0, 48(V1)
9D008760  8C620030   LW V0, 48(V1)
9D008794  8C420030   LW V0, 48(V0)
9D008890  8C450030   LW A1, 48(V0)
9D008974  8C630030   LW V1, 48(V1)
1017:                }
1018:                
1019:                
1020:                /*******************************************************************************
1021:                  Function:
1022:                    UART_DATA UARTGetData ( UART_MODULE id )
1023:                
1024:                  Summary:
1025:                    Routine to get data received by the UART.
1026:                
1027:                  Description:
1028:                    This routine allows the caller to read a data word received by the UART.
1029:                
1030:                  Precondition:
1031:                    The module must have been appropriately configured, the UART module must have been
1032:                    enabled, and a complete data frame must have been received by the UART.
1033:                
1034:                  Parameters:
1035:                    id      - Identifies the desired UART module.
1036:                
1037:                  Returns:
1038:                    Data received by the UART.
1039:                
1040:                  Example:
1041:                    <code>
1042:                    UART_DATA data;
1043:                	
1044:                	if (UARTReceivedDataIsAvailable(UART1))
1045:                    {
1046:                        data = UARTGetData(UART1);
1047:                    }
1048:                    </code>
1049:                
1050:                  Remarks:
1051:                    Size of the data word depends on the current configuration (see
1052:                    UARTSetLineControl).
1053:                  *****************************************************************************/
1054:                
1055:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1056:                {
1057:                    UART_DATA data;
1058:                
1059:                    data.__data = uartReg[id]->rx.reg;
1060:                
1061:                    return data;
1062:                }
1063:                
1064:                
1065:                /*******************************************************************************
1066:                  Function:
1067:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1068:                
1069:                  Summary:
1070:                    Routine to program the address for which the UART module may watch.
1071:                
1072:                  Description:
1073:                    This routine programs the 8-bit address for which the module may watch.
1074:                
1075:                  Precondition:
1076:                    None
1077:                
1078:                  Parameters:
1079:                    id      - Identifies the desired UART module.
1080:                
1081:                    address - 8-bit address for which the module will watch.
1082:                
1083:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1084:                              * TRUE - Enable address watch mode
1085:                              * FALSE - Disable address watch mode
1086:                
1087:                  Returns:
1088:                    None.
1089:                
1090:                  Example:
1091:                    <code>
1092:                    #define SLAVE_ADDRESS  0x42
1093:                	
1094:                	UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1095:                    </code>
1096:                
1097:                  Remarks:
1098:                    The module can be placed into a mode where it will ignore all data received
1099:                    until it identifies the programmed adress.  After the programmed address
1100:                    has been identified, it will begin receiving data normally.  This mode is
1101:                    particularly useful for supporting the IEEE-485 protocol.
1102:                  *****************************************************************************/
1103:                
1104:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1105:                
1106:                
1107:                /*******************************************************************************
1108:                  Function:
1109:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1110:                
1111:                  Summary:
1112:                    Routine to enable or disable recognition of the programmed address byte.
1113:                
1114:                  Description:
1115:                    This routine can enable or disable the "address watch" mode.  In this mode,
1116:                    the UART module will ignore all data until it recognizes the programmed address.
1117:                
1118:                  Precondition:
1119:                    UART should have already been enabled and set with watch address.
1120:                
1121:                  Parameters:
1122:                    id      - Identifies the desired UART module.
1123:                
1124:                    watch   - Determines if the "address watch" mode will be enabled or
1125:                              disabled.
1126:                              * TRUE - Enable address watch mode
1127:                              * FALSE - Disable address watch mode
1128:                
1129:                  Returns:
1130:                    None.
1131:                
1132:                  Example:
1133:                    <code>
1134:                    #define SLAVE_ADDRESS 0x42
1135:                	
1136:                	// Set the address, but don't enable the watch until later,
1137:                	// UART continues to receive data normally
1138:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1139:                
1140:                    // ...
1141:                
1142:                    // Now begin to ignore all UART traffic until we are addressed
1143:                    UARTWatchForAddress(UART1, TRUE);
1144:                    </code>
1145:                
1146:                  Remarks:
1147:                    The UART module can be placed into a mode where it will ignore all data received
1148:                    until it identifies the programmed address.  After the programmed address
1149:                    has been identified, it will begin receiving data normally.  This mode is
1150:                    particularly useful for supporting the IEEE-485 protocol.
1151:                  *****************************************************************************/
1152:                
1153:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1154:                
1155:                
1156:                /*******************************************************************************
1157:                  Function:
1158:                    void UARTSendBreak ( UART_MODULE id )
1159:                
1160:                  Summary:
1161:                    Routine to send a break signal from the UART.
1162:                
1163:                  Description:
1164:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1165:                
1166:                  Precondition:
1167:                    The UART should have been appropriately configured.  The transmitter should
1168:                    be idle, although not necessarily enabled yet.
1169:                
1170:                  Parameters:
1171:                    id      - Identifies the desired UART module.
1172:                
1173:                  Returns:
1174:                    None
1175:                
1176:                  Example:
1177:                    <code>
1178:                    if (UARTTransmissionHasCompleted(UART1))
1179:                    {
1180:                        UARTSendBreak(UART1);
1181:                    }
1182:                    </code>
1183:                
1184:                  Remarks:
1185:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1186:                    data may be pre-loaded into the FIFO and it will be send immediately
1187:                    following the break signal.
1188:                  *****************************************************************************/
1189:                
1190:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1191:                {
1192:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1193:                }
1194:                
1195:                
1196:                /*******************************************************************************
1197:                  Function:
1198:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1199:                
1200:                  Summary:
1201:                    Routine to automatically determine the data rate (bits-per-second) of an
1202:                    external transmitter to the UART.
1203:                
1204:                  Description:
1205:                    This routine initiates the process of automatically determining the data
1206:                    rate (bits-per-second) of an external transmitter to the UART.
1207:                
1208:                  Precondition:
1209:                    The UART should have been appropriately configured.  The transmitter should
1210:                    be idle, although not necessarily enabled yet.
1211:                
1212:                  Parameters:
1213:                    id      - Identifies the desired UART module.
1214:                
1215:                  Returns:
1216:                    None
1217:                
1218:                  Example:
1219:                    <code>
1220:                	// See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1221:                	// methods to detect a Break.
1222:                	
1223:                    if (breakDetected && useAutoRateDetect) 
1224:                    {
1225:                        UARTStartAutoDataRateDetect (UART1);
1226:                    }
1227:                    </code>
1228:                
1229:                  Remarks:
1230:                    The UART module begins measuring the data rate beginning at the next start
1231:                    bit.  The external transmitter should send an alternating pattern (0x55)
1232:                    for the byte to be measured for an effective rate detection.  To ensure
1233:                    an effective measurement sequence, this can be done immediately following
1234:                    a break reception. It is important that this UART module is not
1235:                	transmitting data while it is trying to detect RX baud rate, see the 
1236:                	"PIC32 Family Reference Manual, Sect. 21 UART".
1237:                  *****************************************************************************/
1238:                
1239:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1240:                {
1241:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1242:                }
1243:                
1244:                
1245:                
1246:                /*******************************************************************************
1247:                  Function:
1248:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1249:                
1250:                  Summary:
1251:                    Routine to identify when automatic data rate detection has completed.
1252:                
1253:                  Description:
1254:                    This routine checks to see if automatic data rate detection has completed.
1255:                
1256:                  Precondition:
1257:                    Automatic rate detection should have been previously started.
1258:                
1259:                  Parameters:
1260:                    id      - Identifies the desired UART module.
1261:                
1262:                  Returns:
1263:                    * TRUE    - Indicates that automatic rate detection has completed.
1264:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1265:                
1266:                  Example:
1267:                    <code>
1268:                    #define PERIPHERAL_CLOCK    10000000
1269:                	
1270:                	UINT32 currentRate;
1271:                	
1272:                	if (UARTDataRateDetected(UART1))
1273:                    {
1274:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1275:                    }
1276:                    </code>
1277:                
1278:                  Remarks:
1279:                    This routine returns FALSE after automatic rate detection
1280:                    has been started but before rate is detectdd, it will return TRUE
1281:                	at any other time.
1282:                  *****************************************************************************/
1283:                
1284:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1285:                {
1286:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1287:                }
1288:                
1289:                #ifdef __cplusplus
1290:                  }
1291:                #endif
1292:                
1293:                #endif // _UART_h_
1294:                
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
118:                         pb_clock >>= 1;
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
170:                     {
171:                         wait_states++;
172:                         sys_clock -= FLASH_SPEED_HZ;
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
176:                     mCheConfigure(wait_states);
177:                     INTRestoreInterrupts(int_status);
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
227:                     {
228:                         wait_states++;
229:                         sys_clock -= FLASH_SPEED_HZ;
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
233:                     mCheConfigure(wait_states);
234:                     INTRestoreInterrupts(int_status);
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
279:                 
280:                     int_status=INTDisableInterrupts();
281:                 
282:                     mBMXDisableDRMWaitState();
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
286:                     cache_status |= CHE_CONF_PF_ALL;
287:                     mCheConfigure(cache_status);
288:                     CheKseg0CacheOn();
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
9D008FE8  0F402B71   JAL INTDisableInterrupts
9D008FEC  00000000   NOP
342:                 
343:                     mBMXDisableDRMWaitState();
9D008FF0  24040040   ADDIU A0, ZERO, 64
9D008FF4  3C03BF88   LUI V1, -16504
9D008FF8  AC642004   SW A0, 8196(V1)
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
358:                     {
359:                         cache_status = mCheGetCon();
360:                         cache_status |= CHE_CONF_PF_ALL;
361:                         mCheConfigure(cache_status);
362:                         CheKseg0CacheOn();
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
367:                     pb_clk >>= OSCCONbits.PBDIV;
9D008FFC  3C03BF81   LUI V1, -16511
9D009000  8C63F000   LW V1, -4096(V1)
368:                 
369:                     INTRestoreInterrupts(int_status);
9D009004  0F402B52   JAL INTRestoreInterrupts
9D009008  00402021   ADDU A0, V0, ZERO
370:                 
371:                     return pb_clk;
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/vpc-32.c  -----------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /* 
20:                   * File:   vpc-32.c
21:                   * Author: Jacques Deschênes
22:                   *
23:                   * Created on 26 août 2013, 07:38
24:                   */
25:                  
26:                  #include <stdio.h>
27:                  #include <stdlib.h>
28:                  #include <plib.h>
29:                  
30:                  
31:                  #include "hardware/HardwareProfile.h"
32:                  #include "hardware/ntsc.h"
33:                  #include "hardware/serial_comm.h"
34:                  #include "hardware/keyboard.h"
35:                  #include "hardware/Pinguino/diskio.h"
36:                  #include "console.h"
37:                  #include "hardware/Pinguino/ff.h"
38:                  #include "vpForth/opcodes.h"
39:                  #include "vpForth/vpForth.h"
40:                  
41:                  // PIC32MX150F128B Configuration Bit Settings
42:                  #include <xc.h>
43:                  
44:                  // DEVCFG3
45:                  // USERID = No Setting
46:                  #pragma config PMDL1WAY = OFF           // permet plusieurs configurations des périphériques.
47:                  #pragma config IOL1WAY = OFF            // permet plusieurs configuration des broches.
48:                  
49:                  // DEVCFG2
50:                  #pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
51:                  #if SYSCLK==40000000L
52:                  #pragma config FPLLMUL = MUL_16         // SYSCLK=40Mhz
53:                  #else
54:                  #pragma config FPLLMUL = MUL_15          // PLL Multiplier (15x Multiplier) SYSCLK=37,5Mhz
55:                  #endif
56:                  #pragma config FPLLODIV = DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)
57:                  
58:                  // DEVCFG1
59:                  #pragma config FNOSC = PRIPLL           // Oscillator Selection Bits (Primary Osc w/PLL (XT+,HS+,EC+PLL))
60:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
61:                  #pragma config IESO = OFF               // Internal/External Switch Over (Disabled)
62:                  #pragma config POSCMOD = HS             // Primary Oscillator Configuration (XT osc mode)
63:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
64:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
65:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
66:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
67:                  
68:                  // DEVCFG0
69:                  #pragma config JTAGEN = OFF             // JTAG Enable (JTAG Disabled)
70:                  #pragma config ICESEL = ICS_PGx1        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
71:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
72:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
73:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
74:                  
75:                  
76:                  
77:                  const char *msg1=" test video ntsc\r";
78:                  const char *msg2="01234567890123456789012345678901234567890123456789012"; // 53 caractères par ligne
79:                  
80:                  
81:                  void test_pattern(void){
9D009764  27BDFFE8   ADDIU SP, SP, -24
9D009768  AFBF0014   SW RA, 20(SP)
9D00976C  3C06A000   LUI A2, -24576
9D009770  24C60080   ADDIU A2, A2, 128
9D009774  00C03821   ADDU A3, A2, ZERO
9D009778  24C523F0   ADDIU A1, A2, 9200
9D00977C  00C01021   ADDU V0, A2, ZERO
9D00979C  24E30028   ADDIU V1, A3, 40
9D0097C0  24E71AE8   ADDIU A3, A3, 6888
82:                      int i,j;
83:                      for (i=0;i<VRES;i++){
9D009794  5445FFFD   BNEL V0, A1, 0x9D00978C
9D009798  AC440000   SW A0, 0(V0)
84:                          video_bmp[i][0]=0x80000000;
9D009780  3C048000   LUI A0, -32768
9D009788  AC440000   SW A0, 0(V0)
85:                          video_bmp[i][HRES/32-1]=1;
9D009784  24030001   ADDIU V1, ZERO, 1
9D00978C  AC430024   SW V1, 36(V0)
9D009790  24420028   ADDIU V0, V0, 40
86:                      }
87:                      for (i=0;i<HRES/32;i++){
9D0097B0  54C3FFFD   BNEL A2, V1, 0x9D0097A8
9D0097B4  ACC20000   SW V0, 0(A2)
9D0097B8  3C02A000   LUI V0, -24576
9D0097BC  24420970   ADDIU V0, V0, 2416
88:                          video_bmp[0][i]=0xffffffff;
9D0097A0  2402FFFF   ADDIU V0, ZERO, -1
9D0097A4  ACC20000   SW V0, 0(A2)
89:                          video_bmp[VRES-1][i]=0xffffffff;
9D0097A8  ACC223C8   SW V0, 9160(A2)
9D0097AC  24C60004   ADDIU A2, A2, 4
90:                      }
91:                      for (i=VRES/4;i<VRES/2+VRES/4;i++){
9D0097F8  5447FFFB   BNEL V0, A3, 0x9D0097E8
9D0097FC  AC460000   SW A2, 0(V0)
92:                          video_bmp[i][2]=0xFF00FF00;
9D0097C4  3C06FF00   LUI A2, -256
9D0097C8  34C6FF00   ORI A2, A2, -256
9D0097E4  AC460000   SW A2, 0(V0)
93:                          video_bmp[i][3]=0xF0F0F0F0;
9D0097CC  3C05F0F0   LUI A1, -3856
9D0097D0  34A5F0F0   ORI A1, A1, -3856
9D0097E8  AC450004   SW A1, 4(V0)
94:                          video_bmp[i][4]=0xcccccccc;
9D0097D4  3C04CCCC   LUI A0, -13108
9D0097D8  3484CCCC   ORI A0, A0, -13108
9D0097EC  AC440008   SW A0, 8(V0)
95:                          video_bmp[i][5]=0xaaaaaaaa;
9D0097DC  3C03AAAA   LUI V1, -21846
9D0097E0  3463AAAA   ORI V1, V1, -21846
9D0097F0  AC43000C   SW V1, 12(V0)
9D0097F4  24420028   ADDIU V0, V0, 40
96:                      }//i
97:                      print(LOCAL_CON,msg1);
9D009800  00002021   ADDU A0, ZERO, ZERO
9D009804  0F401DDD   JAL print
9D009808  8F858014   LW A1, -32748(GP)
98:                      print(LOCAL_CON,msg2);
9D00980C  00002021   ADDU A0, ZERO, ZERO
9D009810  0F401DDD   JAL print
9D009814  8F858018   LW A1, -32744(GP)
99:                  }//test_pattern()
9D009818  8FBF0014   LW RA, 20(SP)
9D00981C  03E00008   JR RA
9D009820  27BD0018   ADDIU SP, SP, 24
100:                 
101:                 
102:                 void main(void) {
9D009824  27BDFFE8   ADDIU SP, SP, -24
9D009828  AFBF0014   SW RA, 20(SP)
103:                     int code;
104:                     short key;
105:                     unsigned char buff[BLK_SIZE];
106:                     int i;
107:                     unsigned int size;
108:                 
109:                     HardwareInit();
9D00982C  0F4023F8   JAL HardwareInit
9D009830  00000000   NOP
110:                     UartInit(STDIO,115200,DEFAULT_LINE_CTRL);
9D009834  24040001   ADDIU A0, ZERO, 1
9D009838  3C050001   LUI A1, 1
9D00983C  34A5C200   ORI A1, A1, -15872
9D009840  0F402190   JAL UartInit
9D009844  00003021   ADDU A2, ZERO, ZERO
111:                     ln_cnt=0;
9D009848  AF808054   SW ZERO, -32684(GP)
112:                     video=0;
9D00984C  AF808050   SW ZERO, -32688(GP)
113:                     test_pattern();
9D009850  0F4025D9   JAL test_pattern
9D009854  00000000   NOP
114:                     UartPrint(STDOUT,"initialisation video\r");
9D009858  24040001   ADDIU A0, ZERO, 1
9D00985C  3C059D01   LUI A1, -25343
9D009860  0F4021F2   JAL UartPrint
9D009864  24A5A15C   ADDIU A1, A1, -24228
115:                     VideoInit();
9D009868  0F402266   JAL VideoInit
9D00986C  00000000   NOP
116:                     delay_ms(500);
9D009870  0F40246D   JAL delay_ms
9D009874  240401F4   ADDIU A0, ZERO, 500
117:                     UartPrint(STDOUT,"initialisation clavier: ");
9D009878  24040001   ADDIU A0, ZERO, 1
9D00987C  3C059D01   LUI A1, -25343
9D009880  0F4021F2   JAL UartPrint
9D009884  24A5A174   ADDIU A1, A1, -24204
118:                     if (KeyboardInit()){
9D009888  0F40191A   JAL KeyboardInit
9D00988C  00000000   NOP
9D009890  10400006   BEQ V0, ZERO, 0x9D0098AC
9D009894  24040001   ADDIU A0, ZERO, 1
119:                         UartPrint(STDOUT,"OK\r");
9D009898  3C059D01   LUI A1, -25343
9D00989C  0F4021F2   JAL UartPrint
9D0098A0  24A5A190   ADDIU A1, A1, -24176
120:                         comm_channel=LOCAL_CON;
9D0098A4  0B402634   J 0x9D0098D0
9D0098A8  A3808038   SB ZERO, -32712(GP)
121:                     }else{
122:                         UartPrint(STDOUT,"erreur clavier\r");
9D0098AC  3C059D01   LUI A1, -25343
9D0098B0  0F4021F2   JAL UartPrint
9D0098B4  24A5A194   ADDIU A1, A1, -24172
123:                         UartPrint(STDOUT,"Utilisation du lien sériel.\r");
9D0098B8  24040001   ADDIU A0, ZERO, 1
9D0098BC  3C059D01   LUI A1, -25343
9D0098C0  0F4021F2   JAL UartPrint
9D0098C4  24A5A1A4   ADDIU A1, A1, -24156
124:                         comm_channel=SERIAL_CON;
9D0098C8  24020001   ADDIU V0, ZERO, 1
9D0098CC  A3828038   SB V0, -32712(GP)
125:                     }
126:                     text_coord_t cpos;
127:                     UartPrint(STDOUT,"initialisation peripherique carte SD.\r");
9D0098D0  24040001   ADDIU A0, ZERO, 1
9D0098D4  3C059D01   LUI A1, -25343
9D0098D8  0F4021F2   JAL UartPrint
9D0098DC  24A5A1C4   ADDIU A1, A1, -24124
128:                     UartPrint(STDOUT,"initialisation carte SD: ");
9D0098E0  24040001   ADDIU A0, ZERO, 1
9D0098E4  3C059D01   LUI A1, -25343
9D0098E8  0F4021F2   JAL UartPrint
9D0098EC  24A5A1EC   ADDIU A1, A1, -24084
129:                     if (!mount(0)){
9D0098F0  0F402341   JAL mount
9D0098F4  00002021   ADDU A0, ZERO, ZERO
9D0098F8  14400005   BNE V0, ZERO, 0x9D009910
9D0098FC  24040001   ADDIU A0, ZERO, 1
130:                         UartPrint(STDOUT,"Echec\r");
9D009900  3C059D01   LUI A1, -25343
9D009904  0F4021F2   JAL UartPrint
9D009908  24A5A208   ADDIU A1, A1, -24056
131:                     }
132:                     UartPrint(STDOUT, "OK\r");
9D00990C  24040001   ADDIU A0, ZERO, 1
9D009910  3C059D01   LUI A1, -25343
9D009914  0F4021F2   JAL UartPrint
9D009918  24A5A190   ADDIU A1, A1, -24176
133:                 //    FIL *fp;
134:                 //    FILINFO *fo;
135:                 //    fp=malloc(sizeof(FIL));
136:                 //    fo=malloc(sizeof(FILINFO));
137:                 //    if (!f_open(fp,"readme.txt",FA_READ)){
138:                 //        f_stat("readme.txt",fo);
139:                 //        if (!f_read(fp,buff,fo->fsize,(UINT*)&i)){
140:                 //            clear_screen();
141:                 //            buff[fo->fsize]=0;
142:                 //            print("file size: ");
143:                 //            print_int(i,10);
144:                 //            put_char('\r');
145:                 //            print(buff);
146:                 //            f_close(fp);
147:                 //            if (i==40){
148:                 //                f_open(fp,"readme.txt",FA_WRITE);
149:                 //                f_lseek(fp,i);
150:                 //                f_write(fp,"test ecriture\r",14,(UINT*)&i);
151:                 //                f_stat("readme.txt",fo);
152:                 //                print("grandeur apres ecriture: ");
153:                 //                print_int(fo->fsize,10);
154:                 //                f_close(fp);
155:                 //            }
156:                 //            free(fp);
157:                 //            free(fo);
158:                 //        }
159:                 //    }
160:                 //    UartPrint(STDOUT,"lecture du registre CSD\r");
161:                 //    clear_screen();
162:                 //    size=disk_ioctl(0,GET_SECTOR_SIZE,buff);
163:                 //    print_int(*(unsigned short *)buff,10);
164:                 //    put_char('\r');
165:                 //    size=disk_ioctl(0,GET_SECTOR_COUNT,buff);
166:                 //    print_int(*(int*)buff,10);
167:                 //    put_char('\r');
168:                 //    size=disk_ioctl(0,GET_BLOCK_SIZE,buff);
169:                 //    print_int(*(int*)buff,10);
170:                 //    put_char('\r');
171:                 //    for (i=511;i;i--){
172:                 //        buff[i]=255;
173:                 //    }
174:                 //    while (1);
175:                 //    delay_ms(2000);
176:                     tone(400,1000);
9D00991C  24040190   ADDIU A0, ZERO, 400
9D009920  0F402948   JAL tone
9D009924  240503E8   ADDIU A1, ZERO, 1000
177:                     UartPrint(STDOUT,"initialisation completee.\r");
9D009928  24040001   ADDIU A0, ZERO, 1
9D00992C  3C059D01   LUI A1, -25343
9D009930  0F4021F2   JAL UartPrint
9D009934  24A5A210   ADDIU A1, A1, -24048
178:                     set_cursor(CR_BLOCK);
9D009938  0F401ED0   JAL set_cursor
9D00993C  24040001   ADDIU A0, ZERO, 1
179:                     clear_screen();
9D009940  0F401DCF   JAL clear_screen
9D009944  00000000   NOP
180:                     shell();
9D009948  0F4025C1   JAL shell
9D00994C  00000000   NOP
181:                 } // main()
9D009950  8FBF0014   LW RA, 20(SP)
9D009954  03E00008   JR RA
9D009958  27BD0018   ADDIU SP, SP, 24
182:                 
183:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/vpForth/vpForth.c  --------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   vpForth.c
21:                   * Author: Jacques Deschênes
22:                   *
23:                   * Created on 6 juin 2013
24:                   */
25:                  
26:                  #include "../hardware/HardwareProfile.h"
27:                  #include "../hardware/serial_comm.h"
28:                  #include "../console.h"
29:                  
30:                  #include "vpForth.h"
31:                  #include "opcodes.h"
32:                  
33:                  #define TIB_SIZE 80
34:                  #define PAD_SIZE 80
35:                  #define USER_NAMES_SIZE 100
36:                  #define XT_NULL 0
37:                  #define COMPILE 1
38:                  #define IMMEDIATE 0
39:                  #define RESERVED 0
40:                  #define CELL_SIZE 4
41:                  #define HASH_BASE 68
42:                  
43:                  
44:                  // data types
45:                  typedef unsigned char BYTE ;
46:                  typedef unsigned short WORD;
47:                  typedef unsigned int name_hash;
48:                  typedef char *code_ptr;
49:                  typedef int(*compfct)();
50:                  
51:                  typedef struct{
52:                      name_hash name;
53:                      code_ptr cfa;
54:                  } dict_entry_t;
55:                  
56:                  
57:                  // variables
58:                  unsigned char ram_code[RAM_SPACE];
59:                  char state=IMMEDIATE;
60:                  int cstack[6]; // pile utilisé par le compilateur (control flow stack)
61:                  char cp=-1; //pointeur pour la pile cstack
62:                  char error=0;
63:                  code_ptr imm_code, mark;
64:                  
65:                  const name_hash vm_tokens[]= { // vm tokens hash
66:                  156436, // BYE
67:                  9629672, // ?KEY
68:                  11525779, // EMIT
69:                  201603, // LIT
70:                  801952535, // FCALL
71:                  229075, // RET
72:                  155956, // BRA
73:                  9588916, // ?BRA
74:                  11576354, // EXEC
75:                  0, // !
76:                  31, // @
77:                  2312, // C!
78:                  2343, // C@
79:                  229803, // RP@
80:                  229772, // RP!
81:                  3363, // R@
82:                  2021, // >R
83:                  3361, // R>
84:                  234427, // SP@
85:                  234396, // SP!
86:                  11234871, // DROP
87:                  165423, // DUP
88:                  15973519, // SWAP
89:                  14711441, // OVER
90:                  10, // +
91:                  12, // -
92:                  9, // *
93:                  14, // /
94:                  206619, // MOD
95:                  1047, // 0<
96:                  151063, // AND
97:                  3177, // OR
98:                  257497, // XOR
99:                  211259, // NOT
100:                 196712, // KEY
101:                 233765, // SFR
102:                 233699, // SET
103:                 740656049, // CLEAR
104:                 188073, // INV
105:                 10892291, // CLIT
106:                 17180931, // WLIT
107:                 885, // ."
108:                 1059157367, // READL
109:                 1058529047, // RCALL
110:                 16298208, // TYPE
111:                 759868776, // DELAY
112:                 9598383, // ?DUP
113:                 696, // +1
114:                 832, // -1
115:                 680, // +!
116:                 374718263, // 2drop
117:                 229755, // rot
118:                 5510767, // 2dup
119:                 206221, // min
120:                 205687, // max
121:                 150262, // abs
122:                 1863, // <<
123:                 2001, // >>
124:                 4608667, // /mod
125:                 652046345, // ?braz
126:                 13, // .
127:                 267015, // zsp
128:                 266947, // zrp
129:                 12432680, // here
130:                 10527660, // base
131:                 28, // =
132:                 1865, // <>
133:                 27, // <
134:                 29, // >
135:                 1864, // <=
136:                 2000, // >=
137:                 866780819, // iemit
138:                 1083997420, // ispace
139:                 1084006818, // ispces
140:                 2361, // cr
141:                 738488102, // cell+
142:                 738488104, // cell-
143:                 } ;
144:                 
145:                 
146:                 // mots systèmes enrigistrés en mémoire flash
147:                 
148:                 const char dots[]={ISPACE,ICLIT,'(',IEMIT,ISPFETCH,IZSP,ISUB,
149:                                    ICLIT,CELL_SIZE,IDIV,IDUP,IDOT,ICLIT,')',IEMIT,ISPACE,
150:                                    ITOR,IZSP,ICELLP,IRFROM,IDUP,IQBRAZ,8,IMINUS1,
151:                                    ITOR,IDUP,IFETCH,IDOT,ISPACE,IBRA, -13,IDDROP,IRET};
152:                 
153:                 const char dotr[]={ISPACE,ICLIT,'(',IEMIT,IRPFETCH,IZRP,ISUB,
154:                                    ICLIT,CELL_SIZE,IDIV,IDUP,IDOT,ICLIT,')',IEMIT,ISPACE,
155:                                    ITOR,IZRP,ICELLP,IRFROM,IDUP,IQBRAZ,8,IMINUS1,
156:                                    ITOR,IDUP,IFETCH,IDOT,ISPACE,IBRA, -13,IDDROP,IRET};
157:                 
158:                 //void print_integer(int n);
159:                 void compile_if();
160:                 void compile_then();
161:                 void compile_else();
162:                 void compile_repeat();
163:                 void compile_again();
164:                 void compile_while();
165:                 void compile_do();
166:                 void compile_loop();
167:                 void compile_ploop();
168:                 void compile_begin();
169:                 void compile_until();
170:                 void compile_var();
171:                 void compile_const();
172:                 int compile_token(int);
173:                 void column();
174:                 void semi_column();
175:                 
176:                 
177:                 dict_entry_t system_dict[]={
178:                     {-25,(code_ptr)column}, // :
179:                     {-26,(code_ptr)semi_column}, // ;
180:                     {-247297, (code_ptr)compile_var}, // var
181:                     {-741642187, (code_ptr)compile_const},  // const
182:                     {-2757, (code_ptr)compile_if}, // if
183:                     {-16218861, (code_ptr)compile_then}, // then
184:                     {-11521820, (code_ptr)compile_else}, // else
185:                     {-15576879, (code_ptr)compile_repeat},  //rept
186:                     {-696303181, (code_ptr)compile_again}, // again
187:                     {-1167045072, (code_ptr)compile_while}, // while
188:                     {-2426, (code_ptr)compile_do}, // do
189:                     {-13736455, (code_ptr)compile_loop}, // loop
190:                     {-227550215, (code_ptr)compile_ploop}, // +loop
191:                     {-717083437, (code_ptr)compile_begin}, // begin
192:                     {-1126219579, (code_ptr)compile_until}, // until
193:                     {934,(code_ptr)dots}, // .s
194:                     {933,(code_ptr)dotr}, // .r
195:                 };
196:                 #define SYSTEM_COUNT 20
197:                 
198:                 
199:                 
200:                 dict_entry_t user_dict[USER_NAMES_SIZE];
201:                 char free_slot=0;
202:                 
203:                 char tib[TIB_SIZE];
204:                 char pad[PAD_SIZE];
205:                 
206:                 code_ptr cip;
207:                 
208:                 char ctib;
209:                 char first, last,current;
210:                 
211:                 
212:                 name_hash hash(){// hash le token courant.
9D004C90  27BDFFE8   ADDIU SP, SP, -24
9D004C94  AFBF0014   SW RA, 20(SP)
9D004CE0  3C08A000   LUI T0, -24576
9D004CE4  250824C0   ADDIU T0, T0, 9408
9D004CE8  01042021   ADDU A0, T0, A0
9D004CEC  25080005   ADDIU T0, T0, 5
9D004CF0  01054021   ADDU T0, T0, A1
213:                     name_hash nh;
214:                     int i;
215:                     char c;
216:                     nh=0;
217:                     print(SERIAL_CON,&tib[first]);
9D004C98  83828074   LB V0, -32652(GP)
9D004C9C  24040001   ADDIU A0, ZERO, 1
9D004CA0  3C05A000   LUI A1, -24576
9D004CA4  24A524C0   ADDIU A1, A1, 9408
9D004CA8  0F401DDD   JAL print
9D004CAC  00A22821   ADDU A1, A1, V0
218:                     for (i=first;i<first+5 && tib[i]!=0;i++){
9D004CB0  83858074   LB A1, -32652(GP)
9D004CB4  24A30005   ADDIU V1, A1, 5
9D004CB8  00A3182A   SLT V1, A1, V1
9D004CBC  10600023   BEQ V1, ZERO, 0x9D004D4C
9D004CC0  00001021   ADDU V0, ZERO, ZERO
9D004CC4  3C02A000   LUI V0, -24576
9D004CC8  244224C0   ADDIU V0, V0, 9408
9D004CCC  00451021   ADDU V0, V0, A1
9D004CD0  80430000   LB V1, 0(V0)
9D004CD4  1060001D   BEQ V1, ZERO, 0x9D004D4C
9D004CD8  00001021   ADDU V0, ZERO, ZERO
9D004CDC  24A40001   ADDIU A0, A1, 1
9D004D38  10880004   BEQ A0, T0, 0x9D004D4C
9D004D3C  00431021   ADDU V0, V0, V1
9D004D40  80830000   LB V1, 0(A0)
9D004D44  1460FFEC   BNE V1, ZERO, 0x9D004CF8
9D004D48  24840001   ADDIU A0, A0, 1
219:                         c = tib[i] & 127;
9D004CF8  3063007F   ANDI V1, V1, 127
220:                         if (c>='a' && c<='z') c -= 32;
9D004CFC  306500FF   ANDI A1, V1, 255
9D004D00  24A6FF9F   ADDIU A2, A1, -97
9D004D04  30C600FF   ANDI A2, A2, 255
9D004D08  2CC6001A   SLTIU A2, A2, 26
9D004D0C  10C00004   BEQ A2, ZERO, 0x9D004D20
9D004D10  2866007B   SLTI A2, V1, 123
9D004D14  24A3FFE0   ADDIU V1, A1, -32
9D004D18  0B40134C   J 0x9D004D30
9D004D1C  7C031C20   SEB V1, V1
221:                         else if (c>'z') c -= 26;
9D004D20  54C00004   BNEL A2, ZERO, 0x9D004D34
9D004D24  70471002   MUL V0, V0, A3
9D004D28  24A3FFE6   ADDIU V1, A1, -26
9D004D2C  7C031C20   SEB V1, V1
222:                         nh *= HASH_BASE;
9D004CF4  24070044   ADDIU A3, ZERO, 68
9D004D30  70471002   MUL V0, V0, A3
223:                         nh += c-33;
9D004D34  2442FFDF   ADDIU V0, V0, -33
224:                     }
225:                     return nh;
226:                 }//hash()
9D004D4C  8FBF0014   LW RA, 20(SP)
9D004D50  03E00008   JR RA
9D004D54  27BD0018   ADDIU SP, SP, 24
227:                 
228:                 void hash2str(name_hash hash, char *name){
9D004D58  27BDFFE0   ADDIU SP, SP, -32
9D004D5C  AFBF001C   SW RA, 28(SP)
9D004DA8  27A80010   ADDIU T0, SP, 16
9D004DAC  01023821   ADDU A3, T0, V0
229:                     int i,d;
230:                     char str[6];
231:                     str[5]=0;
232:                     i=4;
9D004D68  24020004   ADDIU V0, ZERO, 4
233:                     while (hash){
9D004D60  10800019   BEQ A0, ZERO, 0x9D004DC8
9D004D64  A3A00015   SB ZERO, 21(SP)
9D004DB4  1480FFF1   BNE A0, ZERO, 0x9D004D7C
9D004DB8  2443FFFF   ADDIU V1, V0, -1
234:                         d=hash % HASH_BASE;
9D004D6C  24060044   ADDIU A2, ZERO, 68
9D004D80  0086001B   DIVU A0, A2
9D004D84  00C001F4   TEQ A2, ZERO
9D004D88  00001810   MFHI V1, 0
235:                         hash /= HASH_BASE;
9D004D70  3C09F0F0   LUI T1, -3856
9D004D74  0B401360   J 0x9D004D80
9D004D78  3529F0F1   ORI T1, T1, -3855
9D004D8C  00890019   MULTU 0, A0, T1
9D004D90  00005810   MFHI T3, 0
9D004D94  000B2182   SRL A0, T3, 6
236:                         d += 33;
9D004D98  24630021   ADDIU V1, V1, 33
237:                         if (d>='a') d += 26;
9D004D9C  28680061   SLTI T0, V1, 97
9D004DA0  2467001A   ADDIU A3, V1, 26
9D004DA4  00E8180A   MOVZ V1, A3, T0
238:                         str[i--]=d;
9D004D7C  00601021   ADDU V0, V1, ZERO
9D004DB0  A0E30000   SB V1, 0(A3)
239:                     }
240:                     if (i==4) str[4]=33; else i++;
9D004DBC  24040004   ADDIU A0, ZERO, 4
9D004DC0  14640005   BNE V1, A0, 0x9D004DD8
9D004DC4  00A02021   ADDU A0, A1, ZERO
9D004DC8  24020021   ADDIU V0, ZERO, 33
9D004DCC  A3A20014   SB V0, 20(SP)
9D004DD0  24020004   ADDIU V0, ZERO, 4
241:                     strcpy(name,&str[i]);
9D004DD4  00A02021   ADDU A0, A1, ZERO
9D004DD8  27AA0010   ADDIU T2, SP, 16
9D004DDC  0F40274B   JAL 0x9D009D2C
9D004DE0  01422821   ADDU A1, T2, V0
242:                 }//hashs2str()
9D004DE4  8FBF001C   LW RA, 28(SP)
9D004DE8  03E00008   JR RA
9D004DEC  27BD0020   ADDIU SP, SP, 32
243:                 
244:                 
245:                 void upper(){
9D004E04  3C02A000   LUI V0, -24576
9D004E08  244224C0   ADDIU V0, V0, 9408
9D004E0C  00441021   ADDU V0, V0, A0
9D004E30  2464FFFF   ADDIU A0, V1, -1
246:                     int i;
247:                     for (i=first;i<=last;i++) if (tib[i]>='a' && tib[i]<='z') tib[i] -= 32;
9D004DF0  83848074   LB A0, -32652(GP)
9D004DF4  83868060   LB A2, -32672(GP)
9D004DF8  00C4102A   SLT V0, A2, A0
9D004DFC  14400010   BNE V0, ZERO, 0x9D004E40
9D004E00  24830001   ADDIU V1, A0, 1
9D004E10  90440000   LBU A0, 0(V0)
9D004E14  2485FF9F   ADDIU A1, A0, -97
9D004E18  30A500FF   ANDI A1, A1, 255
9D004E1C  2CA5001A   SLTIU A1, A1, 26
9D004E20  10A00003   BEQ A1, ZERO, 0x9D004E30
9D004E24  24630001   ADDIU V1, V1, 1
9D004E28  2484FFE0   ADDIU A0, A0, -32
9D004E2C  A0440000   SB A0, 0(V0)
9D004E34  00C4202A   SLT A0, A2, A0
9D004E38  1080FFF5   BEQ A0, ZERO, 0x9D004E10
9D004E3C  24420001   ADDIU V0, V0, 1
9D004E40  03E00008   JR RA
9D004E44  00000000   NOP
248:                 }// upper()
249:                 
250:                 int word(int c){
9D004E78  250824C0   ADDIU T0, T0, 9408
9D004EA4  24A524C0   ADDIU A1, A1, 9408
251:                     int i;
252:                     i=current;
9D004E48  83838068   LB V1, -32664(GP)
9D004E4C  00601021   ADDU V0, V1, ZERO
253:                     while  (i<ctib && tib[i]==c ) i++;
9D004E50  83878075   LB A3, -32651(GP)
9D004E54  0067282A   SLT A1, V1, A3
9D004E58  10A00010   BEQ A1, ZERO, 0x9D004E9C
9D004E5C  00E03021   ADDU A2, A3, ZERO
9D004E60  3C05A000   LUI A1, -24576
9D004E64  24A524C0   ADDIU A1, A1, 9408
9D004E68  00A31821   ADDU V1, A1, V1
9D004E6C  80650000   LB A1, 0(V1)
9D004E70  14A40023   BNE A1, A0, 0x9D004F00
9D004E74  3C08A000   LUI T0, -24576
9D004E7C  24420001   ADDIU V0, V0, 1
9D004E80  10470006   BEQ V0, A3, 0x9D004E9C
9D004E84  01021821   ADDU V1, T0, V0
9D004E88  80630000   LB V1, 0(V1)
9D004E8C  5065FFFC   BEQL V1, A1, 0x9D004E80
9D004E90  24420001   ADDIU V0, V0, 1
254:                     first=i;
9D004E94  0B4013C1   J 0x9D004F04
9D004E98  A3828074   SB V0, -32652(GP)
9D004E9C  0B4013B1   J 0x9D004EC4
9D004EA0  A3828074   SB V0, -32652(GP)
9D004F00  A3828074   SB V0, -32652(GP)
255:                     while (i<ctib && tib[i]!=c) i++;
9D004EA8  24420001   ADDIU V0, V0, 1
9D004EAC  0046182A   SLT V1, V0, A2
9D004EB0  10600004   BEQ V1, ZERO, 0x9D004EC4
9D004EB4  00A21821   ADDU V1, A1, V0
9D004EB8  80630000   LB V1, 0(V1)
9D004EBC  5464FFFB   BNEL V1, A0, 0x9D004EAC
9D004EC0  24420001   ADDIU V0, V0, 1
9D004F04  3C03A000   LUI V1, -24576
9D004F08  246324C0   ADDIU V1, V1, 9408
9D004F0C  00431821   ADDU V1, V0, V1
9D004F10  80630000   LB V1, 0(V1)
9D004F14  5464FFE3   BNEL V1, A0, 0x9D004EA4
9D004F18  3C05A000   LUI A1, -24576
256:                     last = i-1;
9D004EC4  2443FFFF   ADDIU V1, V0, -1
9D004EC8  A3838060   SB V1, -32672(GP)
9D004F1C  0B4013B2   J 0x9D004EC8
9D004F20  2443FFFF   ADDIU V1, V0, -1
9D004F24  03E00008   JR RA
9D004F28  00000000   NOP
257:                     if (tib[i]==c){tib[i]=0; i++;}
9D004ECC  3C03A000   LUI V1, -24576
9D004ED0  246324C0   ADDIU V1, V1, 9408
9D004ED4  00431821   ADDU V1, V0, V1
9D004ED8  80630000   LB V1, 0(V1)
9D004EDC  54640011   BNEL V1, A0, 0x9D004F24
9D004EE0  A3828068   SB V0, -32664(GP)
9D004EE4  3C03A000   LUI V1, -24576
9D004EE8  246324C0   ADDIU V1, V1, 9408
9D004EEC  00431821   ADDU V1, V0, V1
9D004EF0  A0600000   SB ZERO, 0(V1)
9D004EF4  24420001   ADDIU V0, V0, 1
258:                     current=i;
259:                 }// word()
9D004EF8  03E00008   JR RA
9D004EFC  A3828068   SB V0, -32664(GP)
260:                 
261:                 
262:                 int try_user(name_hash nh){
9D00522C  000318C0   SLL V1, V1, 3
9D005230  3C05A000   LUI A1, -24576
9D005234  24A52510   ADDIU A1, A1, 9488
9D005238  00A31821   ADDU V1, A1, V1
263:                     int i;
264:                     code_ptr cptr;
265:                     if (state)cptr=here; else cptr=cip;
9D00519C  83828032   LB V0, -32718(GP)
9D0051A0  50400002   BEQL V0, ZERO, 0x9D0051AC
9D0051A4  8F87806C   LW A3, -32660(GP)
9D0051A8  8F87CAA0   LW A3, -13664(GP)
266:                     for(i=free_slot-1;i>-1;i--){
9D0051AC  83838034   LB V1, -32716(GP)
9D0051B0  2462FFFF   ADDIU V0, V1, -1
9D0051B4  04400025   BLTZ V0, 0x9D00524C
9D0051B8  3C05A000   LUI A1, -24576
9D00523C  2406FFFF   ADDIU A2, ZERO, -1
9D005240  2442FFFF   ADDIU V0, V0, -1
9D005244  5446FFE5   BNEL V0, A2, 0x9D0051DC
9D005248  8C650000   LW A1, 0(V1)
267:                         if (user_dict[i].name==nh){
9D0051BC  000230C0   SLL A2, V0, 3
9D0051C0  24A52510   ADDIU A1, A1, 9488
9D0051C4  00C52821   ADDU A1, A2, A1
9D0051C8  8CA50000   LW A1, 0(A1)
9D0051CC  54A40017   BNEL A1, A0, 0x9D00522C
9D0051D0  2463FFFE   ADDIU V1, V1, -2
9D0051DC  14A40018   BNE A1, A0, 0x9D005240
9D0051E0  2463FFF8   ADDIU V1, V1, -8
268:                             *cptr++=IRCALL;
9D0051D4  0B40147A   J 0x9D0051E8
9D0051D8  2403002B   ADDIU V1, ZERO, 43
9D0051E4  2403002B   ADDIU V1, ZERO, 43
9D0051E8  A0E30000   SB V1, 0(A3)
269:                             *cptr++=(int)user_dict[i].cfa;
9D0051EC  000220C0   SLL A0, V0, 3
9D0051F0  3C03A000   LUI V1, -24576
9D0051F4  24632510   ADDIU V1, V1, 9488
9D0051F8  00641821   ADDU V1, V1, A0
9D0051FC  8C640004   LW A0, 4(V1)
9D005200  A0E40001   SB A0, 1(A3)
270:                             *cptr++=(int)user_dict[i].cfa>>8;
9D005204  8C630004   LW V1, 4(V1)
9D005208  00031A03   SRA V1, V1, 8
9D00520C  A0E30002   SB V1, 2(A3)
271:                             if (state)here=cptr;else cip=cptr;
9D005210  83838032   LB V1, -32718(GP)
9D005214  10600003   BEQ V1, ZERO, 0x9D005224
9D005218  24E70003   ADDIU A3, A3, 3
9D00521C  0B401493   J 0x9D00524C
9D005220  AF87CAA0   SW A3, -13664(GP)
9D005224  0B401493   J 0x9D00524C
9D005228  AF87806C   SW A3, -32660(GP)
272:                             break;
273:                         }
274:                     }
275:                     if (i==-1) return 0; else return 1;
9D00524C  24420001   ADDIU V0, V0, 1
276:                 }// try_user()
9D005250  03E00008   JR RA
9D005254  0002102B   SLTU V0, ZERO, V0
277:                 
278:                 int try_system(name_hash nh){
9D005258  27BDFFE8   ADDIU SP, SP, -24
9D00525C  AFBF0014   SW RA, 20(SP)
9D0052E0  83828033   LB V0, -32717(GP)
9D0052E4  0B4014D1   J 0x9D005344
9D0052E8  2C420001   SLTIU V0, V0, 1
279:                     int i;
280:                     code_ptr cptr;
281:                    compfct f;
282:                    if (state) cptr=here;else cptr=cip;
9D005260  83828032   LB V0, -32718(GP)
9D005264  50400002   BEQL V0, ZERO, 0x9D005270
9D005268  8F89806C   LW T1, -32660(GP)
9D00526C  8F89CAA0   LW T1, -13664(GP)
283:                    for(i=SYSTEM_COUNT-1;i>-1;i--){
9D005290  24030012   ADDIU V1, ZERO, 18
9D005294  2408FFFF   ADDIU T0, ZERO, -1
9D0052B8  24030013   ADDIU V1, ZERO, 19
9D005338  1468FFD7   BNE V1, T0, 0x9D005298
9D00533C  24A5FFF8   ADDIU A1, A1, -8
284:                         if (abs(system_dict[i].name)==nh){
9D005270  3C02A000   LUI V0, -24576
9D005274  8C424C34   LW V0, 19508(V0)
9D005278  00021FC3   SRA V1, V0, 31
9D00527C  00622826   XOR A1, V1, V0
9D005280  00A31823   SUBU V1, A1, V1
9D005284  1064000C   BEQ V1, A0, 0x9D0052B8
9D005288  3C05A000   LUI A1, -24576
9D00528C  24A54C2C   ADDIU A1, A1, 19500
9D005298  8CA20000   LW V0, 0(A1)
9D00529C  000237C3   SRA A2, V0, 31
9D0052A0  00C23826   XOR A3, A2, V0
9D0052A4  00E63023   SUBU A2, A3, A2
9D0052A8  54C40023   BNEL A2, A0, 0x9D005338
9D0052AC  2463FFFF   ADDIU V1, V1, -1
9D0052B0  0B4014AF   J 0x9D0052BC
9D0052B4  00000000   NOP
285:                             if ((int)system_dict[i].name<0){
9D0052BC  0443000B   BGEZL V0, 0x9D0052EC
9D0052C0  24020004   ADDIU V0, ZERO, 4
286:                                 f=(compfct)system_dict[i].cfa;
9D0052C4  000318C0   SLL V1, V1, 3
9D0052C8  3C02A000   LUI V0, -24576
9D0052CC  24424B9C   ADDIU V0, V0, 19356
9D0052D0  00431821   ADDU V1, V0, V1
287:                                 f();
9D0052D4  8C620004   LW V0, 4(V1)
9D0052D8  0040F809   JALR V0
9D0052DC  00000000   NOP
288:                                 if (error) return 0;
289:                             }else{
290:                                 *cptr++=IFCALL;
9D0052EC  A1220000   SB V0, 0(T1)
291:                                 *cptr++=(int)system_dict[i].cfa;
9D0052F0  000318C0   SLL V1, V1, 3
9D0052F4  3C02A000   LUI V0, -24576
9D0052F8  24424B9C   ADDIU V0, V0, 19356
9D0052FC  00431821   ADDU V1, V0, V1
9D005300  8C620004   LW V0, 4(V1)
9D005304  A1220001   SB V0, 1(T1)
292:                                 *cptr++=(int)system_dict[i].cfa>>8;
9D005308  8C620004   LW V0, 4(V1)
9D00530C  00021203   SRA V0, V0, 8
9D005310  A1220002   SB V0, 2(T1)
293:                                 if (state) here=cptr;else cip=cptr;
9D005314  83828032   LB V0, -32718(GP)
9D005318  10400004   BEQ V0, ZERO, 0x9D00532C
9D00531C  25290003   ADDIU T1, T1, 3
9D005320  AF89CAA0   SW T1, -13664(GP)
9D00532C  AF89806C   SW T1, -32660(GP)
294:                             }
295:                             return 1;
9D005324  0B4014D1   J 0x9D005344
9D005328  24020001   ADDIU V0, ZERO, 1
9D005330  0B4014D1   J 0x9D005344
9D005334  24020001   ADDIU V0, ZERO, 1
296:                         }
297:                     }
298:                     return 0;
9D005340  00001021   ADDU V0, ZERO, ZERO
299:                 }// try_system()
9D005344  8FBF0014   LW RA, 20(SP)
9D005348  03E00008   JR RA
9D00534C  27BD0018   ADDIU SP, SP, 24
300:                 
301:                 
302:                 int try_token(name_hash nh){ // recherche le mot dans VM_TOKENS
9D0057BC  27BDFFE8   ADDIU SP, SP, -24
303:                     int i;
304:                     for (i=TOK_COUNT-1;i>-1;i--){
9D0057D8  2402004B   ADDIU V0, ZERO, 75
9D0057DC  2406FFFF   ADDIU A2, ZERO, -1
9D0057F4  2402004C   ADDIU V0, ZERO, 76
9D005808  1446FFF5   BNE V0, A2, 0x9D0057E0
9D00580C  2463FFFC   ADDIU V1, V1, -4
305:                         if (nh==vm_tokens[i]){
9D0057C0  3C022C04   LUI V0, 11268
9D0057C4  24426F28   ADDIU V0, V0, 28456
9D0057C8  1082000A   BEQ A0, V0, 0x9D0057F4
9D0057CC  AFBF0014   SW RA, 20(SP)
9D0057D0  3C039D01   LUI V1, -25343
9D0057D4  24639AF8   ADDIU V1, V1, -25864
9D0057E0  8C650000   LW A1, 0(V1)
9D0057E4  54A40008   BNEL A1, A0, 0x9D005808
9D0057E8  2442FFFF   ADDIU V0, V0, -1
9D0057EC  0B4015FE   J 0x9D0057F8
9D0057F0  00000000   NOP
306:                             return compile_token(i);
9D0057F8  0F401561   JAL compile_token
9D0057FC  00402021   ADDU A0, V0, ZERO
9D005800  0B401606   J 0x9D005818
9D005804  8FBF0014   LW RA, 20(SP)
307:                         }
308:                     }
309:                     return 0;
9D005810  00001021   ADDU V0, ZERO, ZERO
310:                 }//try_token()
9D005814  8FBF0014   LW RA, 20(SP)
9D005818  03E00008   JR RA
9D00581C  27BD0018   ADDIU SP, SP, 24
311:                 
312:                 
313:                 int parse_int(int *n){
9D005350  27BDFFE0   ADDIU SP, SP, -32
9D005354  AFBF001C   SW RA, 28(SP)
9D005358  AFB10018   SW S1, 24(SP)
9D00535C  AFB00014   SW S0, 20(SP)
9D0053E4  24C624C0   ADDIU A2, A2, 9408
9D0053F8  00C22021   ADDU A0, A2, V0
314:                     int i,base,sign;
315:                     upper();
9D005360  0F40137C   JAL upper
9D005364  00808021   ADDU S0, A0, ZERO
316:                     *n=0;
9D005368  AE000000   SW ZERO, 0(S0)
317:                     base=10;
9D0053B8  2405000A   ADDIU A1, ZERO, 10
318:                     sign=1;
9D0053D8  24110001   ADDIU S1, ZERO, 1
319:                     i=first;
9D00536C  83828074   LB V0, -32652(GP)
320:                     switch (tib[i]){
9D005370  3C03A000   LUI V1, -24576
9D005374  246324C0   ADDIU V1, V1, 9408
9D005378  00431821   ADDU V1, V0, V1
9D00537C  80630000   LB V1, 0(V1)
9D005380  2404002B   ADDIU A0, ZERO, 43
9D005384  10640013   BEQ V1, A0, 0x9D0053D4
9D005388  2404002D   ADDIU A0, ZERO, 45
9D00538C  10640006   BEQ V1, A0, 0x9D0053A8
9D005390  24040024   ADDIU A0, ZERO, 36
9D005394  14640008   BNE V1, A0, 0x9D0053B8
9D005398  24110001   ADDIU S1, ZERO, 1
321:                         case '$':
322:                             base=16;
323:                             i++;
9D00539C  24420001   ADDIU V0, V0, 1
324:                             break;
9D0053A0  0B4014EF   J 0x9D0053BC
9D0053A4  24050010   ADDIU A1, ZERO, 16
325:                         case '-':
326:                             sign=-1;
9D0053AC  2411FFFF   ADDIU S1, ZERO, -1
327:                             i++;
9D0053A8  24420001   ADDIU V0, V0, 1
328:                             break;
9D0053B0  0B4014EF   J 0x9D0053BC
9D0053B4  2405000A   ADDIU A1, ZERO, 10
329:                         case '+':
330:                             i++;
9D0053D4  24420001   ADDIU V0, V0, 1
331:                             break;
9D0053DC  0B4014EF   J 0x9D0053BC
9D0053E0  2405000A   ADDIU A1, ZERO, 10
332:                     }
333:                     for (;i<=last;i++){
9D0053BC  83838060   LB V1, -32672(GP)
9D0053C0  0062182A   SLT V1, V1, V0
9D0053C4  50600007   BEQL V1, ZERO, 0x9D0053E4
9D0053C8  3C06A000   LUI A2, -24576
9D005464  24420001   ADDIU V0, V0, 1
9D005468  83838060   LB V1, -32672(GP)
9D00546C  0062182A   SLT V1, V1, V0
9D005470  5060FFDF   BEQL V1, ZERO, 0x9D0053F0
9D005474  8E030000   LW V1, 0(S0)
334:                         *n = *n*base;
9D0053EC  8E030000   LW V1, 0(S0)
9D0053F0  70A34002   MUL T0, A1, V1
9D0053F4  AE080000   SW T0, 0(S0)
335:                         if (tib[i]>='0' && tib[i]<='9') *n += tib[i]-'0';
9D0053FC  80830000   LB V1, 0(A0)
9D005400  2464FFD0   ADDIU A0, V1, -48
9D005404  308400FF   ANDI A0, A0, 255
9D005408  2C84000A   SLTIU A0, A0, 10
9D00540C  10800004   BEQ A0, ZERO, 0x9D005420
9D005410  2464FFD0   ADDIU A0, V1, -48
9D005414  00881821   ADDU V1, A0, T0
9D005418  0B401519   J 0x9D005464
9D00541C  AE030000   SW V1, 0(S0)
336:                         else if (base==16 && tib[i]>='A' && tib[i]<='F') *n += tib[i]-'A'+10;
9D0053E8  24070010   ADDIU A3, ZERO, 16
9D005420  14A70008   BNE A1, A3, 0x9D005444
9D005424  28640041   SLTI A0, V1, 65
9D005428  14800006   BNE A0, ZERO, 0x9D005444
9D00542C  28640047   SLTI A0, V1, 71
9D005430  10800004   BEQ A0, ZERO, 0x9D005444
9D005434  2464FFC9   ADDIU A0, V1, -55
9D005438  00881821   ADDU V1, A0, T0
9D00543C  0B401519   J 0x9D005464
9D005440  AE030000   SW V1, 0(S0)
337:                         else{
338:                             error=1;
9D005444  24020001   ADDIU V0, ZERO, 1
9D005448  A3828033   SB V0, -32717(GP)
339:                             print(comm_channel," erreur lecture entier.\r");
9D00544C  83848038   LB A0, -32712(GP)
9D005450  3C059D01   LUI A1, -25343
9D005454  0F401DDD   JAL print
9D005458  24A5995C   ADDIU A1, A1, -26276
340:                             break;
9D00545C  0B40151F   J 0x9D00547C
9D005460  8E020000   LW V0, 0(S0)
341:                         }
342:                     }
343:                     *n = *n * sign;
9D0053CC  0B40151F   J 0x9D00547C
9D0053D0  8E020000   LW V0, 0(S0)
9D005478  8E020000   LW V0, 0(S0)
9D00547C  70518802   MUL S1, V0, S1
9D005480  AE110000   SW S1, 0(S0)
344:                     return !error;
9D005484  83828033   LB V0, -32717(GP)
345:                 }//parse_int()
9D005488  2C420001   SLTIU V0, V0, 1
9D00548C  8FBF001C   LW RA, 28(SP)
9D005490  8FB10018   LW S1, 24(SP)
9D005494  8FB00014   LW S0, 20(SP)
9D005498  03E00008   JR RA
9D00549C  27BD0020   ADDIU SP, SP, 32
346:                 
347:                 
348:                 int try_integer(){
9D0054A0  27BDFFE0   ADDIU SP, SP, -32
9D0054A4  AFBF001C   SW RA, 28(SP)
9D0054A8  AFB00018   SW S0, 24(SP)
349:                     int n;
350:                 
351:                     code_ptr cptr;
352:                     if (state) cptr=here;else cptr=cip;
9D0054AC  83828032   LB V0, -32718(GP)
9D0054B0  50400002   BEQL V0, ZERO, 0x9D0054BC
9D0054B4  8F90806C   LW S0, -32660(GP)
9D0054B8  8F90CAA0   LW S0, -13664(GP)
353:                     if (parse_int(&n)){
9D0054BC  0F4014D4   JAL parse_int
9D0054C0  27A40010   ADDIU A0, SP, 16
9D0054C4  10400029   BEQ V0, ZERO, 0x9D00556C
9D0054C8  8FA20010   LW V0, 16(SP)
354:                         if (n<128 && n > -129){
9D0054CC  24430080   ADDIU V1, V0, 128
9D0054D0  2C630100   SLTIU V1, V1, 256
9D0054D4  10600007   BEQ V1, ZERO, 0x9D0054F4
9D0054D8  3403FFFF   ORI V1, ZERO, -1
355:                             *cptr++=ICLIT;
9D0054DC  24020027   ADDIU V0, ZERO, 39
9D0054E0  A2020000   SB V0, 0(S0)
356:                             *cptr++=n;
9D0054E4  8FA20010   LW V0, 16(SP)
9D0054E8  A2020001   SB V0, 1(S0)
9D0054EC  0B401557   J 0x9D00555C
9D0054F0  26100002   ADDIU S0, S0, 2
357:                         }else if (abs(n)<65536){
9D0054F4  00431021   ADDU V0, V0, V1
9D0054F8  3C030001   LUI V1, 1
9D0054FC  3463FFFF   ORI V1, V1, -1
9D005500  0043102B   SLTU V0, V0, V1
9D005504  1040000A   BEQ V0, ZERO, 0x9D005530
9D005508  24020003   ADDIU V0, ZERO, 3
358:                             *cptr++=IWLIT;
9D00550C  24020028   ADDIU V0, ZERO, 40
9D005510  A2020000   SB V0, 0(S0)
359:                             *cptr++=n;
9D005514  8FA20010   LW V0, 16(SP)
9D005518  A2020001   SB V0, 1(S0)
360:                             *cptr++=n>>8;
9D00551C  8FA20010   LW V0, 16(SP)
9D005520  00021203   SRA V0, V0, 8
9D005524  A2020002   SB V0, 2(S0)
9D005528  0B401557   J 0x9D00555C
9D00552C  26100003   ADDIU S0, S0, 3
361:                         }else{
362:                             *cptr++=ILIT;
9D005530  A2020000   SB V0, 0(S0)
363:                             *cptr++=n;
9D005534  8FA20010   LW V0, 16(SP)
9D005538  A2020001   SB V0, 1(S0)
364:                             *cptr++=n>>8;
9D00553C  8FA20010   LW V0, 16(SP)
9D005540  00021203   SRA V0, V0, 8
9D005544  A2020002   SB V0, 2(S0)
365:                             *cptr++=n>>16;
9D005548  87A20012   LH V0, 18(SP)
9D00554C  A2020003   SB V0, 3(S0)
366:                             *cptr++=n>>24;
9D005550  83A20013   LB V0, 19(SP)
9D005554  A2020004   SB V0, 4(S0)
9D005558  26100005   ADDIU S0, S0, 5
367:                         }
368:                        if (state)here=cptr;else cip=cptr;
9D00555C  83828032   LB V0, -32718(GP)
9D005560  50400002   BEQL V0, ZERO, 0x9D00556C
9D005564  AF90806C   SW S0, -32660(GP)
9D005568  AF90CAA0   SW S0, -13664(GP)
369:                     }
370:                     return !error;
9D00556C  83828033   LB V0, -32717(GP)
371:                 }// try_integer()
9D005570  2C420001   SLTIU V0, V0, 1
9D005574  8FBF001C   LW RA, 28(SP)
9D005578  8FB00018   LW S0, 24(SP)
9D00557C  03E00008   JR RA
9D005580  27BD0020   ADDIU SP, SP, 32
372:                 
373:                 void column(){ // ':' doit être le premier mot dans tib
9D00512C  27BDFFE8   ADDIU SP, SP, -24
9D005130  AFBF0014   SW RA, 20(SP)
374:                     name_hash nh;
375:                 
376:                     if (state || first>0){error=1;return;}
9D005134  83828032   LB V0, -32718(GP)
9D005138  14400003   BNE V0, ZERO, 0x9D005148
9D00513C  83828074   LB V0, -32652(GP)
9D005140  18400004   BLEZ V0, 0x9D005154
9D005144  00000000   NOP
9D005148  24020001   ADDIU V0, ZERO, 1
9D00514C  0B401464   J 0x9D005190
9D005150  A3828033   SB V0, -32717(GP)
377:                     word(SPC);
9D005154  0F401392   JAL word
9D005158  24040020   ADDIU A0, ZERO, 32
378:                     nh=hash();
9D00515C  0F401324   JAL hash
9D005160  00000000   NOP
379:                     state=1;
9D005164  24030001   ADDIU V1, ZERO, 1
9D005168  A3838032   SB V1, -32718(GP)
380:                     mark=here;
9D00516C  8F84CAA0   LW A0, -13664(GP)
9D005170  AF848070   SW A0, -32656(GP)
381:                     user_dict[free_slot].name=nh;
9D005174  83858034   LB A1, -32716(GP)
9D005178  000528C0   SLL A1, A1, 3
9D00517C  3C03A000   LUI V1, -24576
9D005180  24632510   ADDIU V1, V1, 9488
9D005184  00A31821   ADDU V1, A1, V1
9D005188  AC620000   SW V0, 0(V1)
382:                     user_dict[free_slot].cfa=here;
9D00518C  AC640004   SW A0, 4(V1)
383:                 }//column()
9D005190  8FBF0014   LW RA, 20(SP)
9D005194  03E00008   JR RA
9D005198  27BD0018   ADDIU SP, SP, 24
384:                 
385:                 void semi_column(){// ';' doit-être le dernier mot dans tib
386:                     if (!state){error=1;return;}
9D004768  83828032   LB V0, -32718(GP)
9D00476C  14400004   BNE V0, ZERO, 0x9D004780
9D004770  8F82CAA0   LW V0, -13664(GP)
9D004774  24020001   ADDIU V0, ZERO, 1
9D004778  03E00008   JR RA
9D00477C  A3828033   SB V0, -32717(GP)
387:                     *here++=IRET;
9D004780  24030005   ADDIU V1, ZERO, 5
9D004784  A0430000   SB V1, 0(V0)
9D004788  24430001   ADDIU V1, V0, 1
9D00478C  AF83CAA0   SW V1, -13664(GP)
388:                     cip=here+256;
9D004790  24420101   ADDIU V0, V0, 257
9D004794  AF82806C   SW V0, -32660(GP)
389:                     state=IMMEDIATE;
9D004798  A3808032   SB ZERO, -32718(GP)
390:                     free_slot++;
9D00479C  93828034   LBU V0, -32716(GP)
9D0047A0  24420001   ADDIU V0, V0, 1
9D0047A4  03E00008   JR RA
9D0047A8  A3828034   SB V0, -32716(GP)
391:                 }//semi_column()
392:                 
393:                 void compile_var(){ // var, ne doit pas être utilisé à l'intérieur d'une définition
9D005074  27BDFFE8   ADDIU SP, SP, -24
9D005078  AFBF0014   SW RA, 20(SP)
394:                     name_hash nh;
395:                     code_ptr cfa,var;
396:                     if (state) {error=1;return;}
9D00507C  83828032   LB V0, -32718(GP)
9D005080  10400003   BEQ V0, ZERO, 0x9D005090
9D005084  24020001   ADDIU V0, ZERO, 1
9D005088  0B401448   J 0x9D005120
9D00508C  A3828033   SB V0, -32717(GP)
397:                     state=COMPILE;
9D005090  A3828032   SB V0, -32718(GP)
398:                     word(SPC);
9D005094  0F401392   JAL word
9D005098  24040020   ADDIU A0, ZERO, 32
399:                     if (last<first){error=1;return;}
9D00509C  83838060   LB V1, -32672(GP)
9D0050A0  83828074   LB V0, -32652(GP)
9D0050A4  0062102A   SLT V0, V1, V0
9D0050A8  10400003   BEQ V0, ZERO, 0x9D0050B8
9D0050AC  24020001   ADDIU V0, ZERO, 1
9D0050B0  0B401448   J 0x9D005120
9D0050B4  A3828033   SB V0, -32717(GP)
400:                     nh=hash();
9D0050B8  0F401324   JAL hash
9D0050BC  00000000   NOP
401:                     cfa=here;
9D0050C0  8F83CAA0   LW V1, -13664(GP)
402:                     var = cfa+6;
9D0050CC  24640006   ADDIU A0, V1, 6
403:                     *here++=ILIT;
9D0050C4  24040003   ADDIU A0, ZERO, 3
9D0050C8  A0640000   SB A0, 0(V1)
404:                     *here++=(int)var;
9D0050D0  A0640001   SB A0, 1(V1)
405:                     *here++=(int)var>>8;
9D0050D4  00042A03   SRA A1, A0, 8
9D0050D8  A0650002   SB A1, 2(V1)
406:                     *here++=(int)var>>16;
9D0050DC  00042C03   SRA A1, A0, 16
9D0050E0  A0650003   SB A1, 3(V1)
407:                     *here++=(int)var>>24;
9D0050E4  00042603   SRA A0, A0, 24
9D0050E8  A0640004   SB A0, 4(V1)
408:                     *here++=IRET;
9D0050EC  24040005   ADDIU A0, ZERO, 5
9D0050F0  A0640005   SB A0, 5(V1)
409:                     here +=CELL_SIZE;
9D0050F4  2464000A   ADDIU A0, V1, 10
9D0050F8  AF84CAA0   SW A0, -13664(GP)
410:                     user_dict[free_slot].name=nh;
9D0050FC  83848034   LB A0, -32716(GP)
9D005100  000430C0   SLL A2, A0, 3
9D005104  3C05A000   LUI A1, -24576
9D005108  24A52510   ADDIU A1, A1, 9488
9D00510C  00C52821   ADDU A1, A2, A1
9D005110  ACA20000   SW V0, 0(A1)
411:                     user_dict[free_slot].cfa=cfa;
9D005114  ACA30004   SW V1, 4(A1)
412:                     free_slot++;
9D005118  24840001   ADDIU A0, A0, 1
9D00511C  A3848034   SB A0, -32716(GP)
413:                 }// compile_var()
9D005120  8FBF0014   LW RA, 20(SP)
9D005124  03E00008   JR RA
9D005128  27BD0018   ADDIU SP, SP, 24
414:                 
415:                 void compile_const(){ // const, ne doit pas être utilisé à l'intérieur d'une définition
9D004F2C  27BDFFE8   ADDIU SP, SP, -24
9D004F30  AFBF0014   SW RA, 20(SP)
416:                     name_hash nh;
417:                     code_ptr cfa;
418:                     int n;
419:                     if (state) {error=1;return;}
9D004F34  83828032   LB V0, -32718(GP)
9D004F38  10400003   BEQ V0, ZERO, 0x9D004F48
9D004F3C  24020001   ADDIU V0, ZERO, 1
9D004F40  0B40141A   J 0x9D005068
9D004F44  A3828033   SB V0, -32717(GP)
420:                     state=COMPILE;
9D004F48  A3828032   SB V0, -32718(GP)
421:                     word(SPC);
9D004F4C  0F401392   JAL word
9D004F50  24040020   ADDIU A0, ZERO, 32
422:                     if (last<first){error=1;return;}
9D004F54  83838060   LB V1, -32672(GP)
9D004F58  83828074   LB V0, -32652(GP)
9D004F5C  0062102A   SLT V0, V1, V0
9D004F60  10400003   BEQ V0, ZERO, 0x9D004F70
9D004F64  24020001   ADDIU V0, ZERO, 1
9D004F68  0B40141A   J 0x9D005068
9D004F6C  A3828033   SB V0, -32717(GP)
423:                     nh=hash();
9D004F70  0F401324   JAL hash
9D004F74  00000000   NOP
424:                     cfa=here;
9D004F78  8F83CAA0   LW V1, -13664(GP)
425:                     cip=here+256;
9D004F7C  24640100   ADDIU A0, V1, 256
9D004F80  AF84806C   SW A0, -32660(GP)
426:                     *here++=*cip++;
9D004F84  90640100   LBU A0, 256(V1)
9D004F88  A0640000   SB A0, 0(V1)
9D004F8C  24640001   ADDIU A0, V1, 1
9D004F90  AF84CAA0   SW A0, -13664(GP)
9D004F94  24640101   ADDIU A0, V1, 257
9D004F98  AF84806C   SW A0, -32660(GP)
427:                     *here++=*cip++;
9D004F9C  90640101   LBU A0, 257(V1)
9D004FA0  A0640001   SB A0, 1(V1)
9D004FA4  24650002   ADDIU A1, V1, 2
9D004FA8  AF85CAA0   SW A1, -13664(GP)
9D004FAC  24640102   ADDIU A0, V1, 258
9D004FB0  AF84806C   SW A0, -32660(GP)
428:                     if (*(cip-2)==IWLIT){
9D004FB4  8087FFFE   LB A3, -2(A0)
9D004FB8  24060028   ADDIU A2, ZERO, 40
9D004FBC  54E60008   BNEL A3, A2, 0x9D004FE0
9D004FC0  80670102   LB A3, 258(V1)
429:                         *here++=*cip++;
9D004FC4  90660102   LBU A2, 258(V1)
9D004FC8  A0660002   SB A2, 2(V1)
9D004FCC  24A50001   ADDIU A1, A1, 1
9D004FD0  AF85CAA0   SW A1, -13664(GP)
9D004FD4  24840001   ADDIU A0, A0, 1
9D004FD8  0B40140C   J 0x9D005030
9D004FDC  AF84806C   SW A0, -32660(GP)
430:                     }else if (*cip-2==ILIT){
9D004FE0  24060005   ADDIU A2, ZERO, 5
9D004FE4  54E60013   BNEL A3, A2, 0x9D005034
9D004FE8  8F84CAA0   LW A0, -13664(GP)
431:                         *here++=*cip++;
9D004FEC  A0660002   SB A2, 2(V1)
9D004FF0  24A60001   ADDIU A2, A1, 1
9D004FF4  AF86CAA0   SW A2, -13664(GP)
9D004FF8  24860001   ADDIU A2, A0, 1
9D004FFC  AF86806C   SW A2, -32660(GP)
432:                         *here++=*cip++;
9D005000  90860001   LBU A2, 1(A0)
9D005004  A0A60001   SB A2, 1(A1)
9D005008  24A60002   ADDIU A2, A1, 2
9D00500C  AF86CAA0   SW A2, -13664(GP)
9D005010  24860002   ADDIU A2, A0, 2
9D005014  AF86806C   SW A2, -32660(GP)
433:                         *here++=*cip++;
9D005018  90860002   LBU A2, 2(A0)
9D00501C  A0A60002   SB A2, 2(A1)
9D005020  24A50003   ADDIU A1, A1, 3
9D005024  AF85CAA0   SW A1, -13664(GP)
9D005028  24840003   ADDIU A0, A0, 3
9D00502C  AF84806C   SW A0, -32660(GP)
434:                     }
435:                     *here++=IRET;
9D005030  8F84CAA0   LW A0, -13664(GP)
9D005034  24050005   ADDIU A1, ZERO, 5
9D005038  A0850000   SB A1, 0(A0)
9D00503C  24840001   ADDIU A0, A0, 1
9D005040  AF84CAA0   SW A0, -13664(GP)
436:                     user_dict[free_slot].name=nh;
9D005044  83848034   LB A0, -32716(GP)
9D005048  000430C0   SLL A2, A0, 3
9D00504C  3C05A000   LUI A1, -24576
9D005050  24A52510   ADDIU A1, A1, 9488
9D005054  00C52821   ADDU A1, A2, A1
9D005058  ACA20000   SW V0, 0(A1)
437:                     user_dict[free_slot].cfa=cfa;
9D00505C  ACA30004   SW V1, 4(A1)
438:                     free_slot++;
9D005060  24840001   ADDIU A0, A0, 1
9D005064  A3848034   SB A0, -32716(GP)
439:                 }// compile_const()
9D005068  8FBF0014   LW RA, 20(SP)
9D00506C  03E00008   JR RA
9D005070  27BD0018   ADDIU SP, SP, 24
440:                 
441:                 void compile_if(){ //if
442:                     code_ptr cptr;
443:                     if (state) cptr=here;else cptr=cip;
9D0047AC  83828032   LB V0, -32718(GP)
9D0047B0  50400002   BEQL V0, ZERO, 0x9D0047BC
9D0047B4  8F82806C   LW V0, -32660(GP)
9D0047B8  8F82CAA0   LW V0, -13664(GP)
444:                     *cptr++=IQBRAZ;
9D0047BC  2403003B   ADDIU V1, ZERO, 59
9D0047C0  A0430000   SB V1, 0(V0)
9D0047C4  24440001   ADDIU A0, V0, 1
445:                     cstack[++cp]=(int)cptr;
9D0047C8  93838011   LBU V1, -32751(GP)
9D0047CC  24630001   ADDIU V1, V1, 1
9D0047D0  7C031C20   SEB V1, V1
9D0047D4  A3838011   SB V1, -32751(GP)
9D0047D8  00031880   SLL V1, V1, 2
9D0047DC  3C05A000   LUI A1, -24576
9D0047E0  24A52830   ADDIU A1, A1, 10288
9D0047E4  00651821   ADDU V1, V1, A1
9D0047E8  AC640000   SW A0, 0(V1)
446:                     cptr++; // saute  addresse de ?braz
447:                     if (state)here=cptr;else cip=cptr;
9D0047EC  83838032   LB V1, -32718(GP)
9D0047F0  10600003   BEQ V1, ZERO, 0x9D004800
9D0047F4  24420002   ADDIU V0, V0, 2
9D0047F8  03E00008   JR RA
9D0047FC  AF82CAA0   SW V0, -13664(GP)
9D004800  03E00008   JR RA
9D004804  AF82806C   SW V0, -32660(GP)
448:                 }// compile_if()
449:                 
450:                 void compile_then(){ //then
451:                     char *there;
452:                     code_ptr cptr;
453:                     if (state) cptr=here;else cptr=cip;
9D004808  83828032   LB V0, -32718(GP)
9D00480C  50400002   BEQL V0, ZERO, 0x9D004818
9D004810  8F82806C   LW V0, -32660(GP)
9D004814  8F82CAA0   LW V0, -13664(GP)
454:                     there=(char *)cstack[cp--];
9D004818  83848011   LB A0, -32751(GP)
9D00481C  00042880   SLL A1, A0, 2
9D004820  3C03A000   LUI V1, -24576
9D004824  24632830   ADDIU V1, V1, 10288
9D004828  00A31821   ADDU V1, A1, V1
9D00482C  8C630000   LW V1, 0(V1)
9D004830  2484FFFF   ADDIU A0, A0, -1
9D004834  A3848011   SB A0, -32751(GP)
455:                     *there=cptr-there-1;
9D004838  00032027   NOR A0, ZERO, V1
9D00483C  00822021   ADDU A0, A0, V0
9D004840  A0640000   SB A0, 0(V1)
456:                     if (state)here=cptr;else cip=cptr;
9D004844  83838032   LB V1, -32718(GP)
9D004848  50600003   BEQL V1, ZERO, 0x9D004858
9D00484C  AF82806C   SW V0, -32660(GP)
9D004850  03E00008   JR RA
9D004854  AF82CAA0   SW V0, -13664(GP)
9D004858  03E00008   JR RA
9D00485C  00000000   NOP
457:                 }// compile_then()
458:                 
459:                 void compile_else(){ //else
460:                     char *there;
461:                     code_ptr cptr;
462:                     if (state) cptr=here;else cptr=cip;
9D004860  83828032   LB V0, -32718(GP)
9D004864  50400002   BEQL V0, ZERO, 0x9D004870
9D004868  8F82806C   LW V0, -32660(GP)
9D00486C  8F82CAA0   LW V0, -13664(GP)
463:                     there=(char*)cstack[cp];
9D004870  83848011   LB A0, -32751(GP)
9D004874  00042080   SLL A0, A0, 2
9D004878  3C03A000   LUI V1, -24576
9D00487C  24632830   ADDIU V1, V1, 10288
9D004880  00832021   ADDU A0, A0, V1
9D004884  8C840000   LW A0, 0(A0)
464:                     *there=cptr-there+1;
9D004888  00442823   SUBU A1, V0, A0
9D00488C  24A50001   ADDIU A1, A1, 1
9D004890  A0850000   SB A1, 0(A0)
465:                     *cptr++=IBRA;
9D004894  24040006   ADDIU A0, ZERO, 6
9D004898  A0440000   SB A0, 0(V0)
9D00489C  24440001   ADDIU A0, V0, 1
466:                     cstack[cp]=(int)cptr;
9D0048A0  83858011   LB A1, -32751(GP)
9D0048A4  00052880   SLL A1, A1, 2
9D0048A8  00A31821   ADDU V1, A1, V1
9D0048AC  AC640000   SW A0, 0(V1)
467:                     cptr++;
468:                     if (state)here=cptr;else cip=cptr;
9D0048B0  83838032   LB V1, -32718(GP)
9D0048B4  10600003   BEQ V1, ZERO, 0x9D0048C4
9D0048B8  24420002   ADDIU V0, V0, 2
9D0048BC  03E00008   JR RA
9D0048C0  AF82CAA0   SW V0, -13664(GP)
9D0048C4  03E00008   JR RA
9D0048C8  AF82806C   SW V0, -32660(GP)
469:                 }//compile_else(){
470:                 
471:                 void compile_do(){ // 'do'
472:                     code_ptr cptr;
473:                     if (state)cptr=here;else cptr=cip;
9D0048CC  83828032   LB V0, -32718(GP)
9D0048D0  50400002   BEQL V0, ZERO, 0x9D0048DC
9D0048D4  8F82806C   LW V0, -32660(GP)
9D0048D8  8F82CAA0   LW V0, -13664(GP)
474:                     *cptr++=ITOR;
9D0048DC  24030010   ADDIU V1, ZERO, 16
9D0048E0  A0430000   SB V1, 0(V0)
475:                     *cptr++=ITOR;
9D0048E4  A0430001   SB V1, 1(V0)
9D0048E8  24420002   ADDIU V0, V0, 2
476:                     cstack[++cp]=(int)cptr;
9D0048EC  93838011   LBU V1, -32751(GP)
9D0048F0  24630001   ADDIU V1, V1, 1
9D0048F4  7C031C20   SEB V1, V1
9D0048F8  A3838011   SB V1, -32751(GP)
9D0048FC  00031880   SLL V1, V1, 2
9D004900  3C04A000   LUI A0, -24576
9D004904  24842830   ADDIU A0, A0, 10288
9D004908  00641821   ADDU V1, V1, A0
9D00490C  AC620000   SW V0, 0(V1)
477:                     if (state) here=cptr; else cip=cptr;
9D004910  83838032   LB V1, -32718(GP)
9D004914  50600003   BEQL V1, ZERO, 0x9D004924
9D004918  AF82806C   SW V0, -32660(GP)
9D00491C  03E00008   JR RA
9D004920  AF82CAA0   SW V0, -13664(GP)
9D004924  03E00008   JR RA
9D004928  00000000   NOP
478:                 }//compile_do()
479:                 
480:                 void compile_loop(){ //loop
481:                     code_ptr there, cptr;
482:                 
483:                     if (state) cptr=here;else cptr=cip;
9D00492C  83828032   LB V0, -32718(GP)
9D004930  50400002   BEQL V0, ZERO, 0x9D00493C
9D004934  8F82806C   LW V0, -32660(GP)
9D004938  8F82CAA0   LW V0, -13664(GP)
484:                     there=(code_ptr)cstack[cp--];
9D00493C  83838011   LB V1, -32751(GP)
9D004940  00032880   SLL A1, V1, 2
9D004944  3C04A000   LUI A0, -24576
9D004948  24842830   ADDIU A0, A0, 10288
9D00494C  00A42021   ADDU A0, A1, A0
9D004950  8C840000   LW A0, 0(A0)
9D004954  2463FFFF   ADDIU V1, V1, -1
9D004958  A3838011   SB V1, -32751(GP)
485:                     *cptr++=IRFROM;
9D00495C  24030011   ADDIU V1, ZERO, 17
9D004960  A0430000   SB V1, 0(V0)
486:                     *cptr++=IPLUS1;
9D004964  2405002F   ADDIU A1, ZERO, 47
9D004968  A0450001   SB A1, 1(V0)
487:                     *cptr++=IDUP;
9D00496C  24050015   ADDIU A1, ZERO, 21
9D004970  A0450002   SB A1, 2(V0)
488:                     *cptr++=IRFETCH;
9D004974  2405000F   ADDIU A1, ZERO, 15
9D004978  A0450003   SB A1, 3(V0)
489:                     *cptr++=ISWAP;
9D00497C  24050016   ADDIU A1, ZERO, 22
9D004980  A0450004   SB A1, 4(V0)
490:                     *cptr++=ITOR;
9D004984  24050010   ADDIU A1, ZERO, 16
9D004988  A0450005   SB A1, 5(V0)
491:                     *cptr++=ISUB;
9D00498C  24050019   ADDIU A1, ZERO, 25
9D004990  A0450006   SB A1, 6(V0)
492:                     *cptr++=IQBRA;
9D004994  24050007   ADDIU A1, ZERO, 7
9D004998  A0450007   SB A1, 7(V0)
9D00499C  24450008   ADDIU A1, V0, 8
493:                     *cptr++=there-cptr-1;
9D0049A0  2484FFFF   ADDIU A0, A0, -1
9D0049A4  00852023   SUBU A0, A0, A1
9D0049A8  A0440008   SB A0, 8(V0)
494:                     *cptr++=IRFROM;
9D0049AC  A0430009   SB V1, 9(V0)
495:                     *cptr++=IRFROM;
9D0049B0  A043000A   SB V1, 10(V0)
496:                     *cptr++=IDDROP;
9D0049B4  24030032   ADDIU V1, ZERO, 50
9D0049B8  A043000B   SB V1, 11(V0)
497:                     if (state) here=cptr;else cip=cptr;
9D0049BC  83838032   LB V1, -32718(GP)
9D0049C0  10600003   BEQ V1, ZERO, 0x9D0049D0
9D0049C4  2442000C   ADDIU V0, V0, 12
9D0049C8  03E00008   JR RA
9D0049CC  AF82CAA0   SW V0, -13664(GP)
9D0049D0  03E00008   JR RA
9D0049D4  AF82806C   SW V0, -32660(GP)
498:                 }//compile_loop()
499:                 
500:                 
501:                 void compile_ploop(){//+loop
502:                     code_ptr there, cptr;
503:                 
504:                     if (state) cptr=here;else cptr=cip;
9D0049D8  83828032   LB V0, -32718(GP)
9D0049DC  50400002   BEQL V0, ZERO, 0x9D0049E8
9D0049E0  8F82806C   LW V0, -32660(GP)
9D0049E4  8F82CAA0   LW V0, -13664(GP)
505:                     there=(code_ptr)cstack[cp--];
9D0049E8  83838011   LB V1, -32751(GP)
9D0049EC  00032880   SLL A1, V1, 2
9D0049F0  3C04A000   LUI A0, -24576
9D0049F4  24842830   ADDIU A0, A0, 10288
9D0049F8  00A42021   ADDU A0, A1, A0
9D0049FC  8C840000   LW A0, 0(A0)
9D004A00  2463FFFF   ADDIU V1, V1, -1
9D004A04  A3838011   SB V1, -32751(GP)
506:                     *cptr++=IRFROM;
9D004A08  24030011   ADDIU V1, ZERO, 17
9D004A0C  A0430000   SB V1, 0(V0)
507:                     *cptr++=IADD;
9D004A10  24050018   ADDIU A1, ZERO, 24
9D004A14  A0450001   SB A1, 1(V0)
508:                     *cptr++=IDUP;
9D004A18  24050015   ADDIU A1, ZERO, 21
9D004A1C  A0450002   SB A1, 2(V0)
509:                     *cptr++=IRFETCH;
9D004A20  2405000F   ADDIU A1, ZERO, 15
9D004A24  A0450003   SB A1, 3(V0)
510:                     *cptr++=ISWAP;
9D004A28  24050016   ADDIU A1, ZERO, 22
9D004A2C  A0450004   SB A1, 4(V0)
511:                     *cptr++=ITOR;
9D004A30  24050010   ADDIU A1, ZERO, 16
9D004A34  A0450005   SB A1, 5(V0)
512:                     *cptr++=ISUB;
9D004A38  24050019   ADDIU A1, ZERO, 25
9D004A3C  A0450006   SB A1, 6(V0)
513:                     *cptr++=IQBRA;
9D004A40  24050007   ADDIU A1, ZERO, 7
9D004A44  A0450007   SB A1, 7(V0)
9D004A48  24450008   ADDIU A1, V0, 8
514:                     *cptr++=there-cptr-1;
9D004A4C  2484FFFF   ADDIU A0, A0, -1
9D004A50  00852023   SUBU A0, A0, A1
9D004A54  A0440008   SB A0, 8(V0)
515:                     *cptr++=IRFROM;
9D004A58  A0430009   SB V1, 9(V0)
516:                     *cptr++=IRFROM;
9D004A5C  A043000A   SB V1, 10(V0)
517:                     *cptr++=IDDROP;
9D004A60  24030032   ADDIU V1, ZERO, 50
9D004A64  A043000B   SB V1, 11(V0)
518:                     if (state) here=cptr;else cip=cptr;
9D004A68  83838032   LB V1, -32718(GP)
9D004A6C  10600003   BEQ V1, ZERO, 0x9D004A7C
9D004A70  2442000C   ADDIU V0, V0, 12
9D004A74  03E00008   JR RA
9D004A78  AF82CAA0   SW V0, -13664(GP)
9D004A7C  03E00008   JR RA
9D004A80  AF82806C   SW V0, -32660(GP)
519:                 }//compile_ploop()
520:                 
521:                 void compile_begin(){//begin
522:                     if (state) 
9D004A84  83828032   LB V0, -32718(GP)
9D004A88  1040000B   BEQ V0, ZERO, 0x9D004AB8
9D004A8C  93828011   LBU V0, -32751(GP)
523:                       cstack[++cp]=(int)here;
9D004A90  24420001   ADDIU V0, V0, 1
9D004A94  7C021420   SEB V0, V0
9D004A98  A3828011   SB V0, -32751(GP)
9D004A9C  00021080   SLL V0, V0, 2
9D004AA0  3C03A000   LUI V1, -24576
9D004AA4  24632830   ADDIU V1, V1, 10288
9D004AA8  00431021   ADDU V0, V0, V1
9D004AAC  8F83CAA0   LW V1, -13664(GP)
9D004AB0  03E00008   JR RA
9D004AB4  AC430000   SW V1, 0(V0)
524:                     else
525:                       cstack[++cp]=(int)cip;
9D004AB8  24420001   ADDIU V0, V0, 1
9D004ABC  7C021420   SEB V0, V0
9D004AC0  A3828011   SB V0, -32751(GP)
9D004AC4  00021080   SLL V0, V0, 2
9D004AC8  3C03A000   LUI V1, -24576
9D004ACC  24632830   ADDIU V1, V1, 10288
9D004AD0  00431021   ADDU V0, V0, V1
9D004AD4  8F83806C   LW V1, -32660(GP)
9D004AD8  03E00008   JR RA
9D004ADC  AC430000   SW V1, 0(V0)
526:                 }//compile_begin()
527:                 
528:                 void compile_again(){//again
529:                     code_ptr there,cptr;
530:                     if (state) cptr=here;else cptr=cip;
9D004AE0  83828032   LB V0, -32718(GP)
9D004AE4  50400002   BEQL V0, ZERO, 0x9D004AF0
9D004AE8  8F82806C   LW V0, -32660(GP)
9D004AEC  8F82CAA0   LW V0, -13664(GP)
531:                     there=(code_ptr)cstack[cp--];
9D004AF0  83838011   LB V1, -32751(GP)
9D004AF4  00032880   SLL A1, V1, 2
9D004AF8  3C04A000   LUI A0, -24576
9D004AFC  24842830   ADDIU A0, A0, 10288
9D004B00  00A42021   ADDU A0, A1, A0
9D004B04  8C850000   LW A1, 0(A0)
9D004B08  2463FFFF   ADDIU V1, V1, -1
9D004B0C  A3838011   SB V1, -32751(GP)
532:                     *cptr++=IBRA;
9D004B10  24030006   ADDIU V1, ZERO, 6
9D004B14  A0430000   SB V1, 0(V0)
9D004B18  24440001   ADDIU A0, V0, 1
533:                     *cptr++=there-cptr-1;
9D004B1C  24A3FFFF   ADDIU V1, A1, -1
9D004B20  00641823   SUBU V1, V1, A0
9D004B24  A0430001   SB V1, 1(V0)
534:                     if (state) here=cptr;else cip=cptr;
9D004B28  83838032   LB V1, -32718(GP)
9D004B2C  10600003   BEQ V1, ZERO, 0x9D004B3C
9D004B30  24420002   ADDIU V0, V0, 2
9D004B34  03E00008   JR RA
9D004B38  AF82CAA0   SW V0, -13664(GP)
9D004B3C  03E00008   JR RA
9D004B40  AF82806C   SW V0, -32660(GP)
535:                 }// compile_again()
536:                 
537:                 void compile_while(){ // while
538:                     code_ptr there,cptr;
539:                     if (state) cptr=here;else cptr=cip;
9D004B44  83828032   LB V0, -32718(GP)
9D004B48  50400002   BEQL V0, ZERO, 0x9D004B54
9D004B4C  8F82806C   LW V0, -32660(GP)
9D004B50  8F82CAA0   LW V0, -13664(GP)
540:                     *cptr++=IQBRAZ;
9D004B54  2403003B   ADDIU V1, ZERO, 59
9D004B58  A0430000   SB V1, 0(V0)
9D004B5C  24440001   ADDIU A0, V0, 1
541:                     cstack[++cp]=(int)cptr;
9D004B60  93838011   LBU V1, -32751(GP)
9D004B64  24630001   ADDIU V1, V1, 1
9D004B68  7C031C20   SEB V1, V1
9D004B6C  A3838011   SB V1, -32751(GP)
9D004B70  00031880   SLL V1, V1, 2
9D004B74  3C05A000   LUI A1, -24576
9D004B78  24A52830   ADDIU A1, A1, 10288
9D004B7C  00651821   ADDU V1, V1, A1
9D004B80  AC640000   SW A0, 0(V1)
542:                     cptr++;
543:                     if (state) here=cptr;else cip=cptr;
9D004B84  83838032   LB V1, -32718(GP)
9D004B88  10600003   BEQ V1, ZERO, 0x9D004B98
9D004B8C  24420002   ADDIU V0, V0, 2
9D004B90  03E00008   JR RA
9D004B94  AF82CAA0   SW V0, -13664(GP)
9D004B98  03E00008   JR RA
9D004B9C  AF82806C   SW V0, -32660(GP)
544:                 }// compile_while()
545:                 
546:                 void compile_repeat(){//rept
547:                     code_ptr there,therew,cptr;
548:                     if (state) cptr=here;else cptr=cip;
9D004BA0  83828032   LB V0, -32718(GP)
9D004BA4  50400002   BEQL V0, ZERO, 0x9D004BB0
9D004BA8  8F82806C   LW V0, -32660(GP)
9D004BAC  8F82CAA0   LW V0, -13664(GP)
549:                     therew=(code_ptr)cstack[cp--]; // while référence avant
9D004BB0  83848011   LB A0, -32751(GP)
9D004BB4  00042880   SLL A1, A0, 2
9D004BB8  3C03A000   LUI V1, -24576
9D004BBC  24632830   ADDIU V1, V1, 10288
9D004BC0  00A32821   ADDU A1, A1, V1
9D004BC4  8CA50000   LW A1, 0(A1)
9D004BC8  2484FFFF   ADDIU A0, A0, -1
9D004BCC  7C042420   SEB A0, A0
550:                     there=(code_ptr)cstack[cp--]; // begin référence avant
9D004BD0  00043080   SLL A2, A0, 2
9D004BD4  00C31821   ADDU V1, A2, V1
9D004BD8  8C630000   LW V1, 0(V1)
9D004BDC  2484FFFF   ADDIU A0, A0, -1
9D004BE0  A3848011   SB A0, -32751(GP)
551:                     *cptr++=IBRA;
9D004BE4  24040006   ADDIU A0, ZERO, 6
9D004BE8  A0440000   SB A0, 0(V0)
9D004BEC  24440001   ADDIU A0, V0, 1
552:                     *cptr++=there-cptr-1; // saut arrière vers BEGIN
9D004BF0  306300FF   ANDI V1, V1, 255
9D004BF4  2466FFFF   ADDIU A2, V1, -1
9D004BF8  00C42023   SUBU A0, A2, A0
9D004BFC  A0440001   SB A0, 1(V0)
9D004C00  24420002   ADDIU V0, V0, 2
553:                     *therew=cptr-there-1; // saut avant du while après rept
9D004C04  00031827   NOR V1, ZERO, V1
9D004C08  00621821   ADDU V1, V1, V0
9D004C0C  A0A30000   SB V1, 0(A1)
554:                     if (state) here=cptr;else cip=cptr;
9D004C10  83838032   LB V1, -32718(GP)
9D004C14  50600003   BEQL V1, ZERO, 0x9D004C24
9D004C18  AF82806C   SW V0, -32660(GP)
9D004C1C  03E00008   JR RA
9D004C20  AF82CAA0   SW V0, -13664(GP)
9D004C24  03E00008   JR RA
9D004C28  00000000   NOP
555:                 }//compile_repeat()
556:                 
557:                 void compile_until(){// until
558:                     code_ptr there, cptr;
559:                     if (state) cptr=here;else cptr=cip;
9D004C2C  83828032   LB V0, -32718(GP)
9D004C30  50400002   BEQL V0, ZERO, 0x9D004C3C
9D004C34  8F82806C   LW V0, -32660(GP)
9D004C38  8F82CAA0   LW V0, -13664(GP)
560:                     there=(code_ptr)cstack[cp--];
9D004C3C  83838011   LB V1, -32751(GP)
9D004C40  00032880   SLL A1, V1, 2
9D004C44  3C04A000   LUI A0, -24576
9D004C48  24842830   ADDIU A0, A0, 10288
9D004C4C  00A42021   ADDU A0, A1, A0
9D004C50  8C850000   LW A1, 0(A0)
9D004C54  2463FFFF   ADDIU V1, V1, -1
9D004C58  A3838011   SB V1, -32751(GP)
561:                     *cptr++=IQBRAZ;
9D004C5C  2403003B   ADDIU V1, ZERO, 59
9D004C60  A0430000   SB V1, 0(V0)
9D004C64  24440001   ADDIU A0, V0, 1
562:                     *cptr++=there-cptr-1;
9D004C68  24A3FFFF   ADDIU V1, A1, -1
9D004C6C  00641823   SUBU V1, V1, A0
9D004C70  A0430001   SB V1, 1(V0)
563:                     if (state) here=cptr;else cip=cptr;
9D004C74  83838032   LB V1, -32718(GP)
9D004C78  10600003   BEQ V1, ZERO, 0x9D004C88
9D004C7C  24420002   ADDIU V0, V0, 2
9D004C80  03E00008   JR RA
9D004C84  AF82CAA0   SW V0, -13664(GP)
9D004C88  03E00008   JR RA
9D004C8C  AF82806C   SW V0, -32660(GP)
564:                 }// compile_until()
565:                 
566:                 int compile_token(int code){
9D005584  27BDFFD8   ADDIU SP, SP, -40
9D005588  AFBF0024   SW RA, 36(SP)
9D00558C  AFB10020   SW S1, 32(SP)
9D005590  AFB0001C   SW S0, 28(SP)
9D00562C  3C03A000   LUI V1, -24576
9D005630  246324C0   ADDIU V1, V1, 9408
9D005634  00621821   ADDU V1, V1, V0
567:                     int i;
568:                     code_ptr cptr;
569:                     if (state) cptr=here;else cptr=cip;
9D005594  83828032   LB V0, -32718(GP)
9D005598  10400003   BEQ V0, ZERO, 0x9D0055A8
9D00559C  00808021   ADDU S0, A0, ZERO
9D0055A0  0B40156B   J 0x9D0055AC
9D0055A4  8F91CAA0   LW S1, -13664(GP)
9D0055A8  8F91806C   LW S1, -32660(GP)
570:                     if (code==ILIT || code==ICLIT || code == IWLIT){
9D0055AC  24020003   ADDIU V0, ZERO, 3
9D0055B0  12020007   BEQ S0, V0, 0x9D0055D0
9D0055B4  00000000   NOP
9D0055B8  24020027   ADDIU V0, ZERO, 39
9D0055BC  12020004   BEQ S0, V0, 0x9D0055D0
9D0055C0  00000000   NOP
9D0055C4  24020028   ADDIU V0, ZERO, 40
9D0055C8  56020009   BNEL S0, V0, 0x9D0055F0
9D0055CC  24020029   ADDIU V0, ZERO, 41
571:                         word(SPC);
9D0055D0  0F401392   JAL word
9D0055D4  24040020   ADDIU A0, ZERO, 32
572:                         upper();
9D0055D8  0F40137C   JAL upper
9D0055DC  00000000   NOP
573:                         try_integer();
9D0055E0  0F401528   JAL try_integer
9D0055E4  00000000   NOP
9D0055E8  0B4015E5   J 0x9D005794
9D0055EC  83828032   LB V0, -32718(GP)
574:                     } else if (code==IDOTQ){
9D0055F0  16020047   BNE S0, V0, 0x9D005710
9D0055F4  24020004   ADDIU V0, ZERO, 4
575:                         for(i=current;i<ctib && tib[i]!='"';i++);
9D0055F8  83888068   LB T0, -32664(GP)
9D0055FC  AFA80010   SW T0, 16(SP)
9D005600  83868075   LB A2, -32651(GP)
9D005604  0106102A   SLT V0, T0, A2
9D005608  10400016   BEQ V0, ZERO, 0x9D005664
9D00560C  01002821   ADDU A1, T0, ZERO
9D005610  3C02A000   LUI V0, -24576
9D005614  244224C0   ADDIU V0, V0, 9408
9D005618  00481021   ADDU V0, V0, T0
9D00561C  80430000   LB V1, 0(V0)
9D005620  24020022   ADDIU V0, ZERO, 34
9D005624  1062000F   BEQ V1, V0, 0x9D005664
9D005628  25020001   ADDIU V0, T0, 1
9D005638  24070022   ADDIU A3, ZERO, 34
9D00563C  0046202A   SLT A0, V0, A2
9D005640  14800003   BNE A0, ZERO, 0x9D005650
9D005644  00402821   ADDU A1, V0, ZERO
9D005648  0B401599   J 0x9D005664
9D00564C  AFA20010   SW V0, 16(SP)
9D005650  80640000   LB A0, 0(V1)
9D005654  24420001   ADDIU V0, V0, 1
9D005658  1487FFF8   BNE A0, A3, 0x9D00563C
9D00565C  24630001   ADDIU V1, V1, 1
9D005660  AFA50010   SW A1, 16(SP)
576:                         first=current;
9D005664  A3888074   SB T0, -32652(GP)
577:                         last=i-1;
9D005668  24A2FFFF   ADDIU V0, A1, -1
9D00566C  7C021420   SEB V0, V0
9D005670  A3828060   SB V0, -32672(GP)
578:                         if (tib[i]=='"') i++;
9D005674  3C03A000   LUI V1, -24576
9D005678  246324C0   ADDIU V1, V1, 9408
9D00567C  00A31821   ADDU V1, A1, V1
9D005680  80640000   LB A0, 0(V1)
9D005684  24030022   ADDIU V1, ZERO, 34
9D005688  14830004   BNE A0, V1, 0x9D00569C
9D00568C  8FA30010   LW V1, 16(SP)
9D005690  24A50001   ADDIU A1, A1, 1
9D005694  AFA50010   SW A1, 16(SP)
579:                         current=i;
9D005698  8FA30010   LW V1, 16(SP)
9D00569C  A3838068   SB V1, -32664(GP)
580:                         i=last-first+1;
9D0056A0  00484023   SUBU T0, V0, T0
9D0056A4  25080001   ADDIU T0, T0, 1
581:                         if (i>0){
9D0056A8  19000039   BLEZ T0, 0x9D005790
9D0056AC  AFA80010   SW T0, 16(SP)
582:                             *cptr++=IDOTQ;
9D0056B0  24020029   ADDIU V0, ZERO, 41
9D0056B4  A2220000   SB V0, 0(S1)
583:                             *cptr++=i;
9D0056B8  8FA20010   LW V0, 16(SP)
9D0056BC  A2220001   SB V0, 1(S1)
584:                             for (i=first;i<=last;i++) *cptr++=tib[i];
9D0056C0  83828074   LB V0, -32652(GP)
9D0056C4  AFA20010   SW V0, 16(SP)
9D0056C8  83838060   LB V1, -32672(GP)
9D0056CC  0062182A   SLT V1, V1, V0
9D0056D0  1460002F   BNE V1, ZERO, 0x9D005790
9D0056D4  26310002   ADDIU S1, S1, 2
9D0056D8  3C04A000   LUI A0, -24576
9D0056DC  248424C0   ADDIU A0, A0, 9408
9D0056E0  00441021   ADDU V0, V0, A0
9D0056E4  90420000   LBU V0, 0(V0)
9D0056E8  A2220000   SB V0, 0(S1)
9D0056EC  8FA20010   LW V0, 16(SP)
9D0056F0  24420001   ADDIU V0, V0, 1
9D0056F4  AFA20010   SW V0, 16(SP)
9D0056F8  83838060   LB V1, -32672(GP)
9D0056FC  0062182A   SLT V1, V1, V0
9D005700  1060FFF7   BEQ V1, ZERO, 0x9D0056E0
9D005704  26310001   ADDIU S1, S1, 1
585:                         }
586:                     } else if (code==IFCALL || code== IRCALL || code==IBRA|| code==IQBRA){
9D005710  12020007   BEQ S0, V0, 0x9D005730
9D005714  2402002B   ADDIU V0, ZERO, 43
9D005718  12020005   BEQ S0, V0, 0x9D005730
9D00571C  24020006   ADDIU V0, ZERO, 6
9D005720  12020003   BEQ S0, V0, 0x9D005730
9D005724  24020007   ADDIU V0, ZERO, 7
9D005728  56020018   BNEL S0, V0, 0x9D00578C
9D00572C  A2300000   SB S0, 0(S1)
587:                         *cptr++=code;
9D005730  A2300000   SB S0, 0(S1)
9D005734  26310001   ADDIU S1, S1, 1
588:                         word(SPC);
9D005738  0F401392   JAL word
9D00573C  24040020   ADDIU A0, ZERO, 32
589:                         upper();
9D005740  0F40137C   JAL upper
9D005744  00000000   NOP
590:                         if (parse_int(&i)){
9D005748  0F4014D4   JAL parse_int
9D00574C  27A40010   ADDIU A0, SP, 16
9D005750  10400010   BEQ V0, ZERO, 0x9D005794
9D005754  83828032   LB V0, -32718(GP)
591:                             *cptr++=i;
9D005758  8FA20010   LW V0, 16(SP)
9D00575C  A2220000   SB V0, 0(S1)
592:                             if (code==IFCALL || code==IRCALL) *cptr++= (i>>8);
9D005760  24020004   ADDIU V0, ZERO, 4
9D005764  12020004   BEQ S0, V0, 0x9D005778
9D005768  26310001   ADDIU S1, S1, 1
9D00576C  2402002B   ADDIU V0, ZERO, 43
9D005770  16020008   BNE S0, V0, 0x9D005794
9D005774  83828032   LB V0, -32718(GP)
9D005778  8FA20010   LW V0, 16(SP)
9D00577C  00021203   SRA V0, V0, 8
9D005780  A2220000   SB V0, 0(S1)
9D005784  0B4015E4   J 0x9D005790
9D005788  26310001   ADDIU S1, S1, 1
593:                         }
594:                     }else {
595:                         *cptr++=code;
9D00578C  26310001   ADDIU S1, S1, 1
596:                     }
597:                     if (state) here=cptr;else cip=cptr;
9D005708  0B4015E5   J 0x9D005794
9D00570C  83828032   LB V0, -32718(GP)
9D005790  83828032   LB V0, -32718(GP)
9D005794  50400002   BEQL V0, ZERO, 0x9D0057A0
9D005798  AF91806C   SW S1, -32660(GP)
9D00579C  AF91CAA0   SW S1, -13664(GP)
598:                     return !error;
9D0057A0  83828033   LB V0, -32717(GP)
599:                 }// compile_token()
9D0057A4  2C420001   SLTIU V0, V0, 1
9D0057A8  8FBF0024   LW RA, 36(SP)
9D0057AC  8FB10020   LW S1, 32(SP)
9D0057B0  8FB0001C   LW S0, 28(SP)
9D0057B4  03E00008   JR RA
9D0057B8  27BD0028   ADDIU SP, SP, 40
600:                 
601:                 
602:                 //void print_integer(int n){
603:                 //    int i;
604:                 //    char sign;
605:                 //    if (n<0){sign='-';n=abs(n);}else sign=' ';
606:                 //    pad[11]=0;
607:                 //    i=10;
608:                 //    while (n){
609:                 //       pad[i--]= '0'+ n%10;
610:                 //       n /=10;
611:                 //    }
612:                 //    if (i==10) pad[i]='0'; else (sign=='-')?pad[i]=sign:i++;
613:                 //    UartPrint(STDOUT,&pad[i]);
614:                 //    UartPrint(STDOUT," ");
615:                 //}// print_integer()
616:                 
617:                 int compile_run(){ // analyse le contenu de TIB
9D005820  27BDFFE8   ADDIU SP, SP, -24
9D005824  AFBF0014   SW RA, 20(SP)
9D005828  AFB00010   SW S0, 16(SP)
618:                     int code;
619:                     imm_code=here+256;
9D00582C  8F82CAA0   LW V0, -13664(GP)
9D005830  24420100   ADDIU V0, V0, 256
9D005834  AF828064   SW V0, -32668(GP)
620:                     cip=imm_code;
9D005838  AF82806C   SW V0, -32660(GP)
621:                     current=0;
9D00583C  A3808068   SB ZERO, -32664(GP)
622:                     name_hash nh;
623:                     state=IMMEDIATE;
9D005840  A3808032   SB ZERO, -32718(GP)
624:                     error=0;
625:                     while (!error && current<ctib){
9D005844  0B401633   J 0x9D0058CC
9D005848  A3808033   SB ZERO, -32717(GP)
9D0058CC  83828033   LB V0, -32717(GP)
9D0058D0  1440001A   BNE V0, ZERO, 0x9D00593C
9D0058D4  83838068   LB V1, -32664(GP)
9D0058D8  83828075   LB V0, -32651(GP)
9D0058DC  0062102A   SLT V0, V1, V0
9D0058E0  1440FFDA   BNE V0, ZERO, 0x9D00584C
9D0058E4  83828032   LB V0, -32718(GP)
9D0058E8  0B401654   J 0x9D005950
9D0058EC  00000000   NOP
626:                         word(SPC);
9D00584C  0F401392   JAL word
9D005850  24040020   ADDIU A0, ZERO, 32
627:                         nh = hash();
9D005854  0F401324   JAL hash
9D005858  00000000   NOP
9D00585C  00408021   ADDU S0, V0, ZERO
628:                         if (!(try_user(nh)||try_system(nh)||try_token(nh)||try_integer())){
9D005860  0F401467   JAL try_user
9D005864  00402021   ADDU A0, V0, ZERO
9D005868  14400019   BNE V0, ZERO, 0x9D0058D0
9D00586C  83828033   LB V0, -32717(GP)
9D005870  0F401496   JAL try_system
9D005874  02002021   ADDU A0, S0, ZERO
9D005878  14400015   BNE V0, ZERO, 0x9D0058D0
9D00587C  83828033   LB V0, -32717(GP)
9D005880  0F4015EF   JAL try_token
9D005884  02002021   ADDU A0, S0, ZERO
9D005888  14400011   BNE V0, ZERO, 0x9D0058D0
9D00588C  83828033   LB V0, -32717(GP)
9D005890  0F401528   JAL try_integer
9D005894  00000000   NOP
9D005898  5440000D   BNEL V0, ZERO, 0x9D0058D0
9D00589C  83828033   LB V0, -32717(GP)
629:                             print(comm_channel, "erreur de compilation, position: ");
9D0058A0  83848038   LB A0, -32712(GP)
9D0058A4  3C059D01   LUI A1, -25343
9D0058A8  0F401DDD   JAL print
9D0058AC  24A59978   ADDIU A1, A1, -26248
630:                             print_int(comm_channel, first+1,6);
9D0058B0  83858074   LB A1, -32652(GP)
9D0058B4  83848038   LB A0, -32712(GP)
9D0058B8  24A50001   ADDIU A1, A1, 1
9D0058BC  0F401E0F   JAL print_int
9D0058C0  24060006   ADDIU A2, ZERO, 6
631:                             return 1;
9D0058C4  0B401650   J 0x9D005940
9D0058C8  24020001   ADDIU V0, ZERO, 1
632:                         }
633:                     }//while (current<ctib)
634:                     if (!(error || state)){
9D005950  5040FFE7   BEQL V0, ZERO, 0x9D0058F0
9D005954  8F82806C   LW V0, -32660(GP)
635:                         *cip=IBYE;
9D0058F0  A0400000   SB ZERO, 0(V0)
636:                         code = StackVM((const unsigned char*)imm_code);
9D0058F4  0F400CB9   JAL 0x9D0032E4
9D0058F8  8F848064   LW A0, -32668(GP)
9D0058FC  00408021   ADDU S0, V0, ZERO
637:                         if (code){
9D005900  1200000F   BEQ S0, ZERO, 0x9D005940
9D005904  00001021   ADDU V0, ZERO, ZERO
638:                             UartPrint(STDOUT,"Erreur opcode VM: ");
9D005908  24040001   ADDIU A0, ZERO, 1
9D00590C  3C059D01   LUI A1, -25343
9D005910  0F4021F2   JAL UartPrint
9D005914  24A5999C   ADDIU A1, A1, -26212
639:                             print_int(SERIAL_CON,code,2);
9D005918  24040001   ADDIU A0, ZERO, 1
9D00591C  02002821   ADDU A1, S0, ZERO
9D005920  0F401E0F   JAL print_int
9D005924  24060002   ADDIU A2, ZERO, 2
640:                             UartPutch(STDOUT,'\r');
9D005928  24040001   ADDIU A0, ZERO, 1
9D00592C  0F4021BA   JAL UartPutch
9D005930  2405000D   ADDIU A1, ZERO, 13
641:                             return 1;
9D005934  0B401650   J 0x9D005940
9D005938  24020001   ADDIU V0, ZERO, 1
642:                         }
643:                     }
644:                     return 0;
9D00593C  00001021   ADDU V0, ZERO, ZERO
9D005958  0B401650   J 0x9D005940
9D00595C  00001021   ADDU V0, ZERO, ZERO
645:                 }// compile_run()
9D005940  8FBF0014   LW RA, 20(SP)
9D005944  8FB00010   LW S0, 16(SP)
9D005948  03E00008   JR RA
9D00594C  27BD0018   ADDIU SP, SP, 24
646:                 
647:                 
648:                 void vpForth(){ // démarrage système forth en mode interpréteur
9D005960  27BDFFE0   ADDIU SP, SP, -32
9D005964  AFBF001C   SW RA, 28(SP)
9D005968  AFB10018   SW S1, 24(SP)
9D00596C  AFB00014   SW S0, 20(SP)
649:                     here=(unsigned char *)&ram_code;
9D005970  3C02A000   LUI V0, -24576
9D005974  24422848   ADDIU V0, V0, 10312
9D005978  AF82CAA0   SW V0, -13664(GP)
650:                 //    comm_channel=SERIAL_CON;
651:                     print(comm_channel,SYSTEM_NAME);
9D00597C  83848038   LB A0, -32712(GP)
9D005980  3C059D01   LUI A1, -25343
9D005984  0F401DDD   JAL print
9D005988  24A599B0   ADDIU A1, A1, -26192
652:                     print(comm_channel,SYSTEM_VERSION);
9D00598C  83848038   LB A0, -32712(GP)
9D005990  3C059D01   LUI A1, -25343
9D005994  0F401DDD   JAL print
9D005998  24A599BC   ADDIU A1, A1, -26180
653:                     while (1){
654:                         if ((ctib=readline(comm_channel, &tib[0],TIB_SIZE-1))){
9D00599C  3C10A000   LUI S0, -24576
9D0059A0  261024C0   ADDIU S0, S0, 9408
9D0059AC  83848038   LB A0, -32712(GP)
9D0059B0  02002821   ADDU A1, S0, ZERO
9D0059B4  0F401F23   JAL readline
9D0059B8  2406004F   ADDIU A2, ZERO, 79
9D0059BC  7C021420   SEB V0, V0
9D0059C0  10400007   BEQ V0, ZERO, 0x9D0059E0
9D0059C4  A3828075   SB V0, -32651(GP)
655:                             cursor_right();
9D0059C8  0F401D0A   JAL cursor_right
9D0059CC  00000000   NOP
656:                             if (compile_run()) break;
9D0059D0  0F401608   JAL compile_run
9D0059D4  00000000   NOP
9D0059D8  14400006   BNE V0, ZERO, 0x9D0059F4
9D0059DC  8FBF001C   LW RA, 28(SP)
657:                         }
658:                         print(comm_channel, " ok\r");
9D0059A4  3C119D01   LUI S1, -25343
9D0059A8  263199C4   ADDIU S1, S1, -26172
9D0059E0  83848038   LB A0, -32712(GP)
9D0059E4  0F401DDD   JAL print
9D0059E8  02202821   ADDU A1, S1, ZERO
659:                     }// while(1)
9D0059EC  0B40166C   J 0x9D0059B0
9D0059F0  83848038   LB A0, -32712(GP)
660:                 }//tForth()
9D0059F4  8FB10018   LW S1, 24(SP)
9D0059F8  8FB00014   LW S0, 20(SP)
9D0059FC  03E00008   JR RA
9D005A00  27BD0020   ADDIU SP, SP, 32
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/vpForth/vm.S  -------------------------------------------
                                                  1:     /*
                                                  2:     * Copyright 2013, Jacques Deschênes
                                                  3:     * This file is part of VPC-32.
                                                  4:     *
                                                  5:     *     VPC-32 is free software: you can redistribute it and/or modify
                                                  6:     *     it under the terms of the GNU General Public License as published by
                                                  7:     *     the Free Software Foundation, either version 3 of the License, or
                                                  8:     *     (at your option) any later version.
                                                  9:     *
                                                  10:    *     VPC-32 is distributed in the hope that it will be useful,
                                                  11:    *     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                                  12:    *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                                  13:    *     GNU General Public License for more details.
                                                  14:    *
                                                  15:    *     You should have received a copy of the GNU General Public License
                                                  16:    *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
                                                  17:    */
                                                  18:    
                                                  19:    /*
                                                  20:     * File:   vm.S
                                                  21:     * Author: Jacques Deschênes
                                                  22:     *
                                                  23:     * Created on 31 mai 2013
                                                  24:     *  machine viruelle à piles qui est utilisée comme
                                                  25:     *  modèle d'exécution par vpForth.
                                                  26:     */
                                                  27:    
                                                  28:    #include <p32xxxx.h>
                                                  29:    #include "opcodes.h"
                                                  30:    
                                                  31:    .extern put_char
                                                  32:    .extern get_key
                                                  33:    .extern wait_key
                                                  34:    .extern sys_tick
                                                  35:    .extern print_int
                                                  36:    .extern print_hex
                                                  37:    .extern readline
                                                  38:    .extern comm_channel
                                                  39:    
                                                  40:    /*
                                                  41:    RAM_SEG=0xA000
                                                  42:    CODE_SEG=0x9D00
                                                  43:    SFR_SEG=0xBF88
                                                  44:    */
                                                  45:    /*
                                                  46:    #define RAM_SEG  0xA000
                                                  47:    #define CODE_SEG 0x9D00
                                                  48:    #define SFR_SEG  0xBF88
                                                  49:    */
                                                  50:    
                                                  51:    /* constantes */
                                                  52:    FLASH_SIZE=2048
                                                  53:    CELL_SIZE=4
                                                  54:    
                                                  55:    RAM_SEG=0xA000
                                                  56:    CODE_SEG=0x9D00
                                                  57:    SFR_SEG=0xBF88
                                                  58:    
                                                  59:    
                                                  60:    /* utilisation des regitres MIPS */
                                                  61:    ip=s0  /* pointeur d'instruction VM */
                                                  62:    dp=s1  /* pointeur pile de données */
                                                  63:    rp=s2  /* pointeur pile de contrôle */
                                                  64:    wp=s3 /* pointeur de travail */
                                                  65:    topd=s4 /* sommet de la pile des arguments */
                                                  66:    topr=s5 /* sommet de la pile de contrôle */
                                                  67:    
                                                  68:     # NOTE: les pointeurs de piles sont incrémentés avant l''empilement.
                                                  69:     #       et décrémenté après le dépilement.
                                                  70:    
                                                  71:        .macro _dpush  R   # empile le contenu de R
                                                  72:         addiu dp,dp, (CELL_SIZE)
                                                  73:         sw topd, 0(dp)
                                                  74:         addu topd,zero, \R
                                                  75:        .endm
                                                  76:    
                                                  77:        .macro _dpop  R=$0
                                                  78:        addu \R,zero, topd
                                                  79:        lw topd, 0(dp)
                                                  80:        addiu dp,dp,-(CELL_SIZE)
                                                  81:        .endm
                                                  82:    
                                                  83:        .macro _fetch_t R  # copie le contenu de topd dans R
                                                  84:        addu \R, topd, zero
                                                  85:        .endm
                                                  86:    
                                                  87:        .macro _store_t R  # met le contenu du registre R dans topd
                                                  88:        addu topd, \R, zero
                                                  89:        .endm
                                                  90:    
                                                  91:    
                                                  92:    
                                                  93:        .macro _fetch_n R, N  # copie le Nième élément de la pile dans R
                                                  94:        lw \R, -(\N-1)*4(dp)
                                                  95:        .endm
                                                  96:    
                                                  97:        .macro _store_n R, N  # copie R, N en N ième position de la pile
                                                  98:        sw \R, -(\N-1)*4(dp)
                                                  99:        .endm
                                                  100:   
                                                  101:   
                                                  102:       .macro _rpush   R   # empile R sur pile des retours
                                                  103:       addiu rp,rp,(CELL_SIZE)
                                                  104:       sw topr, 0(rp)
                                                  105:       addu topr, zero, \R  # move R -> topr
                                                  106:       .endm
                                                  107:   
                                                  108:       .macro _rpop  R  # dépile topr dans R
                                                  109:       addu \R, topr, zero
                                                  110:       lw topr, 0(rp)
                                                  111:       addiu rp,rp,-(CELL_SIZE)
                                                  112:       .endm
                                                  113:   
                                                  114:       .macro _fetch_r  R   # copie topr dans R
                                                  115:       addu \R, topr,zero
                                                  116:       .endm
                                                  117:   
                                                  118:       .macro _store_r R    # copie R dans topr
                                                  119:       addu topr, \R, zero
                                                  120:       .endm
                                                  121:   
                                                  122:       .macro _next        # next bytecode
                                                  123:       addiu ip,ip,1
                                                  124:       .endm
                                                  125:   
                                                  126:       .macro ld_bytecode R
                                                  127:       lb \R, 0(ip)
                                                  128:       .endm
                                                  129:   
                                                  130:   
                                                  131:       .macro _to_r    # >R
                                                  132:       _dpop wp
                                                  133:       _rpush wp
                                                  134:       .endm
                                                  135:   
                                                  136:       .macro _r_from  # R>
                                                  137:       _rpop t7
                                                  138:       _dpush t7
                                                  139:       .endm
                                                  140:   
                                                  141:   
                                                  142:       .macro _getch channel  # channel et un pointeur sur le device id.
                                                  143:       la a0, \channel
                                                  144:       jal get_key
                                                  145:       lb a0, 0(a0)
                                                  146:       .endm
                                                  147:   
                                                  148:       .macro _putch channel   # transmet le caractère qui est dans topd
                                                  149:       la a0, \channel
                                                  150:       lb a0, 0(a0)
                                                  151:       _dpop a1
                                                  152:       jal put_char
                                                  153:       nop
                                                  154:       .endm
                                                  155:   
                                                  156:       .macro ld_var R V  # charge le registre R avec le contenu du pointeur V
                                                  157:       la \R, \V
                                                  158:       lw \R, 0(\R)
                                                  159:       .endm
                                                  160:   
                                                  161:       DPRINT=1
                                                  162:   
                                                  163:       .macro _dbg_print N
                                                  164:       .if DPRINT
                                                  165:       jal dbg_print
                                                  166:       li a0, \N
                                                  167:       .endif
                                                  168:       .endm
                                                  169:   
                                                  170:       .macro _fn_enter N
                                                  171:       addiu sp, sp, -(\N)
                                                  172:       sw ra, (\N-4)(sp)
                                                  173:       .endm
                                                  174:       
                                                  175:       .macro _fn_exit N
                                                  176:       lw ra, (\N-4)(sp)
                                                  177:       j ra
                                                  178:       addiu sp,sp, \N
                                                  179:       .endm
                                                  180:   
                                                  181:   
                                                  182:   STDIO=1
                                                  183:   
                                                  184:   DSTACK_SIZE=128
                                                  185:   RSTACK_SIZE=128
                                                  186:   
                                                  187:   SFR_CLEAR=4
                                                  188:   SFR_SET=8
                                                  189:   SFR_INV=12
                                                  190:   
                                                  191:   .data
                                                  192:   .global base, dstack, rstack, here
                                                  193:   
                                                  194:   base: .word 10
                                                  195:   zsp: .word   dempty   # pile données position vide
                                                  196:   zrp: .word   rempty   # pile retour position vide
                                                  197:   
                                                  198:   .section .bss
                                                  199:   here: .word  0
                                                  200:   dempty:  .word 0    # pile vide
                                                  201:   dstack:  .space DSTACK_SIZE
                                                  202:   rempty:  .word 0    # pile vide
                                                  203:   rstack: .space RSTACK_SIZE
                                                  204:   
                                                  205:   .text
                                                  206:   .set noreorder
                                                  207:   .set macro
                                                  208:   .global StackVM,  flash_code
                                                  209:   # .global tokens
                                                  210:   .ent StackVM
                                                  211:   
                                                  212:   
                                                  213:   StackVM:
9D0032E4  27BDFFE0   ADDIU SP, SP, -32            214:       _fn_enter 32
9D0032E8  AFBF001C   SW RA, 28(SP)
9D0032EC  AFB00018   SW S0, 24(SP)                215:       sw  s0, 24(sp)
9D0032F0  AFB10014   SW S1, 20(SP)                216:       sw  s1, 20(sp)
9D0032F4  AFB20010   SW S2, 16(SP)                217:       sw  s2, 16(sp)
9D0032F8  AFB3000C   SW S3, 12(SP)                218:       sw  s3, 12(sp)
9D0032FC  AFB40008   SW S4, 8(SP)                 219:       sw  s4, 8(sp)
9D003300  AFB50004   SW S5, 4(SP)                 220:       sw  s5, 4(sp)
9D003304  00048021   ADDU S0, ZERO, A0            221:       addu ip, zero, a0  #buffer code passé en paramètre
9D003308  3C11A000   LUI S1, -24576               222:       la dp, dempty
9D00330C  26314A94   ADDIU S1, S1, 19092
9D003310  3C12A000   LUI S2, -24576               223:       la rp, rempty
9D003314  26524B18   ADDIU S2, S2, 19224
9D003318  3C13A000   LUI S3, -24576               224:       la wp, zsp
9D00331C  26734CC4   ADDIU S3, S3, 19652
9D003320  AE710000   SW S1, 0(S3)                 225:       sw dp, 0(wp)    // valeur de sp lorsque pile données vide.
9D003324  AE720004   SW S2, 4(S3)                 226:       sw rp, 4(wp)    // valeur de rp lorsque pile retour vide.
                                                  227:   
                                                  228:   vm:
9D003328  82080000   LB T0, 0(S0)                 229:       ld_bytecode t0
9D00332C  26100001   ADDIU S0, S0, 1              230:       _next
9D003330  2509FFB3   ADDIU T1, T0, -77            231:       addiu t1,t0, IBADOP
9D003334  1D200277   BGTZ T1, 0x9D003D14          232:       bgtz  t1, badop
9D003338  00084080   SLL T0, T0, 2                233:       sll   t0, t0, 2   
9D00333C  3C099D00   LUI T1, -25344               234:       la t1, opcodes_vectors
9D003340  25293E34   ADDIU T1, T1, 15924
9D003344  01284821   ADDU T1, T1, T0              235:       addu  t1,t1,t0
9D003348  8D290000   LW T1, 0(T1)                 236:       lw  t1, 0(t1)
9D00334C  01200008   JR T1                        237:       j   t1
9D003350  00000000   NOP                          238:       nop
                                                  239:   end:   # 'bye' ( -- ) sortie de la machine virtuelle
9D003354  00001026   XOR V0, ZERO, ZERO           240:       xor v0, zero,zero
9D003358  1000026F   BEQ ZERO, ZERO, 0x9D003D18   241:       b exit
9D00335C  00000000   NOP                          242:       nop
                                                  243:   
                                                  244:   qrx: # '?key' ( -- ch -1 | 0 )
9D003360  3C04A000   LUI A0, -24576               245:       _getch comm_channel
9D003364  24840028   ADDIU A0, A0, 40
9D003368  0F401EE3   JAL get_key
9D00336C  80840000   LB A0, 0(A0)
9D003370  26310004   ADDIU S1, S1, 4              246:       _dpush v0
9D003374  AE340000   SW S4, 0(S1)
9D003378  0002A021   ADDU S4, ZERO, V0
9D00337C  1040FFEA   BEQ V0, ZERO, 0x9D003328     247:       beq v0, zero, vm
9D003380  00000000   NOP                          248:       nop
9D003384  2408FFFF   ADDIU T0, ZERO, -1           249:       addiu t0,zero,-1
9D003388  26310004   ADDIU S1, S1, 4              250:       _dpush t0
9D00338C  AE340000   SW S4, 0(S1)
9D003390  0008A021   ADDU S4, ZERO, T0
9D003394  1000FFE4   BEQ ZERO, ZERO, 0x9D003328   251:       b vm
9D003398  00000000   NOP                          252:       nop
                                                  253:   
                                                  254:   dot:  # '.'  ( n --  ) imprime entier n
9D00339C  3C13A000   LUI S3, -24576               255:       la wp, comm_channel
9D0033A0  26730028   ADDIU S3, S3, 40
9D0033A4  82640000   LB A0, 0(S3)                 256:       lb a0,0(wp)
9D0033A8  00142821   ADDU A1, ZERO, S4            257:       _dpop a1
9D0033AC  8E340000   LW S4, 0(S1)
9D0033B0  2631FFFC   ADDIU S1, S1, -4
9D0033B4  0F401E0F   JAL 0x9D00783C               258:       jal print_int
9D0033B8  24060001   ADDIU A2, ZERO, 1            259:       addiu a2,zero,1
9D0033BC  1000FFDA   BEQ ZERO, ZERO, 0x9D003328   260:       b vm
9D0033C0  00000000   NOP                          261:       nop
                                                  262:   
                                                  263:   emit:   # 'emit' ( ch -- ) transmet charactère au terminal
9D0033C4  3C04A000   LUI A0, -24576               264:       _putch comm_channel
9D0033C8  24840028   ADDIU A0, A0, 40
9D0033CC  80840000   LB A0, 0(A0)
9D0033D0  00142821   ADDU A1, ZERO, S4
9D0033D4  8E340000   LW S4, 0(S1)
9D0033D8  2631FFFC   ADDIU S1, S1, -4
9D0033DC  0F401D62   JAL put_char
9D0033E0  00000000   NOP
9D0033E4  1000FFD0   BEQ ZERO, ZERO, 0x9D003328   265:       b vm
9D0033E8  00000000   NOP                          266:       nop
                                                  267:   
                                                  268:   iemit:  # 'iemit' ( n -- ) transmet n comme 4 octet ordonné en little indian
9D0033EC  02802821   ADDU A1, S4, ZERO            269:       _fetch_t a1
9D0033F0  24080004   ADDIU T0, ZERO, 4            270:       li t0, 4
9D0033F4  26310004   ADDIU S1, S1, 4              271:       _dpush t0
9D0033F8  AE340000   SW S4, 0(S1)
9D0033FC  0008A021   ADDU S4, ZERO, T0
9D003400  3C13A000   LUI S3, -24576               272:       la wp, comm_channel
9D003404  26730028   ADDIU S3, S3, 40
                                                  273:   1:
9D003408  0F401D62   JAL 0x9D007588               274:       jal put_char
9D00340C  8E640000   LW A0, 0(S3)                 275:       lw a0,0(wp)
9D003410  2694FFFF   ADDIU S4, S4, -1             276:       addiu topd,-1
9D003414  12800006   BEQ S4, ZERO, 0x9D003430     277:       beqz topd, 2f
9D003418  00000000   NOP                          278:       nop
9D00341C  8E250000   LW A1, 0(S1)                 279:       _fetch_n a1, 1
9D003420  00052A02   SRL A1, A1, 8                280:       srl a1,a1,8
9D003424  AE250000   SW A1, 0(S1)                 281:       _store_n a1, 1
9D003428  1000FFF7   BEQ ZERO, ZERO, 0x9D003408   282:       b 1b
9D00342C  00000000   NOP                          283:       nop
                                                  284:   2:
9D003430  8E34FFFC   LW S4, -4(S1)                285:       lw topd, -(CELL_SIZE)(dp)
9D003434  2631FFF8   ADDIU S1, S1, -8             286:       addiu dp, dp, -2*(CELL_SIZE)
9D003438  1000FFBB   BEQ ZERO, ZERO, 0x9D003328   287:       b vm
9D00343C  00000000   NOP                          288:       nop
                                                  289:   
                                                  290:   lit:    # 'lit' ( -- n) empile un entier
9D003440  0F400F4F   JAL 0x9D003D3C               291:       jal fetch_int
9D003444  00000000   NOP                          292:       nop
9D003448  26310004   ADDIU S1, S1, 4              293:       _dpush v0
9D00344C  AE340000   SW S4, 0(S1)
9D003450  0002A021   ADDU S4, ZERO, V0
9D003454  1000FFB4   BEQ ZERO, ZERO, 0x9D003328   294:       b vm
9D003458  00000000   NOP                          295:       nop
                                                  296:   
                                                  297:   clit:       # 'clit' ( -- byte ) empile un octet signe étendu sur 32 bits
9D00345C  82080000   LB T0, 0(S0)                 298:       ld_bytecode t0
9D003460  26100001   ADDIU S0, S0, 1              299:       _next
9D003464  26310004   ADDIU S1, S1, 4              300:       _dpush t0
9D003468  AE340000   SW S4, 0(S1)
9D00346C  0008A021   ADDU S4, ZERO, T0
9D003470  1000FFAD   BEQ ZERO, ZERO, 0x9D003328   301:       b vm
9D003474  00000000   NOP                          302:       nop
                                                  303:   
                                                  304:   wlit:       # 'wlit' ( -- w16  ) empile un mot de 16 bits
9D003478  92080000   LBU T0, 0(S0)                305:       lbu t0, 0(ip)
9D00347C  26100001   ADDIU S0, S0, 1              306:       _next
9D003480  82090000   LB T1, 0(S0)                 307:       ld_bytecode t1
9D003484  26100001   ADDIU S0, S0, 1              308:       _next
9D003488  00094A00   SLL T1, T1, 8                309:       sll  t1,t1, 8
9D00348C  01094025   OR T0, T0, T1                310:       or  t0,t0,t1
9D003490  26310004   ADDIU S1, S1, 4              311:       _dpush t0
9D003494  AE340000   SW S4, 0(S1)
9D003498  0008A021   ADDU S4, ZERO, T0
9D00349C  1000FFA2   BEQ ZERO, ZERO, 0x9D003328   312:       b vm
9D0034A0  00000000   NOP                          313:       nop
                                                  314:   
                                                  315:   fcall:   # 'fcall' (R: -- addr_ret ) appelle sous-routine VM en mémoire flash
9D0034A4  3C0A9D00   LUI T2, -25344               316:       lui t2, CODE_SEG
9D0034A8  92080000   LBU T0, 0(S0)                317:       lbu t0, 0(ip)
                                                  318:   fcall_1:
9D0034AC  26100001   ADDIU S0, S0, 1              319:       _next
9D0034B0  92090000   LBU T1, 0(S0)                320:       lbu t1, 0(ip)
9D0034B4  26100001   ADDIU S0, S0, 1              321:       _next
9D0034B8  00094A00   SLL T1, T1, 8                322:       sll t1,t1,8
9D0034BC  01094025   OR T0, T0, T1                323:       or t0,t0,t1
9D0034C0  010A4025   OR T0, T0, T2                324:       or t0,t0,t2
9D0034C4  26520004   ADDIU S2, S2, 4              325:       _rpush ip
9D0034C8  AE550000   SW S5, 0(S2)
9D0034CC  0010A821   ADDU S5, ZERO, S0
9D0034D0  1000FF95   BEQ ZERO, ZERO, 0x9D003328   326:       b vm
9D0034D4  01008021   ADDU S0, T0, ZERO            327:       move ip, t0
                                                  328:   
                                                  329:   rcall:  # 'rcall' (R: -- addr_ret ) appelle sous-routine VM en mémoire RAM
9D0034D8  3C0AA000   LUI T2, -24576               330:       lui t2, RAM_SEG
9D0034DC  92080000   LBU T0, 0(S0)                331:       lbu t0, 0(ip)
9D0034E0  1000FFF2   BEQ ZERO, ZERO, 0x9D0034AC   332:       b fcall_1
9D0034E4  00000000   NOP                          333:       nop
                                                  334:   
                                                  335:   ret:        # ';' (R: addr_ret -- ) sortie de sous-routine
9D0034E8  3C09A000   LUI T1, -24576               336:       la t1, zrp    # vérifie si la pile est vide, si c''est le cas exit.
9D0034EC  25294CC8   ADDIU T1, T1, 19656
9D0034F0  8D290000   LW T1, 0(T1)                 337:       lw t1, 0(t1)
9D0034F4  11320208   BEQ T1, S2, 0x9D003D18       338:       beq t1,rp, exit # erreur accès pile retour vide
9D0034F8  00000000   NOP                          339:       nop
9D0034FC  02A08021   ADDU S0, S5, ZERO            340:       _rpop ip
9D003500  8E550000   LW S5, 0(S2)
9D003504  2652FFFC   ADDIU S2, S2, -4
9D003508  1000FF87   BEQ ZERO, ZERO, 0x9D003328   341:       b vm
9D00350C  00000000   NOP                          342:       nop
                                                  343:   
                                                  344:   bra:        # 'branch' ( -- ) branchement incondionnnel (adresse relative +127,-128)
9D003510  82080000   LB T0, 0(S0)                 345:       ld_bytecode t0
9D003514  26100001   ADDIU S0, S0, 1              346:       _next
9D003518  1000FF83   BEQ ZERO, ZERO, 0x9D003328   347:       b vm
9D00351C  02088021   ADDU S0, S0, T0              348:       addu ip, ip, t0   # branchement relative intervale -128 à +127
                                                  349:   
                                                  350:   qbra:       # '?bra' ( t|f -- ) branche si sommet pile est vrai (topd!=0)
9D003520  00144021   ADDU T0, ZERO, S4            351:       _dpop t0
9D003524  8E340000   LW S4, 0(S1)
9D003528  2631FFFC   ADDIU S1, S1, -4
9D00352C  1100FF7E   BEQ T0, ZERO, 0x9D003328     352:       beqz t0, vm
9D003530  26100001   ADDIU S0, S0, 1              353:       _next
9D003534  8208FFFF   LB T0, -1(S0)                354:       lb t0, -1(ip)
9D003538  1000FF7B   BEQ ZERO, ZERO, 0x9D003328   355:       b vm
9D00353C  02088021   ADDU S0, S0, T0              356:       addu ip,ip,t0
                                                  357:   
                                                  358:   qbraz:      # '?braz' ( t|f -- ) branche si sommet pile est faux (topd==0)
9D003540  00144021   ADDU T0, ZERO, S4            359:       _dpop t0
9D003544  8E340000   LW S4, 0(S1)
9D003548  2631FFFC   ADDIU S1, S1, -4
9D00354C  1500FF76   BNE T0, ZERO, 0x9D003328     360:       bne t0, zero, vm
9D003550  26100001   ADDIU S0, S0, 1              361:       _next
9D003554  8208FFFF   LB T0, -1(S0)                362:       lb t0, -1(ip)
9D003558  1000FF73   BEQ ZERO, ZERO, 0x9D003328   363:       b vm
9D00355C  02088021   ADDU S0, S0, T0              364:       addu ip,ip,t0
                                                  365:   
                                                  366:   exec:       # 'exec' ( addr -- ) appelle sous-routine à partir de la pile
9D003560  26520004   ADDIU S2, S2, 4              367:       _rpush ip
9D003564  AE550000   SW S5, 0(S2)
9D003568  0010A821   ADDU S5, ZERO, S0
9D00356C  00148021   ADDU S0, ZERO, S4            368:       _dpop ip
9D003570  8E340000   LW S4, 0(S1)
9D003574  2631FFFC   ADDIU S1, S1, -4
9D003578  1000FF6B   BEQ ZERO, ZERO, 0x9D003328   369:       b vm
9D00357C  00000000   NOP                          370:       nop
                                                  371:   
                                                  372:   store:      # '!' ( n addr -- )  variable = n
9D003580  00144021   ADDU T0, ZERO, S4            373:       _dpop t0
9D003584  8E340000   LW S4, 0(S1)
9D003588  2631FFFC   ADDIU S1, S1, -4
9D00358C  00144821   ADDU T1, ZERO, S4            374:       _dpop t1
9D003590  8E340000   LW S4, 0(S1)
9D003594  2631FFFC   ADDIU S1, S1, -4
9D003598  A1090000   SB T1, 0(T0)                 375:       sb t1, 0(t0)   # l''adresse n''est pas forcément alignée donc on y va octet par octet
9D00359C  00094A02   SRL T1, T1, 8                376:       srl t1,t1,8
9D0035A0  A1090001   SB T1, 1(T0)                 377:       sb t1,1(t0)
9D0035A4  00094A02   SRL T1, T1, 8                378:       srl t1,t1,8
9D0035A8  A1090002   SB T1, 2(T0)                 379:       sb t1,2(t0)
9D0035AC  00094A02   SRL T1, T1, 8                380:       srl t1,t1,8
9D0035B0  A1090003   SB T1, 3(T0)                 381:       sb t1,3(t0)
9D0035B4  1000FF5C   BEQ ZERO, ZERO, 0x9D003328   382:       b vm
9D0035B8  00000000   NOP                          383:       nop
                                                  384:   
                                                  385:   fetch:      # '@' ( addr -- n ) topd = variable
9D0035BC  02804021   ADDU T0, S4, ZERO            386:       _fetch_t t0
9D0035C0  91090000   LBU T1, 0(T0)                387:       lbu t1, 0(t0)   # l''adresse n''est pas forcément alignée donc on y va octet par octet
9D0035C4  910A0001   LBU T2, 1(T0)                388:       lbu t2, 1(t0)
9D0035C8  000A5200   SLL T2, T2, 8                389:       sll t2,t2,8
9D0035CC  012A4825   OR T1, T1, T2                390:       or t1,t1,t2
9D0035D0  910A0002   LBU T2, 2(T0)                391:       lbu t2, 2(t0)
9D0035D4  000A5400   SLL T2, T2, 16               392:       sll t2,t2,16
9D0035D8  012A4825   OR T1, T1, T2                393:       or t1,t1,t2
9D0035DC  910A0003   LBU T2, 3(T0)                394:       lbu t2, 3(t0)
9D0035E0  000A5600   SLL T2, T2, 24               395:       sll t2, 24
9D0035E4  012A4025   OR T0, T1, T2                396:       or t0,t1,t2
9D0035E8  1000FF4F   BEQ ZERO, ZERO, 0x9D003328   397:       b vm
9D0035EC  0100A021   ADDU S4, T0, ZERO            398:       _store_t t0
                                                  399:   
                                                  400:   cstore:     # 'c!' ( char addr --  ) variable = char
9D0035F0  00144021   ADDU T0, ZERO, S4            401:       _dpop t0
9D0035F4  8E340000   LW S4, 0(S1)
9D0035F8  2631FFFC   ADDIU S1, S1, -4
9D0035FC  00144821   ADDU T1, ZERO, S4            402:       _dpop t1
9D003600  8E340000   LW S4, 0(S1)
9D003604  2631FFFC   ADDIU S1, S1, -4
9D003608  A1090000   SB T1, 0(T0)                 403:       sb t1, 0(t0)
9D00360C  1000FF46   BEQ ZERO, ZERO, 0x9D003328   404:       b vm
9D003610  00000000   NOP                          405:       nop
                                                  406:   
                                                  407:   cfetch:     # 'c@' ( addr -- char )  topd= char
9D003614  02804021   ADDU T0, S4, ZERO            408:       addu t0, topd, zero
9D003618  81080000   LB T0, 0(T0)                 409:       lb t0, 0(t0)
9D00361C  1000FF42   BEQ ZERO, ZERO, 0x9D003328   410:       b vm
9D003620  0100A021   ADDU S4, T0, ZERO            411:       addu topd, t0, zero
                                                  412:   
                                                  413:   rpfetch:    # 'rp@' ( -- rp ) topd = rp
9D003624  26310004   ADDIU S1, S1, 4              414:       _dpush rp
9D003628  AE340000   SW S4, 0(S1)
9D00362C  0012A021   ADDU S4, ZERO, S2
9D003630  1000FF3D   BEQ ZERO, ZERO, 0x9D003328   415:       b vm
9D003634  00000000   NOP                          416:       nop
                                                  417:   
                                                  418:   rpstore:    # 'rp!' ( rp -- ) rp = topd
9D003638  00149021   ADDU S2, ZERO, S4            419:       _dpop rp
9D00363C  8E340000   LW S4, 0(S1)
9D003640  2631FFFC   ADDIU S1, S1, -4
9D003644  1000FF38   BEQ ZERO, ZERO, 0x9D003328   420:       b vm
9D003648  00000000   NOP                          421:       nop
                                                  422:   
                                                  423:   rfetch:     # 'r@' ( -- n ) (R: n -- n )
9D00364C  02A04021   ADDU T0, S5, ZERO            424:       _fetch_r t0
9D003650  26310004   ADDIU S1, S1, 4              425:       _dpush t0
9D003654  AE340000   SW S4, 0(S1)
9D003658  0008A021   ADDU S4, ZERO, T0
9D00365C  1000FF32   BEQ ZERO, ZERO, 0x9D003328   426:       b vm
9D003660  00000000   NOP                          427:       nop
                                                  428:   
                                                  429:   tor:        # >r ( n -- ) (R: -- n )
9D003664  00149821   ADDU S3, ZERO, S4            430:       _to_r
9D003668  8E340000   LW S4, 0(S1)
9D00366C  2631FFFC   ADDIU S1, S1, -4
9D003670  26520004   ADDIU S2, S2, 4
9D003674  AE550000   SW S5, 0(S2)
9D003678  0013A821   ADDU S5, ZERO, S3
9D00367C  1000FF2A   BEQ ZERO, ZERO, 0x9D003328   431:       b vm
9D003680  00000000   NOP                          432:       nop
                                                  433:   
                                                  434:   rfrom:      # 'r>' ( -- n ) (R: n -- )
9D003684  02A07821   ADDU T7, S5, ZERO            435:       _r_from
9D003688  8E550000   LW S5, 0(S2)
9D00368C  2652FFFC   ADDIU S2, S2, -4
9D003690  26310004   ADDIU S1, S1, 4
9D003694  AE340000   SW S4, 0(S1)
9D003698  000FA021   ADDU S4, ZERO, T7
9D00369C  1000FF22   BEQ ZERO, ZERO, 0x9D003328   436:       b vm
9D0036A0  00000000   NOP                          437:       nop
                                                  438:   
                                                  439:   spfetch:    #  'sp@' ( -- dp )
9D0036A4  02204021   ADDU T0, S1, ZERO            440:       move t0, dp
9D0036A8  26310004   ADDIU S1, S1, 4              441:       _dpush t0
9D0036AC  AE340000   SW S4, 0(S1)
9D0036B0  0008A021   ADDU S4, ZERO, T0
9D0036B4  1000FF1C   BEQ ZERO, ZERO, 0x9D003328   442:       b vm
9D0036B8  00000000   NOP                          443:       nop
                                                  444:   
                                                  445:   spstore:    # 'sp!' ( n -- )
9D0036BC  1000FF1A   BEQ ZERO, ZERO, 0x9D003328   446:       b vm
9D0036C0  02808821   ADDU S1, S4, ZERO            447:       move dp, topd
                                                  448:   
                                                  449:   zerosp:     # 'zsp' ( -- n) position du bas de la pile données
9D0036C4  3C08A000   LUI T0, -24576               450:       la t0, zsp
9D0036C8  25084CC4   ADDIU T0, T0, 19652
9D0036CC  8D080000   LW T0, 0(T0)                 451:       lw t0, 0(t0)
9D0036D0  26310004   ADDIU S1, S1, 4              452:       _dpush t0
9D0036D4  AE340000   SW S4, 0(S1)
9D0036D8  0008A021   ADDU S4, ZERO, T0
9D0036DC  1000FF12   BEQ ZERO, ZERO, 0x9D003328   453:       b vm
9D0036E0  00000000   NOP                          454:       nop
                                                  455:   
                                                  456:   zerorp:     # 'zrp' ( -- n ) position du base de la pile retours
9D0036E4  3C08A000   LUI T0, -24576               457:       la t0, zrp
9D0036E8  25084CC8   ADDIU T0, T0, 19656
9D0036EC  8D080000   LW T0, 0(T0)                 458:       lw t0, 0(t0)
9D0036F0  26310004   ADDIU S1, S1, 4              459:       _dpush t0
9D0036F4  AE340000   SW S4, 0(S1)
9D0036F8  0008A021   ADDU S4, ZERO, T0
9D0036FC  1000FF0A   BEQ ZERO, ZERO, 0x9D003328   460:       b vm
9D003700  00000000   NOP                          461:       nop
                                                  462:   
                                                  463:   ipfetch:        # 'ip@' ( -- ip ) empile la valeur courante du pointeur d''instructions
9D003704  26310004   ADDIU S1, S1, 4              464:       _dpush ip
9D003708  AE340000   SW S4, 0(S1)
9D00370C  0010A021   ADDU S4, ZERO, S0
9D003710  1000FF05   BEQ ZERO, ZERO, 0x9D003328   465:       b vm
9D003714  00000000   NOP                          466:       nop
                                                  467:   
                                                  468:   ipstore:        # 'ip!' ( ip -- ) initialise le pointeur d''insturctions
9D003718  00144021   ADDU T0, ZERO, S4            469:       _dpop t0
9D00371C  8E340000   LW S4, 0(S1)
9D003720  2631FFFC   ADDIU S1, S1, -4
9D003724  1000FF00   BEQ ZERO, ZERO, 0x9D003328   470:       b vm
9D003728  01008021   ADDU S0, T0, ZERO            471:       move ip, t0
                                                  472:   
                                                  473:   herefetch:  # 'here'  ( -- addr ) adresse de la variable here
9D00372C  3C08A000   LUI T0, -24576               474:       la t0, here
9D003730  25084A90   ADDIU T0, T0, 19088
9D003734  8D080000   LW T0, 0(T0)                 475:       lw t0, 0(t0)
9D003738  26310004   ADDIU S1, S1, 4              476:       _dpush t0
9D00373C  AE340000   SW S4, 0(S1)
9D003740  0008A021   ADDU S4, ZERO, T0
9D003744  1000FEF8   BEQ ZERO, ZERO, 0x9D003328   477:       b vm
9D003748  00000000   NOP                          478:       nop
                                                  479:   
                                                  480:   basefetch: # 'base' ( -- addr ) adresse de la variable here
9D00374C  3C08A000   LUI T0, -24576               481:       la t0, base
9D003750  25084CC0   ADDIU T0, T0, 19648
9D003754  8D080000   LW T0, 0(T0)                 482:       lw t0, 0(t0)
9D003758  26310004   ADDIU S1, S1, 4              483:       _dpush t0
9D00375C  AE340000   SW S4, 0(S1)
9D003760  0008A021   ADDU S4, ZERO, T0
9D003764  1000FEF0   BEQ ZERO, ZERO, 0x9D003328   484:       b vm
9D003768  00000000   NOP                          485:       nop
                                                  486:   
                                                  487:   drop:       # 'drop' ( n -- )
9D00376C  00144021   ADDU T0, ZERO, S4            488:       _dpop t0
9D003770  8E340000   LW S4, 0(S1)
9D003774  2631FFFC   ADDIU S1, S1, -4
9D003778  1000FEEB   BEQ ZERO, ZERO, 0x9D003328   489:       b vm
9D00377C  00000000   NOP                          490:       nop
                                                  491:   
                                                  492:   ddrop:      # '2drop' ( n1 n2 -- )
9D003780  8E34FFFC   LW S4, -4(S1)                493:       lw topd, -4(dp)
9D003784  1000FEE8   BEQ ZERO, ZERO, 0x9D003328   494:       b vm
9D003788  2631FFF8   ADDIU S1, S1, -8             495:       addiu dp,dp,-8
                                                  496:   
                                                  497:   dup:        # 'dup' ( n -- n n )
9D00378C  26310004   ADDIU S1, S1, 4              498:       addiu dp, dp, CELL_SIZE
9D003790  1000FEE5   BEQ ZERO, ZERO, 0x9D003328   499:       b vm
9D003794  AE340000   SW S4, 0(S1)                 500:       sw topd, 0(dp)
                                                  501:   
                                                  502:   
                                                  503:   ddup:       # '2dup' ( n1 n2 -- n1 n2 n1 n2 )
9D003798  26310008   ADDIU S1, S1, 8              504:       addiu dp, dp, 2*(CELL_SIZE)
9D00379C  AE34FFFC   SW S4, -4(S1)                505:       sw topd, -4(dp)
9D0037A0  8E28FFF8   LW T0, -8(S1)                506:       lw t0, -8(dp)
9D0037A4  1000FEE0   BEQ ZERO, ZERO, 0x9D003328   507:       b vm
9D0037A8  AE280000   SW T0, 0(S1)                 508:       sw t0, 0(dp)
                                                  509:   
                                                  510:   qdup:       # ?dup ( n -- n n | n ) duplique n si n!=0
9D0037AC  1280FEDE   BEQ S4, ZERO, 0x9D003328     511:       beqz topd, vm
9D0037B0  00000000   NOP                          512:       nop
9D0037B4  26310004   ADDIU S1, S1, 4              513:       addiu dp, dp, (CELL_SIZE)
9D0037B8  1000FEDB   BEQ ZERO, ZERO, 0x9D003328   514:       b vm
9D0037BC  AE340000   SW S4, 0(S1)                 515:       sw topd, 0(dp)
                                                  516:   
                                                  517:   swap:       # 'swap' (n1 n2 -- n2 n1 )
9D0037C0  02804021   ADDU T0, S4, ZERO            518:       _fetch_t t0
9D0037C4  8E340000   LW S4, 0(S1)                 519:       lw topd, 0(dp)
9D0037C8  1000FED7   BEQ ZERO, ZERO, 0x9D003328   520:       b vm
9D0037CC  AE280000   SW T0, 0(S1)                 521:       sw t0, 0(dp)
                                                  522:   
                                                  523:   over:       # 'over' ( n1 n2 -- n1 n2 n1 )
9D0037D0  8E28FFFC   LW T0, -4(S1)                524:       _fetch_n t0, 2
9D0037D4  26310004   ADDIU S1, S1, 4              525:       addiu dp, dp, (CELL_SIZE)
9D0037D8  AE340000   SW S4, 0(S1)                 526:       sw topd, 0(dp)
9D0037DC  1000FED2   BEQ ZERO, ZERO, 0x9D003328   527:       b vm
9D0037E0  0100A021   ADDU S4, T0, ZERO            528:       _store_t t0
                                                  529:   
                                                  530:   rot:        # rot ( n2 n1 n0 -- n1 n0 n2 )
9D0037E4  02804021   ADDU T0, S4, ZERO            531:       _fetch_t t0
9D0037E8  8E34FFFC   LW S4, -4(S1)                532:       _fetch_n topd, 2
9D0037EC  8E290000   LW T1, 0(S1)                 533:       _fetch_n t1, 1
9D0037F0  AE29FFFC   SW T1, -4(S1)                534:       _store_n t1, 2
9D0037F4  AE280000   SW T0, 0(S1)                 535:       _store_n t0, 1 
9D0037F8  1000FECB   BEQ ZERO, ZERO, 0x9D003328   536:       b vm
9D0037FC  00000000   NOP                          537:       nop
                                                  538:   
                                                  539:   plus:       # '+'   ( n1 n2 -- n1+n2 )
9D003800  00144021   ADDU T0, ZERO, S4            540:       _dpop t0
9D003804  8E340000   LW S4, 0(S1)
9D003808  2631FFFC   ADDIU S1, S1, -4
9D00380C  1000FEC6   BEQ ZERO, ZERO, 0x9D003328   541:       b vm
9D003810  0288A021   ADDU S4, S4, T0              542:       addu topd,topd,t0
                                                  543:   
                                                  544:   plus1:      # '+1'  (n -- n+1 )
9D003814  1000FEC4   BEQ ZERO, ZERO, 0x9D003328   545:       b vm
9D003818  26940001   ADDIU S4, S4, 1              546:       addiu topd, topd, 1
                                                  547:   
                                                  548:   plusstore:  # '+!'  ( n addr -- ) *addr  = *addr+n
9D00381C  00144021   ADDU T0, ZERO, S4            549:       _dpop t0
9D003820  8E340000   LW S4, 0(S1)
9D003824  2631FFFC   ADDIU S1, S1, -4
9D003828  8D090000   LW T1, 0(T0)                 550:       lw t1, 0(t0)
9D00382C  02894820   ADD T1, S4, T1               551:       add t1, topd, t1
9D003830  AD090000   SW T1, 0(T0)                 552:       sw t1, 0(t0)
9D003834  00144021   ADDU T0, ZERO, S4            553:       _dpop t0
9D003838  8E340000   LW S4, 0(S1)
9D00383C  2631FFFC   ADDIU S1, S1, -4
9D003840  1000FEB9   BEQ ZERO, ZERO, 0x9D003328   554:       b vm
9D003844  00000000   NOP                          555:       nop
                                                  556:   
                                                  557:   minus:      # '-' ( n1 n2 -- n1-n2 )
9D003848  00144021   ADDU T0, ZERO, S4            558:       _dpop t0
9D00384C  8E340000   LW S4, 0(S1)
9D003850  2631FFFC   ADDIU S1, S1, -4
9D003854  0288A023   SUBU S4, S4, T0              559:       subu topd,topd,t0
9D003858  1000FEB3   BEQ ZERO, ZERO, 0x9D003328   560:       b vm
9D00385C  00000000   NOP                          561:       nop
                                                  562:   
                                                  563:   minus1:     # '-1' ( n -- n-1 )
9D003860  1000FEB1   BEQ ZERO, ZERO, 0x9D003328   564:       b vm
9D003864  2694FFFF   ADDIU S4, S4, -1             565:       addiu topd, topd, -1
                                                  566:   
                                                  567:   multi:      # '*' ( n1 n2 -- n1*n2 )
9D003868  00144021   ADDU T0, ZERO, S4            568:       _dpop t0
9D00386C  8E340000   LW S4, 0(S1)
9D003870  2631FFFC   ADDIU S1, S1, -4
9D003874  7288A002   MUL S4, S4, T0               569:       mul topd,topd,t0
9D003878  1000FEAB   BEQ ZERO, ZERO, 0x9D003328   570:       b vm
9D00387C  00000000   NOP                          571:       nop
                                                  572:   
                                                  573:   divi:      # '/' ( n1 n2 -- n1/n2 )
9D003880  00144021   ADDU T0, ZERO, S4            574:       _dpop t0
9D003884  8E340000   LW S4, 0(S1)
9D003888  2631FFFC   ADDIU S1, S1, -4
9D00388C  010001F4   TEQ T0, ZERO                 575:       div topd,t0
9D003890  0288001A   DIV S4, T0
9D003894  2401FFFF   ADDIU AT, ZERO, -1
9D003898  15010002   BNE T0, AT, 0x9D0038A4
9D00389C  3C018000   LUI AT, -32768
9D0038A0  028101B4   TEQ S4, AT
9D0038A4  0000A012   MFLO S4, 0
9D0038A8  1000FE9F   BEQ ZERO, ZERO, 0x9D003328   576:       b vm
9D0038AC  0000A012   MFLO S4, 0                   577:       mflo topd
                                                  578:   
                                                  579:   divmod:     # '/mod'  ( n1 n2 -- n1%n2 n1/n2 )
9D0038B0  02804021   ADDU T0, S4, ZERO            580:       _fetch_t t0
9D0038B4  8E290000   LW T1, 0(S1)                 581:       lw t1, 0(dp)
9D0038B8  010001F4   TEQ T0, ZERO                 582:       div t1, t0
9D0038BC  0128001A   DIV T1, T0
9D0038C0  2401FFFF   ADDIU AT, ZERO, -1
9D0038C4  15010002   BNE T0, AT, 0x9D0038D0
9D0038C8  3C018000   LUI AT, -32768
9D0038CC  012101B4   TEQ T1, AT
9D0038D0  00004812   MFLO T1, 0
9D0038D4  0000A012   MFLO S4, 0                   583:       mflo topd
9D0038D8  00004810   MFHI T1, 0                   584:       mfhi t1
9D0038DC  AE290000   SW T1, 0(S1)                 585:       sw t1, 0(dp)
9D0038E0  1000FE91   BEQ ZERO, ZERO, 0x9D003328   586:       b vm
9D0038E4  00000000   NOP                          587:       nop
                                                  588:   
                                                  589:   lshift:     # '<<' ( n1 u -- n1<<u )
9D0038E8  00144021   ADDU T0, ZERO, S4            590:       _dpop t0
9D0038EC  8E340000   LW S4, 0(S1)
9D0038F0  2631FFFC   ADDIU S1, S1, -4
9D0038F4  1000FE8C   BEQ ZERO, ZERO, 0x9D003328   591:       b vm
9D0038F8  0114A004   SLLV S4, S4, T0              592:       sllv topd, topd, t0
                                                  593:   
                                                  594:   rshift:     # '>>'  ( n1 u -- n1>>u )
9D0038FC  00144021   ADDU T0, ZERO, S4            595:       _dpop t0
9D003900  8E340000   LW S4, 0(S1)
9D003904  2631FFFC   ADDIU S1, S1, -4
9D003908  1000FE87   BEQ ZERO, ZERO, 0x9D003328   596:       b vm
9D00390C  0114A006   SRLV S4, S4, T0              597:       srlv topd, topd, t0
                                                  598:   
                                                  599:   modulo:     # 'mod' ( n1 n2 -- n1%n2 )
9D003910  00144021   ADDU T0, ZERO, S4            600:       _dpop t0
9D003914  8E340000   LW S4, 0(S1)
9D003918  2631FFFC   ADDIU S1, S1, -4
9D00391C  010001F4   TEQ T0, ZERO                 601:       div topd,t0
9D003920  0288001A   DIV S4, T0
9D003924  2401FFFF   ADDIU AT, ZERO, -1
9D003928  15010002   BNE T0, AT, 0x9D003934
9D00392C  3C018000   LUI AT, -32768
9D003930  028101B4   TEQ S4, AT
9D003934  0000A012   MFLO S4, 0
9D003938  1000FE7B   BEQ ZERO, ZERO, 0x9D003328   602:       b vm
9D00393C  0000A010   MFHI S4, 0                   603:       mfhi topd
                                                  604:   
                                                  605:   min:        # 'min' (n1 n2 -- min )  conserve le plus petit
9D003940  00144021   ADDU T0, ZERO, S4            606:       _dpop t0
9D003944  8E340000   LW S4, 0(S1)
9D003948  2631FFFC   ADDIU S1, S1, -4
9D00394C  02884823   SUBU T1, S4, T0              607:       subu t1,topd,t0
9D003950  0520FE75   BLTZ T1, 0x9D003328          608:       bltz t1, vm
9D003954  00000000   NOP                          609:       nop
9D003958  1000FE73   BEQ ZERO, ZERO, 0x9D003328   610:       b vm
9D00395C  0100A021   ADDU S4, T0, ZERO            611:       _store_t t0
                                                  612:   
                                                  613:   max:        # 'max' (n1 n2 -- max ) conserve le plus grand
9D003960  00144021   ADDU T0, ZERO, S4            614:       _dpop t0
9D003964  8E340000   LW S4, 0(S1)
9D003968  2631FFFC   ADDIU S1, S1, -4
9D00396C  01144823   SUBU T1, T0, S4              615:       subu t1,t0,topd
9D003970  0520FE6D   BLTZ T1, 0x9D003328          616:       bltz t1, vm
9D003974  00000000   NOP                          617:       nop
9D003978  1000FE6B   BEQ ZERO, ZERO, 0x9D003328   618:       b vm
9D00397C  0100A021   ADDU S4, T0, ZERO            619:       _store_t t0
                                                  620:   
                                                  621:   abs:        # 'abs' ( n -- abs(n) )
9D003980  0680FE69   BLTZ S4, 0x9D003328          622:       bltz topd, vm
9D003984  0280A027   NOR S4, S4, ZERO             623:       not topd, topd
9D003988  1000FE67   BEQ ZERO, ZERO, 0x9D003328   624:       b vm
9D00398C  00000000   NOP                          625:       nop
                                                  626:   
                                                  627:   ltz:   # '0<'  ( n -- t|f )
9D003990  0680FE65   BLTZ S4, 0x9D003328          628:       bltz topd, vm
9D003994  2414FFFF   ADDIU S4, ZERO, -1           629:       addiu topd,zero,-1
9D003998  1000FE63   BEQ ZERO, ZERO, 0x9D003328   630:       b vm
9D00399C  0294A026   XOR S4, S4, S4               631:       xor topd,topd,topd
                                                  632:   
                                                  633:   bitand:     # 'and' ( n1 n2 -- n1&n2)
9D0039A0  00144021   ADDU T0, ZERO, S4            634:       _dpop t0
9D0039A4  8E340000   LW S4, 0(S1)
9D0039A8  2631FFFC   ADDIU S1, S1, -4
9D0039AC  1000FE5E   BEQ ZERO, ZERO, 0x9D003328   635:       b vm
9D0039B0  0288A024   AND S4, S4, T0               636:       and topd,topd,t0
                                                  637:   
                                                  638:   bitor:     # 'or' ( n1 n2 -- n1|n2)
9D0039B4  00144021   ADDU T0, ZERO, S4            639:       _dpop t0
9D0039B8  8E340000   LW S4, 0(S1)
9D0039BC  2631FFFC   ADDIU S1, S1, -4
9D0039C0  1000FE59   BEQ ZERO, ZERO, 0x9D003328   640:       b vm
9D0039C4  0288A025   OR S4, S4, T0                641:       or topd,topd,t0
                                                  642:   
                                                  643:   bitxor:     # 'xor' ( n1 n2 -- n1^n2)
9D0039C8  00144021   ADDU T0, ZERO, S4            644:       _dpop t0
9D0039CC  8E340000   LW S4, 0(S1)
9D0039D0  2631FFFC   ADDIU S1, S1, -4
9D0039D4  1000FE54   BEQ ZERO, ZERO, 0x9D003328   645:       b vm
9D0039D8  0288A026   XOR S4, S4, T0               646:       xor topd,topd,t0
                                                  647:   
                                                  648:   bitnot:     # 'not' ( n1 -- ~n1 )
9D0039DC  1000FE52   BEQ ZERO, ZERO, 0x9D003328   649:       b vm
9D0039E0  0280A027   NOR S4, S4, ZERO             650:       not topd, topd
                                                  651:   
                                                  652:   equal:      # '='  ( n1 n2 -- t|f ) n1==n2?
9D0039E4  00144021   ADDU T0, ZERO, S4            653:       _dpop t0
9D0039E8  8E340000   LW S4, 0(S1)
9D0039EC  2631FFFC   ADDIU S1, S1, -4
9D0039F0  0288A026   XOR S4, S4, T0               654:       xor topd, topd, t0
9D0039F4  1280FE4C   BEQ S4, ZERO, 0x9D003328     655:       beqz topd, vm
9D0039F8  2414FFFF   ADDIU S4, ZERO, -1           656:       addiu topd, zero, -1
9D0039FC  1000FE4A   BEQ ZERO, ZERO, 0x9D003328   657:       b vm
9D003A00  0294A026   XOR S4, S4, S4               658:       xor topd, topd ,topd
                                                  659:   
                                                  660:   nequal:     # '<>' ( n1 n2 -- t|f ) n1<>n2?
9D003A04  00144021   ADDU T0, ZERO, S4            661:       _dpop t0
9D003A08  8E340000   LW S4, 0(S1)
9D003A0C  2631FFFC   ADDIU S1, S1, -4
9D003A10  02884026   XOR T0, S4, T0               662:       xor t0, topd, t0
9D003A14  1100FE44   BEQ T0, ZERO, 0x9D003328     663:       beqz t0, vm
9D003A18  0294A026   XOR S4, S4, S4               664:       xor topd, topd, topd
9D003A1C  1000FE42   BEQ ZERO, ZERO, 0x9D003328   665:       b vm
9D003A20  2414FFFF   ADDIU S4, ZERO, -1           666:       addiu topd, zero, -1
                                                  667:   
                                                  668:   less:       # '<'  ( n1 n2 -- t|f ) n1<n2?
9D003A24  00144021   ADDU T0, ZERO, S4            669:       _dpop t0
9D003A28  8E340000   LW S4, 0(S1)
9D003A2C  2631FFFC   ADDIU S1, S1, -4
9D003A30  02884023   SUBU T0, S4, T0              670:       subu t0, topd, t0
9D003A34  0500FE3C   BLTZ T0, 0x9D003328          671:       bltz t0, vm
9D003A38  2414FFFF   ADDIU S4, ZERO, -1           672:       addiu topd, zero, -1
9D003A3C  1000FE3A   BEQ ZERO, ZERO, 0x9D003328   673:       b vm
9D003A40  0294A026   XOR S4, S4, S4               674:       xor topd, topd, topd
                                                  675:   
                                                  676:   greater:    # '>'  ( n1 n2 -- t|f ) n1>n2?
9D003A44  00144021   ADDU T0, ZERO, S4            677:       _dpop t0
9D003A48  8E340000   LW S4, 0(S1)
9D003A4C  2631FFFC   ADDIU S1, S1, -4
9D003A50  02884023   SUBU T0, S4, T0              678:       subu t0, topd, t0
9D003A54  0500FE34   BLTZ T0, 0x9D003328          679:       bltz t0, vm
9D003A58  0294A026   XOR S4, S4, S4               680:       xor topd, topd, topd
9D003A5C  1000FE32   BEQ ZERO, ZERO, 0x9D003328   681:       b vm
9D003A60  2414FFFF   ADDIU S4, ZERO, -1           682:       addiu topd, zero, -1
                                                  683:   
                                                  684:   ltez:        # '<=' ( n1 n2 -- t|f ) n1<=n2?
9D003A64  00144021   ADDU T0, ZERO, S4            685:       _dpop t0
9D003A68  8E340000   LW S4, 0(S1)
9D003A6C  2631FFFC   ADDIU S1, S1, -4
9D003A70  02884023   SUBU T0, S4, T0              686:       subu t0, topd, t0
9D003A74  1900FE2C   BLEZ T0, 0x9D003328          687:       blez t0, vm
9D003A78  2414FFFF   ADDIU S4, ZERO, -1           688:       addiu topd, zero, -1
9D003A7C  1000FE2A   BEQ ZERO, ZERO, 0x9D003328   689:       b vm
9D003A80  0294A026   XOR S4, S4, S4               690:       xor topd, topd, topd
                                                  691:   
                                                  692:   gtez:        # '>=' ( n1 n2 -- t|f ) n1>=n2?
9D003A84  00144021   ADDU T0, ZERO, S4            693:       _dpop t0
9D003A88  8E340000   LW S4, 0(S1)
9D003A8C  2631FFFC   ADDIU S1, S1, -4
9D003A90  02884023   SUBU T0, S4, T0              694:       subu t0, topd, t0
9D003A94  1900FE24   BLEZ T0, 0x9D003328          695:       blez t0, vm
9D003A98  0294A026   XOR S4, S4, S4               696:       xor topd, topd, topd
9D003A9C  1000FE22   BEQ ZERO, ZERO, 0x9D003328   697:       b vm
9D003AA0  2414FFFF   ADDIU S4, ZERO, -1           698:       addiu topd, zero, -1
                                                  699:   
                                                  700:   key:        #  ( -- char ) attend réception caractère par terminal
9D003AA4  3C04A000   LUI A0, -24576               701:       _getch comm_channel
9D003AA8  24840028   ADDIU A0, A0, 40
9D003AAC  0F401EE3   JAL get_key
9D003AB0  80840000   LB A0, 0(A0)
9D003AB4  26310004   ADDIU S1, S1, 4              702:       _dpush v0
9D003AB8  AE340000   SW S4, 0(S1)
9D003ABC  0002A021   ADDU S4, ZERO, V0
9D003AC0  1000FE19   BEQ ZERO, ZERO, 0x9D003328   703:       b vm
9D003AC4  00000000   NOP                          704:       nop
                                                  705:   
                                                  706:   sfr:        # ( reg -- sfr ) transforme la valeur de registre 16 bits en addresse SFR
9D003AC8  3C08BF88   LUI T0, -16504               707:       lui t0, SFR_SEG
9D003ACC  3294FFFF   ANDI S4, S4, -1              708:       andi topd,topd, 65535
9D003AD0  1000FE15   BEQ ZERO, ZERO, 0x9D003328   709:       b vm
9D003AD4  0288A025   OR S4, S4, T0                710:       or  topd,topd,t0
                                                  711:   
                                                  712:   set:        # ( bits sfr -- ) mets à 1 les bits du SFR
9D003AD8  00144021   ADDU T0, ZERO, S4            713:       _dpop t0
9D003ADC  8E340000   LW S4, 0(S1)
9D003AE0  2631FFFC   ADDIU S1, S1, -4
9D003AE4  25080008   ADDIU T0, T0, 8              714:       addiu t0, t0,SFR_SET
9D003AE8  00144821   ADDU T1, ZERO, S4            715:       _dpop t1
9D003AEC  8E340000   LW S4, 0(S1)
9D003AF0  2631FFFC   ADDIU S1, S1, -4
9D003AF4  1000FE0C   BEQ ZERO, ZERO, 0x9D003328   716:       b vm
9D003AF8  AD090000   SW T1, 0(T0)                 717:       sw t1, 0(t0)
                                                  718:   
                                                  719:   clear:      # ( bits sfr -- ) met à 0 les bits du SFR
9D003AFC  00144021   ADDU T0, ZERO, S4            720:       _dpop t0
9D003B00  8E340000   LW S4, 0(S1)
9D003B04  2631FFFC   ADDIU S1, S1, -4
9D003B08  25080004   ADDIU T0, T0, 4              721:       addiu t0, t0, SFR_CLEAR
9D003B0C  00144821   ADDU T1, ZERO, S4            722:       _dpop t1
9D003B10  8E340000   LW S4, 0(S1)
9D003B14  2631FFFC   ADDIU S1, S1, -4
9D003B18  1000FE03   BEQ ZERO, ZERO, 0x9D003328   723:       b vm
9D003B1C  AD090000   SW T1, 0(T0)                 724:       sw t1, 0(t0)
                                                  725:   
                                                  726:   invert:     # ( bits sfr -- ) inverse la valeur des bits
9D003B20  00144021   ADDU T0, ZERO, S4            727:       _dpop t0
9D003B24  8E340000   LW S4, 0(S1)
9D003B28  2631FFFC   ADDIU S1, S1, -4
9D003B2C  2508000C   ADDIU T0, T0, 12             728:       addiu t0, t0,SFR_INV
9D003B30  00144821   ADDU T1, ZERO, S4            729:       _dpop t1
9D003B34  8E340000   LW S4, 0(S1)
9D003B38  2631FFFC   ADDIU S1, S1, -4
9D003B3C  1000FDFA   BEQ ZERO, ZERO, 0x9D003328   730:       b vm
9D003B40  AD090000   SW T1, 0(T0)                 731:       sw t1, 0(t0)
                                                  732:   
                                                  733:   dotq:      # '."' ( -- ) ip pointe vers le texte, le premier octet est le compte.
9D003B44  82080000   LB T0, 0(S0)                 734:       ld_bytecode t0
9D003B48  26310004   ADDIU S1, S1, 4              735:       _dpush t0
9D003B4C  AE340000   SW S4, 0(S1)
9D003B50  0008A021   ADDU S4, ZERO, T0
9D003B54  26100001   ADDIU S0, S0, 1              736:       _next
                                                  737:   dotq_loop:
9D003B58  1280000B   BEQ S4, ZERO, 0x9D003B88     738:       beqz topd, dotq_exit
9D003B5C  2694FFFF   ADDIU S4, S4, -1             739:       addiu topd,topd,-1
9D003B60  3C13A000   LUI S3, -24576               740:       lui wp, RAM_SEG
9D003B64  3C04A000   LUI A0, -24576               741:       la a0, comm_channel
9D003B68  24840028   ADDIU A0, A0, 40
9D003B6C  8C840000   LW A0, 0(A0)                 742:       lw a0, 0(a0)
9D003B70  82050000   LB A1, 0(S0)                 743:       ld_bytecode a1
9D003B74  0F401D62   JAL 0x9D007588               744:       jal put_char
9D003B78  00000000   NOP                          745:       nop
9D003B7C  26100001   ADDIU S0, S0, 1              746:       _next
9D003B80  1000FFF5   BEQ ZERO, ZERO, 0x9D003B58   747:       b dotq_loop
9D003B84  00000000   NOP                          748:       nop
                                                  749:   dotq_exit:
9D003B88  00144021   ADDU T0, ZERO, S4            750:       _dpop t0
9D003B8C  8E340000   LW S4, 0(S1)
9D003B90  2631FFFC   ADDIU S1, S1, -4
9D003B94  1000FDE4   BEQ ZERO, ZERO, 0x9D003328   751:       b vm
9D003B98  00000000   NOP                          752:       nop
                                                  753:   
                                                  754:   readln:    # 'accept' ( buff max -- count ) lecture ligne du terminal
9D003B9C  3C04A000   LUI A0, -24576               755:       la a0, comm_channel
9D003BA0  24840028   ADDIU A0, A0, 40
9D003BA4  8C840000   LW A0, 0(A0)                 756:       lw a0, 0(a0)
9D003BA8  00143021   ADDU A2, ZERO, S4            757:       _dpop a2
9D003BAC  8E340000   LW S4, 0(S1)
9D003BB0  2631FFFC   ADDIU S1, S1, -4
9D003BB4  02802821   ADDU A1, S4, ZERO            758:       _fetch_t a1
9D003BB8  0F401F23   JAL 0x9D007C8C               759:       jal readline
9D003BBC  00000000   NOP                          760:       nop
9D003BC0  1000FDD9   BEQ ZERO, ZERO, 0x9D003328   761:       b vm
9D003BC4  0040A021   ADDU S4, V0, ZERO            762:       _store_t v0
                                                  763:   
                                                  764:   type:   # 'type'  ( count buff -- ) envoie le texte dans buff au terminal
9D003BC8  3C04A000   LUI A0, -24576               765:       la a0, comm_channel
9D003BCC  24840028   ADDIU A0, A0, 40
9D003BD0  8C840000   LW A0, 0(A0)                 766:       lw a0, 0(a0)
9D003BD4  00149821   ADDU S3, ZERO, S4            767:       _dpop wp
9D003BD8  8E340000   LW S4, 0(S1)
9D003BDC  2631FFFC   ADDIU S1, S1, -4
                                                  768:   1:
9D003BE0  0F401D62   JAL 0x9D007588               769:       jal put_char
9D003BE4  82650000   LB A1, 0(S3)                 770:       lb a1,0(wp)
9D003BE8  26730001   ADDIU S3, S3, 1              771:       addiu wp, wp, 1
9D003BEC  2694FFFF   ADDIU S4, S4, -1             772:       addiu topd, topd, -1
9D003BF0  12800001   BEQ S4, ZERO, 0x9D003BF8     773:       beq topd, zero, 2f
9D003BF4  1000FFFA   BEQ ZERO, ZERO, 0x9D003BE0   774:       b 1b
                                                  775:   2:
9D003BF8  00144021   ADDU T0, ZERO, S4            776:       _dpop t0
9D003BFC  8E340000   LW S4, 0(S1)
9D003C00  2631FFFC   ADDIU S1, S1, -4
9D003C04  1000FDC8   BEQ ZERO, ZERO, 0x9D003328   777:       b vm
9D003C08  00000000   NOP                          778:       nop
                                                  779:   
                                                  780:   
                                                  781:   delay:  # 'delay' ( msec -- ) delay en millisecondes
9D003C0C  3C13A000   LUI S3, -24576               782:       la wp, sys_tick
9D003C10  26730048   ADDIU S3, S3, 72
9D003C14  8E680000   LW T0, 0(S3)                 783:       lw t0, 0(wp)
9D003C18  0288A021   ADDU S4, S4, T0              784:       addu topd, topd, t0
                                                  785:   1:
9D003C1C  8E680000   LW T0, 0(S3)                 786:       lw t0, 0(wp)
9D003C20  02884023   SUBU T0, S4, T0              787:       subu t0,topd,t0
9D003C24  1500FFFD   BNE T0, ZERO, 0x9D003C1C     788:       bne t0,zero, 1b
9D003C28  00000000   NOP                          789:       nop
9D003C2C  00144021   ADDU T0, ZERO, S4            790:       _dpop t0
9D003C30  8E340000   LW S4, 0(S1)
9D003C34  2631FFFC   ADDIU S1, S1, -4
9D003C38  1000FDBB   BEQ ZERO, ZERO, 0x9D003328   791:       b vm
9D003C3C  00000000   NOP                          792:       nop
                                                  793:   
                                                  794:   space:      # 'space' ( -- ) imprime un espace
9D003C40  24080020   ADDIU T0, ZERO, 32           795:       li t0,32
9D003C44  26310004   ADDIU S1, S1, 4              796:       _dpush t0
9D003C48  AE340000   SW S4, 0(S1)
9D003C4C  0008A021   ADDU S4, ZERO, T0
9D003C50  3C04A000   LUI A0, -24576               797:       _putch comm_channel
9D003C54  24840028   ADDIU A0, A0, 40
9D003C58  80840000   LB A0, 0(A0)
9D003C5C  00142821   ADDU A1, ZERO, S4
9D003C60  8E340000   LW S4, 0(S1)
9D003C64  2631FFFC   ADDIU S1, S1, -4
9D003C68  0F401D62   JAL put_char
9D003C6C  00000000   NOP
9D003C70  1000FDAD   BEQ ZERO, ZERO, 0x9D003328   798:       b vm
9D003C74  00000000   NOP                          799:       nop
                                                  800:   
                                                  801:   spaces:     # 'spces' ( n -- ) imprime n espaces
9D003C78  1280000F   BEQ S4, ZERO, 0x9D003CB8     802:       beqz topd, 1f
9D003C7C  24080020   ADDIU T0, ZERO, 32           803:       li t0, 32
9D003C80  26310004   ADDIU S1, S1, 4              804:       _dpush t0
9D003C84  AE340000   SW S4, 0(S1)
9D003C88  0008A021   ADDU S4, ZERO, T0
9D003C8C  3C04A000   LUI A0, -24576               805:       _putch comm_channel
9D003C90  24840028   ADDIU A0, A0, 40
9D003C94  80840000   LB A0, 0(A0)
9D003C98  00142821   ADDU A1, ZERO, S4
9D003C9C  8E340000   LW S4, 0(S1)
9D003CA0  2631FFFC   ADDIU S1, S1, -4
9D003CA4  0F401D62   JAL put_char
9D003CA8  00000000   NOP
9D003CAC  2694FFFF   ADDIU S4, S4, -1             806:       addiu topd, topd, -1
9D003CB0  1000FFF1   BEQ ZERO, ZERO, 0x9D003C78   807:       b spaces
9D003CB4  00000000   NOP                          808:       nop
                                                  809:   1:
9D003CB8  00140021   ADDU ZERO, ZERO, S4          810:       _dpop
9D003CBC  8E340000   LW S4, 0(S1)
9D003CC0  2631FFFC   ADDIU S1, S1, -4
9D003CC4  1000FD98   BEQ ZERO, ZERO, 0x9D003328   811:       b vm
9D003CC8  00000000   NOP                          812:       nop
                                                  813:   
                                                  814:   crlf:
9D003CCC  2408000D   ADDIU T0, ZERO, 13           815:       li t0, '\r'
9D003CD0  26310004   ADDIU S1, S1, 4              816:       _dpush t0
9D003CD4  AE340000   SW S4, 0(S1)
9D003CD8  0008A021   ADDU S4, ZERO, T0
9D003CDC  3C04A000   LUI A0, -24576               817:       _putch comm_channel
9D003CE0  24840028   ADDIU A0, A0, 40
9D003CE4  80840000   LB A0, 0(A0)
9D003CE8  00142821   ADDU A1, ZERO, S4
9D003CEC  8E340000   LW S4, 0(S1)
9D003CF0  2631FFFC   ADDIU S1, S1, -4
9D003CF4  0F401D62   JAL put_char
9D003CF8  00000000   NOP
9D003CFC  1000FD8A   BEQ ZERO, ZERO, 0x9D003328   818:       b vm
9D003D00  00000000   NOP                          819:       nop
                                                  820:   
                                                  821:   cellp:
9D003D04  1000FD88   BEQ ZERO, ZERO, 0x9D003328   822:       b vm
9D003D08  26940004   ADDIU S4, S4, 4              823:       addiu topd, topd, CELL_SIZE
                                                  824:   
                                                  825:   cellm:
9D003D0C  1000FD86   BEQ ZERO, ZERO, 0x9D003328   826:       b vm
9D003D10  2694FFFC   ADDIU S4, S4, -4             827:       addiu topd, topd, -(CELL_SIZE)
                                                  828:   
                                                  829:   badop:
9D003D14  01001021   ADDU V0, T0, ZERO            830:       move v0,t0
                                                  831:   exit:
9D003D18  8FB00018   LW S0, 24(SP)                832:       lw  s0,24(sp)
9D003D1C  8FB10014   LW S1, 20(SP)                833:       lw  s1,20(sp)
9D003D20  8FB20010   LW S2, 16(SP)                834:       lw  s2,16(sp)
9D003D24  8FB3000C   LW S3, 12(SP)                835:       lw  s3,12(sp)
9D003D28  8FB40008   LW S4, 8(SP)                 836:       lw  s4,8(sp)
9D003D2C  8FB50004   LW S5, 4(SP)                 837:       lw  s5,4(sp)
9D003D30  8FBF001C   LW RA, 28(SP)                838:       _fn_exit 32
9D003D34  03E00008   JR RA
9D003D38  27BD0020   ADDIU SP, SP, 32
                                                  839:   .end StackVM
                                                  840:   
                                                  841:   .ent fetch_int
                                                  842:   fetch_int:  # lit un entier little indian dans espace code VM
9D003D3C  92080000   LBU T0, 0(S0)                843:       lbu t0, 0(ip)
9D003D40  92090001   LBU T1, 1(S0)                844:       lbu t1, 1(ip)
9D003D44  00094A00   SLL T1, T1, 8                845:       sll  t1,t1, 8
9D003D48  920A0002   LBU T2, 2(S0)                846:       lbu t2, 2(ip)
9D003D4C  000A5400   SLL T2, T2, 16               847:       sll t2,t2, 16
9D003D50  820B0003   LB T3, 3(S0)                 848:       lb t3, 3(ip)
9D003D54  000B5E00   SLL T3, T3, 24               849:       sll t3,t3, 24
9D003D58  01094025   OR T0, T0, T1                850:       or  t0,t0,t1
9D003D5C  010A4025   OR T0, T0, T2                851:       or  t0,t0,t2
9D003D60  010B1025   OR V0, T0, T3                852:       or  v0,t0,t3
9D003D64  26100004   ADDIU S0, S0, 4              853:       addiu ip,ip,CELL_SIZE
9D003D68  03E00008   JR RA                        854:       j ra
9D003D6C  00000000   NOP                          855:       nop
                                                  856:   .end fetch_int
                                                  857:   
                                                  858:   .ent dbg_putch    # envoie un caratère vers UART2
                                                  859:   dbg_putch:        # a0 contient le caractère
9D003D70  3C0EBF80   LUI T6, -16512               860:       la t6, U2STA
9D003D74  25CE6210   ADDIU T6, T6, 25104
                                                  861:   1:
9D003D78  8DCD0000   LW T5, 0(T6)                 862:       lw t5,0(t6)
9D003D7C  31AD0200   ANDI T5, T5, 512             863:       andi t5,t5, _U1STA_UTXBF_MASK
9D003D80  15A0FFFD   BNE T5, ZERO, 0x9D003D78     864:       bne t5, zero,  1b
9D003D84  00000000   NOP                          865:       nop
9D003D88  3C0EBF80   LUI T6, -16512               866:       la t6, U2TXREG
9D003D8C  25CE6220   ADDIU T6, T6, 25120
9D003D90  ADC40000   SW A0, 0(T6)                 867:       sw a0, 0(t6)
9D003D94  03E00008   JR RA                        868:       j ra
9D003D98  00000000   NOP                          869:       nop
                                                  870:   .end dbg_putch
                                                  871:   
                                                  872:   .ent dbg_print    # envoie une chaine de caractère asciiz vers UART2
                                                  873:                     # a0 contient le numéro du point de contrôle
                                                  874:   dbg_print:
9D003D9C  27BDFFFC   ADDIU SP, SP, -4             875:       _fn_enter 4
9D003DA0  AFBF0000   SW RA, 0(SP)
9D003DA4  26310004   ADDIU S1, S1, 4              876:       _dpush a0
9D003DA8  AE340000   SW S4, 0(S1)
9D003DAC  0004A021   ADDU S4, ZERO, A0
9D003DB0  3C0F9D00   LUI T7, -25344               877:       la t7, dbg_msg
9D003DB4  25EF3E20   ADDIU T7, T7, 15904
9D003DB8  26310004   ADDIU S1, S1, 4              878:       _dpush t7
9D003DBC  AE340000   SW S4, 0(S1)
9D003DC0  000FA021   ADDU S4, ZERO, T7
                                                  879:   1:
9D003DC4  82840000   LB A0, 0(S4)                 880:       lb a0, 0(topd)
9D003DC8  3084007F   ANDI A0, A0, 127             881:       andi a0, a0, 0x7f
9D003DCC  10800006   BEQ A0, ZERO, 0x9D003DE8     882:       beqz a0, 2f
9D003DD0  00000000   NOP                          883:       nop
9D003DD4  0F400F5C   JAL 0x9D003D70               884:       jal dbg_putch
9D003DD8  00000000   NOP                          885:       nop
9D003DDC  26940001   ADDIU S4, S4, 1              886:       addiu topd,topd,1
9D003DE0  1000FFF8   BEQ ZERO, ZERO, 0x9D003DC4   887:       b 1b
9D003DE4  00000000   NOP                          888:       nop
                                                  889:   2:
9D003DE8  00147821   ADDU T7, ZERO, S4            890:       _dpop t7
9D003DEC  8E340000   LW S4, 0(S1)
9D003DF0  2631FFFC   ADDIU S1, S1, -4
9D003DF4  00142021   ADDU A0, ZERO, S4            891:       _dpop a0
9D003DF8  8E340000   LW S4, 0(S1)
9D003DFC  2631FFFC   ADDIU S1, S1, -4
9D003E00  0F400F5C   JAL 0x9D003D70               892:       jal dbg_putch
9D003E04  00000000   NOP                          893:       nop
9D003E08  2404000D   ADDIU A0, ZERO, 13           894:       li a0, '\r'
9D003E0C  0F400F5C   JAL 0x9D003D70               895:       jal dbg_putch
9D003E10  00000000   NOP                          896:       nop
9D003E14  8FBF0000   LW RA, 0(SP)                 897:       _fn_exit 4
9D003E18  03E00008   JR RA
9D003E1C  27BD0004   ADDIU SP, SP, 4
9D003E20  75626564   JALX 0x95899590
9D003E28  206B6365   ADDI T3, V1, 25445
9D003E30  00203A74   TEQ AT, ZERO
9D003F68  00000000   NOP
9D003F6C  00000000   NOP
9D003F70  00000000   NOP
9D003F74  00000000   NOP
9D003F78  00000000   NOP
9D003F7C  00000000   NOP
9D003F80  00000000   NOP
9D003F84  00000000   NOP
9D003F88  00000000   NOP
9D003F8C  00000000   NOP
9D003F90  00000000   NOP
9D003F94  00000000   NOP
9D003F98  00000000   NOP
9D003F9C  00000000   NOP
9D003FA0  00000000   NOP
9D003FA4  00000000   NOP
9D003FA8  00000000   NOP
9D003FAC  00000000   NOP
9D003FB0  00000000   NOP
9D003FB4  00000000   NOP
9D003FB8  00000000   NOP
9D003FBC  00000000   NOP
9D003FC0  00000000   NOP
9D003FC4  00000000   NOP
9D003FC8  00000000   NOP
9D003FCC  00000000   NOP
9D003FD0  00000000   NOP
9D003FD4  00000000   NOP
9D003FD8  00000000   NOP
9D003FDC  00000000   NOP
9D003FE0  00000000   NOP
9D003FE4  00000000   NOP
9D003FE8  00000000   NOP
9D003FEC  00000000   NOP
9D003FF0  00000000   NOP
9D003FF4  00000000   NOP
9D003FF8  00000000   NOP
9D003FFC  00000000   NOP
9D004000  00000000   NOP
9D004004  00000000   NOP
9D004008  00000000   NOP
9D00400C  00000000   NOP
9D004010  00000000   NOP
9D004014  00000000   NOP
9D004018  00000000   NOP
9D00401C  00000000   NOP
9D004020  00000000   NOP
9D004024  00000000   NOP
9D004028  00000000   NOP
9D00402C  00000000   NOP
9D004030  00000000   NOP
9D004034  00000000   NOP
9D004038  00000000   NOP
9D00403C  00000000   NOP
9D004040  00000000   NOP
9D004044  00000000   NOP
9D004048  00000000   NOP
9D00404C  00000000   NOP
9D004050  00000000   NOP
9D004054  00000000   NOP
9D004058  00000000   NOP
9D00405C  00000000   NOP
9D004060  00000000   NOP
9D004064  00000000   NOP
9D004068  00000000   NOP
9D00406C  00000000   NOP
9D004070  00000000   NOP
9D004074  00000000   NOP
9D004078  00000000   NOP
9D00407C  00000000   NOP
9D004080  00000000   NOP
9D004084  00000000   NOP
9D004088  00000000   NOP
9D00408C  00000000   NOP
9D004090  00000000   NOP
9D004094  00000000   NOP
9D004098  00000000   NOP
9D00409C  00000000   NOP
9D0040A0  00000000   NOP
9D0040A4  00000000   NOP
9D0040A8  00000000   NOP
9D0040AC  00000000   NOP
9D0040B0  00000000   NOP
9D0040B4  00000000   NOP
9D0040B8  00000000   NOP
9D0040BC  00000000   NOP
9D0040C0  00000000   NOP
9D0040C4  00000000   NOP
9D0040C8  00000000   NOP
9D0040CC  00000000   NOP
9D0040D0  00000000   NOP
9D0040D4  00000000   NOP
9D0040D8  00000000   NOP
9D0040DC  00000000   NOP
9D0040E0  00000000   NOP
9D0040E4  00000000   NOP
9D0040E8  00000000   NOP
9D0040EC  00000000   NOP
9D0040F0  00000000   NOP
9D0040F4  00000000   NOP
9D0040F8  00000000   NOP
9D0040FC  00000000   NOP
9D004100  00000000   NOP
9D004104  00000000   NOP
9D004108  00000000   NOP
9D00410C  00000000   NOP
9D004110  00000000   NOP
9D004114  00000000   NOP
9D004118  00000000   NOP
9D00411C  00000000   NOP
9D004120  00000000   NOP
9D004124  00000000   NOP
9D004128  00000000   NOP
9D00412C  00000000   NOP
9D004130  00000000   NOP
9D004134  00000000   NOP
9D004138  00000000   NOP
9D00413C  00000000   NOP
9D004140  00000000   NOP
9D004144  00000000   NOP
9D004148  00000000   NOP
9D00414C  00000000   NOP
9D004150  00000000   NOP
9D004154  00000000   NOP
9D004158  00000000   NOP
9D00415C  00000000   NOP
9D004160  00000000   NOP
9D004164  00000000   NOP
9D004168  00000000   NOP
9D00416C  00000000   NOP
9D004170  00000000   NOP
9D004174  00000000   NOP
9D004178  00000000   NOP
9D00417C  00000000   NOP
9D004180  00000000   NOP
9D004184  00000000   NOP
9D004188  00000000   NOP
9D00418C  00000000   NOP
9D004190  00000000   NOP
9D004194  00000000   NOP
9D004198  00000000   NOP
9D00419C  00000000   NOP
9D0041A0  00000000   NOP
9D0041A4  00000000   NOP
9D0041A8  00000000   NOP
9D0041AC  00000000   NOP
9D0041B0  00000000   NOP
9D0041B4  00000000   NOP
9D0041B8  00000000   NOP
9D0041BC  00000000   NOP
9D0041C0  00000000   NOP
9D0041C4  00000000   NOP
9D0041C8  00000000   NOP
9D0041CC  00000000   NOP
9D0041D0  00000000   NOP
9D0041D4  00000000   NOP
9D0041D8  00000000   NOP
9D0041DC  00000000   NOP
9D0041E0  00000000   NOP
9D0041E4  00000000   NOP
9D0041E8  00000000   NOP
9D0041EC  00000000   NOP
9D0041F0  00000000   NOP
9D0041F4  00000000   NOP
9D0041F8  00000000   NOP
9D0041FC  00000000   NOP
9D004200  00000000   NOP
9D004204  00000000   NOP
9D004208  00000000   NOP
9D00420C  00000000   NOP
9D004210  00000000   NOP
9D004214  00000000   NOP
9D004218  00000000   NOP
9D00421C  00000000   NOP
9D004220  00000000   NOP
9D004224  00000000   NOP
9D004228  00000000   NOP
9D00422C  00000000   NOP
9D004230  00000000   NOP
9D004234  00000000   NOP
9D004238  00000000   NOP
9D00423C  00000000   NOP
9D004240  00000000   NOP
9D004244  00000000   NOP
9D004248  00000000   NOP
9D00424C  00000000   NOP
9D004250  00000000   NOP
9D004254  00000000   NOP
9D004258  00000000   NOP
9D00425C  00000000   NOP
9D004260  00000000   NOP
9D004264  00000000   NOP
9D004268  00000000   NOP
9D00426C  00000000   NOP
9D004270  00000000   NOP
9D004274  00000000   NOP
9D004278  00000000   NOP
9D00427C  00000000   NOP
9D004280  00000000   NOP
9D004284  00000000   NOP
9D004288  00000000   NOP
9D00428C  00000000   NOP
9D004290  00000000   NOP
9D004294  00000000   NOP
9D004298  00000000   NOP
9D00429C  00000000   NOP
9D0042A0  00000000   NOP
9D0042A4  00000000   NOP
9D0042A8  00000000   NOP
9D0042AC  00000000   NOP
9D0042B0  00000000   NOP
9D0042B4  00000000   NOP
9D0042B8  00000000   NOP
9D0042BC  00000000   NOP
9D0042C0  00000000   NOP
9D0042C4  00000000   NOP
9D0042C8  00000000   NOP
9D0042CC  00000000   NOP
9D0042D0  00000000   NOP
9D0042D4  00000000   NOP
9D0042D8  00000000   NOP
9D0042DC  00000000   NOP
9D0042E0  00000000   NOP
9D0042E4  00000000   NOP
9D0042E8  00000000   NOP
9D0042EC  00000000   NOP
9D0042F0  00000000   NOP
9D0042F4  00000000   NOP
9D0042F8  00000000   NOP
9D0042FC  00000000   NOP
9D004300  00000000   NOP
9D004304  00000000   NOP
9D004308  00000000   NOP
9D00430C  00000000   NOP
9D004310  00000000   NOP
9D004314  00000000   NOP
9D004318  00000000   NOP
9D00431C  00000000   NOP
9D004320  00000000   NOP
9D004324  00000000   NOP
9D004328  00000000   NOP
9D00432C  00000000   NOP
9D004330  00000000   NOP
9D004334  00000000   NOP
9D004338  00000000   NOP
9D00433C  00000000   NOP
9D004340  00000000   NOP
9D004344  00000000   NOP
9D004348  00000000   NOP
9D00434C  00000000   NOP
9D004350  00000000   NOP
9D004354  00000000   NOP
9D004358  00000000   NOP
9D00435C  00000000   NOP
9D004360  00000000   NOP
9D004364  00000000   NOP
9D004368  00000000   NOP
9D00436C  00000000   NOP
9D004370  00000000   NOP
9D004374  00000000   NOP
9D004378  00000000   NOP
9D00437C  00000000   NOP
9D004380  00000000   NOP
9D004384  00000000   NOP
9D004388  00000000   NOP
9D00438C  00000000   NOP
9D004390  00000000   NOP
9D004394  00000000   NOP
9D004398  00000000   NOP
9D00439C  00000000   NOP
9D0043A0  00000000   NOP
9D0043A4  00000000   NOP
9D0043A8  00000000   NOP
9D0043AC  00000000   NOP
9D0043B0  00000000   NOP
9D0043B4  00000000   NOP
9D0043B8  00000000   NOP
9D0043BC  00000000   NOP
9D0043C0  00000000   NOP
9D0043C4  00000000   NOP
9D0043C8  00000000   NOP
9D0043CC  00000000   NOP
9D0043D0  00000000   NOP
9D0043D4  00000000   NOP
9D0043D8  00000000   NOP
9D0043DC  00000000   NOP
9D0043E0  00000000   NOP
9D0043E4  00000000   NOP
9D0043E8  00000000   NOP
9D0043EC  00000000   NOP
9D0043F0  00000000   NOP
9D0043F4  00000000   NOP
9D0043F8  00000000   NOP
9D0043FC  00000000   NOP
9D004400  00000000   NOP
9D004404  00000000   NOP
9D004408  00000000   NOP
9D00440C  00000000   NOP
9D004410  00000000   NOP
9D004414  00000000   NOP
9D004418  00000000   NOP
9D00441C  00000000   NOP
9D004420  00000000   NOP
9D004424  00000000   NOP
9D004428  00000000   NOP
9D00442C  00000000   NOP
9D004430  00000000   NOP
9D004434  00000000   NOP
9D004438  00000000   NOP
9D00443C  00000000   NOP
9D004440  00000000   NOP
9D004444  00000000   NOP
9D004448  00000000   NOP
9D00444C  00000000   NOP
9D004450  00000000   NOP
9D004454  00000000   NOP
9D004458  00000000   NOP
9D00445C  00000000   NOP
9D004460  00000000   NOP
9D004464  00000000   NOP
9D004468  00000000   NOP
9D00446C  00000000   NOP
9D004470  00000000   NOP
9D004474  00000000   NOP
9D004478  00000000   NOP
9D00447C  00000000   NOP
9D004480  00000000   NOP
9D004484  00000000   NOP
9D004488  00000000   NOP
9D00448C  00000000   NOP
9D004490  00000000   NOP
9D004494  00000000   NOP
9D004498  00000000   NOP
9D00449C  00000000   NOP
9D0044A0  00000000   NOP
9D0044A4  00000000   NOP
9D0044A8  00000000   NOP
9D0044AC  00000000   NOP
9D0044B0  00000000   NOP
9D0044B4  00000000   NOP
9D0044B8  00000000   NOP
9D0044BC  00000000   NOP
9D0044C0  00000000   NOP
9D0044C4  00000000   NOP
9D0044C8  00000000   NOP
9D0044CC  00000000   NOP
9D0044D0  00000000   NOP
9D0044D4  00000000   NOP
9D0044D8  00000000   NOP
9D0044DC  00000000   NOP
9D0044E0  00000000   NOP
9D0044E4  00000000   NOP
9D0044E8  00000000   NOP
9D0044EC  00000000   NOP
9D0044F0  00000000   NOP
9D0044F4  00000000   NOP
9D0044F8  00000000   NOP
9D0044FC  00000000   NOP
9D004500  00000000   NOP
9D004504  00000000   NOP
9D004508  00000000   NOP
9D00450C  00000000   NOP
9D004510  00000000   NOP
9D004514  00000000   NOP
9D004518  00000000   NOP
9D00451C  00000000   NOP
9D004520  00000000   NOP
9D004524  00000000   NOP
9D004528  00000000   NOP
9D00452C  00000000   NOP
9D004530  00000000   NOP
9D004534  00000000   NOP
9D004538  00000000   NOP
9D00453C  00000000   NOP
9D004540  00000000   NOP
9D004544  00000000   NOP
9D004548  00000000   NOP
9D00454C  00000000   NOP
9D004550  00000000   NOP
9D004554  00000000   NOP
9D004558  00000000   NOP
9D00455C  00000000   NOP
9D004560  00000000   NOP
9D004564  00000000   NOP
9D004568  00000000   NOP
9D00456C  00000000   NOP
9D004570  00000000   NOP
9D004574  00000000   NOP
9D004578  00000000   NOP
9D00457C  00000000   NOP
9D004580  00000000   NOP
9D004584  00000000   NOP
9D004588  00000000   NOP
9D00458C  00000000   NOP
9D004590  00000000   NOP
9D004594  00000000   NOP
9D004598  00000000   NOP
9D00459C  00000000   NOP
9D0045A0  00000000   NOP
9D0045A4  00000000   NOP
9D0045A8  00000000   NOP
9D0045AC  00000000   NOP
9D0045B0  00000000   NOP
9D0045B4  00000000   NOP
9D0045B8  00000000   NOP
9D0045BC  00000000   NOP
9D0045C0  00000000   NOP
9D0045C4  00000000   NOP
9D0045C8  00000000   NOP
9D0045CC  00000000   NOP
9D0045D0  00000000   NOP
9D0045D4  00000000   NOP
9D0045D8  00000000   NOP
9D0045DC  00000000   NOP
9D0045E0  00000000   NOP
9D0045E4  00000000   NOP
9D0045E8  00000000   NOP
9D0045EC  00000000   NOP
9D0045F0  00000000   NOP
9D0045F4  00000000   NOP
9D0045F8  00000000   NOP
9D0045FC  00000000   NOP
9D004600  00000000   NOP
9D004604  00000000   NOP
9D004608  00000000   NOP
9D00460C  00000000   NOP
9D004610  00000000   NOP
9D004614  00000000   NOP
9D004618  00000000   NOP
9D00461C  00000000   NOP
9D004620  00000000   NOP
9D004624  00000000   NOP
9D004628  00000000   NOP
9D00462C  00000000   NOP
9D004630  00000000   NOP
9D004634  00000000   NOP
9D004638  00000000   NOP
9D00463C  00000000   NOP
9D004640  00000000   NOP
9D004644  00000000   NOP
9D004648  00000000   NOP
9D00464C  00000000   NOP
9D004650  00000000   NOP
9D004654  00000000   NOP
9D004658  00000000   NOP
9D00465C  00000000   NOP
9D004660  00000000   NOP
9D004664  00000000   NOP
9D004668  00000000   NOP
9D00466C  00000000   NOP
9D004670  00000000   NOP
9D004674  00000000   NOP
9D004678  00000000   NOP
9D00467C  00000000   NOP
9D004680  00000000   NOP
9D004684  00000000   NOP
9D004688  00000000   NOP
9D00468C  00000000   NOP
9D004690  00000000   NOP
9D004694  00000000   NOP
9D004698  00000000   NOP
9D00469C  00000000   NOP
9D0046A0  00000000   NOP
9D0046A4  00000000   NOP
9D0046A8  00000000   NOP
9D0046AC  00000000   NOP
9D0046B0  00000000   NOP
9D0046B4  00000000   NOP
9D0046B8  00000000   NOP
9D0046BC  00000000   NOP
9D0046C0  00000000   NOP
9D0046C4  00000000   NOP
9D0046C8  00000000   NOP
9D0046CC  00000000   NOP
9D0046D0  00000000   NOP
9D0046D4  00000000   NOP
9D0046D8  00000000   NOP
9D0046DC  00000000   NOP
9D0046E0  00000000   NOP
9D0046E4  00000000   NOP
9D0046E8  00000000   NOP
9D0046EC  00000000   NOP
9D0046F0  00000000   NOP
9D0046F4  00000000   NOP
9D0046F8  00000000   NOP
9D0046FC  00000000   NOP
9D004700  00000000   NOP
9D004704  00000000   NOP
9D004708  00000000   NOP
9D00470C  00000000   NOP
9D004710  00000000   NOP
9D004714  00000000   NOP
9D004718  00000000   NOP
9D00471C  00000000   NOP
9D004720  00000000   NOP
9D004724  00000000   NOP
9D004728  00000000   NOP
9D00472C  00000000   NOP
9D004730  00000000   NOP
9D004734  00000000   NOP
9D004738  00000000   NOP
9D00473C  00000000   NOP
9D004740  00000000   NOP
9D004744  00000000   NOP
9D004748  00000000   NOP
9D00474C  00000000   NOP
9D004750  00000000   NOP
9D004754  00000000   NOP
9D004758  00000000   NOP
9D00475C  00000000   NOP
9D004760  00000000   NOP
9D004764  00000000   NOP
                                                  898:   .end dbg_print
                                                  899:   
                                                  900:   dbg_msg:
                                                  901:   .string "debug check point: "
                                                  902:   
                                                  903:   
                                                  904:   opcodes_vectors:
                                                  905:   .word end,qrx,emit,lit,fcall,ret,bra,qbra,exec,store,fetch,cstore
                                                  906:   .word cfetch,rpfetch,rpstore,rfetch,tor,rfrom,spfetch,spstore,drop,dup,swap,over
                                                  907:   .word plus,minus,multi,divi,modulo,ltz,bitand,bitor,bitxor,bitnot,key
                                                  908:   .word sfr,set,clear,invert
                                                  909:   .word clit, wlit
                                                  910:   .word dotq, readln,rcall, type
                                                  911:   .word delay
                                                  912:   .word qdup, plus1, minus1,plusstore, ddrop, rot, ddup
                                                  913:   .word  min, max, abs, lshift, rshift, divmod
                                                  914:   .word qbraz, dot, zerosp, zerorp, herefetch,basefetch
                                                  915:   .word equal,nequal, less, greater,ltez,gtez, iemit
                                                  916:   .word space, spaces, crlf, cellp, cellm
                                                  917:   
                                                  918:   flash_code: .space FLASH_SIZE
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/sound.c  ------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   sound.c
20:                   * Author: Jacques Deschênes
21:                   *
22:                   * Created on 13 septembre 2013, 20:42
23:                   */
24:                  
25:                  #include "hardware/HardwareProfile.h"
26:                  
27:                  volatile unsigned char tone_on=0;
28:                  volatile unsigned int duration;
29:                  
30:                  void tone(unsigned int freq, // fréquence en hertz
31:                            unsigned int msec){ // durée en  millisecondes
32:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
33:                      OC3CONbits.OCM = 5; //mode pwm
9D00A520  3C02BF80   LUI V0, -16512
9D00A524  8C433400   LW V1, 13312(V0)
9D00A528  24060005   ADDIU A2, ZERO, 5
9D00A52C  7CC31004   INS V1, A2, 0, 3
9D00A530  AC433400   SW V1, 13312(V0)
34:                      OC3CONbits.OCTSEL=1; // timer 3
9D00A534  8C463400   LW A2, 13312(V0)
9D00A538  24030001   ADDIU V1, ZERO, 1
9D00A53C  7C6618C4   INS A2, V1, 3, 1
9D00A540  AC463400   SW A2, 13312(V0)
35:                      T3CON=0;
9D00A544  3C06BF80   LUI A2, -16512
9D00A548  ACC00A00   SW ZERO, 2560(A2)
36:                      PR3=(SYSCLK/8/freq)-1; // rapport cyclique 50%
9D00A54C  3C060047   LUI A2, 71
9D00A550  34C6868C   ORI A2, A2, -31092
9D00A554  00C4001B   DIVU A2, A0
9D00A558  008001F4   TEQ A0, ZERO
9D00A55C  00003012   MFLO A2, 0
9D00A560  24C6FFFF   ADDIU A2, A2, -1
9D00A564  3C07BF80   LUI A3, -16512
9D00A568  ACE60A20   SW A2, 2592(A3)
37:                      OC3RS=0;
9D00A56C  3C06BF80   LUI A2, -16512
9D00A570  ACC03420   SW ZERO, 13344(A2)
38:                      OC3R=SYSCLK/16/freq;
9D00A574  3C060023   LUI A2, 35
9D00A578  34C6C346   ORI A2, A2, -15546
9D00A57C  00C4001B   DIVU A2, A0
9D00A580  008001F4   TEQ A0, ZERO
9D00A584  00003012   MFLO A2, 0
9D00A588  3C07BF80   LUI A3, -16512
9D00A58C  ACE63410   SW A2, 13328(A3)
39:                      OC3CONbits.ON=1;
9D00A590  8C443400   LW A0, 13312(V0)
9D00A594  7C647BC4   INS A0, V1, 15, 1
9D00A598  AC443400   SW A0, 13312(V0)
40:                      duration=msec;
9D00A59C  AF85808C   SW A1, -32628(GP)
41:                      tone_on=1;
9D00A5A0  A3838048   SB V1, -32696(GP)
42:                      T3CONbits.TCKPS=3;
9D00A5A4  3C02BF80   LUI V0, -16512
9D00A5A8  8C440A00   LW A0, 2560(V0)
9D00A5AC  24050003   ADDIU A1, ZERO, 3
9D00A5B0  7CA43104   INS A0, A1, 4, 3
9D00A5B4  AC440A00   SW A0, 2560(V0)
43:                      T3CONbits.ON=1;
9D00A5B8  8C440A00   LW A0, 2560(V0)
9D00A5BC  7C647BC4   INS A0, V1, 15, 1
9D00A5C0  AC440A00   SW A0, 2560(V0)
44:                  } //tone();
9D00A5C4  03E00008   JR RA
9D00A5C8  00000000   NOP
45:                  
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/shell.c  ------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  
20:                  /*
21:                   * File:   shell.h
22:                   * Author: Jacques Deschênes
23:                   *
24:                   * Created on 18 septembre 2013, 07:29
25:                   * Description: un environnement de commande simple pour le VPC-32.
26:                   *   liste des commandes:
27:                   *      ls     liste des fichiers sur la carte SD
28:                   *      rm     efface un fichier.
29:                   *      mv     renomme un fichier.
30:                   *      ed     ouvre l'éditeur
31:                   *      as     assemble un fichier écris en assembleur pour la machine virtuelle.
32:                   *      run    execute un programme compilé pour la machine virtuelle.
33:                   *      cp     copie un fichier
34:                   *      snd    envoie un fichier vers le port sériel
35:                   *      rcv    reçois un fichier par le port sériel
36:                   *      forth  lance l'environnement vpForth
37:                   */
38:                  
39:                  #include <string.h>
40:                  #include "hardware/HardwareProfile.h"
41:                  #include "hardware/keyboard.h"
42:                  #include "console.h"
43:                  #include "hardware/Pinguino/ff.h"
44:                  #include <plib.h>
45:                  
46:                  #define MAX_LINE_LEN 80
47:                  typedef struct{
48:                      char buff[MAX_LINE_LEN]; // chaîne saisie par l'utilisateur.
49:                      unsigned char len;  // longueur de la chaîne.
50:                      unsigned char first; // position du premier caractère du mot
51:                      unsigned char next; // position du du curseur de l'analyseur.
52:                  } input_buff_t;
53:                  
54:                  static input_buff_t cmd_line;
55:                  
56:                  typedef enum CMDS {CMD_LS,CMD_RM,CMD_MV,CMD_ED,CMD_AS,CMD_RUN,
57:                                     CMD_CP,CMD_SND,CMD_RCV,CMD_FORTH} cmds_t;
58:                  
59:                  #define CMD_LEN 10
60:                  const char *commands[CMD_LEN]={
61:                      "ls","rm","mv","ed","as","run","cp","snd","rcv","forth"};
62:                  
63:                  int cmd_search(char *target){
9D009534  27BDFFD8   ADDIU SP, SP, -40
9D009538  AFBF0024   SW RA, 36(SP)
9D00953C  AFB30020   SW S3, 32(SP)
9D009540  AFB2001C   SW S2, 28(SP)
9D009544  AFB10018   SW S1, 24(SP)
9D009548  AFB00014   SW S0, 20(SP)
9D00954C  00809021   ADDU S2, A0, ZERO
64:                      int i;
65:                      for (i=CMD_LEN-1;i>=0;i--){
9D009550  3C11A000   LUI S1, -24576
9D009554  26314C9C   ADDIU S1, S1, 19612
9D009558  24100009   ADDIU S0, ZERO, 9
9D00955C  2413FFFF   ADDIU S3, ZERO, -1
9D009574  2610FFFF   ADDIU S0, S0, -1
9D009578  1613FFF9   BNE S0, S3, 0x9D009560
9D00957C  2631FFFC   ADDIU S1, S1, -4
66:                          if (!strcmp(target,commands[i])){
9D009560  02402021   ADDU A0, S2, ZERO
9D009564  0F40280F   JAL 0x9D00A03C
9D009568  8E250000   LW A1, 0(S1)
9D00956C  10400005   BEQ V0, ZERO, 0x9D009584
9D009570  02001021   ADDU V0, S0, ZERO
67:                              break;
68:                          }
69:                      }
70:                      return i;
71:                  }//cmd_search()
9D009580  02001021   ADDU V0, S0, ZERO
9D009584  8FBF0024   LW RA, 36(SP)
9D009588  8FB30020   LW S3, 32(SP)
9D00958C  8FB2001C   LW S2, 28(SP)
9D009590  8FB10018   LW S1, 24(SP)
9D009594  8FB00014   LW S0, 20(SP)
9D009598  03E00008   JR RA
9D00959C  27BD0028   ADDIU SP, SP, 40
72:                  
73:                  int next_token(void){
74:                      cmd_line.first=cmd_line.next;
9D0095A0  3C03A000   LUI V1, -24576
9D0095A4  24634C24   ADDIU V1, V1, 19492
9D0095A8  90620052   LBU V0, 82(V1)
9D0095AC  A0620051   SB V0, 81(V1)
75:                      while (cmd_line.first<cmd_line.len && cmd_line.buff[cmd_line.first]==' '){cmd_line.first++;}
9D0095B0  90640050   LBU A0, 80(V1)
9D0095B4  0044182B   SLTU V1, V0, A0
9D0095B8  10600016   BEQ V1, ZERO, 0x9D009614
9D0095BC  3C03A000   LUI V1, -24576
9D0095C0  24634C24   ADDIU V1, V1, 19492
9D0095C4  00431821   ADDU V1, V0, V1
9D0095C8  80650000   LB A1, 0(V1)
9D0095CC  24030020   ADDIU V1, ZERO, 32
9D0095D0  14A30026   BNE A1, V1, 0x9D00966C
9D0095D4  3C06A000   LUI A2, -24576
9D0095D8  24C64C24   ADDIU A2, A2, 19492
9D0095DC  24050020   ADDIU A1, ZERO, 32
9D0095E0  24420001   ADDIU V0, V0, 1
9D0095E4  304200FF   ANDI V0, V0, 255
9D0095E8  14440004   BNE V0, A0, 0x9D0095FC
9D0095EC  00461821   ADDU V1, V0, A2
9D0095F0  3C03A000   LUI V1, -24576
9D0095F4  0B402585   J 0x9D009614
9D0095F8  A0624C75   SB V0, 19573(V1)
9D0095FC  80630000   LB V1, 0(V1)
9D009600  5065FFF8   BEQL V1, A1, 0x9D0095E4
9D009604  24420001   ADDIU V0, V0, 1
9D009608  3C03A000   LUI V1, -24576
9D00960C  0B40259B   J 0x9D00966C
9D009610  A0624C75   SB V0, 19573(V1)
76:                      cmd_line.next=cmd_line.first;
9D009614  3C03A000   LUI V1, -24576
9D009618  0B402598   J 0x9D009660
9D00961C  A0624C76   SB V0, 19574(V1)
9D00966C  3C03A000   LUI V1, -24576
9D009670  24634C24   ADDIU V1, V1, 19492
9D009674  A0620052   SB V0, 82(V1)
77:                      while (cmd_line.next<cmd_line.len && cmd_line.buff[cmd_line.next]!=' '){cmd_line.next++;}
9D009620  3C07A000   LUI A3, -24576
9D009624  24E74C24   ADDIU A3, A3, 19492
9D009628  24060020   ADDIU A2, ZERO, 32
9D00962C  24630001   ADDIU V1, V1, 1
9D009630  306300FF   ANDI V1, V1, 255
9D009634  0064282B   SLTU A1, V1, A0
9D009638  10A00006   BEQ A1, ZERO, 0x9D009654
9D00963C  00672821   ADDU A1, V1, A3
9D009640  80A50000   LB A1, 0(A1)
9D009644  54A6FFFA   BNEL A1, A2, 0x9D009630
9D009648  24630001   ADDIU V1, V1, 1
9D009654  3C04A000   LUI A0, -24576
9D009658  A0834C76   SB V1, 19574(A0)
9D009678  00431821   ADDU V1, V0, V1
9D00967C  80660000   LB A2, 0(V1)
9D009680  24050020   ADDIU A1, ZERO, 32
9D009684  14C5FFE6   BNE A2, A1, 0x9D009620
9D009688  00401821   ADDU V1, V0, ZERO
78:                      if (cmd_line.next<(cmd_line.len)){
79:                          cmd_line.buff[cmd_line.next++]=(char)(0);
9D00964C  0B4025A4   J 0x9D009690
9D009650  3C04A000   LUI A0, -24576
9D00968C  3C04A000   LUI A0, -24576
9D009690  24844C24   ADDIU A0, A0, 19492
9D009694  00642821   ADDU A1, V1, A0
9D009698  A0A00000   SB ZERO, 0(A1)
9D00969C  24630001   ADDIU V1, V1, 1
9D0096A0  0B402597   J 0x9D00965C
9D0096A4  A0830052   SB V1, 82(A0)
80:                      }
81:                      if (cmd_line.next>cmd_line.first)
9D00965C  3C03A000   LUI V1, -24576
82:                          return 1;
9D009660  90634C76   LBU V1, 19574(V1)
83:                      else
84:                          return 0;
85:                  }//next_token()
9D009664  03E00008   JR RA
9D009668  0043102B   SLTU V0, V0, V1
86:                  
87:                  void parse_execute(void){
9D0096A8  27BDFFE0   ADDIU SP, SP, -32
9D0096AC  AFBF001C   SW RA, 28(SP)
9D0096B0  AFB10018   SW S1, 24(SP)
9D0096B4  AFB00014   SW S0, 20(SP)
88:                      while (next_token()){
9D0096C0  0B4025B8   J 0x9D0096E0
9D0096C4  24110009   ADDIU S1, ZERO, 9
9D0096E0  0F402568   JAL next_token
9D0096E4  00000000   NOP
9D0096E8  5440FFF7   BNEL V0, ZERO, 0x9D0096C8
9D0096EC  92040051   LBU A0, 81(S0)
89:                          switch (cmd_search(&cmd_line.buff[cmd_line.first])){
9D0096B8  3C10A000   LUI S0, -24576
9D0096BC  26104C24   ADDIU S0, S0, 19492
9D0096C8  0F40254D   JAL cmd_search
9D0096CC  02042021   ADDU A0, S0, A0
9D0096D0  14510003   BNE V0, S1, 0x9D0096E0
9D0096D4  00000000   NOP
90:                              case CMD_LS:
91:                                  break;
92:                              case CMD_RM:
93:                                  break;
94:                              case CMD_MV:
95:                                  break;
96:                              case CMD_ED:
97:                                  break;
98:                              case CMD_AS:
99:                                  break;
100:                             case CMD_FORTH:
101:                                 vpForth();
9D0096D8  0F401658   JAL vpForth
9D0096DC  00000000   NOP
102:                                 break;
103:                             case CMD_RUN:
104:                                 break;
105:                             case CMD_SND:
106:                                 break;
107:                             case CMD_RCV:
108:                                 break;
109:                             case CMD_CP:
110:                                 break;
111:                         }
112:                     }
113:                 }// parse_execute()
9D0096F0  8FBF001C   LW RA, 28(SP)
9D0096F4  8FB10018   LW S1, 24(SP)
9D0096F8  8FB00014   LW S0, 20(SP)
9D0096FC  03E00008   JR RA
9D009700  27BD0020   ADDIU SP, SP, 32
114:                 
115:                 const char *prompt="\r>";
116:                 
117:                 void shell(void){
9D009704  27BDFFE8   ADDIU SP, SP, -24
9D009708  AFBF0014   SW RA, 20(SP)
9D00970C  AFB00010   SW S0, 16(SP)
118:                     int len;
119:                     print(comm_channel,"VPC-32 shell\r");
9D009710  83848038   LB A0, -32712(GP)
9D009714  3C059D01   LUI A1, -25343
9D009718  0F401DDD   JAL print
9D00971C  24A5A924   ADDIU A1, A1, -22236
120:                     while (1){
121:                         print(comm_channel,prompt);
9D009728  83848038   LB A0, -32712(GP)
9D00972C  0F401DDD   JAL print
9D009730  8F858024   LW A1, -32732(GP)
9D00975C  0B4025CB   J 0x9D00972C
9D009760  83848038   LB A0, -32712(GP)
122:                         cmd_line.first=0;
9D009720  3C10A000   LUI S0, -24576
9D009724  26104C24   ADDIU S0, S0, 19492
9D009734  A2000051   SB ZERO, 81(S0)
123:                         cmd_line.next=0;
9D009738  A2000052   SB ZERO, 82(S0)
124:                         cmd_line.len=readline(comm_channel,cmd_line.buff,CHAR_PER_LINE);
9D00973C  83848038   LB A0, -32712(GP)
9D009740  02002821   ADDU A1, S0, ZERO
9D009744  0F401F23   JAL readline
9D009748  24060035   ADDIU A2, ZERO, 53
125:                         if (cmd_line.len){
9D00974C  1040FFF6   BEQ V0, ZERO, 0x9D009728
9D009750  A2020050   SB V0, 80(S0)
126:                             parse_execute();
9D009754  0F4025AA   JAL parse_execute
9D009758  00000000   NOP
127:                         }
128:                     }//while(1)
129:                 }//shell()
130:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/serial_comm.c  ---------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   uart.h
20:                   * Author: Jacques Deschênes
21:                   * Description: fonctions de bas niveau pour communication UART avec le PC
22:                   * Created on 17 avril 2013, 14:48
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "serial_comm.h"
27:                  #include "HardwareProfile.h"
28:                  
29:                  static char unget;
30:                  
31:                  void UartInit(UART_MODULE channel, int baudrate, UART_LINE_CONTROL_MODE LineCtrl){
9D008640  27BDFFE0   ADDIU SP, SP, -32
9D008644  AFBF001C   SW RA, 28(SP)
9D008648  AFB20018   SW S2, 24(SP)
9D00864C  AFB10014   SW S1, 20(SP)
9D008650  AFB00010   SW S0, 16(SP)
9D008654  00808021   ADDU S0, A0, ZERO
9D008658  00A09021   ADDU S2, A1, ZERO
9D00865C  00C08821   ADDU S1, A2, ZERO
32:                  /*initialise le périphérique UART*/
33:                     // Configure UART, information dans uart.h
34:                     UARTConfigure(channel, UART_ENABLE_PINS_TX_RX_ONLY); // pas de contrôle de flux matériel.
9D008660  0F402A78   JAL UARTConfigure
9D008664  00002821   ADDU A1, ZERO, ZERO
35:                     UARTSetLineControl(channel, LineCtrl);
9D008668  02002021   ADDU A0, S0, ZERO
9D00866C  0F402B20   JAL UARTSetLineControl
9D008670  02202821   ADDU A1, S1, ZERO
36:                     UARTSetDataRate(channel, mGetPeripheralClock(), baudrate);
9D008674  02002021   ADDU A0, S0, ZERO
9D008678  3C05023C   LUI A1, 572
9D00867C  24A53460   ADDIU A1, A1, 13408
9D008680  0F4029FC   JAL UARTSetDataRate
9D008684  02403021   ADDU A2, S2, ZERO
37:                     // activation du périphérique
38:                     UARTEnable(channel, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D008688  02002021   ADDU A0, S0, ZERO
9D00868C  0F4029C3   JAL UARTEnable
9D008690  24050087   ADDIU A1, ZERO, 135
39:                     unget=-1;
9D008694  2402FFFF   ADDIU V0, ZERO, -1
9D008698  A3828028   SB V0, -32728(GP)
40:                  };
9D00869C  8FBF001C   LW RA, 28(SP)
9D0086A0  8FB20018   LW S2, 24(SP)
9D0086A4  8FB10014   LW S1, 20(SP)
9D0086A8  8FB00010   LW S0, 16(SP)
9D0086AC  03E00008   JR RA
9D0086B0  27BD0020   ADDIU SP, SP, 32
41:                  
42:                  char UartGetch(UART_MODULE channel){
43:                  /*lecture d'un caractère retourne 0 si aucun disponible*/
44:                      char ch;
45:                      if (!unget==-1) {
46:                          ch=unget;
47:                          unget=-1;
48:                          return ch;
49:                      }else{
50:                          if (UARTReceivedDataIsAvailable (channel)){
9D0086D0  10800003   BEQ A0, ZERO, 0x9D0086E0
9D0086D4  00001021   ADDU V0, ZERO, ZERO
51:                                 return UARTGetDataByte(channel);
9D0086DC  7C021420   SEB V0, V0
52:                          }else{
53:                              return 0;
54:                          }
55:                      }
56:                  };
9D0086E0  03E00008   JR RA
9D0086E4  00000000   NOP
57:                  
58:                  void UartPutch(UART_MODULE channel, char c){
9D0086E8  7C052C20   SEB A1, A1
59:                  /*Envoie d'un caractère*/
60:                      while(!UARTTransmitterIsReady(channel));
9D008708  1440FFFD   BNE V0, ZERO, 0x9D008700
9D00870C  00000000   NOP
61:                        UARTSendDataByte(channel, c);
62:                  };
9D008718  03E00008   JR RA
9D00871C  00000000   NOP
63:                  
64:                  char UartWaitch(UART_MODULE channel, int delay){
9D008720  27BDFFE0   ADDIU SP, SP, -32
9D008724  AFBF001C   SW RA, 28(SP)
9D008728  AFB10018   SW S1, 24(SP)
9D00872C  AFB00014   SW S0, 20(SP)
9D008730  00808021   ADDU S0, A0, ZERO
65:                  /*attend un caractère pour un temps spécifié par delay
66:                  *retourne 0 si aucun reçu avant expiration du délais
67:                  */
68:                      int t;
69:                      char ch;
70:                      if (!unget==-1){
71:                          ch=unget;
72:                          unget=-1;
73:                          return unget;
74:                      }
75:                      if (!delay) while (1) if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D008734  14A0000D   BNE A1, ZERO, 0x9D00876C
9D008738  00A08821   ADDU S1, A1, ZERO
9D008758  1040FFFD   BEQ V0, ZERO, 0x9D008750
9D00875C  00000000   NOP
9D008764  0B4021ED   J 0x9D0087B4
9D008768  7C021420   SEB V0, V0
76:                      t=ticks()+delay;
9D00876C  0F402462   JAL ticks
9D008770  00108080   SLL S0, S0, 2
77:                      while (ticks()<delay){
9D00877C  0B4021E8   J 0x9D0087A0
9D008780  02028021   ADDU S0, S0, V0
9D0087A0  0F402462   JAL ticks
9D0087A4  00000000   NOP
9D0087A8  0051102B   SLTU V0, V0, S1
9D0087AC  5440FFF5   BNEL V0, ZERO, 0x9D008784
9D0087B0  8E020000   LW V0, 0(S0)
78:                         if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D00878C  10600004   BEQ V1, ZERO, 0x9D0087A0
9D008790  00000000   NOP
9D008798  0B4021ED   J 0x9D0087B4
9D00879C  7C021420   SEB V0, V0
79:                      }
80:                      return 0;
81:                  }
9D0087B4  8FBF001C   LW RA, 28(SP)
9D0087B8  8FB10018   LW S1, 24(SP)
9D0087BC  8FB00014   LW S0, 20(SP)
9D0087C0  03E00008   JR RA
9D0087C4  27BD0020   ADDIU SP, SP, 32
82:                  
83:                  void UartPrint(UART_MODULE channel, const char* str){
84:                  /* envoie la chaine de caractère str via le UART */
85:                     while(*str != (char)0)
9D0087C8  80A60000   LB A2, 0(A1)
9D0087CC  10C0000F   BEQ A2, ZERO, 0x9D00880C
9D0087D0  00041880   SLL V1, A0, 2
9D008800  80A60000   LB A2, 0(A1)
9D008804  14C0FFF7   BNE A2, ZERO, 0x9D0087E4
9D008808  00000000   NOP
86:                     {
87:                        while(!UARTTransmitterIsReady(channel));
9D0087EC  1440FFFD   BNE V0, ZERO, 0x9D0087E4
9D0087F0  00000000   NOP
88:                        UARTSendDataByte(channel, *str++);
9D0087F4  24A50001   ADDIU A1, A1, 1
89:                     }
90:                     while(!UARTTransmissionHasCompleted(channel));
9D008828  1040FFFD   BEQ V0, ZERO, 0x9D008820
9D00882C  00000000   NOP
91:                  };
9D008830  03E00008   JR RA
9D008834  00000000   NOP
92:                  
93:                  int UartReadln(UART_MODULE channel, char *buffer, int buff_len){
9D008838  27BDFFD0   ADDIU SP, SP, -48
9D00883C  AFBF002C   SW RA, 44(SP)
9D008840  AFB50028   SW S5, 40(SP)
9D008844  AFB40024   SW S4, 36(SP)
9D008848  AFB30020   SW S3, 32(SP)
9D00884C  AFB2001C   SW S2, 28(SP)
9D008850  AFB10018   SW S1, 24(SP)
9D008854  AFB00014   SW S0, 20(SP)
9D008858  00809821   ADDU S3, A0, ZERO
9D00885C  00A0A021   ADDU S4, A1, ZERO
9D008860  00C08821   ADDU S1, A2, ZERO
94:                  /* lecture d'une chaine se terminant par '\r'
95:                   *  complète la chaine avec un zéro
96:                   *  retourne le nombre de caractère dans le buffer.
97:                   */
98:                      int count=0;
9D008864  00008021   ADDU S0, ZERO, ZERO
99:                      char c;
100:                     if (!unget==-1){
101:                         c=unget;
102:                         unget=-1;
103:                         *buffer++=c;
104:                         if (c==CR) return;
105:                     }
106:                     while (count < (buff_len-1)){
9D008878  0B40223D   J 0x9D0088F4
9D00887C  3C159D01   LUI S5, -25343
9D0088DC  0B40223E   J 0x9D0088F8
9D0088E0  2622FFFF   ADDIU V0, S1, -1
9D0088F4  2622FFFF   ADDIU V0, S1, -1
9D0088F8  0202102A   SLT V0, S0, V0
9D0088FC  5440FFE0   BNEL V0, ZERO, 0x9D008880
9D008900  8E420000   LW V0, 0(S2)
107:                         if (UARTReceivedDataIsAvailable(channel)){
9D008888  5060001B   BEQL V1, ZERO, 0x9D0088F8
9D00888C  2622FFFF   ADDIU V0, S1, -1
108:                             c = UARTGetDataByte(channel);
9D008894  7C052C20   SEB A1, A1
109:                             if (c==CR){UartPutch(channel,'\r'); break;}
9D008898  2402000D   ADDIU V0, ZERO, 13
9D00889C  14A20006   BNE A1, V0, 0x9D0088B8
9D0088A0  24020008   ADDIU V0, ZERO, 8
9D0088A4  02602021   ADDU A0, S3, ZERO
9D0088A8  0F4021BA   JAL UartPutch
9D0088AC  2405000D   ADDIU A1, ZERO, 13
9D0088B0  0B402241   J 0x9D008904
9D0088B4  00000000   NOP
110:                             if (c==BS){
9D0088B8  54A2000A   BNEL A1, V0, 0x9D0088E4
9D0088BC  A2850000   SB A1, 0(S4)
111:                                 if (count){
9D0088C0  5200000D   BEQL S0, ZERO, 0x9D0088F8
9D0088C4  2622FFFF   ADDIU V0, S1, -1
112:                                     buffer--;
9D0088C8  2694FFFF   ADDIU S4, S4, -1
113:                                     count--;
9D0088CC  2610FFFF   ADDIU S0, S0, -1
114:                                     UartPrint(channel,"\b \b");
9D0088D0  02602021   ADDU A0, S3, ZERO
9D0088D4  0F4021F2   JAL UartPrint
9D0088D8  26A5ADEC   ADDIU A1, S5, -21012
115:                                 }
116:                             }else{
117:                                 *buffer++=c;
9D0088E4  26940001   ADDIU S4, S4, 1
118:                                 count++;
9D0088E8  26100001   ADDIU S0, S0, 1
119:                                 UartPutch(channel,c);
9D0088EC  0F4021BA   JAL UartPutch
9D0088F0  02602021   ADDU A0, S3, ZERO
120:                             }
121:                             
122:                         }
123:                     }
124:                     if (count) *buffer = (char)0;
9D008904  56000001   BNEL S0, ZERO, 0x9D00890C
9D008908  A2800000   SB ZERO, 0(S4)
125:                     UartPutch(channel,'\r');
9D00890C  02602021   ADDU A0, S3, ZERO
9D008910  0F4021BA   JAL UartPutch
9D008914  2405000D   ADDIU A1, ZERO, 13
126:                     return count;
127:                 }
9D008918  02001021   ADDU V0, S0, ZERO
9D00891C  8FBF002C   LW RA, 44(SP)
9D008920  8FB50028   LW S5, 40(SP)
9D008924  8FB40024   LW S4, 36(SP)
9D008928  8FB30020   LW S3, 32(SP)
9D00892C  8FB2001C   LW S2, 28(SP)
9D008930  8FB10018   LW S1, 24(SP)
9D008934  8FB00014   LW S0, 20(SP)
9D008938  03E00008   JR RA
9D00893C  27BD0030   ADDIU SP, SP, 48
128:                 
129:                 int UartReceivedBreak(UART_MODULE channel){
130:                    char ch;
131:                    if (unget==-1 && UARTReceivedDataIsAvailable(channel)) {
9D008940  83858028   LB A1, -32728(GP)
9D008944  2403FFFF   ADDIU V1, ZERO, -1
9D008948  14A30011   BNE A1, V1, 0x9D008990
9D00894C  00001021   ADDU V0, ZERO, ZERO
9D00896C  10800008   BEQ A0, ZERO, 0x9D008990
9D008970  00001021   ADDU V0, ZERO, ZERO
132:                        ch=UARTGetDataByte(channel);
9D008978  7C031C20   SEB V1, V1
133:                        if (ch==ESC) return 1; else unget=ch;
9D00897C  2404001B   ADDIU A0, ZERO, 27
9D008980  10640003   BEQ V1, A0, 0x9D008990
9D008984  24020001   ADDIU V0, ZERO, 1
9D008988  A3838028   SB V1, -32728(GP)
134:                    }
135:                    return 0;
9D00898C  00001021   ADDU V0, ZERO, ZERO
136:                 }
9D008990  03E00008   JR RA
9D008994  00000000   NOP
137:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/ntsc.c  ----------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /* 
19:                   * File:   test-ntsc.c
20:                   * Author: Jacques Deschênes
21:                   * Description: test génération signal vidéo NTSC sur PIC32MX150F128B.
22:                   * Created on 20 août 2013, 08:48
23:                   */
24:                  
25:                  #include <stdio.h>
26:                  #include <stdlib.h>
27:                  #include <sys/attribs.h>
28:                  #include <plib.h>
29:                  #include "HardwareProfile.h"
30:                  #include "ntsc.h"
31:                  
32:                  /*
33:                   *  la fréqueence PBCLK influence la largeur des pixels vidéo. Comme PBCLK==SYSCLK
34:                   *  on peut allonger les pixels en diminuant la fréquence légèrement.
35:                   *  pour une résolution horizontale de 320 pixels et une fréquence de 40Mhz le
36:                   *  meilleur diviseur pour le générateur BGR du SPI est de 2 ce qui donne
37:                   *  une fréquence de pixel de  40e6/(2*(2+1)=6,67Mhz et la durée total d'une
38:                   *  ligne vidéo est donc de 320/6,67e6= 48µSec.
39:                   *  En principe pour le standard NTSC on dispose de 52µSec par ligne vidéo.
40:                   *  En pratique on est plutôt à 51µSec. Donc ici on a 3µSec inutilisées.
41:                   *  en résuidant SYSCLK à 37,5Mhz on a 51,2µSec par ligne vidéo. Les pixels
42:                   *  sont donc moins compressé horizontalement. Mais sur certains téléviseurs
43:                   *  on peut perdre quelques pixels en bout de ligne.
44:                   *  la constante SPI_DLY doit-être ajustée en fonction de PBCLK pour que les
45:                   *  320 pixels horizontals soient visibles.
46:                   */
47:                  
48:                  #define PWM_PERIOD (SYSCLK/15748)-1
49:                  #define HSYNC  (SYSCLK/212766)  // 4,7µSec
50:                  #define FIRST_LINE 27   //première ligne de scan visible
51:                  #define LAST_LINE  256  // dernière ligne de scan visible
52:                  #define BITCLK HRES * 1000000L/52 // 52µSec c'est le temps que dure 1 ligne vidéo.
53:                  #if SYSCLK==40000000L
54:                  #define SPI_DLY HSYNC+90 // délais en début de ligne avant l'envoie du signal vidéo.
55:                  #else
56:                  #define SPI_DLY HSYNC+30 // délais en début de ligne avant l'envoie du signal vidéo.
57:                  #endif
58:                  #define _enable_video_out()  SPI1CONSET =(1<<15)
59:                  #define _disable_video_out() SPI1CONCLR =(1<<15)
60:                  
61:                  unsigned int video_bmp[VRES][HRES/32]; // video bitmap 7168 octets
62:                  volatile unsigned int ln_cnt;
63:                  volatile unsigned int video;
64:                  volatile int *DmaSrc;
65:                  
66:                  
67:                  
68:                  void VideoInit(void){
9D008998  27BDFFD8   ADDIU SP, SP, -40
9D00899C  AFBF0024   SW RA, 36(SP)
9D0089A0  AFB20020   SW S2, 32(SP)
9D0089A4  AFB1001C   SW S1, 28(SP)
9D0089A8  AFB00018   SW S0, 24(SP)
69:                      //configuration PWM sur OC2 pour SYNC, utilisation TIMER2
70:                      T2CON = 0;
9D0089AC  3C02BF80   LUI V0, -16512
9D0089B0  AC400800   SW ZERO, 2048(V0)
71:                      PR2=PWM_PERIOD;
9D0089B4  2403094C   ADDIU V1, ZERO, 2380
9D0089B8  3C02BF80   LUI V0, -16512
9D0089BC  AC430820   SW V1, 2080(V0)
72:                      OC2CONbits.OCM = 5; // mode train d'impulsion
9D0089C0  3C02BF80   LUI V0, -16512
9D0089C4  8C433200   LW V1, 12800(V0)
9D0089C8  24120005   ADDIU S2, ZERO, 5
9D0089CC  7E431004   INS V1, S2, 0, 3
9D0089D0  AC433200   SW V1, 12800(V0)
73:                      OC2RS = 0; 
9D0089D4  3C03BF80   LUI V1, -16512
9D0089D8  AC603220   SW ZERO, 12832(V1)
74:                      OC2R = HSYNC;
9D0089DC  240400B0   ADDIU A0, ZERO, 176
9D0089E0  3C03BF80   LUI V1, -16512
9D0089E4  AC643210   SW A0, 12816(V1)
75:                      IFS0bits.T2IF=0;
9D0089E8  3C03BF88   LUI V1, -16504
9D0089EC  8C641030   LW A0, 4144(V1)
9D0089F0  7C044A44   INS A0, ZERO, 9, 1
9D0089F4  AC641030   SW A0, 4144(V1)
76:                      IEC0bits.T2IE=1;
9D0089F8  3C03BF88   LUI V1, -16504
9D0089FC  8C641060   LW A0, 4192(V1)
9D008A00  24110001   ADDIU S1, ZERO, 1
9D008A04  7E244A44   INS A0, S1, 9, 1
9D008A08  AC641060   SW A0, 4192(V1)
77:                      IPC2bits.T2IP=7;
9D008A0C  3C03BF88   LUI V1, -16504
9D008A10  8C6410B0   LW A0, 4272(V1)
9D008A14  24050007   ADDIU A1, ZERO, 7
9D008A18  7CA42084   INS A0, A1, 2, 3
9D008A1C  AC6410B0   SW A0, 4272(V1)
78:                      IPC2bits.T2IS=3;
9D008A20  8C6410B0   LW A0, 4272(V1)
9D008A24  24050003   ADDIU A1, ZERO, 3
9D008A28  7CA40804   INS A0, A1, 0, 2
9D008A2C  AC6410B0   SW A0, 4272(V1)
79:                      OC2CONbits.ON =1;  // activation
9D008A30  8C433200   LW V1, 12800(V0)
9D008A34  7E237BC4   INS V1, S1, 15, 1
9D008A38  AC433200   SW V1, 12800(V0)
80:                      T2CONbits.ON=1;  // activation
9D008A3C  3C02BF80   LUI V0, -16512
9D008A40  8C430800   LW V1, 2048(V0)
9D008A44  7E237BC4   INS V1, S1, 15, 1
9D008A48  AC430800   SW V1, 2048(V0)
81:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
82:                      OC1CONbits.OCM = 5; //mode train d'impulsion
9D008A4C  3C02BF80   LUI V0, -16512
9D008A50  8C433000   LW V1, 12288(V0)
9D008A54  7E431004   INS V1, S2, 0, 3
9D008A58  AC433000   SW V1, 12288(V0)
83:                      OC1RS=0;
9D008A5C  3C03BF80   LUI V1, -16512
9D008A60  AC603020   SW ZERO, 12320(V1)
84:                      OC1R=HSYNC+SPI_DLY;
9D008A64  2404017E   ADDIU A0, ZERO, 382
9D008A68  3C03BF80   LUI V1, -16512
9D008A6C  AC643010   SW A0, 12304(V1)
85:                      OC1CONbits.ON=1;
9D008A70  8C433000   LW V1, 12288(V0)
9D008A74  7E237BC4   INS V1, S1, 15, 1
9D008A78  AC433000   SW V1, 12288(V0)
86:                      // configuration SPI pour sortie vidéo
87:                      // configure le DMA
88:                      DmaChnOpen(0,0,DMA_OPEN_DEFAULT);
9D008A7C  00002021   ADDU A0, ZERO, ZERO
9D008A80  00002821   ADDU A1, ZERO, ZERO
9D008A84  0F4028D9   JAL DmaChnOpen
9D008A88  00003021   ADDU A2, ZERO, ZERO
89:                      DmaChnSetEventControl(0,DMA_EV_START_IRQ_EN|
9D008A8C  00002021   ADDU A0, ZERO, ZERO
9D008A90  0F402AF5   JAL DmaChnWriteEventControlFlags
9D008A94  24052610   ADDIU A1, ZERO, 9744
90:                                            DMA_EV_START_IRQ(_SPI1_TX_IRQ));
91:                      DmaChnSetTxfer(0,(void *)DmaSrc,(void *)&SPI1BUF,HRES/8,4,4);
9D008A98  24020004   ADDIU V0, ZERO, 4
9D008A9C  AFA20010   SW V0, 16(SP)
9D008AA0  AFA20014   SW V0, 20(SP)
9D008AA4  00002021   ADDU A0, ZERO, ZERO
9D008AA8  8F85804C   LW A1, -32692(GP)
9D008AAC  3C06BF80   LUI A2, -16512
9D008AB0  24C65820   ADDIU A2, A2, 22560
9D008AB4  0F40299D   JAL DmaChnSetTxfer
9D008AB8  24070028   ADDIU A3, ZERO, 40
92:                      // configuration du SPI canal 1
93:                      SPI1CONbits.DISSDI=1; // SDI n'est pas utilisé.
9D008ABC  3C10BF80   LUI S0, -16512
9D008AC0  8E025800   LW V0, 22528(S0)
9D008AC4  7E222104   INS V0, S1, 4, 1
9D008AC8  AE025800   SW V0, 22528(S0)
94:                      SPI1CONbits.FRMEN=1; // frame mode
9D008ACC  8E025800   LW V0, 22528(S0)
9D008AD0  7E22FFC4   INS V0, S1, 31, 1
9D008AD4  AE025800   SW V0, 22528(S0)
95:                      SPI1CONbits.FRMCNT=5; // 32 octets par frame.
9D008AD8  8E025800   LW V0, 22528(S0)
9D008ADC  7E42D604   INS V0, S2, 24, 3
9D008AE0  AE025800   SW V0, 22528(S0)
96:                      SPI1CONbits.FRMPOL=1; // sync sur transition montante
9D008AE4  8E025800   LW V0, 22528(S0)
9D008AE8  7E22EF44   INS V0, S1, 29, 1
9D008AEC  AE025800   SW V0, 22528(S0)
97:                      SPI1CONbits.FRMSYNC=1; // synchronisation esclave
9D008AF0  8E025800   LW V0, 22528(S0)
9D008AF4  7E22F784   INS V0, S1, 30, 1
9D008AF8  AE025800   SW V0, 22528(S0)
98:                      SPI1CONbits.MSTEN=1; // SPI maître
9D008AFC  8E025800   LW V0, 22528(S0)
9D008B00  7E222944   INS V0, S1, 5, 1
9D008B04  AE025800   SW V0, 22528(S0)
99:                     // SPI1CONbits.SPIFE=1; // synchronisation sur clock premier bit.
100:                     SPI1CONbits.MODE32=1; // mode 32 bits
9D008B08  8E025800   LW V0, 22528(S0)
9D008B0C  7E225AC4   INS V0, S1, 11, 1
9D008B10  AE025800   SW V0, 22528(S0)
101:                     SPI1CONbits.STXISEL=1; // interruption sur TBE
9D008B14  8E025800   LW V0, 22528(S0)
9D008B18  7E221884   INS V0, S1, 2, 2
9D008B1C  AE025800   SW V0, 22528(S0)
102:                     SpiChnSetBitRate(SPI_CHANNEL1, PBCLK, BITCLK);
9D008B20  24040001   ADDIU A0, ZERO, 1
9D008B24  3C05023C   LUI A1, 572
9D008B28  24A53460   ADDIU A1, A1, 13408
9D008B2C  3C06005D   LUI A2, 93
9D008B30  0F402A69   JAL SpiChnSetBitRate
9D008B34  34C6E676   ORI A2, A2, -6538
103:                     SPI1CONbits.ON=1;
9D008B38  8E025800   LW V0, 22528(S0)
9D008B3C  7E227BC4   INS V0, S1, 15, 1
9D008B40  AE025800   SW V0, 22528(S0)
104:                 }//init_video()
9D008B44  8FBF0024   LW RA, 36(SP)
9D008B48  8FB20020   LW S2, 32(SP)
9D008B4C  8FB1001C   LW S1, 28(SP)
9D008B50  8FB00018   LW S0, 24(SP)
9D008B54  03E00008   JR RA
9D008B58  27BD0028   ADDIU SP, SP, 40
105:                 
106:                 
107:                 
108:                 void __ISR(_TIMER_2_VECTOR,IPL7AUTO) tmr2_isr(void){
9D008B5C  415DE800   RDPGPR SP, SP
9D008B60  401B7000   MFC0 K1, EPC
9D008B64  401A6002   MFC0 K0, SRSCtl
9D008B68  27BDFFE0   ADDIU SP, SP, -32
9D008B6C  401B6000   MFC0 K1, Status
9D008B70  AFBA001C   SW K0, 28(SP)
9D008B74  AFBB0018   SW K1, 24(SP)
9D008B78  7C1B7844   INS K1, ZERO, 1, 15
9D008B7C  377B1C00   ORI K1, K1, 7168
9D008B80  409B6000   MTC0 K1, Status
9D008B84  AFA30008   SW V1, 8(SP)
9D008B88  AFA20004   SW V0, 4(SP)
9D008B8C  AFA4000C   SW A0, 12(SP)
109:                     _disable_video_out();
9D008B90  34038000   ORI V1, ZERO, -32768
9D008B94  3C02BF80   LUI V0, -16512
9D008B98  AC435804   SW V1, 22532(V0)
110:                     ln_cnt++;
9D008B9C  8F828054   LW V0, -32684(GP)
9D008BA0  24420001   ADDIU V0, V0, 1
9D008BA4  AF828054   SW V0, -32684(GP)
111:                     switch (ln_cnt){
9D008BA8  8F828054   LW V0, -32684(GP)
9D008BAC  2403001A   ADDIU V1, ZERO, 26
9D008BB0  1043001C   BEQ V0, V1, 0x9D008C24
9D008BB4  2C43001B   SLTIU V1, V0, 27
9D008BB8  10600009   BEQ V1, ZERO, 0x9D008BE0
9D008BBC  24030101   ADDIU V1, ZERO, 257
9D008BC0  24030001   ADDIU V1, ZERO, 1
9D008BC4  1043000D   BEQ V0, V1, 0x9D008BFC
9D008BC8  2403089C   ADDIU V1, ZERO, 2204
9D008BCC  24030004   ADDIU V1, ZERO, 4
9D008BD0  1443001D   BNE V0, V1, 0x9D008C48
9D008BD4  240300B0   ADDIU V1, ZERO, 176
9D008BE0  10430016   BEQ V0, V1, 0x9D008C3C
9D008BE4  00000000   NOP
9D008BE8  24030106   ADDIU V1, ZERO, 262
9D008BEC  14430016   BNE V0, V1, 0x9D008C48
9D008BF0  00000000   NOP
9D008BF4  0B402306   J 0x9D008C18
9D008BF8  00000000   NOP
112:                         case 1:  // début vsync
113:                             OC2R=PWM_PERIOD-HSYNC;
9D008BFC  3C02BF80   LUI V0, -16512
9D008C00  AC433210   SW V1, 12816(V0)
114:                             break;
9D008C04  0B402327   J 0x9D008C9C
9D008C08  24030200   ADDIU V1, ZERO, 512
115:                         case 4: // fin vsync
116:                             OC2R=HSYNC;
9D008BD8  0B402303   J 0x9D008C0C
9D008BDC  3C02BF80   LUI V0, -16512
9D008C0C  AC433210   SW V1, 12816(V0)
117:                             break;
9D008C10  0B402327   J 0x9D008C9C
9D008C14  24030200   ADDIU V1, ZERO, 512
118:                         case 262:  //fin du frame
119:                             ln_cnt=0;
9D008C18  AF808054   SW ZERO, -32684(GP)
120:                             break;
9D008C1C  0B402327   J 0x9D008C9C
9D008C20  24030200   ADDIU V1, ZERO, 512
121:                   
122:                         case FIRST_LINE-1:
123:                             video=1;
9D008C24  24020001   ADDIU V0, ZERO, 1
9D008C28  AF828050   SW V0, -32688(GP)
124:                             DmaSrc=(void*)&video_bmp[0];
9D008C2C  3C02A000   LUI V0, -24576
9D008C30  24420080   ADDIU V0, V0, 128
125:                             break;
9D008C34  0B402326   J 0x9D008C98
9D008C38  AF82804C   SW V0, -32692(GP)
126:                         case LAST_LINE+1:
127:                             video=0;
9D008C3C  AF808050   SW ZERO, -32688(GP)
128:                             break;
9D008C40  0B402327   J 0x9D008C9C
9D008C44  24030200   ADDIU V1, ZERO, 512
129:                         default:
130:                             if (video){
9D008C48  8F828050   LW V0, -32688(GP)
9D008C4C  10400012   BEQ V0, ZERO, 0x9D008C98
9D008C50  34038000   ORI V1, ZERO, -32768
131:                                 _enable_video_out();
9D008C54  3C02BF80   LUI V0, -16512
9D008C58  AC435808   SW V1, 22536(V0)
132:                                 IFS1bits.SPI1TXIF=1;
9D008C5C  3C02BF88   LUI V0, -16504
9D008C60  8C431040   LW V1, 4160(V0)
9D008C64  24040001   ADDIU A0, ZERO, 1
9D008C68  7C833184   INS V1, A0, 6, 1
9D008C6C  AC431040   SW V1, 4160(V0)
133:                                 DCH0SSA=KVA_TO_PA((void *)DmaSrc);
9D008C70  8F82804C   LW V0, -32692(GP)
9D008C74  7C44E000   EXT A0, V0, 0, 29
9D008C78  3C03BF88   LUI V1, -16504
9D008C7C  AC643090   SW A0, 12432(V1)
134:                                 DmaSrc +=HRES/32;
9D008C80  24420028   ADDIU V0, V0, 40
9D008C84  AF82804C   SW V0, -32692(GP)
135:                                 DCH0CON |=128; // remplace DmaChnEnable(0); réduit le temps de latence
9D008C88  3C02BF88   LUI V0, -16504
9D008C8C  8C433060   LW V1, 12384(V0)
9D008C90  34630080   ORI V1, V1, 128
9D008C94  AC433060   SW V1, 12384(V0)
136:                             }
137:                     }//switch (ln_cnt)
138:                     mT2ClearIntFlag();
9D008C98  24030200   ADDIU V1, ZERO, 512
9D008C9C  3C02BF88   LUI V0, -16504
9D008CA0  AC431034   SW V1, 4148(V0)
139:                 }//tmr2_isr()
9D008CA4  8FA2001C   LW V0, 28(SP)
9D008CA8  3042000F   ANDI V0, V0, 15
9D008CAC  14400004   BNE V0, ZERO, 0x9D008CC0
9D008CB0  8FBB0018   LW K1, 24(SP)
9D008CB4  8FA4000C   LW A0, 12(SP)
9D008CB8  8FA30008   LW V1, 8(SP)
9D008CBC  8FA20004   LW V0, 4(SP)
9D008CC0  8FBA001C   LW K0, 28(SP)
9D008CC4  27BD0020   ADDIU SP, SP, 32
9D008CC8  409A6002   MTC0 K0, SRSCtl
9D008CCC  41DDE800   WRPGPR SP, SP
9D008CD0  409B6000   MTC0 K1, Status
9D008CD4  42000018   ERET
140:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/keyboard.c  ------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * Name: keyboard.c
20:                   * Author: Jacques Deschênes
21:                   * Description:  interface avec clavier PS/2
22:                   * Date: 2013-08-26
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "hardwareProfile.h"
27:                  #include "keyboard.h"
28:                  #include "QWERTY.h"
29:                  
30:                  #define KBD_CLK 1  // SET/CLR bit
31:                  #define KBD_DAT 2  // SET/CLR bit
32:                  
33:                  #define _wait_key() while (head==tail)
34:                  
35:                  
36:                  static  unsigned char kbd_queue[32]; // file circulaire pour les codes reçus du clavier.
37:                  volatile  static unsigned char head=0, tail=0; // tête et queue de la file
38:                  volatile  static unsigned char  in_byte=0, bit_cnt=0, parity=0;
39:                  volatile unsigned char rx_flags=0, kbd_leds=0;
40:                  volatile unsigned short key_state; // état des touches d'alteration: shift, ctrl, alt,etc.
41:                  
42:                  #define FN_COUNT 32
43:                  const short fn_keys[FN_COUNT]={CAPS_LOCK,SCROLL_LOCK,NUM_LOCK,LSHIFT,RSHIFT,LCTRL,
44:                  RCTRL,LALT,RALT,F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,PRN,PAUSE,UP_ARROW,DOWN_ARROW,
45:                  LEFT_ARROW,RIGHT_ARROW,INSERT,HOME,PGUP,PGDN,END
46:                  };
47:                  
48:                  static int KbdReset(void);
49:                  
50:                  int KeyboardInit(){ // initialisation E/S et RAZ clavier
9D006468  27BDFFE0   ADDIU SP, SP, -32
9D00646C  AFBF001C   SW RA, 28(SP)
9D006470  AFB20018   SW S2, 24(SP)
9D006474  AFB10014   SW S1, 20(SP)
51:                      unsigned char c;
52:                      unsigned int t0;
53:                      t0=ticks()+750;
9D006478  0F402462   JAL ticks
9D00647C  AFB00010   SW S0, 16(SP)
9D006480  245002EE   ADDIU S0, V0, 750
54:                      head=0;
9D006484  A380802F   SB ZERO, -32721(GP)
55:                      tail=0;
9D006488  A380802D   SB ZERO, -32723(GP)
56:                      in_byte=0;
9D00648C  A380802E   SB ZERO, -32722(GP)
57:                      bit_cnt=0;
9D006490  A380802B   SB ZERO, -32725(GP)
58:                      parity=0;
9D006494  A380802C   SB ZERO, -32724(GP)
59:                      rx_flags=0;
9D006498  A3808029   SB ZERO, -32727(GP)
60:                      kbd_leds=0;
9D00649C  A380802A   SB ZERO, -32726(GP)
61:                      key_state=0;
9D0064A0  A780805C   SH ZERO, -32676(GP)
62:                      TRISASET=KBD_CLK|KBD_DAT;
9D0064A4  24040003   ADDIU A0, ZERO, 3
9D0064A8  3C02BF88   LUI V0, -16504
9D0064AC  AC446018   SW A0, 24600(V0)
63:                      INTCONbits.INT4EP=0; // interruption sur transition descendante
9D0064B0  3C02BF88   LUI V0, -16504
9D0064B4  8C431000   LW V1, 4096(V0)
9D0064B8  7C032104   INS V1, ZERO, 4, 1
9D0064BC  AC431000   SW V1, 4096(V0)
64:                      IPC4bits.INT4IP=6; // priorité 4
9D0064C0  3C02BF88   LUI V0, -16504
9D0064C4  8C4310D0   LW V1, 4304(V0)
9D0064C8  24050006   ADDIU A1, ZERO, 6
9D0064CC  7CA3E684   INS V1, A1, 26, 3
9D0064D0  AC4310D0   SW V1, 4304(V0)
65:                      IPC4bits.INT4IS=3;  // sous-priorité 3.
9D0064D4  8C4310D0   LW V1, 4304(V0)
9D0064D8  7C83CE04   INS V1, A0, 24, 2
9D0064DC  AC4310D0   SW V1, 4304(V0)
66:                      while (!PORTAbits.RA0);
9D0064E0  3C03BF88   LUI V1, -16504
9D0064E4  8C626020   LW V0, 24608(V1)
9D0064E8  30420001   ANDI V0, V0, 1
9D0064EC  1040FFFD   BEQ V0, ZERO, 0x9D0064E4
9D0064F0  3C02BF88   LUI V0, -16504
67:                      IFS0bits.INT4IF=0; // RAZ indicateur interruption
9D0064F4  8C431030   LW V1, 4144(V0)
9D0064F8  7C03BDC4   INS V1, ZERO, 23, 1
9D0064FC  AC431030   SW V1, 4144(V0)
68:                      IEC0SET = _IEC0_INT4IE_MASK; // activation interruption externe 4 (KBD_CLK)
9D006500  3C030080   LUI V1, 128
9D006504  3C02BF88   LUI V0, -16504
9D006508  AC431068   SW V1, 4200(V0)
69:                      while ((ticks()!=t0) && ((rx_flags & F_ERROR)==0)){
9D00650C  0B40194A   J 0x9D006528
9D006510  241100AA   ADDIU S1, ZERO, 170
9D006528  0F402462   JAL ticks
9D00652C  00000000   NOP
9D006530  10500005   BEQ V0, S0, 0x9D006548
9D006534  00000000   NOP
9D006538  93828029   LBU V0, -32727(GP)
9D00653C  30420001   ANDI V0, V0, 1
9D006540  1040FFF4   BEQ V0, ZERO, 0x9D006514
9D006544  00000000   NOP
70:                          c=KbdScancode();
9D006514  0F4017A8   JAL KbdScancode
9D006518  00000000   NOP
71:                          if (c==BAT_OK){
9D00651C  304200FF   ANDI V0, V0, 255
9D006520  10510026   BEQ V0, S1, 0x9D0065BC
9D006524  24020001   ADDIU V0, ZERO, 1
72:                              return 1;
73:                          }
74:                      }
75:                      if (KbdReset())
76:                          return 1;
77:                      else
78:                          return 0;
79:                  } //KeyboardInit()
9D0065BC  8FBF001C   LW RA, 28(SP)
9D0065C0  8FB20018   LW S2, 24(SP)
9D0065C4  8FB10014   LW S1, 20(SP)
9D0065C8  8FB00010   LW S0, 16(SP)
9D0065CC  03E00008   JR RA
9D0065D0  27BD0020   ADDIU SP, SP, 32
80:                  
81:                  static int KbdReset(void){
82:                      unsigned int t0;
83:                      short c;
84:                      rx_flags = 0;
9D006548  A3808029   SB ZERO, -32727(GP)
85:                      KbdSend(KBD_RESET);
9D00654C  0F401702   JAL KbdSend
9D006550  2404FFFF   ADDIU A0, ZERO, -1
86:                      t0=ticks()+750;
9D006554  0F402462   JAL ticks
9D006558  00008021   ADDU S0, ZERO, ZERO
9D00655C  245102EE   ADDIU S1, V0, 750
87:                      c=0;
88:                      while ((ticks()!=t0) && ((rx_flags & F_ERROR)==0) && !c){
9D006578  0F402462   JAL ticks
9D00657C  00000000   NOP
9D006580  12220007   BEQ S1, V0, 0x9D0065A0
9D006584  00000000   NOP
9D006588  93828029   LBU V0, -32727(GP)
9D00658C  30420001   ANDI V0, V0, 1
9D006590  14400003   BNE V0, ZERO, 0x9D0065A0
9D006594  00000000   NOP
9D006598  1200FFF3   BEQ S0, ZERO, 0x9D006568
9D00659C  00000000   NOP
89:                              c=KbdScancode();
9D006568  0F4017A8   JAL KbdScancode
9D00656C  00000000   NOP
9D006570  00521826   XOR V1, V0, S2
9D006574  0043800B   MOVN S0, V0, V1
90:                              if (c==KBD_ACK){
9D006560  0B40195E   J 0x9D006578
9D006564  241200FA   ADDIU S2, ZERO, 250
91:                                  c=0;
92:                              }
93:                      }
94:                      if ((rx_flags & F_ERROR) || (c!=BAT_OK))
9D0065A0  93838029   LBU V1, -32727(GP)
9D0065A4  30630001   ANDI V1, V1, 1
9D0065A8  14600003   BNE V1, ZERO, 0x9D0065B8
9D0065AC  00001021   ADDU V0, ZERO, ZERO
95:                          return 0;
9D0065B0  3A0200AA   XORI V0, S0, 170
9D0065B4  2C420001   SLTIU V0, V0, 1
9D0065B8  0002102B   SLTU V0, ZERO, V0
96:                      else
97:                          return 1;
98:                  }//KbdReset()
99:                  
100:                 typedef enum  _STATE {ST0, ST_EXT0, ST_RELEASE, ST_COMPLETED} state_t;
101:                 
102:                 short KbdScancode(){  // obtient le code clavier en tête de la file
9D005EA0  27BDFFE8   ADDIU SP, SP, -24
9D005EA4  AFBF0014   SW RA, 20(SP)
9D005EA8  AFB00010   SW S0, 16(SP)
9D006194  3C079D01   LUI A3, -25343
9D006198  24E7A924   ADDIU A3, A3, -22236
103:                 	unsigned int i, flags;
104:                         state_t state;
105:                 	short code;
106:                         if (head==tail){
9D005EAC  9383802F   LBU V1, -32721(GP)
9D005EB0  306300FF   ANDI V1, V1, 255
9D005EB4  9382802D   LBU V0, -32723(GP)
9D005EB8  304200FF   ANDI V0, V0, 255
9D005EBC  1462001B   BNE V1, V0, 0x9D005F2C
9D005EC0  00002021   ADDU A0, ZERO, ZERO
9D005F2C  00003021   ADDU A2, ZERO, ZERO
107:                             if (rx_flags & F_ERROR){
9D005EC4  93838029   LBU V1, -32727(GP)
9D005EC8  30630001   ANDI V1, V1, 1
9D005ECC  10600162   BEQ V1, ZERO, 0x9D006458
9D005ED0  00001021   ADDU V0, ZERO, ZERO
108:                                 _status_on();
9D005ED4  3C10BF88   LUI S0, -16504
9D005ED8  8E026120   LW V0, 24864(S0)
9D005EDC  34420008   ORI V0, V0, 8
9D005EE0  AE026120   SW V0, 24864(S0)
109:                                 delay_ms(400);
9D005EE4  0F40246D   JAL delay_ms
9D005EE8  24040190   ADDIU A0, ZERO, 400
110:                                 _status_off();
9D005EEC  8E036120   LW V1, 24864(S0)
9D005EF0  2402FFF7   ADDIU V0, ZERO, -9
9D005EF4  00621024   AND V0, V1, V0
9D005EF8  AE026120   SW V0, 24864(S0)
111:                                 delay_ms(400);
9D005EFC  0F40246D   JAL delay_ms
9D005F00  24040190   ADDIU A0, ZERO, 400
112:                                 rx_flags &= ~F_ERROR;
9D005F04  93828029   LBU V0, -32727(GP)
9D005F08  304200FE   ANDI V0, V0, 254
9D005F0C  A3828029   SB V0, -32727(GP)
113:                                 IEC0bits.INT4IE=1;
9D005F10  3C02BF88   LUI V0, -16504
9D005F14  8C431060   LW V1, 4192(V0)
9D005F18  24040001   ADDIU A0, ZERO, 1
9D005F1C  7C83BDC4   INS V1, A0, 23, 1
9D005F20  AC431060   SW V1, 4192(V0)
114:                             }
115:                             return 0; // tampon vide
9D005F24  0B401916   J 0x9D006458
9D005F28  00001021   ADDU V0, ZERO, ZERO
116:                         }
117:                 	code = 0;
118:                 	flags=0;
119:                         state=ST0;
120:                 	while (state!=ST_COMPLETED){
9D005F40  240A0003   ADDIU T2, ZERO, 3
9D006104  148AFF91   BNE A0, T2, 0x9D005F4C
9D006108  00000000   NOP
121:                             _wait_key();
9D005F4C  9383802F   LBU V1, -32721(GP)
9D005F50  306300FF   ANDI V1, V1, 255
9D005F54  9382802D   LBU V0, -32723(GP)
9D005F58  304200FF   ANDI V0, V0, 255
9D005F5C  1062FFFB   BEQ V1, V0, 0x9D005F4C
9D005F60  00000000   NOP
122:                             code=kbd_queue[head];
9D005F30  3C08A000   LUI T0, -24576
9D005F34  25084CA0   ADDIU T0, T0, 19616
9D005F64  9382802F   LBU V0, -32721(GP)
9D005F68  304200FF   ANDI V0, V0, 255
9D005F6C  00481021   ADDU V0, V0, T0
9D005F70  90430000   LBU V1, 0(V0)
9D005F74  7C031620   SEH V0, V1
123:                             head++;
9D005F78  9385802F   LBU A1, -32721(GP)
9D005F7C  24A50001   ADDIU A1, A1, 1
9D005F80  30A500FF   ANDI A1, A1, 255
9D005F84  A385802F   SB A1, -32721(GP)
124:                             head &= 31;
9D005F88  9385802F   LBU A1, -32721(GP)
9D005F8C  30A5001F   ANDI A1, A1, 31
9D005F90  A385802F   SB A1, -32721(GP)
125:                             switch (state){
9D005F38  24070001   ADDIU A3, ZERO, 1
9D005F94  10870026   BEQ A0, A3, 0x9D006030
9D005F98  00000000   NOP
9D005F9C  10800006   BEQ A0, ZERO, 0x9D005FB8
9D005FA0  00000000   NOP
9D005FA4  24030002   ADDIU V1, ZERO, 2
9D005FA8  14830056   BNE A0, V1, 0x9D006104
9D005FAC  00C02821   ADDU A1, A2, ZERO
126:                                 case ST0:
127:                                     switch (code){
9D005F44  240B00E1   ADDIU T3, ZERO, 225
9D005F48  240C00E0   ADDIU T4, ZERO, 224
9D005FB8  106B000B   BEQ V1, T3, 0x9D005FE8
9D005FBC  24040007   ADDIU A0, ZERO, 7
9D005FC0  50690005   BEQL V1, T1, 0x9D005FD8
9D005FC4  34C68000   ORI A2, A2, -32768
9D005FC8  146C004E   BNE V1, T4, 0x9D006104
9D005FCC  01402021   ADDU A0, T2, ZERO
128:                                         case KEY_REL:
129:                                             flags |= REL_BIT;
130:                                             state = ST_RELEASE;
131:                                             break;
9D005FD8  0B4017D3   J 0x9D005F4C
9D005FDC  24040002   ADDIU A0, ZERO, 2
132:                                         case XTD_KEY:
133:                                             flags |= XT_BIT;
9D005FD0  0B4017F8   J 0x9D005FE0
9D005FD4  34C60100   ORI A2, A2, 256
134:                                             state = ST_EXT0;
135:                                             break;
9D005FE0  0B4017D3   J 0x9D005F4C
9D005FE4  00E02021   ADDU A0, A3, ZERO
136:                                         case 0xE1:
137:                                             for (i=7;i;i--){     // touche PAUSE élimine les 7 prochains caractères
9D006020  1480FFF1   BNE A0, ZERO, 0x9D005FE8
9D006024  240201E1   ADDIU V0, ZERO, 481
138:                                                     _wait_key();
9D005FE8  9383802F   LBU V1, -32721(GP)
9D005FEC  306300FF   ANDI V1, V1, 255
9D005FF0  9382802D   LBU V0, -32723(GP)
9D005FF4  304200FF   ANDI V0, V0, 255
9D005FF8  1062FFFB   BEQ V1, V0, 0x9D005FE8
9D005FFC  00000000   NOP
139:                                                     head++;
9D006000  9382802F   LBU V0, -32721(GP)
9D006004  24420001   ADDIU V0, V0, 1
9D006008  304200FF   ANDI V0, V0, 255
9D00600C  A382802F   SB V0, -32721(GP)
140:                                                     head &= 31;
9D006010  9382802F   LBU V0, -32721(GP)
9D006014  3042001F   ANDI V0, V0, 31
9D006018  A382802F   SB V0, -32721(GP)
9D00601C  2484FFFF   ADDIU A0, A0, -1
141:                                             }
142:                                             code = PAUSE;
143:                                         default:
144:                                             state=ST_COMPLETED;
145:                                     }//switch(code)
146:                                     break;
147:                                 case ST_EXT0:
148:                                     if (code==KEY_REL){
9D005F3C  240900F0   ADDIU T1, ZERO, 240
9D006030  14490004   BNE V0, T1, 0x9D006044
9D006034  30C30100   ANDI V1, A2, 256
149:                                         flags |= REL_BIT;
9D006038  34C68000   ORI A2, A2, -32768
150:                                         state = ST_RELEASE;
9D00603C  0B4017D3   J 0x9D005F4C
9D006040  24040002   ADDIU A0, ZERO, 2
151:                                     }else{
152:                                         if ((flags & XT_BIT) && (code==0x12)){ // touche PrtSc enfoncée.
9D006044  10600031   BEQ V1, ZERO, 0x9D00610C
9D006048  00C02821   ADDU A1, A2, ZERO
9D00604C  24030012   ADDIU V1, ZERO, 18
9D006050  1443002F   BNE V0, V1, 0x9D006110
9D006054  3C03BF88   LUI V1, -16504
9D006058  24040002   ADDIU A0, ZERO, 2
153:                                             for (i=2;i;i--){ // élimine les 2 codes suivants
9D006094  1480FFF1   BNE A0, ZERO, 0x9D00605C
9D006098  24020112   ADDIU V0, ZERO, 274
9D00609C  0B401843   J 0x9D00610C
9D0060A0  00A03021   ADDU A2, A1, ZERO
154:                                                 _wait_key();
9D00605C  9383802F   LBU V1, -32721(GP)
9D006060  306300FF   ANDI V1, V1, 255
9D006064  9382802D   LBU V0, -32723(GP)
9D006068  304200FF   ANDI V0, V0, 255
9D00606C  1062FFFB   BEQ V1, V0, 0x9D00605C
9D006070  00000000   NOP
155:                                                 head++;
9D006074  9382802F   LBU V0, -32721(GP)
9D006078  24420001   ADDIU V0, V0, 1
9D00607C  304200FF   ANDI V0, V0, 255
9D006080  A382802F   SB V0, -32721(GP)
156:                                                 head &=31;
9D006084  9382802F   LBU V0, -32721(GP)
9D006088  3042001F   ANDI V0, V0, 31
9D00608C  A382802F   SB V0, -32721(GP)
9D006090  2484FFFF   ADDIU A0, A0, -1
157:                                             }
158:                                             code = PRN;
159:                                         }
160:                                         state = ST_COMPLETED;
161:                                     }
162:                                     break;
163:                                 case ST_RELEASE:
164:                                     if ((flags & XT_BIT) && (code==0x7c)){ //touche PrtSc relâchée.
9D005FB0  0B401829   J 0x9D0060A4
9D005FB4  30C30100   ANDI V1, A2, 256
9D0060A4  1060001A   BEQ V1, ZERO, 0x9D006110
9D0060A8  3C03BF88   LUI V1, -16504
9D0060AC  2403007C   ADDIU V1, ZERO, 124
9D0060B0  14430017   BNE V0, V1, 0x9D006110
9D0060B4  3C03BF88   LUI V1, -16504
9D0060B8  24040003   ADDIU A0, ZERO, 3
165:                                         for (i=3;i;i--){ // élimine les 3 codes suivants.
9D0060F4  1480FFF1   BNE A0, ZERO, 0x9D0060BC
9D0060F8  24020112   ADDIU V0, ZERO, 274
9D0060FC  0B401843   J 0x9D00610C
9D006100  00A03021   ADDU A2, A1, ZERO
166:                                             _wait_key();
9D0060BC  9383802F   LBU V1, -32721(GP)
9D0060C0  306300FF   ANDI V1, V1, 255
9D0060C4  9382802D   LBU V0, -32723(GP)
9D0060C8  304200FF   ANDI V0, V0, 255
9D0060CC  1062FFFB   BEQ V1, V0, 0x9D0060BC
9D0060D0  00000000   NOP
167:                                             head++;
9D0060D4  9382802F   LBU V0, -32721(GP)
9D0060D8  24420001   ADDIU V0, V0, 1
9D0060DC  304200FF   ANDI V0, V0, 255
9D0060E0  A382802F   SB V0, -32721(GP)
168:                                             head &= 31;
9D0060E4  9382802F   LBU V0, -32721(GP)
9D0060E8  3042001F   ANDI V0, V0, 31
9D0060EC  A382802F   SB V0, -32721(GP)
9D0060F0  2484FFFF   ADDIU A0, A0, -1
169:                                         }
170:                                         code = PRN;
171:                                     }
172:                                     state=ST_COMPLETED;
173:                                     break;
174:                                 default:;
175:                             }//switch(state)
176:                         }//while(state...)
177:                         IEC0bits.INT4IE=0; // section critique désactive interruption
9D006028  0B401844   J 0x9D006110
9D00602C  3C03BF88   LUI V1, -16504
9D00610C  3C03BF88   LUI V1, -16504
9D006110  8C641060   LW A0, 4192(V1)
9D006114  7C04BDC4   INS A0, ZERO, 23, 1
9D006118  AC641060   SW A0, 4192(V1)
178:                 	if (head==tail){
9D00611C  9384802F   LBU A0, -32721(GP)
9D006120  308400FF   ANDI A0, A0, 255
9D006124  9383802D   LBU V1, -32723(GP)
9D006128  306300FF   ANDI V1, V1, 255
9D00612C  14830005   BNE A0, V1, 0x9D006144
9D006130  3C03BF88   LUI V1, -16504
179:                 		rx_flags &= ~F_RCVD;
9D006134  93838029   LBU V1, -32727(GP)
9D006138  306300FD   ANDI V1, V1, 253
9D00613C  A3838029   SB V1, -32727(GP)
180:                 	}
181:                         IEC0bits.INT4IE=1; // fin section critique réactive interruption
9D006140  3C03BF88   LUI V1, -16504
9D006144  8C641060   LW A0, 4192(V1)
9D006148  24050001   ADDIU A1, ZERO, 1
9D00614C  7CA4BDC4   INS A0, A1, 23, 1
9D006150  AC641060   SW A0, 4192(V1)
182:                         if ((code==KBD_ACK)||(code==KBD_RSND)||(code==BAT_OK)||(code==BAT_ERROR)){
9D006154  240300FA   ADDIU V1, ZERO, 250
9D006158  104300BF   BEQ V0, V1, 0x9D006458
9D00615C  240300FE   ADDIU V1, ZERO, 254
9D006160  104300BD   BEQ V0, V1, 0x9D006458
9D006164  240300AA   ADDIU V1, ZERO, 170
9D006168  104300BB   BEQ V0, V1, 0x9D006458
9D00616C  240300FC   ADDIU V1, ZERO, 252
9D006170  104300B9   BEQ V0, V1, 0x9D006458
9D006174  24030058   ADDIU V1, ZERO, 88
183:                             return code;
184:                         }
185:                         code |= flags;
9D006178  00462825   OR A1, V0, A2
9D00617C  30A5FFFF   ANDI A1, A1, -1
9D006180  7C051620   SEH V0, A1
186:                         for (i=0;i<FN_COUNT;i++){
9D006444  5467FF56   BNEL V1, A3, 0x9D0061A0
9D006448  84640000   LH A0, 0(V1)
187:                             if ((code&0x1ff)==fn_keys[i]){
9D006184  30A501FF   ANDI A1, A1, 511
9D006188  10A30007   BEQ A1, V1, 0x9D0061A8
9D00618C  3C039D01   LUI V1, -25343
9D006190  2463A8E6   ADDIU V1, V1, -22298
9D00619C  84640000   LH A0, 0(V1)
9D0061A0  148500A8   BNE A0, A1, 0x9D006444
9D0061A4  24630002   ADDIU V1, V1, 2
188:                                 code |= FN_BIT;
9D0061A8  34420200   ORI V0, V0, 512
9D0061AC  7C021620   SEH V0, V0
189:                                 switch (code&0x1ff){ // les touches d'alteration sont traitées ici.
9D0061B0  304301FF   ANDI V1, V0, 511
9D0061B4  24040059   ADDIU A0, ZERO, 89
9D0061B8  10640030   BEQ V1, A0, 0x9D00627C
9D0061BC  2864005A   SLTI A0, V1, 90
9D0061C0  10800011   BEQ A0, ZERO, 0x9D006208
9D0061C4  2404007E   ADDIU A0, ZERO, 126
9D0061C8  24040012   ADDIU A0, ZERO, 18
9D0061CC  1064001D   BEQ V1, A0, 0x9D006244
9D0061D0  28640013   SLTI A0, V1, 19
9D0061D4  10800006   BEQ A0, ZERO, 0x9D0061F0
9D0061D8  24040014   ADDIU A0, ZERO, 20
9D0061DC  24040011   ADDIU A0, ZERO, 17
9D0061E0  1464009A   BNE V1, A0, 0x9D00644C
9D0061E4  00000000   NOP
9D0061F0  10640030   BEQ V1, A0, 0x9D0062B4
9D0061F4  24040058   ADDIU A0, ZERO, 88
9D0061F8  14640094   BNE V1, A0, 0x9D00644C
9D0061FC  00000000   NOP
9D006208  1064007E   BEQ V1, A0, 0x9D006404
9D00620C  2864007F   SLTI A0, V1, 127
9D006210  10800006   BEQ A0, ZERO, 0x9D00622C
9D006214  24040111   ADDIU A0, ZERO, 273
9D006218  24040077   ADDIU A0, ZERO, 119
9D00621C  1464008B   BNE V1, A0, 0x9D00644C
9D006220  00000000   NOP
9D00622C  1064003C   BEQ V1, A0, 0x9D006320
9D006230  24040114   ADDIU A0, ZERO, 276
9D006234  14640085   BNE V1, A0, 0x9D00644C
9D006238  00000000   NOP
190:                                     case LSHIFT:
191:                                         if (flags & REL_BIT){
9D006244  30C68000   ANDI A2, A2, -32768
9D006248  10C00006   BEQ A2, ZERO, 0x9D006264
9D00624C  00000000   NOP
192:                                             key_state &=~F_LSHIFT;
9D006250  9782805C   LHU V0, -32676(GP)
9D006254  3042FFF7   ANDI V0, V0, -9
9D006258  A782805C   SH V0, -32676(GP)
9D00625C  0B401916   J 0x9D006458
9D006260  00001021   ADDU V0, ZERO, ZERO
193:                                         }else{
194:                                             key_state |= F_LSHIFT;
9D006264  9782805C   LHU V0, -32676(GP)
9D006268  3042FFFF   ANDI V0, V0, -1
9D00626C  34420008   ORI V0, V0, 8
9D006270  A782805C   SH V0, -32676(GP)
9D006274  0B401916   J 0x9D006458
9D006278  00001021   ADDU V0, ZERO, ZERO
195:                                         }
196:                                         code=0;
197:                                         break;
198:                                     case RSHIFT:
199:                                         if (flags & REL_BIT){
9D00627C  30C68000   ANDI A2, A2, -32768
9D006280  10C00006   BEQ A2, ZERO, 0x9D00629C
9D006284  00000000   NOP
200:                                             key_state &=~F_RSHIFT;
9D006288  9782805C   LHU V0, -32676(GP)
9D00628C  3042FFEF   ANDI V0, V0, -17
9D006290  A782805C   SH V0, -32676(GP)
9D006294  0B401916   J 0x9D006458
9D006298  00001021   ADDU V0, ZERO, ZERO
201:                                         }else{
202:                                             key_state |= F_RSHIFT;
9D00629C  9782805C   LHU V0, -32676(GP)
9D0062A0  3042FFFF   ANDI V0, V0, -1
9D0062A4  34420010   ORI V0, V0, 16
9D0062A8  A782805C   SH V0, -32676(GP)
9D0062AC  0B401916   J 0x9D006458
9D0062B0  00001021   ADDU V0, ZERO, ZERO
203:                                         }
204:                                         code=0;
205:                                         break;
206:                                     case LCTRL:
207:                                         if (flags & REL_BIT){
9D0062B4  30C68000   ANDI A2, A2, -32768
9D0062B8  10C00006   BEQ A2, ZERO, 0x9D0062D4
9D0062BC  00000000   NOP
208:                                             key_state &=~F_LCTRL;
9D0062C0  9782805C   LHU V0, -32676(GP)
9D0062C4  3042FFDF   ANDI V0, V0, -33
9D0062C8  A782805C   SH V0, -32676(GP)
9D0062CC  0B401916   J 0x9D006458
9D0062D0  00001021   ADDU V0, ZERO, ZERO
209:                                         }else{
210:                                             key_state |= F_LCTRL;
9D0062D4  9782805C   LHU V0, -32676(GP)
9D0062D8  3042FFFF   ANDI V0, V0, -1
9D0062DC  34420020   ORI V0, V0, 32
9D0062E0  A782805C   SH V0, -32676(GP)
9D0062E4  0B401916   J 0x9D006458
9D0062E8  00001021   ADDU V0, ZERO, ZERO
211:                                         }
212:                                         code=0;
213:                                         break;
214:                                     case RCTRL:
215:                                         if (flags & REL_BIT){
9D00623C  0B4018BB   J 0x9D0062EC
9D006240  30C68000   ANDI A2, A2, -32768
9D0062EC  10C00006   BEQ A2, ZERO, 0x9D006308
9D0062F0  00000000   NOP
216:                                             key_state &=~F_RCTRL;
9D0062F4  9782805C   LHU V0, -32676(GP)
9D0062F8  3042FFBF   ANDI V0, V0, -65
9D0062FC  A782805C   SH V0, -32676(GP)
9D006300  0B401916   J 0x9D006458
9D006304  00001021   ADDU V0, ZERO, ZERO
217:                                         }else{
218:                                             key_state |= F_RCTRL;
9D006308  9782805C   LHU V0, -32676(GP)
9D00630C  3042FFFF   ANDI V0, V0, -1
9D006310  34420040   ORI V0, V0, 64
9D006314  A782805C   SH V0, -32676(GP)
9D006318  0B401916   J 0x9D006458
9D00631C  00001021   ADDU V0, ZERO, ZERO
219:                                         }
220:                                         code=0;
221:                                         break;
222:                                     case RALT:
223:                                         if (flags & REL_BIT){
9D006320  30C68000   ANDI A2, A2, -32768
9D006324  10C00006   BEQ A2, ZERO, 0x9D006340
9D006328  00000000   NOP
224:                                             key_state &=~F_ALTCHAR;
9D00632C  9782805C   LHU V0, -32676(GP)
9D006330  3042FEFF   ANDI V0, V0, -257
9D006334  A782805C   SH V0, -32676(GP)
9D006338  0B401916   J 0x9D006458
9D00633C  00001021   ADDU V0, ZERO, ZERO
225:                                         }else{
226:                                             key_state |= F_ALTCHAR;
9D006340  9782805C   LHU V0, -32676(GP)
9D006344  3042FFFF   ANDI V0, V0, -1
9D006348  34420100   ORI V0, V0, 256
9D00634C  A782805C   SH V0, -32676(GP)
9D006350  0B401916   J 0x9D006458
9D006354  00001021   ADDU V0, ZERO, ZERO
227:                                         }
228:                                         code=0;
229:                                         break;
230:                                     case LALT:
231:                                         if (flags & REL_BIT){
9D0061E8  0B4018D6   J 0x9D006358
9D0061EC  30C68000   ANDI A2, A2, -32768
9D006358  10C00006   BEQ A2, ZERO, 0x9D006374
9D00635C  00000000   NOP
232:                                             key_state &=~F_LALT;
9D006360  9782805C   LHU V0, -32676(GP)
9D006364  3042FF7F   ANDI V0, V0, -129
9D006368  A782805C   SH V0, -32676(GP)
9D00636C  0B401916   J 0x9D006458
9D006370  00001021   ADDU V0, ZERO, ZERO
233:                                         }else{
234:                                             key_state |= F_LALT;
9D006374  9782805C   LHU V0, -32676(GP)
9D006378  3042FFFF   ANDI V0, V0, -1
9D00637C  34420080   ORI V0, V0, 128
9D006380  A782805C   SH V0, -32676(GP)
9D006384  0B401916   J 0x9D006458
9D006388  00001021   ADDU V0, ZERO, ZERO
235:                                         }
236:                                         code=0;
237:                                         break;
238:                                     case NUM_LOCK:
239:                                         if (flags & REL_BIT){
9D006224  0B4018E3   J 0x9D00638C
9D006228  30C68000   ANDI A2, A2, -32768
9D00638C  10C0002F   BEQ A2, ZERO, 0x9D00644C
9D006390  00000000   NOP
240:                                             kbd_leds ^= F_NUM;
9D006394  9382802A   LBU V0, -32726(GP)
9D006398  304200FF   ANDI V0, V0, 255
9D00639C  38420002   XORI V0, V0, 2
9D0063A0  A382802A   SB V0, -32726(GP)
241:                                             key_state ^= F_NUM;
9D0063A4  9782805C   LHU V0, -32676(GP)
9D0063A8  3042FFFF   ANDI V0, V0, -1
9D0063AC  38420002   XORI V0, V0, 2
9D0063B0  A782805C   SH V0, -32676(GP)
242:                                             SetKbdLeds(kbd_leds);
9D0063B4  9384802A   LBU A0, -32726(GP)
9D0063B8  0F401773   JAL SetKbdLeds
9D0063BC  308400FF   ANDI A0, A0, 255
9D0063C0  0B401916   J 0x9D006458
9D0063C4  00001021   ADDU V0, ZERO, ZERO
243:                                             code=0;
244:                                         }
245:                                         break;
246:                                     case CAPS_LOCK:
247:                                         if (flags & REL_BIT){
9D006200  0B4018F2   J 0x9D0063C8
9D006204  30C68000   ANDI A2, A2, -32768
9D0063C8  10C00020   BEQ A2, ZERO, 0x9D00644C
9D0063CC  00000000   NOP
248:                                             kbd_leds ^= F_CAPS;
9D0063D0  9382802A   LBU V0, -32726(GP)
9D0063D4  304200FF   ANDI V0, V0, 255
9D0063D8  38420004   XORI V0, V0, 4
9D0063DC  A382802A   SB V0, -32726(GP)
249:                                             key_state ^= F_CAPS;
9D0063E0  9782805C   LHU V0, -32676(GP)
9D0063E4  3042FFFF   ANDI V0, V0, -1
9D0063E8  38420004   XORI V0, V0, 4
9D0063EC  A782805C   SH V0, -32676(GP)
250:                                             SetKbdLeds(kbd_leds);
9D0063F0  9384802A   LBU A0, -32726(GP)
9D0063F4  0F401773   JAL SetKbdLeds
9D0063F8  308400FF   ANDI A0, A0, 255
9D0063FC  0B401916   J 0x9D006458
9D006400  00001021   ADDU V0, ZERO, ZERO
251:                                             code=0;
252:                                         }
253:                                         break;
254:                                     case SCROLL_LOCK:
255:                                         if (flags & REL_BIT){
9D006404  30C68000   ANDI A2, A2, -32768
9D006408  10C00010   BEQ A2, ZERO, 0x9D00644C
9D00640C  00000000   NOP
256:                                             kbd_leds ^= F_SCROLL;
9D006410  9382802A   LBU V0, -32726(GP)
9D006414  304200FF   ANDI V0, V0, 255
9D006418  38420001   XORI V0, V0, 1
9D00641C  A382802A   SB V0, -32726(GP)
257:                                             key_state ^= F_SCROLL;
9D006420  9782805C   LHU V0, -32676(GP)
9D006424  3042FFFF   ANDI V0, V0, -1
9D006428  38420001   XORI V0, V0, 1
9D00642C  A782805C   SH V0, -32676(GP)
258:                                             SetKbdLeds(kbd_leds);
9D006430  9384802A   LBU A0, -32726(GP)
9D006434  0F401773   JAL SetKbdLeds
9D006438  308400FF   ANDI A0, A0, 255
9D00643C  0B401916   J 0x9D006458
9D006440  00001021   ADDU V0, ZERO, ZERO
259:                                             code=0;
260:                                         }
261:                                         break;
262:                                     default:;
263:                                 }//switch(code)
264:                                 break;
265:                             }// if
266:                         }//for
267:                         if ((code < 0) && !(code & FN_BIT)) // ne retourne pas les relâchement de touche pour les touches caractères.
9D00644C  04410002   BGEZ V0, 0x9D006458
9D006450  30430200   ANDI V1, V0, 512
268:                             return 0;
9D006454  0003100A   MOVZ V0, ZERO, V1
269:                         else
270:                             return code;
271:                 }// GetScancode()
9D006458  8FBF0014   LW RA, 20(SP)
9D00645C  8FB00010   LW S0, 16(SP)
9D006460  03E00008   JR RA
9D006464  27BD0018   ADDIU SP, SP, 24
272:                 
273:                 
274:                 short KbdKey(short scancode){  // obtient la transcription du code en ASCII
9D005A04  7C042620   SEH A0, A0
275:                 	int a,i;
276:                 	a=0;
9D005A70  0B4016FD   J 0x9D005BF4
9D005A74  00001021   ADDU V0, ZERO, ZERO
277:                 	if (scancode & XT_BIT){
9D005A08  3086FFFF   ANDI A2, A0, -1
9D005A0C  30C20100   ANDI V0, A2, 256
9D005A10  10400019   BEQ V0, ZERO, 0x9D005A78
9D005A14  3C029D01   LUI V0, -25343
278:                 		i=0;
279:                 		while (qwerty_xt_char[i].code){
9D005A18  8443A030   LH V1, -24528(V0)
9D005A1C  10600075   BEQ V1, ZERO, 0x9D005BF4
9D005A20  00001021   ADDU V0, ZERO, ZERO
9D005A64  84430000   LH V1, 0(V0)
9D005A68  1460FFF2   BNE V1, ZERO, 0x9D005A34
9D005A6C  24A50001   ADDIU A1, A1, 1
280:                 			if (qwerty_xt_char[i].code==scancode){
9D005A24  5483000D   BNEL A0, V1, 0x9D005A5C
9D005A28  3C029D01   LUI V0, -25343
9D005A2C  0B401691   J 0x9D005A44
9D005A30  00002821   ADDU A1, ZERO, ZERO
9D005A34  1483000B   BNE A0, V1, 0x9D005A64
9D005A38  24420004   ADDIU V0, V0, 4
9D005A60  00002821   ADDU A1, ZERO, ZERO
281:                 				a=qwerty_xt_char[i].ascii;
9D005A3C  0B401692   J 0x9D005A48
9D005A40  00052880   SLL A1, A1, 2
9D005A44  00052880   SLL A1, A1, 2
9D005A48  3C029D01   LUI V0, -25343
9D005A4C  2442A030   ADDIU V0, V0, -24528
9D005A50  00452821   ADDU A1, V0, A1
282:                 				break;
9D005A54  0B4016FD   J 0x9D005BF4
9D005A58  84A20002   LH V0, 2(A1)
9D005A5C  2442A034   ADDIU V0, V0, -24524
283:                 			}
284:                 			i++;
285:                 		} // while (xt_char[i].code)
286:                 	}else if (key_state & F_SHIFT){
9D005A78  9782805C   LHU V0, -32676(GP)
9D005A7C  30420018   ANDI V0, V0, 24
9D005A80  5440000A   BNEL V0, ZERO, 0x9D005AAC
9D005A84  3C029D01   LUI V0, -25343
287:                 		i=0;
288:                 		while (qwerty_shifted_key[i].code){
9D005AAC  84429FDC   LH V0, -24612(V0)
9D005AB0  50400019   BEQL V0, ZERO, 0x9D005B18
9D005AB4  3C029D01   LUI V0, -25343
9D005B08  84430000   LH V1, 0(V0)
9D005B0C  1460FFEF   BNE V1, ZERO, 0x9D005ACC
9D005B10  24A50001   ADDIU A1, A1, 1
289:                 			if (qwerty_shifted_key[i].code==(scancode&0xff)){
9D005AB8  30C700FF   ANDI A3, A2, 255
9D005ABC  14470010   BNE V0, A3, 0x9D005B00
9D005AC0  3C029D01   LUI V0, -25343
9D005AC4  0B4016B7   J 0x9D005ADC
9D005AC8  00002821   ADDU A1, ZERO, ZERO
9D005ACC  1467000E   BNE V1, A3, 0x9D005B08
9D005AD0  24420004   ADDIU V0, V0, 4
9D005B04  00002821   ADDU A1, ZERO, ZERO
290:                 				a=qwerty_shifted_key[i].ascii;
9D005AD4  0B4016B8   J 0x9D005AE0
9D005AD8  00052880   SLL A1, A1, 2
9D005ADC  00052880   SLL A1, A1, 2
9D005AE0  3C029D01   LUI V0, -25343
9D005AE4  24429FDC   ADDIU V0, V0, -24612
9D005AE8  00452821   ADDU A1, V0, A1
9D005AEC  84A20002   LH V0, 2(A1)
291:                 				break;
292:                 			}
293:                 			i++;
294:                 		}// while (shifted_key.code)
295:                 		if (!a){
9D005AF0  14400041   BNE V0, ZERO, 0x9D005BF8
9D005AF4  2403FF00   ADDIU V1, ZERO, -256
9D005B00  24429FE0   ADDIU V0, V0, -24608
296:                 			i=0;
297:                 			while (qwerty[i].code){
9D005AF8  0B4016C6   J 0x9D005B18
9D005AFC  3C029D01   LUI V0, -25343
9D005B14  3C029D01   LUI V0, -25343
9D005B18  84439ECC   LH V1, -24884(V0)
9D005B1C  10600035   BEQ V1, ZERO, 0x9D005BF4
9D005B20  00001021   ADDU V0, ZERO, ZERO
9D005B78  84430000   LH V1, 0(V0)
9D005B7C  1460FFEE   BNE V1, ZERO, 0x9D005B38
9D005B80  24A50001   ADDIU A1, A1, 1
9D005B84  0B4016FD   J 0x9D005BF4
9D005B88  00001021   ADDU V0, ZERO, ZERO
298:                 				if (qwerty[i].code==(scancode&0xff)){
9D005B24  30C600FF   ANDI A2, A2, 255
9D005B28  54660011   BNEL V1, A2, 0x9D005B70
9D005B2C  3C029D01   LUI V0, -25343
9D005B30  0B4016D2   J 0x9D005B48
9D005B34  00002821   ADDU A1, ZERO, ZERO
9D005B38  14C3000F   BNE A2, V1, 0x9D005B78
9D005B3C  24420004   ADDIU V0, V0, 4
9D005B74  00002821   ADDU A1, ZERO, ZERO
299:                 					a=qwerty[i].ascii;
9D005B40  0B4016D3   J 0x9D005B4C
9D005B44  00052880   SLL A1, A1, 2
9D005B48  00052880   SLL A1, A1, 2
9D005B4C  3C029D01   LUI V0, -25343
9D005B50  24429ECC   ADDIU V0, V0, -24884
9D005B54  00452821   ADDU A1, V0, A1
9D005B58  84A20002   LH V0, 2(A1)
300:                 					break;
301:                 				}
302:                 				i++;
303:                 			}// while (translate.code)
304:                 			if (a>='a' && a<='z'){
9D005B5C  2445FF9F   ADDIU A1, V0, -97
9D005B60  2CA5001A   SLTIU A1, A1, 26
9D005B70  24429ED0   ADDIU V0, V0, -24880
305:                 				a -=32;
9D005B64  2443FFE0   ADDIU V1, V0, -32
9D005B68  0B4016FD   J 0x9D005BF4
9D005B6C  0065100B   MOVN V0, V1, A1
306:                 			}
307:                 		} // if (!a)
308:                 	}else{
309:                 		i=0;
310:                 		while (qwerty[i].code){
9D005A88  3C029D01   LUI V0, -25343
9D005A8C  84439ECC   LH V1, -24884(V0)
9D005A90  10600058   BEQ V1, ZERO, 0x9D005BF4
9D005A94  00001021   ADDU V0, ZERO, ZERO
9D005BD0  84430000   LH V1, 0(V0)
9D005BD4  1460FFED   BNE V1, ZERO, 0x9D005B8C
9D005BD8  24A50001   ADDIU A1, A1, 1
9D005BDC  0B4016FD   J 0x9D005BF4
9D005BE0  00001021   ADDU V0, ZERO, ZERO
311:                 			if (qwerty[i].code==(scancode&0xff)){
9D005A98  30C600FF   ANDI A2, A2, 255
9D005A9C  1466004A   BNE V1, A2, 0x9D005BC8
9D005AA0  3C029D01   LUI V0, -25343
9D005AA4  0B4016E7   J 0x9D005B9C
9D005AA8  00002821   ADDU A1, ZERO, ZERO
9D005B8C  14660010   BNE V1, A2, 0x9D005BD0
9D005B90  24420004   ADDIU V0, V0, 4
9D005BCC  00002821   ADDU A1, ZERO, ZERO
312:                 				a=qwerty[i].ascii;
9D005B94  0B4016E8   J 0x9D005BA0
9D005B98  00052880   SLL A1, A1, 2
9D005B9C  00052880   SLL A1, A1, 2
9D005BA0  3C029D01   LUI V0, -25343
9D005BA4  24429ECC   ADDIU V0, V0, -24884
9D005BA8  00452821   ADDU A1, V0, A1
9D005BAC  84A20002   LH V0, 2(A1)
313:                 				break;
314:                 			}
315:                 			i++;
316:                 		}// while (translate.code)
317:                 		if (a>='a' && a<='z' && (key_state & F_CAPS)){
9D005BB0  2443FF9F   ADDIU V1, V0, -97
9D005BB4  2C63001A   SLTIU V1, V1, 26
9D005BB8  1460000A   BNE V1, ZERO, 0x9D005BE4
9D005BBC  2403FF00   ADDIU V1, ZERO, -256
9D005BC8  24429ED0   ADDIU V0, V0, -24880
9D005BE4  9785805C   LHU A1, -32676(GP)
9D005BE8  30A50004   ANDI A1, A1, 4
318:                 			a -=32;
9D005BEC  2443FFE0   ADDIU V1, V0, -32
9D005BF0  0065100B   MOVN V0, V1, A1
319:                 		}
320:                 	}
321:                 	return a|(scancode&0xff00);
9D005BC0  0B4016FF   J 0x9D005BFC
9D005BC4  00832024   AND A0, A0, V1
9D005BF4  2403FF00   ADDIU V1, ZERO, -256
9D005BF8  00832024   AND A0, A0, V1
9D005BFC  00441025   OR V0, V0, A0
322:                 } // GetKey()
9D005C00  03E00008   JR RA
9D005C04  7C021620   SEH V0, V0
323:                 
324:                 void KbdSend(char cmd){  // envoie une commande au clavier
9D005C08  7C042420   SEB A0, A0
325:                     register unsigned int dly;
326:                         bit_cnt=0;
9D005C0C  A380802B   SB ZERO, -32725(GP)
327:                 	parity=0;
9D005C10  A380802C   SB ZERO, -32724(GP)
328:                 	IEC0CLR=_IEC0_INT4IE_MASK; // désactive les interruptions sur KBD_CLK
9D005C14  3C030080   LUI V1, 128
9D005C18  3C02BF88   LUI V0, -16504
9D005C1C  AC431064   SW V1, 4196(V0)
329:                         TRISACLR = KBD_CLK; // MCU prend le contrôle de la ligne KBD_CLK
9D005C20  24020001   ADDIU V0, ZERO, 1
9D005C24  3C03BF88   LUI V1, -16504
9D005C28  AC626014   SW V0, 24596(V1)
330:                         LATACLR = KBD_CLK; //  mis à 0  KBD_CLK
9D005C2C  3C03BF88   LUI V1, -16504
9D005C30  AC626034   SW V0, 24628(V1)
9D005C34  240204C5   ADDIU V0, ZERO, 1221
9D005C38  2442FFFF   ADDIU V0, V0, -1
331:                         // délais minimum 100µsec
332:                         for (dly=(100/3*CLK_PER_USEC);dly;dly--);
9D005C3C  1440FFFF   BNE V0, ZERO, 0x9D005C3C
9D005C40  2442FFFF   ADDIU V0, V0, -1
333:                         TRISACLR = KBD_DAT;	// prend le contrôle de la ligne KBD_DAT
9D005C44  24020002   ADDIU V0, ZERO, 2
9D005C48  3C03BF88   LUI V1, -16504
9D005C4C  AC626014   SW V0, 24596(V1)
334:                 	LATACLR = KBD_DAT;   	// met KBD_DAT à zéro
9D005C50  3C03BF88   LUI V1, -16504
9D005C54  AC626034   SW V0, 24628(V1)
335:                 	TRISASET = KBD_CLK; 	// libère la ligne clock
9D005C58  24030001   ADDIU V1, ZERO, 1
9D005C5C  3C02BF88   LUI V0, -16504
9D005C60  AC436018   SW V1, 24600(V0)
336:                         while (!(PORTAbits.RA0)); // attend que la ligne revienne à 1
9D005C64  3C03BF88   LUI V1, -16504
9D005C68  8C626020   LW V0, 24608(V1)
9D005C6C  30420001   ANDI V0, V0, 1
9D005C70  1040FFFD   BEQ V0, ZERO, 0x9D005C68
9D005C74  00000000   NOP
337:                         while (bit_cnt<8){      // envoie les 8 bits, le moins significatif en premier.
9D005C78  9382802B   LBU V0, -32725(GP)
9D005C7C  304200FF   ANDI V0, V0, 255
9D005C80  2C420008   SLTIU V0, V0, 8
9D005C84  1040001F   BEQ V0, ZERO, 0x9D005D04
9D005C88  3C02BF88   LUI V0, -16504
9D005CF0  9383802B   LBU V1, -32725(GP)
9D005CF4  306300FF   ANDI V1, V1, 255
9D005CF8  2C630008   SLTIU V1, V1, 8
9D005CFC  1460FFE6   BNE V1, ZERO, 0x9D005C98
9D005D00  00042043   SRA A0, A0, 1
338:                 		while (PORTAbits.RA0);   // attend clock à 0
9D005C98  8C436020   LW V1, 24608(V0)
9D005C9C  30630001   ANDI V1, V1, 1
9D005CA0  1460FFFD   BNE V1, ZERO, 0x9D005C98
9D005CA4  30830001   ANDI V1, A0, 1
339:                                 if (cmd&1){
9D005CA8  10600008   BEQ V1, ZERO, 0x9D005CCC
9D005CAC  00000000   NOP
340:                 			LATASET = KBD_DAT;
9D005C94  3C06BF88   LUI A2, -16504
9D005CB0  ACC56038   SW A1, 24632(A2)
341:                 			parity++;
9D005CB4  9383802C   LBU V1, -32724(GP)
9D005CB8  24630001   ADDIU V1, V1, 1
9D005CBC  306300FF   ANDI V1, V1, 255
9D005CC0  A383802C   SB V1, -32724(GP)
9D005CC4  0B401734   J 0x9D005CD0
9D005CC8  00000000   NOP
342:                 		}else{
343:                 			LATACLR = KBD_DAT;
9D005C8C  3C07BF88   LUI A3, -16504
9D005C90  24050002   ADDIU A1, ZERO, 2
9D005CCC  ACE56034   SW A1, 24628(A3)
344:                 		}
345:                 		cmd >>= 1;
346:                 		while (!(PORTAbits.RA0)); // attend clock à 1
9D005CD0  8C436020   LW V1, 24608(V0)
9D005CD4  30630001   ANDI V1, V1, 1
9D005CD8  1060FFFD   BEQ V1, ZERO, 0x9D005CD0
9D005CDC  00000000   NOP
347:                 		bit_cnt++;				  // un bit de plus envoyé.
9D005CE0  9383802B   LBU V1, -32725(GP)
9D005CE4  24630001   ADDIU V1, V1, 1
9D005CE8  306300FF   ANDI V1, V1, 255
9D005CEC  A383802B   SB V1, -32725(GP)
348:                 	}
349:                         while (PORTAbits.RA0);   // attend clock à 0
9D005D04  3C03BF88   LUI V1, -16504
9D005D08  8C626020   LW V0, 24608(V1)
9D005D0C  30420001   ANDI V0, V0, 1
9D005D10  1440FFFD   BNE V0, ZERO, 0x9D005D08
9D005D14  00000000   NOP
350:                 	if (!(parity & 1)){
9D005D18  9382802C   LBU V0, -32724(GP)
9D005D1C  30420001   ANDI V0, V0, 1
9D005D20  14400005   BNE V0, ZERO, 0x9D005D38
9D005D24  24030002   ADDIU V1, ZERO, 2
351:                 		LATASET = KBD_DAT;
9D005D28  3C02BF88   LUI V0, -16504
9D005D2C  AC436038   SW V1, 24632(V0)
352:                 	}else{
353:                 		LATACLR = KBD_DAT;
9D005D38  3C02BF88   LUI V0, -16504
9D005D3C  AC436034   SW V1, 24628(V0)
354:                 	}
355:                 	while (!(PORTAbits.RA0)); // attend clock à 1
9D005D30  0B401751   J 0x9D005D44
9D005D34  3C03BF88   LUI V1, -16504
9D005D40  3C03BF88   LUI V1, -16504
9D005D44  8C626020   LW V0, 24608(V1)
9D005D48  30420001   ANDI V0, V0, 1
9D005D4C  1040FFFD   BEQ V0, ZERO, 0x9D005D44
9D005D50  00000000   NOP
356:                 	while (PORTAbits.RA0);   // attend clock à 0
9D005D54  3C03BF88   LUI V1, -16504
9D005D58  8C626020   LW V0, 24608(V1)
9D005D5C  30420001   ANDI V0, V0, 1
9D005D60  1440FFFD   BNE V0, ZERO, 0x9D005D58
9D005D64  3C02BF88   LUI V0, -16504
357:                 	TRISASET = KBD_DAT;  		// libère la ligne data
9D005D68  24030002   ADDIU V1, ZERO, 2
9D005D6C  AC436018   SW V1, 24600(V0)
358:                 	while (!(PORTAbits.RA0)); // attend clock à 1
9D005D70  3C03BF88   LUI V1, -16504
9D005D74  8C626020   LW V0, 24608(V1)
9D005D78  30420001   ANDI V0, V0, 1
9D005D7C  1040FFFD   BEQ V0, ZERO, 0x9D005D74
9D005D80  00000000   NOP
359:                 	while (PORTA & (KBD_DAT+KBD_CLK)); 	// attend que le clavier mette data et clock à 0
9D005D84  3C03BF88   LUI V1, -16504
9D005D88  8C626020   LW V0, 24608(V1)
9D005D8C  30420003   ANDI V0, V0, 3
9D005D90  1440FFFD   BNE V0, ZERO, 0x9D005D88
9D005D94  3C04BF88   LUI A0, -16504
360:                 	while (!((PORTA & (KBD_DAT+KBD_CLK))==(KBD_DAT+KBD_CLK))); // attend que les 2 lignes reviennent à 1.
9D005D98  24030003   ADDIU V1, ZERO, 3
9D005D9C  8C826020   LW V0, 24608(A0)
9D005DA0  30420003   ANDI V0, V0, 3
9D005DA4  1443FFFD   BNE V0, V1, 0x9D005D9C
9D005DA8  00000000   NOP
361:                 	bit_cnt=0;
9D005DAC  A380802B   SB ZERO, -32725(GP)
362:                         IFS0CLR=_IFS0_INT4IF_MASK;
9D005DB0  3C020080   LUI V0, 128
9D005DB4  3C03BF88   LUI V1, -16504
9D005DB8  AC621034   SW V0, 4148(V1)
363:                 	IEC0SET = _IEC0_INT4IE_MASK; // réactivation interruption
9D005DBC  3C03BF88   LUI V1, -16504
9D005DC0  AC621068   SW V0, 4200(V1)
364:                 } // KbdSend()
9D005DC4  03E00008   JR RA
9D005DC8  00000000   NOP
365:                 
366:                 int SetKbdLeds(unsigned char leds_state){ // contrôle l'état des LEDS du clavier
9D005DCC  27BDFFE0   ADDIU SP, SP, -32
9D005DD0  AFBF001C   SW RA, 28(SP)
9D005DD4  AFB20018   SW S2, 24(SP)
9D005DD8  AFB10014   SW S1, 20(SP)
9D005DDC  AFB00010   SW S0, 16(SP)
367:                     unsigned int t0;
368:                     short c;
369:                     t0=ticks()+100;
9D005DE0  0F402462   JAL ticks
9D005DE4  309200FF   ANDI S2, A0, 255
9D005DE8  24510064   ADDIU S1, V0, 100
370:                     KbdSend(KBD_LED);
9D005DEC  0F401702   JAL KbdSend
9D005DF0  2404FFED   ADDIU A0, ZERO, -19
371:                     c=0;
372:                     while (!(ticks()==t0) && !(rx_flags & F_ERROR) && !c){
9D005DF4  0B401782   J 0x9D005E08
9D005DF8  00008021   ADDU S0, ZERO, ZERO
9D005E08  0F402462   JAL ticks
9D005E0C  00000000   NOP
9D005E10  10510007   BEQ V0, S1, 0x9D005E30
9D005E14  240200FA   ADDIU V0, ZERO, 250
9D005E18  93828029   LBU V0, -32727(GP)
9D005E1C  30420001   ANDI V0, V0, 1
9D005E20  14400003   BNE V0, ZERO, 0x9D005E30
9D005E24  240200FA   ADDIU V0, ZERO, 250
9D005E28  1200FFF4   BEQ S0, ZERO, 0x9D005DFC
9D005E2C  00000000   NOP
373:                         c=KbdScancode();
9D005DFC  0F4017A8   JAL KbdScancode
9D005E00  00000000   NOP
9D005E04  00408021   ADDU S0, V0, ZERO
374:                     }
375:                     if (c==KBD_ACK){
9D005E30  16020015   BNE S0, V0, 0x9D005E88
9D005E34  24020001   ADDIU V0, ZERO, 1
376:                         t0=ticks()+100;
9D005E38  0F402462   JAL ticks
9D005E3C  00008021   ADDU S0, ZERO, ZERO
9D005E40  24510064   ADDIU S1, V0, 100
377:                         KbdSend(leds_state);
9D005E44  0F401702   JAL KbdSend
9D005E48  7C122420   SEB A0, S2
378:                         c=0;
379:                         while (!(ticks()==t0) && !(rx_flags & F_ERROR) && !c){
9D005E4C  0B401798   J 0x9D005E60
9D005E50  00000000   NOP
9D005E60  0F402462   JAL ticks
9D005E64  00000000   NOP
9D005E68  10510007   BEQ V0, S1, 0x9D005E88
9D005E6C  24020001   ADDIU V0, ZERO, 1
9D005E70  93828029   LBU V0, -32727(GP)
9D005E74  30420001   ANDI V0, V0, 1
9D005E78  14400003   BNE V0, ZERO, 0x9D005E88
9D005E7C  24020001   ADDIU V0, ZERO, 1
9D005E80  1200FFF4   BEQ S0, ZERO, 0x9D005E54
9D005E84  00000000   NOP
380:                             c=KbdScancode();
9D005E54  0F4017A8   JAL KbdScancode
9D005E58  00000000   NOP
9D005E5C  00408021   ADDU S0, V0, ZERO
381:                         }
382:                     }
383:                     if (c=KBD_ACK)
384:                         return 1;
385:                     else
386:                         return 0;
387:                 } // SetKbdLeds()
9D005E88  8FBF001C   LW RA, 28(SP)
9D005E8C  8FB20018   LW S2, 24(SP)
9D005E90  8FB10014   LW S1, 20(SP)
9D005E94  8FB00010   LW S0, 16(SP)
9D005E98  03E00008   JR RA
9D005E9C  27BD0020   ADDIU SP, SP, 32
388:                 
389:                 void __ISR(_EXTERNAL_4_VECTOR,IPL6SOFT) kbd_clk_isr(void){
9D0065D4  415DE800   RDPGPR SP, SP
9D0065D8  401A7000   MFC0 K0, EPC
9D0065DC  401B6000   MFC0 K1, Status
9D0065E0  27BDFFE0   ADDIU SP, SP, -32
9D0065E4  AFBA001C   SW K0, 28(SP)
9D0065E8  401A6002   MFC0 K0, SRSCtl
9D0065EC  AFBB0018   SW K1, 24(SP)
9D0065F0  AFBA0014   SW K0, 20(SP)
9D0065F4  7C1B7844   INS K1, ZERO, 1, 15
9D0065F8  377B1800   ORI K1, K1, 6144
9D0065FC  409B6000   MTC0 K1, Status
9D006600  AFA4000C   SW A0, 12(SP)
9D006604  AFA30008   SW V1, 8(SP)
9D006608  AFA20004   SW V0, 4(SP)
390:                 	switch (bit_cnt){
9D00660C  9382802B   LBU V0, -32725(GP)
9D006610  304200FF   ANDI V0, V0, 255
9D006614  24030009   ADDIU V1, ZERO, 9
9D006618  10430010   BEQ V0, V1, 0x9D00665C
9D00661C  2403000A   ADDIU V1, ZERO, 10
9D006620  10430028   BEQ V0, V1, 0x9D0066C4
9D006624  00000000   NOP
9D006628  1440003B   BNE V0, ZERO, 0x9D006718
9D00662C  3C02BF88   LUI V0, -16504
391:                 	case 0:   // start bit
392:                 		if (!(PORTA & KBD_DAT)){
9D006630  8C426020   LW V0, 24608(V0)
9D006634  30420002   ANDI V0, V0, 2
9D006638  5440004C   BNEL V0, ZERO, 0x9D00676C
9D00663C  3C030080   LUI V1, 128
393:                                     parity=0;
9D006640  A380802C   SB ZERO, -32724(GP)
394:                                     bit_cnt++;
9D006644  9382802B   LBU V0, -32725(GP)
9D006648  24420001   ADDIU V0, V0, 1
9D00664C  304200FF   ANDI V0, V0, 255
9D006650  A382802B   SB V0, -32725(GP)
395:                                 }
396:                 		break;
397:                 	case 9:   // paritée
398:                 		if (PORTA & KBD_DAT)
9D00665C  3C02BF88   LUI V0, -16504
9D006660  8C426020   LW V0, 24608(V0)
9D006664  30420002   ANDI V0, V0, 2
9D006668  10400005   BEQ V0, ZERO, 0x9D006680
9D00666C  00000000   NOP
399:                 			parity++;
9D006670  9382802C   LBU V0, -32724(GP)
9D006674  24420001   ADDIU V0, V0, 1
9D006678  304200FF   ANDI V0, V0, 255
9D00667C  A382802C   SB V0, -32724(GP)
400:                 		if (!(parity & 1)){
9D006680  9382802C   LBU V0, -32724(GP)
9D006684  30420001   ANDI V0, V0, 1
9D006688  14400008   BNE V0, ZERO, 0x9D0066AC
9D00668C  00000000   NOP
401:                 			rx_flags |= F_ERROR;
9D006690  93828029   LBU V0, -32727(GP)
9D006694  304200FF   ANDI V0, V0, 255
9D006698  34420001   ORI V0, V0, 1
9D00669C  A3828029   SB V0, -32727(GP)
402:                                         IEC0CLR = _IEC0_INT4IE_MASK; // désactive l'interruption
9D0066A0  3C030080   LUI V1, 128
9D0066A4  3C02BF88   LUI V0, -16504
9D0066A8  AC431064   SW V1, 4196(V0)
403:                 		}
404:                 		bit_cnt++;
9D0066AC  9382802B   LBU V0, -32725(GP)
9D0066B0  24420001   ADDIU V0, V0, 1
9D0066B4  304200FF   ANDI V0, V0, 255
9D0066B8  A382802B   SB V0, -32725(GP)
405:                 		break;
9D0066BC  0B4019DB   J 0x9D00676C
9D0066C0  3C030080   LUI V1, 128
406:                 	case 10:  // stop bit
407:                 		kbd_queue[tail]=in_byte;
9D0066C4  9384802D   LBU A0, -32723(GP)
9D0066C8  308400FF   ANDI A0, A0, 255
9D0066CC  9383802E   LBU V1, -32722(GP)
9D0066D0  3C02A000   LUI V0, -24576
9D0066D4  24424CA0   ADDIU V0, V0, 19616
9D0066D8  00821021   ADDU V0, A0, V0
9D0066DC  A0430000   SB V1, 0(V0)
408:                 		tail++;
9D0066E0  9382802D   LBU V0, -32723(GP)
9D0066E4  24420001   ADDIU V0, V0, 1
9D0066E8  304200FF   ANDI V0, V0, 255
9D0066EC  A382802D   SB V0, -32723(GP)
409:                 		tail &=31;
9D0066F0  9382802D   LBU V0, -32723(GP)
9D0066F4  3042001F   ANDI V0, V0, 31
9D0066F8  A382802D   SB V0, -32723(GP)
410:                 		bit_cnt=0;
9D0066FC  A380802B   SB ZERO, -32725(GP)
411:                 		rx_flags |= F_RCVD;
9D006700  93828029   LBU V0, -32727(GP)
9D006704  304200FF   ANDI V0, V0, 255
9D006708  34420002   ORI V0, V0, 2
9D00670C  A3828029   SB V0, -32727(GP)
412:                 		break;
9D006710  0B4019DB   J 0x9D00676C
9D006714  3C030080   LUI V1, 128
413:                 	default:
414:                 		in_byte >>=1;
9D006718  9382802E   LBU V0, -32722(GP)
9D00671C  7C423040   EXT V0, V0, 1, 7
9D006720  A382802E   SB V0, -32722(GP)
415:                 		if(PORTA & KBD_DAT){
9D006724  3C02BF88   LUI V0, -16504
9D006728  8C426020   LW V0, 24608(V0)
9D00672C  30420002   ANDI V0, V0, 2
9D006730  10400009   BEQ V0, ZERO, 0x9D006758
9D006734  00000000   NOP
416:                 			in_byte |=128;
9D006738  9382802E   LBU V0, -32722(GP)
9D00673C  3042007F   ANDI V0, V0, 127
9D006740  34420080   ORI V0, V0, 128
9D006744  A382802E   SB V0, -32722(GP)
417:                 			parity++;
9D006748  9382802C   LBU V0, -32724(GP)
9D00674C  24420001   ADDIU V0, V0, 1
9D006750  304200FF   ANDI V0, V0, 255
9D006754  A382802C   SB V0, -32724(GP)
418:                 		}
419:                 		bit_cnt++;
9D006758  9382802B   LBU V0, -32725(GP)
9D00675C  24420001   ADDIU V0, V0, 1
9D006760  304200FF   ANDI V0, V0, 255
9D006764  A382802B   SB V0, -32725(GP)
420:                 	}
421:                         mINT4ClearIntFlag();
9D006654  0B4019DB   J 0x9D00676C
9D006658  3C030080   LUI V1, 128
9D006768  3C030080   LUI V1, 128
9D00676C  3C02BF88   LUI V0, -16504
9D006770  AC431034   SW V1, 4148(V0)
422:                 } // kbd_clk_isr()
9D006774  8FA4000C   LW A0, 12(SP)
9D006778  8FA30008   LW V1, 8(SP)
9D00677C  8FA20004   LW V0, 4(SP)
9D006780  41606000   DI ZERO
9D006784  000000C0   EHB
9D006788  8FBA001C   LW K0, 28(SP)
9D00678C  8FBB0018   LW K1, 24(SP)
9D006790  409A7000   MTC0 K0, EPC
9D006794  8FBA0014   LW K0, 20(SP)
9D006798  27BD0020   ADDIU SP, SP, 32
9D00679C  409A6002   MTC0 K0, SRSCtl
9D0067A0  41DDE800   WRPGPR SP, SP
9D0067A4  409B6000   MTC0 K1, Status
9D0067A8  42000018   ERET
423:                 
424:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/sdmmc.c  ------------------------------
1:                   /*
2:                   ** SDMMC.c SD card interface
3:                   **
4:                   ** 7/20/06 v1.4 LDJ
5:                   ** 7/14/07 v2.0 LDJ
6:                   **
7:                   [30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
8:                   ** 07 May 2012	Changes made to allow SD card library to support
9:                   **					PIC32 Pinguino and PIC32 Pinguino Micro that have neither
10:                  **					SD card presence nor WP switch detection switches.
11:                  **					see functions getCD() and getWP() below.
12:                  */
13:                  
14:                  #ifndef __SDMMC_C__
15:                  #define __SDMMC_C__
16:                  
17:                  //#include <system.c>
18:                  //#include <digitalw.c>
19:                  //#include <spi.c>        // in order to use default SPI port
20:                  #include <plib.h>
21:                  #include "sdmmc.h"
22:                  //#include "diskio.h"
23:                  //#include "ff.h"
24:                  
25:                  // send one byte of data and receive one back at the same time
26:                  unsigned char writeSPI(unsigned char b)
27:                  {
9D0082DC  308400FF   ANDI A0, A0, 255
28:                  
29:                  	SPI2BUF = b;						
9D0082E0  3C02BF80   LUI V0, -16512
9D0082E4  AC445A20   SW A0, 23072(V0)
30:                  	while(!SPI2STATbits.SPIRBF);	// wait transfer complete
9D0082E8  3C03BF80   LUI V1, -16512
9D0082EC  8C625A10   LW V0, 23056(V1)
9D0082F0  30420001   ANDI V0, V0, 1
9D0082F4  1040FFFD   BEQ V0, ZERO, 0x9D0082EC
9D0082F8  3C02BF80   LUI V0, -16512
31:                  	return SPI2BUF;					// read the received value
9D0082FC  8C425A20   LW V0, 23072(V0)
32:                  
33:                  /*
34:                  	BUFFER = b;			            // write to buffer for TX
35:                  	while (!STATRX);		        // wait until cycle complete
36:                  	return BUFFER;			        // return with byte read
37:                   */
38:                  }	// writeSPI
9D008300  03E00008   JR RA
9D008304  304200FF   ANDI V0, V0, 255
39:                  
40:                  void initSD(void)
41:                  {
42:                  	PORTB |=SDCSEL; //digitalwrite(SDCSEL, HIGH);	// initially keep the SD card disabled
9D008308  3C02BF88   LUI V0, -16504
9D00830C  8C436120   LW V1, 24864(V0)
9D008310  34630004   ORI V1, V1, 4
9D008314  AC436120   SW V1, 24864(V0)
43:                  	TRISB &=~SDCSEL; //pinmode(SDCSEL, OUTPUT);		// make Card select an output pin
9D008318  3C02BF88   LUI V0, -16504
9D00831C  8C446110   LW A0, 24848(V0)
9D008320  2403FFFB   ADDIU V1, ZERO, -5
9D008324  00831824   AND V1, A0, V1
9D008328  AC436110   SW V1, 24848(V0)
44:                  
45:                  	// init the spi module for a slow (safe) clock speed first
46:                  
47:                  	SPI2CON = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
9D00832C  34038120   ORI V1, ZERO, -32480
9D008330  3C02BF80   LUI V0, -16512
9D008334  AC435A00   SW V1, 23040(V0)
48:                  	SPI2BRG = (mGetPeripheralClock() / (2 * 250000)) - 1;
9D008338  2403004A   ADDIU V1, ZERO, 74
9D00833C  3C02BF80   LUI V0, -16512
9D008340  AC435A30   SW V1, 23088(V0)
49:                  
50:                  /*
51:                  	SPICONF = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
52:                  	CLKSPD  = (GetPeripheralClock() / (2 * 250000)) - 1;
53:                  */
54:                  }   // initSD
9D008344  03E00008   JR RA
9D008348  00000000   NOP
55:                  
56:                  #define readSPI()   writeSPI(0xFF)
57:                  #define clockSPI()  writeSPI(0xFF)
58:                  
59:                  void disableSD(void)
60:                  {
9D00834C  27BDFFE8   ADDIU SP, SP, -24
9D008350  AFBF0014   SW RA, 20(SP)
61:                  
62:                         PORTB |= SDCSEL; //digitalwrite(SDCSEL, HIGH);	// Deselected = SDCSEL high
9D008354  3C02BF88   LUI V0, -16504
9D008358  8C436120   LW V1, 24864(V0)
9D00835C  34630004   ORI V1, V1, 4
9D008360  AC436120   SW V1, 24864(V0)
63:                         clockSPI();
9D008364  0F4020B7   JAL writeSPI
9D008368  240400FF   ADDIU A0, ZERO, 255
64:                  }
9D00836C  8FBF0014   LW RA, 20(SP)
9D008370  03E00008   JR RA
9D008374  27BD0018   ADDIU SP, SP, 24
65:                  
66:                  void enableSD(void)
67:                  {
68:                  	PORTB &= ~ SDCSEL; //digitalwrite(SDCSEL, LOW);	// Selected = SDCSEL low
9D008378  3C02BF88   LUI V0, -16504
9D00837C  8C446120   LW A0, 24864(V0)
9D008380  2403FFFB   ADDIU V1, ZERO, -5
9D008384  00831824   AND V1, A0, V1
9D008388  AC436120   SW V1, 24864(V0)
69:                  }
9D00838C  03E00008   JR RA
9D008390  00000000   NOP
70:                  
71:                  // c    command code
72:                  // a    byte address of data block
73:                  int sendSDCmd(unsigned char c, unsigned a)
74:                  {
9D008394  27BDFFE0   ADDIU SP, SP, -32
9D008398  AFBF001C   SW RA, 28(SP)
9D00839C  AFB10018   SW S1, 24(SP)
9D0083A0  AFB00014   SW S0, 20(SP)
9D0083A4  00A08821   ADDU S1, A1, ZERO
75:                  	int i, r;
76:                  
77:                  	// enable SD card
78:                  	// CS low
79:                  	enableSD();
9D0083A8  0F4020DE   JAL enableSD
9D0083AC  309000FF   ANDI S0, A0, 255
80:                  
81:                  	// send a comand packet (6 bytes)
82:                  	writeSPI(c | 0x40);    // send command
9D0083B0  0F4020B7   JAL writeSPI
9D0083B4  36040040   ORI A0, S0, 64
83:                  	writeSPI(a>>24);       // msb of the address
9D0083B8  0F4020B7   JAL writeSPI
9D0083BC  00112602   SRL A0, S1, 24
84:                  	writeSPI(a>>16);
9D0083C0  0F4020B7   JAL writeSPI
9D0083C4  7E243C00   EXT A0, S1, 16, 8
85:                  	writeSPI(a>>8);
9D0083C8  0F4020B7   JAL writeSPI
9D0083CC  7E243A00   EXT A0, S1, 8, 8
86:                  	writeSPI(a);           // lsb
9D0083D0  0F4020B7   JAL writeSPI
9D0083D4  322400FF   ANDI A0, S1, 255
87:                  
88:                  	writeSPI(0x95);        // send CMD0 CRC
9D0083D8  0F4020B7   JAL writeSPI
9D0083DC  24040095   ADDIU A0, ZERO, 149
9D0083E0  24100008   ADDIU S0, ZERO, 8
89:                  
90:                  	// now wait for a response, allow for up to 8 bytes delay
91:                  	for(i=0; i<8; i++)
9D0083F8  1600FFFA   BNE S0, ZERO, 0x9D0083E4
9D0083FC  00000000   NOP
92:                  	{
93:                  		r = readSPI();
9D0083E4  0F4020B7   JAL writeSPI
9D0083E8  240400FF   ADDIU A0, ZERO, 255
94:                  		if (r != 0xFF)
9D0083EC  240300FF   ADDIU V1, ZERO, 255
9D0083F0  14430003   BNE V0, V1, 0x9D008400
9D0083F4  2610FFFF   ADDIU S0, S0, -1
95:                  			break;
96:                  	}
97:                  	return (r);
98:                  
99:                  	/* return response
100:                 	FF - timeout
101:                 	00 - command accepted
102:                 	01 - command received, card in idle state after RESET
103:                 
104:                 	other codes:
105:                 	bit 0 = Idle state
106:                 	bit 1 = Erase Reset
107:                 	bit 2 = Illegal command
108:                 	bit 3 = Communication CRC error
109:                 	bit 4 = Erase sequence error
110:                 	bit 5 = Address error
111:                 	bit 6 = Parameter error
112:                 	bit 7 = Always 0
113:                 	*/
114:                 	// NOTE CSCD is still low!
115:                 } // sendSDCmd
9D008400  8FBF001C   LW RA, 28(SP)
9D008404  8FB10018   LW S1, 24(SP)
9D008408  8FB00014   LW S0, 20(SP)
9D00840C  03E00008   JR RA
9D008410  27BD0020   ADDIU SP, SP, 32
116:                 
117:                 
118:                 // returns 0 if successful
119:                 //          E_COMMAND_ACK   failed to acknowledge reset command
120:                 //          E_INIT_TIMEOUT  failed to initialize
121:                 int initMedia(void)
122:                 {
9D008414  27BDFFE0   ADDIU SP, SP, -32
9D008418  AFBF001C   SW RA, 28(SP)
9D00841C  AFB10018   SW S1, 24(SP)
123:                 	int i, r;
124:                 
125:                 	// 1. with the card NOT selected
126:                 	// Set DI and CS high
127:                 	disableSD();
9D008420  0F4020D3   JAL disableSD
9D008424  AFB00014   SW S0, 20(SP)
128:                 
129:                 	// 2. send 74 or more clock cycles to start up
130:                 	// apply 74 or more clock pulses to SCLK.
131:                 	// The card will enter its native operating mode and go ready to accept native commands.
132:                 	for (i=0; i<10; i++)
9D008428  00008021   ADDU S0, ZERO, ZERO
9D00842C  2411000A   ADDIU S1, ZERO, 10
9D008438  26100001   ADDIU S0, S0, 1
9D00843C  1611FFFC   BNE S0, S1, 0x9D008430
9D008440  00000000   NOP
133:                 		clockSPI();
9D008430  0F4020B7   JAL writeSPI
9D008434  240400FF   ADDIU A0, ZERO, 255
134:                 
135:                 	// 3. now select the card
136:                 	enableSD();
9D008444  0F4020DE   JAL enableSD
9D008448  00000000   NOP
137:                 
138:                 	//card detection is now in disk_initialize()
139:                 
140:                 	return 0;
141:                 } // init media
9D00844C  00001021   ADDU V0, ZERO, ZERO
9D008450  8FBF001C   LW RA, 28(SP)
9D008454  8FB10018   LW S1, 24(SP)
9D008458  8FB00014   LW S0, 20(SP)
9D00845C  03E00008   JR RA
9D008460  27BD0020   ADDIU SP, SP, 32
142:                 
143:                 
144:                 // a        LBA of sector requested
145:                 // p        pointer to sector buffer
146:                 // returns  TRUE if successful
147:                 int readSECTOR(LBA a, char *p)
148:                 {
9D008464  27BDFFD8   ADDIU SP, SP, -40
9D008468  AFBF0024   SW RA, 36(SP)
9D00846C  AFB40020   SW S4, 32(SP)
9D008470  AFB3001C   SW S3, 28(SP)
9D008474  AFB20018   SW S2, 24(SP)
9D008478  AFB10014   SW S1, 20(SP)
9D00847C  AFB00010   SW S0, 16(SP)
9D008480  00A08821   ADDU S1, A1, ZERO
149:                 	int r, i;
150:                 
151:                 	#ifdef READ_LED
152:                         _read_off();
9D008484  3C02BF88   LUI V0, -16504
9D008488  8C456120   LW A1, 24864(V0)
9D00848C  2403FFF7   ADDIU V1, ZERO, -9
9D008490  00A31824   AND V1, A1, V1
9D008494  AC436120   SW V1, 24864(V0)
153:                 	//digitalwrite(READ_LED, 0);
154:                 	#endif
155:                 
156:                 	// 1. send READ command
157:                 	r = sendSDCmd(READ_SINGLE, (a << 9));
9D008498  00042A40   SLL A1, A0, 9
9D00849C  0F4020E5   JAL sendSDCmd
9D0084A0  24040011   ADDIU A0, ZERO, 17
158:                 	if (r == 0)    // check if command was accepted
9D0084A4  1440001A   BNE V0, ZERO, 0x9D008510
9D0084A8  00409021   ADDU S2, V0, ZERO
9D0084AC  00008021   ADDU S0, ZERO, ZERO
159:                 	{
160:                 	// 2. wait for a response
161:                 	for(i=0; i<R_TIMEOUT; i++)
9D0084B4  241461A8   ADDIU S4, ZERO, 25000
9D0084C8  26100001   ADDIU S0, S0, 1
9D0084CC  1614FFFA   BNE S0, S4, 0x9D0084B8
9D0084D0  00000000   NOP
9D0084D4  0B402144   J 0x9D008510
9D0084D8  00000000   NOP
162:                 	{
163:                 	r = readSPI();
9D0084B8  0F4020B7   JAL writeSPI
9D0084BC  240400FF   ADDIU A0, ZERO, 255
164:                 	if (r == DATA_START)
9D0084B0  241300FE   ADDIU S3, ZERO, 254
9D0084C0  10530006   BEQ V0, S3, 0x9D0084DC
9D0084C4  00409021   ADDU S2, V0, ZERO
165:                 	break;
166:                 	}
167:                 
168:                 	// 3. if it did not timeout, read 512 byte of data
169:                 	if (i != R_TIMEOUT)
9D0084DC  240261A8   ADDIU V0, ZERO, 25000
9D0084E0  1202000B   BEQ S0, V0, 0x9D008510
9D0084E4  26300200   ADDIU S0, S1, 512
170:                 	{
171:                 		i = 512;
172:                 		do{
173:                 			*p++ = readSPI();
9D0084E8  0F4020B7   JAL writeSPI
9D0084EC  240400FF   ADDIU A0, ZERO, 255
9D0084F0  A2220000   SB V0, 0(S1)
9D0084F4  26310001   ADDIU S1, S1, 1
174:                 		} while (--i>0);
9D0084F8  1630FFFB   BNE S1, S0, 0x9D0084E8
9D0084FC  00000000   NOP
175:                 
176:                 		// 4. ignore CRC
177:                 		readSPI();
9D008500  0F4020B7   JAL writeSPI
9D008504  240400FF   ADDIU A0, ZERO, 255
178:                 		readSPI();
9D008508  0F4020B7   JAL writeSPI
9D00850C  240400FF   ADDIU A0, ZERO, 255
179:                 
180:                 	} // data arrived
181:                 
182:                 	} // command accepted
183:                 
184:                 	// 5. remember to disable the card
185:                 	disableSD();
9D008510  0F4020D3   JAL disableSD
9D008514  00000000   NOP
186:                 
187:                 	#ifdef READ_LED
188:                         _read_on();
9D008518  3C02BF88   LUI V0, -16504
9D00851C  8C436120   LW V1, 24864(V0)
9D008520  34630008   ORI V1, V1, 8
9D008524  AC436120   SW V1, 24864(V0)
189:                 	//digital(READ_LED, 1);
190:                 	#endif
191:                 
192:                 	return (r == DATA_START);    // return TRUE if successful
9D008528  3A4200FE   XORI V0, S2, 254
193:                 } // readSECTOR
9D00852C  2C420001   SLTIU V0, V0, 1
9D008530  8FBF0024   LW RA, 36(SP)
9D008534  8FB40020   LW S4, 32(SP)
9D008538  8FB3001C   LW S3, 28(SP)
9D00853C  8FB20018   LW S2, 24(SP)
9D008540  8FB10014   LW S1, 20(SP)
9D008544  8FB00010   LW S0, 16(SP)
9D008548  03E00008   JR RA
9D00854C  27BD0028   ADDIU SP, SP, 40
194:                 
195:                 
196:                 // a        LBA of sector requested
197:                 // p        pointer to sector buffer
198:                 // returns  TRUE if successful
199:                 int writeSECTOR(LBA a, char *p)
9D008584  26110200   ADDIU S1, S0, 512
200:                 {
9D008550  27BDFFE0   ADDIU SP, SP, -32
9D008554  AFBF001C   SW RA, 28(SP)
9D008558  AFB20018   SW S2, 24(SP)
9D00855C  AFB10014   SW S1, 20(SP)
9D008560  AFB00010   SW S0, 16(SP)
9D008564  00A08021   ADDU S0, A1, ZERO
201:                 	unsigned r, i;
202:                 
203:                 	// 0. check Write Protect
204:                 //	if (getWP())
205:                 //		return FAIL;
206:                 
207:                 	// 1. send WRITE command
208:                 	r = sendSDCmd(WRITE_SINGLE, (a << 9));
9D008568  00042A40   SLL A1, A0, 9
9D00856C  0F4020E5   JAL sendSDCmd
9D008570  24040018   ADDIU A0, ZERO, 24
209:                 	if (r == 0)    // check if command was accepted
9D008574  14400025   BNE V0, ZERO, 0x9D00860C
9D008578  00409021   ADDU S2, V0, ZERO
210:                 	{
211:                 		// 2. send data
212:                 		writeSPI(DATA_START);
9D00857C  0F4020B7   JAL writeSPI
9D008580  240400FE   ADDIU A0, ZERO, 254
213:                 
214:                 		// send 512 bytes of data
215:                 		for(i=0; i<512; i++)
9D008594  5611FFFD   BNEL S0, S1, 0x9D00858C
9D008598  92040000   LBU A0, 0(S0)
216:                 		writeSPI(*p++);
9D008588  92040000   LBU A0, 0(S0)
9D00858C  0F4020B7   JAL writeSPI
9D008590  26100001   ADDIU S0, S0, 1
217:                 
218:                 		// 3. send dummy CRC
219:                 		clockSPI();
9D00859C  0F4020B7   JAL writeSPI
9D0085A0  240400FF   ADDIU A0, ZERO, 255
220:                 		clockSPI();
9D0085A4  0F4020B7   JAL writeSPI
9D0085A8  240400FF   ADDIU A0, ZERO, 255
221:                 
222:                 		// 4. check if data accepted
223:                 		r = readSPI();
9D0085AC  0F4020B7   JAL writeSPI
9D0085B0  240400FF   ADDIU A0, ZERO, 255
224:                 		if ((r & 0xf) == DATA_ACCEPT)
9D0085B4  3042000F   ANDI V0, V0, 15
9D0085B8  24030005   ADDIU V1, ZERO, 5
9D0085BC  14430013   BNE V0, V1, 0x9D00860C
9D0085C0  3C02BF88   LUI V0, -16504
225:                 		{
226:                 			#ifdef WRITE_LED
227:                                         _write_off();
9D0085C4  8C446120   LW A0, 24864(V0)
9D0085C8  2403FFF7   ADDIU V1, ZERO, -9
9D0085CC  00831824   AND V1, A0, V1
9D0085D0  AC436120   SW V1, 24864(V0)
228:                 			//digitalwrite(WRITE_LED, 0);
229:                 			#endif
230:                 
231:                 			// 5. wait for write completion
232:                 			for(i=0; i<W_TIMEOUT; i++)
9D0085D4  00008021   ADDU S0, ZERO, ZERO
9D0085D8  3C110003   LUI S1, 3
9D0085DC  3631D090   ORI S1, S1, -12144
9D0085F0  26100001   ADDIU S0, S0, 1
9D0085F4  1611FFFA   BNE S0, S1, 0x9D0085E0
9D0085F8  00000000   NOP
233:                 			{
234:                 				r = readSPI();
9D0085E0  0F4020B7   JAL writeSPI
9D0085E4  240400FF   ADDIU A0, ZERO, 255
235:                 				if (r != 0 )
9D0085E8  14400004   BNE V0, ZERO, 0x9D0085FC
9D0085EC  00409021   ADDU S2, V0, ZERO
236:                 					break;
237:                 			}
238:                 			#ifdef WRITE_LED
239:                                         _write_on();
9D0085FC  3C02BF88   LUI V0, -16504
9D008600  8C436120   LW V1, 24864(V0)
9D008604  34630008   ORI V1, V1, 8
9D008608  AC436120   SW V1, 24864(V0)
240:                 			//digitalwrite(WRITE_LED, 1);
241:                 			#endif
242:                 		} // accepted
243:                 		else
244:                 		{
245:                 			r = FAIL;
246:                 		}
247:                 	} // command accepted
248:                 
249:                 	// 6. disable the card
250:                 	disableSD();
9D00860C  0F4020D3   JAL disableSD
9D008610  00000000   NOP
251:                 
252:                 	return (r);      // return TRUE if successful
253:                 } // writeSECTOR
9D008614  02401021   ADDU V0, S2, ZERO
9D008618  8FBF001C   LW RA, 28(SP)
9D00861C  8FB20018   LW S2, 24(SP)
9D008620  8FB10014   LW S1, 20(SP)
9D008624  8FB00010   LW S0, 16(SP)
9D008628  03E00008   JR RA
9D00862C  27BD0020   ADDIU SP, SP, 32
254:                 
255:                 
256:                 // SD card connector presence detection switch
257:                 // returns  TRUE card present
258:                 //          FALSE card not present
259:                 int getCD(void)
260:                 {
261:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
262:                 // 2013-09-05 ** added support for VPC_32
263:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined (EMPEROR460) || defined(VPC_32)
264:                 	return TRUE;
265:                 #else
266:                 	return (SDCD);
267:                 #endif
268:                 }
9D008630  03E00008   JR RA
9D008634  24020001   ADDIU V0, ZERO, 1
269:                 
270:                 // card Write Protect tab detection switch
271:                 // returns  TRUE write protect tab on LOCK
272:                 //          FALSE write protection tab OPEN
273:                 int getWP(void)
274:                 {
275:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
276:                 // 2013-09-05 ** added support for VPC_32
277:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined(EMPEROR460) || defined (VPC_32)
278:                 	return FALSE;
279:                 #else
280:                 	return (SDWP);
281:                 #endif
282:                 }
9D008638  03E00008   JR RA
9D00863C  00001021   ADDU V0, ZERO, ZERO
283:                 
284:                 #endif /* __SDMMC_C__ */
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/fileio.c  -----------------------------
1:                   /*	----------------------------------------------------------------------------
2:                   	FILE:			fileio.c
3:                   	PROJECT:		pinguino32
4:                   	PURPOSE:		SD Card file system functions
5:                   	AUTHORS:		Alfred Broda <alfredbroda@gmail.com>
6:                   					Mark Harper <markfh@f2s.com>
7:                   					Regis Blanchot <rblanchot@gmail.com>
8:                   	FIRST RELEASE:	23 dec. 2011
9:                   	LAST RELEASE:	06 jan. 2012
10:                  	----------------------------------------------------------------------------
11:                  	based on original code by Regis Blanchot and FatFS example for PIC24
12:                  	----------------------------------------------------------------------------
13:                   	[30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
14:                  	07 May 2012	As part of providing support for PIC32 Pinguino Micro and
15:                  					potentially other cards removed #if defined (PIC32_Pinguino) etc
16:                  					and #endif in function mount() so that SDCS is set via mount 
17:                  					for all cards.
18:                  */
19:                  
20:                  #ifndef __FILEIO_C__
21:                  #define __FILEIO_C__
22:                  
23:                  // standard C libraries used
24:                  #include <ctype.h>      		// toupper...
25:                  #include <string.h>     		// memcpy...
26:                  //#include <malloc.h>				// malloc, free?
27:                  #include <GenericTypeDefs.h>
28:                  
29:                  #include "fileio.h"
30:                  #include "sdmmc.h"
31:                  #include "ff.h"					// Fat Filesystem
32:                  #include "diskio.h"				// card access functions
33:                  #include "../serial_comm.h"
34:                  
35:                  //#define SD_DEBUG
36:                  
37:                  //#ifdef SD_DEBUG
38:                  //    #include <__cdc.c>          // USB CDC functions
39:                  //#endif
40:                  
41:                  /*	----------------------------------------------------------------------------
42:                   mount
43:                   initializes a MEDIA structure for FILEIO access
44:                   will mount only the first partition on the disk/card
45:                   --------------------------------------------------------------------------*/
46:                  
47:                  static FATFS _Fat;
48:                  
49:                  char mount(unsigned char pin) {
9D008D04  27BDFFE0   ADDIU SP, SP, -32
9D008D08  AFBF001C   SW RA, 28(SP)
50:                  	int flag, i;
51:                  	FRESULT r;
52:                  
53:                  	SDCS = pin;
9D008D0C  A3848088   SB A0, -32632(GP)
54:                  
55:                  	// 0. init the I/Os
56:                  #ifdef SD_DEBUG
57:                  	UartPrint(STDOUT,"Initialisation carte SD\r");
9D008D10  24040001   ADDIU A0, ZERO, 1
9D008D14  3C059D01   LUI A1, -25343
9D008D18  0F4021F2   JAL UartPrint
9D008D1C  24A5A278   ADDIU A1, A1, -23944
58:                  #endif
59:                  	initSD();
9D008D20  0F4020C2   JAL initSD
9D008D24  00000000   NOP
60:                  
61:                  #ifdef SD_DEBUG
62:                  	UartPrint(STDOUT,"Looking for SD slot... ");
9D008D28  24040001   ADDIU A0, ZERO, 1
9D008D2C  3C059D01   LUI A1, -25343
9D008D30  0F4021F2   JAL UartPrint
9D008D34  24A5A294   ADDIU A1, A1, -23916
63:                  #endif
64:                  	// 1. check if the card is in the slot
65:                  	if (!getCD()) {
9D008D38  0F40218C   JAL getCD
9D008D3C  00000000   NOP
9D008D40  14400008   BNE V0, ZERO, 0x9D008D64
9D008D44  24040001   ADDIU A0, ZERO, 1
66:                  		FError = FE_NOT_PRESENT;
9D008D48  24020002   ADDIU V0, ZERO, 2
9D008D4C  A382807C   SB V0, -32644(GP)
67:                  #ifdef SD_DEBUG
68:                  		UartPrint(STDOUT, "Échec!\r");
9D008D50  3C059D01   LUI A1, -25343
9D008D54  0F4021F2   JAL UartPrint
9D008D58  24A5A2AC   ADDIU A1, A1, -23892
69:                  #endif
70:                  		return FALSE;
9D008D5C  0B40239D   J 0x9D008E74
9D008D60  00001021   ADDU V0, ZERO, ZERO
71:                  	}
72:                  #ifdef SD_DEBUG
73:                  	UartPrint(STDOUT,"OK\r");
9D008D64  3C059D01   LUI A1, -25343
9D008D68  0F4021F2   JAL UartPrint
9D008D6C  24A5A2B4   ADDIU A1, A1, -23884
74:                  #endif
75:                  
76:                  	// 2. initialize the card
77:                  #ifdef SD_DEBUG
78:                  	UartPrint(STDOUT,"Initializing SD card... ");
9D008D70  24040001   ADDIU A0, ZERO, 1
9D008D74  3C059D01   LUI A1, -25343
9D008D78  0F4021F2   JAL UartPrint
9D008D7C  24A5A2B8   ADDIU A1, A1, -23880
79:                  #endif
80:                  	initMedia();
9D008D80  0F402105   JAL initMedia
9D008D84  00000000   NOP
81:                          if (disk_initialize(0)==STA_NOINIT){
9D008D88  0F401AC2   JAL disk_initialize
9D008D8C  00002021   ADDU A0, ZERO, ZERO
9D008D90  24030001   ADDIU V1, ZERO, 1
9D008D94  14430006   BNE V0, V1, 0x9D008DB0
9D008D98  24040001   ADDIU A0, ZERO, 1
82:                  #ifdef SD_DEBUG
83:                              UartPrint(STDOUT,"Echec d'initialisation de la carte SD\r");
9D008D9C  3C059D01   LUI A1, -25343
9D008DA0  0F4021F2   JAL UartPrint
9D008DA4  24A5A2D4   ADDIU A1, A1, -23852
84:                  #endif
85:                              return 0;
9D008DA8  0B40239D   J 0x9D008E74
9D008DAC  00001021   ADDU V0, ZERO, ZERO
86:                          };
87:                  #ifdef SD_DEBUG
88:                          UartPrint(STDOUT,"OK\r");
9D008DB0  3C059D01   LUI A1, -25343
9D008DB4  0F4021F2   JAL UartPrint
9D008DB8  24A5A2B4   ADDIU A1, A1, -23884
89:                  #endif
90:                  	// We're skipping the old step 3 because there's no need for malloc
91:                  	// This takes 6k off the code size if malloc is not used elsewhere.
92:                  	// Instead, just point it to our _Fat var.
93:                  	// The FATFS struct takes only 560 bytes of mem.
94:                  	Fat = &_Fat;
9D008DBC  3C02A000   LUI V0, -24576
9D008DC0  24424860   ADDIU V0, V0, 18528
9D008DC4  AF828080   SW V0, -32640(GP)
95:                  
96:                  	// Mount media
97:                  #ifdef SD_DEBUG
98:                  	UartPrint(STDOUT,"Mounting FAT filesystem... ");
9D008DC8  24040001   ADDIU A0, ZERO, 1
9D008DCC  3C059D01   LUI A1, -25343
9D008DD0  0F4021F2   JAL UartPrint
9D008DD4  24A5A2FC   ADDIU A1, A1, -23812
99:                  #endif
100:                 	r = f_mount(0, Fat);
9D008DD8  00002021   ADDU A0, ZERO, ZERO
9D008DDC  0F40063D   JAL f_mount
9D008DE0  8F858080   LW A1, -32640(GP)
101:                 	if (r != FR_OK) {
9D008DE4  10400007   BEQ V0, ZERO, 0x9D008E04
9D008DE8  24040001   ADDIU A0, ZERO, 1
102:                 		FError = r;
9D008DEC  A382807C   SB V0, -32644(GP)
103:                 #ifdef SD_DEBUG
104:                 		UartPrint(STDOUT,"Failed!\r");
9D008DF0  3C059D01   LUI A1, -25343
9D008DF4  0F4021F2   JAL UartPrint
9D008DF8  24A5A318   ADDIU A1, A1, -23784
105:                 #endif
106:                 		//free(Fat);
107:                 		return FALSE;
9D008DFC  0B40239D   J 0x9D008E74
9D008E00  00001021   ADDU V0, ZERO, ZERO
108:                 	}
109:                 #ifdef SD_DEBUG
110:                 	UartPrint(STDOUT, "OK\r");
9D008E04  3C059D01   LUI A1, -25343
9D008E08  0F4021F2   JAL UartPrint
9D008E0C  24A5A2B4   ADDIU A1, A1, -23884
111:                 #endif
112:                 
113:                 #ifdef SD_DEBUG
114:                 	UartPrint(STDOUT,"Checking FAT filesystem... ");
9D008E10  24040001   ADDIU A0, ZERO, 1
9D008E14  3C059D01   LUI A1, -25343
9D008E18  0F4021F2   JAL UartPrint
9D008E1C  24A5A324   ADDIU A1, A1, -23772
115:                 #endif
116:                 	const TCHAR * pth = "/";
9D008E20  3C029D01   LUI V0, -25343
9D008E24  2442A340   ADDIU V0, V0, -23744
9D008E28  AFA20010   SW V0, 16(SP)
117:                 	r = chk_mounted(&pth, &Fat, 0);
9D008E2C  27A40010   ADDIU A0, SP, 16
9D008E30  27858080   ADDIU A1, GP, -32640
9D008E34  0F40050B   JAL chk_mounted
9D008E38  00003021   ADDU A2, ZERO, ZERO
118:                 	if (r != FR_OK) {
9D008E3C  10400009   BEQ V0, ZERO, 0x9D008E64
9D008E40  24040001   ADDIU A0, ZERO, 1
119:                 		FError = r;
9D008E44  A382807C   SB V0, -32644(GP)
120:                 #ifdef SD_DEBUG
121:                 		UartPrint(STDOUT, "Failed!\r");
9D008E48  3C059D01   LUI A1, -25343
9D008E4C  0F4021F2   JAL UartPrint
9D008E50  24A5A318   ADDIU A1, A1, -23784
122:                                  //put_rc(r);
123:                 #endif
124:                 		unmount();
9D008E54  0F402336   JAL unmount
9D008E58  00000000   NOP
125:                 		return FALSE;
9D008E5C  0B40239D   J 0x9D008E74
9D008E60  00001021   ADDU V0, ZERO, ZERO
126:                 	}
127:                 #ifdef SD_DEBUG
128:                 	UartPrint(STDOUT, "OK\r");
9D008E64  3C059D01   LUI A1, -25343
9D008E68  0F4021F2   JAL UartPrint
9D008E6C  24A5A2B4   ADDIU A1, A1, -23884
129:                 #endif
130:                 
131:                 	return TRUE;
9D008E70  24020001   ADDIU V0, ZERO, 1
132:                 } // mount
9D008E74  8FBF001C   LW RA, 28(SP)
9D008E78  03E00008   JR RA
9D008E7C  27BD0020   ADDIU SP, SP, 32
133:                 
134:                 /*	----------------------------------------------------------------------------
135:                  unmount    initializes a MEDIA structure for FILEIO access
136:                  --------------------------------------------------------------------------*/
137:                 
138:                 void unmount(void) {
9D008CD8  27BDFFE8   ADDIU SP, SP, -24
9D008CDC  AFBF0014   SW RA, 20(SP)
139:                 	f_mount(0, NULL);
9D008CE0  00002021   ADDU A0, ZERO, ZERO
9D008CE4  0F40063D   JAL f_mount
9D008CE8  00002821   ADDU A1, ZERO, ZERO
140:                 	//free(Fat);
141:                 	SPI2CONCLR = 0x8000; // SPI2 OFF
9D008CEC  34038000   ORI V1, ZERO, -32768
9D008CF0  3C02BF80   LUI V0, -16512
9D008CF4  AC435A04   SW V1, 23044(V0)
142:                 } // unmount
9D008CF8  8FBF0014   LW RA, 20(SP)
9D008CFC  03E00008   JR RA
9D008D00  27BD0018   ADDIU SP, SP, 24
143:                 
144:                 /*	----------------------------------------------------------------------------
145:                  present   test if a SD card is present
146:                  --------------------------------------------------------------------------*/
147:                 
148:                 char SD_present(unsigned char pin) {
9D008E80  27BDFFE8   ADDIU SP, SP, -24
9D008E84  AFBF0014   SW RA, 20(SP)
149:                 	if (mount(pin)) {
9D008E88  0F402341   JAL mount
9D008E8C  308400FF   ANDI A0, A0, 255
9D008E90  10400004   BEQ V0, ZERO, 0x9D008EA4
9D008E94  00001821   ADDU V1, ZERO, ZERO
150:                 		unmount();
9D008E98  0F402336   JAL unmount
9D008E9C  00000000   NOP
151:                 		return TRUE;
9D008EA0  24030001   ADDIU V1, ZERO, 1
152:                 	} else {
153:                 		return FALSE;
154:                 	}
155:                 }
9D008EA4  00601021   ADDU V0, V1, ZERO
9D008EA8  8FBF0014   LW RA, 20(SP)
9D008EAC  03E00008   JR RA
9D008EB0  27BD0018   ADDIU SP, SP, 24
156:                 
157:                 /*	----------------------------------------------------------------------------
158:                  Scans the current disk and compiles a list of files with a given extension
159:                  list     array of file names max * 8
160:                  max      number of entries
161:                  ext      file extension we are searching for
162:                  return   number of files found
163:                  --------------------------------------------------------------------------*/
164:                 
165:                 //unsigned listTYPE(char *listname, long *listsize, int max, const char *ext )
166:                 unsigned listTYPE(DIRTABLE *list, int max, const char *ext)
167:                 //unsigned listTYPE(char *list, int max, const char *ext )
168:                 {
169:                 	//TODO: implement
170:                 
171:                 	return 0;
172:                 } // listTYPE
9D008EB4  03E00008   JR RA
9D008EB8  00001021   ADDU V0, ZERO, ZERO
173:                 
174:                 /* Prints the directory contents */
175:                 unsigned listDir(const char *path) {
9D008EBC  27BDFFC0   ADDIU SP, SP, -64
9D008EC0  AFBF003C   SW RA, 60(SP)
9D008EC4  AFB10038   SW S1, 56(SP)
9D008EC8  AFB00034   SW S0, 52(SP)
9D008ECC  00808021   ADDU S0, A0, ZERO
176:                 	//TODO: remove all CDC references
177:                 	long p1;
178:                 	PF_BYTE res, b;
179:                 	UINT s1, s2;
180:                 	DIR dir; /* Directory object */
181:                 
182:                 	res = f_opendir(&dir, "/");
9D008ED0  27A40010   ADDIU A0, SP, 16
9D008ED4  3C059D01   LUI A1, -25343
9D008ED8  0F4009BB   JAL f_opendir
9D008EDC  24A5A340   ADDIU A1, A1, -23744
183:                 #ifdef SD_DEBUG
184:                 	UartPrint(STDOUT,"f_opendir? ");
9D008EE0  24040001   ADDIU A0, ZERO, 1
9D008EE4  3C059D01   LUI A1, -25343
9D008EE8  0F4021F2   JAL UartPrint
9D008EEC  24A5A344   ADDIU A1, A1, -23740
185:                 	//put_rc(res);
186:                 #endif
187:                 	p1 = s1 = s2 = 0;
9D008F10  00008821   ADDU S1, ZERO, ZERO
188:                 	//CDCprintln("\nf_readdir('%s'): ", path);
189:                         print("\rnf_readdir('");
9D008EF0  3C049D01   LUI A0, -25343
9D008EF4  0F401DDD   JAL print
9D008EF8  2484A350   ADDIU A0, A0, -23728
190:                         print(path);
9D008EFC  0F401DDD   JAL print
9D008F00  02002021   ADDU A0, S0, ZERO
191:                         print("'):");
9D008F04  3C049D01   LUI A0, -25343
9D008F08  0F401DDD   JAL print
9D008F0C  2484A360   ADDIU A0, A0, -23712
192:                 	for (;;) {
193:                 		res = f_readdir(&dir, &Finfo);
9D008F14  3C10A000   LUI S0, -24576
9D008F18  26104848   ADDIU S0, S0, 18504
9D008F1C  27A40010   ADDIU A0, SP, 16
9D008F20  0F4009EC   JAL f_readdir
9D008F24  02002821   ADDU A1, S0, ZERO
194:                 #ifdef SD_DEBUG
195:                 //		put_rc(res);
196:                 #endif
197:                 		if ((res != FR_OK) || !Finfo.fname[0]) {
9D008F28  304200FF   ANDI V0, V0, 255
9D008F2C  14400009   BNE V0, ZERO, 0x9D008F54
9D008F30  02201021   ADDU V0, S1, ZERO
9D008F34  82020009   LB V0, 9(S0)
9D008F38  10400006   BEQ V0, ZERO, 0x9D008F54
9D008F3C  02201021   ADDU V0, S1, ZERO
198:                 			break;
199:                 		}
200:                 
201:                 		if (Finfo.fattrib & AM_DIR) {
9D008F40  92020008   LBU V0, 8(S0)
9D008F44  30420010   ANDI V0, V0, 16
202:                 			s2++;
203:                 		} else {
204:                 			s1++;
9D008F48  2C420001   SLTIU V0, V0, 1
9D008F4C  0B4023C7   J 0x9D008F1C
9D008F50  02228821   ADDU S1, S1, V0
205:                 			p1 += Finfo.fsize;
206:                 		}
207:                 /* what about other outputs ?
208:                 		UartPrint(STDOUT,"%c%c%c%c%c ",
209:                                 (Finfo.fattrib & AM_DIR) ? 'D' : '-',
210:                 				(Finfo.fattrib & AM_RDO) ? 'R' : '-',
211:                 				(Finfo.fattrib & AM_HID) ? 'H' : '-',
212:                 				(Finfo.fattrib & AM_SYS) ? 'S' : '-',
213:                 				(Finfo.fattrib & AM_ARC) ? 'A' : '-');
214:                 		UartPrint(STDOUT,"%u/%02u/%02u %02u:%02u ",
215:                                 (Finfo.fdate >> 9) + 1980,
216:                 				(Finfo.fdate >> 5) & 15, Finfo.fdate & 31, (Finfo.ftime >> 11),
217:                 				(Finfo.ftime >> 5) & 63);
218:                 		UartPrint(STDOUT," %9u ", Finfo.fsize);
219:                 		UartPrint(STDOUT, " %-12s %s", Finfo.fname,
220:                 #if _USE_LFN
221:                 				Lfname);
222:                 #else
223:                 				"");
224:                 #endif
225:                 */
226:                 	}
227:                 
228:                 	return s1;
229:                 } // listDir
9D008F54  8FBF003C   LW RA, 60(SP)
9D008F58  8FB10038   LW S1, 56(SP)
9D008F5C  8FB00034   LW S0, 52(SP)
9D008F60  03E00008   JR RA
9D008F64  27BD0040   ADDIU SP, SP, 64
230:                 
231:                 char isDirectory(FILINFO file) {
9D008F68  AFA40000   SW A0, 0(SP)
9D008F6C  AFA50004   SW A1, 4(SP)
9D008F70  AFA60008   SW A2, 8(SP)
9D008F74  AFA7000C   SW A3, 12(SP)
232:                 	if (file.fattrib & AM_DIR) {
233:                 		return TRUE;
234:                 	} else {
235:                 		return FALSE;
236:                 	}
237:                 }
9D008F78  03E00008   JR RA
9D008F7C  7CC20100   EXT V0, A2, 4, 1
238:                 
239:                 char isReadOnly(FILINFO file) {
9D008F80  AFA40000   SW A0, 0(SP)
9D008F84  AFA50004   SW A1, 4(SP)
9D008F88  AFA60008   SW A2, 8(SP)
9D008F8C  AFA7000C   SW A3, 12(SP)
240:                 	if (file.fattrib & AM_RDO) {
241:                 		return TRUE;
242:                 	} else {
243:                 		return FALSE;
244:                 	}
245:                 }
9D008F90  03E00008   JR RA
9D008F94  30C20001   ANDI V0, A2, 1
246:                 
247:                 char isHidden(FILINFO file) {
9D008F98  AFA40000   SW A0, 0(SP)
9D008F9C  AFA50004   SW A1, 4(SP)
9D008FA0  AFA60008   SW A2, 8(SP)
9D008FA4  AFA7000C   SW A3, 12(SP)
248:                 	if (file.fattrib & AM_HID) {
249:                 		return TRUE;
250:                 	} else {
251:                 		return FALSE;
252:                 	}
253:                 }
9D008FA8  03E00008   JR RA
9D008FAC  7CC20040   EXT V0, A2, 1, 1
254:                 
255:                 char isSystem(FILINFO file) {
9D008FB0  AFA40000   SW A0, 0(SP)
9D008FB4  AFA50004   SW A1, 4(SP)
9D008FB8  AFA60008   SW A2, 8(SP)
9D008FBC  AFA7000C   SW A3, 12(SP)
256:                 	if (file.fattrib & AM_SYS) {
257:                 		return TRUE;
258:                 	} else {
259:                 		return FALSE;
260:                 	}
261:                 }
9D008FC0  03E00008   JR RA
9D008FC4  7CC20080   EXT V0, A2, 2, 1
262:                 
263:                 char isArchive(FILINFO file) {
9D008FC8  AFA40000   SW A0, 0(SP)
9D008FCC  AFA50004   SW A1, 4(SP)
9D008FD0  AFA60008   SW A2, 8(SP)
9D008FD4  AFA7000C   SW A3, 12(SP)
264:                 	if (file.fattrib & AM_ARC) {
265:                 		return TRUE;
266:                 	} else {
267:                 		return FALSE;
268:                 	}
269:                 }
9D008FD8  03E00008   JR RA
9D008FDC  7CC20140   EXT V0, A2, 5, 1
270:                 #endif /* __FILEIO_C__ */
271:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/ff.c  ---------------------------------
1:                   /*----------------------------------------------------------------------------/
2:                    /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
3:                    /-----------------------------------------------------------------------------/
4:                    / FatFs module is a generic FAT file system module for small embedded systems.
5:                    / This is a free software that opened for education, research and commercial
6:                    / developments under license policy of following terms.
7:                    /
8:                    /  Copyright (C) 2011, ChaN, all right reserved.
9:                    /
10:                   / * The FatFs module is a free software and there is NO WARRANTY.
11:                   / * No restriction on use. You can use, modify and redistribute it for
12:                   /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
13:                   / * Redistributions of source code must retain the above copyright notice.
14:                   /
15:                   /-----------------------------------------------------------------------------/
16:                   / Feb 26,'06 R0.00  Prototype.
17:                   /
18:                   / Apr 29,'06 R0.01  First stable version.
19:                   /
20:                   / Jun 01,'06 R0.02  Added FAT12 support.
21:                   /                   Removed unbuffered mode.
22:                   /                   Fixed a problem on small (<32M) partition.
23:                   / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
24:                   /
25:                   / Sep 22,'06 R0.03  Added f_rename().
26:                   /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
27:                   / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
28:                   /                   Fixed f_mkdir() creates incorrect directory on FAT32.
29:                   /
30:                   / Feb 04,'07 R0.04  Supported multiple drive system.
31:                   /                   Changed some interfaces for multiple drive system.
32:                   /                   Changed f_mountdrv() to f_mount().
33:                   /                   Added f_mkfs().
34:                   / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
35:                   /                   Added a capability of extending file size to f_lseek().
36:                   /                   Added minimization level 3.
37:                   /                   Fixed an endian sensitive code in f_mkfs().
38:                   / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
39:                   /                   Added FSInfo support.
40:                   /                   Fixed DBCS name can result FR_INVALID_NAME.
41:                   /                   Fixed short seek (<= csize) collapses the file object.
42:                   /
43:                   / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
44:                   /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
45:                   /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
46:                   / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
47:                   /                   Fixed off by one error at FAT sub-type determination.
48:                   /                   Fixed btr in f_read() can be mistruncated.
49:                   /                   Fixed cached sector is not flushed when create and close without write.
50:                   /
51:                   / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
52:                   /                   Improved performance of f_lseek() on moving to the same or following cluster.
53:                   /
54:                   / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
55:                   /                   Added long file name feature.
56:                   /                   Added multiple code page feature.
57:                   /                   Added re-entrancy for multitask operation.
58:                   /                   Added auto cluster size selection to f_mkfs().
59:                   /                   Added rewind option to f_readdir().
60:                   /                   Changed result code of critical errors.
61:                   /                   Renamed string functions to avoid name collision.
62:                   / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
63:                   /                   Added multiple sector size feature.
64:                   / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
65:                   /                   Fixed wrong cache control in f_lseek().
66:                   /                   Added relative path feature.
67:                   /                   Added f_chdir() and f_chdrive().
68:                   /                   Added proper case conversion to extended char.
69:                   / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
70:                   /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
71:                   /                   Fixed name matching error on the 13 char boundary.
72:                   /                   Added a configuration option, _LFN_UNICODE.
73:                   /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
74:                   /
75:                   / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
76:                   /                   Added file lock feature. (_FS_SHARE)
77:                   /                   Added fast seek feature. (_USE_FASTSEEK)
78:                   /                   Changed some types on the API, XCHAR->TCHAR.
79:                   /                   Changed fname member in the FILINFO structure on Unicode cfg.
80:                   /                   String functions support UTF-8 encoding files on Unicode cfg.
81:                   / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
82:                   /                   Added sector erase feature. (_USE_ERASE)
83:                   /                   Moved file lock semaphore table from fs object to the bss.
84:                   /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
85:                   /                   Fixed f_mkfs() creates wrong FAT32 volume.
86:                   / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
87:                   /                   f_lseek() reports required table size on creating CLMP.
88:                   /                   Extended format syntax of f_printf function.
89:                   /                   Ignores duplicated directory separators in given path names.
90:                   /
91:                   / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
92:                   /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
93:                   /---------------------------------------------------------------------------
94:                   / 2011-12 Alfred Broda <alfredbroda@gmail.com> adapted for Pinguno Project
95:                   / BYTE and WORD were changed to PF_BYTE and PF_WORD because of a conflict.
96:                   ---------------------------------------------------------------------------*/
97:                  
98:                  #include "ff.h"			/* FatFs configurations and declarations */
99:                  #include "diskio.h"		/* Declarations of low level disk I/O functions */
100:                 
101:                 /*--------------------------------------------------------------------------
102:                 
103:                  Module Private Definitions
104:                 
105:                  ---------------------------------------------------------------------------*/
106:                 
107:                 #if _FATFS != 6502	/* Revision ID */
108:                 #error Wrong include file (ff.h).
109:                 #endif
110:                 
111:                 /* Definitions on sector size */
112:                 #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
113:                 #error Wrong sector size.
114:                 #endif
115:                 #if _MAX_SS != 512
116:                 #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
117:                 #else
118:                 #define	SS(fs)	512U			/* Fixed sector size */
119:                 #endif
120:                 
121:                 /* Reentrancy related */
122:                 #if _FS_REENTRANT
123:                 #if _USE_LFN == 1
124:                 #error Static LFN work area must not be used in re-entrant configuration.
125:                 #endif
126:                 #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
127:                 #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
128:                 #else
129:                 #define	ENTER_FF(fs)
130:                 #define LEAVE_FF(fs, res)	return res
131:                 #endif
132:                 
133:                 #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
134:                 
135:                 /* File shareing feature */
136:                 #if _FS_SHARE
137:                 #if _FS_READONLY
138:                 #error _FS_SHARE must be 0 on read-only cfg.
139:                 #endif
140:                 typedef struct {
141:                 	FATFS *fs; /* File ID 1, volume (NULL:blank entry) */
142:                 	DWORD clu; /* File ID 2, directory */
143:                 	PF_WORD idx; /* File ID 3, directory index */
144:                 	PF_WORD ctr; /* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
145:                 }FILESEM;
146:                 #endif
147:                 
148:                 /* Misc definitions */
149:                 #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
150:                 #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
151:                 
152:                 /* DBCS code ranges and SBCS extend char conversion table */
153:                 
154:                 #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
155:                 #define _DF1S	0x81	/* DBC 1st byte range 1 start */
156:                 #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
157:                 #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
158:                 #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
159:                 #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
160:                 #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
161:                 #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
162:                 #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
163:                 
164:                 #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
165:                 #define _DF1S	0x81
166:                 #define _DF1E	0xFE
167:                 #define _DS1S	0x40
168:                 #define _DS1E	0x7E
169:                 #define _DS2S	0x80
170:                 #define _DS2E	0xFE
171:                 
172:                 #elif _CODE_PAGE == 949	/* Korean */
173:                 #define _DF1S	0x81
174:                 #define _DF1E	0xFE
175:                 #define _DS1S	0x41
176:                 #define _DS1E	0x5A
177:                 #define _DS2S	0x61
178:                 #define _DS2E	0x7A
179:                 #define _DS3S	0x81
180:                 #define _DS3E	0xFE
181:                 
182:                 #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
183:                 #define _DF1S	0x81
184:                 #define _DF1E	0xFE
185:                 #define _DS1S	0x40
186:                 #define _DS1E	0x7E
187:                 #define _DS2S	0xA1
188:                 #define _DS2E	0xFE
189:                 
190:                 #elif _CODE_PAGE == 437	/* U.S. (OEM) */
191:                 #define _DF1S	0
192:                 #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
193:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
194:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
195:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
196:                 
197:                 #elif _CODE_PAGE == 720	/* Arabic (OEM) */
198:                 #define _DF1S	0
199:                 #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
200:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
201:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
202:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
203:                 
204:                 #elif _CODE_PAGE == 737	/* Greek (OEM) */
205:                 #define _DF1S	0
206:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
207:                 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
208:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
209:                 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
210:                 
211:                 #elif _CODE_PAGE == 775	/* Baltic (OEM) */
212:                 #define _DF1S	0
213:                 #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
214:                 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
215:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
216:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
217:                 
218:                 #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
219:                 #define _DF1S	0
220:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
221:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
222:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
223:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
224:                 
225:                 #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
226:                 #define _DF1S	0
227:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
228:                 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
229:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
230:                 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
231:                 
232:                 #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
233:                 #define _DF1S	0
234:                 #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
235:                 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
236:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
237:                 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
238:                 
239:                 #elif _CODE_PAGE == 857	/* Turkish (OEM) */
240:                 #define _DF1S	0
241:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
242:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
243:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
244:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
245:                 
246:                 #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
247:                 #define _DF1S	0
248:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
249:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
250:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
251:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
252:                 
253:                 #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
254:                 #define _DF1S	0
255:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
256:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
257:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
258:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
259:                 
260:                 #elif _CODE_PAGE == 866	/* Russian (OEM) */
261:                 #define _DF1S	0
262:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
263:                 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
264:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
265:                 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
266:                 
267:                 #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
268:                 #define _DF1S	0
269:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
270:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
271:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
272:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
273:                 
274:                 #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
275:                 #define _DF1S	0
276:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
277:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
278:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
279:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
280:                 
281:                 #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
282:                 #define _DF1S	0
283:                 #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
284:                 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
285:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
286:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
287:                 
288:                 #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
289:                 #define _DF1S	0
290:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
291:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
292:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
293:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
294:                 
295:                 #elif _CODE_PAGE == 1253 /* Greek (Windows) */
296:                 #define _DF1S	0
297:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
298:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
299:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
300:                 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
301:                 
302:                 #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
303:                 #define _DF1S	0
304:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
305:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
306:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
307:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
308:                 
309:                 #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
310:                 #define _DF1S	0
311:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
312:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
313:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
314:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
315:                 
316:                 #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
317:                 #define _DF1S	0
318:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
319:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
320:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
321:                 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
322:                 
323:                 #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
324:                 #define _DF1S	0
325:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
326:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
327:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
328:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
329:                 
330:                 #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
331:                 #define _DF1S	0
332:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
333:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
334:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
335:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
336:                 
337:                 #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
338:                 #if _USE_LFN
339:                 #error Cannot use LFN feature without valid code page.
340:                 #endif
341:                 #define _DF1S	0
342:                 
343:                 #else
344:                 #error Unknown code page
345:                 
346:                 #endif
347:                 
348:                 /* Character code support macros */
349:                 #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
350:                 #define IsLower(c)	(((c)>='a')&&((c)<='z'))
351:                 #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
352:                 
353:                 #if _DF1S		/* Code page is DBCS */
354:                 
355:                 #ifdef _DF2S	/* Two 1st byte areas */
356:                 #define IsDBCS1(c)	(((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E) || ((PF_BYTE)(c) >= _DF2S && (PF_BYTE)(c) <= _DF2E))
357:                 #else			/* One 1st byte area */
358:                 #define IsDBCS1(c)	((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E)
359:                 #endif
360:                 
361:                 #ifdef _DS3S	/* Three 2nd byte areas */
362:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E) || ((PF_BYTE)(c) >= _DS3S && (PF_BYTE)(c) <= _DS3E))
363:                 #else			/* Two 2nd byte areas */
364:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E))
365:                 #endif
366:                 
367:                 #else			/* Code page is SBCS */
368:                 
369:                 #define IsDBCS1(c)	0
370:                 #define IsDBCS2(c)	0
371:                 
372:                 #endif /* _DF1S */
373:                 
374:                 /* Name status flags */
375:                 #define NS			11		/* Index of name status byte in fn[] */
376:                 #define NS_LOSS		0x01	/* Out of 8.3 format */
377:                 #define NS_LFN		0x02	/* Force to create LFN entry */
378:                 #define NS_LAST		0x04	/* Last segment */
379:                 #define NS_BODY		0x08	/* Lower case flag (body) */
380:                 #define NS_EXT		0x10	/* Lower case flag (ext) */
381:                 #define NS_DOT		0x20	/* Dot entry */
382:                 
383:                 /* FAT sub-type boundaries */
384:                 /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
385:                 #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
386:                 #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
387:                 
388:                 /* FatFs refers the members in the FAT structures as byte array instead of
389:                  / structure member because the structure is not binary compatible between
390:                  / different platforms */
391:                 
392:                 #define BS_jmpBoot			0	/* Jump instruction (3) */
393:                 #define BS_OEMName			3	/* OEM name (8) */
394:                 #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
395:                 #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
396:                 #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
397:                 #define BPB_NumFATs			16	/* Number of FAT copies (1) */
398:                 #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
399:                 #define BPB_TotSec16		19	/* Volume size [sector] (2) */
400:                 #define BPB_Media			21	/* Media descriptor (1) */
401:                 #define BPB_FATSz16			22	/* FAT size [sector] (2) */
402:                 #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
403:                 #define BPB_NumHeads		26	/* Number of heads (2) */
404:                 #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
405:                 #define BPB_TotSec32		32	/* Volume size [sector] (4) */
406:                 #define BS_DrvNum			36	/* Physical drive number (2) */
407:                 #define BS_BootSig			38	/* Extended boot signature (1) */
408:                 #define BS_VolID			39	/* Volume serial number (4) */
409:                 #define BS_VolLab			43	/* Volume label (8) */
410:                 #define BS_FilSysType		54	/* File system type (1) */
411:                 #define BPB_FATSz32			36	/* FAT size [sector] (4) */
412:                 #define BPB_ExtFlags		40	/* Extended flags (2) */
413:                 #define BPB_FSVer			42	/* File system version (2) */
414:                 #define BPB_RootClus		44	/* Root dir first cluster (4) */
415:                 #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
416:                 #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
417:                 #define BS_DrvNum32			64	/* Physical drive number (2) */
418:                 #define BS_BootSig32		66	/* Extended boot signature (1) */
419:                 #define BS_VolID32			67	/* Volume serial number (4) */
420:                 #define BS_VolLab32			71	/* Volume label (8) */
421:                 #define BS_FilSysType32		82	/* File system type (1) */
422:                 #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
423:                 #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
424:                 #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
425:                 #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
426:                 #define MBR_Table			446	/* MBR: Partition table offset (2) */
427:                 #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
428:                 #define BS_55AA				510	/* Boot sector signature (2) */
429:                 
430:                 #define	DIR_Name			0	/* Short file name (11) */
431:                 #define	DIR_Attr			11	/* Attribute (1) */
432:                 #define	DIR_NTres			12	/* NT flag (1) */
433:                 #define	DIR_CrtTime			14	/* Created time (2) */
434:                 #define	DIR_CrtDate			16	/* Created date (2) */
435:                 #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
436:                 #define	DIR_WrtTime			22	/* Modified time (2) */
437:                 #define	DIR_WrtDate			24	/* Modified date (2) */
438:                 #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
439:                 #define	DIR_FileSize		28	/* File size (4) */
440:                 #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
441:                 #define	LDIR_Attr			11	/* LFN attribute (1) */
442:                 #define	LDIR_Type			12	/* LFN type (1) */
443:                 #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
444:                 #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
445:                 #define	SZ_DIR				32		/* Size of a directory entry */
446:                 #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
447:                 #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
448:                 #define	NDDE				0x05	/* Replacement of a character collides with DDE */
449:                 
450:                 /*------------------------------------------------------------*/
451:                 /* Module private work area                                   */
452:                 /*------------------------------------------------------------*/
453:                 /* Note that uninitialized variables with static duration are
454:                  /  zeroed/nulled at start-up. If not, the compiler or start-up
455:                  /  routine is out of ANSI-C standard.
456:                  */
457:                 
458:                 #if _VOLUMES
459:                 static FATFS *FatFs[_VOLUMES]; /* Pointer to the file system objects (logical drives) */
460:                 #else
461:                 #error Number of volumes must not be 0.
462:                 #endif
463:                 
464:                 static PF_WORD Fsid; /* File system mount ID */
465:                 
466:                 #if _FS_RPATH
467:                 static
468:                 PF_BYTE CurrVol; /* Current drive */
469:                 #endif
470:                 
471:                 #if _FS_SHARE
472:                 static
473:                 FILESEM Files[_FS_SHARE]; /* File lock semaphores */
474:                 #endif
475:                 
476:                 #if _USE_LFN == 0			/* No LFN feature */
477:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
478:                 #define INIT_BUF(dobj)		(dobj).fn = sfn
479:                 #define	FREE_BUF()
480:                 
481:                 #elif _USE_LFN == 1			/* LFN feature with static working buffer */
482:                 static WCHAR LfnBuf[_MAX_LFN+1];
483:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
484:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
485:                 #define	FREE_BUF()
486:                 
487:                 #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
488:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
489:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
490:                 #define	FREE_BUF()
491:                 
492:                 #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
493:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR *lfn
494:                 #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
495:                 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
496:                 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
497:                 #define	FREE_BUF()			ff_memfree(lfn)
498:                 
499:                 #else
500:                 #error Wrong LFN configuration.
501:                 #endif
502:                 
503:                 /*--------------------------------------------------------------------------
504:                 
505:                  Module Private Functions
506:                 
507:                  ---------------------------------------------------------------------------*/
508:                 
509:                 /*-----------------------------------------------------------------------*/
510:                 /* String functions                                                      */
511:                 /*-----------------------------------------------------------------------*/
512:                 
513:                 /* Copy memory to memory */
514:                 static
515:                 void mem_cpy(void* dst, const void* src, UINT cnt) {
9D000028  00862021   ADDU A0, A0, A2
516:                 	PF_BYTE *d = (PF_BYTE*) dst;
517:                 	const PF_BYTE *s = (const PF_BYTE*) src;
518:                 
519:                 #if _WORD_ACCESS == 1
520:                 	while (cnt >= sizeof(int)) {
521:                 		*(int*) d = *(int*) s;
522:                 		d += sizeof(int);
523:                 		s += sizeof(int);
524:                 		cnt -= sizeof(int);
525:                 	}
526:                 #endif
527:                 	while (cnt--)
9D000020  10C00007   BEQ A2, ZERO, 0x9D000040
9D000024  00801021   ADDU V0, A0, ZERO
9D000038  1444FFFC   BNE V0, A0, 0x9D00002C
9D00003C  24A50001   ADDIU A1, A1, 1
9D000040  03E00008   JR RA
9D000044  00000000   NOP
528:                 		*d++ = *s++;
9D00002C  90A30000   LBU V1, 0(A1)
9D000030  A0430000   SB V1, 0(V0)
9D000034  24420001   ADDIU V0, V0, 1
529:                 }
530:                 
531:                 /* Fill memory */
532:                 static
533:                 void mem_set(void* dst, int val, UINT cnt) {
9D000050  00862021   ADDU A0, A0, A2
534:                 	PF_BYTE *d = (PF_BYTE*) dst;
535:                 
536:                 	while (cnt--)
9D000048  10C00006   BEQ A2, ZERO, 0x9D000064
9D00004C  00801021   ADDU V0, A0, ZERO
9D00005C  5444FFFE   BNEL V0, A0, 0x9D000058
9D000060  A0450000   SB A1, 0(V0)
9D000064  03E00008   JR RA
9D000068  00000000   NOP
537:                 		*d++ = (PF_BYTE) val;
9D000054  A0450000   SB A1, 0(V0)
9D000058  24420001   ADDIU V0, V0, 1
538:                 }
539:                 
540:                 /* Compare memory to memory */
541:                 static
542:                 int mem_cmp(const void* dst, const void* src, UINT cnt) {
543:                 	const PF_BYTE *d = (const PF_BYTE *) dst, *s = (const PF_BYTE *) src;
9D0010C0  01402021   ADDU A0, T2, ZERO
544:                 	int r = 0;
545:                 
546:                 	while (cnt-- && (r = *d++ - *s++) == 0)
9D0010CC  50680037   BEQL V1, T0, 0x9D0011AC
9D0010D0  9143000B   LBU V1, 11(T2)
9D0010D4  90660000   LBU A2, 0(V1)
9D0010D8  90850000   LBU A1, 0(A0)
9D0010DC  24630001   ADDIU V1, V1, 1
9D0010E0  10C5FFFA   BEQ A2, A1, 0x9D0010CC
9D0010E4  24840001   ADDIU A0, A0, 1
547:                 		;
548:                 	return r;
549:                 }
550:                 
551:                 /* Check if chr is contained in the string */
552:                 static
553:                 int chk_chr(const char* str, int chr) {
554:                 	while (*str && *str != chr)
9D000E8C  24160022   ADDIU S6, ZERO, 34
9D000E90  3C179D01   LUI S7, -25343
9D000FA4  10560071   BEQ V0, S6, 0x9D00116C
9D000FA8  00405021   ADDU T2, V0, ZERO
9D000FAC  26E5AD90   ADDIU A1, S7, -21104
9D000FB4  80A70000   LB A3, 0(A1)
9D000FB8  50E00005   BEQL A3, ZERO, 0x9D000FD0
9D000FBC  2445FFBF   ADDIU A1, V0, -65
9D000FC0  5547FFFC   BNEL T2, A3, 0x9D000FB4
9D000FC4  24A50001   ADDIU A1, A1, 1
9D000FC8  0B40045E   J 0x9D001178
9D000FCC  24020006   ADDIU V0, ZERO, 6
9D00116C  0B40045E   J 0x9D001178
9D001170  24020006   ADDIU V0, ZERO, 6
9D001174  24020006   ADDIU V0, ZERO, 6
555:                 		str++;
9D000FB0  24A50001   ADDIU A1, A1, 1
556:                 	return *str;
557:                 }
558:                 
559:                 /*-----------------------------------------------------------------------*/
560:                 /* Request/Release grant to access the volume                            */
561:                 /*-----------------------------------------------------------------------*/
562:                 #if _FS_REENTRANT
563:                 
564:                 static
565:                 int lock_fs (
566:                 		FATFS *fs /* File system object */
567:                 )
568:                 {
569:                 	return ff_req_grant(fs->sobj);
570:                 }
571:                 
572:                 static
573:                 void unlock_fs (
574:                 		FATFS *fs, /* File system object */
575:                 		FRESULT res /* Result code to be returned */
576:                 )
577:                 {
578:                 	if (res != FR_NOT_ENABLED &&
579:                 			res != FR_INVALID_DRIVE &&
580:                 			res != FR_INVALID_OBJECT &&
581:                 			res != FR_TIMEOUT) {
582:                 		ff_rel_grant(fs->sobj);
583:                 	}
584:                 }
585:                 #endif
586:                 
587:                 /*-----------------------------------------------------------------------*/
588:                 /* File shareing control functions                                       */
589:                 /*-----------------------------------------------------------------------*/
590:                 #if _FS_SHARE
591:                 
592:                 static
593:                 FRESULT chk_lock ( /* Check if the file can be accessed */
594:                 		DIR* dj, /* Directory object pointing the file to be checked */
595:                 		int acc /* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
596:                 )
597:                 {
598:                 	UINT i, be;
599:                 
600:                 	/* Search file semaphore table */
601:                 	for (i = be = 0; i < _FS_SHARE; i++) {
602:                 		if (Files[i].fs) { /* Existing entry */
603:                 			if (Files[i].fs == dj->fs && /* Check if the file matched with an open file */
604:                 					Files[i].clu == dj->sclust &&
605:                 					Files[i].idx == dj->index) break;
606:                 		} else { /* Blank entry */
607:                 			be++;
608:                 		}
609:                 	}
610:                 	if (i == _FS_SHARE) /* The file is not opened */
611:                 	return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES; /* Is there a blank entry for new file? */
612:                 
613:                 	/* The file has been opened. Reject any open against writing file and all write mode open */
614:                 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
615:                 }
616:                 
617:                 static
618:                 int enq_lock (void) /* Check if an entry is available for a new file */
619:                 {
620:                 	UINT i;
621:                 
622:                 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
623:                 	return (i == _FS_SHARE) ? 0 : 1;
624:                 }
625:                 
626:                 static
627:                 UINT inc_lock ( /* Increment file open counter and returns its index (0:int error) */
628:                 		DIR* dj, /* Directory object pointing the file to register or increment */
629:                 		int acc /* Desired access mode (0:Read, !0:Write) */
630:                 )
631:                 {
632:                 	UINT i;
633:                 
634:                 	for (i = 0; i < _FS_SHARE; i++) { /* Find the file */
635:                 		if (Files[i].fs == dj->fs &&
636:                 				Files[i].clu == dj->sclust &&
637:                 				Files[i].idx == dj->index) break;
638:                 	}
639:                 
640:                 	if (i == _FS_SHARE) { /* Not opened. Register it as new. */
641:                 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
642:                 		if (i == _FS_SHARE) return 0; /* No space to register (int err) */
643:                 		Files[i].fs = dj->fs;
644:                 		Files[i].clu = dj->sclust;
645:                 		Files[i].idx = dj->index;
646:                 		Files[i].ctr = 0;
647:                 	}
648:                 
649:                 	if (acc && Files[i].ctr) return 0; /* Access violation (int err) */
650:                 
651:                 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1; /* Set semaphore value */
652:                 
653:                 	return i + 1;
654:                 }
655:                 
656:                 static
657:                 FRESULT dec_lock ( /* Decrement file open counter */
658:                 		UINT i /* Semaphore index */
659:                 )
660:                 {
661:                 	PF_WORD n;
662:                 	FRESULT res;
663:                 
664:                 	if (--i < _FS_SHARE) {
665:                 		n = Files[i].ctr;
666:                 		if (n == 0x100) n = 0;
667:                 		if (n) n--;
668:                 		Files[i].ctr = n;
669:                 		if (!n) Files[i].fs = 0;
670:                 		res = FR_OK;
671:                 	} else {
672:                 		res = FR_INT_ERR;
673:                 	}
674:                 	return res;
675:                 }
676:                 
677:                 static
678:                 void clear_lock ( /* Clear lock entries of the volume */
679:                 		FATFS *fs
680:                 )
681:                 {
682:                 	UINT i;
683:                 
684:                 	for (i = 0; i < _FS_SHARE; i++) {
685:                 		if (Files[i].fs == fs) Files[i].fs = 0;
686:                 	}
687:                 }
688:                 #endif
689:                 
690:                 /*-----------------------------------------------------------------------*/
691:                 /* Change window offset                                                  */
692:                 /*-----------------------------------------------------------------------*/
693:                 
694:                 static FRESULT move_window(FATFS *fs, /* File system object */
695:                 DWORD sector /* Sector number to make appearance in the fs->win[] */
696:                 ) /* Move to zero only writes back dirty window */
697:                 {
9D000208  27BDFFD8   ADDIU SP, SP, -40
9D00020C  AFBF0024   SW RA, 36(SP)
9D000210  AFB40020   SW S4, 32(SP)
9D000214  AFB3001C   SW S3, 28(SP)
9D000218  AFB20018   SW S2, 24(SP)
9D00021C  AFB10014   SW S1, 20(SP)
9D000220  AFB00010   SW S0, 16(SP)
9D000224  00808021   ADDU S0, A0, ZERO
9D000228  00A09021   ADDU S2, A1, ZERO
698:                 	DWORD wsect;
699:                 
700:                 	wsect = fs->winsect;
9D00022C  8C91002C   LW S1, 44(A0)
701:                 	if (wsect != sector) { /* Changed current window */
9D000230  1225002D   BEQ S1, A1, 0x9D0002E8
9D000234  00001821   ADDU V1, ZERO, ZERO
702:                 #if !_FS_READONLY
703:                 		if (fs->wflag) { /* Write back dirty window if needed */
9D000238  90820004   LBU V0, 4(A0)
9D00023C  1040001F   BEQ V0, ZERO, 0x9D0002BC
9D000240  02203021   ADDU A2, S1, ZERO
704:                 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
9D000244  24940030   ADDIU S4, A0, 48
9D000248  90840001   LBU A0, 1(A0)
9D00024C  02802821   ADDU A1, S4, ZERO
9D000250  0F401B90   JAL disk_write
9D000254  24070001   ADDIU A3, ZERO, 1
9D000258  14400023   BNE V0, ZERO, 0x9D0002E8
9D00025C  24030001   ADDIU V1, ZERO, 1
705:                 				return FR_DISK_ERR;
706:                 			fs->wflag = 0;
9D000260  A2000004   SB ZERO, 4(S0)
707:                 			if (wsect < (fs->fatbase + fs->fsize)) { /* In FAT area */
9D000264  8E03001C   LW V1, 28(S0)
9D000268  8E020020   LW V0, 32(S0)
9D00026C  00621021   ADDU V0, V1, V0
9D000270  0222102B   SLTU V0, S1, V0
9D000274  10400011   BEQ V0, ZERO, 0x9D0002BC
9D000278  00000000   NOP
708:                 				PF_BYTE nf;
709:                 				for (nf = fs->n_fats; nf > 1; nf--) { /* Reflect the change to all FAT copies */
9D00027C  92130003   LBU S3, 3(S0)
9D000280  2E620002   SLTIU V0, S3, 2
9D000284  1440000D   BNE V0, ZERO, 0x9D0002BC
9D000288  00000000   NOP
9D0002A8  2673FFFF   ADDIU S3, S3, -1
9D0002AC  327300FF   ANDI S3, S3, 255
9D0002B0  24020001   ADDIU V0, ZERO, 1
9D0002B4  5662FFF6   BNEL S3, V0, 0x9D000290
9D0002B8  8E02001C   LW V0, 28(S0)
710:                 					wsect += fs->fsize;
9D00028C  8E02001C   LW V0, 28(S0)
9D000290  02228821   ADDU S1, S1, V0
711:                 					disk_write(fs->drv, fs->win, wsect, 1);
9D000294  92040001   LBU A0, 1(S0)
9D000298  02802821   ADDU A1, S4, ZERO
9D00029C  02203021   ADDU A2, S1, ZERO
9D0002A0  0F401B90   JAL disk_write
9D0002A4  24070001   ADDIU A3, ZERO, 1
712:                 				}
713:                 			}
714:                 		}
715:                 #endif
716:                 		if (sector) {
9D0002BC  1240000A   BEQ S2, ZERO, 0x9D0002E8
9D0002C0  00001821   ADDU V1, ZERO, ZERO
717:                 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
9D0002C4  92040001   LBU A0, 1(S0)
9D0002C8  26050030   ADDIU A1, S0, 48
9D0002CC  02403021   ADDU A2, S2, ZERO
9D0002D0  0F401B5A   JAL disk_read
9D0002D4  24070001   ADDIU A3, ZERO, 1
9D0002D8  14400003   BNE V0, ZERO, 0x9D0002E8
9D0002DC  24030001   ADDIU V1, ZERO, 1
718:                 				return FR_DISK_ERR;
719:                 			fs->winsect = sector;
9D0002E0  AE12002C   SW S2, 44(S0)
720:                 		}
721:                 	}
722:                 
723:                 	return FR_OK;
9D0002E4  00001821   ADDU V1, ZERO, ZERO
724:                 }
9D0002E8  00601021   ADDU V0, V1, ZERO
9D0002EC  8FBF0024   LW RA, 36(SP)
9D0002F0  8FB40020   LW S4, 32(SP)
9D0002F4  8FB3001C   LW S3, 28(SP)
9D0002F8  8FB20018   LW S2, 24(SP)
9D0002FC  8FB10014   LW S1, 20(SP)
9D000300  8FB00010   LW S0, 16(SP)
9D000304  03E00008   JR RA
9D000308  27BD0028   ADDIU SP, SP, 40
725:                 
726:                 /*-----------------------------------------------------------------------*/
727:                 /* Clean-up cached data                                                  */
728:                 /*-----------------------------------------------------------------------*/
729:                 #if !_FS_READONLY
730:                 static FRESULT sync( /* FR_OK: successful, FR_DISK_ERR: failed */
731:                 FATFS *fs /* File system object */
732:                 ) {
9D0003E4  27BDFFE0   ADDIU SP, SP, -32
9D0003E8  AFBF001C   SW RA, 28(SP)
9D0003EC  AFB20018   SW S2, 24(SP)
9D0003F0  AFB10014   SW S1, 20(SP)
9D0003F4  AFB00010   SW S0, 16(SP)
9D0003F8  00808821   ADDU S1, A0, ZERO
733:                 	FRESULT res;
734:                 
735:                 	res = move_window(fs, 0);
9D0003FC  0F400082   JAL 0x9D000208
9D000400  00002821   ADDU A1, ZERO, ZERO
736:                 	if (res == FR_OK) {
9D000404  1440003A   BNE V0, ZERO, 0x9D0004F0
9D000408  00408021   ADDU S0, V0, ZERO
737:                 		/* Update FSInfo sector if needed */
738:                 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
9D00040C  92230000   LBU V1, 0(S1)
9D000410  24020003   ADDIU V0, ZERO, 3
9D000414  54620031   BNEL V1, V0, 0x9D0004DC
9D000418  92240001   LBU A0, 1(S1)
9D00041C  92220005   LBU V0, 5(S1)
9D000420  5040002E   BEQL V0, ZERO, 0x9D0004DC
9D000424  92240001   LBU A0, 1(S1)
739:                 			fs->winsect = 0;
9D000428  AE20002C   SW ZERO, 44(S1)
740:                 			/* Create FSInfo structure */
741:                 			mem_set(fs->win, 0, 512);
9D00042C  26320030   ADDIU S2, S1, 48
9D000430  02402021   ADDU A0, S2, ZERO
9D000434  00002821   ADDU A1, ZERO, ZERO
9D000438  0F400012   JAL 0x9D000048
9D00043C  24060200   ADDIU A2, ZERO, 512
742:                 			ST_WORD(fs->win+BS_55AA, 0xAA55);
9D000440  24020055   ADDIU V0, ZERO, 85
9D000444  A222022E   SB V0, 558(S1)
9D000448  2402FFAA   ADDIU V0, ZERO, -86
9D00044C  A222022F   SB V0, 559(S1)
743:                 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
9D000450  24020052   ADDIU V0, ZERO, 82
9D000454  A2220030   SB V0, 48(S1)
9D000458  A2220031   SB V0, 49(S1)
9D00045C  24020061   ADDIU V0, ZERO, 97
9D000460  A2220032   SB V0, 50(S1)
9D000464  24030041   ADDIU V1, ZERO, 65
9D000468  A2230033   SB V1, 51(S1)
744:                 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
9D00046C  24040072   ADDIU A0, ZERO, 114
9D000470  A2240214   SB A0, 532(S1)
9D000474  A2240215   SB A0, 533(S1)
9D000478  A2230216   SB V1, 534(S1)
9D00047C  A2220217   SB V0, 535(S1)
745:                 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
9D000480  8E220010   LW V0, 16(S1)
9D000484  A2220218   SB V0, 536(S1)
9D000488  7C433A00   EXT V1, V0, 8, 8
9D00048C  A2230219   SB V1, 537(S1)
9D000490  00021C02   SRL V1, V0, 16
9D000494  A223021A   SB V1, 538(S1)
9D000498  00021602   SRL V0, V0, 24
9D00049C  A222021B   SB V0, 539(S1)
746:                 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
9D0004A0  8E22000C   LW V0, 12(S1)
9D0004A4  A222021C   SB V0, 540(S1)
9D0004A8  7C433A00   EXT V1, V0, 8, 8
9D0004AC  A223021D   SB V1, 541(S1)
9D0004B0  00021C02   SRL V1, V0, 16
9D0004B4  A223021E   SB V1, 542(S1)
9D0004B8  00021602   SRL V0, V0, 24
9D0004BC  A222021F   SB V0, 543(S1)
747:                 			/* Write it into the FSInfo sector */
748:                 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
9D0004C0  92240001   LBU A0, 1(S1)
9D0004C4  02402821   ADDU A1, S2, ZERO
9D0004C8  8E260014   LW A2, 20(S1)
9D0004CC  0F401B90   JAL disk_write
9D0004D0  24070001   ADDIU A3, ZERO, 1
749:                 			fs->fsi_flag = 0;
9D0004D4  A2200005   SB ZERO, 5(S1)
750:                 		}
751:                 		/* Make sure that no pending write process in the physical drive */
752:                 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
9D0004D8  92240001   LBU A0, 1(S1)
9D0004DC  00002821   ADDU A1, ZERO, ZERO
9D0004E0  0F401BD5   JAL disk_ioctl
9D0004E4  00003021   ADDU A2, ZERO, ZERO
753:                 			res = FR_DISK_ERR;
9D0004E8  24030001   ADDIU V1, ZERO, 1
9D0004EC  0062800B   MOVN S0, V1, V0
754:                 	}
755:                 
756:                 	return res;
757:                 }
9D0004F0  02001021   ADDU V0, S0, ZERO
9D0004F4  8FBF001C   LW RA, 28(SP)
9D0004F8  8FB20018   LW S2, 24(SP)
9D0004FC  8FB10014   LW S1, 20(SP)
9D000500  8FB00010   LW S0, 16(SP)
9D000504  03E00008   JR RA
9D000508  27BD0020   ADDIU SP, SP, 32
758:                 #endif
759:                 
760:                 /*-----------------------------------------------------------------------*/
761:                 /* Get sector# from cluster#                                             */
762:                 /*-----------------------------------------------------------------------*/
763:                 
764:                 DWORD clust2sect( /* !=0: Sector number, 0: Failed - invalid cluster# */
765:                 FATFS *fs, /* File system object */
766:                 DWORD clst /* Cluster# to be converted */
767:                 ) {
768:                 	clst -= 2;
9D000558  24A5FFFE   ADDIU A1, A1, -2
769:                 	if (clst >= (fs->n_fatent - 2))
9D00055C  8C830018   LW V1, 24(A0)
9D000560  2463FFFE   ADDIU V1, V1, -2
9D000564  00A3182B   SLTU V1, A1, V1
9D000568  10600005   BEQ V1, ZERO, 0x9D000580
9D00056C  00001021   ADDU V0, ZERO, ZERO
770:                 		return 0; /* Invalid cluster# */
771:                 	return clst * fs->csize + fs->database;
9D000570  90820002   LBU V0, 2(A0)
9D000574  8C830028   LW V1, 40(A0)
9D000578  70A22002   MUL A0, A1, V0
9D00057C  00831021   ADDU V0, A0, V1
772:                 }
9D000580  03E00008   JR RA
9D000584  00000000   NOP
773:                 
774:                 /*-----------------------------------------------------------------------*/
775:                 /* FAT access - Read value of a FAT entry                                */
776:                 /*-----------------------------------------------------------------------*/
777:                 
778:                 DWORD get_fat( /* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
779:                 FATFS *fs, /* File system object */
780:                 DWORD clst /* Cluster# to get the link information */
781:                 ) {
9D000588  27BDFFD8   ADDIU SP, SP, -40
9D00058C  AFBF0024   SW RA, 36(SP)
9D000590  AFB30020   SW S3, 32(SP)
9D000594  AFB2001C   SW S2, 28(SP)
9D000598  AFB10018   SW S1, 24(SP)
9D00059C  AFB00014   SW S0, 20(SP)
9D0005A0  00808021   ADDU S0, A0, ZERO
9D0005A4  00A08821   ADDU S1, A1, ZERO
782:                 	UINT wc, bc;
783:                 	PF_BYTE *p;
784:                 
785:                 	if (clst < 2 || clst >= fs->n_fatent) /* Chack range */
9D0005A8  2CA20002   SLTIU V0, A1, 2
9D0005AC  1440004F   BNE V0, ZERO, 0x9D0006EC
9D0005B0  24030001   ADDIU V1, ZERO, 1
9D0005B4  8C820018   LW V0, 24(A0)
9D0005B8  00A2102B   SLTU V0, A1, V0
9D0005BC  1040004C   BEQ V0, ZERO, 0x9D0006F0
9D0005C0  00601021   ADDU V0, V1, ZERO
786:                 		return 1;
787:                 
788:                 	switch (fs->fs_type) {
9D0005C4  90820000   LBU V0, 0(A0)
9D0005C8  24030002   ADDIU V1, ZERO, 2
9D0005CC  50430025   BEQL V0, V1, 0x9D000664
9D0005D0  00052A02   SRL A1, A1, 8
9D0005D4  24030003   ADDIU V1, ZERO, 3
9D0005D8  5043002F   BEQL V0, V1, 0x9D000698
9D0005DC  000529C2   SRL A1, A1, 7
9D0005E0  24030001   ADDIU V1, ZERO, 1
9D0005E4  54430041   BNEL V0, V1, 0x9D0006EC
9D0005E8  2403FFFF   ADDIU V1, ZERO, -1
789:                 	case FS_FAT12:
790:                 		bc = (UINT) clst;
791:                 		bc += bc / 2;
9D0005EC  00059042   SRL S2, A1, 1
9D0005F0  02459021   ADDU S2, S2, A1
792:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D0005F4  00122A42   SRL A1, S2, 9
9D0005F8  8C820020   LW V0, 32(A0)
9D0005FC  0F400082   JAL 0x9D000208
9D000600  00A22821   ADDU A1, A1, V0
9D000604  14400039   BNE V0, ZERO, 0x9D0006EC
9D000608  2403FFFF   ADDIU V1, ZERO, -1
793:                 			break;
794:                 		wc = fs->win[bc % SS(fs)];
9D00060C  324201FF   ANDI V0, S2, 511
9D000610  02021021   ADDU V0, S0, V0
9D000614  90530030   LBU S3, 48(V0)
795:                 		bc++;
9D000618  26520001   ADDIU S2, S2, 1
796:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D00061C  00122A42   SRL A1, S2, 9
9D000620  8E020020   LW V0, 32(S0)
9D000624  02002021   ADDU A0, S0, ZERO
9D000628  0F400082   JAL 0x9D000208
9D00062C  00A22821   ADDU A1, A1, V0
9D000630  1440002E   BNE V0, ZERO, 0x9D0006EC
9D000634  2403FFFF   ADDIU V1, ZERO, -1
797:                 			break;
798:                 		wc |= fs->win[bc % SS(fs)] << 8;
9D000638  325201FF   ANDI S2, S2, 511
9D00063C  02128021   ADDU S0, S0, S2
9D000640  92030030   LBU V1, 48(S0)
9D000644  00031A00   SLL V1, V1, 8
9D000648  00739825   OR S3, V1, S3
799:                 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
9D00064C  32310001   ANDI S1, S1, 1
9D000650  00131102   SRL V0, S3, 4
9D000654  32730FFF   ANDI S3, S3, 4095
9D000658  00401821   ADDU V1, V0, ZERO
9D00065C  0B4001BB   J 0x9D0006EC
9D000660  0271180A   MOVZ V1, S3, S1
800:                 
801:                 	case FS_FAT16:
802:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))))
9D000664  8C820020   LW V0, 32(A0)
9D000668  0F400082   JAL 0x9D000208
9D00066C  00A22821   ADDU A1, A1, V0
9D000670  1440001E   BNE V0, ZERO, 0x9D0006EC
9D000674  2403FFFF   ADDIU V1, ZERO, -1
803:                 			break;
804:                 		p = &fs->win[clst * 2 % SS(fs)];
9D000678  00118840   SLL S1, S1, 1
9D00067C  323101FF   ANDI S1, S1, 511
805:                 		return LD_WORD(p);
9D000680  02111021   ADDU V0, S0, S1
9D000684  90430031   LBU V1, 49(V0)
9D000688  00031A00   SLL V1, V1, 8
9D00068C  90420030   LBU V0, 48(V0)
9D000690  0B4001BB   J 0x9D0006EC
9D000694  00621825   OR V1, V1, V0
806:                 
807:                 	case FS_FAT32:
808:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))))
9D000698  8C820020   LW V0, 32(A0)
9D00069C  0F400082   JAL 0x9D000208
9D0006A0  00A22821   ADDU A1, A1, V0
9D0006A4  14400011   BNE V0, ZERO, 0x9D0006EC
9D0006A8  2403FFFF   ADDIU V1, ZERO, -1
809:                 			break;
810:                 		p = &fs->win[clst * 4 % SS(fs)];
9D0006AC  00118880   SLL S1, S1, 2
9D0006B0  323101FF   ANDI S1, S1, 511
9D0006B4  26220030   ADDIU V0, S1, 48
9D0006B8  02021021   ADDU V0, S0, V0
811:                 		return LD_DWORD(p) & 0x0FFFFFFF;
9D0006BC  90440002   LBU A0, 2(V0)
9D0006C0  00042400   SLL A0, A0, 16
9D0006C4  90430003   LBU V1, 3(V0)
9D0006C8  00031E00   SLL V1, V1, 24
9D0006CC  00831825   OR V1, A0, V1
9D0006D0  90420001   LBU V0, 1(V0)
9D0006D4  00021200   SLL V0, V0, 8
9D0006D8  00621825   OR V1, V1, V0
9D0006DC  02118021   ADDU S0, S0, S1
9D0006E0  92020030   LBU V0, 48(S0)
9D0006E4  00621825   OR V1, V1, V0
9D0006E8  7C63D800   EXT V1, V1, 0, 28
812:                 	}
813:                 
814:                 	return 0xFFFFFFFF; /* An error occurred at the disk I/O layer */
815:                 }
9D0006EC  00601021   ADDU V0, V1, ZERO
9D0006F0  8FBF0024   LW RA, 36(SP)
9D0006F4  8FB30020   LW S3, 32(SP)
9D0006F8  8FB2001C   LW S2, 28(SP)
9D0006FC  8FB10018   LW S1, 24(SP)
9D000700  8FB00014   LW S0, 20(SP)
9D000704  03E00008   JR RA
9D000708  27BD0028   ADDIU SP, SP, 40
816:                 
817:                 /*-----------------------------------------------------------------------*/
818:                 /* FAT access - Change value of a FAT entry                              */
819:                 /*-----------------------------------------------------------------------*/
820:                 #if !_FS_READONLY
821:                 
822:                 FRESULT put_fat(FATFS *fs, /* File system object */
823:                 DWORD clst, /* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
824:                 DWORD val /* New value to mark the cluster */
825:                 ) {
9D0008C8  27BDFFD8   ADDIU SP, SP, -40
9D0008CC  AFBF0024   SW RA, 36(SP)
9D0008D0  AFB30020   SW S3, 32(SP)
9D0008D4  AFB2001C   SW S2, 28(SP)
9D0008D8  AFB10018   SW S1, 24(SP)
9D0008DC  AFB00014   SW S0, 20(SP)
9D0008E0  00808021   ADDU S0, A0, ZERO
9D0008E4  00A08821   ADDU S1, A1, ZERO
9D0008E8  00C09021   ADDU S2, A2, ZERO
826:                 	UINT bc;
827:                 	PF_BYTE *p;
828:                 	FRESULT res;
829:                 
830:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D0008EC  2CA30002   SLTIU V1, A1, 2
9D0008F0  1460005D   BNE V1, ZERO, 0x9D000A68
9D0008F4  24020002   ADDIU V0, ZERO, 2
9D0008F8  8C830018   LW V1, 24(A0)
9D0008FC  00A3182B   SLTU V1, A1, V1
9D000900  10600059   BEQ V1, ZERO, 0x9D000A68
9D000904  24030002   ADDIU V1, ZERO, 2
831:                 		res = FR_INT_ERR;
832:                 
833:                 	} else {
834:                 		switch (fs->fs_type) {
9D000908  90820000   LBU V0, 0(A0)
9D00090C  10430030   BEQ V0, V1, 0x9D0009D0
9D000910  24030003   ADDIU V1, ZERO, 3
9D000914  1043003B   BEQ V0, V1, 0x9D000A04
9D000918  24030001   ADDIU V1, ZERO, 1
9D00091C  14430050   BNE V0, V1, 0x9D000A60
9D000920  24020002   ADDIU V0, ZERO, 2
835:                 		case FS_FAT12:
836:                 			bc = clst;
837:                 			bc += bc / 2;
9D000924  00059842   SRL S3, A1, 1
9D000928  02659821   ADDU S3, S3, A1
838:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D00092C  00132A42   SRL A1, S3, 9
9D000930  8C820020   LW V0, 32(A0)
9D000934  0F400082   JAL 0x9D000208
9D000938  00A22821   ADDU A1, A1, V0
839:                 			if (res != FR_OK)
9D00093C  14400049   BNE V0, ZERO, 0x9D000A64
9D000940  24030001   ADDIU V1, ZERO, 1
840:                 				break;
841:                 			p = &fs->win[bc % SS(fs)];
9D000944  326301FF   ANDI V1, S3, 511
842:                 			*p = (clst & 1) ? ((*p & 0x0F) | ((PF_BYTE) val << 4))
9D000948  32310001   ANDI S1, S1, 1
9D00094C  12200008   BEQ S1, ZERO, 0x9D000970
9D000950  324200FF   ANDI V0, S2, 255
9D000954  02031021   ADDU V0, S0, V1
9D000958  90440030   LBU A0, 48(V0)
9D00095C  3084000F   ANDI A0, A0, 15
9D000960  324200FF   ANDI V0, S2, 255
9D000964  00021100   SLL V0, V0, 4
9D000968  00821025   OR V0, A0, V0
9D00096C  304200FF   ANDI V0, V0, 255
9D000970  02031821   ADDU V1, S0, V1
9D000974  A0620030   SB V0, 48(V1)
843:                 					: (PF_BYTE) val;
844:                 			bc++;
9D000978  26730001   ADDIU S3, S3, 1
845:                 			fs->wflag = 1;
9D00097C  24020001   ADDIU V0, ZERO, 1
9D000980  A2020004   SB V0, 4(S0)
846:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D000984  00132A42   SRL A1, S3, 9
9D000988  8E020020   LW V0, 32(S0)
9D00098C  02002021   ADDU A0, S0, ZERO
9D000990  0F400082   JAL 0x9D000208
9D000994  00A22821   ADDU A1, A1, V0
847:                 			if (res != FR_OK)
9D000998  14400032   BNE V0, ZERO, 0x9D000A64
9D00099C  24030001   ADDIU V1, ZERO, 1
848:                 				break;
849:                 			p = &fs->win[bc % SS(fs)];
850:                 			*p = (clst & 1) ? (PF_BYTE) (val >> 4) : ((*p & 0xF0)
9D0009A0  12200003   BEQ S1, ZERO, 0x9D0009B0
9D0009A4  327301FF   ANDI S3, S3, 511
9D0009A8  0B400271   J 0x9D0009C4
9D0009AC  7E523900   EXT S2, S2, 4, 8
9D0009B0  02131821   ADDU V1, S0, S3
9D0009B4  90630030   LBU V1, 48(V1)
9D0009B8  306300F0   ANDI V1, V1, 240
9D0009BC  7E521A00   EXT S2, S2, 8, 4
9D0009C0  00729025   OR S2, V1, S2
9D0009C4  02139821   ADDU S3, S0, S3
851:                 					| ((PF_BYTE) (val >> 8) & 0x0F));
852:                 			break;
9D0009C8  0B400298   J 0x9D000A60
9D0009CC  A2720030   SB S2, 48(S3)
853:                 
854:                 		case FS_FAT16:
855:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
9D0009D0  00052A02   SRL A1, A1, 8
9D0009D4  8C820020   LW V0, 32(A0)
9D0009D8  0F400082   JAL 0x9D000208
9D0009DC  00A22821   ADDU A1, A1, V0
856:                 			if (res != FR_OK)
9D0009E0  14400020   BNE V0, ZERO, 0x9D000A64
9D0009E4  24030001   ADDIU V1, ZERO, 1
857:                 				break;
858:                 			p = &fs->win[clst * 2 % SS(fs)];
9D0009E8  00118840   SLL S1, S1, 1
9D0009EC  323101FF   ANDI S1, S1, 511
859:                 			ST_WORD(p, (PF_WORD)val)
9D0009F0  02111821   ADDU V1, S0, S1
9D0009F4  A0720030   SB S2, 48(V1)
9D0009F8  7E523A00   EXT S2, S2, 8, 8
860:                 			;
861:                 			break;
9D0009FC  0B400298   J 0x9D000A60
9D000A00  A0720031   SB S2, 49(V1)
862:                 
863:                 		case FS_FAT32:
864:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
9D000A04  000529C2   SRL A1, A1, 7
9D000A08  8C820020   LW V0, 32(A0)
9D000A0C  0F400082   JAL 0x9D000208
9D000A10  00A22821   ADDU A1, A1, V0
865:                 			if (res != FR_OK)
9D000A14  14400013   BNE V0, ZERO, 0x9D000A64
9D000A18  24030001   ADDIU V1, ZERO, 1
866:                 				break;
867:                 			p = &fs->win[clst * 4 % SS(fs)];
9D000A1C  00118880   SLL S1, S1, 2
9D000A20  323101FF   ANDI S1, S1, 511
9D000A24  26230030   ADDIU V1, S1, 48
9D000A28  02031821   ADDU V1, S0, V1
868:                 			val |= LD_DWORD(p) & 0xF0000000;
9D000A2C  90640003   LBU A0, 3(V1)
9D000A30  00042600   SLL A0, A0, 24
9D000A34  02118821   ADDU S1, S0, S1
9D000A38  3C05F000   LUI A1, -4096
9D000A3C  00852024   AND A0, A0, A1
9D000A40  00929025   OR S2, A0, S2
869:                 			ST_DWORD(p, val)
9D000A44  A2320030   SB S2, 48(S1)
9D000A48  7E443A00   EXT A0, S2, 8, 8
9D000A4C  A0640001   SB A0, 1(V1)
9D000A50  00122402   SRL A0, S2, 16
9D000A54  A0640002   SB A0, 2(V1)
9D000A58  00129602   SRL S2, S2, 24
9D000A5C  A0720003   SB S2, 3(V1)
870:                 			;
871:                 			break;
872:                 
873:                 		default:
874:                 			res = FR_INT_ERR;
875:                 		}
876:                 		fs->wflag = 1;
9D000A60  24030001   ADDIU V1, ZERO, 1
9D000A64  A2030004   SB V1, 4(S0)
877:                 	}
878:                 
879:                 	return res;
880:                 }
9D000A68  8FBF0024   LW RA, 36(SP)
9D000A6C  8FB30020   LW S3, 32(SP)
9D000A70  8FB2001C   LW S2, 28(SP)
9D000A74  8FB10018   LW S1, 24(SP)
9D000A78  8FB00014   LW S0, 20(SP)
9D000A7C  03E00008   JR RA
9D000A80  27BD0028   ADDIU SP, SP, 40
881:                 #endif /* !_FS_READONLY */
882:                 
883:                 /*-----------------------------------------------------------------------*/
884:                 /* FAT handling - Remove a cluster chain                                 */
885:                 /*-----------------------------------------------------------------------*/
886:                 #if !_FS_READONLY
887:                 static FRESULT remove_chain(FATFS *fs, /* File system object */
888:                 DWORD clst /* Cluster# to remove a chain from */
889:                 ) {
9D001344  27BDFFD0   ADDIU SP, SP, -48
9D001348  AFBF002C   SW RA, 44(SP)
9D00134C  AFB50028   SW S5, 40(SP)
9D001350  AFB40024   SW S4, 36(SP)
9D001354  AFB30020   SW S3, 32(SP)
9D001358  AFB2001C   SW S2, 28(SP)
9D00135C  AFB10018   SW S1, 24(SP)
9D001360  AFB00014   SW S0, 20(SP)
9D001364  00808821   ADDU S1, A0, ZERO
9D001368  00A09021   ADDU S2, A1, ZERO
890:                 	FRESULT res;
891:                 	DWORD nxt;
892:                 #if _USE_ERASE
893:                 	DWORD scl = clst, ecl = clst, resion[2];
894:                 #endif
895:                 
896:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D00136C  2CA30002   SLTIU V1, A1, 2
9D001370  14600025   BNE V1, ZERO, 0x9D001408
9D001374  24020002   ADDIU V0, ZERO, 2
9D001378  8C830018   LW V1, 24(A0)
9D00137C  00A3182B   SLTU V1, A1, V1
9D001380  14600003   BNE V1, ZERO, 0x9D001390
9D001384  24140001   ADDIU S4, ZERO, 1
897:                 		res = FR_INT_ERR;
898:                 
899:                 	} else {
900:                 		res = FR_OK;
901:                 		while (clst < fs->n_fatent) { /* Not a last link? */
9D0013E4  8E230018   LW V1, 24(S1)
9D0013E8  0203182B   SLTU V1, S0, V1
9D0013EC  1460FFEA   BNE V1, ZERO, 0x9D001398
9D0013F0  02009021   ADDU S2, S0, ZERO
902:                 			nxt = get_fat(fs, clst); /* Get cluster status */
9D001398  02202021   ADDU A0, S1, ZERO
9D00139C  0F400162   JAL get_fat
9D0013A0  02402821   ADDU A1, S2, ZERO
903:                 			if (nxt == 0)
9D0013A4  10400015   BEQ V0, ZERO, 0x9D0013FC
9D0013A8  00408021   ADDU S0, V0, ZERO
9D0013FC  0B400502   J 0x9D001408
9D001400  00001021   ADDU V0, ZERO, ZERO
904:                 				break; /* Empty cluster? */
905:                 			if (nxt == 1) {
9D0013AC  50540016   BEQL V0, S4, 0x9D001408
9D0013B0  24020002   ADDIU V0, ZERO, 2
906:                 				res = FR_INT_ERR;
907:                 				break;
908:                 			} /* Internal error? */
909:                 			if (nxt == 0xFFFFFFFF) {
9D001390  2413FFFF   ADDIU S3, ZERO, -1
9D0013B4  10530013   BEQ V0, S3, 0x9D001404
9D0013B8  02202021   ADDU A0, S1, ZERO
910:                 				res = FR_DISK_ERR;
9D001404  24020001   ADDIU V0, ZERO, 1
911:                 				break;
912:                 			} /* Disk error? */
913:                 			res = put_fat(fs, clst, 0); /* Mark the cluster "empty" */
9D0013BC  02402821   ADDU A1, S2, ZERO
9D0013C0  0F400232   JAL put_fat
9D0013C4  00003021   ADDU A2, ZERO, ZERO
914:                 			if (res != FR_OK)
9D0013C8  14400010   BNE V0, ZERO, 0x9D00140C
9D0013CC  8FBF002C   LW RA, 44(SP)
915:                 				break;
916:                 			if (fs->free_clust != 0xFFFFFFFF) { /* Update FSInfo */
9D0013D0  8E230010   LW V1, 16(S1)
9D0013D4  10730003   BEQ V1, S3, 0x9D0013E4
9D0013D8  24630001   ADDIU V1, V1, 1
917:                 				fs->free_clust++;
9D0013DC  AE230010   SW V1, 16(S1)
918:                 				fs->fsi_flag = 1;
9D001394  24150001   ADDIU S5, ZERO, 1
9D0013E0  A2350005   SB S5, 5(S1)
919:                 			}
920:                 #if _USE_ERASE
921:                 			if (ecl + 1 == nxt) { /* Next cluster is contiguous */
922:                 				ecl = nxt;
923:                 			} else { /* End of contiguous clusters */
924:                 				resion[0] = clust2sect(fs, scl); /* Start sector */
925:                 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1; /* End sector */
926:                 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion); /* Erase the block */
927:                 				scl = ecl = nxt;
928:                 			}
929:                 #endif
930:                 			clst = nxt; /* Next cluster */
931:                 		}
932:                 	}
933:                 
934:                 	return res;
935:                 }
9D001388  0B400503   J 0x9D00140C
9D00138C  8FBF002C   LW RA, 44(SP)
9D0013F4  0B400503   J 0x9D00140C
9D0013F8  8FBF002C   LW RA, 44(SP)
9D001408  8FBF002C   LW RA, 44(SP)
9D00140C  8FB50028   LW S5, 40(SP)
9D001410  8FB40024   LW S4, 36(SP)
9D001414  8FB30020   LW S3, 32(SP)
9D001418  8FB2001C   LW S2, 28(SP)
9D00141C  8FB10018   LW S1, 24(SP)
9D001420  8FB00014   LW S0, 20(SP)
9D001424  03E00008   JR RA
9D001428  27BD0030   ADDIU SP, SP, 48
936:                 #endif
937:                 
938:                 /*-----------------------------------------------------------------------*/
939:                 /* FAT handling - Stretch or Create a cluster chain                      */
940:                 /*-----------------------------------------------------------------------*/
941:                 #if !_FS_READONLY
942:                 static DWORD create_chain( /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
943:                 FATFS *fs, /* File system object */
944:                 DWORD clst /* Cluster# to stretch. 0 means create a new chain. */
945:                 ) {
9D000A84  27BDFFD0   ADDIU SP, SP, -48
9D000A88  AFBF002C   SW RA, 44(SP)
9D000A8C  AFB60028   SW S6, 40(SP)
9D000A90  AFB50024   SW S5, 36(SP)
9D000A94  AFB40020   SW S4, 32(SP)
9D000A98  AFB3001C   SW S3, 28(SP)
9D000A9C  AFB20018   SW S2, 24(SP)
9D000AA0  AFB10014   SW S1, 20(SP)
9D000AA4  AFB00010   SW S0, 16(SP)
9D000AA8  00808821   ADDU S1, A0, ZERO
946:                 	DWORD cs, ncl, scl;
947:                 	FRESULT res;
948:                 
949:                 	if (clst == 0) { /* Create a new chain */
9D000AAC  14A00009   BNE A1, ZERO, 0x9D000AD4
9D000AB0  00A0B021   ADDU S6, A1, ZERO
950:                 		scl = fs->last_clust; /* Get suggested start point */
9D000AB4  8C92000C   LW S2, 12(A0)
951:                 		if (!scl || scl >= fs->n_fatent)
9D000AB8  52400011   BEQL S2, ZERO, 0x9D000B00
9D000ABC  24120001   ADDIU S2, ZERO, 1
9D000AC0  8C830018   LW V1, 24(A0)
9D000AC4  0243182B   SLTU V1, S2, V1
952:                 			scl = 1;
9D000AC8  24020001   ADDIU V0, ZERO, 1
9D000ACC  0B4002C0   J 0x9D000B00
9D000AD0  0043900A   MOVZ S2, V0, V1
953:                 	} else { /* Stretch the current chain */
954:                 		cs = get_fat(fs, clst); /* Check the cluster status */
9D000AD4  0F400162   JAL get_fat
9D000AD8  00000000   NOP
955:                 		if (cs < 2)
9D000ADC  2C430002   SLTIU V1, V0, 2
9D000AE0  5460003F   BNEL V1, ZERO, 0x9D000BE0
9D000AE4  24020001   ADDIU V0, ZERO, 1
956:                 			return 1; /* It is an invalid cluster */
957:                 		if (cs < fs->n_fatent)
9D000AE8  8E230018   LW V1, 24(S1)
9D000AEC  0043182B   SLTU V1, V0, V1
9D000AF0  10600003   BEQ V1, ZERO, 0x9D000B00
9D000AF4  02C09021   ADDU S2, S6, ZERO
958:                 			return cs; /* It is already followed by next cluster */
959:                 		scl = clst;
960:                 	}
961:                 
962:                 	ncl = scl; /* Start cluster */
9D000B00  02408021   ADDU S0, S2, ZERO
963:                 	for (;;) {
964:                 		ncl++; /* Next cluster */
9D000B10  26100001   ADDIU S0, S0, 1
965:                 		if (ncl >= fs->n_fatent) { /* Wrap around */
9D000B14  8E220018   LW V0, 24(S1)
9D000B18  0202102B   SLTU V0, S0, V0
9D000B1C  14400004   BNE V0, ZERO, 0x9D000B30
9D000B20  02202021   ADDU A0, S1, ZERO
966:                 			ncl = 2;
967:                 			if (ncl > scl)
9D000B04  2E550002   SLTIU S5, S2, 2
9D000B24  16A0002D   BNE S5, ZERO, 0x9D000BDC
9D000B28  24100002   ADDIU S0, ZERO, 2
968:                 				return 0; /* No free cluster */
969:                 		}
970:                 		cs = get_fat(fs, ncl); /* Get the cluster status */
9D000B2C  02202021   ADDU A0, S1, ZERO
9D000B30  0F400162   JAL get_fat
9D000B34  02002821   ADDU A1, S0, ZERO
971:                 		if (cs == 0)
9D000B38  50400009   BEQL V0, ZERO, 0x9D000B60
9D000B3C  02009021   ADDU S2, S0, ZERO
972:                 			break; /* Found a free cluster */
973:                 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
9D000B08  2413FFFF   ADDIU S3, ZERO, -1
9D000B0C  24140001   ADDIU S4, ZERO, 1
9D000B40  10530028   BEQ V0, S3, 0x9D000BE4
9D000B44  8FBF002C   LW RA, 44(SP)
9D000B48  50540027   BEQL V0, S4, 0x9D000BE8
9D000B4C  8FB60028   LW S6, 40(SP)
974:                 			return cs;
975:                 		if (ncl == scl)
9D000B50  1612FFF0   BNE S0, S2, 0x9D000B14
9D000B54  26100001   ADDIU S0, S0, 1
976:                 			return 0; /* No free cluster */
9D000B58  0B4002F8   J 0x9D000BE0
9D000B5C  00001021   ADDU V0, ZERO, ZERO
977:                 	}
978:                 
979:                 	res = put_fat(fs, ncl, 0x0FFFFFFF); /* Mark the new cluster "last link" */
9D000B60  02202021   ADDU A0, S1, ZERO
9D000B64  02002821   ADDU A1, S0, ZERO
9D000B68  3C060FFF   LUI A2, 4095
9D000B6C  0F400232   JAL put_fat
9D000B70  34C6FFFF   ORI A2, A2, -1
980:                 	if (res == FR_OK && clst != 0) {
9D000B74  54400014   BNEL V0, ZERO, 0x9D000BC8
9D000B78  38420001   XORI V0, V0, 1
9D000B7C  52C00008   BEQL S6, ZERO, 0x9D000BA0
9D000B80  AE32000C   SW S2, 12(S1)
981:                 		res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
9D000B84  02202021   ADDU A0, S1, ZERO
9D000B88  02C02821   ADDU A1, S6, ZERO
9D000B8C  0F400232   JAL put_fat
9D000B90  02003021   ADDU A2, S0, ZERO
982:                 	}
983:                 	if (res == FR_OK) {
9D000B94  5440000C   BNEL V0, ZERO, 0x9D000BC8
9D000B98  38420001   XORI V0, V0, 1
984:                 		fs->last_clust = ncl; /* Update FSINFO */
9D000B9C  AE32000C   SW S2, 12(S1)
985:                 		if (fs->free_clust != 0xFFFFFFFF) {
9D000BA0  8E230010   LW V1, 16(S1)
9D000BA4  2404FFFF   ADDIU A0, ZERO, -1
9D000BA8  1064000D   BEQ V1, A0, 0x9D000BE0
9D000BAC  02001021   ADDU V0, S0, ZERO
986:                 			fs->free_clust--;
9D000BB0  2463FFFF   ADDIU V1, V1, -1
9D000BB4  AE230010   SW V1, 16(S1)
987:                 			fs->fsi_flag = 1;
9D000BB8  24020001   ADDIU V0, ZERO, 1
9D000BBC  A2220005   SB V0, 5(S1)
9D000BC0  0B4002F8   J 0x9D000BE0
9D000BC4  02001021   ADDU V0, S0, ZERO
988:                 		}
989:                 	} else {
990:                 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
9D000BC8  2403FFFF   ADDIU V1, ZERO, -1
9D000BCC  24040001   ADDIU A0, ZERO, 1
9D000BD0  0082180B   MOVN V1, A0, V0
9D000BD4  0B4002F8   J 0x9D000BE0
9D000BD8  00601021   ADDU V0, V1, ZERO
9D000BDC  00001021   ADDU V0, ZERO, ZERO
991:                 	}
992:                 
993:                 	return ncl; /* Return new cluster number or error code */
994:                 }
9D000AF8  0B4002F9   J 0x9D000BE4
9D000AFC  8FBF002C   LW RA, 44(SP)
9D000BE0  8FBF002C   LW RA, 44(SP)
9D000BE4  8FB60028   LW S6, 40(SP)
9D000BE8  8FB50024   LW S5, 36(SP)
9D000BEC  8FB40020   LW S4, 32(SP)
9D000BF0  8FB3001C   LW S3, 28(SP)
9D000BF4  8FB20018   LW S2, 24(SP)
9D000BF8  8FB10014   LW S1, 20(SP)
9D000BFC  8FB00010   LW S0, 16(SP)
9D000C00  03E00008   JR RA
9D000C04  27BD0030   ADDIU SP, SP, 48
995:                 #endif /* !_FS_READONLY */
996:                 
997:                 /*-----------------------------------------------------------------------*/
998:                 /* FAT handling - Convert offset into cluster with link map table        */
999:                 /*-----------------------------------------------------------------------*/
1000:                
1001:                #if _USE_FASTSEEK
1002:                static DWORD clmt_clust( /* <2:Error, >=2:Cluster number */
1003:                FIL* fp, /* Pointer to the file object */
1004:                DWORD ofs /* File offset to be converted to cluster# */
1005:                ) {
1006:                	DWORD cl, ncl, *tbl;
1007:                
1008:                	tbl = fp->cltbl + 1; /* Top of CLMT */
9D00006C  8C820024   LW V0, 36(A0)
9D000070  24470004   ADDIU A3, V0, 4
1009:                	cl = ofs / SS(fp->fs) / fp->fs->csize; /* Cluster order from top of the file */
9D000074  8C860000   LW A2, 0(A0)
9D000078  90C30002   LBU V1, 2(A2)
9D000088  00052A42   SRL A1, A1, 9
9D00008C  00A3001B   DIVU A1, V1
9D000090  006001F4   TEQ V1, ZERO
9D000094  00001812   MFLO V1, 0
9D000098  00001012   MFLO V0, 0
1010:                	for (;;) {
1011:                		ncl = *tbl++; /* Number of cluters in the fragment */
9D00007C  8C460004   LW A2, 4(V0)
9D0000B0  00603021   ADDU A2, V1, ZERO
9D0000C0  8C830004   LW V1, 4(A0)
1012:                		if (!ncl)
9D000080  10C00017   BEQ A2, ZERO, 0x9D0000E0
9D000084  00001021   ADDU V0, ZERO, ZERO
9D0000C4  5460FFFA   BNEL V1, ZERO, 0x9D0000B0
9D0000C8  00461023   SUBU V0, V0, A2
1013:                			return 0; /* End of table? (error) */
9D0000CC  03E00008   JR RA
9D0000D0  00001021   ADDU V0, ZERO, ZERO
1014:                		if (cl < ncl)
9D00009C  0066182B   SLTU V1, V1, A2
9D0000A0  10600007   BEQ V1, ZERO, 0x9D0000C0
9D0000A4  24E40004   ADDIU A0, A3, 4
9D0000B4  0043182B   SLTU V1, V0, V1
9D0000B8  14600006   BNE V1, ZERO, 0x9D0000D4
9D0000BC  24840008   ADDIU A0, A0, 8
1015:                			break; /* In this fragment? */
1016:                		cl -= ncl;
1017:                		tbl++; /* Next fragment */
1018:                	}
1019:                	return cl + *tbl; /* Return the cluster number */
9D0000A8  0B400036   J 0x9D0000D8
9D0000AC  8C830000   LW V1, 0(A0)
9D0000D4  8C830000   LW V1, 0(A0)
9D0000D8  03E00008   JR RA
9D0000DC  00431021   ADDU V0, V0, V1
1020:                }
9D0000E0  03E00008   JR RA
9D0000E4  00000000   NOP
1021:                #endif	/* _USE_FASTSEEK */
1022:                
1023:                /*-----------------------------------------------------------------------*/
1024:                /* Directory handling - Set directory index                              */
1025:                /*-----------------------------------------------------------------------*/
1026:                
1027:                static FRESULT dir_sdi(DIR *dj, /* Pointer to directory object */
9D0007B4  3294FFFF   ANDI S4, S4, -1
9D0007B8  02328823   SUBU S1, S1, S2
9D0007BC  3231FFFF   ANDI S1, S1, -1
9D0007C0  2413FFFF   ADDIU S3, ZERO, -1
1028:                PF_WORD idx /* Directory index number */
1029:                ) {
9D00070C  27BDFFD8   ADDIU SP, SP, -40
9D000710  AFBF0024   SW RA, 36(SP)
9D000714  AFB40020   SW S4, 32(SP)
9D000718  AFB3001C   SW S3, 28(SP)
9D00071C  AFB20018   SW S2, 24(SP)
9D000720  AFB10014   SW S1, 20(SP)
9D000724  AFB00010   SW S0, 16(SP)
9D000728  00808021   ADDU S0, A0, ZERO
9D00072C  00A08821   ADDU S1, A1, ZERO
1030:                	DWORD clst;
1031:                	PF_WORD ic;
1032:                
1033:                	dj->index = idx;
9D000730  A4850006   SH A1, 6(A0)
1034:                	clst = dj->sclust;
9D000734  8C850008   LW A1, 8(A0)
1035:                	if (clst == 1 || clst >= dj->fs->n_fatent) /* Check start cluster range */
9D000738  24030001   ADDIU V1, ZERO, 1
9D00073C  10A30044   BEQ A1, V1, 0x9D000850
9D000740  24020002   ADDIU V0, ZERO, 2
9D000744  8C830000   LW V1, 0(A0)
9D000748  8C640018   LW A0, 24(V1)
9D00074C  00A4202B   SLTU A0, A1, A0
9D000750  50800040   BEQL A0, ZERO, 0x9D000854
9D000754  8FBF0024   LW RA, 36(SP)
1036:                		return FR_INT_ERR;
1037:                	if (!clst && dj->fs->fs_type == FS_FAT32) /* Replace cluster# 0 with root cluster# if in FAT32 */
9D000758  54A00012   BNEL A1, ZERO, 0x9D0007A4
9D00075C  90720002   LBU S2, 2(V1)
9D000760  90640000   LBU A0, 0(V1)
9D000764  24020003   ADDIU V0, ZERO, 3
9D000768  54820005   BNEL A0, V0, 0x9D000780
9D00076C  AE00000C   SW ZERO, 12(S0)
1038:                		clst = dj->fs->dirbase;
9D000770  8C650024   LW A1, 36(V1)
1039:                
1040:                	if (clst == 0) { /* Static table (root-dir in FAT12/16) */
9D000774  54A0000B   BNEL A1, ZERO, 0x9D0007A4
9D000778  90720002   LBU S2, 2(V1)
1041:                		dj->clust = clst;
9D00077C  AE00000C   SW ZERO, 12(S0)
1042:                		if (idx >= dj->fs->n_rootdir) /* Index is out of range */
9D000780  94640008   LHU A0, 8(V1)
9D000784  0224202B   SLTU A0, S1, A0
9D000788  10800031   BEQ A0, ZERO, 0x9D000850
9D00078C  24020002   ADDIU V0, ZERO, 2
1043:                			return FR_INT_ERR;
1044:                		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D000790  7E247900   EXT A0, S1, 4, 16
9D000794  8C620024   LW V0, 36(V1)
9D000798  00821021   ADDU V0, A0, V0
9D00079C  0B400209   J 0x9D000824
9D0007A0  AE020010   SW V0, 16(S0)
1045:                	} else { /* Dynamic table (sub-dirs or root-dir in FAT32) */
1046:                		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize; /* Entries per cluster */
9D0007A4  00129100   SLL S2, S2, 4
1047:                		while (idx >= ic) { /* Follow cluster chain */
9D0007A8  0232102B   SLTU V0, S1, S2
9D0007AC  14400017   BNE V0, ZERO, 0x9D00080C
9D0007B0  0012A023   SUBU S4, ZERO, S2
9D0007F8  00521821   ADDU V1, V0, S2
9D0007FC  3063FFFF   ANDI V1, V1, -1
9D000800  0072182B   SLTU V1, V1, S2
9D000804  5060FFEF   BEQL V1, ZERO, 0x9D0007C4
9D000808  00408821   ADDU S1, V0, ZERO
1048:                			clst = get_fat(dj->fs, clst); /* Get next cluster */
9D0007C4  0F400162   JAL get_fat
9D0007C8  8E040000   LW A0, 0(S0)
1049:                			if (clst == 0xFFFFFFFF)
9D0007CC  1053001D   BEQ V0, S3, 0x9D000844
9D0007D0  00402821   ADDU A1, V0, ZERO
1050:                				return FR_DISK_ERR; /* Disk error */
9D000844  0B400214   J 0x9D000850
9D000848  24020001   ADDIU V0, ZERO, 1
1051:                			if (clst < 2 || clst >= dj->fs->n_fatent) /* Reached to end of table or int error */
9D0007D4  2C420002   SLTIU V0, V0, 2
9D0007D8  1440001D   BNE V0, ZERO, 0x9D000850
9D0007DC  24020002   ADDIU V0, ZERO, 2
9D0007E0  8E020000   LW V0, 0(S0)
9D0007E4  8C420018   LW V0, 24(V0)
9D0007E8  00A2102B   SLTU V0, A1, V0
9D0007EC  10400017   BEQ V0, ZERO, 0x9D00084C
9D0007F0  02341021   ADDU V0, S1, S4
9D0007F4  3042FFFF   ANDI V0, V0, -1
1052:                				return FR_INT_ERR;
9D00084C  24020002   ADDIU V0, ZERO, 2
1053:                			idx -= ic;
1054:                		}
1055:                		dj->clust = clst;
9D00080C  AE05000C   SW A1, 12(S0)
1056:                		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D000810  0F400156   JAL clust2sect
9D000814  8E040000   LW A0, 0(S0)
9D000818  7E237900   EXT V1, S1, 4, 16
9D00081C  00621021   ADDU V0, V1, V0
9D000820  AE020010   SW V0, 16(S0)
1057:                	}
1058:                
1059:                	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR; /* Ptr to the entry in the sector */
9D000824  8E020000   LW V0, 0(S0)
9D000828  24420030   ADDIU V0, V0, 48
9D00082C  3231000F   ANDI S1, S1, 15
9D000830  00118940   SLL S1, S1, 5
9D000834  00518821   ADDU S1, V0, S1
9D000838  AE110014   SW S1, 20(S0)
1060:                
1061:                	return FR_OK; /* Seek succeeded */
9D00083C  0B400214   J 0x9D000850
9D000840  00001021   ADDU V0, ZERO, ZERO
1062:                }
9D000850  8FBF0024   LW RA, 36(SP)
9D000854  8FB40020   LW S4, 32(SP)
9D000858  8FB3001C   LW S3, 28(SP)
9D00085C  8FB20018   LW S2, 24(SP)
9D000860  8FB10014   LW S1, 20(SP)
9D000864  8FB00010   LW S0, 16(SP)
9D000868  03E00008   JR RA
9D00086C  27BD0028   ADDIU SP, SP, 40
1063:                
1064:                /*-----------------------------------------------------------------------*/
1065:                /* Directory handling - Move directory index next                        */
1066:                /*-----------------------------------------------------------------------*/
1067:                
1068:                static FRESULT dir_next( /* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
1069:                DIR *dj, /* Pointer to directory object */
1070:                int stretch /* 0: Do not stretch table, 1: Stretch table if needed */
1071:                ) {
9D000C08  27BDFFD8   ADDIU SP, SP, -40
9D000C0C  AFBF0024   SW RA, 36(SP)
9D000C10  AFB40020   SW S4, 32(SP)
9D000C14  AFB3001C   SW S3, 28(SP)
9D000C18  AFB20018   SW S2, 24(SP)
9D000C1C  AFB10014   SW S1, 20(SP)
9D000C20  AFB00010   SW S0, 16(SP)
9D000C24  00808821   ADDU S1, A0, ZERO
9D000C28  00A08021   ADDU S0, A1, ZERO
1072:                	DWORD clst;
1073:                	PF_WORD i;
1074:                
1075:                	stretch = stretch; /* To suppress warning on read-only cfg. */
1076:                	i = dj->index + 1;
9D000C2C  94920006   LHU S2, 6(A0)
9D000C30  26520001   ADDIU S2, S2, 1
9D000C34  3252FFFF   ANDI S2, S2, -1
1077:                	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
9D000C38  1240006C   BEQ S2, ZERO, 0x9D000DEC
9D000C3C  24030004   ADDIU V1, ZERO, 4
9D000C40  8C820010   LW V0, 16(A0)
9D000C44  5040006A   BEQL V0, ZERO, 0x9D000DF0
9D000C48  00601021   ADDU V0, V1, ZERO
1078:                		return FR_NO_FILE;
1079:                
1080:                	if (!(i % (SS(dj->fs) / SZ_DIR))) { /* Sector changed? */
9D000C4C  3243000F   ANDI V1, S2, 15
9D000C50  5460005D   BNEL V1, ZERO, 0x9D000DC8
9D000C54  A6320006   SH S2, 6(S1)
1081:                		dj->sect++; /* Next sector */
9D000C58  24420001   ADDIU V0, V0, 1
9D000C5C  AC820010   SW V0, 16(A0)
1082:                
1083:                		if (dj->clust == 0) { /* Static table */
9D000C60  8C85000C   LW A1, 12(A0)
9D000C64  54A00008   BNEL A1, ZERO, 0x9D000C88
9D000C68  8C840000   LW A0, 0(A0)
1084:                			if (i >= dj->fs->n_rootdir) /* Report EOT when end of table */
9D000C6C  8C820000   LW V0, 0(A0)
9D000C70  94420008   LHU V0, 8(V0)
9D000C74  0242102B   SLTU V0, S2, V0
9D000C78  14400052   BNE V0, ZERO, 0x9D000DC4
9D000C7C  24030004   ADDIU V1, ZERO, 4
1085:                				return FR_NO_FILE;
1086:                		} else { /* Dynamic table */
1087:                			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) { /* Cluster changed? */
9D000C88  90820002   LBU V0, 2(A0)
9D000C8C  2442FFFF   ADDIU V0, V0, -1
9D000C90  00121902   SRL V1, S2, 4
9D000C94  00431024   AND V0, V0, V1
9D000C98  5440004B   BNEL V0, ZERO, 0x9D000DC8
9D000C9C  A6320006   SH S2, 6(S1)
1088:                				clst = get_fat(dj->fs, dj->clust); /* Get next cluster */
9D000CA0  0F400162   JAL get_fat
9D000CA4  00000000   NOP
9D000CA8  00409821   ADDU S3, V0, ZERO
1089:                				if (clst <= 1)
9D000CAC  2C420002   SLTIU V0, V0, 2
9D000CB0  1440004E   BNE V0, ZERO, 0x9D000DEC
9D000CB4  24030002   ADDIU V1, ZERO, 2
1090:                					return FR_INT_ERR;
1091:                				if (clst == 0xFFFFFFFF)
9D000CB8  2402FFFF   ADDIU V0, ZERO, -1
9D000CBC  1262004B   BEQ S3, V0, 0x9D000DEC
9D000CC0  24030001   ADDIU V1, ZERO, 1
1092:                					return FR_DISK_ERR;
1093:                				if (clst >= dj->fs->n_fatent) { /* When it reached end of dynamic table */
9D000CC4  8E240000   LW A0, 0(S1)
9D000CC8  8C820018   LW V0, 24(A0)
9D000CCC  0262102B   SLTU V0, S3, V0
9D000CD0  54400038   BNEL V0, ZERO, 0x9D000DB4
9D000CD4  AE33000C   SW S3, 12(S1)
1094:                #if !_FS_READONLY
1095:                					PF_BYTE c;
1096:                					if (!stretch)
9D000CD8  12000044   BEQ S0, ZERO, 0x9D000DEC
9D000CDC  24030004   ADDIU V1, ZERO, 4
1097:                						return FR_NO_FILE; /* When do not stretch, report EOT */
1098:                					clst = create_chain(dj->fs, dj->clust); /* Stretch cluster chain */
9D000CE0  0F4002A1   JAL 0x9D000A84
9D000CE4  8E25000C   LW A1, 12(S1)
9D000CE8  00409821   ADDU S3, V0, ZERO
1099:                					if (clst == 0)
9D000CEC  1040003F   BEQ V0, ZERO, 0x9D000DEC
9D000CF0  24030007   ADDIU V1, ZERO, 7
1100:                						return FR_DENIED; /* No free cluster */
1101:                					if (clst == 1)
9D000CF4  24020001   ADDIU V0, ZERO, 1
9D000CF8  1262003C   BEQ S3, V0, 0x9D000DEC
9D000CFC  24030002   ADDIU V1, ZERO, 2
1102:                						return FR_INT_ERR;
1103:                					if (clst == 0xFFFFFFFF)
9D000D00  2402FFFF   ADDIU V0, ZERO, -1
9D000D04  12620039   BEQ S3, V0, 0x9D000DEC
9D000D08  24030001   ADDIU V1, ZERO, 1
1104:                						return FR_DISK_ERR;
1105:                					/* Clean-up stretched table */
1106:                					if (move_window(dj->fs, 0))
9D000D0C  8E240000   LW A0, 0(S1)
9D000D10  0F400082   JAL 0x9D000208
9D000D14  00002821   ADDU A1, ZERO, ZERO
9D000D18  14400034   BNE V0, ZERO, 0x9D000DEC
9D000D1C  24030001   ADDIU V1, ZERO, 1
1107:                						return FR_DISK_ERR; /* Flush active window */
1108:                					mem_set(dj->fs->win, 0, SS(dj->fs)); /* Clear window buffer */
9D000D20  8E240000   LW A0, 0(S1)
9D000D24  24840030   ADDIU A0, A0, 48
9D000D28  00002821   ADDU A1, ZERO, ZERO
9D000D2C  0F400012   JAL 0x9D000048
9D000D30  24060200   ADDIU A2, ZERO, 512
1109:                					dj->fs->winsect = clust2sect(dj->fs, clst); /* Cluster start sector */
9D000D34  8E300000   LW S0, 0(S1)
9D000D38  02002021   ADDU A0, S0, ZERO
9D000D3C  0F400156   JAL clust2sect
9D000D40  02602821   ADDU A1, S3, ZERO
9D000D44  AE02002C   SW V0, 44(S0)
1110:                					for (c = 0; c < dj->fs->csize; c++) { /* Fill the new cluster with 0 */
9D000D48  8E220000   LW V0, 0(S1)
9D000D4C  90430002   LBU V1, 2(V0)
9D000D50  10600014   BEQ V1, ZERO, 0x9D000DA4
9D000D54  00008021   ADDU S0, ZERO, ZERO
9D000D84  321000FF   ANDI S0, S0, 255
9D000D88  8E220000   LW V0, 0(S1)
9D000D8C  90430002   LBU V1, 2(V0)
9D000D90  0203182B   SLTU V1, S0, V1
9D000D94  5460FFF2   BNEL V1, ZERO, 0x9D000D60
9D000D98  A0540004   SB S4, 4(V0)
1111:                						dj->fs->wflag = 1;
9D000D58  24140001   ADDIU S4, ZERO, 1
9D000D5C  A0540004   SB S4, 4(V0)
1112:                						if (move_window(dj->fs, 0))
9D000D60  8E240000   LW A0, 0(S1)
9D000D64  0F400082   JAL 0x9D000208
9D000D68  00002821   ADDU A1, ZERO, ZERO
9D000D6C  1440001E   BNE V0, ZERO, 0x9D000DE8
9D000D70  26100001   ADDIU S0, S0, 1
1113:                							return FR_DISK_ERR;
9D000DE8  24030001   ADDIU V1, ZERO, 1
1114:                						dj->fs->winsect++;
9D000D74  8E220000   LW V0, 0(S1)
9D000D78  8C43002C   LW V1, 44(V0)
9D000D7C  24630001   ADDIU V1, V1, 1
9D000D80  AC43002C   SW V1, 44(V0)
1115:                					}
1116:                					dj->fs->winsect -= c; /* Rewind window address */
9D000D9C  0B40036A   J 0x9D000DA8
9D000DA0  8C43002C   LW V1, 44(V0)
9D000DA4  8C43002C   LW V1, 44(V0)
9D000DA8  00708023   SUBU S0, V1, S0
9D000DAC  AC50002C   SW S0, 44(V0)
1117:                #else
1118:                					return FR_NO_FILE; /* Report EOT */
1119:                #endif
1120:                				}
1121:                				dj->clust = clst; /* Initialize data for new cluster */
9D000DB0  AE33000C   SW S3, 12(S1)
1122:                				dj->sect = clust2sect(dj->fs, clst);
9D000DB4  8E240000   LW A0, 0(S1)
9D000DB8  0F400156   JAL clust2sect
9D000DBC  02602821   ADDU A1, S3, ZERO
9D000DC0  AE220010   SW V0, 16(S1)
1123:                			}
1124:                		}
1125:                	}
1126:                
1127:                	dj->index = i;
9D000DC4  A6320006   SH S2, 6(S1)
1128:                	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
9D000DC8  8E220000   LW V0, 0(S1)
9D000DCC  24420030   ADDIU V0, V0, 48
9D000DD0  3252000F   ANDI S2, S2, 15
9D000DD4  00129140   SLL S2, S2, 5
9D000DD8  00529021   ADDU S2, V0, S2
9D000DDC  AE320014   SW S2, 20(S1)
1129:                
1130:                	return FR_OK;
9D000DE0  0B40037B   J 0x9D000DEC
9D000DE4  00001821   ADDU V1, ZERO, ZERO
1131:                }
9D000C80  0B40037C   J 0x9D000DF0
9D000C84  00601021   ADDU V0, V1, ZERO
9D000DEC  00601021   ADDU V0, V1, ZERO
9D000DF0  8FBF0024   LW RA, 36(SP)
9D000DF4  8FB40020   LW S4, 32(SP)
9D000DF8  8FB3001C   LW S3, 28(SP)
9D000DFC  8FB20018   LW S2, 24(SP)
9D000E00  8FB10014   LW S1, 20(SP)
9D000E04  8FB00010   LW S0, 16(SP)
9D000E08  03E00008   JR RA
9D000E0C  27BD0028   ADDIU SP, SP, 40
1132:                
1133:                /*-----------------------------------------------------------------------*/
1134:                /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
1135:                /*-----------------------------------------------------------------------*/
1136:                #if _USE_LFN
1137:                static
1138:                const PF_BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30}; /* Offset of LFN chars in the directory entry */
1139:                
1140:                static
1141:                int cmp_lfn ( /* 1:Matched, 0:Not matched */
1142:                		WCHAR *lfnbuf, /* Pointer to the LFN to be compared */
1143:                		PF_BYTE *dir /* Pointer to the directory entry containing a part of LFN */
1144:                )
1145:                {
1146:                	UINT i, s;
1147:                	WCHAR wc, uc;
1148:                
1149:                	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13; /* Get offset in the LFN buffer */
1150:                	s = 0; wc = 1;
1151:                	do {
1152:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1153:                		if (wc) { /* Last char has not been processed */
1154:                			wc = ff_wtoupper(uc); /* Convert it to upper case */
1155:                			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++])) /* Compare it */
1156:                			return 0; /* Not matched */
1157:                		} else {
1158:                			if (uc != 0xFFFF) return 0; /* Check filler */
1159:                		}
1160:                	}while (++s < 13); /* Repeat until all chars in the entry are checked */
1161:                
1162:                	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i]) /* Last segment matched but different length */
1163:                	return 0;
1164:                
1165:                	return 1; /* The part of LFN matched */
1166:                }
1167:                
1168:                static
1169:                int pick_lfn ( /* 1:Succeeded, 0:Buffer overflow */
1170:                		WCHAR *lfnbuf, /* Pointer to the Unicode-LFN buffer */
1171:                		PF_BYTE *dir /* Pointer to the directory entry */
1172:                )
1173:                {
1174:                	UINT i, s;
1175:                	WCHAR wc, uc;
1176:                
1177:                	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13; /* Offset in the LFN buffer */
1178:                
1179:                	s = 0; wc = 1;
1180:                	do {
1181:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1182:                		if (wc) { /* Last char has not been processed */
1183:                			if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1184:                			lfnbuf[i++] = wc = uc; /* Store it */
1185:                		} else {
1186:                			if (uc != 0xFFFF) return 0; /* Check filler */
1187:                		}
1188:                	}while (++s < 13); /* Read all character in the entry */
1189:                
1190:                	if (dir[LDIR_Ord] & LLE) { /* Put terminator if it is the last LFN part */
1191:                		if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1192:                		lfnbuf[i] = 0;
1193:                	}
1194:                
1195:                	return 1;
1196:                }
1197:                
1198:                #if !_FS_READONLY
1199:                static
1200:                void fit_lfn (
1201:                		const WCHAR *lfnbuf, /* Pointer to the LFN buffer */
1202:                		PF_BYTE *dir, /* Pointer to the directory entry */
1203:                		PF_BYTE ord, /* LFN order (1-20) */
1204:                		PF_BYTE sum /* SFN sum */
1205:                )
1206:                {
1207:                	UINT i, s;
1208:                	WCHAR wc;
1209:                
1210:                	dir[LDIR_Chksum] = sum; /* Set check sum */
1211:                	dir[LDIR_Attr] = AM_LFN; /* Set attribute. LFN entry */
1212:                	dir[LDIR_Type] = 0;
1213:                	ST_WORD(dir+LDIR_FstClusLO, 0);
1214:                
1215:                	i = (ord - 1) * 13; /* Get offset in the LFN buffer */
1216:                	s = wc = 0;
1217:                	do {
1218:                		if (wc != 0xFFFF) wc = lfnbuf[i++]; /* Get an effective char */
1219:                		ST_WORD(dir+LfnOfs[s], wc); /* Put it */
1220:                		if (!wc) wc = 0xFFFF; /* Padding chars following last char */
1221:                	}while (++s < 13);
1222:                	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE; /* Bottom LFN part is the start of LFN sequence */
1223:                	dir[LDIR_Ord] = ord; /* Set the LFN order */
1224:                }
1225:                
1226:                #endif
1227:                #endif
1228:                
1229:                /*-----------------------------------------------------------------------*/
1230:                /* Create numbered name                                                  */
1231:                /*-----------------------------------------------------------------------*/
1232:                #if _USE_LFN
1233:                void gen_numname (
1234:                		PF_BYTE *dst, /* Pointer to generated SFN */
1235:                		const PF_BYTE *src, /* Pointer to source SFN to be modified */
1236:                		const WCHAR *lfn, /* Pointer to LFN */
1237:                		PF_WORD seq /* Sequence number */
1238:                )
1239:                {
1240:                	PF_BYTE ns[8], c;
1241:                	UINT i, j;
1242:                
1243:                	mem_cpy(dst, src, 11);
1244:                
1245:                	if (seq > 5) { /* On many collisions, generate a hash number instead of sequential number */
1246:                		do seq = (seq >> 1) + (seq << 15) + (PF_WORD)*lfn++; while (*lfn);
1247:                	}
1248:                
1249:                	/* itoa (hexdecimal) */
1250:                	i = 7;
1251:                	do {
1252:                		c = (seq % 16) + '0';
1253:                		if (c > '9') c += 7;
1254:                		ns[i--] = c;
1255:                		seq /= 16;
1256:                	}while (seq);
1257:                	ns[i] = '~';
1258:                
1259:                	/* Append the number */
1260:                	for (j = 0; j < i && dst[j] != ' '; j++) {
1261:                		if (IsDBCS1(dst[j])) {
1262:                			if (j == i - 1) break;
1263:                			j++;
1264:                		}
1265:                	}
1266:                	do {
1267:                		dst[j++] = (i < 8) ? ns[i++] : ' ';
1268:                	}while (j < 8);
1269:                }
1270:                #endif
1271:                
1272:                /*-----------------------------------------------------------------------*/
1273:                /* Calculate sum of an SFN                                               */
1274:                /*-----------------------------------------------------------------------*/
1275:                #if _USE_LFN
1276:                static
1277:                PF_BYTE sum_sfn (
1278:                		const PF_BYTE *dir /* Ptr to directory entry */
1279:                )
1280:                {
1281:                	PF_BYTE sum = 0;
1282:                	UINT n = 11;
1283:                
1284:                	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
1285:                	return sum;
1286:                }
1287:                #endif
1288:                
1289:                /*-----------------------------------------------------------------------*/
1290:                /* Directory handling - Find an object in the directory                  */
1291:                /*-----------------------------------------------------------------------*/
1292:                
1293:                static FRESULT dir_find(DIR *dj /* Pointer to the directory object linked to the file name */
1294:                ) {
1295:                	FRESULT res;
1296:                	PF_BYTE c, *dir;
1297:                #if _USE_LFN
1298:                	PF_BYTE a, ord, sum;
1299:                #endif
1300:                
1301:                	res = dir_sdi(dj, 0); /* Rewind directory object */
9D001074  02402021   ADDU A0, S2, ZERO
9D001078  0F4001C3   JAL 0x9D00070C
9D00107C  00002821   ADDU A1, ZERO, ZERO
1302:                	if (res != FR_OK)
9D001080  5440001F   BNEL V0, ZERO, 0x9D001100
9D001084  8E430018   LW V1, 24(S2)
1303:                		return res;
1304:                
1305:                #if _USE_LFN
1306:                	ord = sum = 0xFF;
1307:                #endif
1308:                	do {
1309:                		res = move_window(dj->fs, dj->sect);
9D001088  8E440000   LW A0, 0(S2)
9D00108C  0F400082   JAL 0x9D000208
9D001090  8E450010   LW A1, 16(S2)
1310:                		if (res != FR_OK)
9D001094  5440001A   BNEL V0, ZERO, 0x9D001100
9D001098  8E430018   LW V1, 24(S2)
1311:                			break;
1312:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D00109C  8E470014   LW A3, 20(S2)
1313:                		c = dir[DIR_Name];
1314:                		if (c == 0) {
9D0010A0  90E30000   LBU V1, 0(A3)
9D0010A4  50600046   BEQL V1, ZERO, 0x9D0011C0
9D0010A8  8E420018   LW V0, 24(S2)
1315:                			res = FR_NO_FILE;
1316:                			break;
1317:                		} /* Reached to end of table */
1318:                #if _USE_LFN	/* LFN configuration */
1319:                		a = dir[DIR_Attr] & AM_MASK;
1320:                		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1321:                			ord = 0xFF;
1322:                		} else {
1323:                			if (a == AM_LFN) { /* An LFN entry is found */
1324:                				if (dj->lfn) {
1325:                					if (c & LLE) { /* Is it start of LFN sequence? */
1326:                						sum = dir[LDIR_Chksum];
1327:                						c &= ~LLE; ord = c; /* LFN start order */
1328:                						dj->lfn_idx = dj->index;
1329:                					}
1330:                					/* Check validity of the LFN entry and compare it with given name */
1331:                					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1332:                				}
1333:                			} else { /* An SFN entry is found */
1334:                				if (!ord && sum == sum_sfn(dir)) break; /* LFN matched? */
1335:                				ord = 0xFF; dj->lfn_idx = 0xFFFF; /* Reset LFN sequence */
1336:                				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break; /* SFN matched? */
1337:                			}
1338:                		}
1339:                #else		/* Non LFN configuration */
1340:                		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
9D0010AC  90E9000B   LBU T1, 11(A3)
9D0010B0  31230008   ANDI V1, T1, 8
9D0010B4  1460000C   BNE V1, ZERO, 0x9D0010E8
9D0010B8  00E01821   ADDU V1, A3, ZERO
9D0010BC  8E4A0018   LW T2, 24(S2)
1341:                			break;
1342:                #endif
1343:                		res = dir_next(dj, 0); /* Next entry */
9D0010E8  02402021   ADDU A0, S2, ZERO
9D0010EC  0F400302   JAL 0x9D000C08
9D0010F0  00002821   ADDU A1, ZERO, ZERO
1344:                	} while (res == FR_OK);
9D0010F4  5040FFE5   BEQL V0, ZERO, 0x9D00108C
9D0010F8  8E440000   LW A0, 0(S2)
1345:                
1346:                	return res;
1347:                }
1348:                
1349:                /*-----------------------------------------------------------------------*/
1350:                /* Read an object from the directory                                     */
1351:                /*-----------------------------------------------------------------------*/
1352:                #if _FS_MINIMIZE <= 1
1353:                static FRESULT dir_read(DIR *dj /* Pointer to the directory object that pointing the entry to be read */
1354:                ) {
9D00129C  27BDFFE0   ADDIU SP, SP, -32
9D0012A0  AFBF001C   SW RA, 28(SP)
9D0012A4  AFB20018   SW S2, 24(SP)
9D0012A8  AFB10014   SW S1, 20(SP)
9D0012AC  AFB00010   SW S0, 16(SP)
9D0012B0  00808021   ADDU S0, A0, ZERO
1355:                	FRESULT res;
1356:                	PF_BYTE c, *dir;
1357:                #if _USE_LFN
1358:                	PF_BYTE a, ord = 0xFF, sum = 0xFF;
1359:                #endif
1360:                
1361:                	res = FR_NO_FILE;
9D0012B4  24020004   ADDIU V0, ZERO, 4
1362:                	while (dj->sect) {
9D0012BC  0B4004C5   J 0x9D001314
9D0012C0  2412002E   ADDIU S2, ZERO, 46
9D001314  8E050010   LW A1, 16(S0)
9D001318  14A0FFEA   BNE A1, ZERO, 0x9D0012C4
9D00131C  00000000   NOP
1363:                		res = move_window(dj->fs, dj->sect);
9D0012C4  0F400082   JAL 0x9D000208
9D0012C8  8E040000   LW A0, 0(S0)
1364:                		if (res != FR_OK)
9D0012CC  54400017   BNEL V0, ZERO, 0x9D00132C
9D0012D0  AE000010   SW ZERO, 16(S0)
1365:                			break;
1366:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D0012D4  8E040014   LW A0, 20(S0)
1367:                		c = dir[DIR_Name];
9D0012D8  90830000   LBU V1, 0(A0)
1368:                		if (c == 0) {
9D0012DC  50600012   BEQL V1, ZERO, 0x9D001328
9D0012E0  24020004   ADDIU V0, ZERO, 4
1369:                			res = FR_NO_FILE;
1370:                			break;
1371:                		} /* Reached to end of table */
1372:                #if _USE_LFN	/* LFN configuration */
1373:                		a = dir[DIR_Attr] & AM_MASK;
1374:                		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1375:                			ord = 0xFF;
1376:                		} else {
1377:                			if (a == AM_LFN) { /* An LFN entry is found */
1378:                				if (c & LLE) { /* Is it start of LFN sequence? */
1379:                					sum = dir[LDIR_Chksum];
1380:                					c &= ~LLE; ord = c;
1381:                					dj->lfn_idx = dj->index;
1382:                				}
1383:                				/* Check LFN validity and capture it */
1384:                				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1385:                			} else { /* An SFN entry is found */
1386:                				if (ord || sum != sum_sfn(dir)) /* Is there a valid LFN? */
1387:                				dj->lfn_idx = 0xFFFF; /* It has no LFN. */
1388:                				break;
1389:                			}
1390:                		}
1391:                #else		/* Non LFN configuration */
1392:                		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL)) /* Is it a valid entry? */
9D0012B8  241100E5   ADDIU S1, ZERO, 229
9D0012E4  50710007   BEQL V1, S1, 0x9D001304
9D0012E8  02002021   ADDU A0, S0, ZERO
9D0012EC  50720005   BEQL V1, S2, 0x9D001304
9D0012F0  02002021   ADDU A0, S0, ZERO
9D0012F4  9083000B   LBU V1, 11(A0)
9D0012F8  30630008   ANDI V1, V1, 8
9D0012FC  1060000B   BEQ V1, ZERO, 0x9D00132C
9D001300  02002021   ADDU A0, S0, ZERO
1393:                			break;
1394:                #endif
1395:                		res = dir_next(dj, 0); /* Next entry */
9D001304  0F400302   JAL 0x9D000C08
9D001308  00002821   ADDU A1, ZERO, ZERO
1396:                		if (res != FR_OK)
9D00130C  54400007   BNEL V0, ZERO, 0x9D00132C
9D001310  AE000010   SW ZERO, 16(S0)
1397:                			break;
1398:                	}
1399:                
1400:                	if (res != FR_OK)
9D001320  10400003   BEQ V0, ZERO, 0x9D001330
9D001324  8FBF001C   LW RA, 28(SP)
1401:                		dj->sect = 0;
9D001328  AE000010   SW ZERO, 16(S0)
1402:                
1403:                	return res;
1404:                }
9D00132C  8FBF001C   LW RA, 28(SP)
9D001330  8FB20018   LW S2, 24(SP)
9D001334  8FB10014   LW S1, 20(SP)
9D001338  8FB00010   LW S0, 16(SP)
9D00133C  03E00008   JR RA
9D001340  27BD0020   ADDIU SP, SP, 32
1405:                #endif
1406:                
1407:                /*-----------------------------------------------------------------------*/
1408:                /* Register an object to the directory                                   */
1409:                /*-----------------------------------------------------------------------*/
1410:                #if !_FS_READONLY
1411:                static FRESULT dir_register( /* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
1412:                DIR *dj /* Target directory with object name to be created */
1413:                ) {
9D0011C8  27BDFFE0   ADDIU SP, SP, -32
9D0011CC  AFBF001C   SW RA, 28(SP)
9D0011D0  AFB20018   SW S2, 24(SP)
9D0011D4  AFB10014   SW S1, 20(SP)
9D0011D8  AFB00010   SW S0, 16(SP)
9D0011DC  00808821   ADDU S1, A0, ZERO
1414:                	FRESULT res;
1415:                	PF_BYTE c, *dir;
1416:                #if _USE_LFN	/* LFN configuration */
1417:                	PF_WORD n, ne, is;
1418:                	PF_BYTE sn[12], *fn, sum;
1419:                	WCHAR *lfn;
1420:                
1421:                	fn = dj->fn; lfn = dj->lfn;
1422:                	mem_cpy(sn, fn, 12);
1423:                
1424:                	if (_FS_RPATH && (sn[NS] & NS_DOT)) /* Cannot create dot entry */
1425:                	return FR_INVALID_NAME;
1426:                
1427:                	if (sn[NS] & NS_LOSS) { /* When LFN is out of 8.3 format, generate a numbered name */
1428:                		fn[NS] = 0; dj->lfn = 0; /* Find only SFN */
1429:                		for (n = 1; n < 100; n++) {
1430:                			gen_numname(fn, sn, lfn, n); /* Generate a numbered name */
1431:                			res = dir_find(dj); /* Check if the name collides with existing SFN */
1432:                			if (res != FR_OK) break;
1433:                		}
1434:                		if (n == 100) return FR_DENIED; /* Abort if too many collisions */
1435:                		if (res != FR_NO_FILE) return res; /* Abort if the result is other than 'not collided' */
1436:                		fn[NS] = sn[NS]; dj->lfn = lfn;
1437:                	}
1438:                
1439:                	if (sn[NS] & NS_LFN) { /* When LFN is to be created, reserve an SFN + LFN entries. */
1440:                		for (ne = 0; lfn[ne]; ne++);
1441:                		ne = (ne + 25) / 13;
1442:                	} else { /* Otherwise reserve only an SFN entry. */
1443:                		ne = 1;
1444:                	}
1445:                
1446:                	/* Reserve contiguous entries */
1447:                	res = dir_sdi(dj, 0);
1448:                	if (res != FR_OK) return res;
1449:                	n = is = 0;
1450:                	do {
1451:                		res = move_window(dj->fs, dj->sect);
1452:                		if (res != FR_OK) break;
1453:                		c = *dj->dir; /* Check the entry status */
1454:                		if (c == DDE || c == 0) { /* Is it a blank entry? */
1455:                			if (n == 0) is = dj->index; /* First index of the contiguous entry */
1456:                			if (++n == ne) break; /* A contiguous entry that required count is found */
1457:                		} else {
1458:                			n = 0; /* Not a blank entry. Restart to search */
1459:                		}
1460:                		res = dir_next(dj, 1); /* Next entry with table stretch */
1461:                	}while (res == FR_OK);
1462:                
1463:                	if (res == FR_OK && ne > 1) { /* Initialize LFN entry if needed */
1464:                		res = dir_sdi(dj, is);
1465:                		if (res == FR_OK) {
1466:                			sum = sum_sfn(dj->fn); /* Sum of the SFN tied to the LFN */
1467:                			ne--;
1468:                			do { /* Store LFN entries in bottom first */
1469:                				res = move_window(dj->fs, dj->sect);
1470:                				if (res != FR_OK) break;
1471:                				fit_lfn(dj->lfn, dj->dir, (PF_BYTE)ne, sum);
1472:                				dj->fs->wflag = 1;
1473:                				res = dir_next(dj, 0); /* Next entry */
1474:                			}while (res == FR_OK && --ne);
1475:                		}
1476:                	}
1477:                
1478:                #else	/* Non LFN configuration */
1479:                	res = dir_sdi(dj, 0);
9D0011E0  0F4001C3   JAL 0x9D00070C
9D0011E4  00002821   ADDU A1, ZERO, ZERO
1480:                	if (res == FR_OK) {
9D0011E8  1440001E   BNE V0, ZERO, 0x9D001264
9D0011EC  00408021   ADDU S0, V0, ZERO
1481:                		do { /* Find a blank entry for the SFN */
1482:                			res = move_window(dj->fs, dj->sect);
9D0011F4  8E240000   LW A0, 0(S1)
9D0011F8  0F400082   JAL 0x9D000208
9D0011FC  8E250010   LW A1, 16(S1)
1483:                			if (res != FR_OK)
9D001200  14400018   BNE V0, ZERO, 0x9D001264
9D001204  00408021   ADDU S0, V0, ZERO
1484:                				break;
1485:                			c = *dj->dir;
9D001208  8E220014   LW V0, 20(S1)
9D00120C  90420000   LBU V0, 0(V0)
1486:                			if (c == DDE || c == 0)
9D0011F0  241200E5   ADDIU S2, ZERO, 229
9D001210  5052001C   BEQL V0, S2, 0x9D001284
9D001214  8E240000   LW A0, 0(S1)
9D001218  10400019   BEQ V0, ZERO, 0x9D001280
9D00121C  02202021   ADDU A0, S1, ZERO
1487:                				break; /* Is it a blank entry? */
1488:                			res = dir_next(dj, 1); /* Next entry with table stretch */
9D001220  0F400302   JAL 0x9D000C08
9D001224  24050001   ADDIU A1, ZERO, 1
1489:                		} while (res == FR_OK);
9D001228  1040FFF2   BEQ V0, ZERO, 0x9D0011F4
9D00122C  00408021   ADDU S0, V0, ZERO
1490:                	}
1491:                #endif
1492:                
1493:                	if (res == FR_OK) { /* Initialize the SFN entry */
1494:                		res = move_window(dj->fs, dj->sect);
9D001280  8E240000   LW A0, 0(S1)
9D001284  0F400082   JAL 0x9D000208
9D001288  8E250010   LW A1, 16(S1)
1495:                		if (res == FR_OK) {
9D00128C  1440FFF5   BNE V0, ZERO, 0x9D001264
9D001290  00408021   ADDU S0, V0, ZERO
1496:                			dir = dj->dir;
9D001294  0B40048E   J 0x9D001238
9D001298  8E320014   LW S2, 20(S1)
1497:                			mem_set(dir, 0, SZ_DIR); /* Clean the entry */
9D001238  02402021   ADDU A0, S2, ZERO
9D00123C  00002821   ADDU A1, ZERO, ZERO
9D001240  0F400012   JAL 0x9D000048
9D001244  24060020   ADDIU A2, ZERO, 32
1498:                			mem_cpy(dir, dj->fn, 11); /* Put SFN */
9D001248  02402021   ADDU A0, S2, ZERO
9D00124C  8E250018   LW A1, 24(S1)
9D001250  0F400008   JAL 0x9D000020
9D001254  2406000B   ADDIU A2, ZERO, 11
1499:                #if _USE_LFN
1500:                			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT); /* Put NT flag */
1501:                #endif
1502:                			dj->fs->wflag = 1;
9D001258  8E220000   LW V0, 0(S1)
9D00125C  24030001   ADDIU V1, ZERO, 1
9D001260  A0430004   SB V1, 4(V0)
1503:                		}
1504:                	}
1505:                
1506:                	return res;
1507:                }
9D001230  0B40049A   J 0x9D001268
9D001234  02001021   ADDU V0, S0, ZERO
9D001264  02001021   ADDU V0, S0, ZERO
9D001268  8FBF001C   LW RA, 28(SP)
9D00126C  8FB20018   LW S2, 24(SP)
9D001270  8FB10014   LW S1, 20(SP)
9D001274  8FB00010   LW S0, 16(SP)
9D001278  03E00008   JR RA
9D00127C  27BD0020   ADDIU SP, SP, 32
1508:                #endif /* !_FS_READONLY */
1509:                
1510:                /*-----------------------------------------------------------------------*/
1511:                /* Remove an object from the directory                                   */
1512:                /*-----------------------------------------------------------------------*/
1513:                #if !_FS_READONLY && !_FS_MINIMIZE
1514:                static FRESULT dir_remove( /* FR_OK: Successful, FR_DISK_ERR: A disk error */
1515:                DIR *dj /* Directory object pointing the entry to be removed */
1516:                ) {
9D000870  27BDFFE8   ADDIU SP, SP, -24
9D000874  AFBF0014   SW RA, 20(SP)
9D000878  AFB00010   SW S0, 16(SP)
9D00087C  00808021   ADDU S0, A0, ZERO
1517:                	FRESULT res;
1518:                #if _USE_LFN	/* LFN configuration */
1519:                	PF_WORD i;
1520:                
1521:                	i = dj->index; /* SFN index */
1522:                	res = dir_sdi(dj, (PF_WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx)); /* Goto the SFN or top of the LFN entries */
1523:                	if (res == FR_OK) {
1524:                		do {
1525:                			res = move_window(dj->fs, dj->sect);
1526:                			if (res != FR_OK) break;
1527:                			*dj->dir = DDE; /* Mark the entry "deleted" */
1528:                			dj->fs->wflag = 1;
1529:                			if (dj->index >= i) break; /* When reached SFN, all entries of the object has been deleted. */
1530:                			res = dir_next(dj, 0); /* Next entry */
1531:                		}while (res == FR_OK);
1532:                		if (res == FR_NO_FILE) res = FR_INT_ERR;
1533:                	}
1534:                
1535:                #else			/* Non LFN configuration */
1536:                	res = dir_sdi(dj, dj->index);
9D000880  0F4001C3   JAL 0x9D00070C
9D000884  94850006   LHU A1, 6(A0)
1537:                	if (res == FR_OK) {
9D000888  1440000C   BNE V0, ZERO, 0x9D0008BC
9D00088C  8FBF0014   LW RA, 20(SP)
1538:                		res = move_window(dj->fs, dj->sect);
9D000890  8E040000   LW A0, 0(S0)
9D000894  0F400082   JAL 0x9D000208
9D000898  8E050010   LW A1, 16(S0)
1539:                		if (res == FR_OK) {
9D00089C  14400006   BNE V0, ZERO, 0x9D0008B8
9D0008A0  2404FFE5   ADDIU A0, ZERO, -27
1540:                			*dj->dir = DDE; /* Mark the entry "deleted" */
9D0008A4  8E030014   LW V1, 20(S0)
9D0008A8  A0640000   SB A0, 0(V1)
1541:                			dj->fs->wflag = 1;
9D0008AC  8E030000   LW V1, 0(S0)
9D0008B0  24040001   ADDIU A0, ZERO, 1
9D0008B4  A0640004   SB A0, 4(V1)
1542:                		}
1543:                	}
1544:                #endif
1545:                
1546:                	return res;
1547:                }
9D0008B8  8FBF0014   LW RA, 20(SP)
9D0008BC  8FB00010   LW S0, 16(SP)
9D0008C0  03E00008   JR RA
9D0008C4  27BD0018   ADDIU SP, SP, 24
1548:                #endif /* !_FS_READONLY */
1549:                
1550:                /*-----------------------------------------------------------------------*/
1551:                /* Pick a segment and create the object name in directory form           */
1552:                /*-----------------------------------------------------------------------*/
1553:                
1554:                static FRESULT create_name(DIR *dj, /* Pointer to the directory object */
1555:                const TCHAR **path /* Pointer to pointer to the segment in the path string */
1556:                ) {
1557:                #ifdef _EXCVT
1558:                	static const PF_BYTE excvt[] = _EXCVT; /* Upper conversion table for extended chars */
1559:                #endif
1560:                
1561:                #if _USE_LFN	/* LFN configuration */
1562:                	PF_BYTE b, cf;
1563:                	WCHAR w, *lfn;
1564:                	UINT i, ni, si, di;
1565:                	const TCHAR *p;
1566:                
1567:                	/* Create LFN in Unicode */
1568:                	for (p = *path; *p == '/' || *p == '\\'; p++); /* Strip duplicated separator */
1569:                	lfn = dj->lfn;
1570:                	si = di = 0;
1571:                	for (;;) {
1572:                		w = p[si++]; /* Get a character */
1573:                		if (w < ' ' || w == '/' || w == '\\') break; /* Break on end of segment */
1574:                		if (di >= _MAX_LFN) /* Reject too long name */
1575:                		return FR_INVALID_NAME;
1576:                #if !_LFN_UNICODE
1577:                		w &= 0xFF;
1578:                		if (IsDBCS1(w)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1579:                			b = (PF_BYTE)p[si++]; /* Get 2nd byte */
1580:                			if (!IsDBCS2(b))
1581:                			return FR_INVALID_NAME; /* Reject invalid sequence */
1582:                			w = (w << 8) + b; /* Create a DBC */
1583:                		}
1584:                		w = ff_convert(w, 1); /* Convert ANSI/OEM to Unicode */
1585:                		if (!w) return FR_INVALID_NAME; /* Reject invalid code */
1586:                #endif
1587:                		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
1588:                		return FR_INVALID_NAME;
1589:                		lfn[di++] = w; /* Store the Unicode char */
1590:                	}
1591:                	*path = &p[si]; /* Return pointer to the next segment */
1592:                	cf = (w < ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
1593:                #if _FS_RPATH
1594:                	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
1595:                			(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
1596:                		lfn[di] = 0;
1597:                		for (i = 0; i < 11; i++)
1598:                		dj->fn[i] = (i < di) ? '.' : ' ';
1599:                		dj->fn[i] = cf | NS_DOT; /* This is a dot entry */
1600:                		return FR_OK;
1601:                	}
1602:                #endif
1603:                	while (di) { /* Strip trailing spaces and dots */
1604:                		w = lfn[di-1];
1605:                		if (w != ' ' && w != '.') break;
1606:                		di--;
1607:                	}
1608:                	if (!di) return FR_INVALID_NAME; /* Reject nul string */
1609:                
1610:                	lfn[di] = 0; /* LFN is created */
1611:                
1612:                	/* Create SFN in directory form */
1613:                	mem_set(dj->fn, ' ', 11);
1614:                	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++); /* Strip leading spaces and dots */
1615:                	if (si) cf |= NS_LOSS | NS_LFN;
1616:                	while (di && lfn[di - 1] != '.') di--; /* Find extension (di<=si: no extension) */
1617:                
1618:                	b = i = 0; ni = 8;
1619:                	for (;;) {
1620:                		w = lfn[si++]; /* Get an LFN char */
1621:                		if (!w) break; /* Break on end of the LFN */
1622:                		if (w == ' ' || (w == '.' && si != di)) { /* Remove spaces and dots */
1623:                			cf |= NS_LOSS | NS_LFN; continue;
1624:                		}
1625:                
1626:                		if (i >= ni || si == di) { /* Extension or end of SFN */
1627:                			if (ni == 11) { /* Long extension */
1628:                				cf |= NS_LOSS | NS_LFN; break;
1629:                			}
1630:                			if (si != di) cf |= NS_LOSS | NS_LFN; /* Out of 8.3 format */
1631:                			if (si > di) break; /* No extension */
1632:                			si = di; i = 8; ni = 11; /* Enter extension section */
1633:                			b <<= 2; continue;
1634:                		}
1635:                
1636:                		if (w >= 0x80) { /* Non ASCII char */
1637:                #ifdef _EXCVT
1638:                			w = ff_convert(w, 0); /* Unicode -> OEM code */
1639:                			if (w) w = excvt[w - 0x80]; /* Convert extended char to upper (SBCS) */
1640:                #else
1641:                			w = ff_convert(ff_wtoupper(w), 0); /* Upper converted Unicode -> OEM code */
1642:                #endif
1643:                			cf |= NS_LFN; /* Force create LFN entry */
1644:                		}
1645:                
1646:                		if (_DF1S && w >= 0x100) { /* Double byte char (always false on SBCS cfg) */
1647:                			if (i >= ni - 1) {
1648:                				cf |= NS_LOSS | NS_LFN; i = ni; continue;
1649:                			}
1650:                			dj->fn[i++] = (PF_BYTE)(w >> 8);
1651:                		} else { /* Single byte char */
1652:                			if (!w || chk_chr("+,;=[]", w)) { /* Replace illegal chars for SFN */
1653:                				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
1654:                			} else {
1655:                				if (IsUpper(w)) { /* ASCII large capital */
1656:                					b |= 2;
1657:                				} else {
1658:                					if (IsLower(w)) { /* ASCII small capital */
1659:                						b |= 1; w -= 0x20;
1660:                					}
1661:                				}
1662:                			}
1663:                		}
1664:                		dj->fn[i++] = (PF_BYTE)w;
1665:                	}
1666:                
1667:                	if (dj->fn[0] == DDE) dj->fn[0] = NDDE; /* If the first char collides with deleted mark, replace it with 0x05 */
1668:                
1669:                	if (ni == 8) b <<= 2;
1670:                	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) /* Create LFN entry when there are composite capitals */
1671:                	cf |= NS_LFN;
1672:                	if (!(cf & NS_LFN)) { /* When LFN is in 8.3 format without extended char, NT flags are created */
1673:                		if ((b & 0x03) == 0x01) cf |= NS_EXT; /* NT flag (Extension has only small capital) */
1674:                		if ((b & 0x0C) == 0x04) cf |= NS_BODY; /* NT flag (Filename has only small capital) */
1675:                	}
1676:                
1677:                	dj->fn[NS] = cf; /* SFN is created */
1678:                
1679:                	return FR_OK;
1680:                
1681:                #else	/* Non-LFN configuration */
1682:                	PF_BYTE b, c, d, *sfn;
1683:                	UINT ni, si, i;
1684:                	const char *p;
1685:                
1686:                	/* Create file name in directory form */
1687:                	for (p = *path; *p == '/' || *p == '\\'; p++)
9D000E84  2413005C   ADDIU S3, ZERO, 92
9D000E94  82020000   LB V0, 0(S0)
9D000E98  5051FFFE   BEQL V0, S1, 0x9D000E94
9D000E9C  26100001   ADDIU S0, S0, 1
9D000EA0  5053FFFC   BEQL V0, S3, 0x9D000E94
9D000EA4  26100001   ADDIU S0, S0, 1
1688:                		; /* Strip duplicated separator */
1689:                	sfn = dj->fn;
9D000EA8  8E550018   LW S5, 24(S2)
1690:                	mem_set(sfn, ' ', 11);
9D000EAC  02A02021   ADDU A0, S5, ZERO
9D000EB0  24050020   ADDIU A1, ZERO, 32
9D000EB4  0F400012   JAL 0x9D000048
9D000EB8  2406000B   ADDIU A2, ZERO, 11
1691:                	si = i = b = 0;
9D000EBC  00003021   ADDU A2, ZERO, ZERO
9D000EC0  00001821   ADDU V1, ZERO, ZERO
9D000EC8  00004021   ADDU T0, ZERO, ZERO
1692:                	ni = 8;
9D000EC4  24040008   ADDIU A0, ZERO, 8
1693:                #if _FS_RPATH
1694:                	if (p[si] == '.') { /* Is this a dot entry? */
1695:                		for (;;) {
1696:                			c = (PF_BYTE)p[si++];
1697:                			if (c != '.' || si >= 3) break;
1698:                			sfn[i++] = c;
1699:                		}
1700:                		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
1701:                		*path = &p[si]; /* Return pointer to the next segment */
1702:                		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT; /* Set last segment flag if end of path */
1703:                		return FR_OK;
1704:                	}
1705:                #endif
1706:                	for (;;) {
1707:                		c = (PF_BYTE) p[si++];
9D000ED0  02031021   ADDU V0, S0, V1
9D000ED4  80450000   LB A1, 0(V0)
9D000ED8  30A200FF   ANDI V0, A1, 255
1708:                		if (c <= ' ' || c == '/' || c == '\\')
9D000EDC  2C470021   SLTIU A3, V0, 33
9D000EE0  14E0004C   BNE A3, ZERO, 0x9D001014
9D000EE4  24630001   ADDIU V1, V1, 1
9D000EE8  505100AE   BEQL V0, S1, 0x9D0011A4
9D000EEC  02038021   ADDU S0, S0, V1
9D000EF0  505300AC   BEQL V0, S3, 0x9D0011A4
9D000EF4  02038021   ADDU S0, S0, V1
1709:                			break; /* Break on end of segment */
1710:                		if (c == '.' || i >= ni) {
9D000E88  2414002E   ADDIU S4, ZERO, 46
9D000EF8  10540003   BEQ V0, S4, 0x9D000F08
9D000EFC  00C4382B   SLTU A3, A2, A0
9D000F00  14E0000A   BNE A3, ZERO, 0x9D000F2C
9D000F04  35070003   ORI A3, T0, 3
1711:                			if (ni != 8 || c != '.')
9D000ECC  24090008   ADDIU T1, ZERO, 8
9D000F08  5489009B   BNEL A0, T1, 0x9D001178
9D000F0C  24020006   ADDIU V0, ZERO, 6
9D000F10  14540099   BNE V0, S4, 0x9D001178
9D000F14  24020006   ADDIU V0, ZERO, 6
1712:                				return FR_INVALID_NAME;
1713:                			i = 8;
9D000F20  01203021   ADDU A2, T1, ZERO
1714:                			ni = 11;
9D000F24  0B4003B4   J 0x9D000ED0
9D000F28  2404000B   ADDIU A0, ZERO, 11
1715:                			b <<= 2;
9D000F18  00084080   SLL T0, T0, 2
9D000F1C  310800FF   ANDI T0, T0, 255
1716:                			continue;
1717:                		}
1718:                		if (c >= 0x80) { /* Extended char? */
1719:                			b |= 3; /* Eliminate NT flag */
9D000F2C  28A50000   SLTI A1, A1, 0
9D000F30  00E5400B   MOVN T0, A3, A1
1720:                #ifdef _EXCVT
1721:                			c = excvt[c-0x80]; /* Upper conversion (SBCS) */
1722:                #else
1723:                #if !_DF1S	/* ASCII only cfg */
1724:                			return FR_INVALID_NAME;
1725:                #endif
1726:                #endif
1727:                		}
1728:                		if (IsDBCS1(c)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
9D000F34  2445007F   ADDIU A1, V0, 127
9D000F38  30A500FF   ANDI A1, A1, 255
9D000F3C  2CA5001F   SLTIU A1, A1, 31
9D000F40  14A00006   BNE A1, ZERO, 0x9D000F5C
9D000F44  02032821   ADDU A1, S0, V1
9D000F48  24450020   ADDIU A1, V0, 32
9D000F4C  30A500FF   ANDI A1, A1, 255
9D000F50  2CA5001D   SLTIU A1, A1, 29
9D000F54  10A00013   BEQ A1, ZERO, 0x9D000FA4
9D000F58  02032821   ADDU A1, S0, V1
1729:                			d = (PF_BYTE) p[si++]; /* Get 2nd byte */
9D000F5C  90A50000   LBU A1, 0(A1)
1730:                			if (!IsDBCS2(d) || i >= ni - 1) /* Reject invalid DBC */
9D000F60  24A7FFC0   ADDIU A3, A1, -64
9D000F64  30E700FF   ANDI A3, A3, 255
9D000F68  2CE7003F   SLTIU A3, A3, 63
9D000F6C  14E00005   BNE A3, ZERO, 0x9D000F84
9D000F70  2487FFFF   ADDIU A3, A0, -1
9D000F74  38A70080   XORI A3, A1, 128
9D000F78  2CE7007D   SLTIU A3, A3, 125
9D000F7C  10E00077   BEQ A3, ZERO, 0x9D00115C
9D000F80  2487FFFF   ADDIU A3, A0, -1
9D000F84  00C7382B   SLTU A3, A2, A3
9D000F88  10E00076   BEQ A3, ZERO, 0x9D001164
9D000F8C  24630001   ADDIU V1, V1, 1
9D00115C  0B40045E   J 0x9D001178
9D001160  24020006   ADDIU V0, ZERO, 6
9D001164  0B40045E   J 0x9D001178
9D001168  24020006   ADDIU V0, ZERO, 6
1731:                				return FR_INVALID_NAME;
1732:                			sfn[i++] = c;
9D000F90  02A63821   ADDU A3, S5, A2
9D000F94  A0E20000   SB V0, 0(A3)
1733:                			sfn[i++] = d;
9D000F98  A0E50001   SB A1, 1(A3)
9D000F9C  0B4003B4   J 0x9D000ED0
9D000FA0  24C60002   ADDIU A2, A2, 2
1734:                		} else { /* Single byte code */
1735:                			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) /* Reject illegal chrs for SFN */
1736:                				return FR_INVALID_NAME;
1737:                			if (IsUpper(c)) { /* ASCII large capital? */
9D000FD0  30A500FF   ANDI A1, A1, 255
9D000FD4  2CA5001A   SLTIU A1, A1, 26
9D000FD8  10A00003   BEQ A1, ZERO, 0x9D000FE8
9D000FDC  2445FF9F   ADDIU A1, V0, -97
1738:                				b |= 2;
9D000FE0  0B400401   J 0x9D001004
9D000FE4  35080002   ORI T0, T0, 2
1739:                			} else {
1740:                				if (IsLower(c)) { /* ASCII small capital? */
9D000FE8  30A500FF   ANDI A1, A1, 255
9D000FEC  2CA5001A   SLTIU A1, A1, 26
9D000FF0  10A00005   BEQ A1, ZERO, 0x9D001008
9D000FF4  02A62821   ADDU A1, S5, A2
1741:                					b |= 1;
9D000FF8  35080001   ORI T0, T0, 1
1742:                					c -= 0x20;
9D000FFC  2442FFE0   ADDIU V0, V0, -32
9D001000  304200FF   ANDI V0, V0, 255
1743:                				}
1744:                			}
1745:                			sfn[i++] = c;
9D001004  02A62821   ADDU A1, S5, A2
9D001008  A0A20000   SB V0, 0(A1)
9D00100C  0B4003B4   J 0x9D000ED0
9D001010  24C60001   ADDIU A2, A2, 1
1746:                		}
1747:                	}
1748:                	*path = &p[si]; /* Return pointer to the next segment */
9D001014  02038021   ADDU S0, S0, V1
1749:                	c = (c <= ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
9D001018  24020004   ADDIU V0, ZERO, 4
9D0011A4  0B400407   J 0x9D00101C
9D0011A8  00001021   ADDU V0, ZERO, ZERO
1750:                
1751:                	if (!i)
9D00101C  10C00055   BEQ A2, ZERO, 0x9D001174
9D001020  240300E5   ADDIU V1, ZERO, 229
1752:                		return FR_INVALID_NAME; /* Reject nul string */
1753:                	if (sfn[0] == DDE)
9D001024  92A50000   LBU A1, 0(S5)
9D001028  14A30004   BNE A1, V1, 0x9D00103C
9D00102C  24030008   ADDIU V1, ZERO, 8
1754:                		sfn[0] = NDDE; /* When first char collides with DDE, replace it with 0x05 */
9D001030  24030005   ADDIU V1, ZERO, 5
9D001034  A2A30000   SB V1, 0(S5)
1755:                
1756:                	if (ni == 8)
9D001038  24030008   ADDIU V1, ZERO, 8
9D00103C  14830004   BNE A0, V1, 0x9D001050
9D001040  01002021   ADDU A0, T0, ZERO
1757:                		b <<= 2;
9D001044  00084080   SLL T0, T0, 2
9D001048  310800FF   ANDI T0, T0, 255
1758:                	if ((b & 0x03) == 0x01)
9D00104C  01002021   ADDU A0, T0, ZERO
9D001050  31080003   ANDI T0, T0, 3
1759:                		c |= NS_EXT; /* NT flag (Name extension has only small capital) */
9D001054  34430010   ORI V1, V0, 16
9D001058  39080001   XORI T0, T0, 1
9D00105C  0068100A   MOVZ V0, V1, T0
1760:                	if ((b & 0x0C) == 0x04)
9D001060  3084000C   ANDI A0, A0, 12
1761:                		c |= NS_BODY; /* NT flag (Name body has only small capital) */
9D001064  34430008   ORI V1, V0, 8
9D001068  38840004   XORI A0, A0, 4
9D00106C  0064100A   MOVZ V0, V1, A0
1762:                
1763:                	sfn[NS] = c; /* Store NT flag, File name is created */
9D001070  A2A2000B   SB V0, 11(S5)
1764:                
1765:                	return FR_OK;
1766:                #endif
1767:                }
1768:                
1769:                /*-----------------------------------------------------------------------*/
1770:                /* Get file information from directory entry                             */
1771:                /*-----------------------------------------------------------------------*/
1772:                #if _FS_MINIMIZE <= 1
1773:                static
1774:                void get_fileinfo( /* No return code */
9D00011C  00C41021   ADDU V0, A2, A0
1775:                DIR *dj, /* Pointer to the directory object */
1776:                FILINFO *fno /* Pointer to the file information to be filled */
1777:                ) {
1778:                	UINT i;
1779:                	PF_BYTE nt, *dir;
1780:                	TCHAR *p, c;
1781:                
1782:                	p = fno->fname;
1783:                	if (dj->sect) {
9D0000E8  8C820010   LW V0, 16(A0)
9D0000EC  10400039   BEQ V0, ZERO, 0x9D0001D4
9D0000F0  24A30009   ADDIU V1, A1, 9
1784:                		dir = dj->dir;
9D0000F4  8C860014   LW A2, 20(A0)
1785:                		nt = dir[DIR_NTres]; /* NT flag */
1786:                		for (i = 0; i < 8; i++) { /* Copy name body */
9D000110  24080008   ADDIU T0, ZERO, 8
9D000138  24840001   ADDIU A0, A0, 1
9D00013C  1488FFF7   BNE A0, T0, 0x9D00011C
9D000140  24630001   ADDIU V1, V1, 1
1787:                			c = dir[i];
9D0000F8  80C20000   LB V0, 0(A2)
9D000120  80420000   LB V0, 0(V0)
1788:                			if (c == ' ')
9D0000FC  24040020   ADDIU A0, ZERO, 32
9D000100  10440010   BEQ V0, A0, 0x9D000144
9D000104  00002021   ADDU A0, ZERO, ZERO
9D000114  0B40004B   J 0x9D00012C
9D000118  240B0020   ADDIU T3, ZERO, 32
9D000124  504B0008   BEQL V0, T3, 0x9D000148
9D000128  90C40008   LBU A0, 8(A2)
1789:                				break;
1790:                			if (c == NDDE)
9D000108  240A0005   ADDIU T2, ZERO, 5
1791:                				c = (TCHAR) DDE;
9D00010C  2409FFE5   ADDIU T1, ZERO, -27
9D00012C  004A3826   XOR A3, V0, T2
9D000130  0127100A   MOVZ V0, T1, A3
1792:                			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c))
1793:                				c += 0x20;
1794:                #if _LFN_UNICODE
1795:                			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
1796:                			c = (c << 8) | dir[++i];
1797:                			c = ff_convert(c, 1);
1798:                			if (!c) c = '?';
1799:                #endif
1800:                			*p++ = c;
9D000134  A0620000   SB V0, 0(V1)
1801:                		}
1802:                		if (dir[8] != ' ') { /* Copy name extension */
9D000144  90C40008   LBU A0, 8(A2)
9D000148  24020020   ADDIU V0, ZERO, 32
9D00014C  1082000A   BEQ A0, V0, 0x9D000178
9D000150  2402002E   ADDIU V0, ZERO, 46
1803:                			*p++ = '.';
9D000154  A0620000   SB V0, 0(V1)
1804:                			for (i = 8; i < 11; i++) {
1805:                				c = dir[i];
9D000158  80C20008   LB V0, 8(A2)
9D0001E0  80C20009   LB V0, 9(A2)
9D0001F4  80C2000A   LB V0, 10(A2)
1806:                				if (c == ' ')
9D00015C  24040020   ADDIU A0, ZERO, 32
9D000160  1444001E   BNE V0, A0, 0x9D0001DC
9D000164  24630001   ADDIU V1, V1, 1
9D0001E4  24040020   ADDIU A0, ZERO, 32
9D0001E8  1044FFE3   BEQ V0, A0, 0x9D000178
9D0001EC  24630001   ADDIU V1, V1, 1
9D0001F8  1444FFDD   BNE V0, A0, 0x9D000170
9D0001FC  24630001   ADDIU V1, V1, 1
1807:                					break;
1808:                				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c))
1809:                					c += 0x20;
1810:                #if _LFN_UNICODE
1811:                				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
1812:                				c = (c << 8) | dir[++i];
1813:                				c = ff_convert(c, 1);
1814:                				if (!c) c = '?';
1815:                #endif
1816:                				*p++ = c;
9D000170  A0620000   SB V0, 0(V1)
9D000174  24630001   ADDIU V1, V1, 1
9D0001DC  A0620000   SB V0, 0(V1)
9D0001F0  A0620000   SB V0, 0(V1)
1817:                			}
1818:                		}
1819:                		fno->fattrib = dir[DIR_Attr]; /* Attribute */
9D000168  0B40005F   J 0x9D00017C
9D00016C  90C2000B   LBU V0, 11(A2)
9D000178  90C2000B   LBU V0, 11(A2)
9D00017C  A0A20008   SB V0, 8(A1)
9D000200  0B40005F   J 0x9D00017C
9D000204  90C2000B   LBU V0, 11(A2)
1820:                		fno->fsize = LD_DWORD(dir+DIR_FileSize); /* Size */
9D000180  90C4001F   LBU A0, 31(A2)
9D000184  00042600   SLL A0, A0, 24
9D000188  90C2001E   LBU V0, 30(A2)
9D00018C  00021400   SLL V0, V0, 16
9D000190  00821025   OR V0, A0, V0
9D000194  90C4001C   LBU A0, 28(A2)
9D000198  00441025   OR V0, V0, A0
9D00019C  90C4001D   LBU A0, 29(A2)
9D0001A0  00042200   SLL A0, A0, 8
9D0001A4  00441025   OR V0, V0, A0
9D0001A8  ACA20000   SW V0, 0(A1)
1821:                		fno->fdate = LD_WORD(dir+DIR_WrtDate); /* Date */
9D0001AC  90C20019   LBU V0, 25(A2)
9D0001B0  00021200   SLL V0, V0, 8
9D0001B4  90C40018   LBU A0, 24(A2)
9D0001B8  00441025   OR V0, V0, A0
9D0001BC  A4A20004   SH V0, 4(A1)
1822:                		fno->ftime = LD_WORD(dir+DIR_WrtTime); /* Time */
9D0001C0  90C20017   LBU V0, 23(A2)
9D0001C4  00021200   SLL V0, V0, 8
9D0001C8  90C40016   LBU A0, 22(A2)
9D0001CC  00441025   OR V0, V0, A0
9D0001D0  A4A20006   SH V0, 6(A1)
1823:                	}
1824:                	*p = 0; /* Terminate SFN str by a \0 */
1825:                
1826:                #if _USE_LFN
1827:                	if (fno->lfname && fno->lfsize) {
1828:                		TCHAR *tp = fno->lfname;
1829:                		WCHAR w, *lfn;
1830:                
1831:                		i = 0;
1832:                		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
1833:                			lfn = dj->lfn;
1834:                			while ((w = *lfn++) != 0) { /* Get an LFN char */
1835:                #if !_LFN_UNICODE
1836:                				w = ff_convert(w, 0); /* Unicode -> OEM conversion */
1837:                				if (!w) {i = 0; break;} /* Could not convert, no LFN */
1838:                				if (_DF1S && w >= 0x100) /* Put 1st byte if it is a DBC (always false on SBCS cfg) */
1839:                				tp[i++] = (TCHAR)(w >> 8);
1840:                #endif
1841:                				if (i >= fno->lfsize - 1) {i = 0; break;} /* Buffer overflow, no LFN */
1842:                				tp[i++] = (TCHAR)w;
1843:                			}
1844:                		}
1845:                		tp[i] = 0; /* Terminate the LFN str by a \0 */
1846:                	}
1847:                #endif
1848:                }
9D0001D4  03E00008   JR RA
9D0001D8  A0600000   SB ZERO, 0(V1)
1849:                #endif /* _FS_MINIMIZE <= 1 */
1850:                
1851:                /*-----------------------------------------------------------------------*/
1852:                /* Follow a file path                                                    */
1853:                /*-----------------------------------------------------------------------*/
1854:                
1855:                static FRESULT follow_path( /* FR_OK(0): successful, !=0: error code */
9D0010C4  0B400435   J 0x9D0010D4
9D0010C8  24E8000B   ADDIU T0, A3, 11
1856:                DIR *dj, /* Directory object to return last directory and found object */
1857:                const TCHAR *path /* Full-path string to find a file or directory */
1858:                ) {
9D000E10  27BDFFC8   ADDIU SP, SP, -56
9D000E14  AFBF0034   SW RA, 52(SP)
9D000E18  AFB70030   SW S7, 48(SP)
9D000E1C  AFB6002C   SW S6, 44(SP)
9D000E20  AFB50028   SW S5, 40(SP)
9D000E24  AFB40024   SW S4, 36(SP)
9D000E28  AFB30020   SW S3, 32(SP)
9D000E2C  AFB2001C   SW S2, 28(SP)
9D000E30  AFB10018   SW S1, 24(SP)
9D000E34  AFB00014   SW S0, 20(SP)
9D000E38  00809021   ADDU S2, A0, ZERO
1859:                	FRESULT res;
1860:                	PF_BYTE *dir, ns;
1861:                
1862:                #if _FS_RPATH
1863:                	if (*path == '/' || *path == '\\') { /* There is a heading separator */
1864:                		path++; dj->sclust = 0; /* Strip it and start from the root dir */
1865:                	} else { /* No heading separator */
1866:                		dj->sclust = dj->fs->cdir; /* Start from the current dir */
1867:                	}
1868:                #else
1869:                	if (*path == '/' || *path == '\\') /* Strip heading separator if exist */
9D000E3C  80A20000   LB V0, 0(A1)
9D000E40  2403002F   ADDIU V1, ZERO, 47
9D000E44  10430004   BEQ V0, V1, 0x9D000E58
9D000E48  00A08021   ADDU S0, A1, ZERO
9D000E4C  2403005C   ADDIU V1, ZERO, 92
9D000E50  54430003   BNEL V0, V1, 0x9D000E60
9D000E54  AE400008   SW ZERO, 8(S2)
1870:                		path++;
9D000E58  26100001   ADDIU S0, S0, 1
1871:                	dj->sclust = 0; /* Start from the root dir */
9D000E5C  AE400008   SW ZERO, 8(S2)
1872:                #endif
1873:                
1874:                	if ((UINT) *path < ' ') { /* Nul path means the start directory itself */
9D000E60  92020000   LBU V0, 0(S0)
9D000E64  2C420020   SLTIU V0, V0, 32
9D000E68  10400006   BEQ V0, ZERO, 0x9D000E84
9D000E6C  2411002F   ADDIU S1, ZERO, 47
1875:                		res = dir_sdi(dj, 0);
9D000E70  02402021   ADDU A0, S2, ZERO
9D000E74  0F4001C3   JAL 0x9D00070C
9D000E78  00002821   ADDU A1, ZERO, ZERO
1876:                		dj->dir = 0;
9D000E7C  0B40045E   J 0x9D001178
9D000E80  AE400014   SW ZERO, 20(S2)
1877:                
1878:                	} else { /* Follow path */
1879:                		for (;;) {
1880:                			res = create_name(dj, &path); /* Get a segment */
1881:                			if (res != FR_OK)
1882:                				break;
1883:                			res = dir_find(dj); /* Find it */
9D001114  24030004   ADDIU V1, ZERO, 4
9D001118  24020005   ADDIU V0, ZERO, 5
9D00111C  0B40045E   J 0x9D001178
9D001120  0064100B   MOVN V0, V1, A0
1884:                			ns = *(dj->fn + NS);
9D0010FC  8E430018   LW V1, 24(S2)
9D001100  9064000B   LBU A0, 11(V1)
9D0011C0  0B400444   J 0x9D001110
9D0011C4  9044000B   LBU A0, 11(V0)
1885:                			if (res != FR_OK) { /* Failed to find the object */
1886:                				if (res != FR_NO_FILE)
9D001104  24030004   ADDIU V1, ZERO, 4
9D001108  1443001C   BNE V0, V1, 0x9D00117C
9D00110C  8FBF0034   LW RA, 52(SP)
1887:                					break; /* Abort if any hard error occured */
1888:                				/* Object not found */
1889:                				if (_FS_RPATH && (ns & NS_DOT)) { /* If dot entry is not exit */
1890:                					dj->sclust = 0;
1891:                					dj->dir = 0; /* It is the root dir */
1892:                					res = FR_OK;
1893:                					if (!(ns & NS_LAST))
1894:                						continue;
1895:                				} else { /* Could not find the object */
1896:                					if (!(ns & NS_LAST))
9D001110  30840004   ANDI A0, A0, 4
1897:                						res = FR_NO_PATH;
1898:                				}
1899:                				break;
1900:                			}
1901:                			if (ns & NS_LAST)
9D0011AC  30630004   ANDI V1, V1, 4
9D0011B0  5060FFDC   BEQL V1, ZERO, 0x9D001124
9D0011B4  31290010   ANDI T1, T1, 16
1902:                				break; /* Last segment match. Function completed. */
1903:                			dir = dj->dir; /* There is next segment. Follow the sub directory */
1904:                			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
9D001124  11200014   BEQ T1, ZERO, 0x9D001178
9D001128  24020005   ADDIU V0, ZERO, 5
1905:                				res = FR_NO_PATH;
1906:                				break;
1907:                			}
1908:                			dj->sclust = LD_CLUST(dir);
9D00112C  90E30015   LBU V1, 21(A3)
9D001130  00031A00   SLL V1, V1, 8
9D001134  90E20014   LBU V0, 20(A3)
9D001138  00621825   OR V1, V1, V0
9D00113C  00031C00   SLL V1, V1, 16
9D001140  90E2001B   LBU V0, 27(A3)
9D001144  00021200   SLL V0, V0, 8
9D001148  90E4001A   LBU A0, 26(A3)
9D00114C  00441025   OR V0, V0, A0
9D001150  00621025   OR V0, V1, V0
9D001154  0B4003A5   J 0x9D000E94
9D001158  AE420008   SW V0, 8(S2)
1909:                		}
1910:                	}
1911:                
1912:                	return res;
1913:                }
9D001178  8FBF0034   LW RA, 52(SP)
9D00117C  8FB70030   LW S7, 48(SP)
9D001180  8FB6002C   LW S6, 44(SP)
9D001184  8FB50028   LW S5, 40(SP)
9D001188  8FB40024   LW S4, 36(SP)
9D00118C  8FB30020   LW S3, 32(SP)
9D001190  8FB2001C   LW S2, 28(SP)
9D001194  8FB10018   LW S1, 24(SP)
9D001198  8FB00014   LW S0, 20(SP)
9D00119C  03E00008   JR RA
9D0011A0  27BD0038   ADDIU SP, SP, 56
9D0011B8  0B40045F   J 0x9D00117C
9D0011BC  8FBF0034   LW RA, 52(SP)
1914:                
1915:                /*-----------------------------------------------------------------------*/
1916:                /* Load a sector and check if it is an FAT Volume Boot Record            */
1917:                /*-----------------------------------------------------------------------*/
1918:                
1919:                static PF_BYTE check_fs( /* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
1920:                FATFS *fs, /* File system object */
1921:                DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
1922:                ) {
9D00030C  27BDFFE8   ADDIU SP, SP, -24
9D000310  AFBF0014   SW RA, 20(SP)
9D000314  AFB00010   SW S0, 16(SP)
9D000318  00808021   ADDU S0, A0, ZERO
9D00031C  00A03021   ADDU A2, A1, ZERO
1923:                	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK) /* Load boot record */
9D000320  90840001   LBU A0, 1(A0)
9D000324  26050030   ADDIU A1, S0, 48
9D000328  0F401B5A   JAL disk_read
9D00032C  24070001   ADDIU A3, ZERO, 1
9D000330  14400027   BNE V0, ZERO, 0x9D0003D0
9D000334  24030003   ADDIU V1, ZERO, 3
1924:                		return 3;
9D0003C0  3C02FFAB   LUI V0, -85
9D0003C4  3442BEBA   ORI V0, V0, -16710
9D0003C8  00621821   ADDU V1, V1, V0
9D0003CC  0003182B   SLTU V1, ZERO, V1
1925:                	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55) /* Check record signature (always placed at offset 510 even if the sector size is >512) */
9D000338  9204022F   LBU A0, 559(S0)
9D00033C  00042200   SLL A0, A0, 8
9D000340  9202022E   LBU V0, 558(S0)
9D000344  00822025   OR A0, A0, V0
9D000348  7C042620   SEH A0, A0
9D00034C  2402AA55   ADDIU V0, ZERO, -21931
9D000350  1482001F   BNE A0, V0, 0x9D0003D0
9D000354  24030002   ADDIU V1, ZERO, 2
1926:                		return 2;
1927:                
1928:                	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) /* Check "FAT" string */
9D000358  92040069   LBU A0, 105(S0)
9D00035C  00042600   SLL A0, A0, 24
9D000360  92020068   LBU V0, 104(S0)
9D000364  00021400   SLL V0, V0, 16
9D000368  00822025   OR A0, A0, V0
9D00036C  92020066   LBU V0, 102(S0)
9D000370  00822025   OR A0, A0, V0
9D000374  92020067   LBU V0, 103(S0)
9D000378  00021200   SLL V0, V0, 8
9D00037C  00822025   OR A0, A0, V0
9D000380  7C84B800   EXT A0, A0, 0, 24
9D000384  3C020054   LUI V0, 84
9D000388  24424146   ADDIU V0, V0, 16710
9D00038C  10820010   BEQ A0, V0, 0x9D0003D0
9D000390  00001821   ADDU V1, ZERO, ZERO
1929:                		return 0;
1930:                	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
9D000394  92030085   LBU V1, 133(S0)
9D000398  00031E00   SLL V1, V1, 24
9D00039C  92020084   LBU V0, 132(S0)
9D0003A0  00021400   SLL V0, V0, 16
9D0003A4  00621825   OR V1, V1, V0
9D0003A8  92020082   LBU V0, 130(S0)
9D0003AC  00621825   OR V1, V1, V0
9D0003B0  92020083   LBU V0, 131(S0)
9D0003B4  00021200   SLL V0, V0, 8
9D0003B8  00621825   OR V1, V1, V0
9D0003BC  7C63B800   EXT V1, V1, 0, 24
1931:                		return 0;
1932:                
1933:                	return 1;
1934:                }
9D0003D0  00601021   ADDU V0, V1, ZERO
9D0003D4  8FBF0014   LW RA, 20(SP)
9D0003D8  8FB00010   LW S0, 16(SP)
9D0003DC  03E00008   JR RA
9D0003E0  27BD0018   ADDIU SP, SP, 24
1935:                
1936:                /*-----------------------------------------------------------------------*/
1937:                /* Check if the file system object is valid or not                       */
1938:                /*-----------------------------------------------------------------------*/
1939:                
1940:                FRESULT chk_mounted( /* FR_OK(0): successful, !=0: any error occurred */
1941:                                            const TCHAR **path, /* Pointer to pointer to the path name (drive number) */
1942:                                            FATFS **rfs, /* Pointer to pointer to the found file system object */
1943:                                            PF_BYTE chk_wp /* !=0: Check media write protection for write access */
1944:                                            ) {
9D00142C  27BDFFE0   ADDIU SP, SP, -32
9D001430  AFBF001C   SW RA, 28(SP)
9D001434  AFB20018   SW S2, 24(SP)
9D001438  AFB10014   SW S1, 20(SP)
9D00143C  AFB00010   SW S0, 16(SP)
9D001440  30D100FF   ANDI S1, A2, 255
1945:                	PF_BYTE fmt, b, pi, *tbl;
1946:                	UINT vol;
1947:                	DSTATUS stat;
1948:                	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
1949:                	PF_WORD nrsv;
1950:                	const TCHAR *p = *path;
9D001444  8C820000   LW V0, 0(A0)
1951:                	FATFS *fs;
1952:                
1953:                	/* Get logical drive number from the path name */
1954:                	vol = p[0] - '0'; /* Is there a drive number? */
9D001448  80430000   LB V1, 0(V0)
9D00144C  2463FFD0   ADDIU V1, V1, -48
1955:                	if (vol <= 9 && p[1] == ':') { /* Found a drive number, get and strip it */
9D001450  2C66000A   SLTIU A2, V1, 10
9D001454  10C0000A   BEQ A2, ZERO, 0x9D001480
9D001458  8F908040   LW S0, -32704(GP)
9D00145C  80470001   LB A3, 1(V0)
9D001460  2406003A   ADDIU A2, ZERO, 58
9D001464  54E60007   BNEL A3, A2, 0x9D001484
9D001468  ACB00000   SW S0, 0(A1)
1956:                		p += 2;
9D00146C  24420002   ADDIU V0, V0, 2
1957:                		*path = p; /* Return pointer to the path name */
9D001470  AC820000   SW V0, 0(A0)
1958:                	} else { /* No drive number is given */
1959:                #if _FS_RPATH
1960:                		vol = CurrVol; /* Use current drive */
1961:                #else
1962:                		vol = 0; /* Use drive 0 */
1963:                #endif
1964:                	}
1965:                
1966:                	/* Check if the file system object is valid or not */
1967:                	if (vol >= _VOLUMES) /* Is the drive number valid? */
9D001474  14600112   BNE V1, ZERO, 0x9D0018C0
9D001478  2402000B   ADDIU V0, ZERO, 11
1968:                		return FR_INVALID_DRIVE;
1969:                	*rfs = fs = FatFs[vol]; /* Return pointer to the corresponding file system object */
9D00147C  8F908040   LW S0, -32704(GP)
9D001480  ACB00000   SW S0, 0(A1)
1970:                	if (!fs)
9D001484  1200010E   BEQ S0, ZERO, 0x9D0018C0
9D001488  2402000C   ADDIU V0, ZERO, 12
1971:                		return FR_NOT_ENABLED; /* Is the file system object available? */
1972:                
1973:                	ENTER_FF(fs); /* Lock file system */
1974:                
1975:                	if (fs->fs_type) { /* If the logical drive has been mounted */
9D00148C  92020000   LBU V0, 0(S0)
9D001490  5040000D   BEQL V0, ZERO, 0x9D0014C8
9D001494  A2000000   SB ZERO, 0(S0)
1976:                		stat = disk_status(fs->drv);
9D001498  0F401B53   JAL disk_status
9D00149C  92040001   LBU A0, 1(S0)
9D0014A0  00401821   ADDU V1, V0, ZERO
1977:                		if (!(stat & STA_NOINIT)) { /* and the physical drive is kept initialized (has not been changed), */
9D0014A4  30420001   ANDI V0, V0, 1
9D0014A8  54400007   BNEL V0, ZERO, 0x9D0014C8
9D0014AC  A2000000   SB ZERO, 0(S0)
1978:                			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check write protection if needed */
9D0014B0  12200103   BEQ S1, ZERO, 0x9D0018C0
9D0014B4  2404000A   ADDIU A0, ZERO, 10
9D0014B8  30620004   ANDI V0, V1, 4
1979:                				return FR_WRITE_PROTECTED;
1980:                			return FR_OK; /* The file system object is valid */
9D0014BC  0002200A   MOVZ A0, ZERO, V0
9D0014C0  0B400630   J 0x9D0018C0
9D0014C4  00801021   ADDU V0, A0, ZERO
1981:                		}
1982:                	}
1983:                
1984:                	/* The file system object is not valid. */
1985:                	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
1986:                
1987:                	fs->fs_type = 0; /* Clear the file system object */
1988:                	fs->drv = LD2PD(vol); /* Bind the logical drive and a physical drive */
9D0014C8  A2000001   SB ZERO, 1(S0)
1989:                	stat = disk_initialize(fs->drv); /* Initialize low level disk I/O layer */
9D0014CC  0F401AC2   JAL disk_initialize
9D0014D0  00002021   ADDU A0, ZERO, ZERO
9D0014D4  00401821   ADDU V1, V0, ZERO
1990:                	if (stat & STA_NOINIT) /* Check if the initialization succeeded */
9D0014D8  30440001   ANDI A0, V0, 1
9D0014DC  148000F8   BNE A0, ZERO, 0x9D0018C0
9D0014E0  24020003   ADDIU V0, ZERO, 3
1991:                		return FR_NOT_READY; /* Failed to initialize due to no media or hard error */
1992:                	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check disk write protection if needed */
9D0014E4  12200003   BEQ S1, ZERO, 0x9D0014F4
9D0014E8  30630004   ANDI V1, V1, 4
9D0014EC  146000F4   BNE V1, ZERO, 0x9D0018C0
9D0014F0  2402000A   ADDIU V0, ZERO, 10
1993:                		return FR_WRITE_PROTECTED;
1994:                #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
1995:                	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
1996:                	return FR_DISK_ERR;
1997:                #endif
1998:                	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
1999:                	fmt = check_fs(fs, bsect = 0); /* Load sector 0 and check if it is an FAT-VBR (in SFD) */
9D0014F4  02002021   ADDU A0, S0, ZERO
9D0014F8  0F4000C3   JAL 0x9D00030C
9D0014FC  00002821   ADDU A1, ZERO, ZERO
9D001500  00401821   ADDU V1, V0, ZERO
2000:                	if (LD2PT(vol) && !fmt)
2001:                		fmt = 1; /* Force non-SFD if the volume is forced partition */
2002:                	if (fmt == 1) { /* Not an FAT-VBR, the physical drive can be partitioned */
9D001504  24020001   ADDIU V0, ZERO, 1
9D001508  14620012   BNE V1, V0, 0x9D001554
9D00150C  00008821   ADDU S1, ZERO, ZERO
2003:                		/* Check the partition listed in the partition table */
2004:                		pi = LD2PT(vol);
2005:                		if (pi)
2006:                			pi--;
2007:                		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
2008:                		if (tbl[4]) { /* Is the partition existing? */
9D001510  920301F2   LBU V1, 498(S0)
9D001514  106000EA   BEQ V1, ZERO, 0x9D0018C0
9D001518  2402000D   ADDIU V0, ZERO, 13
2009:                			bsect = LD_DWORD(&tbl[8]); /* Partition offset in LBA */
9D00151C  921101F9   LBU S1, 505(S0)
9D001520  00118E00   SLL S1, S1, 24
9D001524  920201F8   LBU V0, 504(S0)
9D001528  00021400   SLL V0, V0, 16
9D00152C  02228825   OR S1, S1, V0
9D001530  920201F6   LBU V0, 502(S0)
9D001534  02228825   OR S1, S1, V0
9D001538  920201F7   LBU V0, 503(S0)
9D00153C  00021200   SLL V0, V0, 8
9D001540  02228825   OR S1, S1, V0
2010:                			fmt = check_fs(fs, bsect); /* Check the partition */
9D001544  02002021   ADDU A0, S0, ZERO
9D001548  0F4000C3   JAL 0x9D00030C
9D00154C  02202821   ADDU A1, S1, ZERO
9D001550  00401821   ADDU V1, V0, ZERO
2011:                		}
2012:                	}
2013:                	if (fmt == 3)
9D001554  24040003   ADDIU A0, ZERO, 3
9D001558  106400D9   BEQ V1, A0, 0x9D0018C0
9D00155C  24020001   ADDIU V0, ZERO, 1
2014:                		return FR_DISK_ERR;
2015:                	if (fmt)
9D001560  146000D7   BNE V1, ZERO, 0x9D0018C0
9D001564  2402000D   ADDIU V0, ZERO, 13
2016:                		return FR_NO_FILESYSTEM; /* No FAT volume is found */
2017:                
2018:                	/* An FAT volume is found. Following code initializes the file system object */
2019:                
2020:                	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs)) /* (BPB_BytsPerSec must be equal to the physical sector size) */
9D001568  9204003C   LBU A0, 60(S0)
9D00156C  00042200   SLL A0, A0, 8
9D001570  9202003B   LBU V0, 59(S0)
9D001574  00822025   OR A0, A0, V0
9D001578  7C042620   SEH A0, A0
9D00157C  24030200   ADDIU V1, ZERO, 512
9D001580  148300CF   BNE A0, V1, 0x9D0018C0
9D001584  2402000D   ADDIU V0, ZERO, 13
2021:                		return FR_NO_FILESYSTEM;
2022:                
2023:                	fasize = LD_WORD(fs->win+BPB_FATSz16); /* Number of sectors per FAT */
9D001588  92030047   LBU V1, 71(S0)
9D00158C  00031A00   SLL V1, V1, 8
9D001590  92020046   LBU V0, 70(S0)
9D001594  00621825   OR V1, V1, V0
2024:                	if (!fasize)
9D001598  5460000C   BNEL V1, ZERO, 0x9D0015CC
9D00159C  AE03001C   SW V1, 28(S0)
2025:                		fasize = LD_DWORD(fs->win+BPB_FATSz32);
9D0015A0  92030057   LBU V1, 87(S0)
9D0015A4  00031E00   SLL V1, V1, 24
9D0015A8  92020056   LBU V0, 86(S0)
9D0015AC  00021400   SLL V0, V0, 16
9D0015B0  00621825   OR V1, V1, V0
9D0015B4  92020054   LBU V0, 84(S0)
9D0015B8  00621825   OR V1, V1, V0
9D0015BC  92020055   LBU V0, 85(S0)
9D0015C0  00021200   SLL V0, V0, 8
9D0015C4  00621825   OR V1, V1, V0
2026:                	fs->fsize = fasize;
9D0015C8  AE03001C   SW V1, 28(S0)
2027:                
2028:                	fs->n_fats = b = fs->win[BPB_NumFATs]; /* Number of FAT copies */
9D0015CC  92040040   LBU A0, 64(S0)
9D0015D0  A2040003   SB A0, 3(S0)
2029:                	if (b != 1 && b != 2)
9D0015D4  2485FFFF   ADDIU A1, A0, -1
9D0015D8  30A500FF   ANDI A1, A1, 255
9D0015DC  2CA50002   SLTIU A1, A1, 2
9D0015E0  10A000B7   BEQ A1, ZERO, 0x9D0018C0
9D0015E4  2402000D   ADDIU V0, ZERO, 13
2030:                		return FR_NO_FILESYSTEM; /* (Must be 1 or 2) */
2031:                	fasize *= b; /* Number of sectors for FAT area */
9D001678  70642002   MUL A0, V1, A0
2032:                
2033:                	fs->csize = b = fs->win[BPB_SecPerClus]; /* Number of sectors per cluster */
9D0015E8  9205003D   LBU A1, 61(S0)
2034:                	if (!b || (b & (b - 1)))
9D0015EC  10A000B4   BEQ A1, ZERO, 0x9D0018C0
9D0015F0  A2050002   SB A1, 2(S0)
9D0015F4  24A6FFFF   ADDIU A2, A1, -1
9D0015F8  00C53024   AND A2, A2, A1
9D0015FC  14C000B1   BNE A2, ZERO, 0x9D0018C4
9D001600  8FBF001C   LW RA, 28(SP)
2035:                		return FR_NO_FILESYSTEM; /* (Must be power of 2) */
2036:                
2037:                	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt); /* Number of root directory entries */
9D001604  92060042   LBU A2, 66(S0)
9D001608  00063200   SLL A2, A2, 8
9D00160C  92020041   LBU V0, 65(S0)
9D001610  00C23025   OR A2, A2, V0
9D001614  A6060008   SH A2, 8(S0)
2038:                	if (fs->n_rootdir % (SS(fs) / SZ_DIR))
9D001618  30C7000F   ANDI A3, A2, 15
9D00161C  14E000A8   BNE A3, ZERO, 0x9D0018C0
9D001620  2402000D   ADDIU V0, ZERO, 13
2039:                		return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be sector aligned) */
2040:                
2041:                	tsect = LD_WORD(fs->win+BPB_TotSec16); /* Number of sectors on the volume */
9D001624  92070044   LBU A3, 68(S0)
9D001628  00073A00   SLL A3, A3, 8
9D00162C  92020043   LBU V0, 67(S0)
9D001630  00E23825   OR A3, A3, V0
2042:                	if (!tsect)
9D001634  14E0000B   BNE A3, ZERO, 0x9D001664
9D001638  9208003F   LBU T0, 63(S0)
2043:                		tsect = LD_DWORD(fs->win+BPB_TotSec32);
9D00163C  92070053   LBU A3, 83(S0)
9D001640  00073E00   SLL A3, A3, 24
9D001644  92020052   LBU V0, 82(S0)
9D001648  00021400   SLL V0, V0, 16
9D00164C  00E23825   OR A3, A3, V0
9D001650  92020050   LBU V0, 80(S0)
9D001654  00E23825   OR A3, A3, V0
9D001658  92020051   LBU V0, 81(S0)
9D00165C  00021200   SLL V0, V0, 8
9D001660  00E23825   OR A3, A3, V0
2044:                
2045:                	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt); /* Number of reserved sectors */
9D001664  00084200   SLL T0, T0, 8
9D001668  9202003E   LBU V0, 62(S0)
9D00166C  01024025   OR T0, T0, V0
2046:                	if (!nrsv)
9D001670  11000093   BEQ T0, ZERO, 0x9D0018C0
9D001674  2402000D   ADDIU V0, ZERO, 13
2047:                		return FR_NO_FILESYSTEM; /* (BPB_RsvdSecCnt must not be 0) */
2048:                
2049:                	/* Determine the FAT sub type */
2050:                	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR); /* RSV+FAT+DIR */
9D00167C  00064902   SRL T1, A2, 4
9D001680  01284821   ADDU T1, T1, T0
9D001684  01244821   ADDU T1, T1, A0
2051:                	if (tsect < sysect)
9D001688  00E9502B   SLTU T2, A3, T1
9D00168C  1540008D   BNE T2, ZERO, 0x9D0018C4
9D001690  8FBF001C   LW RA, 28(SP)
2052:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2053:                	nclst = (tsect - sysect) / fs->csize; /* Number of clusters */
9D001694  00E93823   SUBU A3, A3, T1
9D001698  00E5001B   DIVU A3, A1
9D00169C  00A001F4   TEQ A1, ZERO
9D0016A0  00002812   MFLO A1, 0
2054:                	if (!nclst)
9D0016A4  10A00086   BEQ A1, ZERO, 0x9D0018C0
9D0016A8  2CB20FF6   SLTIU S2, A1, 4086
2055:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2056:                	fmt = FS_FAT12;
9D0016AC  24020001   ADDIU V0, ZERO, 1
9D0016B0  240A0002   ADDIU T2, ZERO, 2
9D0016B4  0152100A   MOVZ V0, T2, S2
9D0016B8  00409021   ADDU S2, V0, ZERO
2057:                	if (nclst >= MIN_FAT16)
2058:                		fmt = FS_FAT16;
2059:                	if (nclst >= MIN_FAT32)
9D0016BC  3402FFF6   ORI V0, ZERO, -10
9D0016C0  00A2102B   SLTU V0, A1, V0
9D0016C4  10400084   BEQ V0, ZERO, 0x9D0018D8
9D0016C8  24A50002   ADDIU A1, A1, 2
2060:                		fmt = FS_FAT32;
9D0018EC  0B4005BA   J 0x9D0016E8
9D0018F0  24120003   ADDIU S2, ZERO, 3
2061:                
2062:                	/* Boundaries and Limits */
2063:                	fs->n_fatent = nclst + 2; /* Number of FAT entries */
9D0016CC  AE050018   SW A1, 24(S0)
9D0018D8  AE050018   SW A1, 24(S0)
2064:                	fs->database = bsect + sysect; /* Data start sector */
9D0016D0  02294821   ADDU T1, S1, T1
9D0016D4  AE090028   SW T1, 40(S0)
9D0018DC  02294821   ADDU T1, S1, T1
9D0018E0  AE090028   SW T1, 40(S0)
2065:                	fs->fatbase = bsect + nrsv; /* FAT start sector */
9D0016D8  02284021   ADDU T0, S1, T0
9D0018E4  02284021   ADDU T0, S1, T0
9D0018E8  AE080020   SW T0, 32(S0)
2066:                	if (fmt == FS_FAT32) {
9D0016DC  24020003   ADDIU V0, ZERO, 3
9D0016E0  16420010   BNE S2, V0, 0x9D001724
9D0016E4  AE080020   SW T0, 32(S0)
2067:                		if (fs->n_rootdir)
9D0016E8  14C00075   BNE A2, ZERO, 0x9D0018C0
9D0016EC  2402000D   ADDIU V0, ZERO, 13
2068:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be 0) */
2069:                		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
9D0016F0  9204005F   LBU A0, 95(S0)
9D0016F4  00042600   SLL A0, A0, 24
9D0016F8  9202005E   LBU V0, 94(S0)
9D0016FC  00021400   SLL V0, V0, 16
9D001700  00822025   OR A0, A0, V0
9D001704  9202005C   LBU V0, 92(S0)
9D001708  00822025   OR A0, A0, V0
9D00170C  9202005D   LBU V0, 93(S0)
9D001710  00021200   SLL V0, V0, 8
9D001714  00821025   OR V0, A0, V0
9D001718  AE020024   SW V0, 36(S0)
2070:                		szbfat = fs->n_fatent * 4; /* (Required FAT size) */
9D00171C  0B4005D6   J 0x9D001758
9D001720  00052880   SLL A1, A1, 2
2071:                	} else {
2072:                		if (!fs->n_rootdir)
9D001724  10C00066   BEQ A2, ZERO, 0x9D0018C0
9D001728  2402000D   ADDIU V0, ZERO, 13
2073:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must not be 0) */
2074:                		fs->dirbase = fs->fatbase + fasize; /* Root directory start sector */
9D00172C  00882021   ADDU A0, A0, T0
2075:                		szbfat = (fmt == FS_FAT16) ? /* (Required FAT size) */
2076:                		fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
9D001730  24020002   ADDIU V0, ZERO, 2
9D001734  16420003   BNE S2, V0, 0x9D001744
9D001738  AE040024   SW A0, 36(S0)
9D00173C  0B4005D6   J 0x9D001758
9D001740  00052840   SLL A1, A1, 1
9D001744  24020003   ADDIU V0, ZERO, 3
9D001748  70A21002   MUL V0, A1, V0
9D00174C  00021042   SRL V0, V0, 1
9D001750  30A50001   ANDI A1, A1, 1
9D001754  00452821   ADDU A1, V0, A1
2077:                	}
2078:                	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) /* (BPB_FATSz must not be less than required) */
9D001758  24A501FF   ADDIU A1, A1, 511
9D00175C  00052A42   SRL A1, A1, 9
9D001760  0065182B   SLTU V1, V1, A1
9D001764  14600056   BNE V1, ZERO, 0x9D0018C0
9D001768  2402000D   ADDIU V0, ZERO, 13
2079:                		return FR_NO_FILESYSTEM;
2080:                
2081:                #if !_FS_READONLY
2082:                	/* Initialize cluster allocation information */
2083:                	fs->free_clust = 0xFFFFFFFF;
9D00176C  2402FFFF   ADDIU V0, ZERO, -1
9D001770  AE020010   SW V0, 16(S0)
2084:                	fs->last_clust = 0;
2085:                
2086:                	/* Get fsinfo if available */
2087:                	if (fmt == FS_FAT32) {
9D001774  24020003   ADDIU V0, ZERO, 3
9D001778  16420048   BNE S2, V0, 0x9D00189C
9D00177C  AE00000C   SW ZERO, 12(S0)
2088:                		fs->fsi_flag = 0;
9D001780  A2000005   SB ZERO, 5(S0)
2089:                		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
9D001784  92060061   LBU A2, 97(S0)
9D001788  00063200   SLL A2, A2, 8
9D00178C  92020060   LBU V0, 96(S0)
9D001790  00C23025   OR A2, A2, V0
9D001794  02263021   ADDU A2, S1, A2
9D001798  AE060014   SW A2, 20(S0)
2090:                		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK
9D00179C  92040001   LBU A0, 1(S0)
9D0017A0  26050030   ADDIU A1, S0, 48
9D0017A4  0F401B5A   JAL disk_read
9D0017A8  24070001   ADDIU A3, ZERO, 1
9D0017AC  5440003C   BNEL V0, ZERO, 0x9D0018A0
9D0017B0  A2120000   SB S2, 0(S0)
2091:                				&& LD_WORD(fs->win+BS_55AA) == 0xAA55
9D0017B4  9203022F   LBU V1, 559(S0)
9D0017B8  00031A00   SLL V1, V1, 8
9D0017BC  9202022E   LBU V0, 558(S0)
9D0017C0  00621825   OR V1, V1, V0
9D0017C4  7C031E20   SEH V1, V1
9D0017C8  2402AA55   ADDIU V0, ZERO, -21931
9D0017CC  54620034   BNEL V1, V0, 0x9D0018A0
9D0017D0  A2120000   SB S2, 0(S0)
2092:                				&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
9D0017D4  92030033   LBU V1, 51(S0)
9D0017D8  00031E00   SLL V1, V1, 24
9D0017DC  92020032   LBU V0, 50(S0)
9D0017E0  00021400   SLL V0, V0, 16
9D0017E4  00621825   OR V1, V1, V0
9D0017E8  92020030   LBU V0, 48(S0)
9D0017EC  00621825   OR V1, V1, V0
9D0017F0  92020031   LBU V0, 49(S0)
9D0017F4  00021200   SLL V0, V0, 8
9D0017F8  00621825   OR V1, V1, V0
9D0017FC  3C024161   LUI V0, 16737
9D001800  24425252   ADDIU V0, V0, 21074
9D001804  54620026   BNEL V1, V0, 0x9D0018A0
9D001808  A2120000   SB S2, 0(S0)
2093:                				&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
9D00180C  92030217   LBU V1, 535(S0)
9D001810  00031E00   SLL V1, V1, 24
9D001814  92020216   LBU V0, 534(S0)
9D001818  00021400   SLL V0, V0, 16
9D00181C  00621825   OR V1, V1, V0
9D001820  92020214   LBU V0, 532(S0)
9D001824  00621825   OR V1, V1, V0
9D001828  92020215   LBU V0, 533(S0)
9D00182C  00021200   SLL V0, V0, 8
9D001830  00621825   OR V1, V1, V0
9D001834  3C026141   LUI V0, 24897
9D001838  24427272   ADDIU V0, V0, 29298
9D00183C  54620018   BNEL V1, V0, 0x9D0018A0
9D001840  A2120000   SB S2, 0(S0)
2094:                			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
9D001844  9203021F   LBU V1, 543(S0)
9D001848  00031E00   SLL V1, V1, 24
9D00184C  9202021E   LBU V0, 542(S0)
9D001850  00021400   SLL V0, V0, 16
9D001854  00621825   OR V1, V1, V0
9D001858  9202021C   LBU V0, 540(S0)
9D00185C  00621825   OR V1, V1, V0
9D001860  9202021D   LBU V0, 541(S0)
9D001864  00021200   SLL V0, V0, 8
9D001868  00621025   OR V0, V1, V0
9D00186C  AE02000C   SW V0, 12(S0)
2095:                			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
9D001870  9203021B   LBU V1, 539(S0)
9D001874  00031E00   SLL V1, V1, 24
9D001878  9202021A   LBU V0, 538(S0)
9D00187C  00021400   SLL V0, V0, 16
9D001880  00621825   OR V1, V1, V0
9D001884  92020218   LBU V0, 536(S0)
9D001888  00621825   OR V1, V1, V0
9D00188C  92020219   LBU V0, 537(S0)
9D001890  00021200   SLL V0, V0, 8
9D001894  00621025   OR V0, V1, V0
9D001898  AE020010   SW V0, 16(S0)
2096:                		}
2097:                	}
2098:                #endif
2099:                	fs->fs_type = fmt; /* FAT sub-type */
9D00189C  A2120000   SB S2, 0(S0)
2100:                	fs->id = ++Fsid; /* File system mount ID */
9D0018A0  97828044   LHU V0, -32700(GP)
9D0018A4  24420001   ADDIU V0, V0, 1
9D0018A8  3042FFFF   ANDI V0, V0, -1
9D0018AC  A7828044   SH V0, -32700(GP)
9D0018B0  A6020006   SH V0, 6(S0)
2101:                	fs->winsect = 0; /* Invalidate sector cache */
9D0018B4  AE00002C   SW ZERO, 44(S0)
2102:                	fs->wflag = 0;
9D0018B8  A2000004   SB ZERO, 4(S0)
2103:                #if _FS_RPATH
2104:                	fs->cdir = 0; /* Current directory (root dir) */
2105:                #endif
2106:                #if _FS_SHARE				/* Clear file lock semaphores */
2107:                	clear_lock(fs);
2108:                #endif
2109:                
2110:                	return FR_OK;
9D0018BC  00001021   ADDU V0, ZERO, ZERO
2111:                }
9D0018C0  8FBF001C   LW RA, 28(SP)
9D0018C4  8FB20018   LW S2, 24(SP)
9D0018C8  8FB10014   LW S1, 20(SP)
9D0018CC  8FB00010   LW S0, 16(SP)
9D0018D0  03E00008   JR RA
9D0018D4  27BD0020   ADDIU SP, SP, 32
2112:                
2113:                /*-----------------------------------------------------------------------*/
2114:                /* Check if the file/dir object is valid or not                          */
2115:                /*-----------------------------------------------------------------------*/
2116:                
2117:                static FRESULT validate( /* FR_OK(0): The object is valid, !=0: Invalid */
2118:                FATFS *fs, /* Pointer to the file system object */
2119:                PF_WORD id /* Member id of the target object to be checked */
2120:                ) {
9D00050C  27BDFFE8   ADDIU SP, SP, -24
9D000510  AFBF0014   SW RA, 20(SP)
2121:                	if (!fs || !fs->fs_type || fs->id != id)
9D000514  1080000D   BEQ A0, ZERO, 0x9D00054C
9D000518  24020009   ADDIU V0, ZERO, 9
9D00051C  90830000   LBU V1, 0(A0)
9D000520  1060000B   BEQ V1, ZERO, 0x9D000550
9D000524  8FBF0014   LW RA, 20(SP)
9D000528  94830006   LHU V1, 6(A0)
9D00052C  14650008   BNE V1, A1, 0x9D000550
9D000530  00000000   NOP
2122:                		return FR_INVALID_OBJECT;
2123:                
2124:                	ENTER_FF(fs); /* Lock file system */
2125:                
2126:                	if (disk_status(fs->drv) & STA_NOINIT)
9D000534  0F401B53   JAL disk_status
9D000538  90840001   LBU A0, 1(A0)
9D00053C  30420001   ANDI V0, V0, 1
2127:                		return FR_NOT_READY;
9D000540  24030003   ADDIU V1, ZERO, 3
9D000544  0002180A   MOVZ V1, ZERO, V0
9D000548  00601021   ADDU V0, V1, ZERO
2128:                
2129:                	return FR_OK;
2130:                }
9D00054C  8FBF0014   LW RA, 20(SP)
9D000550  03E00008   JR RA
9D000554  27BD0018   ADDIU SP, SP, 24
2131:                
2132:                /*--------------------------------------------------------------------------
2133:                
2134:                 Public Functions
2135:                
2136:                 --------------------------------------------------------------------------*/
2137:                
2138:                /*-----------------------------------------------------------------------*/
2139:                /* Mount/Unmount a Logical Drive                                         */
2140:                /*-----------------------------------------------------------------------*/
2141:                
2142:                FRESULT f_mount(PF_BYTE vol, /* Logical drive number to be mounted/unmounted */
2143:                                FATFS *fs /* Pointer to new file system object (NULL for unmount)*/
2144:                                ) {
9D0018F4  308400FF   ANDI A0, A0, 255
2145:                	FATFS *rfs;
2146:                
2147:                	if (vol >= _VOLUMES) {/* Check if the drive number is valid */
9D0018F8  14800008   BNE A0, ZERO, 0x9D00191C
9D0018FC  2402000B   ADDIU V0, ZERO, 11
2148:                		return FR_INVALID_DRIVE;
2149:                	}
2150:                	rfs = FatFs[vol]; /* Get current fs object */
9D001900  8F828040   LW V0, -32704(GP)
2151:                
2152:                	if (rfs) {
9D001904  54400001   BNEL V0, ZERO, 0x9D00190C
9D001908  A0400000   SB ZERO, 0(V0)
2153:                #if _FS_SHARE
2154:                		clear_lock(rfs);
2155:                #endif
2156:                #if _FS_REENTRANT				/* Discard sync object of the current volume */
2157:                		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2158:                #endif
2159:                		rfs->fs_type = 0; /* Clear old fs object */
2160:                	}
2161:                
2162:                	if (fs) {
9D00190C  54A00001   BNEL A1, ZERO, 0x9D001914
9D001910  A0A00000   SB ZERO, 0(A1)
2163:                		fs->fs_type = 0; /* Clear new fs object */
2164:                #if _FS_REENTRANT				/* Create sync object for the new volume */
2165:                		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2166:                #endif
2167:                	}
2168:                	FatFs[vol] = fs; /* Register new fs object */
9D001914  AF858040   SW A1, -32704(GP)
2169:                
2170:                	return FR_OK;
9D001918  00001021   ADDU V0, ZERO, ZERO
2171:                }
9D00191C  03E00008   JR RA
9D001920  00000000   NOP
2172:                
2173:                /*-----------------------------------------------------------------------*/
2174:                /* Open or Create a File                                                 */
2175:                /*-----------------------------------------------------------------------*/
2176:                
2177:                FRESULT f_open(FIL *fp, /* Pointer to the blank file object */
2178:                                const TCHAR *path, /* Pointer to the file name */
2179:                                PF_BYTE mode /* Access mode and file open mode flags */
2180:                                ) {
9D001924  27BDFFB0   ADDIU SP, SP, -80
9D001928  AFBF004C   SW RA, 76(SP)
9D00192C  AFB40048   SW S4, 72(SP)
9D001930  AFB30044   SW S3, 68(SP)
9D001934  AFB20040   SW S2, 64(SP)
9D001938  AFB1003C   SW S1, 60(SP)
9D00193C  AFB00038   SW S0, 56(SP)
9D001940  00808821   ADDU S1, A0, ZERO
9D001944  AFA50054   SW A1, 84(SP)
2181:                	FRESULT res;
2182:                	DIR dj;
2183:                	PF_BYTE *dir;
2184:                	DEF_NAMEBUF;
2185:                
2186:                	fp->fs = 0; /* Clear file object */
9D001948  AC800000   SW ZERO, 0(A0)
2187:                
2188:                #if !_FS_READONLY
2189:                	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS
9D00194C  30D2001F   ANDI S2, A2, 31
2190:                			| FA_CREATE_NEW;
2191:                	res = chk_mounted(&path, &dj.fs, (PF_BYTE) (mode & ~FA_READ));
9D001950  02409821   ADDU S3, S2, ZERO
9D001954  27A40054   ADDIU A0, SP, 84
9D001958  27A50010   ADDIU A1, SP, 16
9D00195C  0F40050B   JAL chk_mounted
9D001960  3246001E   ANDI A2, S2, 30
2192:                #else
2193:                	mode &= FA_READ;
2194:                	res = chk_mounted(&path, &dj.fs, 0);
2195:                #endif
2196:                	INIT_BUF(dj);
9D001964  27A3002C   ADDIU V1, SP, 44
2197:                	if (res == FR_OK)
9D001968  14400086   BNE V0, ZERO, 0x9D001B84
9D00196C  AFA30028   SW V1, 40(SP)
2198:                		res = follow_path(&dj, path); /* Follow the file path */
9D001970  27A40010   ADDIU A0, SP, 16
9D001974  0F400384   JAL 0x9D000E10
9D001978  8FA50054   LW A1, 84(SP)
2199:                	dir = dj.dir;
9D001B84  0B400663   J 0x9D00198C
9D001B88  8FB00024   LW S0, 36(SP)
2200:                
2201:                #if !_FS_READONLY	/* R/W configuration */
2202:                	if (res == FR_OK) {
9D00197C  14400003   BNE V0, ZERO, 0x9D00198C
9D001980  8FB00024   LW S0, 36(SP)
2203:                		if (!dir) /* Current dir itself */
2204:                			res = FR_INVALID_NAME;
9D001984  24030006   ADDIU V1, ZERO, 6
9D001988  0070100A   MOVZ V0, V1, S0
2205:                #if _FS_SHARE
2206:                		else
2207:                		res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2208:                #endif
2209:                	}
2210:                	/* Create or Open a file */
2211:                	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
9D00198C  3263001C   ANDI V1, S3, 28
9D001990  10600044   BEQ V1, ZERO, 0x9D001AA4
9D001994  00000000   NOP
2212:                		DWORD dw, cl;
2213:                
2214:                		if (res != FR_OK) { /* No file, create new */
9D001998  5040000B   BEQL V0, ZERO, 0x9D0019C8
9D00199C  9203000B   LBU V1, 11(S0)
2215:                			if (res == FR_NO_FILE) /* There is no file to open, create a new entry */
9D0019A0  24030004   ADDIU V1, ZERO, 4
9D0019A4  14430070   BNE V0, V1, 0x9D001B68
9D0019A8  8FBF004C   LW RA, 76(SP)
2216:                #if _FS_SHARE
2217:                				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
2218:                #else
2219:                				res = dir_register(&dj);
9D0019AC  0F400472   JAL 0x9D0011C8
9D0019B0  27A40010   ADDIU A0, SP, 16
2220:                #endif
2221:                			mode |= FA_CREATE_ALWAYS; /* File is created */
2222:                			dir = dj.dir; /* New entry */
9D0019B4  8FB00024   LW S0, 36(SP)
2223:                		} else { /* Any object is already existing */
2224:                			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) { /* Cannot overwrite it (R/O or DIR) */
9D0019C8  30630011   ANDI V1, V1, 17
9D0019CC  14600065   BNE V1, ZERO, 0x9D001B64
9D0019D0  24020007   ADDIU V0, ZERO, 7
2225:                				res = FR_DENIED;
2226:                			} else {
2227:                				if (mode & FA_CREATE_NEW) /* Cannot create as new file */
9D0019D4  32730004   ANDI S3, S3, 4
9D0019D8  16600062   BNE S3, ZERO, 0x9D001B64
9D0019DC  24020008   ADDIU V0, ZERO, 8
2228:                					res = FR_EXIST;
2229:                			}
2230:                		}
2231:                		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) { /* Truncate it if overwrite mode */
9D0019B8  10400009   BEQ V0, ZERO, 0x9D0019E0
9D0019BC  36520008   ORI S2, S2, 8
9D0019E0  32420008   ANDI V0, S2, 8
9D0019E4  1040003F   BEQ V0, ZERO, 0x9D001AE4
9D0019E8  8FA30010   LW V1, 16(SP)
2232:                			dw = get_fattime(); /* Created time */
9D0019EC  0F401CB5   JAL get_fattime
9D0019F0  00000000   NOP
2233:                			ST_DWORD(dir+DIR_CrtTime, dw);
9D0019F4  A202000E   SB V0, 14(S0)
9D0019F8  7C433A00   EXT V1, V0, 8, 8
9D0019FC  A203000F   SB V1, 15(S0)
9D001A00  00021C02   SRL V1, V0, 16
9D001A04  A2030010   SB V1, 16(S0)
9D001A08  00021602   SRL V0, V0, 24
9D001A0C  A2020011   SB V0, 17(S0)
2234:                			dir[DIR_Attr] = 0; /* Reset attribute */
9D001A10  A200000B   SB ZERO, 11(S0)
2235:                			ST_DWORD(dir+DIR_FileSize, 0); /* size = 0 */
9D001A14  A200001C   SB ZERO, 28(S0)
9D001A18  A200001D   SB ZERO, 29(S0)
9D001A1C  A200001E   SB ZERO, 30(S0)
9D001A20  A200001F   SB ZERO, 31(S0)
2236:                			cl = LD_CLUST(dir); /* Get start cluster */
9D001A24  92020015   LBU V0, 21(S0)
9D001A28  00021200   SLL V0, V0, 8
9D001A2C  92030014   LBU V1, 20(S0)
9D001A30  00431025   OR V0, V0, V1
9D001A34  00021400   SLL V0, V0, 16
9D001A38  9213001B   LBU S3, 27(S0)
9D001A3C  00139A00   SLL S3, S3, 8
9D001A40  9203001A   LBU V1, 26(S0)
9D001A44  02639825   OR S3, S3, V1
9D001A48  00539825   OR S3, V0, S3
2237:                			ST_CLUST(dir, 0); /* cluster = 0 */
9D001A4C  A200001A   SB ZERO, 26(S0)
9D001A50  A200001B   SB ZERO, 27(S0)
9D001A54  A2000014   SB ZERO, 20(S0)
9D001A58  A2000015   SB ZERO, 21(S0)
2238:                			dj.fs->wflag = 1;
9D001A5C  8FA40010   LW A0, 16(SP)
9D001A60  24020001   ADDIU V0, ZERO, 1
2239:                			if (cl) { /* Remove the cluster chain if exist */
9D001A64  12600049   BEQ S3, ZERO, 0x9D001B8C
9D001A68  A0820004   SB V0, 4(A0)
2240:                				dw = dj.fs->winsect;
9D001A6C  8C94002C   LW S4, 44(A0)
2241:                				res = remove_chain(dj.fs, cl);
9D001A70  0F4004D1   JAL 0x9D001344
9D001A74  02602821   ADDU A1, S3, ZERO
2242:                				if (res == FR_OK) {
9D001A78  1440003B   BNE V0, ZERO, 0x9D001B68
9D001A7C  8FBF004C   LW RA, 76(SP)
2243:                					dj.fs->last_clust = cl - 1; /* Reuse the cluster hole */
9D001A80  8FA40010   LW A0, 16(SP)
9D001A84  2673FFFF   ADDIU S3, S3, -1
9D001A88  AC93000C   SW S3, 12(A0)
2244:                					res = move_window(dj.fs, dw);
9D001A8C  0F400082   JAL 0x9D000208
9D001A90  02802821   ADDU A1, S4, ZERO
2245:                				}
2246:                			}
2247:                		}
2248:                	} else { /* Open an existing file */
2249:                		if (res == FR_OK) { /* Follow succeeded */
9D001AA4  14400030   BNE V0, ZERO, 0x9D001B68
9D001AA8  8FBF004C   LW RA, 76(SP)
2250:                			if (dir[DIR_Attr] & AM_DIR) { /* It is a directory */
9D001AAC  9203000B   LBU V1, 11(S0)
9D001AB0  30640010   ANDI A0, V1, 16
9D001AB4  1480002B   BNE A0, ZERO, 0x9D001B64
9D001AB8  24020004   ADDIU V0, ZERO, 4
2251:                				res = FR_NO_FILE;
2252:                			} else {
2253:                				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
9D001ABC  32730002   ANDI S3, S3, 2
9D001AC0  12600033   BEQ S3, ZERO, 0x9D001B90
9D001AC4  32420008   ANDI V0, S2, 8
9D001AC8  30630001   ANDI V1, V1, 1
9D001ACC  14600025   BNE V1, ZERO, 0x9D001B64
9D001AD0  24020007   ADDIU V0, ZERO, 7
2254:                					res = FR_DENIED;
2255:                			}
2256:                		}
2257:                	}
2258:                	if (res == FR_OK) {
9D001A94  10400012   BEQ V0, ZERO, 0x9D001AE0
9D001A98  36520020   ORI S2, S2, 32
2259:                		if (mode & FA_CREATE_ALWAYS) /* Set file change flag if created or overwritten */
9D001AD4  0B4006E4   J 0x9D001B90
9D001AD8  32420008   ANDI V0, S2, 8
9D001B8C  32420008   ANDI V0, S2, 8
9D001B90  1040FFD4   BEQ V0, ZERO, 0x9D001AE4
9D001B94  8FA30010   LW V1, 16(SP)
9D001B98  0B4006B7   J 0x9D001ADC
9D001B9C  00001021   ADDU V0, ZERO, ZERO
2260:                			mode |= FA__WRITTEN;
9D001ADC  36520020   ORI S2, S2, 32
2261:                		fp->dir_sect = dj.fs->winsect; /* Pointer to the directory entry */
9D001AE0  8FA30010   LW V1, 16(SP)
9D001AE4  8C64002C   LW A0, 44(V1)
9D001AE8  AE24001C   SW A0, 28(S1)
2262:                		fp->dir_ptr = dir;
9D001AEC  AE300020   SW S0, 32(S1)
2263:                #if _FS_SHARE
2264:                		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2265:                		if (!fp->lockid) res = FR_INT_ERR;
2266:                #endif
2267:                	}
2268:                
2269:                #else				/* R/O configuration */
2270:                	if (res == FR_OK) { /* Follow succeeded */
2271:                		if (!dir) { /* Current dir itself */
2272:                			res = FR_INVALID_NAME;
2273:                		} else {
2274:                			if (dir[DIR_Attr] & AM_DIR) /* It is a directory */
2275:                			res = FR_NO_FILE;
2276:                		}
2277:                	}
2278:                #endif
2279:                	FREE_BUF();
2280:                
2281:                	if (res == FR_OK) {
2282:                		fp->flag = mode; /* File access mode */
9D001AF0  A2320006   SB S2, 6(S1)
2283:                		fp->sclust = LD_CLUST(dir); /* File start cluster */
9D001AF4  92050015   LBU A1, 21(S0)
9D001AF8  00052A00   SLL A1, A1, 8
9D001AFC  92060014   LBU A2, 20(S0)
9D001B00  00A62825   OR A1, A1, A2
9D001B04  00052C00   SLL A1, A1, 16
9D001B08  9204001B   LBU A0, 27(S0)
9D001B0C  00042200   SLL A0, A0, 8
9D001B10  9206001A   LBU A2, 26(S0)
9D001B14  00862025   OR A0, A0, A2
9D001B18  00A42025   OR A0, A1, A0
9D001B1C  AE240010   SW A0, 16(S1)
2284:                		fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
9D001B20  9205001F   LBU A1, 31(S0)
9D001B24  00052E00   SLL A1, A1, 24
9D001B28  9204001E   LBU A0, 30(S0)
9D001B2C  00042400   SLL A0, A0, 16
9D001B30  00A42025   OR A0, A1, A0
9D001B34  9205001C   LBU A1, 28(S0)
9D001B38  00852025   OR A0, A0, A1
9D001B3C  9205001D   LBU A1, 29(S0)
9D001B40  00052A00   SLL A1, A1, 8
9D001B44  00852025   OR A0, A0, A1
9D001B48  AE24000C   SW A0, 12(S1)
2285:                		fp->fptr = 0; /* File pointer */
9D001B4C  AE200008   SW ZERO, 8(S1)
2286:                		fp->dsect = 0;
9D001B50  AE200018   SW ZERO, 24(S1)
2287:                #if _USE_FASTSEEK
2288:                		fp->cltbl = 0; /* Normal seek mode */
9D001B54  AE200024   SW ZERO, 36(S1)
2289:                #endif
2290:                		fp->fs = dj.fs;
9D001B58  AE230000   SW V1, 0(S1)
2291:                		fp->id = dj.fs->id; /* Validate file object */
9D001B5C  94630006   LHU V1, 6(V1)
9D001B60  A6230004   SH V1, 4(S1)
2292:                	}
2293:                
2294:                	LEAVE_FF(dj.fs, res);
2295:                }
9D0019C0  0B4006DA   J 0x9D001B68
9D0019C4  8FBF004C   LW RA, 76(SP)
9D001A9C  0B4006DA   J 0x9D001B68
9D001AA0  8FBF004C   LW RA, 76(SP)
9D001B64  8FBF004C   LW RA, 76(SP)
9D001B68  8FB40048   LW S4, 72(SP)
9D001B6C  8FB30044   LW S3, 68(SP)
9D001B70  8FB20040   LW S2, 64(SP)
9D001B74  8FB1003C   LW S1, 60(SP)
9D001B78  8FB00038   LW S0, 56(SP)
9D001B7C  03E00008   JR RA
9D001B80  27BD0050   ADDIU SP, SP, 80
2296:                
2297:                /*-----------------------------------------------------------------------*/
2298:                /* Read File                                                             */
2299:                /*-----------------------------------------------------------------------*/
2300:                
2301:                FRESULT f_read(FIL *fp, /* Pointer to the file object */
2302:                                void *buff, /* Pointer to data buffer */
2303:                                UINT btr, /* Number of bytes to read */
2304:                                UINT *br /* Pointer to number of bytes read */
2305:                                ) {
9D001BA0  27BDFFC8   ADDIU SP, SP, -56
9D001BA4  AFBF0034   SW RA, 52(SP)
9D001BA8  AFBE0030   SW S8, 48(SP)
9D001BAC  AFB7002C   SW S7, 44(SP)
9D001BB0  AFB60028   SW S6, 40(SP)
9D001BB4  AFB50024   SW S5, 36(SP)
9D001BB8  AFB40020   SW S4, 32(SP)
9D001BBC  AFB3001C   SW S3, 28(SP)
9D001BC0  AFB20018   SW S2, 24(SP)
9D001BC4  AFB10014   SW S1, 20(SP)
9D001BC8  AFB00010   SW S0, 16(SP)
9D001BCC  00808021   ADDU S0, A0, ZERO
9D001BD0  00A0A021   ADDU S4, A1, ZERO
9D001BD4  00C08821   ADDU S1, A2, ZERO
9D001BD8  00E09821   ADDU S3, A3, ZERO
2306:                	FRESULT res;
2307:                	DWORD clst, sect, remain;
2308:                	UINT rcnt, cc;
2309:                	PF_BYTE csect, *rbuff = buff;
2310:                
2311:                	*br = 0; /* Initialize byte counter */
9D001BDC  ACE00000   SW ZERO, 0(A3)
2312:                
2313:                	res = validate(fp->fs, fp->id); /* Check validity */
9D001BE0  8C840000   LW A0, 0(A0)
9D001BE4  0F400143   JAL 0x9D00050C
9D001BE8  96050004   LHU A1, 4(S0)
2314:                	if (res != FR_OK)
9D001BEC  1440008A   BNE V0, ZERO, 0x9D001E18
9D001BF0  0040B821   ADDU S7, V0, ZERO
2315:                		LEAVE_FF(fp->fs, res);
2316:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D001BF4  92020006   LBU V0, 6(S0)
9D001BF8  7C021C20   SEB V1, V0
9D001BFC  04600085   BLTZ V1, 0x9D001E14
9D001C00  30420001   ANDI V0, V0, 1
2317:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2318:                	if (!(fp->flag & FA_READ)) /* Check access mode */
9D001C04  50400084   BEQL V0, ZERO, 0x9D001E18
9D001C08  24170007   ADDIU S7, ZERO, 7
9D001C18  0251102B   SLTU V0, S2, S1
9D001C1C  0222900A   MOVZ S2, S1, V0
2319:                		LEAVE_FF(fp->fs, FR_DENIED);
2320:                	remain = fp->fsize - fp->fptr;
9D001C0C  8E12000C   LW S2, 12(S0)
9D001C10  8E020008   LW V0, 8(S0)
9D001C14  02429023   SUBU S2, S2, V0
2321:                	if (btr > remain)
2322:                		btr = (UINT) remain; /* Truncate btr by remaining bytes */
2323:                
2324:                	for (; btr; /* Repeat until all data read */
9D001C20  1240007E   BEQ S2, ZERO, 0x9D001E1C
9D001C24  02E01021   ADDU V0, S7, ZERO
9D001E04  12400004   BEQ S2, ZERO, 0x9D001E18
9D001E08  AE620000   SW V0, 0(S3)
2325:                	rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
9D001DEC  8E020008   LW V0, 8(S0)
9D001DF0  00511021   ADDU V0, V0, S1
9D001DF4  AE020008   SW V0, 8(S0)
9D001DF8  8E620000   LW V0, 0(S3)
9D001DFC  00511021   ADDU V0, V0, S1
9D001E00  02519023   SUBU S2, S2, S1
9D001E0C  0B40070A   J 0x9D001C28
9D001E10  0291A021   ADDU S4, S4, S1
9D001E14  24170002   ADDIU S7, ZERO, 2
2326:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D001C28  8E050008   LW A1, 8(S0)
9D001C2C  30A201FF   ANDI V0, A1, 511
9D001C30  54400057   BNEL V0, ZERO, 0x9D001D90
9D001C34  8E110008   LW S1, 8(S0)
2327:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D001C38  8E040000   LW A0, 0(S0)
9D001C3C  00051242   SRL V0, A1, 9
9D001C40  90950002   LBU S5, 2(A0)
9D001C44  26B5FFFF   ADDIU S5, S5, -1
9D001C48  0055A824   AND S5, V0, S5
9D001C4C  32B500FF   ANDI S5, S5, 255
2328:                			if (!csect) { /* On the cluster boundary? */
9D001C50  56A0001F   BNEL S5, ZERO, 0x9D001CD0
9D001C54  8E160000   LW S6, 0(S0)
2329:                				if (fp->fptr == 0) { /* On the top of the file? */
9D001C58  54A00003   BNEL A1, ZERO, 0x9D001C68
9D001C5C  8E020024   LW V0, 36(S0)
2330:                					clst = fp->sclust; /* Follow from the origin */
9D001C60  0B400722   J 0x9D001C88
9D001C64  8E020010   LW V0, 16(S0)
2331:                				} else { /* Middle or end of the file */
2332:                #if _USE_FASTSEEK
2333:                					if (fp->cltbl)
9D001C68  10400005   BEQ V0, ZERO, 0x9D001C80
9D001C6C  00000000   NOP
2334:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D001C70  0F40001B   JAL 0x9D00006C
9D001C74  02002021   ADDU A0, S0, ZERO
2335:                					else
2336:                #endif
2337:                						clst = get_fat(fp->fs, fp->clust); /* Follow cluster chain on the FAT */
9D001C80  0F400162   JAL get_fat
9D001C84  8E050014   LW A1, 20(S0)
2338:                				}
2339:                				if (clst < 2)
9D001C78  0B400723   J 0x9D001C8C
9D001C7C  2C430002   SLTIU V1, V0, 2
9D001C88  2C430002   SLTIU V1, V0, 2
9D001C8C  10600007   BEQ V1, ZERO, 0x9D001CAC
9D001C90  2403FFFF   ADDIU V1, ZERO, -1
2340:                					ABORT(fp->fs, FR_INT_ERR);
9D001C94  92030006   LBU V1, 6(S0)
9D001C98  2402FF80   ADDIU V0, ZERO, -128
9D001C9C  00621025   OR V0, V1, V0
9D001CA0  A2020006   SB V0, 6(S0)
9D001CA4  0B400786   J 0x9D001E18
9D001CA8  24170002   ADDIU S7, ZERO, 2
2341:                				if (clst == 0xFFFFFFFF)
9D001CAC  54430007   BNEL V0, V1, 0x9D001CCC
9D001CB0  AE020014   SW V0, 20(S0)
2342:                					ABORT(fp->fs, FR_DISK_ERR);
9D001CB4  92030006   LBU V1, 6(S0)
9D001CB8  2402FF80   ADDIU V0, ZERO, -128
9D001CBC  00621025   OR V0, V1, V0
9D001CC0  A2020006   SB V0, 6(S0)
9D001CC4  0B400786   J 0x9D001E18
9D001CC8  24170001   ADDIU S7, ZERO, 1
2343:                				fp->clust = clst; /* Update current cluster */
2344:                			}
2345:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D001CCC  8E160000   LW S6, 0(S0)
9D001CD0  02C02021   ADDU A0, S6, ZERO
9D001CD4  0F400156   JAL clust2sect
9D001CD8  8E050014   LW A1, 20(S0)
2346:                			if (!sect)
9D001CDC  14400007   BNE V0, ZERO, 0x9D001CFC
9D001CE0  00128A42   SRL S1, S2, 9
2347:                				ABORT(fp->fs, FR_INT_ERR);
9D001CE4  92030006   LBU V1, 6(S0)
9D001CE8  2402FF80   ADDIU V0, ZERO, -128
9D001CEC  00621025   OR V0, V1, V0
9D001CF0  A2020006   SB V0, 6(S0)
9D001CF4  0B400786   J 0x9D001E18
9D001CF8  24170002   ADDIU S7, ZERO, 2
2348:                			sect += csect;
2349:                			cc = btr / SS(fp->fs); /* When remaining bytes >= sector size, */
2350:                			if (cc) { /* Read maximum contiguous sectors directly */
9D001CFC  12200022   BEQ S1, ZERO, 0x9D001D88
9D001D00  0055F021   ADDU S8, V0, S5
2351:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D001D04  92C20002   LBU V0, 2(S6)
9D001D08  02351821   ADDU V1, S1, S5
9D001D0C  0043182B   SLTU V1, V0, V1
2352:                					cc = fp->fs->csize - csect;
9D001D10  0055A823   SUBU S5, V0, S5
9D001D14  02A3880B   MOVN S1, S5, V1
2353:                				if (disk_read(fp->fs->drv, rbuff, sect, (PF_BYTE) cc) != RES_OK)
9D001D18  92C40001   LBU A0, 1(S6)
9D001D1C  02802821   ADDU A1, S4, ZERO
9D001D20  03C03021   ADDU A2, S8, ZERO
9D001D24  0F401B5A   JAL disk_read
9D001D28  322700FF   ANDI A3, S1, 255
9D001D2C  50400007   BEQL V0, ZERO, 0x9D001D4C
9D001D30  8E050000   LW A1, 0(S0)
2354:                					ABORT(fp->fs, FR_DISK_ERR);
9D001D34  92030006   LBU V1, 6(S0)
9D001D38  2402FF80   ADDIU V0, ZERO, -128
9D001D3C  00621025   OR V0, V1, V0
9D001D40  A2020006   SB V0, 6(S0)
9D001D44  0B400786   J 0x9D001E18
9D001D48  24170001   ADDIU S7, ZERO, 1
2355:                #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
2356:                #if _FS_TINY
2357:                				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
9D001D4C  90A20004   LBU V0, 4(A1)
9D001D50  50400026   BEQL V0, ZERO, 0x9D001DEC
9D001D54  00118A40   SLL S1, S1, 9
9D001D58  8CA2002C   LW V0, 44(A1)
9D001D5C  005EF023   SUBU S8, V0, S8
9D001D60  03D1102B   SLTU V0, S8, S1
9D001D64  50400021   BEQL V0, ZERO, 0x9D001DEC
9D001D68  00118A40   SLL S1, S1, 9
2358:                				mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
9D001D6C  001EF240   SLL S8, S8, 9
9D001D70  029E2021   ADDU A0, S4, S8
9D001D74  24A50030   ADDIU A1, A1, 48
9D001D78  0F400008   JAL 0x9D000020
9D001D7C  24060200   ADDIU A2, ZERO, 512
2359:                #else
2360:                				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
2361:                					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf,
2362:                							SS(fp->fs));
2363:                #endif
2364:                #endif
2365:                				rcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2366:                				continue;
9D001D80  0B40077B   J 0x9D001DEC
9D001D84  00118A40   SLL S1, S1, 9
2367:                			}
2368:                #if !_FS_TINY
2369:                			if (fp->dsect != sect) { /* Load data sector if not in cache */
2370:                #if !_FS_READONLY
2371:                				if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2372:                					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2373:                							!= RES_OK)
2374:                						ABORT(fp->fs, FR_DISK_ERR);
2375:                					fp->flag &= ~FA__DIRTY;
2376:                				}
2377:                #endif
2378:                				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK) /* Fill sector cache */
2379:                					ABORT(fp->fs, FR_DISK_ERR);
2380:                			}
2381:                #endif
2382:                			fp->dsect = sect;
9D001D88  AE1E0018   SW S8, 24(S0)
2383:                		}
2384:                		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs)); /* Get partial sector data from sector buffer */
9D001D8C  8E110008   LW S1, 8(S0)
9D001DBC  24020200   ADDIU V0, ZERO, 512
9D001DC0  00518823   SUBU S1, V0, S1
9D001DC4  0232102B   SLTU V0, S1, S2
9D001DC8  0242880A   MOVZ S1, S2, V0
2385:                		if (rcnt > btr)
2386:                			rcnt = btr;
2387:                #if _FS_TINY
2388:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D001D90  8E040000   LW A0, 0(S0)
9D001D94  0F400082   JAL 0x9D000208
9D001D98  8E050018   LW A1, 24(S0)
9D001D9C  10400007   BEQ V0, ZERO, 0x9D001DBC
9D001DA0  323101FF   ANDI S1, S1, 511
2389:                		ABORT(fp->fs, FR_DISK_ERR);
9D001DA4  92030006   LBU V1, 6(S0)
9D001DA8  2402FF80   ADDIU V0, ZERO, -128
9D001DAC  00621025   OR V0, V1, V0
9D001DB0  A2020006   SB V0, 6(S0)
9D001DB4  0B400786   J 0x9D001E18
9D001DB8  24170001   ADDIU S7, ZERO, 1
2390:                		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
9D001DCC  8E050000   LW A1, 0(S0)
9D001DD0  24A50030   ADDIU A1, A1, 48
9D001DD4  8E020008   LW V0, 8(S0)
9D001DD8  304201FF   ANDI V0, V0, 511
9D001DDC  02802021   ADDU A0, S4, ZERO
9D001DE0  00A22821   ADDU A1, A1, V0
9D001DE4  0F400008   JAL 0x9D000020
9D001DE8  02203021   ADDU A2, S1, ZERO
2391:                #else
2392:                		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
2393:                #endif
2394:                	}
2395:                
2396:                	LEAVE_FF(fp->fs, FR_OK);
2397:                }
9D001E18  02E01021   ADDU V0, S7, ZERO
9D001E1C  8FBF0034   LW RA, 52(SP)
9D001E20  8FBE0030   LW S8, 48(SP)
9D001E24  8FB7002C   LW S7, 44(SP)
9D001E28  8FB60028   LW S6, 40(SP)
9D001E2C  8FB50024   LW S5, 36(SP)
9D001E30  8FB40020   LW S4, 32(SP)
9D001E34  8FB3001C   LW S3, 28(SP)
9D001E38  8FB20018   LW S2, 24(SP)
9D001E3C  8FB10014   LW S1, 20(SP)
9D001E40  8FB00010   LW S0, 16(SP)
9D001E44  03E00008   JR RA
9D001E48  27BD0038   ADDIU SP, SP, 56
2398:                
2399:                #if !_FS_READONLY
2400:                /*-----------------------------------------------------------------------*/
2401:                /* Write File                                                            */
2402:                /*-----------------------------------------------------------------------*/
2403:                
2404:                FRESULT f_write(FIL *fp, /* Pointer to the file object */
2405:                                const void *buff, /* Pointer to the data to be written */
2406:                                UINT btw, /* Number of bytes to write */
2407:                                UINT *bw /* Pointer to number of bytes written */
2408:                                ) {
9D001E4C  27BDFFC8   ADDIU SP, SP, -56
9D001E50  AFBF0034   SW RA, 52(SP)
9D001E54  AFBE0030   SW S8, 48(SP)
9D001E58  AFB7002C   SW S7, 44(SP)
9D001E5C  AFB60028   SW S6, 40(SP)
9D001E60  AFB50024   SW S5, 36(SP)
9D001E64  AFB40020   SW S4, 32(SP)
9D001E68  AFB3001C   SW S3, 28(SP)
9D001E6C  AFB20018   SW S2, 24(SP)
9D001E70  AFB10014   SW S1, 20(SP)
9D001E74  AFB00010   SW S0, 16(SP)
9D001E78  00808021   ADDU S0, A0, ZERO
9D001E7C  00A0A021   ADDU S4, A1, ZERO
9D001E80  00C08821   ADDU S1, A2, ZERO
9D001E84  00E09821   ADDU S3, A3, ZERO
2409:                	FRESULT res;
2410:                	DWORD clst, sect;
2411:                	UINT wcnt, cc;
2412:                	const PF_BYTE *wbuff = buff;
2413:                	PF_BYTE csect;
2414:                
2415:                	*bw = 0; /* Initialize byte counter */
9D001E88  ACE00000   SW ZERO, 0(A3)
2416:                
2417:                	res = validate(fp->fs, fp->id); /* Check validity */
9D001E8C  8C840000   LW A0, 0(A0)
9D001E90  0F400143   JAL 0x9D00050C
9D001E94  96050004   LHU A1, 4(S0)
2418:                	if (res != FR_OK)
9D001E98  144000BA   BNE V0, ZERO, 0x9D002184
9D001E9C  0040B821   ADDU S7, V0, ZERO
2419:                		LEAVE_FF(fp->fs, res);
2420:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D001EA0  92020006   LBU V0, 6(S0)
9D001EA4  7C021C20   SEB V1, V0
9D001EA8  046000B5   BLTZ V1, 0x9D002180
9D001EAC  30420002   ANDI V0, V0, 2
2421:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2422:                	if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D001EB0  504000B4   BEQL V0, ZERO, 0x9D002184
9D001EB4  24170007   ADDIU S7, ZERO, 7
2423:                		LEAVE_FF(fp->fs, FR_DENIED);
2424:                	if ((DWORD) (fp->fsize + btw) < fp->fsize)
9D001EB8  8E02000C   LW V0, 12(S0)
9D001EBC  02221821   ADDU V1, S1, V0
9D001EC0  0062102B   SLTU V0, V1, V0
9D001EC4  544000A6   BNEL V0, ZERO, 0x9D002160
9D001EC8  8E020008   LW V0, 8(S0)
2425:                		btw = 0; /* File size cannot reach 4GB */
2426:                
2427:                	for (; btw; /* Repeat until all data written */
9D001ECC  522000A4   BEQL S1, ZERO, 0x9D002160
9D001ED0  8E020008   LW V0, 8(S0)
9D00214C  12200003   BEQ S1, ZERO, 0x9D00215C
9D002150  AE620000   SW V0, 0(S3)
2428:                	wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
9D002134  8E020008   LW V0, 8(S0)
9D002138  00521021   ADDU V0, V0, S2
9D00213C  AE020008   SW V0, 8(S0)
9D002140  8E620000   LW V0, 0(S3)
9D002144  00521021   ADDU V0, V0, S2
9D002148  02328823   SUBU S1, S1, S2
9D002154  0B4007B5   J 0x9D001ED4
9D002158  0292A021   ADDU S4, S4, S2
2429:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D001ED4  8E050008   LW A1, 8(S0)
9D001ED8  30A201FF   ANDI V0, A1, 511
9D001EDC  5440007B   BNEL V0, ZERO, 0x9D0020CC
9D001EE0  8E120008   LW S2, 8(S0)
2430:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D001EE4  8E040000   LW A0, 0(S0)
9D001EE8  00051242   SRL V0, A1, 9
9D001EEC  90950002   LBU S5, 2(A0)
9D001EF0  26B5FFFF   ADDIU S5, S5, -1
9D001EF4  0055A824   AND S5, V0, S5
9D001EF8  32B500FF   ANDI S5, S5, 255
2431:                			if (!csect) { /* On the cluster boundary? */
9D001EFC  56A00026   BNEL S5, ZERO, 0x9D001F98
9D001F00  8C83002C   LW V1, 44(A0)
2432:                				if (fp->fptr == 0) { /* On the top of the file? */
9D001F04  54A00008   BNEL A1, ZERO, 0x9D001F28
9D001F08  8E020024   LW V0, 36(S0)
2433:                					clst = fp->sclust; /* Follow from the origin */
9D001F0C  8E020010   LW V0, 16(S0)
2434:                					if (clst == 0) /* When no cluster is allocated, */
9D001F10  1440000F   BNE V0, ZERO, 0x9D001F50
9D001F14  24030001   ADDIU V1, ZERO, 1
2435:                						fp->sclust = clst = create_chain(fp->fs, 0); /* Create a new cluster chain */
9D001F18  0F4002A1   JAL 0x9D000A84
9D001F1C  00000000   NOP
9D001F20  0B4007D2   J 0x9D001F48
9D001F24  AE020010   SW V0, 16(S0)
2436:                				} else { /* Middle or end of the file */
2437:                #if _USE_FASTSEEK
2438:                					if (fp->cltbl)
9D001F28  10400005   BEQ V0, ZERO, 0x9D001F40
9D001F2C  00000000   NOP
2439:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D001F30  0F40001B   JAL 0x9D00006C
9D001F34  02002021   ADDU A0, S0, ZERO
9D001F38  0B4007D2   J 0x9D001F48
9D001F3C  00000000   NOP
2440:                					else
2441:                #endif
2442:                						clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
9D001F40  0F4002A1   JAL 0x9D000A84
9D001F44  8E050014   LW A1, 20(S0)
2443:                				}
2444:                				if (clst == 0)
9D001F48  10400084   BEQ V0, ZERO, 0x9D00215C
9D001F4C  24030001   ADDIU V1, ZERO, 1
2445:                					break; /* Could not allocate a new cluster (disk full) */
2446:                				if (clst == 1)
9D001F50  14430007   BNE V0, V1, 0x9D001F70
9D001F54  2403FFFF   ADDIU V1, ZERO, -1
2447:                					ABORT(fp->fs, FR_INT_ERR);
9D001F58  92030006   LBU V1, 6(S0)
9D001F5C  2402FF80   ADDIU V0, ZERO, -128
9D001F60  00621025   OR V0, V1, V0
9D001F64  A2020006   SB V0, 6(S0)
9D001F68  0B400861   J 0x9D002184
9D001F6C  24170002   ADDIU S7, ZERO, 2
2448:                				if (clst == 0xFFFFFFFF)
9D001F70  54430007   BNEL V0, V1, 0x9D001F90
9D001F74  AE020014   SW V0, 20(S0)
2449:                					ABORT(fp->fs, FR_DISK_ERR);
9D001F78  92030006   LBU V1, 6(S0)
9D001F7C  2402FF80   ADDIU V0, ZERO, -128
9D001F80  00621025   OR V0, V1, V0
9D001F84  A2020006   SB V0, 6(S0)
9D001F88  0B400861   J 0x9D002184
9D001F8C  24170001   ADDIU S7, ZERO, 1
2450:                				fp->clust = clst; /* Update current cluster */
2451:                			}
2452:                #if _FS_TINY
2453:                			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0)) /* Write-back sector cache */
9D001F90  8E040000   LW A0, 0(S0)
9D001F94  8C83002C   LW V1, 44(A0)
9D001F98  8E020018   LW V0, 24(S0)
9D001F9C  5462000B   BNEL V1, V0, 0x9D001FCC
9D001FA0  8E160000   LW S6, 0(S0)
9D001FA4  0F400082   JAL 0x9D000208
9D001FA8  00002821   ADDU A1, ZERO, ZERO
9D001FAC  50400007   BEQL V0, ZERO, 0x9D001FCC
9D001FB0  8E160000   LW S6, 0(S0)
2454:                			ABORT(fp->fs, FR_DISK_ERR);
9D001FB4  92030006   LBU V1, 6(S0)
9D001FB8  2402FF80   ADDIU V0, ZERO, -128
9D001FBC  00621025   OR V0, V1, V0
9D001FC0  A2020006   SB V0, 6(S0)
9D001FC4  0B400861   J 0x9D002184
9D001FC8  24170001   ADDIU S7, ZERO, 1
2455:                #else
2456:                			if (fp->flag & FA__DIRTY) { /* Write-back sector cache */
2457:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2458:                					ABORT(fp->fs, FR_DISK_ERR);
2459:                				fp->flag &= ~FA__DIRTY;
2460:                			}
2461:                #endif
2462:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D001FCC  02C02021   ADDU A0, S6, ZERO
9D001FD0  0F400156   JAL clust2sect
9D001FD4  8E050014   LW A1, 20(S0)
2463:                			if (!sect)
9D001FD8  14400007   BNE V0, ZERO, 0x9D001FF8
9D001FDC  00119242   SRL S2, S1, 9
2464:                				ABORT(fp->fs, FR_INT_ERR);
9D001FE0  92030006   LBU V1, 6(S0)
9D001FE4  2402FF80   ADDIU V0, ZERO, -128
9D001FE8  00621025   OR V0, V1, V0
9D001FEC  A2020006   SB V0, 6(S0)
9D001FF0  0B400861   J 0x9D002184
9D001FF4  24170002   ADDIU S7, ZERO, 2
2465:                			sect += csect;
2466:                			cc = btw / SS(fp->fs); /* When remaining bytes >= sector size, */
2467:                			if (cc) { /* Write maximum contiguous sectors directly */
9D001FF8  12400021   BEQ S2, ZERO, 0x9D002080
9D001FFC  0055F021   ADDU S8, V0, S5
2468:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D002000  92C20002   LBU V0, 2(S6)
9D002004  02551821   ADDU V1, S2, S5
9D002008  0043182B   SLTU V1, V0, V1
2469:                					cc = fp->fs->csize - csect;
9D00200C  0055A823   SUBU S5, V0, S5
9D002010  02A3900B   MOVN S2, S5, V1
2470:                				if (disk_write(fp->fs->drv, wbuff, sect, (PF_BYTE) cc)
9D002014  92C40001   LBU A0, 1(S6)
9D002018  02802821   ADDU A1, S4, ZERO
9D00201C  03C03021   ADDU A2, S8, ZERO
9D002020  0F401B90   JAL disk_write
9D002024  324700FF   ANDI A3, S2, 255
9D002028  50400007   BEQL V0, ZERO, 0x9D002048
9D00202C  8E040000   LW A0, 0(S0)
2471:                						!= RES_OK)
2472:                					ABORT(fp->fs, FR_DISK_ERR);
9D002030  92030006   LBU V1, 6(S0)
9D002034  2402FF80   ADDIU V0, ZERO, -128
9D002038  00621025   OR V0, V1, V0
9D00203C  A2020006   SB V0, 6(S0)
9D002040  0B400861   J 0x9D002184
9D002044  24170001   ADDIU S7, ZERO, 1
2473:                #if _FS_TINY
2474:                				if (fp->fs->winsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
9D002048  8C82002C   LW V0, 44(A0)
9D00204C  005EF023   SUBU S8, V0, S8
9D002050  03D2102B   SLTU V0, S8, S2
9D002054  50400037   BEQL V0, ZERO, 0x9D002134
9D002058  00129240   SLL S2, S2, 9
2475:                					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
9D00205C  001EF240   SLL S8, S8, 9
9D002060  24840030   ADDIU A0, A0, 48
9D002064  029E2821   ADDU A1, S4, S8
9D002068  0F400008   JAL 0x9D000020
9D00206C  24060200   ADDIU A2, ZERO, 512
2476:                					fp->fs->wflag = 0;
9D002070  8E020000   LW V0, 0(S0)
9D002074  A0400004   SB ZERO, 4(V0)
2477:                				}
2478:                #else
2479:                				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
2480:                					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)),
2481:                							SS(fp->fs));
2482:                					fp->flag &= ~FA__DIRTY;
2483:                				}
2484:                #endif
2485:                				wcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2486:                				continue;
9D002078  0B40084D   J 0x9D002134
9D00207C  00129240   SLL S2, S2, 9
2487:                			}
2488:                #if _FS_TINY
2489:                			if (fp->fptr >= fp->fsize) { /* Avoid silly cache filling at growing edge */
9D002080  8E030008   LW V1, 8(S0)
9D002084  8E02000C   LW V0, 12(S0)
9D002088  0062102B   SLTU V0, V1, V0
9D00208C  5440000E   BNEL V0, ZERO, 0x9D0020C8
9D002090  AE1E0018   SW S8, 24(S0)
2490:                				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
9D002094  02C02021   ADDU A0, S6, ZERO
9D002098  0F400082   JAL 0x9D000208
9D00209C  00002821   ADDU A1, ZERO, ZERO
9D0020A0  50400007   BEQL V0, ZERO, 0x9D0020C0
9D0020A4  8E020000   LW V0, 0(S0)
9D0020A8  92030006   LBU V1, 6(S0)
9D0020AC  2402FF80   ADDIU V0, ZERO, -128
9D0020B0  00621025   OR V0, V1, V0
9D0020B4  A2020006   SB V0, 6(S0)
9D0020B8  0B400861   J 0x9D002184
9D0020BC  24170001   ADDIU S7, ZERO, 1
2491:                				fp->fs->winsect = sect;
9D0020C0  AC5E002C   SW S8, 44(V0)
2492:                			}
2493:                #else
2494:                			if (fp->dsect != sect) { /* Fill sector cache with file data */
2495:                				if (fp->fptr < fp->fsize && disk_read(fp->fs->drv, fp->buf,
2496:                						sect, 1) != RES_OK)
2497:                					ABORT(fp->fs, FR_DISK_ERR);
2498:                			}
2499:                #endif
2500:                			fp->dsect = sect;
9D0020C4  AE1E0018   SW S8, 24(S0)
2501:                		}
2502:                		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
9D0020C8  8E120008   LW S2, 8(S0)
9D0020F8  24020200   ADDIU V0, ZERO, 512
9D0020FC  00529023   SUBU S2, V0, S2
9D002100  0251102B   SLTU V0, S2, S1
9D002104  0222900A   MOVZ S2, S1, V0
2503:                		if (wcnt > btw)
2504:                			wcnt = btw;
2505:                #if _FS_TINY
2506:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D0020CC  8E040000   LW A0, 0(S0)
9D0020D0  0F400082   JAL 0x9D000208
9D0020D4  8E050018   LW A1, 24(S0)
9D0020D8  10400007   BEQ V0, ZERO, 0x9D0020F8
9D0020DC  325201FF   ANDI S2, S2, 511
2507:                		ABORT(fp->fs, FR_DISK_ERR);
9D0020E0  92030006   LBU V1, 6(S0)
9D0020E4  2402FF80   ADDIU V0, ZERO, -128
9D0020E8  00621025   OR V0, V1, V0
9D0020EC  A2020006   SB V0, 6(S0)
9D0020F0  0B400861   J 0x9D002184
9D0020F4  24170001   ADDIU S7, ZERO, 1
2508:                		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
9D002108  8E040000   LW A0, 0(S0)
9D00210C  24840030   ADDIU A0, A0, 48
9D002110  8E020008   LW V0, 8(S0)
9D002114  304201FF   ANDI V0, V0, 511
9D002118  00822021   ADDU A0, A0, V0
9D00211C  02802821   ADDU A1, S4, ZERO
9D002120  0F400008   JAL 0x9D000020
9D002124  02403021   ADDU A2, S2, ZERO
2509:                		fp->fs->wflag = 1;
9D002128  8E020000   LW V0, 0(S0)
9D00212C  24030001   ADDIU V1, ZERO, 1
9D002130  A0430004   SB V1, 4(V0)
2510:                #else
2511:                		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
2512:                		fp->flag |= FA__DIRTY;
2513:                #endif
2514:                	}
2515:                
2516:                	if (fp->fptr > fp->fsize)
9D00215C  8E020008   LW V0, 8(S0)
9D002160  8E03000C   LW V1, 12(S0)
9D002164  0062182B   SLTU V1, V1, V0
9D002168  54600001   BNEL V1, ZERO, 0x9D002170
9D00216C  AE02000C   SW V0, 12(S0)
2517:                		fp->fsize = fp->fptr; /* Update file size if needed */
2518:                	fp->flag |= FA__WRITTEN; /* Set file change flag */
9D002170  92020006   LBU V0, 6(S0)
9D002174  34420020   ORI V0, V0, 32
2519:                
2520:                	LEAVE_FF(fp->fs, FR_OK);
9D002178  0B400861   J 0x9D002184
9D00217C  A2020006   SB V0, 6(S0)
9D002180  24170002   ADDIU S7, ZERO, 2
2521:                }
9D002184  02E01021   ADDU V0, S7, ZERO
9D002188  8FBF0034   LW RA, 52(SP)
9D00218C  8FBE0030   LW S8, 48(SP)
9D002190  8FB7002C   LW S7, 44(SP)
9D002194  8FB60028   LW S6, 40(SP)
9D002198  8FB50024   LW S5, 36(SP)
9D00219C  8FB40020   LW S4, 32(SP)
9D0021A0  8FB3001C   LW S3, 28(SP)
9D0021A4  8FB20018   LW S2, 24(SP)
9D0021A8  8FB10014   LW S1, 20(SP)
9D0021AC  8FB00010   LW S0, 16(SP)
9D0021B0  03E00008   JR RA
9D0021B4  27BD0038   ADDIU SP, SP, 56
2522:                
2523:                /*-----------------------------------------------------------------------*/
2524:                /* Synchronize the File Object                                           */
2525:                /*-----------------------------------------------------------------------*/
2526:                
2527:                FRESULT f_sync(FIL *fp /* Pointer to the file object */
2528:                ) {
9D0021B8  27BDFFE0   ADDIU SP, SP, -32
9D0021BC  AFBF001C   SW RA, 28(SP)
9D0021C0  AFB10018   SW S1, 24(SP)
9D0021C4  AFB00014   SW S0, 20(SP)
9D0021C8  00808021   ADDU S0, A0, ZERO
2529:                	FRESULT res;
2530:                	DWORD tim;
2531:                	PF_BYTE *dir;
2532:                
2533:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D0021CC  8C840000   LW A0, 0(A0)
9D0021D0  0F400143   JAL 0x9D00050C
9D0021D4  96050004   LHU A1, 4(S0)
2534:                	if (res == FR_OK) {
9D0021D8  14400032   BNE V0, ZERO, 0x9D0022A4
9D0021DC  8FBF001C   LW RA, 28(SP)
2535:                		if (fp->flag & FA__WRITTEN) { /* Has the file been written? */
9D0021E0  92030006   LBU V1, 6(S0)
9D0021E4  30630020   ANDI V1, V1, 32
9D0021E8  1060002F   BEQ V1, ZERO, 0x9D0022A8
9D0021EC  8FB10018   LW S1, 24(SP)
2536:                #if !_FS_TINY	/* Write-back dirty buffer */
2537:                			if (fp->flag & FA__DIRTY) {
2538:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2539:                					LEAVE_FF(fp->fs, FR_DISK_ERR);
2540:                				fp->flag &= ~FA__DIRTY;
2541:                			}
2542:                #endif
2543:                			/* Update the directory entry */
2544:                			res = move_window(fp->fs, fp->dir_sect);
9D0021F0  8E040000   LW A0, 0(S0)
9D0021F4  0F400082   JAL 0x9D000208
9D0021F8  8E05001C   LW A1, 28(S0)
2545:                			if (res == FR_OK) {
9D0021FC  14400029   BNE V0, ZERO, 0x9D0022A4
9D002200  8FBF001C   LW RA, 28(SP)
2546:                				dir = fp->dir_ptr;
9D002204  8E110020   LW S1, 32(S0)
2547:                				dir[DIR_Attr] |= AM_ARC; /* Set archive bit */
9D002208  9222000B   LBU V0, 11(S1)
9D00220C  34420020   ORI V0, V0, 32
9D002210  A222000B   SB V0, 11(S1)
2548:                				ST_DWORD(dir+DIR_FileSize, fp->fsize); /* Update file size */
9D002214  8E02000C   LW V0, 12(S0)
9D002218  A222001C   SB V0, 28(S1)
9D00221C  9602000C   LHU V0, 12(S0)
9D002220  00021202   SRL V0, V0, 8
9D002224  A222001D   SB V0, 29(S1)
9D002228  9602000E   LHU V0, 14(S0)
9D00222C  A222001E   SB V0, 30(S1)
9D002230  9202000F   LBU V0, 15(S0)
9D002234  A222001F   SB V0, 31(S1)
2549:                				ST_CLUST(dir, fp->sclust); /* Update start cluster */
9D002238  8E020010   LW V0, 16(S0)
9D00223C  A222001A   SB V0, 26(S1)
9D002240  96020010   LHU V0, 16(S0)
9D002244  00021202   SRL V0, V0, 8
9D002248  A222001B   SB V0, 27(S1)
9D00224C  96020012   LHU V0, 18(S0)
9D002250  A2220014   SB V0, 20(S1)
9D002254  96020012   LHU V0, 18(S0)
9D002258  00021202   SRL V0, V0, 8
2550:                				tim = get_fattime(); /* Update updated time */
9D00225C  0F401CB5   JAL get_fattime
9D002260  A2220015   SB V0, 21(S1)
2551:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D002264  A2220016   SB V0, 22(S1)
9D002268  7C433A00   EXT V1, V0, 8, 8
9D00226C  A2230017   SB V1, 23(S1)
9D002270  00021C02   SRL V1, V0, 16
9D002274  A2230018   SB V1, 24(S1)
9D002278  00021602   SRL V0, V0, 24
9D00227C  A2220019   SB V0, 25(S1)
2552:                				fp->flag &= ~FA__WRITTEN;
9D002280  92020006   LBU V0, 6(S0)
9D002284  304200DF   ANDI V0, V0, 223
9D002288  A2020006   SB V0, 6(S0)
2553:                				fp->fs->wflag = 1;
9D00228C  8E020000   LW V0, 0(S0)
9D002290  24030001   ADDIU V1, ZERO, 1
9D002294  A0430004   SB V1, 4(V0)
2554:                				res = sync(fp->fs);
9D002298  0F4000F9   JAL 0x9D0003E4
9D00229C  8E040000   LW A0, 0(S0)
2555:                			}
2556:                		}
2557:                	}
2558:                
2559:                	LEAVE_FF(fp->fs, res);
2560:                }
9D0022A0  8FBF001C   LW RA, 28(SP)
9D0022A4  8FB10018   LW S1, 24(SP)
9D0022A8  8FB00014   LW S0, 20(SP)
9D0022AC  03E00008   JR RA
9D0022B0  27BD0020   ADDIU SP, SP, 32
2561:                
2562:                #endif /* !_FS_READONLY */
2563:                
2564:                /*-----------------------------------------------------------------------*/
2565:                /* Close File                                                            */
2566:                /*-----------------------------------------------------------------------*/
2567:                
2568:                FRESULT f_close(FIL *fp /* Pointer to the file object to be closed */
2569:                ) {
9D0022B4  27BDFFE8   ADDIU SP, SP, -24
9D0022B8  AFBF0014   SW RA, 20(SP)
9D0022BC  AFB00010   SW S0, 16(SP)
2570:                	FRESULT res;
2571:                
2572:                #if _FS_READONLY
2573:                	FATFS *fs = fp->fs;
2574:                	res = validate(fs, fp->id);
2575:                	if (res == FR_OK) fp->fs = 0; /* Discard file object */
2576:                	LEAVE_FF(fs, res);
2577:                
2578:                #else
2579:                	res = f_sync(fp); /* Flush cached data */
9D0022C0  0F40086E   JAL f_sync
9D0022C4  00808021   ADDU S0, A0, ZERO
2580:                #if _FS_SHARE
2581:                	if (res == FR_OK) { /* Decrement open counter */
2582:                #if _FS_REENTRANT
2583:                		res = validate(fp->fs, fp->id);
2584:                		if (res == FR_OK) {
2585:                			res = dec_lock(fp->lockid);
2586:                			unlock_fs(fp->fs, FR_OK);
2587:                		}
2588:                #else
2589:                		res = dec_lock(fp->lockid);
2590:                #endif
2591:                	}
2592:                #endif
2593:                	if (res == FR_OK)
9D0022C8  50400001   BEQL V0, ZERO, 0x9D0022D0
9D0022CC  AE000000   SW ZERO, 0(S0)
2594:                		fp->fs = 0; /* Discard file object */
2595:                	return res;
2596:                #endif
2597:                }
9D0022D0  8FBF0014   LW RA, 20(SP)
9D0022D4  8FB00010   LW S0, 16(SP)
9D0022D8  03E00008   JR RA
9D0022DC  27BD0018   ADDIU SP, SP, 24
2598:                
2599:                /*-----------------------------------------------------------------------*/
2600:                /* Current Drive/Directory Handlings                                     */
2601:                /*-----------------------------------------------------------------------*/
2602:                
2603:                #if _FS_RPATH >= 1
2604:                
2605:                FRESULT f_chdrive (
2606:                		PF_BYTE drv /* Drive number */
2607:                )
2608:                {
2609:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
2610:                
2611:                	CurrVol = drv;
2612:                
2613:                	return FR_OK;
2614:                }
2615:                
2616:                FRESULT f_chdir (
2617:                		const TCHAR *path /* Pointer to the directory path */
2618:                )
2619:                {
2620:                	FRESULT res;
2621:                	DIR dj;
2622:                	DEF_NAMEBUF;
2623:                
2624:                	res = chk_mounted(&path, &dj.fs, 0);
2625:                	if (res == FR_OK) {
2626:                		INIT_BUF(dj);
2627:                		res = follow_path(&dj, path); /* Follow the path */
2628:                		FREE_BUF();
2629:                		if (res == FR_OK) { /* Follow completed */
2630:                			if (!dj.dir) {
2631:                				dj.fs->cdir = dj.sclust; /* Start directory itself */
2632:                			} else {
2633:                				if (dj.dir[DIR_Attr] & AM_DIR) /* Reached to the directory */
2634:                				dj.fs->cdir = LD_CLUST(dj.dir);
2635:                				else
2636:                				res = FR_NO_PATH; /* Reached but a file */
2637:                			}
2638:                		}
2639:                		if (res == FR_NO_FILE) res = FR_NO_PATH;
2640:                	}
2641:                
2642:                	LEAVE_FF(dj.fs, res);
2643:                }
2644:                
2645:                #if _FS_RPATH >= 2
2646:                FRESULT f_getcwd (
2647:                		TCHAR *path, /* Pointer to the directory path */
2648:                		UINT sz_path /* Size of path */
2649:                )
2650:                {
2651:                	FRESULT res;
2652:                	DIR dj;
2653:                	UINT i, n;
2654:                	DWORD ccl;
2655:                	TCHAR *tp;
2656:                	FILINFO fno;
2657:                	DEF_NAMEBUF;
2658:                
2659:                	*path = 0;
2660:                	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0); /* Get current volume */
2661:                	if (res == FR_OK) {
2662:                		INIT_BUF(dj);
2663:                		i = sz_path; /* Bottom of buffer (dir stack base) */
2664:                		dj.sclust = dj.fs->cdir; /* Start to follow upper dir from current dir */
2665:                		while ((ccl = dj.sclust) != 0) { /* Repeat while current dir is a sub-dir */
2666:                			res = dir_sdi(&dj, 1); /* Get parent dir */
2667:                			if (res != FR_OK) break;
2668:                			res = dir_read(&dj);
2669:                			if (res != FR_OK) break;
2670:                			dj.sclust = LD_CLUST(dj.dir); /* Goto parent dir */
2671:                			res = dir_sdi(&dj, 0);
2672:                			if (res != FR_OK) break;
2673:                			do { /* Find the entry links to the child dir */
2674:                				res = dir_read(&dj);
2675:                				if (res != FR_OK) break;
2676:                				if (ccl == LD_CLUST(dj.dir)) break; /* Found the entry */
2677:                				res = dir_next(&dj, 0);
2678:                			}while (res == FR_OK);
2679:                			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
2680:                			if (res != FR_OK) break;
2681:                #if _USE_LFN
2682:                			fno.lfname = path;
2683:                			fno.lfsize = i;
2684:                #endif
2685:                			get_fileinfo(&dj, &fno); /* Get the dir name and push it to the buffer */
2686:                			tp = fno.fname;
2687:                			if (_USE_LFN && *path) tp = path;
2688:                			for (n = 0; tp[n]; n++);
2689:                			if (i < n + 3) {
2690:                				res = FR_NOT_ENOUGH_CORE; break;
2691:                			}
2692:                			while (n) path[--i] = tp[--n];
2693:                			path[--i] = '/';
2694:                		}
2695:                		tp = path;
2696:                		if (res == FR_OK) {
2697:                			*tp++ = '0' + CurrVol; /* Put drive number */
2698:                			*tp++ = ':';
2699:                			if (i == sz_path) { /* Root-dir */
2700:                				*tp++ = '/';
2701:                			} else { /* Sub-dir */
2702:                				do /* Add stacked path str */
2703:                				*tp++ = path[i++];
2704:                				while (i < sz_path);
2705:                			}
2706:                		}
2707:                		*tp = 0;
2708:                		FREE_BUF();
2709:                	}
2710:                
2711:                	LEAVE_FF(dj.fs, res);
2712:                }
2713:                #endif /* _FS_RPATH >= 2 */
2714:                #endif /* _FS_RPATH >= 1 */
2715:                
2716:                #if _FS_MINIMIZE <= 2
2717:                /*-----------------------------------------------------------------------*/
2718:                /* Seek File R/W Pointer                                                 */
2719:                /*-----------------------------------------------------------------------*/
2720:                
2721:                FRESULT f_lseek(FIL *fp, /* Pointer to the file object */
9D00257C  02539023   SUBU S2, S2, S3
9D002580  2414FFFF   ADDIU S4, ZERO, -1
2722:                                DWORD ofs /* File pointer from top of file */
2723:                                ) {
9D0022E0  27BDFFC8   ADDIU SP, SP, -56
9D0022E4  AFBF0034   SW RA, 52(SP)
9D0022E8  AFBE0030   SW S8, 48(SP)
9D0022EC  AFB7002C   SW S7, 44(SP)
9D0022F0  AFB60028   SW S6, 40(SP)
9D0022F4  AFB50024   SW S5, 36(SP)
9D0022F8  AFB40020   SW S4, 32(SP)
9D0022FC  AFB3001C   SW S3, 28(SP)
9D002300  AFB20018   SW S2, 24(SP)
9D002304  AFB10014   SW S1, 20(SP)
9D002308  AFB00010   SW S0, 16(SP)
9D00230C  00808021   ADDU S0, A0, ZERO
9D002310  00A09021   ADDU S2, A1, ZERO
2724:                	FRESULT res;
2725:                
2726:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D002314  8C840000   LW A0, 0(A0)
9D002318  0F400143   JAL 0x9D00050C
9D00231C  96050004   LHU A1, 4(S0)
2727:                	if (res != FR_OK)
9D002320  144000E5   BNE V0, ZERO, 0x9D0026B8
9D002324  00408821   ADDU S1, V0, ZERO
2728:                		LEAVE_FF(fp->fs, res);
2729:                	if (fp->flag & FA__ERROR) /* Check abort flag */
9D002328  92130006   LBU S3, 6(S0)
9D00232C  7C131420   SEB V0, S3
9D002330  044200E1   BLTZL V0, 0x9D0026B8
9D002334  24110002   ADDIU S1, ZERO, 2
2730:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2731:                
2732:                #if _USE_FASTSEEK
2733:                	if (fp->cltbl) { /* Fast seek */
9D002338  8E170024   LW S7, 36(S0)
9D00233C  12E00055   BEQ S7, ZERO, 0x9D002494
9D002340  2402FFFF   ADDIU V0, ZERO, -1
2734:                		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
2735:                
2736:                		if (ofs == CREATE_LINKMAP) { /* Create CLMT */
9D002344  56420034   BNEL S2, V0, 0x9D002418
9D002348  8E02000C   LW V0, 12(S0)
2737:                			tbl = fp->cltbl;
2738:                			tlen = *tbl++;
9D00234C  8EFE0000   LW S8, 0(S7)
9D002350  26F70004   ADDIU S7, S7, 4
2739:                			ulen = 2; /* Given table size and required table size */
9D002358  24150002   ADDIU S5, ZERO, 2
2740:                			cl = fp->sclust; /* Top of the chain */
9D002354  8E160010   LW S6, 16(S0)
2741:                			if (cl) {
9D00235C  16C00003   BNE S6, ZERO, 0x9D00236C
9D002360  2414FFFF   ADDIU S4, ZERO, -1
2742:                				do {
2743:                					/* Get a fragment */
2744:                					tcl = cl;
2745:                					ncl = 0;
9D002370  00009821   ADDU S3, ZERO, ZERO
2746:                					ulen += 2; /* Top, length and used items */
9D0023CC  26B50002   ADDIU S5, S5, 2
2747:                					do {
2748:                						pcl = cl;
2749:                						ncl++;
2750:                						cl = get_fat(fp->fs, cl);
9D00236C  02C09021   ADDU S2, S6, ZERO
9D002374  8E040000   LW A0, 0(S0)
9D002378  0F400162   JAL get_fat
9D00237C  02402821   ADDU A1, S2, ZERO
2751:                						if (cl <= 1)
9D002380  2C430002   SLTIU V1, V0, 2
9D002384  10600007   BEQ V1, ZERO, 0x9D0023A4
9D002388  00000000   NOP
2752:                							ABORT(fp->fs, FR_INT_ERR);
9D00238C  92030006   LBU V1, 6(S0)
9D002390  2402FF80   ADDIU V0, ZERO, -128
9D002394  00621025   OR V0, V1, V0
9D002398  A2020006   SB V0, 6(S0)
9D00239C  0B4009AE   J 0x9D0026B8
9D0023A0  24110002   ADDIU S1, ZERO, 2
2753:                						if (cl == 0xFFFFFFFF)
9D0023A4  14540007   BNE V0, S4, 0x9D0023C4
9D0023A8  26520001   ADDIU S2, S2, 1
2754:                							ABORT(fp->fs, FR_DISK_ERR);
9D0023AC  92030006   LBU V1, 6(S0)
9D0023B0  2402FF80   ADDIU V0, ZERO, -128
9D0023B4  00621025   OR V0, V1, V0
9D0023B8  A2020006   SB V0, 6(S0)
9D0023BC  0B4009AE   J 0x9D0026B8
9D0023C0  24110001   ADDIU S1, ZERO, 1
2755:                					} while (cl == pcl + 1);
9D0023C4  1242FFEB   BEQ S2, V0, 0x9D002374
9D0023C8  26730001   ADDIU S3, S3, 1
2756:                					if (ulen <= tlen) { /* Store the length and top of the fragment */
9D0023D0  03D5182B   SLTU V1, S8, S5
9D0023D4  54600005   BNEL V1, ZERO, 0x9D0023EC
9D0023D8  8E030000   LW V1, 0(S0)
2757:                						*tbl++ = ncl;
9D0023DC  AEF30000   SW S3, 0(S7)
2758:                						*tbl++ = tcl;
9D0023E0  AEF60004   SW S6, 4(S7)
9D0023E4  26F70008   ADDIU S7, S7, 8
2759:                					}
2760:                				} while (cl < fp->fs->n_fatent); /* Repeat until end of chain */
9D0023E8  8E030000   LW V1, 0(S0)
9D0023EC  8C630018   LW V1, 24(V1)
9D0023F0  0043182B   SLTU V1, V0, V1
9D0023F4  1460FFDD   BNE V1, ZERO, 0x9D00236C
9D0023F8  0040B021   ADDU S6, V0, ZERO
2761:                			}
2762:                			*fp->cltbl = ulen; /* Number of items used */
9D002364  0B400900   J 0x9D002400
9D002368  8E020024   LW V0, 36(S0)
9D0023FC  8E020024   LW V0, 36(S0)
9D002400  AC550000   SW S5, 0(V0)
2763:                			if (ulen <= tlen)
9D002404  03D5A82B   SLTU S5, S8, S5
9D002408  56A000AB   BNEL S5, ZERO, 0x9D0026B8
9D00240C  24110011   ADDIU S1, ZERO, 17
2764:                				*tbl = 0; /* Terminate table */
9D002410  0B4009AE   J 0x9D0026B8
9D002414  AEE00000   SW ZERO, 0(S7)
9D002418  0052182B   SLTU V1, V0, S2
9D00241C  0043900B   MOVN S2, V0, V1
2765:                			else
2766:                				res = FR_NOT_ENOUGH_CORE; /* Given table size is smaller than required */
2767:                
2768:                		} else { /* Fast seek */
2769:                			if (ofs > fp->fsize) /* Clip offset at the file size */
2770:                				ofs = fp->fsize;
2771:                			fp->fptr = ofs; /* Set file pointer */
2772:                			if (ofs) {
9D002420  124000A5   BEQ S2, ZERO, 0x9D0026B8
9D002424  AE120008   SW S2, 8(S0)
2773:                				fp->clust = clmt_clust(fp, ofs - 1);
9D002428  2655FFFF   ADDIU S5, S2, -1
9D00242C  02002021   ADDU A0, S0, ZERO
9D002430  0F40001B   JAL 0x9D00006C
9D002434  02A02821   ADDU A1, S5, ZERO
9D002438  AE020014   SW V0, 20(S0)
2774:                				dsc = clust2sect(fp->fs, fp->clust);
9D00243C  8E140000   LW S4, 0(S0)
9D002440  02802021   ADDU A0, S4, ZERO
9D002444  0F400156   JAL clust2sect
9D002448  00402821   ADDU A1, V0, ZERO
2775:                				if (!dsc)
9D00244C  14400006   BNE V0, ZERO, 0x9D002468
9D002450  325201FF   ANDI S2, S2, 511
2776:                					ABORT(fp->fs, FR_INT_ERR);
9D002454  2402FF80   ADDIU V0, ZERO, -128
9D002458  02629825   OR S3, S3, V0
9D00245C  A2130006   SB S3, 6(S0)
9D002460  0B4009AE   J 0x9D0026B8
9D002464  24110002   ADDIU S1, ZERO, 2
2777:                				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
9D002470  0015AA42   SRL S5, S5, 9
9D002474  2463FFFF   ADDIU V1, V1, -1
9D002478  02A31824   AND V1, S5, V1
9D00247C  00431021   ADDU V0, V0, V1
2778:                				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) { /* Refill sector cache if needed */
9D002468  12400093   BEQ S2, ZERO, 0x9D0026B8
9D00246C  92830002   LBU V1, 2(S4)
9D002480  8E030018   LW V1, 24(S0)
9D002484  5462008C   BNEL V1, V0, 0x9D0026B8
9D002488  AE020018   SW V0, 24(S0)
2779:                #if !_FS_TINY
2780:                #if !_FS_READONLY
2781:                					if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2782:                						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2783:                								!= RES_OK)
2784:                							ABORT(fp->fs, FR_DISK_ERR);
2785:                						fp->flag &= ~FA__DIRTY;
2786:                					}
2787:                #endif
2788:                					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK) /* Load current sector */
2789:                						ABORT(fp->fs, FR_DISK_ERR);
2790:                #endif
2791:                					fp->dsect = dsc;
2792:                				}
2793:                			}
2794:                		}
2795:                	} else
2796:                #endif
2797:                
2798:                	/* Normal Seek */
2799:                	{
2800:                		DWORD clst, bcs, nsect, ifptr;
2801:                
2802:                		if (ofs > fp->fsize /* In read-only mode, clip offset with the file size */
9D002494  8E02000C   LW V0, 12(S0)
9D002498  0052182B   SLTU V1, V0, S2
9D00249C  50600004   BEQL V1, ZERO, 0x9D0024B0
9D0024A0  8E020008   LW V0, 8(S0)
2803:                #if !_FS_READONLY
2804:                				&& !(fp->flag & FA_WRITE)
9D0024A4  32730002   ANDI S3, S3, 2
2805:                #endif
2806:                		)
2807:                			ofs = fp->fsize;
9D0024A8  0053900A   MOVZ S2, V0, S3
2808:                
2809:                		ifptr = fp->fptr;
9D0024AC  8E020008   LW V0, 8(S0)
2810:                		fp->fptr = nsect = 0;
2811:                		if (ofs) {
9D0024B0  12400081   BEQ S2, ZERO, 0x9D0026B8
9D0024B4  AE000008   SW ZERO, 8(S0)
2812:                			bcs = (DWORD) fp->fs->csize * SS(fp->fs); /* Cluster size (byte) */
9D0024B8  8E040000   LW A0, 0(S0)
9D0024BC  90930002   LBU S3, 2(A0)
2813:                			if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
9D0024C0  10400012   BEQ V0, ZERO, 0x9D00250C
9D0024C4  00139A40   SLL S3, S3, 9
9D0024C8  2442FFFF   ADDIU V0, V0, -1
9D0024CC  2643FFFF   ADDIU V1, S2, -1
9D0024D0  0073001B   DIVU V1, S3
9D0024D4  026001F4   TEQ S3, ZERO
9D0024D8  00001812   MFLO V1, 0
9D0024DC  0053001B   DIVU V0, S3
9D0024E0  026001F4   TEQ S3, ZERO
9D0024E4  00002812   MFLO A1, 0
9D0024E8  0065182B   SLTU V1, V1, A1
9D0024EC  54600008   BNEL V1, ZERO, 0x9D002510
9D0024F0  8E020010   LW V0, 16(S0)
2814:                				fp->fptr = (ifptr - 1) & ~(bcs - 1); /* start from the current cluster */
9D0024F4  00131823   SUBU V1, ZERO, S3
9D0024F8  00621024   AND V0, V1, V0
9D0024FC  AE020008   SW V0, 8(S0)
2815:                				ofs -= fp->fptr;
9D002500  02429023   SUBU S2, S2, V0
2816:                				clst = fp->clust;
9D002504  0B40095A   J 0x9D002568
9D002508  8E020014   LW V0, 20(S0)
2817:                			} else { /* When seek to back cluster, */
2818:                				clst = fp->sclust; /* start from the first cluster */
9D00250C  8E020010   LW V0, 16(S0)
2819:                #if !_FS_READONLY
2820:                				if (clst == 0) { /* If no cluster chain, create a new chain */
9D002510  54400015   BNEL V0, ZERO, 0x9D002568
9D002514  AE020014   SW V0, 20(S0)
2821:                					clst = create_chain(fp->fs, 0);
9D002518  0F4002A1   JAL 0x9D000A84
9D00251C  00002821   ADDU A1, ZERO, ZERO
2822:                					if (clst == 1)
9D002520  24030001   ADDIU V1, ZERO, 1
9D002524  14430007   BNE V0, V1, 0x9D002544
9D002528  2403FFFF   ADDIU V1, ZERO, -1
2823:                						ABORT(fp->fs, FR_INT_ERR);
9D00252C  92030006   LBU V1, 6(S0)
9D002530  2402FF80   ADDIU V0, ZERO, -128
9D002534  00621025   OR V0, V1, V0
9D002538  A2020006   SB V0, 6(S0)
9D00253C  0B4009AE   J 0x9D0026B8
9D002540  24110002   ADDIU S1, ZERO, 2
2824:                					if (clst == 0xFFFFFFFF)
9D002544  54430007   BNEL V0, V1, 0x9D002564
9D002548  AE020010   SW V0, 16(S0)
2825:                						ABORT(fp->fs, FR_DISK_ERR);
9D00254C  92030006   LBU V1, 6(S0)
9D002550  2402FF80   ADDIU V0, ZERO, -128
9D002554  00621025   OR V0, V1, V0
9D002558  A2020006   SB V0, 6(S0)
9D00255C  0B4009AE   J 0x9D0026B8
9D002560  24110001   ADDIU S1, ZERO, 1
2826:                					fp->sclust = clst;
2827:                				}
2828:                #endif
2829:                				fp->clust = clst;
9D002564  AE020014   SW V0, 20(S0)
2830:                			}
2831:                			if (clst != 0) {
9D002568  10400043   BEQ V0, ZERO, 0x9D002678
9D00256C  00001821   ADDU V1, ZERO, ZERO
2832:                				while (ofs > bcs) { /* Cluster following loop */
9D002570  0272182B   SLTU V1, S3, S2
9D002574  1060002E   BEQ V1, ZERO, 0x9D002630
9D002578  0013A823   SUBU S5, ZERO, S3
9D002618  00732021   ADDU A0, V1, S3
9D00261C  0264202B   SLTU A0, S3, A0
9D002620  5480FFD8   BNEL A0, ZERO, 0x9D002584
9D002624  00609021   ADDU S2, V1, ZERO
2833:                #if !_FS_READONLY
2834:                					if (fp->flag & FA_WRITE) { /* Check if in write mode or not */
9D002584  92030006   LBU V1, 6(S0)
9D002588  30630002   ANDI V1, V1, 2
9D00258C  10600007   BEQ V1, ZERO, 0x9D0025AC
9D002590  8E040000   LW A0, 0(S0)
2835:                						clst = create_chain(fp->fs, clst); /* Force stretch if in write mode */
9D002594  0F4002A1   JAL 0x9D000A84
9D002598  00402821   ADDU A1, V0, ZERO
2836:                						if (clst == 0) { /* When disk gets full, clip file size */
9D00259C  14400005   BNE V0, ZERO, 0x9D0025B4
9D0025A0  00000000   NOP
2837:                							ofs = bcs;
9D0025A4  0B40098C   J 0x9D002630
9D0025A8  02609021   ADDU S2, S3, ZERO
2838:                							break;
2839:                						}
2840:                					} else
2841:                #endif
2842:                						clst = get_fat(fp->fs, clst); /* Follow cluster chain if not in write mode */
9D0025AC  0F400162   JAL get_fat
9D0025B0  00402821   ADDU A1, V0, ZERO
2843:                					if (clst == 0xFFFFFFFF)
9D0025B4  14540007   BNE V0, S4, 0x9D0025D4
9D0025B8  2C430002   SLTIU V1, V0, 2
2844:                						ABORT(fp->fs, FR_DISK_ERR);
9D0025BC  92030006   LBU V1, 6(S0)
9D0025C0  2402FF80   ADDIU V0, ZERO, -128
9D0025C4  00621025   OR V0, V1, V0
9D0025C8  A2020006   SB V0, 6(S0)
9D0025CC  0B4009AE   J 0x9D0026B8
9D0025D0  24110001   ADDIU S1, ZERO, 1
2845:                					if (clst <= 1 || clst >= fp->fs->n_fatent)
9D0025D4  54600007   BNEL V1, ZERO, 0x9D0025F4
9D0025D8  92030006   LBU V1, 6(S0)
9D0025DC  8E030000   LW V1, 0(S0)
9D0025E0  8C630018   LW V1, 24(V1)
9D0025E4  0043182B   SLTU V1, V0, V1
9D0025E8  54600007   BNEL V1, ZERO, 0x9D002608
9D0025EC  AE020014   SW V0, 20(S0)
2846:                						ABORT(fp->fs, FR_INT_ERR);
9D0025F0  92030006   LBU V1, 6(S0)
9D0025F4  2402FF80   ADDIU V0, ZERO, -128
9D0025F8  00621025   OR V0, V1, V0
9D0025FC  A2020006   SB V0, 6(S0)
9D002600  0B4009AE   J 0x9D0026B8
9D002604  24110002   ADDIU S1, ZERO, 2
2847:                					fp->clust = clst;
2848:                					fp->fptr += bcs;
9D002608  8E030008   LW V1, 8(S0)
9D00260C  00731821   ADDU V1, V1, S3
9D002610  AE030008   SW V1, 8(S0)
9D002614  02551821   ADDU V1, S2, S5
2849:                					ofs -= bcs;
2850:                				}
2851:                				fp->fptr += ofs;
9D002628  0B40098D   J 0x9D002634
9D00262C  8E030008   LW V1, 8(S0)
9D002630  8E030008   LW V1, 8(S0)
9D002634  00721821   ADDU V1, V1, S2
9D002638  AE030008   SW V1, 8(S0)
2852:                				if (ofs % SS(fp->fs)) {
9D00263C  324401FF   ANDI A0, S2, 511
9D002640  1080000D   BEQ A0, ZERO, 0x9D002678
9D002644  00001821   ADDU V1, ZERO, ZERO
2853:                					nsect = clust2sect(fp->fs, clst); /* Current sector */
9D002648  8E040000   LW A0, 0(S0)
9D00264C  0F400156   JAL clust2sect
9D002650  00402821   ADDU A1, V0, ZERO
2854:                					if (!nsect)
9D002654  14400007   BNE V0, ZERO, 0x9D002674
9D002658  00121A42   SRL V1, S2, 9
2855:                						ABORT(fp->fs, FR_INT_ERR);
9D00265C  92030006   LBU V1, 6(S0)
9D002660  2402FF80   ADDIU V0, ZERO, -128
9D002664  00621025   OR V0, V1, V0
9D002668  A2020006   SB V0, 6(S0)
9D00266C  0B4009AE   J 0x9D0026B8
9D002670  24110002   ADDIU S1, ZERO, 2
2856:                					nsect += ofs / SS(fp->fs);
9D002674  00431821   ADDU V1, V0, V1
2857:                				}
2858:                			}
2859:                		}
2860:                		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) { /* Fill sector cache if needed */
9D002678  8E020008   LW V0, 8(S0)
9D00267C  304201FF   ANDI V0, V0, 511
9D002680  50400005   BEQL V0, ZERO, 0x9D002698
9D002684  8E020008   LW V0, 8(S0)
9D002688  8E020018   LW V0, 24(S0)
9D00268C  54430001   BNEL V0, V1, 0x9D002694
9D002690  AE030018   SW V1, 24(S0)
2861:                #if !_FS_TINY
2862:                #if !_FS_READONLY
2863:                			if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2864:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2865:                					ABORT(fp->fs, FR_DISK_ERR);
2866:                				fp->flag &= ~FA__DIRTY;
2867:                			}
2868:                #endif
2869:                			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK) /* Fill sector cache */
2870:                				ABORT(fp->fs, FR_DISK_ERR);
2871:                #endif
2872:                			fp->dsect = nsect;
2873:                		}
2874:                #if !_FS_READONLY
2875:                		if (fp->fptr > fp->fsize) { /* Set file change flag if the file size is extended */
9D002694  8E020008   LW V0, 8(S0)
9D002698  8E03000C   LW V1, 12(S0)
9D00269C  0062182B   SLTU V1, V1, V0
9D0026A0  50600006   BEQL V1, ZERO, 0x9D0026BC
9D0026A4  02201021   ADDU V0, S1, ZERO
2876:                			fp->fsize = fp->fptr;
9D0026A8  AE02000C   SW V0, 12(S0)
2877:                			fp->flag |= FA__WRITTEN;
9D0026AC  92020006   LBU V0, 6(S0)
9D0026B0  34420020   ORI V0, V0, 32
9D0026B4  A2020006   SB V0, 6(S0)
2878:                		}
2879:                #endif
2880:                	}
2881:                
2882:                	LEAVE_FF(fp->fs, res);
2883:                }
9D00248C  0B4009AF   J 0x9D0026BC
9D002490  02201021   ADDU V0, S1, ZERO
9D0026B8  02201021   ADDU V0, S1, ZERO
9D0026BC  8FBF0034   LW RA, 52(SP)
9D0026C0  8FBE0030   LW S8, 48(SP)
9D0026C4  8FB7002C   LW S7, 44(SP)
9D0026C8  8FB60028   LW S6, 40(SP)
9D0026CC  8FB50024   LW S5, 36(SP)
9D0026D0  8FB40020   LW S4, 32(SP)
9D0026D4  8FB3001C   LW S3, 28(SP)
9D0026D8  8FB20018   LW S2, 24(SP)
9D0026DC  8FB10014   LW S1, 20(SP)
9D0026E0  8FB00010   LW S0, 16(SP)
9D0026E4  03E00008   JR RA
9D0026E8  27BD0038   ADDIU SP, SP, 56
2884:                
2885:                #if _FS_MINIMIZE <= 1
2886:                /*-----------------------------------------------------------------------*/
2887:                /* Create a Directroy Object                                             */
2888:                /*-----------------------------------------------------------------------*/
2889:                
2890:                FRESULT f_opendir(DIR *dj, /* Pointer to directory object to create */
2891:                const TCHAR *path /* Pointer to the directory path */
2892:                ) {
9D0026EC  27BDFFD8   ADDIU SP, SP, -40
9D0026F0  AFBF0024   SW RA, 36(SP)
9D0026F4  AFB00020   SW S0, 32(SP)
9D0026F8  00808021   ADDU S0, A0, ZERO
9D0026FC  AFA5002C   SW A1, 44(SP)
2893:                	FRESULT res;
2894:                	DEF_NAMEBUF;
2895:                
2896:                	res = chk_mounted(&path, &dj->fs, 0);
9D002700  27A4002C   ADDIU A0, SP, 44
9D002704  02002821   ADDU A1, S0, ZERO
9D002708  0F40050B   JAL chk_mounted
9D00270C  00003021   ADDU A2, ZERO, ZERO
2897:                	if (res == FR_OK) {
9D002710  14400024   BNE V0, ZERO, 0x9D0027A4
9D002714  8FBF0024   LW RA, 36(SP)
2898:                		INIT_BUF(*dj);
9D002718  27A20010   ADDIU V0, SP, 16
9D00271C  AE020018   SW V0, 24(S0)
2899:                		res = follow_path(dj, path); /* Follow the path to the directory */
9D002720  02002021   ADDU A0, S0, ZERO
9D002724  0F400384   JAL 0x9D000E10
9D002728  8FA5002C   LW A1, 44(SP)
2900:                		FREE_BUF();
2901:                		if (res == FR_OK) { /* Follow completed */
9D00272C  1440001A   BNE V0, ZERO, 0x9D002798
9D002730  38440004   XORI A0, V0, 4
2902:                			if (dj->dir) { /* It is not the root dir */
9D002734  8E030014   LW V1, 20(S0)
9D002738  50600011   BEQL V1, ZERO, 0x9D002780
9D00273C  8E020000   LW V0, 0(S0)
2903:                				if (dj->dir[DIR_Attr] & AM_DIR) { /* The object is a directory */
9D002740  9064000B   LBU A0, 11(V1)
9D002744  30840010   ANDI A0, A0, 16
9D002748  10800015   BEQ A0, ZERO, 0x9D0027A0
9D00274C  24020005   ADDIU V0, ZERO, 5
2904:                					dj->sclust = LD_CLUST(dj->dir);
9D002750  90640015   LBU A0, 21(V1)
9D002754  00042200   SLL A0, A0, 8
9D002758  90620014   LBU V0, 20(V1)
9D00275C  00822025   OR A0, A0, V0
9D002760  00042400   SLL A0, A0, 16
9D002764  9062001B   LBU V0, 27(V1)
9D002768  00021200   SLL V0, V0, 8
9D00276C  9063001A   LBU V1, 26(V1)
9D002770  00431025   OR V0, V0, V1
9D002774  00821025   OR V0, A0, V0
9D002778  AE020008   SW V0, 8(S0)
2905:                				} else { /* The object is not a directory */
2906:                					res = FR_NO_PATH;
2907:                				}
2908:                			}
2909:                			if (res == FR_OK) {
2910:                				dj->id = dj->fs->id;
9D00277C  8E020000   LW V0, 0(S0)
9D002780  94420006   LHU V0, 6(V0)
9D002784  A6020004   SH V0, 4(S0)
2911:                				res = dir_sdi(dj, 0); /* Rewind dir */
9D002788  02002021   ADDU A0, S0, ZERO
9D00278C  0F4001C3   JAL 0x9D00070C
9D002790  00002821   ADDU A1, ZERO, ZERO
2912:                			}
2913:                		}
2914:                		if (res == FR_NO_FILE)
2915:                			res = FR_NO_PATH;
9D002794  38440004   XORI A0, V0, 4
9D002798  24030005   ADDIU V1, ZERO, 5
9D00279C  0064100A   MOVZ V0, V1, A0
2916:                	}
2917:                
2918:                	LEAVE_FF(dj->fs, res);
2919:                }
9D0027A0  8FBF0024   LW RA, 36(SP)
9D0027A4  8FB00020   LW S0, 32(SP)
9D0027A8  03E00008   JR RA
9D0027AC  27BD0028   ADDIU SP, SP, 40
2920:                
2921:                /*-----------------------------------------------------------------------*/
2922:                /* Read Directory Entry in Sequense                                      */
2923:                /*-----------------------------------------------------------------------*/
2924:                
2925:                FRESULT f_readdir(DIR *dj, /* Pointer to the open directory object */
2926:                FILINFO *fno /* Pointer to file information to return */
2927:                ) {
9D0027B0  27BDFFD0   ADDIU SP, SP, -48
9D0027B4  AFBF002C   SW RA, 44(SP)
9D0027B8  AFB20028   SW S2, 40(SP)
9D0027BC  AFB10024   SW S1, 36(SP)
9D0027C0  AFB00020   SW S0, 32(SP)
9D0027C4  00808821   ADDU S1, A0, ZERO
9D0027C8  00A09021   ADDU S2, A1, ZERO
2928:                	FRESULT res;
2929:                	DEF_NAMEBUF;
2930:                
2931:                	res = validate(dj->fs, dj->id); /* Check validity of the object */
9D0027CC  8C840000   LW A0, 0(A0)
9D0027D0  0F400143   JAL 0x9D00050C
9D0027D4  96250004   LHU A1, 4(S1)
2932:                	if (res == FR_OK) {
9D0027D8  1440001C   BNE V0, ZERO, 0x9D00284C
9D0027DC  00408021   ADDU S0, V0, ZERO
2933:                		if (!fno) {
9D0027E0  16400006   BNE S2, ZERO, 0x9D0027FC
9D0027E4  27A20010   ADDIU V0, SP, 16
2934:                			res = dir_sdi(dj, 0); /* Rewind the directory object */
9D0027E8  02202021   ADDU A0, S1, ZERO
9D0027EC  0F4001C3   JAL 0x9D00070C
9D0027F0  00002821   ADDU A1, ZERO, ZERO
9D0027F4  0B400A13   J 0x9D00284C
9D0027F8  00408021   ADDU S0, V0, ZERO
2935:                		} else {
2936:                			INIT_BUF(*dj);
9D0027FC  AE220018   SW V0, 24(S1)
2937:                			res = dir_read(dj); /* Read an directory item */
9D002800  0F4004A7   JAL 0x9D00129C
9D002804  02202021   ADDU A0, S1, ZERO
2938:                			if (res == FR_NO_FILE) { /* Reached end of dir */
9D002808  24030004   ADDIU V1, ZERO, 4
9D00280C  14430003   BNE V0, V1, 0x9D00281C
9D002810  00000000   NOP
2939:                				dj->sect = 0;
9D002814  0B400A09   J 0x9D002824
9D002818  AE200010   SW ZERO, 16(S1)
2940:                				res = FR_OK;
2941:                			}
2942:                			if (res == FR_OK) { /* A valid entry is found */
9D00281C  5440000B   BNEL V0, ZERO, 0x9D00284C
9D002820  00408021   ADDU S0, V0, ZERO
2943:                				get_fileinfo(dj, fno); /* Get the object information */
9D002824  02202021   ADDU A0, S1, ZERO
9D002828  0F40003A   JAL 0x9D0000E8
9D00282C  02402821   ADDU A1, S2, ZERO
2944:                				res = dir_next(dj, 0); /* Increment index for next */
9D002830  02202021   ADDU A0, S1, ZERO
9D002834  0F400302   JAL 0x9D000C08
9D002838  00002821   ADDU A1, ZERO, ZERO
2945:                				if (res == FR_NO_FILE) {
9D00283C  24030004   ADDIU V1, ZERO, 4
9D002840  54430002   BNEL V0, V1, 0x9D00284C
9D002844  00408021   ADDU S0, V0, ZERO
9D002848  AE200010   SW ZERO, 16(S1)
2946:                					dj->sect = 0;
2947:                					res = FR_OK;
2948:                				}
2949:                			} FREE_BUF();
2950:                		}
2951:                	}
2952:                
2953:                	LEAVE_FF(dj->fs, res);
2954:                }
9D00284C  02001021   ADDU V0, S0, ZERO
9D002850  8FBF002C   LW RA, 44(SP)
9D002854  8FB20028   LW S2, 40(SP)
9D002858  8FB10024   LW S1, 36(SP)
9D00285C  8FB00020   LW S0, 32(SP)
9D002860  03E00008   JR RA
9D002864  27BD0030   ADDIU SP, SP, 48
2955:                
2956:                #if _FS_MINIMIZE == 0
2957:                /*-----------------------------------------------------------------------*/
2958:                /* Get File Status                                                       */
2959:                /*-----------------------------------------------------------------------*/
2960:                
2961:                FRESULT f_stat(const TCHAR *path, /* Pointer to the file path */
2962:                                FILINFO *fno /* Pointer to file information to return */
2963:                                ) {
9D002868  27BDFFB8   ADDIU SP, SP, -72
9D00286C  AFBF0044   SW RA, 68(SP)
9D002870  AFB10040   SW S1, 64(SP)
9D002874  AFB0003C   SW S0, 60(SP)
9D002878  AFA40048   SW A0, 72(SP)
9D00287C  00A08821   ADDU S1, A1, ZERO
2964:                	FRESULT res;
2965:                	DIR dj;
2966:                	DEF_NAMEBUF;
2967:                
2968:                	res = chk_mounted(&path, &dj.fs, 0);
9D002880  27A40048   ADDIU A0, SP, 72
9D002884  27A50010   ADDIU A1, SP, 16
9D002888  0F40050B   JAL chk_mounted
9D00288C  00003021   ADDU A2, ZERO, ZERO
2969:                	if (res == FR_OK) {
9D002890  14400010   BNE V0, ZERO, 0x9D0028D4
9D002894  00408021   ADDU S0, V0, ZERO
2970:                		INIT_BUF(dj);
9D002898  27A2002C   ADDIU V0, SP, 44
9D00289C  AFA20028   SW V0, 40(SP)
2971:                		res = follow_path(&dj, path); /* Follow the file path */
9D0028A0  27A40010   ADDIU A0, SP, 16
9D0028A4  0F400384   JAL 0x9D000E10
9D0028A8  8FA50048   LW A1, 72(SP)
2972:                		if (res == FR_OK) { /* Follow completed */
9D0028AC  14400009   BNE V0, ZERO, 0x9D0028D4
9D0028B0  00408021   ADDU S0, V0, ZERO
2973:                			if (dj.dir) /* Found an object */
9D0028B4  8FA20024   LW V0, 36(SP)
9D0028B8  10400005   BEQ V0, ZERO, 0x9D0028D0
9D0028BC  27A40010   ADDIU A0, SP, 16
2974:                				get_fileinfo(&dj, fno);
9D0028C0  0F40003A   JAL 0x9D0000E8
9D0028C4  02202821   ADDU A1, S1, ZERO
2975:                			else
2976:                				/* It is root dir */
2977:                				res = FR_INVALID_NAME;
9D0028D0  24100006   ADDIU S0, ZERO, 6
2978:                		}FREE_BUF();
2979:                	}
2980:                
2981:                	LEAVE_FF(dj.fs, res);
2982:                }
9D0028C8  0B400A36   J 0x9D0028D8
9D0028CC  02001021   ADDU V0, S0, ZERO
9D0028D4  02001021   ADDU V0, S0, ZERO
9D0028D8  8FBF0044   LW RA, 68(SP)
9D0028DC  8FB10040   LW S1, 64(SP)
9D0028E0  8FB0003C   LW S0, 60(SP)
9D0028E4  03E00008   JR RA
9D0028E8  27BD0048   ADDIU SP, SP, 72
2983:                
2984:                #if !_FS_READONLY
2985:                /*-----------------------------------------------------------------------*/
2986:                /* Get Number of Free Clusters                                           */
2987:                /*-----------------------------------------------------------------------*/
2988:                
2989:                FRESULT f_getfree(const TCHAR *path, /* Pointer to the logical drive number (root dir) */
2990:                DWORD *nclst, /* Pointer to the variable to return number of free clusters */
2991:                FATFS **fatfs /* Pointer to pointer to corresponding file system object to return */
2992:                ) {
9D0028EC  27BDFFC8   ADDIU SP, SP, -56
9D0028F0  AFBF0034   SW RA, 52(SP)
9D0028F4  AFB70030   SW S7, 48(SP)
9D0028F8  AFB6002C   SW S6, 44(SP)
9D0028FC  AFB50028   SW S5, 40(SP)
9D002900  AFB40024   SW S4, 36(SP)
9D002904  AFB30020   SW S3, 32(SP)
9D002908  AFB2001C   SW S2, 28(SP)
9D00290C  AFB10018   SW S1, 24(SP)
9D002910  AFB00014   SW S0, 20(SP)
9D002914  AFA40038   SW A0, 56(SP)
9D002918  00A0B821   ADDU S7, A1, ZERO
9D00291C  00C09021   ADDU S2, A2, ZERO
2993:                	FRESULT res;
2994:                	DWORD n, clst, sect, stat;
2995:                	UINT i;
2996:                	PF_BYTE fat, *p;
2997:                
2998:                	/* Get drive number */
2999:                	res = chk_mounted(&path, fatfs, 0);
9D002920  27A40038   ADDIU A0, SP, 56
9D002924  00C02821   ADDU A1, A2, ZERO
9D002928  0F40050B   JAL chk_mounted
9D00292C  00003021   ADDU A2, ZERO, ZERO
3000:                	if (res == FR_OK) {
9D002930  1440005A   BNE V0, ZERO, 0x9D002A9C
9D002934  00408021   ADDU S0, V0, ZERO
3001:                		/* If free_clust is valid, return it without full cluster scan */
3002:                		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
9D002938  8E420000   LW V0, 0(S2)
9D00293C  8C430010   LW V1, 16(V0)
9D002940  8C510018   LW S1, 24(V0)
9D002944  2624FFFE   ADDIU A0, S1, -2
9D002948  0083202B   SLTU A0, A0, V1
9D00294C  54800003   BNEL A0, ZERO, 0x9D00295C
9D002950  90540000   LBU S4, 0(V0)
3003:                			*nclst = (*fatfs)->free_clust;
9D002954  0B400AA7   J 0x9D002A9C
9D002958  AEE30000   SW V1, 0(S7)
3004:                		} else {
3005:                			/* Get number of free clusters */
3006:                			fat = (*fatfs)->fs_type;
3007:                			n = 0;
9D0029C0  00009821   ADDU S3, ZERO, ZERO
3008:                			if (fat == FS_FAT12) {
9D00295C  24030001   ADDIU V1, ZERO, 1
9D002960  56830015   BNEL S4, V1, 0x9D0029B8
9D002964  8C560020   LW S6, 32(V0)
9D002968  24110002   ADDIU S1, ZERO, 2
9D00296C  00009821   ADDU S3, ZERO, ZERO
3009:                				clst = 2;
3010:                				do {
3011:                					stat = get_fat(*fatfs, clst);
9D002978  8E440000   LW A0, 0(S2)
9D00297C  0F400162   JAL get_fat
9D002980  02202821   ADDU A1, S1, ZERO
3012:                					if (stat == 0xFFFFFFFF) {
9D002970  2415FFFF   ADDIU S5, ZERO, -1
9D002984  5055003C   BEQL V0, S5, 0x9D002A78
9D002988  24100001   ADDIU S0, ZERO, 1
3013:                						res = FR_DISK_ERR;
3014:                						break;
3015:                					}
3016:                					if (stat == 1) {
9D002974  24160001   ADDIU S6, ZERO, 1
9D00298C  10560037   BEQ V0, S6, 0x9D002A6C
9D002990  2C420001   SLTIU V0, V0, 1
3017:                						res = FR_INT_ERR;
9D002A6C  0B400A9E   J 0x9D002A78
9D002A70  24100002   ADDIU S0, ZERO, 2
3018:                						break;
3019:                					}
3020:                					if (stat == 0)
3021:                						n++;
9D002994  02629821   ADDU S3, S3, V0
3022:                				} while (++clst < (*fatfs)->n_fatent);
9D002998  26310001   ADDIU S1, S1, 1
9D00299C  8E420000   LW V0, 0(S2)
9D0029A0  8C430018   LW V1, 24(V0)
9D0029A4  0223182B   SLTU V1, S1, V1
9D0029A8  5460FFF4   BNEL V1, ZERO, 0x9D00297C
9D0029AC  8E440000   LW A0, 0(S2)
3023:                			} else {
3024:                				clst = (*fatfs)->n_fatent;
3025:                				sect = (*fatfs)->fatbase;
3026:                				i = 0;
9D0029BC  00001821   ADDU V1, ZERO, ZERO
3027:                				p = 0;
9D0029B8  00001021   ADDU V0, ZERO, ZERO
3028:                				do {
3029:                					if (!i) {
9D0029C8  14600009   BNE V1, ZERO, 0x9D0029F0
9D0029CC  00000000   NOP
3030:                						res = move_window(*fatfs, sect++);
9D0029D0  8E440000   LW A0, 0(S2)
9D0029D4  0F400082   JAL 0x9D000208
9D0029D8  02C02821   ADDU A1, S6, ZERO
9D002A74  00408021   ADDU S0, V0, ZERO
3031:                						if (res != FR_OK)
9D0029DC  14400025   BNE V0, ZERO, 0x9D002A74
9D0029E0  26D60001   ADDIU S6, S6, 1
3032:                							break;
3033:                						p = (*fatfs)->win;
9D0029E4  8E420000   LW V0, 0(S2)
9D0029E8  24420030   ADDIU V0, V0, 48
3034:                						i = SS(*fatfs);
9D0029EC  24030200   ADDIU V1, ZERO, 512
3035:                					}
3036:                					if (fat == FS_FAT16) {
9D0029C4  24150002   ADDIU S5, ZERO, 2
9D0029F0  5695000B   BNEL S4, S5, 0x9D002A20
9D0029F4  90450003   LBU A1, 3(V0)
3037:                						if (LD_WORD(p) == 0)
9D0029F8  90440001   LBU A0, 1(V0)
9D0029FC  00042200   SLL A0, A0, 8
9D002A00  90450000   LBU A1, 0(V0)
9D002A04  00852025   OR A0, A0, A1
9D002A08  7C042620   SEH A0, A0
3038:                							n++;
9D002A0C  2C840001   SLTIU A0, A0, 1
9D002A10  02649821   ADDU S3, S3, A0
3039:                						p += 2;
9D002A14  24420002   ADDIU V0, V0, 2
3040:                						i -= 2;
9D002A18  0B400A96   J 0x9D002A58
9D002A1C  2463FFFE   ADDIU V1, V1, -2
3041:                					} else {
3042:                						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0)
9D002A20  00052E00   SLL A1, A1, 24
9D002A24  90440002   LBU A0, 2(V0)
9D002A28  00042400   SLL A0, A0, 16
9D002A2C  00A42025   OR A0, A1, A0
9D002A30  90450000   LBU A1, 0(V0)
9D002A34  00852025   OR A0, A0, A1
9D002A38  90450001   LBU A1, 1(V0)
9D002A3C  00052A00   SLL A1, A1, 8
9D002A40  00852025   OR A0, A0, A1
9D002A44  7C84D800   EXT A0, A0, 0, 28
3043:                							n++;
9D002A48  2C840001   SLTIU A0, A0, 1
9D002A4C  02649821   ADDU S3, S3, A0
3044:                						p += 4;
9D002A50  24420004   ADDIU V0, V0, 4
3045:                						i -= 4;
9D002A54  2463FFFC   ADDIU V1, V1, -4
3046:                					}
3047:                				} while (--clst);
9D002A58  2631FFFF   ADDIU S1, S1, -1
9D002A5C  1620FFDA   BNE S1, ZERO, 0x9D0029C8
9D002A60  00000000   NOP
3048:                			}
3049:                			(*fatfs)->free_clust = n;
9D0029B0  0B400AA6   J 0x9D002A98
9D0029B4  AC530010   SW S3, 16(V0)
9D002A64  0B400A9F   J 0x9D002A7C
9D002A68  8E420000   LW V0, 0(S2)
9D002A78  8E420000   LW V0, 0(S2)
9D002A7C  AC530010   SW S3, 16(V0)
3050:                			if (fat == FS_FAT32)
9D002A80  24020003   ADDIU V0, ZERO, 3
9D002A84  56820005   BNEL S4, V0, 0x9D002A9C
9D002A88  AEF30000   SW S3, 0(S7)
3051:                				(*fatfs)->fsi_flag = 1;
9D002A8C  8E420000   LW V0, 0(S2)
9D002A90  24030001   ADDIU V1, ZERO, 1
9D002A94  A0430005   SB V1, 5(V0)
3052:                			*nclst = n;
9D002A98  AEF30000   SW S3, 0(S7)
3053:                		}
3054:                	}
3055:                	LEAVE_FF(*fatfs, res);
3056:                }
9D002A9C  02001021   ADDU V0, S0, ZERO
9D002AA0  8FBF0034   LW RA, 52(SP)
9D002AA4  8FB70030   LW S7, 48(SP)
9D002AA8  8FB6002C   LW S6, 44(SP)
9D002AAC  8FB50028   LW S5, 40(SP)
9D002AB0  8FB40024   LW S4, 36(SP)
9D002AB4  8FB30020   LW S3, 32(SP)
9D002AB8  8FB2001C   LW S2, 28(SP)
9D002ABC  8FB10018   LW S1, 24(SP)
9D002AC0  8FB00014   LW S0, 20(SP)
9D002AC4  03E00008   JR RA
9D002AC8  27BD0038   ADDIU SP, SP, 56
3057:                
3058:                /*-----------------------------------------------------------------------*/
3059:                /* Truncate File                                                         */
3060:                /*-----------------------------------------------------------------------*/
3061:                
3062:                FRESULT f_truncate(FIL *fp /* Pointer to the file object */
3063:                ) {
9D002ACC  27BDFFE0   ADDIU SP, SP, -32
9D002AD0  AFBF001C   SW RA, 28(SP)
9D002AD4  AFB10018   SW S1, 24(SP)
9D002AD8  AFB00014   SW S0, 20(SP)
9D002ADC  00808021   ADDU S0, A0, ZERO
3064:                	FRESULT res;
3065:                	DWORD ncl;
3066:                
3067:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D002AE0  8C840000   LW A0, 0(A0)
9D002AE4  0F400143   JAL 0x9D00050C
9D002AE8  96050004   LHU A1, 4(S0)
3068:                	if (res == FR_OK) {
9D002AEC  14400033   BNE V0, ZERO, 0x9D002BBC
9D002AF0  8FBF001C   LW RA, 28(SP)
3069:                		if (fp->flag & FA__ERROR) { /* Check abort flag */
9D002AF4  92030006   LBU V1, 6(S0)
9D002AF8  7C032420   SEB A0, V1
9D002AFC  04800005   BLTZ A0, 0x9D002B14
9D002B00  30640002   ANDI A0, V1, 2
3070:                			res = FR_INT_ERR;
9D002B14  0B400AEE   J 0x9D002BB8
9D002B18  24020002   ADDIU V0, ZERO, 2
3071:                		} else {
3072:                			if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D002B04  54800031   BNEL A0, ZERO, 0x9D002BCC
9D002B08  8E040008   LW A0, 8(S0)
3073:                				res = FR_DENIED;
9D002B0C  0B400AEE   J 0x9D002BB8
9D002B10  24020007   ADDIU V0, ZERO, 7
3074:                		}
3075:                	}
3076:                	if (res == FR_OK) {
3077:                		if (fp->fsize > fp->fptr) {
9D002BCC  8E05000C   LW A1, 12(S0)
9D002BD0  0085282B   SLTU A1, A0, A1
9D002BD4  54A0FFD1   BNEL A1, ZERO, 0x9D002B1C
9D002BD8  AE04000C   SW A0, 12(S0)
3078:                			fp->fsize = fp->fptr; /* Set file size to current R/W point */
3079:                			fp->flag |= FA__WRITTEN;
9D002B1C  34630020   ORI V1, V1, 32
3080:                			if (fp->fptr == 0) { /* When set file size to zero, remove entire cluster chain */
9D002B20  14800006   BNE A0, ZERO, 0x9D002B3C
9D002B24  A2030006   SB V1, 6(S0)
3081:                				res = remove_chain(fp->fs, fp->sclust);
9D002B28  8E040000   LW A0, 0(S0)
9D002B2C  0F4004D1   JAL 0x9D001344
9D002B30  8E050010   LW A1, 16(S0)
3082:                				fp->sclust = 0;
9D002B34  0B400AE8   J 0x9D002BA0
9D002B38  AE000010   SW ZERO, 16(S0)
3083:                			} else { /* When truncate a part of the file, remove remaining clusters */
3084:                				ncl = get_fat(fp->fs, fp->clust);
9D002B3C  8E040000   LW A0, 0(S0)
9D002B40  0F400162   JAL get_fat
9D002B44  8E050014   LW A1, 20(S0)
9D002B48  00408821   ADDU S1, V0, ZERO
3085:                				res = FR_OK;
9D002B58  26220001   ADDIU V0, S1, 1
9D002B5C  2C420001   SLTIU V0, V0, 1
3086:                				if (ncl == 0xFFFFFFFF)
3087:                					res = FR_DISK_ERR;
3088:                				if (ncl == 1)
9D002B4C  24020001   ADDIU V0, ZERO, 1
9D002B50  12220015   BEQ S1, V0, 0x9D002BA8
9D002B54  24020002   ADDIU V0, ZERO, 2
3089:                					res = FR_INT_ERR;
3090:                				if (res == FR_OK && ncl < fp->fs->n_fatent) {
9D002B60  54400012   BNEL V0, ZERO, 0x9D002BAC
9D002B64  92040006   LBU A0, 6(S0)
9D002B68  8E040000   LW A0, 0(S0)
9D002B6C  8C830018   LW V1, 24(A0)
9D002B70  0223182B   SLTU V1, S1, V1
9D002B74  10600011   BEQ V1, ZERO, 0x9D002BBC
9D002B78  8FBF001C   LW RA, 28(SP)
3091:                					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
9D002B7C  8E050014   LW A1, 20(S0)
9D002B80  3C060FFF   LUI A2, 4095
9D002B84  0F400232   JAL put_fat
9D002B88  34C6FFFF   ORI A2, A2, -1
3092:                					if (res == FR_OK)
9D002B8C  54400007   BNEL V0, ZERO, 0x9D002BAC
9D002B90  92040006   LBU A0, 6(S0)
3093:                						res = remove_chain(fp->fs, ncl);
9D002B94  8E040000   LW A0, 0(S0)
9D002B98  0F4004D1   JAL 0x9D001344
9D002B9C  02202821   ADDU A1, S1, ZERO
3094:                				}
3095:                			}
3096:                		}
3097:                		if (res != FR_OK)
9D002BA0  10400006   BEQ V0, ZERO, 0x9D002BBC
9D002BA4  8FBF001C   LW RA, 28(SP)
3098:                			fp->flag |= FA__ERROR;
9D002BA8  92040006   LBU A0, 6(S0)
9D002BAC  2403FF80   ADDIU V1, ZERO, -128
9D002BB0  00831825   OR V1, A0, V1
9D002BB4  A2030006   SB V1, 6(S0)
3099:                	}
3100:                
3101:                	LEAVE_FF(fp->fs, res);
3102:                }
9D002BB8  8FBF001C   LW RA, 28(SP)
9D002BBC  8FB10018   LW S1, 24(SP)
9D002BC0  8FB00014   LW S0, 20(SP)
9D002BC4  03E00008   JR RA
9D002BC8  27BD0020   ADDIU SP, SP, 32
9D002BDC  0B400AEF   J 0x9D002BBC
9D002BE0  8FBF001C   LW RA, 28(SP)
3103:                
3104:                /*-----------------------------------------------------------------------*/
3105:                /* Delete a File or Directory                                            */
3106:                /*-----------------------------------------------------------------------*/
3107:                
3108:                FRESULT f_unlink(const TCHAR *path /* Pointer to the file or directory path */
3109:                ) {
9D002BE4  27BDFFA0   ADDIU SP, SP, -96
9D002BE8  AFBF005C   SW RA, 92(SP)
9D002BEC  AFB00058   SW S0, 88(SP)
9D002BF0  AFA40060   SW A0, 96(SP)
3110:                	FRESULT res;
3111:                	DIR dj, sdj;
3112:                	PF_BYTE *dir;
3113:                	DWORD dclst;
3114:                	DEF_NAMEBUF;
3115:                
3116:                	res = chk_mounted(&path, &dj.fs, 1);
9D002BF4  27A40060   ADDIU A0, SP, 96
9D002BF8  27A50010   ADDIU A1, SP, 16
9D002BFC  0F40050B   JAL chk_mounted
9D002C00  24060001   ADDIU A2, ZERO, 1
3117:                	if (res == FR_OK) {
9D002C04  1440002E   BNE V0, ZERO, 0x9D002CC0
9D002C08  8FBF005C   LW RA, 92(SP)
3118:                		INIT_BUF(dj);
9D002C0C  27A20048   ADDIU V0, SP, 72
9D002C10  AFA20028   SW V0, 40(SP)
3119:                		res = follow_path(&dj, path); /* Follow the file path */
9D002C14  27A40010   ADDIU A0, SP, 16
9D002C18  0F400384   JAL 0x9D000E10
9D002C1C  8FA50060   LW A1, 96(SP)
3120:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3121:                			res = FR_INVALID_NAME; /* Cannot remove dot entry */
3122:                #if _FS_SHARE
3123:                		if (res == FR_OK) res = chk_lock(&dj, 2); /* Cannot remove open file */
3124:                #endif
3125:                		if (res == FR_OK) { /* The object is accessible */
9D002C20  14400026   BNE V0, ZERO, 0x9D002CBC
9D002C24  8FA30024   LW V1, 36(SP)
3126:                			dir = dj.dir;
3127:                			if (!dir) {
9D002C28  10600024   BEQ V1, ZERO, 0x9D002CBC
9D002C2C  24020006   ADDIU V0, ZERO, 6
3128:                				res = FR_INVALID_NAME; /* Cannot remove the start directory */
3129:                			} else {
3130:                				if (dir[DIR_Attr] & AM_RDO)
9D002C30  9062000B   LBU V0, 11(V1)
9D002C34  30420001   ANDI V0, V0, 1
9D002C38  5040002A   BEQL V0, ZERO, 0x9D002CE4
9D002C3C  90620015   LBU V0, 21(V1)
3131:                					res = FR_DENIED; /* Cannot remove R/O object */
9D002C40  0B400B2F   J 0x9D002CBC
9D002C44  24020007   ADDIU V0, ZERO, 7
3132:                			}
3133:                			dclst = LD_CLUST(dir);
9D002CE4  00021200   SLL V0, V0, 8
9D002CE8  90640014   LBU A0, 20(V1)
9D002CEC  00441025   OR V0, V0, A0
9D002CF0  00021400   SLL V0, V0, 16
9D002CF4  9070001B   LBU S0, 27(V1)
9D002CF8  00108200   SLL S0, S0, 8
9D002CFC  9064001A   LBU A0, 26(V1)
9D002D00  02048025   OR S0, S0, A0
9D002D04  00508025   OR S0, V0, S0
3134:                			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) { /* Is it a sub-dir? */
9D002D08  9062000B   LBU V0, 11(V1)
9D002D0C  30420010   ANDI V0, V0, 16
9D002D10  1440FFCD   BNE V0, ZERO, 0x9D002C48
9D002D14  2E030002   SLTIU V1, S0, 2
9D002D18  0B400B33   J 0x9D002CCC
9D002D1C  00000000   NOP
3135:                				if (dclst < 2) {
9D002C48  1460001C   BNE V1, ZERO, 0x9D002CBC
9D002C4C  24020002   ADDIU V0, ZERO, 2
3136:                					res = FR_INT_ERR;
3137:                				} else {
3138:                					mem_cpy(&sdj, &dj, sizeof(DIR)); /* Check if the sub-dir is empty or not */
9D002C50  27A4002C   ADDIU A0, SP, 44
9D002C54  27A50010   ADDIU A1, SP, 16
9D002C58  0F400008   JAL 0x9D000020
9D002C5C  2406001C   ADDIU A2, ZERO, 28
3139:                					sdj.sclust = dclst;
9D002C60  AFB00034   SW S0, 52(SP)
3140:                					res = dir_sdi(&sdj, 2); /* Exclude dot entries */
9D002C64  27A4002C   ADDIU A0, SP, 44
9D002C68  0F4001C3   JAL 0x9D00070C
9D002C6C  24050002   ADDIU A1, ZERO, 2
3141:                					if (res == FR_OK) {
9D002C70  14400013   BNE V0, ZERO, 0x9D002CC0
9D002C74  8FBF005C   LW RA, 92(SP)
3142:                						res = dir_read(&sdj);
9D002C78  0F4004A7   JAL 0x9D00129C
9D002C7C  27A4002C   ADDIU A0, SP, 44
3143:                						if (res == FR_OK /* Not empty dir */
9D002C80  5040000E   BEQL V0, ZERO, 0x9D002CBC
9D002C84  24020007   ADDIU V0, ZERO, 7
3144:                #if _FS_RPATH
3145:                							|| dclst == sdj.fs->cdir /* Current dir */
3146:                #endif
3147:                							) res = FR_DENIED;
3148:                						if (res == FR_NO_FILE)
9D002C88  24030004   ADDIU V1, ZERO, 4
9D002C8C  1043000F   BEQ V0, V1, 0x9D002CCC
9D002C90  8FBF005C   LW RA, 92(SP)
3149:                							res = FR_OK; /* Empty */
3150:                					}
3151:                				}
3152:                			}
3153:                			if (res == FR_OK) {
3154:                				res = dir_remove(&dj); /* Remove the directory entry */
9D002CCC  0F40021C   JAL 0x9D000870
9D002CD0  27A40010   ADDIU A0, SP, 16
3155:                				if (res == FR_OK) {
9D002CD4  1040FFF1   BEQ V0, ZERO, 0x9D002C9C
9D002CD8  8FBF005C   LW RA, 92(SP)
3156:                					if (dclst) /* Remove the cluster chain if exist */
9D002C9C  12000005   BEQ S0, ZERO, 0x9D002CB4
9D002CA0  8FA40010   LW A0, 16(SP)
3157:                						res = remove_chain(dj.fs, dclst);
9D002CA4  0F4004D1   JAL 0x9D001344
9D002CA8  02002821   ADDU A1, S0, ZERO
3158:                					if (res == FR_OK)
9D002CAC  14400004   BNE V0, ZERO, 0x9D002CC0
9D002CB0  8FBF005C   LW RA, 92(SP)
3159:                						res = sync(dj.fs);
9D002CB4  0F4000F9   JAL 0x9D0003E4
9D002CB8  8FA40010   LW A0, 16(SP)
3160:                				}
3161:                			}
3162:                		}FREE_BUF();
3163:                	}
3164:                	LEAVE_FF(dj.fs, res);
3165:                }
9D002C94  0B400B31   J 0x9D002CC4
9D002C98  8FB00058   LW S0, 88(SP)
9D002CBC  8FBF005C   LW RA, 92(SP)
9D002CC0  8FB00058   LW S0, 88(SP)
9D002CC4  03E00008   JR RA
9D002CC8  27BD0060   ADDIU SP, SP, 96
9D002CDC  0B400B31   J 0x9D002CC4
9D002CE0  8FB00058   LW S0, 88(SP)
3166:                
3167:                /*-----------------------------------------------------------------------*/
3168:                /* Create a Directory                                                    */
3169:                /*-----------------------------------------------------------------------*/
3170:                
3171:                FRESULT f_mkdir(const TCHAR *path /* Pointer to the directory path */
9D002EE4  32B500FF   ANDI S5, S5, 255
9D002EE8  26B50001   ADDIU S5, S5, 1
9D002EEC  02B2A821   ADDU S5, S5, S2
3172:                ) {
9D002D20  27BDFF88   ADDIU SP, SP, -120
9D002D24  AFBF0074   SW RA, 116(SP)
9D002D28  AFBE0070   SW S8, 112(SP)
9D002D2C  AFB7006C   SW S7, 108(SP)
9D002D30  AFB60068   SW S6, 104(SP)
9D002D34  AFB50064   SW S5, 100(SP)
9D002D38  AFB40060   SW S4, 96(SP)
9D002D3C  AFB3005C   SW S3, 92(SP)
9D002D40  AFB20058   SW S2, 88(SP)
9D002D44  AFB10054   SW S1, 84(SP)
9D002D48  AFB00050   SW S0, 80(SP)
3173:                	FRESULT res;
3174:                	DIR dj;
3175:                	PF_BYTE *dir, n;
3176:                	DWORD dsc, dcl, pcl, tim = get_fattime();
9D002D4C  0F401CB5   JAL get_fattime
9D002D50  AFA40078   SW A0, 120(SP)
9D002D54  00408821   ADDU S1, V0, ZERO
3177:                	DEF_NAMEBUF;
3178:                
3179:                	res = chk_mounted(&path, &dj.fs, 1);
9D002D58  27A40078   ADDIU A0, SP, 120
9D002D5C  27A50010   ADDIU A1, SP, 16
9D002D60  0F40050B   JAL chk_mounted
9D002D64  24060001   ADDIU A2, ZERO, 1
3180:                	if (res == FR_OK) {
9D002D68  1440008C   BNE V0, ZERO, 0x9D002F9C
9D002D6C  00408021   ADDU S0, V0, ZERO
3181:                		INIT_BUF(dj);
9D002D70  27A2002C   ADDIU V0, SP, 44
9D002D74  AFA20028   SW V0, 40(SP)
3182:                		res = follow_path(&dj, path); /* Follow the file path */
9D002D78  27A40010   ADDIU A0, SP, 16
9D002D7C  0F400384   JAL 0x9D000E10
9D002D80  8FA50078   LW A1, 120(SP)
3183:                		if (res == FR_OK)
9D002D84  50400085   BEQL V0, ZERO, 0x9D002F9C
9D002D88  24100008   ADDIU S0, ZERO, 8
3184:                			res = FR_EXIST; /* Any object with same name is already existing */
3185:                		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
3186:                			res = FR_INVALID_NAME;
3187:                		if (res == FR_NO_FILE) { /* Can create a new directory */
9D002D8C  24030004   ADDIU V1, ZERO, 4
9D002D90  54430082   BNEL V0, V1, 0x9D002F9C
9D002D94  00408021   ADDU S0, V0, ZERO
3188:                			dcl = create_chain(dj.fs, 0); /* Allocate a cluster for the new directory table */
9D002D98  8FA40010   LW A0, 16(SP)
9D002D9C  0F4002A1   JAL 0x9D000A84
9D002DA0  00002821   ADDU A1, ZERO, ZERO
3189:                			res = FR_OK;
3190:                			if (dcl == 0)
9D002DA4  10400009   BEQ V0, ZERO, 0x9D002DCC
9D002DA8  00409821   ADDU S3, V0, ZERO
3191:                				res = FR_DENIED; /* No space to allocate a new cluster */
9D002DCC  24100007   ADDIU S0, ZERO, 7
3192:                			if (dcl == 1)
9D002DAC  24020001   ADDIU V0, ZERO, 1
9D002DB0  52620060   BEQL S3, V0, 0x9D002F34
9D002DB4  24100002   ADDIU S0, ZERO, 2
3193:                				res = FR_INT_ERR;
3194:                			if (dcl == 0xFFFFFFFF)
9D002DB8  2402FFFF   ADDIU V0, ZERO, -1
9D002DBC  5262005D   BEQL S3, V0, 0x9D002F34
9D002DC0  24100001   ADDIU S0, ZERO, 1
9D002DC4  0B400B74   J 0x9D002DD0
9D002DC8  00000000   NOP
3195:                				res = FR_DISK_ERR;
3196:                			if (res == FR_OK) /* Flush FAT */
9D002DD0  16000058   BNE S0, ZERO, 0x9D002F34
9D002DD4  8FA40010   LW A0, 16(SP)
3197:                				res = move_window(dj.fs, 0);
9D002DD8  0F400082   JAL 0x9D000208
9D002DDC  00002821   ADDU A1, ZERO, ZERO
3198:                			if (res == FR_OK) { /* Initialize the new directory table */
9D002DE0  14400054   BNE V0, ZERO, 0x9D002F34
9D002DE4  00408021   ADDU S0, V0, ZERO
3199:                				dsc = clust2sect(dj.fs, dcl);
9D002DE8  8FB00010   LW S0, 16(SP)
9D002DEC  02002021   ADDU A0, S0, ZERO
9D002DF0  0F400156   JAL clust2sect
9D002DF4  02602821   ADDU A1, S3, ZERO
9D002DF8  00409021   ADDU S2, V0, ZERO
3200:                				dir = dj.fs->win;
9D002DFC  26140030   ADDIU S4, S0, 48
3201:                				mem_set(dir, 0, SS(dj.fs));
9D002E00  02802021   ADDU A0, S4, ZERO
9D002E04  00002821   ADDU A1, ZERO, ZERO
9D002E08  0F400012   JAL 0x9D000048
9D002E0C  24060200   ADDIU A2, ZERO, 512
3202:                				mem_set(dir + DIR_Name, ' ', 8 + 3); /* Create "." entry */
9D002E10  02802021   ADDU A0, S4, ZERO
9D002E14  24050020   ADDIU A1, ZERO, 32
9D002E18  0F400012   JAL 0x9D000048
9D002E1C  2406000B   ADDIU A2, ZERO, 11
3203:                				dir[DIR_Name] = '.';
9D002E20  2415002E   ADDIU S5, ZERO, 46
9D002E24  A2150030   SB S5, 48(S0)
3204:                				dir[DIR_Attr] = AM_DIR;
9D002E28  24020010   ADDIU V0, ZERO, 16
9D002E2C  A202003B   SB V0, 59(S0)
3205:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D002E30  322200FF   ANDI V0, S1, 255
9D002E34  AFA20038   SW V0, 56(SP)
9D002E38  A2020046   SB V0, 70(S0)
9D002E3C  00111A02   SRL V1, S1, 8
9D002E40  A3A30048   SB V1, 72(SP)
9D002E44  A2030047   SB V1, 71(S0)
9D002E48  7E223C00   EXT V0, S1, 16, 8
9D002E4C  AFA2003C   SW V0, 60(SP)
9D002E50  A2020048   SB V0, 72(S0)
9D002E54  00118E02   SRL S1, S1, 24
9D002E58  AFB10040   SW S1, 64(SP)
9D002E5C  A2110049   SB S1, 73(S0)
3206:                				ST_CLUST(dir, dcl);
9D002E60  326300FF   ANDI V1, S3, 255
9D002E64  AFA30044   SW V1, 68(SP)
9D002E68  A203004A   SB V1, 74(S0)
9D002E6C  0013BA02   SRL S7, S3, 8
9D002E70  A217004B   SB S7, 75(S0)
9D002E74  0013B402   SRL S6, S3, 16
9D002E78  32DE00FF   ANDI S8, S6, 255
9D002E7C  A21E0044   SB S8, 68(S0)
9D002E80  0016B202   SRL S6, S6, 8
9D002E84  A2160045   SB S6, 69(S0)
3207:                				mem_cpy(dir + SZ_DIR, dir, SZ_DIR); /* Create ".." entry */
9D002E88  26040050   ADDIU A0, S0, 80
9D002E8C  02802821   ADDU A1, S4, ZERO
9D002E90  0F400008   JAL 0x9D000020
9D002E94  24060020   ADDIU A2, ZERO, 32
3208:                				dir[33] = '.';
9D002E98  A2150051   SB S5, 81(S0)
3209:                				pcl = dj.sclust;
3210:                				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
9D002E9C  8FA30010   LW V1, 16(SP)
9D002EA0  90650000   LBU A1, 0(V1)
9D002EA4  24040003   ADDIU A0, ZERO, 3
9D002EA8  14A40004   BNE A1, A0, 0x9D002EBC
9D002EAC  8FA20018   LW V0, 24(SP)
9D002EB0  8C640024   LW A0, 36(V1)
3211:                					pcl = 0;
9D002EB4  00822026   XOR A0, A0, V0
9D002EB8  0004100A   MOVZ V0, ZERO, A0
3212:                				ST_CLUST(dir+SZ_DIR, pcl);
9D002EBC  A202006A   SB V0, 106(S0)
9D002EC0  7C443A00   EXT A0, V0, 8, 8
9D002EC4  A204006B   SB A0, 107(S0)
9D002EC8  00021402   SRL V0, V0, 16
9D002ECC  A2020064   SB V0, 100(S0)
9D002ED0  00021202   SRL V0, V0, 8
9D002ED4  A2020065   SB V0, 101(S0)
3213:                				for (n = dj.fs->csize; n; n--) { /* Write dot entries and clear following sectors */
9D002ED8  90620002   LBU V0, 2(V1)
9D002EDC  1040003C   BEQ V0, ZERO, 0x9D002FD0
9D002EE0  2455FFFF   ADDIU S5, V0, -1
9D002F24  1655FFF4   BNE S2, S5, 0x9D002EF8
9D002F28  8FA40010   LW A0, 16(SP)
9D002F2C  0B400BF4   J 0x9D002FD0
9D002F30  00000000   NOP
3214:                					dj.fs->winsect = dsc++;
9D002EF4  8FA40010   LW A0, 16(SP)
9D002EF8  AC92002C   SW S2, 44(A0)
9D002EFC  26520001   ADDIU S2, S2, 1
3215:                					dj.fs->wflag = 1;
9D002EF0  24110001   ADDIU S1, ZERO, 1
9D002F00  A0910004   SB S1, 4(A0)
3216:                					res = move_window(dj.fs, 0);
9D002F04  0F400082   JAL 0x9D000208
9D002F08  00002821   ADDU A1, ZERO, ZERO
3217:                					if (res != FR_OK)
9D002F0C  14400009   BNE V0, ZERO, 0x9D002F34
9D002F10  00408021   ADDU S0, V0, ZERO
3218:                						break;
3219:                					mem_set(dir, 0, SS(dj.fs));
9D002F14  02802021   ADDU A0, S4, ZERO
9D002F18  00002821   ADDU A1, ZERO, ZERO
9D002F1C  0F400012   JAL 0x9D000048
9D002F20  24060200   ADDIU A2, ZERO, 512
3220:                				}
3221:                			}
3222:                			if (res == FR_OK)
3223:                				res = dir_register(&dj); /* Register the object to the directoy */
9D002FD0  0F400472   JAL 0x9D0011C8
9D002FD4  27A40010   ADDIU A0, SP, 16
3224:                			if (res != FR_OK) {
9D002FD8  1040FFDB   BEQ V0, ZERO, 0x9D002F48
9D002FDC  00408021   ADDU S0, V0, ZERO
3225:                				remove_chain(dj.fs, dcl); /* Could not register, remove cluster chain */
9D002F34  8FA40010   LW A0, 16(SP)
9D002F38  0F4004D1   JAL 0x9D001344
9D002F3C  02602821   ADDU A1, S3, ZERO
9D002FE0  0B400BCE   J 0x9D002F38
9D002FE4  8FA40010   LW A0, 16(SP)
3226:                			} else {
3227:                				dir = dj.dir;
9D002F48  8FA20024   LW V0, 36(SP)
3228:                				dir[DIR_Attr] = AM_DIR; /* Attribute */
9D002F4C  24030010   ADDIU V1, ZERO, 16
9D002F50  A043000B   SB V1, 11(V0)
3229:                				ST_DWORD(dir+DIR_WrtTime, tim); /* Created time */
9D002F54  8FA30038   LW V1, 56(SP)
9D002F58  A0430016   SB V1, 22(V0)
9D002F5C  93A30048   LBU V1, 72(SP)
9D002F60  A0430017   SB V1, 23(V0)
9D002F64  8FA3003C   LW V1, 60(SP)
9D002F68  A0430018   SB V1, 24(V0)
9D002F6C  8FA30040   LW V1, 64(SP)
9D002F70  A0430019   SB V1, 25(V0)
3230:                				ST_CLUST(dir, dcl); /* Table start cluster */
9D002F74  8FA30044   LW V1, 68(SP)
9D002F78  A043001A   SB V1, 26(V0)
9D002F7C  A057001B   SB S7, 27(V0)
9D002F80  A05E0014   SB S8, 20(V0)
9D002F84  A0560015   SB S6, 21(V0)
3231:                				dj.fs->wflag = 1;
9D002F88  8FA40010   LW A0, 16(SP)
9D002F8C  24020001   ADDIU V0, ZERO, 1
3232:                				res = sync(dj.fs);
9D002F90  0F4000F9   JAL 0x9D0003E4
9D002F94  A0820004   SB V0, 4(A0)
9D002F98  00408021   ADDU S0, V0, ZERO
3233:                			}
3234:                		}FREE_BUF();
3235:                	}
3236:                
3237:                	LEAVE_FF(dj.fs, res);
3238:                }
9D002F40  0B400BE8   J 0x9D002FA0
9D002F44  02001021   ADDU V0, S0, ZERO
9D002F9C  02001021   ADDU V0, S0, ZERO
9D002FA0  8FBF0074   LW RA, 116(SP)
9D002FA4  8FBE0070   LW S8, 112(SP)
9D002FA8  8FB7006C   LW S7, 108(SP)
9D002FAC  8FB60068   LW S6, 104(SP)
9D002FB0  8FB50064   LW S5, 100(SP)
9D002FB4  8FB40060   LW S4, 96(SP)
9D002FB8  8FB3005C   LW S3, 92(SP)
9D002FBC  8FB20058   LW S2, 88(SP)
9D002FC0  8FB10054   LW S1, 84(SP)
9D002FC4  8FB00050   LW S0, 80(SP)
9D002FC8  03E00008   JR RA
9D002FCC  27BD0078   ADDIU SP, SP, 120
3239:                
3240:                /*-----------------------------------------------------------------------*/
3241:                /* Change Attribute                                                      */
3242:                /*-----------------------------------------------------------------------*/
3243:                
3244:                FRESULT f_chmod(const TCHAR *path, /* Pointer to the file path */
3245:                PF_BYTE value, /* Attribute bits */
3246:                PF_BYTE mask /* Attribute mask to change */
3247:                ) {
9D002FE8  27BDFFB8   ADDIU SP, SP, -72
9D002FEC  AFBF0044   SW RA, 68(SP)
9D002FF0  AFB10040   SW S1, 64(SP)
9D002FF4  AFB0003C   SW S0, 60(SP)
9D002FF8  AFA40048   SW A0, 72(SP)
9D002FFC  30B100FF   ANDI S1, A1, 255
9D003000  30D000FF   ANDI S0, A2, 255
3248:                	FRESULT res;
3249:                	DIR dj;
3250:                	PF_BYTE *dir;
3251:                	DEF_NAMEBUF;
3252:                
3253:                	res = chk_mounted(&path, &dj.fs, 1);
9D003004  27A40048   ADDIU A0, SP, 72
9D003008  27A50010   ADDIU A1, SP, 16
9D00300C  0F40050B   JAL chk_mounted
9D003010  24060001   ADDIU A2, ZERO, 1
3254:                	if (res == FR_OK) {
9D003014  14400016   BNE V0, ZERO, 0x9D003070
9D003018  8FBF0044   LW RA, 68(SP)
3255:                		INIT_BUF(dj);
9D00301C  27A2002C   ADDIU V0, SP, 44
9D003020  AFA20028   SW V0, 40(SP)
3256:                		res = follow_path(&dj, path); /* Follow the file path */
9D003024  27A40010   ADDIU A0, SP, 16
9D003028  0F400384   JAL 0x9D000E10
9D00302C  8FA50048   LW A1, 72(SP)
3257:                		FREE_BUF();
3258:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3259:                			res = FR_INVALID_NAME;
3260:                		if (res == FR_OK) {
9D003030  1440000E   BNE V0, ZERO, 0x9D00306C
9D003034  8FA30024   LW V1, 36(SP)
3261:                			dir = dj.dir;
3262:                			if (!dir) { /* Is it a root directory? */
9D003038  1060000C   BEQ V1, ZERO, 0x9D00306C
9D00303C  24020006   ADDIU V0, ZERO, 6
3263:                				res = FR_INVALID_NAME;
3264:                			} else { /* File or sub directory */
3265:                				mask &= AM_RDO | AM_HID | AM_SYS | AM_ARC; /* Valid attribute mask */
9D003040  32100027   ANDI S0, S0, 39
3266:                				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr]
9D003048  9062000B   LBU V0, 11(V1)
9D00304C  00821024   AND V0, A0, V0
9D003050  02118024   AND S0, S0, S1
9D003054  00508025   OR S0, V0, S0
9D003058  A070000B   SB S0, 11(V1)
3267:                						& (PF_BYTE) ~mask); /* Apply attribute change */
9D003044  00102027   NOR A0, ZERO, S0
3268:                				dj.fs->wflag = 1;
9D00305C  8FA40010   LW A0, 16(SP)
9D003060  24020001   ADDIU V0, ZERO, 1
3269:                				res = sync(dj.fs);
9D003064  0F4000F9   JAL 0x9D0003E4
9D003068  A0820004   SB V0, 4(A0)
3270:                			}
3271:                		}
3272:                	}
3273:                
3274:                	LEAVE_FF(dj.fs, res);
3275:                }
9D00306C  8FBF0044   LW RA, 68(SP)
9D003070  8FB10040   LW S1, 64(SP)
9D003074  8FB0003C   LW S0, 60(SP)
9D003078  03E00008   JR RA
9D00307C  27BD0048   ADDIU SP, SP, 72
3276:                
3277:                /*-----------------------------------------------------------------------*/
3278:                /* Change Timestamp                                                      */
3279:                /*-----------------------------------------------------------------------*/
3280:                
3281:                FRESULT f_utime(const TCHAR *path, /* Pointer to the file/directory name */
3282:                const FILINFO *fno /* Pointer to the time stamp to be set */
3283:                ) {
9D003080  27BDFFC0   ADDIU SP, SP, -64
9D003084  AFBF003C   SW RA, 60(SP)
9D003088  AFB00038   SW S0, 56(SP)
9D00308C  AFA40040   SW A0, 64(SP)
9D003090  00A08021   ADDU S0, A1, ZERO
3284:                	FRESULT res;
3285:                	DIR dj;
3286:                	PF_BYTE *dir;
3287:                	DEF_NAMEBUF;
3288:                
3289:                	res = chk_mounted(&path, &dj.fs, 1);
9D003094  27A40040   ADDIU A0, SP, 64
9D003098  27A50010   ADDIU A1, SP, 16
9D00309C  0F40050B   JAL chk_mounted
9D0030A0  24060001   ADDIU A2, ZERO, 1
3290:                	if (res == FR_OK) {
9D0030A4  14400019   BNE V0, ZERO, 0x9D00310C
9D0030A8  8FBF003C   LW RA, 60(SP)
3291:                		INIT_BUF(dj);
9D0030AC  27A2002C   ADDIU V0, SP, 44
9D0030B0  AFA20028   SW V0, 40(SP)
3292:                		res = follow_path(&dj, path); /* Follow the file path */
9D0030B4  27A40010   ADDIU A0, SP, 16
9D0030B8  0F400384   JAL 0x9D000E10
9D0030BC  8FA50040   LW A1, 64(SP)
3293:                		FREE_BUF();
3294:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
3295:                			res = FR_INVALID_NAME;
3296:                		if (res == FR_OK) {
9D0030C0  14400011   BNE V0, ZERO, 0x9D003108
9D0030C4  8FA30024   LW V1, 36(SP)
3297:                			dir = dj.dir;
3298:                			if (!dir) { /* Root directory */
9D0030C8  1060000F   BEQ V1, ZERO, 0x9D003108
9D0030CC  24020006   ADDIU V0, ZERO, 6
3299:                				res = FR_INVALID_NAME;
3300:                			} else { /* File or sub-directory */
3301:                				ST_WORD(dir+DIR_WrtTime, fno->ftime);
9D0030D0  96020006   LHU V0, 6(S0)
9D0030D4  A0620016   SB V0, 22(V1)
9D0030D8  96020006   LHU V0, 6(S0)
9D0030DC  00021202   SRL V0, V0, 8
9D0030E0  A0620017   SB V0, 23(V1)
3302:                				ST_WORD(dir+DIR_WrtDate, fno->fdate);
9D0030E4  96020004   LHU V0, 4(S0)
9D0030E8  A0620018   SB V0, 24(V1)
9D0030EC  96020004   LHU V0, 4(S0)
9D0030F0  00021202   SRL V0, V0, 8
9D0030F4  A0620019   SB V0, 25(V1)
3303:                				dj.fs->wflag = 1;
9D0030F8  8FA40010   LW A0, 16(SP)
9D0030FC  24020001   ADDIU V0, ZERO, 1
3304:                				res = sync(dj.fs);
9D003100  0F4000F9   JAL 0x9D0003E4
9D003104  A0820004   SB V0, 4(A0)
3305:                			}
3306:                		}
3307:                	}
3308:                
3309:                	LEAVE_FF(dj.fs, res);
3310:                }
9D003108  8FBF003C   LW RA, 60(SP)
9D00310C  8FB00038   LW S0, 56(SP)
9D003110  03E00008   JR RA
9D003114  27BD0040   ADDIU SP, SP, 64
3311:                
3312:                /*-----------------------------------------------------------------------*/
3313:                /* Rename File/Directory                                                 */
3314:                /*-----------------------------------------------------------------------*/
3315:                
3316:                FRESULT f_rename(const TCHAR *path_old, /* Pointer to the old name */
3317:                const TCHAR *path_new /* Pointer to the new name */
3318:                ) {
9D003118  27BDFF80   ADDIU SP, SP, -128
9D00311C  AFBF007C   SW RA, 124(SP)
9D003120  AFB10078   SW S1, 120(SP)
9D003124  AFB00074   SW S0, 116(SP)
9D003128  AFA40080   SW A0, 128(SP)
9D00312C  00A08021   ADDU S0, A1, ZERO
3319:                	FRESULT res;
3320:                	DIR djo, djn;
3321:                	PF_BYTE buf[21], *dir;
3322:                	DWORD dw;
3323:                	DEF_NAMEBUF;
3324:                
3325:                	res = chk_mounted(&path_old, &djo.fs, 1);
9D003130  27A40080   ADDIU A0, SP, 128
9D003134  27A50010   ADDIU A1, SP, 16
9D003138  0F40050B   JAL chk_mounted
9D00313C  24060001   ADDIU A2, ZERO, 1
3326:                	if (res == FR_OK) {
9D003140  14400064   BNE V0, ZERO, 0x9D0032D4
9D003144  8FBF007C   LW RA, 124(SP)
3327:                		djn.fs = djo.fs;
9D003148  8FA20010   LW V0, 16(SP)
9D00314C  AFA2002C   SW V0, 44(SP)
3328:                		INIT_BUF(djo);
9D003150  27A20060   ADDIU V0, SP, 96
9D003154  AFA20028   SW V0, 40(SP)
3329:                		res = follow_path(&djo, path_old); /* Check old object */
9D003158  27A40010   ADDIU A0, SP, 16
9D00315C  0F400384   JAL 0x9D000E10
9D003160  8FA50080   LW A1, 128(SP)
3330:                		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
3331:                			res = FR_INVALID_NAME;
3332:                #if _FS_SHARE
3333:                		if (res == FR_OK) res = chk_lock(&djo, 2);
3334:                #endif
3335:                		if (res == FR_OK) { /* Old object is found */
9D003164  1440005A   BNE V0, ZERO, 0x9D0032D0
9D003168  8FA50024   LW A1, 36(SP)
3336:                			if (!djo.dir) { /* Is root dir? */
9D00316C  10A00058   BEQ A1, ZERO, 0x9D0032D0
9D003170  24020004   ADDIU V0, ZERO, 4
3337:                				res = FR_NO_FILE;
3338:                			} else {
3339:                				mem_cpy(buf, djo.dir + DIR_Attr, 21); /* Save the object information except for name */
9D003174  27A40048   ADDIU A0, SP, 72
9D003178  24A5000B   ADDIU A1, A1, 11
9D00317C  0F400008   JAL 0x9D000020
9D003180  24060015   ADDIU A2, ZERO, 21
3340:                				mem_cpy(&djn, &djo, sizeof(DIR)); /* Check new object */
9D003184  27A4002C   ADDIU A0, SP, 44
9D003188  27A50010   ADDIU A1, SP, 16
9D00318C  0F400008   JAL 0x9D000020
9D003190  2406001C   ADDIU A2, ZERO, 28
3341:                				res = follow_path(&djn, path_new);
9D003194  27A4002C   ADDIU A0, SP, 44
9D003198  0F400384   JAL 0x9D000E10
9D00319C  02002821   ADDU A1, S0, ZERO
3342:                				if (res == FR_OK)
9D0031A0  5040004B   BEQL V0, ZERO, 0x9D0032D0
9D0031A4  24020008   ADDIU V0, ZERO, 8
3343:                					res = FR_EXIST; /* The new object name is already existing */
3344:                				if (res == FR_NO_FILE) { /* Is it a valid path and no name collision? */
9D0031A8  24030004   ADDIU V1, ZERO, 4
9D0031AC  14430049   BNE V0, V1, 0x9D0032D4
9D0031B0  8FBF007C   LW RA, 124(SP)
3345:                					/* Start critical section that any interruption or error can cause cross-link */
3346:                					res = dir_register(&djn); /* Register the new entry */
9D0031B4  0F400472   JAL 0x9D0011C8
9D0031B8  27A4002C   ADDIU A0, SP, 44
3347:                					if (res == FR_OK) {
9D0031BC  14400045   BNE V0, ZERO, 0x9D0032D4
9D0031C0  8FBF007C   LW RA, 124(SP)
3348:                						dir = djn.dir; /* Copy object information except for name */
9D0031C4  8FB00040   LW S0, 64(SP)
3349:                						mem_cpy(dir + 13, buf + 2, 19);
9D0031C8  2604000D   ADDIU A0, S0, 13
9D0031CC  27A5004A   ADDIU A1, SP, 74
9D0031D0  0F400008   JAL 0x9D000020
9D0031D4  24060013   ADDIU A2, ZERO, 19
3350:                						dir[DIR_Attr] = buf[0] | AM_ARC;
9D0031D8  93A20048   LBU V0, 72(SP)
9D0031DC  34420020   ORI V0, V0, 32
9D0031E0  A202000B   SB V0, 11(S0)
3351:                						djo.fs->wflag = 1;
9D0031E4  24030001   ADDIU V1, ZERO, 1
9D0031E8  8FA20010   LW V0, 16(SP)
9D0031EC  A0430004   SB V1, 4(V0)
3352:                						if (djo.sclust != djn.sclust
9D0031F0  8FA20034   LW V0, 52(SP)
9D0031F4  8FA30018   LW V1, 24(SP)
9D0031F8  1062002D   BEQ V1, V0, 0x9D0032B0
9D0031FC  00000000   NOP
3353:                								&& (dir[DIR_Attr] & AM_DIR)) { /* Update .. entry in the directory if needed */
9D003200  9202000B   LBU V0, 11(S0)
9D003204  30420010   ANDI V0, V0, 16
9D003208  10400029   BEQ V0, ZERO, 0x9D0032B0
9D00320C  8FB1002C   LW S1, 44(SP)
3354:                							dw = clust2sect(djn.fs, LD_CLUST(dir));
9D003210  92050015   LBU A1, 21(S0)
9D003214  00052A00   SLL A1, A1, 8
9D003218  92020014   LBU V0, 20(S0)
9D00321C  00A22825   OR A1, A1, V0
9D003220  00052C00   SLL A1, A1, 16
9D003224  9203001B   LBU V1, 27(S0)
9D003228  00031A00   SLL V1, V1, 8
9D00322C  9202001A   LBU V0, 26(S0)
9D003230  00621025   OR V0, V1, V0
9D003234  02202021   ADDU A0, S1, ZERO
9D003238  0F400156   JAL clust2sect
9D00323C  00A22825   OR A1, A1, V0
9D003240  00402821   ADDU A1, V0, ZERO
3355:                							if (!dw) {
9D003244  10A00022   BEQ A1, ZERO, 0x9D0032D0
9D003248  24020002   ADDIU V0, ZERO, 2
3356:                								res = FR_INT_ERR;
3357:                							} else {
3358:                								res = move_window(djn.fs, dw);
9D00324C  0F400082   JAL 0x9D000208
9D003250  02202021   ADDU A0, S1, ZERO
3359:                								dir = djn.fs->win + SZ_DIR; /* .. entry */
3360:                								if (res == FR_OK && dir[1] == '.') {
9D003254  1440001E   BNE V0, ZERO, 0x9D0032D0
9D003258  8FA3002C   LW V1, 44(SP)
9D00325C  90640051   LBU A0, 81(V1)
9D003260  2402002E   ADDIU V0, ZERO, 46
9D003264  14820012   BNE A0, V0, 0x9D0032B0
9D003268  24020003   ADDIU V0, ZERO, 3
3361:                									dw
3362:                											= (djn.fs->fs_type == FS_FAT32
3363:                													&& djn.sclust
3364:                															== djn.fs->dirbase) ? 0
3365:                													: djn.sclust;
9D00326C  90640000   LBU A0, 0(V1)
9D003270  14820006   BNE A0, V0, 0x9D00328C
9D003274  8FA20034   LW V0, 52(SP)
9D003278  8C640024   LW A0, 36(V1)
9D00327C  8FA50034   LW A1, 52(SP)
9D003280  10A40002   BEQ A1, A0, 0x9D00328C
9D003284  00001021   ADDU V0, ZERO, ZERO
9D003288  8FA20034   LW V0, 52(SP)
3366:                									ST_CLUST(dir, dw);
9D00328C  A062006A   SB V0, 106(V1)
9D003290  7C443A00   EXT A0, V0, 8, 8
9D003294  A064006B   SB A0, 107(V1)
9D003298  00021402   SRL V0, V0, 16
9D00329C  A0620064   SB V0, 100(V1)
9D0032A0  00021202   SRL V0, V0, 8
9D0032A4  A0620065   SB V0, 101(V1)
3367:                									djn.fs->wflag = 1;
9D0032A8  24020001   ADDIU V0, ZERO, 1
9D0032AC  A0620004   SB V0, 4(V1)
3368:                								}
3369:                							}
3370:                						}
3371:                						if (res == FR_OK) {
3372:                							res = dir_remove(&djo); /* Remove old entry */
9D0032B0  0F40021C   JAL 0x9D000870
9D0032B4  27A40010   ADDIU A0, SP, 16
3373:                							if (res == FR_OK)
9D0032B8  54400006   BNEL V0, ZERO, 0x9D0032D4
9D0032BC  8FBF007C   LW RA, 124(SP)
3374:                								res = sync(djo.fs);
9D0032C0  0F4000F9   JAL 0x9D0003E4
9D0032C4  8FA40010   LW A0, 16(SP)
3375:                						}
3376:                					}
3377:                					/* End critical section */
3378:                				}
3379:                			}
3380:                		}FREE_BUF();
3381:                	}
3382:                	LEAVE_FF(djo.fs, res);
3383:                }
9D0032C8  0B400CB5   J 0x9D0032D4
9D0032CC  8FBF007C   LW RA, 124(SP)
9D0032D0  8FBF007C   LW RA, 124(SP)
9D0032D4  8FB10078   LW S1, 120(SP)
9D0032D8  8FB00074   LW S0, 116(SP)
9D0032DC  03E00008   JR RA
9D0032E0  27BD0080   ADDIU SP, SP, 128
3384:                
3385:                #endif /* !_FS_READONLY */
3386:                #endif /* _FS_MINIMIZE == 0 */
3387:                #endif /* _FS_MINIMIZE <= 1 */
3388:                #endif /* _FS_MINIMIZE <= 2 */
3389:                
3390:                /*-----------------------------------------------------------------------*/
3391:                /* Forward data to the stream directly (available on only tiny cfg)      */
3392:                /*-----------------------------------------------------------------------*/
3393:                #if _USE_FORWARD && _FS_TINY
3394:                
3395:                FRESULT f_forward (
3396:                		FIL *fp, /* Pointer to the file object */
3397:                		UINT (*func)(const PF_BYTE*,UINT), /* Pointer to the streaming function */
3398:                		UINT btr, /* Number of bytes to forward */
3399:                		UINT *bf /* Pointer to number of bytes forwarded */
3400:                )
3401:                {
3402:                	FRESULT res;
3403:                	DWORD remain, clst, sect;
3404:                	UINT rcnt;
3405:                	PF_BYTE csect;
3406:                
3407:                	*bf = 0; /* Initialize byte counter */
3408:                
3409:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
3410:                	if (res != FR_OK) LEAVE_FF(fp->fs, res);
3411:                	if (fp->flag & FA__ERROR) /* Check error flag */
3412:                	LEAVE_FF(fp->fs, FR_INT_ERR);
3413:                	if (!(fp->flag & FA_READ)) /* Check access mode */
3414:                	LEAVE_FF(fp->fs, FR_DENIED);
3415:                
3416:                	remain = fp->fsize - fp->fptr;
3417:                	if (btr > remain) btr = (UINT)remain; /* Truncate btr by remaining bytes */
3418:                
3419:                	for (; btr && (*func)(0, 0); /* Repeat until all data transferred or stream becomes busy */
3420:                			fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
3421:                		csect = (PF_BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
3422:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
3423:                			if (!csect) { /* On the cluster boundary? */
3424:                				clst = (fp->fptr == 0) ? /* On the top of the file? */
3425:                				fp->sclust : get_fat(fp->fs, fp->clust);
3426:                				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
3427:                				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
3428:                				fp->clust = clst; /* Update current cluster */
3429:                			}
3430:                		}
3431:                		sect = clust2sect(fp->fs, fp->clust); /* Get current data sector */
3432:                		if (!sect) ABORT(fp->fs, FR_INT_ERR);
3433:                		sect += csect;
3434:                		if (move_window(fp->fs, sect)) /* Move sector window */
3435:                		ABORT(fp->fs, FR_DISK_ERR);
3436:                		fp->dsect = sect;
3437:                		rcnt = SS(fp->fs) - (PF_WORD)(fp->fptr % SS(fp->fs)); /* Forward data from sector window */
3438:                		if (rcnt > btr) rcnt = btr;
3439:                		rcnt = (*func)(&fp->fs->win[(PF_WORD)fp->fptr % SS(fp->fs)], rcnt);
3440:                		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
3441:                	}
3442:                
3443:                	LEAVE_FF(fp->fs, FR_OK);
3444:                }
3445:                #endif /* _USE_FORWARD */
3446:                
3447:                #if _USE_MKFS && !_FS_READONLY
3448:                /*-----------------------------------------------------------------------*/
3449:                /* Create File System on the Drive                                       */
3450:                /*-----------------------------------------------------------------------*/
3451:                #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
3452:                #define N_FATS		1		/* Number of FAT copies (1 or 2) */
3453:                
3454:                FRESULT f_mkfs (
3455:                		PF_BYTE drv, /* Logical drive number */
3456:                		PF_BYTE sfd, /* Partitioning rule 0:FDISK, 1:SFD */
3457:                		UINT au /* Allocation unit size [bytes] */
3458:                )
3459:                {
3460:                	static const PF_WORD vst[] = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0};
3461:                	static const PF_WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
3462:                	PF_BYTE fmt, md, sys, *tbl, pdrv, part;
3463:                	DWORD n_clst, vs, n, wsect;
3464:                	UINT i;
3465:                	DWORD b_vol, b_fat, b_dir, b_data; /* LBA */
3466:                	DWORD n_vol, n_rsv, n_fat, n_dir; /* Size */
3467:                	FATFS *fs;
3468:                	DSTATUS stat;
3469:                
3470:                	/* Check mounted drive and clear work area */
3471:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
3472:                	if (sfd > 1) return FR_INVALID_PARAMETER;
3473:                	if (au & (au - 1)) return FR_INVALID_PARAMETER;
3474:                	fs = FatFs[drv];
3475:                	if (!fs) return FR_NOT_ENABLED;
3476:                	fs->fs_type = 0;
3477:                	pdrv = LD2PD(drv); /* Physical drive */
3478:                	part = LD2PT(drv); /* Partition (0:auto detect, 1-4:get from partition table)*/
3479:                
3480:                	/* Get disk statics */
3481:                	stat = disk_initialize(pdrv);
3482:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3483:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3484:                #if _MAX_SS != 512					/* Get disk sector size */
3485:                	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
3486:                	return FR_DISK_ERR;
3487:                #endif
3488:                	if (_MULTI_PARTITION && part) {
3489:                		/* Get partition information from partition table in the MBR */
3490:                		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3491:                		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
3492:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3493:                		if (!tbl[4]) return FR_MKFS_ABORTED; /* No partition? */
3494:                		b_vol = LD_DWORD(tbl+8); /* Volume start sector */
3495:                		n_vol = LD_DWORD(tbl+12); /* Volume size */
3496:                	} else {
3497:                		/* Create a partition in this function */
3498:                		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
3499:                		return FR_DISK_ERR;
3500:                		b_vol = (sfd) ? 0 : 63; /* Volume start sector */
3501:                		n_vol -= b_vol; /* Volume size */
3502:                	}
3503:                
3504:                	if (!au) { /* AU auto selection */
3505:                		vs = n_vol / (2000 / (SS(fs) / 512));
3506:                		for (i = 0; vs < vst[i]; i++);
3507:                		au = cst[i];
3508:                	}
3509:                	au /= SS(fs); /* Number of sectors per cluster */
3510:                	if (au == 0) au = 1;
3511:                	if (au > 128) au = 128;
3512:                
3513:                	/* Pre-compute number of clusters and FAT syb-type */
3514:                	n_clst = n_vol / au;
3515:                	fmt = FS_FAT12;
3516:                	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
3517:                	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
3518:                
3519:                	/* Determine offset and size of FAT structure */
3520:                	if (fmt == FS_FAT32) {
3521:                		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
3522:                		n_rsv = 32;
3523:                		n_dir = 0;
3524:                	} else {
3525:                		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
3526:                		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
3527:                		n_rsv = 1;
3528:                		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
3529:                	}
3530:                	b_fat = b_vol + n_rsv; /* FAT area start sector */
3531:                	b_dir = b_fat + n_fat * N_FATS; /* Directory area start sector */
3532:                	b_data = b_dir + n_dir; /* Data area start sector */
3533:                	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED; /* Too small volume */
3534:                
3535:                	/* Align data start sector to erase block boundary (for flash memory media) */
3536:                	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
3537:                	n = (b_data + n - 1) & ~(n - 1); /* Next nearest erase block from current data start */
3538:                	n = (n - b_data) / N_FATS;
3539:                	if (fmt == FS_FAT32) { /* FAT32: Move FAT offset */
3540:                		n_rsv += n;
3541:                		b_fat += n;
3542:                	} else { /* FAT12/16: Expand FAT size */
3543:                		n_fat += n;
3544:                	}
3545:                
3546:                	/* Determine number of clusters and final check of validity of the FAT sub-type */
3547:                	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
3548:                	if ( (fmt == FS_FAT16 && n_clst < MIN_FAT16)
3549:                			|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
3550:                	return FR_MKFS_ABORTED;
3551:                
3552:                	switch (fmt) { /* Determine system ID for partition table */
3553:                		case FS_FAT12: sys = 0x01; break;
3554:                		case FS_FAT16: sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
3555:                		default: sys = 0x0C;
3556:                	}
3557:                
3558:                	if (_MULTI_PARTITION && part) {
3559:                		/* Update system ID in the partition table */
3560:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3561:                		tbl[4] = sys;
3562:                		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3563:                		md = 0xF8;
3564:                	} else {
3565:                		if (sfd) { /* No patition table (SFD) */
3566:                			md = 0xF0;
3567:                		} else { /* Create partition table (FDISK) */
3568:                			mem_set(fs->win, 0, SS(fs));
3569:                			tbl = fs->win+MBR_Table; /* Create partiton table for single partition in the drive */
3570:                			tbl[1] = 1; /* Partition start head */
3571:                			tbl[2] = 1; /* Partition start sector */
3572:                			tbl[3] = 0; /* Partition start cylinder */
3573:                			tbl[4] = sys; /* System type */
3574:                			tbl[5] = 254; /* Partition end head */
3575:                			n = (b_vol + n_vol) / 63 / 255;
3576:                			tbl[6] = (PF_BYTE)((n >> 2) | 63); /* Partiiton end sector */
3577:                			tbl[7] = (PF_BYTE)n; /* End cylinder */
3578:                			ST_DWORD(tbl+8, 63); /* Partition start in LBA */
3579:                			ST_DWORD(tbl+12, n_vol); /* Partition size in LBA */
3580:                			ST_WORD(fs->win+BS_55AA, 0xAA55); /* MBR signature */
3581:                			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) /* Write it to the MBR sector */
3582:                			return FR_DISK_ERR;
3583:                			md = 0xF8;
3584:                		}
3585:                	}
3586:                
3587:                	/* Create BPB in the VBR */
3588:                	tbl = fs->win; /* Clear sector */
3589:                	mem_set(tbl, 0, SS(fs));
3590:                	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
3591:                	i = SS(fs); /* Sector size */
3592:                	ST_WORD(tbl+BPB_BytsPerSec, i);
3593:                	tbl[BPB_SecPerClus] = (PF_BYTE)au; /* Sectors per cluster */
3594:                	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv); /* Reserved sectors */
3595:                	tbl[BPB_NumFATs] = N_FATS; /* Number of FATs */
3596:                	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR; /* Number of rootdir entries */
3597:                	ST_WORD(tbl+BPB_RootEntCnt, i);
3598:                	if (n_vol < 0x10000) { /* Number of total sectors */
3599:                		ST_WORD(tbl+BPB_TotSec16, n_vol);
3600:                	} else {
3601:                		ST_DWORD(tbl+BPB_TotSec32, n_vol);
3602:                	}
3603:                	tbl[BPB_Media] = md; /* Media descriptor */
3604:                	ST_WORD(tbl+BPB_SecPerTrk, 63); /* Number of sectors per track */
3605:                	ST_WORD(tbl+BPB_NumHeads, 255); /* Number of heads */
3606:                	ST_DWORD(tbl+BPB_HiddSec, b_vol); /* Hidden sectors */
3607:                	n = get_fattime(); /* Use current time as VSN */
3608:                	if (fmt == FS_FAT32) {
3609:                		ST_DWORD(tbl+BS_VolID32, n); /* VSN */
3610:                		ST_DWORD(tbl+BPB_FATSz32, n_fat); /* Number of sectors per FAT */
3611:                		ST_DWORD(tbl+BPB_RootClus, 2); /* Root directory start cluster (2) */
3612:                		ST_WORD(tbl+BPB_FSInfo, 1); /* FSInfo record offset (VBR+1) */
3613:                		ST_WORD(tbl+BPB_BkBootSec, 6); /* Backup boot record offset (VBR+6) */
3614:                		tbl[BS_DrvNum32] = 0x80; /* Drive number */
3615:                		tbl[BS_BootSig32] = 0x29; /* Extended boot signature */
3616:                		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19); /* Volume label, FAT signature */
3617:                	} else {
3618:                		ST_DWORD(tbl+BS_VolID, n); /* VSN */
3619:                		ST_WORD(tbl+BPB_FATSz16, n_fat); /* Number of sectors per FAT */
3620:                		tbl[BS_DrvNum] = 0x80; /* Drive number */
3621:                		tbl[BS_BootSig] = 0x29; /* Extended boot signature */
3622:                		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19); /* Volume label, FAT signature */
3623:                	}
3624:                	ST_WORD(tbl+BS_55AA, 0xAA55); /* Signature (Offset is fixed here regardless of sector size) */
3625:                	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK) /* Write it to the VBR sector */
3626:                	return FR_DISK_ERR;
3627:                	if (fmt == FS_FAT32) /* Write backup VBR if needed (VBR+6) */
3628:                	disk_write(pdrv, tbl, b_vol + 6, 1);
3629:                
3630:                	/* Initialize FAT area */
3631:                	wsect = b_fat;
3632:                	for (i = 0; i < N_FATS; i++) { /* Initialize each FAT copy */
3633:                		mem_set(tbl, 0, SS(fs)); /* 1st sector of the FAT  */
3634:                		n = md; /* Media descriptor byte */
3635:                		if (fmt != FS_FAT32) {
3636:                			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
3637:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT12/16) */
3638:                		} else {
3639:                			n |= 0xFFFFFF00;
3640:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT32) */
3641:                			ST_DWORD(tbl+4, 0xFFFFFFFF);
3642:                			ST_DWORD(tbl+8, 0x0FFFFFFF); /* Reserve cluster #2 for root dir */
3643:                		}
3644:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3645:                		return FR_DISK_ERR;
3646:                		mem_set(tbl, 0, SS(fs)); /* Fill following FAT entries with zero */
3647:                		for (n = 1; n < n_fat; n++) { /* This loop may take a time on FAT32 volume due to many single sector writes */
3648:                			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3649:                			return FR_DISK_ERR;
3650:                		}
3651:                	}
3652:                
3653:                	/* Initialize root directory */
3654:                	i = (fmt == FS_FAT32) ? au : n_dir;
3655:                	do {
3656:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3657:                		return FR_DISK_ERR;
3658:                	}while (--i);
3659:                
3660:                #if _USE_ERASE	/* Erase data area if needed */
3661:                	{
3662:                		DWORD eb[2];
3663:                
3664:                		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
3665:                		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
3666:                	}
3667:                #endif
3668:                
3669:                	/* Create FSInfo if needed */
3670:                	if (fmt == FS_FAT32) {
3671:                		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
3672:                		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
3673:                		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1); /* Number of free clusters */
3674:                		ST_DWORD(tbl+FSI_Nxt_Free, 2); /* Last allocated cluster# */
3675:                		ST_WORD(tbl+BS_55AA, 0xAA55);
3676:                		disk_write(pdrv, tbl, b_vol + 1, 1); /* Write original (VBR+1) */
3677:                		disk_write(pdrv, tbl, b_vol + 7, 1); /* Write backup (VBR+7) */
3678:                	}
3679:                
3680:                	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
3681:                }
3682:                
3683:                #if _MULTI_PARTITION == 2
3684:                /*-----------------------------------------------------------------------*/
3685:                /* Divide Physical Drive                                                 */
3686:                /*-----------------------------------------------------------------------*/
3687:                
3688:                FRESULT f_fdisk (
3689:                		PF_BYTE pdrv, /* Physical drive number */
3690:                		const DWORD szt[], /* Pointer to the size table for each partitions */
3691:                		void* work /* Pointer to the working buffer */
3692:                )
3693:                {
3694:                	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
3695:                	PF_BYTE s_hd, e_hd, *p, *buf = (PF_BYTE*)work;
3696:                	DSTATUS stat;
3697:                	DWORD sz_disk, sz_part, s_part;
3698:                
3699:                	stat = disk_initialize(pdrv);
3700:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3701:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3702:                	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
3703:                
3704:                	/* Determine CHS in the table regardless of the drive geometry */
3705:                	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2);
3706:                	if (n == 256) n--;
3707:                	e_hd = n - 1;
3708:                	sz_cyl = 63 * n;
3709:                	tot_cyl = sz_disk / sz_cyl;
3710:                
3711:                	/* Create partition table */
3712:                	mem_set(buf, 0, _MAX_SS);
3713:                	p = buf + MBR_Table; b_cyl = 0;
3714:                	for (i = 0; i < 4; i++, p += SZ_PTE) {
3715:                		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
3716:                		if (!p_cyl) continue;
3717:                		s_part = (DWORD)sz_cyl * b_cyl;
3718:                		sz_part = (DWORD)sz_cyl * p_cyl;
3719:                		if (i == 0) { /* Exclude first track of cylinder 0 */
3720:                			s_hd = 1;
3721:                			s_part += 63; sz_part -= 63;
3722:                		} else {
3723:                			s_hd = 0;
3724:                		}
3725:                		e_cyl = b_cyl + p_cyl - 1;
3726:                		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
3727:                
3728:                		/* Set partition table */
3729:                		p[1] = s_hd; /* Start head */
3730:                		p[2] = (PF_BYTE)((b_cyl >> 2) + 1); /* Start sector */
3731:                		p[3] = (PF_BYTE)b_cyl; /* Start cylinder */
3732:                		p[4] = 0x06; /* System type (temporary setting) */
3733:                		p[5] = e_hd; /* End head */
3734:                		p[6] = (PF_BYTE)((e_cyl >> 2) + 63); /* End sector */
3735:                		p[7] = (PF_BYTE)e_cyl; /* End cylinder */
3736:                		ST_DWORD(p + 8, s_part); /* Start sector in LBA */
3737:                		ST_DWORD(p + 12, sz_part); /* Partition size */
3738:                
3739:                		/* Next partition */
3740:                		b_cyl += p_cyl;
3741:                	}
3742:                	ST_WORD(p, 0xAA55);
3743:                
3744:                	/* Write it to the MBR */
3745:                	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
3746:                }
3747:                
3748:                #endif /* _MULTI_PARTITION == 2 */
3749:                #endif /* _USE_MKFS && !_FS_READONLY */
3750:                
3751:                #if _USE_STRFUNC
3752:                /*-----------------------------------------------------------------------*/
3753:                /* Get a string from the file                                            */
3754:                /*-----------------------------------------------------------------------*/
3755:                TCHAR* f_gets (
3756:                		TCHAR* buff, /* Pointer to the string buffer to read */
3757:                		int len, /* Size of string buffer (characters) */
3758:                		FIL* fil /* Pointer to the file object */
3759:                )
3760:                {
3761:                	int n = 0;
3762:                	TCHAR c, *p = buff;
3763:                	PF_BYTE s[2];
3764:                	UINT rc;
3765:                
3766:                	while (n < len - 1) { /* Read bytes until buffer gets filled */
3767:                		f_read(fil, s, 1, &rc);
3768:                		if (rc != 1) break; /* Break on EOF or error */
3769:                		c = s[0];
3770:                #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
3771:                		if (c >= 0x80) {
3772:                			if (c < 0xC0) continue; /* Skip stray trailer */
3773:                			if (c < 0xE0) { /* Two-byte sequense */
3774:                				f_read(fil, s, 1, &rc);
3775:                				if (rc != 1) break;
3776:                				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
3777:                				if (c < 0x80) c = '?';
3778:                			} else {
3779:                				if (c < 0xF0) { /* Three-byte sequense */
3780:                					f_read(fil, s, 2, &rc);
3781:                					if (rc != 2) break;
3782:                					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
3783:                					if (c < 0x800) c = '?';
3784:                				} else { /* Reject four-byte sequense */
3785:                					c = '?';
3786:                				}
3787:                			}
3788:                		}
3789:                #endif
3790:                #if _USE_STRFUNC >= 2
3791:                		if (c == '\r') continue; /* Strip '\r' */
3792:                #endif
3793:                		*p++ = c;
3794:                		n++;
3795:                		if (c == '\n') break; /* Break on EOL */
3796:                	}
3797:                	*p = 0;
3798:                	return n ? buff : 0; /* When no data read (eof or error), return with error. */
3799:                }
3800:                
3801:                #if !_FS_READONLY
3802:                #include <stdarg.h>
3803:                /*-----------------------------------------------------------------------*/
3804:                /* Put a character to the file                                           */
3805:                /*-----------------------------------------------------------------------*/
3806:                int f_putc (
3807:                		TCHAR c, /* A character to be output */
3808:                		FIL* fil /* Pointer to the file object */
3809:                )
3810:                {
3811:                	UINT bw, btw;
3812:                	PF_BYTE s[3];
3813:                
3814:                #if _USE_STRFUNC >= 2
3815:                	if (c == '\n') f_putc ('\r', fil); /* LF -> CRLF conversion */
3816:                #endif
3817:                
3818:                #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
3819:                	if (c < 0x80) { /* 7-bit */
3820:                		s[0] = (PF_BYTE)c;
3821:                		btw = 1;
3822:                	} else {
3823:                		if (c < 0x800) { /* 11-bit */
3824:                			s[0] = (PF_BYTE)(0xC0 | (c >> 6));
3825:                			s[1] = (PF_BYTE)(0x80 | (c & 0x3F));
3826:                			btw = 2;
3827:                		} else { /* 16-bit */
3828:                			s[0] = (PF_BYTE)(0xE0 | (c >> 12));
3829:                			s[1] = (PF_BYTE)(0x80 | ((c >> 6) & 0x3F));
3830:                			s[2] = (PF_BYTE)(0x80 | (c & 0x3F));
3831:                			btw = 3;
3832:                		}
3833:                	}
3834:                #else				/* Write the character without conversion */
3835:                	s[0] = (PF_BYTE)c;
3836:                	btw = 1;
3837:                #endif
3838:                	f_write(fil, s, btw, &bw); /* Write the char to the file */
3839:                	return (bw == btw) ? 1 : EOF; /* Return the result */
3840:                }
3841:                
3842:                /*-----------------------------------------------------------------------*/
3843:                /* Put a string to the file                                              */
3844:                /*-----------------------------------------------------------------------*/
3845:                int f_puts (
3846:                		const TCHAR* str, /* Pointer to the string to be output */
3847:                		FIL* fil /* Pointer to the file object */
3848:                )
3849:                {
3850:                	int n;
3851:                
3852:                	for (n = 0; *str; str++, n++) {
3853:                		if (f_putc(*str, fil) == EOF) return EOF;
3854:                	}
3855:                	return n;
3856:                }
3857:                
3858:                /*-----------------------------------------------------------------------*/
3859:                /* Put a formatted string to the file                                    */
3860:                /*-----------------------------------------------------------------------*/
3861:                int f_printf (
3862:                		FIL* fil, /* Pointer to the file object */
3863:                		const TCHAR* str, /* Pointer to the format string */
3864:                		... /* Optional arguments... */
3865:                )
3866:                {
3867:                	va_list arp;
3868:                	PF_BYTE f, r;
3869:                	UINT i, j, w;
3870:                	ULONG v;
3871:                	TCHAR c, d, s[16], *p;
3872:                	int res, chc, cc;
3873:                
3874:                	va_start(arp, str);
3875:                
3876:                	for (cc = res = 0; cc != EOF; res += cc) {
3877:                		c = *str++;
3878:                		if (c == 0) break; /* End of string */
3879:                		if (c != '%') { /* Non escape character */
3880:                			cc = f_putc(c, fil);
3881:                			if (cc != EOF) cc = 1;
3882:                			continue;
3883:                		}
3884:                		w = f = 0;
3885:                		c = *str++;
3886:                		if (c == '0') { /* Flag: '0' padding */
3887:                			f = 1; c = *str++;
3888:                		} else {
3889:                			if (c == '-') { /* Flag: left justified */
3890:                				f = 2; c = *str++;
3891:                			}
3892:                		}
3893:                		while (IsDigit(c)) { /* Precision */
3894:                			w = w * 10 + c - '0';
3895:                			c = *str++;
3896:                		}
3897:                		if (c == 'l' || c == 'L') { /* Prefix: Size is long int */
3898:                			f |= 4; c = *str++;
3899:                		}
3900:                		if (!c) break;
3901:                		d = c;
3902:                		if (IsLower(d)) d -= 0x20;
3903:                		switch (d) { /* Type is... */
3904:                			case 'S' : /* String */
3905:                			p = va_arg(arp, TCHAR*);
3906:                			for (j = 0; p[j]; j++);
3907:                			chc = 0;
3908:                			if (!(f & 2)) {
3909:                				while (j++ < w) chc += (cc = f_putc(' ', fil));
3910:                			}
3911:                			chc += (cc = f_puts(p, fil));
3912:                			while (j++ < w) chc += (cc = f_putc(' ', fil));
3913:                			if (cc != EOF) cc = chc;
3914:                			continue;
3915:                			case 'C' : /* Character */
3916:                			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
3917:                			case 'B' : /* Binary */
3918:                			r = 2; break;
3919:                			case 'O' : /* Octal */
3920:                			r = 8; break;
3921:                			case 'D' : /* Signed decimal */
3922:                			case 'U' : /* Unsigned decimal */
3923:                			r = 10; break;
3924:                			case 'X' : /* Hexdecimal */
3925:                			r = 16; break;
3926:                			default: /* Unknown type (passthrough) */
3927:                			cc = f_putc(c, fil); continue;
3928:                		}
3929:                
3930:                		/* Get an argument and put it in numeral */
3931:                		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
3932:                		if (d == 'D' && (v & 0x80000000)) {
3933:                			v = 0 - v;
3934:                			f |= 8;
3935:                		}
3936:                		i = 0;
3937:                		do {
3938:                			d = (TCHAR)(v % r); v /= r;
3939:                			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
3940:                			s[i++] = d + '0';
3941:                		}while (v && i < sizeof(s) / sizeof(s[0]));
3942:                		if (f & 8) s[i++] = '-';
3943:                		j = i; d = (f & 1) ? '0' : ' ';
3944:                		res = 0;
3945:                		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
3946:                		do res += (cc = f_putc(s[--i], fil)); while(i);
3947:                		while (j++ < w) res += (cc = f_putc(' ', fil));
3948:                		if (cc != EOF) cc = res;
3949:                	}
3950:                
3951:                	va_end(arp);
3952:                	return (cc == EOF) ? cc : res;
3953:                }
3954:                
3955:                #endif /* !_FS_READONLY */
3956:                #endif /* _USE_STRFUNC */
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/Pinguino/diskio.c  -----------------------------
1:                   /*------------------------------------------------------------------------/
2:                    /  MMCv3/SDv1/SDv2 (in SPI mode) control module
3:                    /-------------------------------------------------------------------------/
4:                    /
5:                    /  Copyright (C) 2010, ChaN, all right reserved.
6:                    /
7:                    / * This software is a free software and there is NO WARRANTY.
8:                    / * No restriction on use. You can use, modify and redistribute it for
9:                    /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
10:                   / * Redistributions of source code must retain the above copyright notice.
11:                   /
12:                   /-------------------------------------------------------------------------*/
13:                  
14:                  // 07 May 2012 Changes made to allow SD card library to support
15:                  //					PIC32 Pinguino Micro and potentially other cards that
16:                  //					do not support the use of the RTCC library.
17:                  // 25 May 2012 Added includes for delay.c and digitalw.c
18:                  
19:                  //#include "ff.h"
20:                  #include "diskio.h"
21:                  //#include <delay.c>
22:                  //#include <digitalw.c>
23:                  #include "../HardwareProfile.h"
24:                  #include "sdmmc.h"
25:                  
26:                  // For boards known to support the RTCC library ***Added 07 May 2012
27:                  // to allow SD Library to support PIC32 Pinguino Micro, which
28:                  // which does not have a RTCC crystal and associated components,
29:                  // and would not operate if #include <rtcc.c> is included.
30:                  // See also changes to get_fattime() below.
31:                  
32:                  #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
33:                  	#include <rtcc.c>
34:                  #endif
35:                  
36:                  /* Definitions for MMC/SDC command */
37:                  #define CMD0   (0)			/* GO_IDLE_STATE */
38:                  #define CMD1   (1)			/* SEND_OP_COND */
39:                  #define ACMD41 (41|0x80)	/* SEND_OP_COND (SDC) */
40:                  #define CMD8   (8)			/* SEND_IF_COND */
41:                  #define CMD9   (9)			/* SEND_CSD */
42:                  #define CMD10  (10)			/* SEND_CID */
43:                  #define CMD12  (12)			/* STOP_TRANSMISSION */
44:                  #define ACMD13 (13|0x80)	/* SD_STATUS (SDC) */
45:                  #define CMD16  (16)			/* SET_BLOCKLEN */
46:                  #define CMD17  (17)			/* READ_SINGLE_BLOCK */
47:                  #define CMD18  (18)			/* READ_MULTIPLE_BLOCK */
48:                  #define CMD23  (23)			/* SET_BLOCK_COUNT */
49:                  #define ACMD23 (23|0x80)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
50:                  #define CMD24  (24)			/* WRITE_BLOCK */
51:                  #define CMD25  (25)			/* WRITE_MULTIPLE_BLOCK */
52:                  #define CMD41  (41)			/* SEND_OP_COND (ACMD) */
53:                  #define CMD55  (55)			/* APP_CMD */
54:                  #define CMD58  (58)			/* READ_OCR */
55:                  
56:                  /* Port Controls  (Platform dependent) */
57:                  //#define SOCKPORT	PORTB		/* Socket contact port */
58:                  //#define SOCKWP	(1<<10)		/* Write protect switch (RB10) */
59:                  //#define SOCKINS	(1<<11)		/* Card detect switch (RB11) */
60:                  
61:                  //#define	FCLK_SLOW()			/* Set slow clock (100k-400k) */
62:                  //#define	FCLK_FAST()			/* Set fast clock (depends on the CSD) */
63:                  
64:                  
65:                  /*--------------------------------------------------------------------------
66:                  
67:                   Module Private Functions
68:                  
69:                   ---------------------------------------------------------------------------*/
70:                  
71:                  static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
72:                  
73:                  static volatile UINT16 Timer1, Timer2; /* 1000Hz decrement timer */
74:                  
75:                  static UINT16 CardType;
76:                  
77:                  /*-----------------------------------------------------------------------*/
78:                  /* Exchange a byte between PIC and MMC via SPI  (Platform dependent)     */
79:                  /*-----------------------------------------------------------------------*/
80:                  
81:                  #define xmit_spi(dat) 	writeSPI(dat)
82:                  #define rcvr_spi()	writeSPI(0xFF)
83:                  #define rcvr_spi_m(p)	SPI2BUF = 0xFF; while (!SPI2STATbits.SPIRBF); *(p) = (PF_BYTE)SPI2BUF;
84:                  #define xchg_spi (dat)  writeSPI(dat)
85:                  #define DLY_US(i)	delay_us(i)
86:                  #define CS_H()		(PORTB|=SDCSEL)//digitalwrite(SDCS, HIGH)
87:                  #define CS_L()		(PORTB&=~SDCSEL)//digitalwrite(SDCS, LOW)
88:                  
89:                  /*-----------------------------------------------------------------------*/
90:                  /* Wait for card ready                                                   */
91:                  /*-----------------------------------------------------------------------*/
92:                  
93:                  static
94:                  int wait_ready(void) {
9D0067AC  27BDFFE0   ADDIU SP, SP, -32
9D0067B0  AFBF001C   SW RA, 28(SP)
9D0067B4  AFB10018   SW S1, 24(SP)
9D0067B8  AFB00014   SW S0, 20(SP)
9D0067BC  24111388   ADDIU S1, ZERO, 5000
95:                  	PF_BYTE d;
96:                  	UINT16 tmr;
97:                  
98:                  	for (tmr = 5000; tmr; tmr--) { /* Wait for ready in timeout of 500ms */
9D0067E8  1620FFF5   BNE S1, ZERO, 0x9D0067C0
9D0067EC  3A0200FF   XORI V0, S0, 255
99:                  		d = rcvr_spi();
9D0067C0  0F4020B7   JAL writeSPI
9D0067C4  240400FF   ADDIU A0, ZERO, 255
9D0067C8  00408021   ADDU S0, V0, ZERO
100:                 		if (d == 0xFF)
9D0067CC  240200FF   ADDIU V0, ZERO, 255
9D0067D0  12020007   BEQ S0, V0, 0x9D0067F0
9D0067D4  3A0200FF   XORI V0, S0, 255
101:                 			break;
102:                 		DLY_US(100);
9D0067D8  0F402465   JAL delay_us
9D0067DC  24040064   ADDIU A0, ZERO, 100
9D0067E0  2631FFFF   ADDIU S1, S1, -1
9D0067E4  3231FFFF   ANDI S1, S1, -1
103:                 	}
104:                 
105:                 	return (d == 0xFF) ? 1 : 0;
106:                 }
9D0067F0  2C420001   SLTIU V0, V0, 1
9D0067F4  8FBF001C   LW RA, 28(SP)
9D0067F8  8FB10018   LW S1, 24(SP)
9D0067FC  8FB00014   LW S0, 20(SP)
9D006800  03E00008   JR RA
9D006804  27BD0020   ADDIU SP, SP, 32
107:                 
108:                 /*-----------------------------------------------------------------------*/
109:                 /* Deselect the card and release SPI bus                                 */
110:                 /*-----------------------------------------------------------------------*/
111:                 
112:                 #define deselect() disableSD();
113:                 
114:                 /*-----------------------------------------------------------------------*/
115:                 /* Select the card and wait ready                                        */
116:                 /*-----------------------------------------------------------------------*/
117:                 
118:                 static int select(void) /* 1:Successful, 0:Timeout */
119:                 {
9D006808  27BDFFE8   ADDIU SP, SP, -24
9D00680C  AFBF0014   SW RA, 20(SP)
120:                 	enableSD();
9D006810  0F4020DE   JAL enableSD
9D006814  00000000   NOP
121:                 	rcvr_spi(); /* Dummy clock (force DO enabled) */
9D006818  0F4020B7   JAL writeSPI
9D00681C  240400FF   ADDIU A0, ZERO, 255
122:                 
123:                 	if (wait_ready())
9D006820  0F4019EB   JAL 0x9D0067AC
9D006824  00000000   NOP
9D006828  14400004   BNE V0, ZERO, 0x9D00683C
9D00682C  24030001   ADDIU V1, ZERO, 1
124:                 		return 1; /* OK */
125:                 	deselect();
9D006830  0F4020D3   JAL disableSD
9D006834  00000000   NOP
126:                 	return 0; /* Timeout */
9D006838  00001821   ADDU V1, ZERO, ZERO
127:                 }
9D00683C  00601021   ADDU V0, V1, ZERO
9D006840  8FBF0014   LW RA, 20(SP)
9D006844  03E00008   JR RA
9D006848  27BD0018   ADDIU SP, SP, 24
128:                 
129:                 /*-----------------------------------------------------------------------*/
130:                 /* Receive a data packet from MMC                                        */
131:                 /*-----------------------------------------------------------------------*/
132:                 
133:                 static int rcvr_datablock( /* 1:OK, 0:Failed */
9D006AD0  0B401A95   J 0x9D006A54
9D006AD4  26310004   ADDIU S1, S1, 4
134:                                           PF_BYTE *buff, /* Data buffer to store received data */
135:                                           UINT16 btr /* Byte count (must be multiple of 4) */
136:                                           ) {
9D0069EC  27BDFFE0   ADDIU SP, SP, -32
9D0069F0  AFBF001C   SW RA, 28(SP)
9D0069F4  AFB20018   SW S2, 24(SP)
9D0069F8  AFB10014   SW S1, 20(SP)
9D0069FC  AFB00010   SW S0, 16(SP)
9D006A00  00808821   ADDU S1, A0, ZERO
9D006A04  00A09021   ADDU S2, A1, ZERO
9D006A08  241003E8   ADDIU S0, ZERO, 1000
137:                 	PF_BYTE d;
138:                 	UINT16 tmr;
139:                 
140:                 	for (tmr = 1000; tmr; tmr--) { /* Wait for data packet in timeout of 100ms */
9D006A30  1600FFF6   BNE S0, ZERO, 0x9D006A0C
9D006A34  00001821   ADDU V1, ZERO, ZERO
141:                 		d = rcvr_spi();
9D006A0C  0F4020B7   JAL writeSPI
9D006A10  240400FF   ADDIU A0, ZERO, 255
142:                 		if (d != 0xFF)
9D006A14  240300FF   ADDIU V1, ZERO, 255
9D006A18  14430009   BNE V0, V1, 0x9D006A40
9D006A1C  240400FE   ADDIU A0, ZERO, 254
143:                 			break;
144:                 		DLY_US(100);
9D006A20  0F402465   JAL delay_us
9D006A24  24040064   ADDIU A0, ZERO, 100
9D006A28  2610FFFF   ADDIU S0, S0, -1
9D006A2C  3210FFFF   ANDI S0, S0, -1
145:                 	}
146:                 	if (d != 0xFE)
9D006A40  1444002A   BNE V0, A0, 0x9D006AEC
9D006A44  00001821   ADDU V1, ZERO, ZERO
147:                 		return 0; /* If not valid data token, return with error */
148:                 
149:                 	do { /* Receive the data block into buffer */
150:                 		rcvr_spi_m(buff++);
9D006A48  3C04BF80   LUI A0, -16512
9D006A4C  240500FF   ADDIU A1, ZERO, 255
9D006A50  3C02BF80   LUI V0, -16512
9D006A54  AC855A20   SW A1, 23072(A0)
9D006A58  8C435A10   LW V1, 23056(V0)
9D006A5C  30630001   ANDI V1, V1, 1
9D006A60  1060FFFD   BEQ V1, ZERO, 0x9D006A58
9D006A64  00000000   NOP
9D006A68  8C835A20   LW V1, 23072(A0)
9D006A6C  A2230000   SB V1, 0(S1)
151:                 		rcvr_spi_m(buff++);
9D006A70  AC855A20   SW A1, 23072(A0)
9D006A74  8C435A10   LW V1, 23056(V0)
9D006A78  30630001   ANDI V1, V1, 1
9D006A7C  1060FFFD   BEQ V1, ZERO, 0x9D006A74
9D006A80  00000000   NOP
9D006A84  8C835A20   LW V1, 23072(A0)
9D006A88  A2230001   SB V1, 1(S1)
152:                 		rcvr_spi_m(buff++);
9D006A8C  AC855A20   SW A1, 23072(A0)
9D006A90  8C435A10   LW V1, 23056(V0)
9D006A94  30630001   ANDI V1, V1, 1
9D006A98  1060FFFD   BEQ V1, ZERO, 0x9D006A90
9D006A9C  00000000   NOP
9D006AA0  8C835A20   LW V1, 23072(A0)
9D006AA4  A2230002   SB V1, 2(S1)
153:                 		rcvr_spi_m(buff++);
9D006AA8  AC855A20   SW A1, 23072(A0)
9D006AAC  8C435A10   LW V1, 23056(V0)
9D006AB0  30630001   ANDI V1, V1, 1
9D006AB4  1060FFFD   BEQ V1, ZERO, 0x9D006AAC
9D006AB8  00000000   NOP
9D006ABC  8C835A20   LW V1, 23072(A0)
154:                 	} while (btr -= 4);
9D006AC0  2652FFFC   ADDIU S2, S2, -4
9D006AC4  3252FFFF   ANDI S2, S2, -1
9D006AC8  12400003   BEQ S2, ZERO, 0x9D006AD8
9D006ACC  A2230003   SB V1, 3(S1)
155:                 	rcvr_spi(); /* Discard CRC */
9D006AD8  0F4020B7   JAL writeSPI
9D006ADC  240400FF   ADDIU A0, ZERO, 255
156:                 	rcvr_spi();
9D006AE0  0F4020B7   JAL writeSPI
9D006AE4  240400FF   ADDIU A0, ZERO, 255
157:                 
158:                 	return 1; /* Return with success */
9D006AE8  24030001   ADDIU V1, ZERO, 1
159:                 }
9D006A38  0B401ABC   J 0x9D006AF0
9D006A3C  00601021   ADDU V0, V1, ZERO
9D006AEC  00601021   ADDU V0, V1, ZERO
9D006AF0  8FBF001C   LW RA, 28(SP)
9D006AF4  8FB20018   LW S2, 24(SP)
9D006AF8  8FB10014   LW S1, 20(SP)
9D006AFC  8FB00010   LW S0, 16(SP)
9D006B00  03E00008   JR RA
9D006B04  27BD0020   ADDIU SP, SP, 32
160:                 
161:                 /*-----------------------------------------------------------------------*/
162:                 /* Send a data packet to MMC                                             */
163:                 /*-----------------------------------------------------------------------*/
164:                 
165:                 #if _READONLY == 0
166:                 static int xmit_datablock( /* 1:OK, 0:Failed */
9D006990  26110200   ADDIU S1, S0, 512
9D0069CC  38630005   XORI V1, V1, 5
9D0069D0  2C630001   SLTIU V1, V1, 1
167:                                           const PF_BYTE *buff, /* 512 byte data block to be transmitted */
168:                                           PF_BYTE token /* Data token */
169:                                           ) {
9D006958  27BDFFE0   ADDIU SP, SP, -32
9D00695C  AFBF001C   SW RA, 28(SP)
9D006960  AFB10018   SW S1, 24(SP)
9D006964  AFB00014   SW S0, 20(SP)
9D006968  00808021   ADDU S0, A0, ZERO
170:                 	PF_BYTE resp;
171:                 	UINT16 bc = BLK_SIZE;
172:                 
173:                 	if (!wait_ready())
9D00696C  0F4019EB   JAL 0x9D0067AC
9D006970  00A08821   ADDU S1, A1, ZERO
9D006974  10400017   BEQ V0, ZERO, 0x9D0069D4
9D006978  00001821   ADDU V1, ZERO, ZERO
174:                 		return 0;
175:                 
176:                 	xmit_spi(token); /* Xmit a token */
9D00697C  0F4020B7   JAL writeSPI
9D006980  02202021   ADDU A0, S1, ZERO
177:                 	if (token != 0xFD) { /* Not StopTran token */
9D006984  240200FD   ADDIU V0, ZERO, 253
9D006988  12220012   BEQ S1, V0, 0x9D0069D4
9D00698C  24030001   ADDIU V1, ZERO, 1
178:                 		do { /* Xmit the 512 byte data block to the MMC */
179:                 			xmit_spi(*buff++);
9D006994  0F4020B7   JAL writeSPI
9D006998  92040000   LBU A0, 0(S0)
180:                 			xmit_spi(*buff++);
9D00699C  92040001   LBU A0, 1(S0)
9D0069A0  0F4020B7   JAL writeSPI
9D0069A4  26100002   ADDIU S0, S0, 2
181:                 		} while (bc -= 2);
9D0069A8  1630FFFA   BNE S1, S0, 0x9D006994
9D0069AC  00000000   NOP
182:                 		xmit_spi(0xFF); /* CRC (Dummy) */
9D0069B0  0F4020B7   JAL writeSPI
9D0069B4  240400FF   ADDIU A0, ZERO, 255
183:                 		xmit_spi(0xFF);
9D0069B8  0F4020B7   JAL writeSPI
9D0069BC  240400FF   ADDIU A0, ZERO, 255
184:                 		resp = rcvr_spi(); /* Receive a data response */
9D0069C0  0F4020B7   JAL writeSPI
9D0069C4  240400FF   ADDIU A0, ZERO, 255
185:                 		if ((resp & 0x1F) != 0x05) /* If not accepted, return with error */
9D0069C8  3043001F   ANDI V1, V0, 31
186:                 			return 0;
187:                 	}
188:                 
189:                 	return 1;
190:                 }
9D0069D4  00601021   ADDU V0, V1, ZERO
9D0069D8  8FBF001C   LW RA, 28(SP)
9D0069DC  8FB10018   LW S1, 24(SP)
9D0069E0  8FB00014   LW S0, 20(SP)
9D0069E4  03E00008   JR RA
9D0069E8  27BD0020   ADDIU SP, SP, 32
191:                 #endif	/* _READONLY */
192:                 
193:                 /*-----------------------------------------------------------------------*/
194:                 /* Send a command packet to MMC                                          */
195:                 /*-----------------------------------------------------------------------*/
196:                 
197:                 static PF_BYTE send_cmd(PF_BYTE cmd, /* Command byte */
198:                                         DWORD arg /* Argument */
199:                                         ) {
9D00684C  27BDFFE0   ADDIU SP, SP, -32
9D006850  AFBF001C   SW RA, 28(SP)
9D006854  AFB10018   SW S1, 24(SP)
9D006858  AFB00014   SW S0, 20(SP)
9D00685C  00A08821   ADDU S1, A1, ZERO
9D0068F8  2410000A   ADDIU S0, ZERO, 10
9D006940  0B401A3F   J 0x9D0068FC
9D006944  2410000A   ADDIU S0, ZERO, 10
9D006950  0B401A3F   J 0x9D0068FC
9D006954  2410000A   ADDIU S0, ZERO, 10
200:                 	PF_BYTE n, res;
201:                 
202:                 	if (cmd & 0x80) { /* ACMD<n> is the command sequense of CMD55-CMD<n> */
9D006860  7C041420   SEB V0, A0
9D006864  04410009   BGEZ V0, 0x9D00688C
9D006868  00808021   ADDU S0, A0, ZERO
203:                 		cmd &= 0x7F;
9D006888  3210007F   ANDI S0, S0, 127
204:                 		res = send_cmd(CMD55, 0);
9D00686C  24040037   ADDIU A0, ZERO, 55
9D006870  0F401A13   JAL 0x9D00684C
9D006874  00002821   ADDU A1, ZERO, ZERO
9D006878  00401821   ADDU V1, V0, ZERO
205:                 		if (res > 1)
9D00687C  2C420002   SLTIU V0, V0, 2
9D006880  10400028   BEQ V0, ZERO, 0x9D006924
9D006884  00601021   ADDU V0, V1, ZERO
206:                 			return res;
207:                 	}
208:                 
209:                 	/* Select the card and wait for ready */
210:                 	deselect();
9D00688C  0F4020D3   JAL disableSD
9D006890  00000000   NOP
211:                 	if (!select())
9D006894  0F401A02   JAL 0x9D006808
9D006898  00000000   NOP
9D00689C  10400020   BEQ V0, ZERO, 0x9D006920
9D0068A0  240300FF   ADDIU V1, ZERO, 255
212:                 		return 0xFF;
213:                 
214:                 	/* Send command packet */
215:                 	xmit_spi(0x40 | cmd); /* Start + Command index */
9D0068A4  0F4020B7   JAL writeSPI
9D0068A8  36040040   ORI A0, S0, 64
216:                 	xmit_spi((PF_BYTE)(arg >> 24)); /* Argument[31..24] */
9D0068AC  0F4020B7   JAL writeSPI
9D0068B0  00112602   SRL A0, S1, 24
217:                 	xmit_spi((PF_BYTE)(arg >> 16)); /* Argument[23..16] */
9D0068B4  0F4020B7   JAL writeSPI
9D0068B8  7E243C00   EXT A0, S1, 16, 8
218:                 	xmit_spi((PF_BYTE)(arg >> 8)); /* Argument[15..8] */
9D0068BC  0F4020B7   JAL writeSPI
9D0068C0  7E243A00   EXT A0, S1, 8, 8
219:                 	xmit_spi((PF_BYTE)arg); /* Argument[7..0] */
9D0068C4  0F4020B7   JAL writeSPI
9D0068C8  322400FF   ANDI A0, S1, 255
220:                 	n = 0x01; /* Dummy CRC + Stop */
221:                 	if (cmd == CMD0)
9D0068CC  1200001E   BEQ S0, ZERO, 0x9D006948
9D0068D0  24020008   ADDIU V0, ZERO, 8
222:                 		n = 0x95; /* Valid CRC for CMD0(0) */
223:                 	if (cmd == CMD8)
9D0068D4  12020018   BEQ S0, V0, 0x9D006938
9D0068D8  00000000   NOP
224:                 		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
225:                 	xmit_spi(n);
9D0068DC  0F4020B7   JAL writeSPI
9D0068E0  24040001   ADDIU A0, ZERO, 1
9D006938  0F4020B7   JAL writeSPI
9D00693C  24040087   ADDIU A0, ZERO, 135
9D006948  0F4020B7   JAL writeSPI
9D00694C  24040095   ADDIU A0, ZERO, 149
226:                 
227:                 	/* Receive command response */
228:                 	if (cmd == CMD12)
9D0068E4  2402000C   ADDIU V0, ZERO, 12
9D0068E8  16020004   BNE S0, V0, 0x9D0068FC
9D0068EC  2410000A   ADDIU S0, ZERO, 10
229:                 		rcvr_spi(); /* Skip a stuff byte when stop reading */
9D0068F0  0F4020B7   JAL writeSPI
9D0068F4  240400FF   ADDIU A0, ZERO, 255
230:                 	n = 10; /* Wait for a valid response in timeout of 10 attempts */
231:                 	do
232:                 		res = rcvr_spi();
9D0068FC  0F4020B7   JAL writeSPI
9D006900  240400FF   ADDIU A0, ZERO, 255
9D006904  00401821   ADDU V1, V0, ZERO
233:                 	while ((res & 0x80) && --n);
9D006908  7C021420   SEB V0, V0
9D00690C  04410004   BGEZ V0, 0x9D006920
9D006910  2610FFFF   ADDIU S0, S0, -1
9D006914  321000FF   ANDI S0, S0, 255
9D006918  1600FFF8   BNE S0, ZERO, 0x9D0068FC
9D00691C  00000000   NOP
234:                 
235:                 	return res; /* Return with the response value */
236:                 }
9D006920  00601021   ADDU V0, V1, ZERO
9D006924  8FBF001C   LW RA, 28(SP)
9D006928  8FB10018   LW S1, 24(SP)
9D00692C  8FB00014   LW S0, 20(SP)
9D006930  03E00008   JR RA
9D006934  27BD0020   ADDIU SP, SP, 32
237:                 
238:                 /*--------------------------------------------------------------------------
239:                 
240:                  Public Functions
241:                 
242:                  ---------------------------------------------------------------------------*/
243:                 
244:                 /*-----------------------------------------------------------------------*/
245:                 /* Initialize Disk Drive                                                 */
246:                 /*-----------------------------------------------------------------------*/
247:                 
248:                 DSTATUS disk_initialize(PF_BYTE drv /* Physical drive number (0) */
9D006BB8  27B10014   ADDIU S1, SP, 20
9D006C54  27A40010   ADDIU A0, SP, 16
9D006C58  00901821   ADDU V1, A0, S0
249:                                         ) {
9D006B08  27BDFFD8   ADDIU SP, SP, -40
9D006B0C  AFBF0024   SW RA, 36(SP)
9D006B10  AFB10020   SW S1, 32(SP)
9D006B14  AFB0001C   SW S0, 28(SP)
9D006B18  308400FF   ANDI A0, A0, 255
250:                 	PF_BYTE n, ty, cmd, buf[4];
251:                 	UINT16 tmr;
252:                 	DSTATUS s = 0;
253:                 	if (drv)
9D006B1C  14800084   BNE A0, ZERO, 0x9D006D30
9D006B20  24020001   ADDIU V0, ZERO, 1
254:                 		return STA_NOINIT; /* Supports only single drive */
255:                 	if (Stat & STA_NODISK)
9D006B24  93828010   LBU V0, -32752(GP)
9D006B28  30420002   ANDI V0, V0, 2
9D006B2C  10400004   BEQ V0, ZERO, 0x9D006B40
9D006B30  00000000   NOP
256:                 		return Stat; /* No card in the socket */
9D006B34  93828010   LBU V0, -32752(GP)
9D006B38  0B401B4C   J 0x9D006D30
9D006B3C  304200FF   ANDI V0, V0, 255
257:                 
258:                 	deselect(); /* Force socket power on */
9D006B40  0F4020D3   JAL disableSD
9D006B44  2410000A   ADDIU S0, ZERO, 10
259:                 	//FCLK_SLOW();
260:                 	for (n = 10; n; n--)
9D006B58  1600FFFB   BNE S0, ZERO, 0x9D006B48
9D006B5C  3C02BF88   LUI V0, -16504
261:                 		rcvr_spi(); /* 80 dummy clocks */
9D006B48  0F4020B7   JAL writeSPI
9D006B4C  240400FF   ADDIU A0, ZERO, 255
9D006B50  2610FFFF   ADDIU S0, S0, -1
9D006B54  321000FF   ANDI S0, S0, 255
262:                 	CS_H();
9D006B60  8C436120   LW V1, 24864(V0)
9D006B64  34630004   ORI V1, V1, 4
9D006B68  AC436120   SW V1, 24864(V0)
9D006B6C  2410000A   ADDIU S0, ZERO, 10
263:                 	for (n = 10; n; n--)
9D006B80  1600FFFB   BNE S0, ZERO, 0x9D006B70
9D006B84  00002021   ADDU A0, ZERO, ZERO
264:                 		rcvr_spi(); /* 80 dummy clocks */
9D006B70  0F4020B7   JAL writeSPI
9D006B74  240400FF   ADDIU A0, ZERO, 255
9D006B78  2610FFFF   ADDIU S0, S0, -1
9D006B7C  321000FF   ANDI S0, S0, 255
265:                 
266:                 	ty = 0;
267:                 	if (send_cmd(CMD0, 0) == 1) { /* Enter Idle state */
9D006B88  0F401A13   JAL 0x9D00684C
9D006B8C  00002821   ADDU A1, ZERO, ZERO
9D006B90  24030001   ADDIU V1, ZERO, 1
9D006B94  5443006B   BNEL V0, V1, 0x9D006D44
9D006B98  A7808030   SH ZERO, -32720(GP)
268:                 		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2? */
9D006B9C  24040008   ADDIU A0, ZERO, 8
9D006BA0  0F401A13   JAL 0x9D00684C
9D006BA4  240501AA   ADDIU A1, ZERO, 426
9D006BA8  24030001   ADDIU V1, ZERO, 1
9D006BAC  14430035   BNE V0, V1, 0x9D006C84
9D006BB0  240400A9   ADDIU A0, ZERO, 169
9D006BB4  27B00010   ADDIU S0, SP, 16
269:                 			for (n = 0; n < 4; n++)
9D006BCC  1611FFFB   BNE S0, S1, 0x9D006BBC
9D006BD0  93A30012   LBU V1, 18(SP)
270:                 				buf[n] = rcvr_spi(); /* Get trailing return value of R7 resp */
9D006BBC  0F4020B7   JAL writeSPI
9D006BC0  240400FF   ADDIU A0, ZERO, 255
9D006BC4  A2020000   SB V0, 0(S0)
9D006BC8  26100001   ADDIU S0, S0, 1
271:                 			if (buf[2] == 0x01 && buf[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
9D006BD4  24020001   ADDIU V0, ZERO, 1
9D006BD8  54620050   BNEL V1, V0, 0x9D006D1C
9D006BDC  A7808030   SH ZERO, -32720(GP)
9D006BE0  93A30013   LBU V1, 19(SP)
9D006BE4  240200AA   ADDIU V0, ZERO, 170
9D006BE8  54620056   BNEL V1, V0, 0x9D006D44
9D006BEC  A7808030   SH ZERO, -32720(GP)
9D006BF0  241003E8   ADDIU S0, ZERO, 1000
272:                 				for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state (ACMD41 with HCS bit) */
9D006C10  2610FFFF   ADDIU S0, S0, -1
9D006C14  3210FFFF   ANDI S0, S0, -1
9D006C18  1600FFF7   BNE S0, ZERO, 0x9D006BF8
9D006C1C  240400A9   ADDIU A0, ZERO, 169
273:                 					if (send_cmd(ACMD41, 1UL << 30) == 0)
9D006BF4  240400A9   ADDIU A0, ZERO, 169
9D006BF8  0F401A13   JAL 0x9D00684C
9D006BFC  3C054000   LUI A1, 16384
9D006C00  10400009   BEQ V0, ZERO, 0x9D006C28
9D006C04  00000000   NOP
274:                 						break;
275:                 					DLY_US(1000);
9D006C08  0F402465   JAL delay_us
9D006C0C  240403E8   ADDIU A0, ZERO, 1000
276:                 				}
277:                 				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
9D006C28  52000046   BEQL S0, ZERO, 0x9D006D44
9D006C2C  A7808030   SH ZERO, -32720(GP)
9D006C30  2404003A   ADDIU A0, ZERO, 58
9D006C34  0F401A13   JAL 0x9D00684C
9D006C38  00002821   ADDU A1, ZERO, ZERO
9D006C3C  54400041   BNEL V0, ZERO, 0x9D006D44
9D006C40  A7808030   SH ZERO, -32720(GP)
9D006C44  00008021   ADDU S0, ZERO, ZERO
278:                 					for (n = 0; n < 4; n++)
9D006C48  24110004   ADDIU S1, ZERO, 4
9D006C60  1611FFFA   BNE S0, S1, 0x9D006C4C
9D006C64  A0620000   SB V0, 0(V1)
279:                 						buf[n] = rcvr_spi();
9D006C4C  0F4020B7   JAL writeSPI
9D006C50  240400FF   ADDIU A0, ZERO, 255
9D006C5C  26100001   ADDIU S0, S0, 1
280:                 					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 */
9D006C68  93A40010   LBU A0, 16(SP)
9D006C6C  30840040   ANDI A0, A0, 64
9D006C70  24030004   ADDIU V1, ZERO, 4
9D006C74  2402000C   ADDIU V0, ZERO, 12
9D006C78  0064100A   MOVZ V0, V1, A0
281:                 				}
282:                 			}
283:                 		} else { /* SDv1 or MMCv3 */
284:                 			if (send_cmd(ACMD41, 0) <= 1) {
9D006C84  0F401A13   JAL 0x9D00684C
9D006C88  00002821   ADDU A1, ZERO, ZERO
9D006C8C  2C420002   SLTIU V0, V0, 2
285:                 				ty = CT_SD1;
9D006C90  24030002   ADDIU V1, ZERO, 2
9D006C94  24040001   ADDIU A0, ZERO, 1
9D006C98  00608821   ADDU S1, V1, ZERO
9D006C9C  0082880A   MOVZ S1, A0, V0
286:                 				cmd = ACMD41; /* SDv1 */
287:                 			} else {
288:                 				ty = CT_MMC;
289:                 				cmd = CMD1; /* MMCv3 */
290:                 			}
291:                 			for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state */
9D006CA0  241003E8   ADDIU S0, ZERO, 1000
9D006CC0  2610FFFF   ADDIU S0, S0, -1
9D006CC4  3210FFFF   ANDI S0, S0, -1
9D006CC8  1600FFF7   BNE S0, ZERO, 0x9D006CA8
9D006CCC  240400A9   ADDIU A0, ZERO, 169
292:                 				if (send_cmd(ACMD41, 0) == 0)
9D006CA4  240400A9   ADDIU A0, ZERO, 169
9D006CA8  0F401A13   JAL 0x9D00684C
9D006CAC  00002821   ADDU A1, ZERO, ZERO
9D006CB0  10400009   BEQ V0, ZERO, 0x9D006CD8
9D006CB4  00000000   NOP
293:                 					break;
294:                 				DLY_US(1000);
9D006CB8  0F402465   JAL delay_us
9D006CBC  240403E8   ADDIU A0, ZERO, 1000
295:                 			}
296:                 			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
9D006CD8  5200001A   BEQL S0, ZERO, 0x9D006D44
9D006CDC  A7808030   SH ZERO, -32720(GP)
9D006CE0  24040010   ADDIU A0, ZERO, 16
9D006CE4  0F401A13   JAL 0x9D00684C
9D006CE8  24050200   ADDIU A1, ZERO, 512
9D006CEC  54400015   BNEL V0, ZERO, 0x9D006D44
9D006CF0  A7808030   SH ZERO, -32720(GP)
297:                 				ty = 0;
298:                 		}
299:                 	}
300:                 	CardType = ty;
9D006C20  0B401B51   J 0x9D006D44
9D006C24  A7808030   SH ZERO, -32720(GP)
9D006C7C  0B401B40   J 0x9D006D00
9D006C80  A7828030   SH V0, -32720(GP)
9D006CD0  0B401B51   J 0x9D006D44
9D006CD4  A7808030   SH ZERO, -32720(GP)
9D006CF4  A7918030   SH S1, -32720(GP)
301:                 	if (ty) {/* Initialization succeded */
9D006CF8  12200008   BEQ S1, ZERO, 0x9D006D1C
9D006CFC  24020001   ADDIU V0, ZERO, 1
302:                 		s &= ~STA_NOINIT;
9D006D18  00001021   ADDU V0, ZERO, ZERO
303:                 		// 6. increase speed
304:                 		SPI2CON = 0; // disable the SPI2 module
9D006D00  3C02BF80   LUI V0, -16512
9D006D04  AC405A00   SW ZERO, 23040(V0)
305:                 		SPI2BRG = 0; // maximum possible baud rate = Fpb/2
9D006D08  3C03BF80   LUI V1, -16512
9D006D0C  AC605A30   SW ZERO, 23088(V1)
306:                 		SPI2CON = 0x8120; // re-enable the SPI2 module
9D006D10  34038120   ORI V1, ZERO, -32480
9D006D14  AC435A00   SW V1, 23040(V0)
307:                 	} else {
308:                 		/* Initialization failed */
309:                 		s |= STA_NOINIT;
9D006D44  0B401B47   J 0x9D006D1C
9D006D48  24020001   ADDIU V0, ZERO, 1
310:                 	}
311:                 	Stat = s;
9D006D1C  A3828010   SB V0, -32752(GP)
312:                 
313:                 	deselect();
9D006D20  0F4020D3   JAL disableSD
9D006D24  00000000   NOP
314:                 
315:                 	return Stat;
9D006D28  93828010   LBU V0, -32752(GP)
9D006D2C  304200FF   ANDI V0, V0, 255
316:                 }
9D006D30  8FBF0024   LW RA, 36(SP)
9D006D34  8FB10020   LW S1, 32(SP)
9D006D38  8FB0001C   LW S0, 28(SP)
9D006D3C  03E00008   JR RA
9D006D40  27BD0028   ADDIU SP, SP, 40
317:                 
318:                 /*-----------------------------------------------------------------------*/
319:                 /* Get Disk Status                                                       */
320:                 /*-----------------------------------------------------------------------*/
321:                 
322:                 DSTATUS disk_status(PF_BYTE drv /* Physical drive number (0) */
323:                 ) {
9D006D4C  308400FF   ANDI A0, A0, 255
324:                 	if (drv)
9D006D50  14800003   BNE A0, ZERO, 0x9D006D60
9D006D54  24020001   ADDIU V0, ZERO, 1
325:                 		return STA_NOINIT; /* Supports only single drive */
326:                 	return Stat;
9D006D58  93828010   LBU V0, -32752(GP)
9D006D5C  304200FF   ANDI V0, V0, 255
327:                 }
9D006D60  03E00008   JR RA
9D006D64  00000000   NOP
328:                 
329:                 /*-----------------------------------------------------------------------*/
330:                 /* Read Sector(s)                                                        */
331:                 /*-----------------------------------------------------------------------*/
332:                 
333:                 DRESULT disk_read(PF_BYTE drv, /* Physical drive nmuber (0) */
334:                                   PF_BYTE *buff, /* Pointer to the data buffer to store read data */
335:                                   DWORD sector, /* Start sector number (LBA) */
336:                                   PF_BYTE count /* Sector count (1..255) */
337:                                   ) {
9D006D68  27BDFFE0   ADDIU SP, SP, -32
9D006D6C  AFBF001C   SW RA, 28(SP)
9D006D70  AFB10018   SW S1, 24(SP)
9D006D74  AFB00014   SW S0, 20(SP)
9D006D78  00A08821   ADDU S1, A1, ZERO
9D006D7C  308400FF   ANDI A0, A0, 255
9D006D80  30F000FF   ANDI S0, A3, 255
338:                 	if (drv || !count)
9D006D84  14800029   BNE A0, ZERO, 0x9D006E2C
9D006D88  24020004   ADDIU V0, ZERO, 4
9D006D8C  52000028   BEQL S0, ZERO, 0x9D006E30
9D006D90  8FBF001C   LW RA, 28(SP)
339:                 		return RES_PARERR;
340:                 	if (Stat & STA_NOINIT)
9D006D94  93838010   LBU V1, -32752(GP)
9D006D98  30630001   ANDI V1, V1, 1
9D006D9C  14600023   BNE V1, ZERO, 0x9D006E2C
9D006DA0  24020003   ADDIU V0, ZERO, 3
341:                 		return RES_NOTRDY;
342:                 
343:                 	if (!(CardType & CT_BLOCK))
9D006DA4  97838030   LHU V1, -32720(GP)
9D006DA8  30630008   ANDI V1, V1, 8
344:                 		sector *= BLK_SIZE; /* Convert to byte address if needed */
9D006DAC  00061240   SLL V0, A2, 9
9D006DB0  0043300A   MOVZ A2, V0, V1
345:                 
346:                 	if (count == 1) { /* Single block read */
9D006DB4  24020001   ADDIU V0, ZERO, 1
9D006DB8  1602000A   BNE S0, V0, 0x9D006DE4
9D006DBC  24040012   ADDIU A0, ZERO, 18
347:                 		if ((send_cmd(CMD17, sector) == 0) /* READ_SINGLE_BLOCK */
9D006DC0  24040011   ADDIU A0, ZERO, 17
9D006DC4  0F401A13   JAL 0x9D00684C
9D006DC8  00C02821   ADDU A1, A2, ZERO
9D006DCC  14400014   BNE V0, ZERO, 0x9D006E20
9D006DD0  02202021   ADDU A0, S1, ZERO
348:                 		&& rcvr_datablock(buff, BLK_SIZE))
9D006DD4  0F401A7B   JAL 0x9D0069EC
9D006DD8  24050200   ADDIU A1, ZERO, 512
349:                 			count = 0;
9D006DDC  0B401B88   J 0x9D006E20
9D006DE0  0002800B   MOVN S0, ZERO, V0
350:                 	} else { /* Multiple block read */
351:                 		if (send_cmd(CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
9D006DE4  0F401A13   JAL 0x9D00684C
9D006DE8  00C02821   ADDU A1, A2, ZERO
9D006DEC  1440000C   BNE V0, ZERO, 0x9D006E20
9D006DF0  00000000   NOP
352:                 			do {
353:                 				if (!rcvr_datablock(buff, BLK_SIZE))
9D006DF4  02202021   ADDU A0, S1, ZERO
9D006DF8  0F401A7B   JAL 0x9D0069EC
9D006DFC  24050200   ADDIU A1, ZERO, 512
9D006E00  10400005   BEQ V0, ZERO, 0x9D006E18
9D006E04  2404000C   ADDIU A0, ZERO, 12
354:                 					break;
355:                 				buff += BLK_SIZE;
356:                 			} while (--count);
9D006E08  2610FFFF   ADDIU S0, S0, -1
9D006E0C  321000FF   ANDI S0, S0, 255
9D006E10  1600FFF8   BNE S0, ZERO, 0x9D006DF4
9D006E14  26310200   ADDIU S1, S1, 512
357:                 			send_cmd(CMD12, 0); /* STOP_TRANSMISSION */
9D006E18  0F401A13   JAL 0x9D00684C
9D006E1C  00002821   ADDU A1, ZERO, ZERO
358:                 		}
359:                 	}
360:                 	deselect();
9D006E20  0F4020D3   JAL disableSD
9D006E24  00000000   NOP
361:                 
362:                 	return count ? RES_ERROR : RES_OK;
9D006E28  0010102B   SLTU V0, ZERO, S0
363:                 }
9D006E2C  8FBF001C   LW RA, 28(SP)
9D006E30  8FB10018   LW S1, 24(SP)
9D006E34  8FB00014   LW S0, 20(SP)
9D006E38  03E00008   JR RA
9D006E3C  27BD0020   ADDIU SP, SP, 32
364:                 
365:                 /*-----------------------------------------------------------------------*/
366:                 /* Write Sector(s)                                                       */
367:                 /*-----------------------------------------------------------------------*/
368:                 
369:                 #if _READONLY == 0
370:                 DRESULT disk_write(PF_BYTE drv, /* Physical drive number (0) */
371:                                    const PF_BYTE *buff, /* Pointer to the data to be written */
372:                                    DWORD sector, /* Start sector number (LBA) */
373:                                    PF_BYTE count /* Sector count (1..255) */
374:                                    ) {
9D006E40  27BDFFE0   ADDIU SP, SP, -32
9D006E44  AFBF001C   SW RA, 28(SP)
9D006E48  AFB20018   SW S2, 24(SP)
9D006E4C  AFB10014   SW S1, 20(SP)
9D006E50  AFB00010   SW S0, 16(SP)
9D006E54  00A08821   ADDU S1, A1, ZERO
9D006E58  00C08021   ADDU S0, A2, ZERO
9D006E5C  308400FF   ANDI A0, A0, 255
9D006E60  30F200FF   ANDI S2, A3, 255
375:                 	if (drv || !count)
9D006E64  14800035   BNE A0, ZERO, 0x9D006F3C
9D006E68  24020004   ADDIU V0, ZERO, 4
9D006E6C  52400034   BEQL S2, ZERO, 0x9D006F40
9D006E70  8FBF001C   LW RA, 28(SP)
376:                 		return RES_PARERR;
377:                 	if (Stat & STA_NOINIT)
9D006E74  93838010   LBU V1, -32752(GP)
9D006E78  30630001   ANDI V1, V1, 1
9D006E7C  1460002F   BNE V1, ZERO, 0x9D006F3C
9D006E80  24020003   ADDIU V0, ZERO, 3
378:                 		return RES_NOTRDY;
379:                 	if (Stat & STA_PROTECT)
9D006E84  93838010   LBU V1, -32752(GP)
9D006E88  30630004   ANDI V1, V1, 4
9D006E8C  1460002B   BNE V1, ZERO, 0x9D006F3C
9D006E90  24020002   ADDIU V0, ZERO, 2
380:                 		return RES_WRPRT;
381:                 
382:                 	if (!(CardType & CT_BLOCK))
9D006E94  97828030   LHU V0, -32720(GP)
9D006E98  30440008   ANDI A0, V0, 8
383:                 		sector *= 512; /* Convert to byte address if needed */
9D006E9C  00061A40   SLL V1, A2, 9
9D006EA0  0064800A   MOVZ S0, V1, A0
384:                 
385:                 	if (count == 1) { /* Single block write */
9D006EA4  24030001   ADDIU V1, ZERO, 1
9D006EA8  1643000A   BNE S2, V1, 0x9D006ED4
9D006EAC  30420006   ANDI V0, V0, 6
386:                 		if ((send_cmd(CMD24, sector) == 0) /* WRITE_BLOCK */
9D006EB0  24040018   ADDIU A0, ZERO, 24
9D006EB4  0F401A13   JAL 0x9D00684C
9D006EB8  02002821   ADDU A1, S0, ZERO
9D006EBC  1440001C   BNE V0, ZERO, 0x9D006F30
9D006EC0  02202021   ADDU A0, S1, ZERO
387:                 		&& xmit_datablock(buff, 0xFE))
9D006EC4  0F401A56   JAL 0x9D006958
9D006EC8  240500FE   ADDIU A1, ZERO, 254
388:                 			count = 0;
9D006ECC  0B401BCC   J 0x9D006F30
9D006ED0  0002900B   MOVN S2, ZERO, V0
389:                 	} else { /* Multiple block write */
390:                 		if (CardType & CT_SDC)
9D006ED4  10400005   BEQ V0, ZERO, 0x9D006EEC
9D006ED8  24040019   ADDIU A0, ZERO, 25
391:                 			send_cmd(ACMD23, count);
9D006EDC  24040097   ADDIU A0, ZERO, 151
9D006EE0  0F401A13   JAL 0x9D00684C
9D006EE4  02402821   ADDU A1, S2, ZERO
392:                 		if (send_cmd(CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
9D006EE8  24040019   ADDIU A0, ZERO, 25
9D006EEC  0F401A13   JAL 0x9D00684C
9D006EF0  02002821   ADDU A1, S0, ZERO
9D006EF4  1440000E   BNE V0, ZERO, 0x9D006F30
9D006EF8  00000000   NOP
393:                 			do {
394:                 				if (!xmit_datablock(buff, 0xFC))
9D006EFC  02202021   ADDU A0, S1, ZERO
9D006F00  0F401A56   JAL 0x9D006958
9D006F04  240500FC   ADDIU A1, ZERO, 252
9D006F08  10400005   BEQ V0, ZERO, 0x9D006F20
9D006F0C  00002021   ADDU A0, ZERO, ZERO
395:                 					break;
396:                 				buff += 512;
397:                 			} while (--count);
9D006F10  2652FFFF   ADDIU S2, S2, -1
9D006F14  325200FF   ANDI S2, S2, 255
9D006F18  1640FFF8   BNE S2, ZERO, 0x9D006EFC
9D006F1C  26310200   ADDIU S1, S1, 512
398:                 			if (!xmit_datablock(0, 0xFD)) /* STOP_TRAN token */
9D006F20  0F401A56   JAL 0x9D006958
9D006F24  240500FD   ADDIU A1, ZERO, 253
399:                 				count = 1;
9D006F28  24030001   ADDIU V1, ZERO, 1
9D006F2C  0062900A   MOVZ S2, V1, V0
400:                 		}
401:                 	}
402:                 	deselect();
9D006F30  0F4020D3   JAL disableSD
9D006F34  00000000   NOP
403:                 
404:                 	return count ? RES_ERROR : RES_OK;
9D006F38  0012102B   SLTU V0, ZERO, S2
405:                 }
9D006F3C  8FBF001C   LW RA, 28(SP)
9D006F40  8FB20018   LW S2, 24(SP)
9D006F44  8FB10014   LW S1, 20(SP)
9D006F48  8FB00010   LW S0, 16(SP)
9D006F4C  03E00008   JR RA
9D006F50  27BD0020   ADDIU SP, SP, 32
406:                 #endif /* _READONLY */
407:                 
408:                 /*-----------------------------------------------------------------------*/
409:                 /* Miscellaneous Functions                                               */
410:                 /*-----------------------------------------------------------------------*/
411:                 
412:                 DRESULT disk_ioctl(PF_BYTE drv, /* Physical drive number (0) */
9D007258  26300004   ADDIU S0, S1, 4
413:                                    PF_BYTE ctrl, /* Control code */
414:                                    void *buff /* Buffer to send/receive data block */
415:                                    ) {
9D006F54  27BDFFD0   ADDIU SP, SP, -48
9D006F58  AFBF002C   SW RA, 44(SP)
9D006F5C  AFB20028   SW S2, 40(SP)
9D006F60  AFB10024   SW S1, 36(SP)
9D006F64  AFB00020   SW S0, 32(SP)
9D006F68  00C08821   ADDU S1, A2, ZERO
9D006F6C  308400FF   ANDI A0, A0, 255
9D006F70  30A500FF   ANDI A1, A1, 255
416:                 	DRESULT res;
417:                 	PF_BYTE n, csd[16], *ptr = buff;
418:                 	DWORD csize;
419:                 
420:                 	if (drv)
9D006F74  148000D0   BNE A0, ZERO, 0x9D0072B8
9D006F78  24100004   ADDIU S0, ZERO, 4
421:                 		return RES_PARERR;
422:                 	if (Stat & STA_NOINIT)
9D006F7C  93828010   LBU V0, -32752(GP)
9D006F80  30420001   ANDI V0, V0, 1
9D006F84  144000CC   BNE V0, ZERO, 0x9D0072B8
9D006F88  24100003   ADDIU S0, ZERO, 3
423:                 		return RES_NOTRDY;
424:                 
425:                 	res = RES_ERROR;
9D007210  0B401CAC   J 0x9D0072B0
9D007214  2C500001   SLTIU S0, V0, 1
9D007238  0B401CAC   J 0x9D0072B0
9D00723C  2C500001   SLTIU S0, V0, 1
9D0072A4  0B401CAC   J 0x9D0072B0
9D0072A8  2C500001   SLTIU S0, V0, 1
426:                 	switch (ctrl) {
9D006F8C  2CA2000F   SLTIU V0, A1, 15
9D006F90  504000C7   BEQL V0, ZERO, 0x9D0072B0
9D006F94  24100004   ADDIU S0, ZERO, 4
9D006F98  00052880   SLL A1, A1, 2
9D006F9C  3C029D00   LUI V0, -25344
9D006FA0  24426FB4   ADDIU V0, V0, 28596
9D006FA4  00452821   ADDU A1, V0, A1
9D006FA8  8CA20000   LW V0, 0(A1)
9D006FAC  00400008   JR V0
9D006FB0  00000000   NOP
427:                 	case CTRL_SYNC: /* Flush dirty buffer if present */
428:                 		if (select()) {
9D006FF0  0F401A02   JAL 0x9D006808
9D006FF4  24100001   ADDIU S0, ZERO, 1
9D006FF8  104000AD   BEQ V0, ZERO, 0x9D0072B0
9D006FFC  00000000   NOP
429:                 			deselect();
9D007000  0F4020D3   JAL disableSD
9D007004  00008021   ADDU S0, ZERO, ZERO
9D007008  0B401CAC   J 0x9D0072B0
9D00700C  00000000   NOP
430:                 			res = RES_OK;
431:                 		}
432:                 		break;
433:                 
434:                 	case GET_SECTOR_COUNT: /* Get number of sectors on the disk (WORD) */
435:                 		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
9D007010  24040009   ADDIU A0, ZERO, 9
9D007014  0F401A13   JAL 0x9D00684C
9D007018  00002821   ADDU A1, ZERO, ZERO
9D00701C  144000A4   BNE V0, ZERO, 0x9D0072B0
9D007020  24100001   ADDIU S0, ZERO, 1
9D007024  27A40010   ADDIU A0, SP, 16
9D007028  0F401A7B   JAL 0x9D0069EC
9D00702C  24050010   ADDIU A1, ZERO, 16
9D007030  1040009F   BEQ V0, ZERO, 0x9D0072B0
9D007034  93A30010   LBU V1, 16(SP)
436:                 			if ((csd[0] >> 6) == 1) { /* SDv2? */
9D007038  00031982   SRL V1, V1, 6
9D00703C  24020001   ADDIU V0, ZERO, 1
9D007040  1462000A   BNE V1, V0, 0x9D00706C
9D007044  93A30018   LBU V1, 24(SP)
437:                 				csize = csd[9] + ((WORD) csd[8] << 8) + 1;
9D007048  93A30019   LBU V1, 25(SP)
9D00704C  24630001   ADDIU V1, V1, 1
9D007050  93A20018   LBU V0, 24(SP)
9D007054  00021200   SLL V0, V0, 8
9D007058  00621021   ADDU V0, V1, V0
438:                 				*(DWORD*) buff = (DWORD) csize << 10;
9D00705C  00021280   SLL V0, V0, 10
9D007060  AE220000   SW V0, 0(S1)
439:                 			} else { /* SDv1 or MMCv2 */
440:                 				n = (csd[5] & 15) + ((csd[10] & 128) >> 7)
9D007090  93A40015   LBU A0, 21(SP)
9D007094  3084000F   ANDI A0, A0, 15
9D007098  93A2001A   LBU V0, 26(SP)
9D00709C  000211C2   SRL V0, V0, 7
9D0070A0  00822021   ADDU A0, A0, V0
9D0070A4  93A20019   LBU V0, 25(SP)
9D0070A8  30420003   ANDI V0, V0, 3
9D0070AC  00021040   SLL V0, V0, 1
441:                 						+ ((csd[9] & 3) << 1) + 2;
442:                 				csize = (csd[8] >> 6) + ((WORD) csd[7] << 2) + ((WORD) (csd[6]
9D00706C  00031982   SRL V1, V1, 6
9D007070  93A20017   LBU V0, 23(SP)
9D007074  00021080   SLL V0, V0, 2
9D007078  00621821   ADDU V1, V1, V0
9D00707C  24630001   ADDIU V1, V1, 1
443:                 						& 3) << 10) + 1;
9D007080  93A20016   LBU V0, 22(SP)
9D007084  30420003   ANDI V0, V0, 3
9D007088  00021280   SLL V0, V0, 10
9D00708C  00621821   ADDU V1, V1, V0
444:                 				*(DWORD*) buff = (DWORD) csize << (n - 9);
9D0070B0  00821021   ADDU V0, A0, V0
9D0070B4  2442FFF9   ADDIU V0, V0, -7
9D0070B8  00431004   SLLV V0, V1, V0
9D0070BC  AE220000   SW V0, 0(S1)
445:                 			}
446:                 			res = RES_OK;
9D007064  0B401CAC   J 0x9D0072B0
9D007068  00008021   ADDU S0, ZERO, ZERO
9D0070C0  0B401CAC   J 0x9D0072B0
9D0070C4  00008021   ADDU S0, ZERO, ZERO
447:                 		}
448:                 		break;
449:                 
450:                 	case GET_SECTOR_SIZE: /* Get sectors on the disk (WORD) */
451:                 		*(WORD*) buff = 512;
9D0070C8  24020200   ADDIU V0, ZERO, 512
9D0070CC  A4C20000   SH V0, 0(A2)
452:                 		res = RES_OK;
453:                 		break;
9D0070D0  0B401CAC   J 0x9D0072B0
9D0070D4  00008021   ADDU S0, ZERO, ZERO
454:                 
455:                 	case GET_BLOCK_SIZE: /* Get erase block size in unit of sectors (DWORD) */
456:                 		if (CardType & CT_SD2) { /* SDv2? */
9D0070D8  97828030   LHU V0, -32720(GP)
9D0070DC  30420004   ANDI V0, V0, 4
9D0070E0  10400019   BEQ V0, ZERO, 0x9D007148
9D0070E4  24040009   ADDIU A0, ZERO, 9
457:                 			if (send_cmd(ACMD13, 0) == 0) { /* Read SD status */
9D0070E8  2404008D   ADDIU A0, ZERO, 141
9D0070EC  0F401A13   JAL 0x9D00684C
9D0070F0  00002821   ADDU A1, ZERO, ZERO
9D0070F4  1440006E   BNE V0, ZERO, 0x9D0072B0
9D0070F8  24100001   ADDIU S0, ZERO, 1
458:                 				rcvr_spi();
9D0070FC  0F4020B7   JAL writeSPI
9D007100  240400FF   ADDIU A0, ZERO, 255
459:                 				if (rcvr_datablock(csd, 16)) { /* Read partial block */
9D007104  27A40010   ADDIU A0, SP, 16
9D007108  0F401A7B   JAL 0x9D0069EC
9D00710C  24050010   ADDIU A1, ZERO, 16
9D007110  10400067   BEQ V0, ZERO, 0x9D0072B0
9D007114  00000000   NOP
9D007118  24100030   ADDIU S0, ZERO, 48
460:                 					for (n = 64 - 16; n; n--)
9D007124  2610FFFF   ADDIU S0, S0, -1
9D007128  321000FF   ANDI S0, S0, 255
9D00712C  1600FFFB   BNE S0, ZERO, 0x9D00711C
9D007130  93A2001A   LBU V0, 26(SP)
461:                 						rcvr_spi(); /* Purge trailing data */
9D00711C  0F4020B7   JAL writeSPI
9D007120  240400FF   ADDIU A0, ZERO, 255
462:                 					*(DWORD*) buff = 16UL << (csd[10] >> 4);
9D007134  00021102   SRL V0, V0, 4
9D007138  24030010   ADDIU V1, ZERO, 16
9D00713C  00431004   SLLV V0, V1, V0
9D007140  0B401CAC   J 0x9D0072B0
9D007144  AE220000   SW V0, 0(S1)
463:                 					res = RES_OK;
464:                 				}
465:                 			}
466:                 		} else { /* SDv1 or MMCv3 */
467:                 			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) { /* Read CSD */
9D007148  0F401A13   JAL 0x9D00684C
9D00714C  00002821   ADDU A1, ZERO, ZERO
9D007150  14400057   BNE V0, ZERO, 0x9D0072B0
9D007154  24100001   ADDIU S0, ZERO, 1
9D007158  27A40010   ADDIU A0, SP, 16
9D00715C  0F401A7B   JAL 0x9D0069EC
9D007160  24050010   ADDIU A1, ZERO, 16
9D007164  10400052   BEQ V0, ZERO, 0x9D0072B0
9D007168  97828030   LHU V0, -32720(GP)
468:                 				if (CardType & CT_SD1) { /* SDv1 */
9D00716C  30420002   ANDI V0, V0, 2
9D007170  1040000F   BEQ V0, ZERO, 0x9D0071B0
9D007174  93A2001B   LBU V0, 27(SP)
469:                 					*(DWORD*) buff = (((csd[10] & 63) << 1) + ((WORD) (csd[11]
9D007180  24630001   ADDIU V1, V1, 1
9D007184  93A2001A   LBU V0, 26(SP)
9D007188  3042003F   ANDI V0, V0, 63
9D00718C  00021040   SLL V0, V0, 1
9D0071A4  AE220000   SW V0, 0(S1)
470:                 							& 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
9D007178  93A3001B   LBU V1, 27(SP)
9D00717C  000319C2   SRL V1, V1, 7
9D007190  00621821   ADDU V1, V1, V0
9D007194  93A2001D   LBU V0, 29(SP)
9D007198  00021182   SRL V0, V0, 6
9D00719C  2442FFFF   ADDIU V0, V0, -1
9D0071A0  00431004   SLLV V0, V1, V0
471:                 				} else { /* MMCv3 */
472:                 					*(DWORD*) buff = ((WORD) ((csd[10] & 124) >> 2) + 1)
9D0071B0  93A3001A   LBU V1, 26(SP)
9D0071B4  7C632080   EXT V1, V1, 2, 5
9D0071B8  24630001   ADDIU V1, V1, 1
9D0071D4  AE220000   SW V0, 0(S1)
473:                 							* (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5)
9D0071BC  00022142   SRL A0, V0, 5
9D0071C0  24840001   ADDIU A0, A0, 1
9D0071C4  30420003   ANDI V0, V0, 3
9D0071C8  000210C0   SLL V0, V0, 3
9D0071D0  70621002   MUL V0, V1, V0
474:                 									+ 1);
9D0071CC  00821021   ADDU V0, A0, V0
475:                 				}
476:                 				res = RES_OK;
9D0071A8  0B401CAC   J 0x9D0072B0
9D0071AC  00008021   ADDU S0, ZERO, ZERO
9D0071D8  0B401CAC   J 0x9D0072B0
9D0071DC  00008021   ADDU S0, ZERO, ZERO
477:                 			}
478:                 		}
479:                 		break;
480:                 
481:                 	case MMC_GET_TYPE: /* Get card type flags (1 byte) */
482:                 		*ptr = CardType;
9D0071E0  97828030   LHU V0, -32720(GP)
9D0071E4  A0C20000   SB V0, 0(A2)
483:                 		res = RES_OK;
484:                 		break;
9D0071E8  0B401CAC   J 0x9D0072B0
9D0071EC  00008021   ADDU S0, ZERO, ZERO
485:                 
486:                 	case MMC_GET_CSD: /* Receive CSD as a data block (16 bytes) */
487:                 		if ((send_cmd(CMD9, 0) == 0) /* READ_CSD */
9D0071F0  24040009   ADDIU A0, ZERO, 9
9D0071F4  0F401A13   JAL 0x9D00684C
9D0071F8  00002821   ADDU A1, ZERO, ZERO
9D0071FC  1440002C   BNE V0, ZERO, 0x9D0072B0
9D007200  24100001   ADDIU S0, ZERO, 1
488:                 		&& rcvr_datablock(buff, 16))
9D007204  02202021   ADDU A0, S1, ZERO
9D007208  0F401A7B   JAL 0x9D0069EC
9D00720C  24050010   ADDIU A1, ZERO, 16
489:                 			res = RES_OK;
490:                 		break;
491:                 
492:                 	case MMC_GET_CID: /* Receive CID as a data block (16 bytes) */
493:                 		if ((send_cmd(CMD10, 0) == 0) /* READ_CID */
9D007218  2404000A   ADDIU A0, ZERO, 10
9D00721C  0F401A13   JAL 0x9D00684C
9D007220  00002821   ADDU A1, ZERO, ZERO
9D007224  14400022   BNE V0, ZERO, 0x9D0072B0
9D007228  24100001   ADDIU S0, ZERO, 1
494:                 		&& rcvr_datablock(buff, 16))
9D00722C  02202021   ADDU A0, S1, ZERO
9D007230  0F401A7B   JAL 0x9D0069EC
9D007234  24050010   ADDIU A1, ZERO, 16
495:                 			res = RES_OK;
496:                 		break;
497:                 
498:                 	case MMC_GET_OCR: /* Receive OCR as an R3 resp (4 bytes) */
499:                 		if (send_cmd(CMD58, 0) == 0) { /* READ_OCR */
9D007240  2404003A   ADDIU A0, ZERO, 58
9D007244  0F401A13   JAL 0x9D00684C
9D007248  00002821   ADDU A1, ZERO, ZERO
9D00724C  14400018   BNE V0, ZERO, 0x9D0072B0
9D007250  24100001   ADDIU S0, ZERO, 1
9D007254  02209021   ADDU S2, S1, ZERO
500:                 			for (n = 0; n < 4; n++)
9D00726C  1650FFFB   BNE S2, S0, 0x9D00725C
9D007270  00000000   NOP
501:                 				*((PF_BYTE*) buff + n) = rcvr_spi();
9D00725C  0F4020B7   JAL writeSPI
9D007260  240400FF   ADDIU A0, ZERO, 255
9D007264  A2420000   SB V0, 0(S2)
9D007268  26520001   ADDIU S2, S2, 1
502:                 			res = RES_OK;
9D007274  0B401CAC   J 0x9D0072B0
9D007278  00008021   ADDU S0, ZERO, ZERO
503:                 		}
504:                 		break;
505:                 
506:                 	case MMC_GET_SDSTAT: /* Receive SD status as a data block (64 bytes) */
507:                 		if (send_cmd(ACMD13, 0) == 0) { /* SD_STATUS */
9D00727C  2404008D   ADDIU A0, ZERO, 141
9D007280  0F401A13   JAL 0x9D00684C
9D007284  00002821   ADDU A1, ZERO, ZERO
9D007288  14400009   BNE V0, ZERO, 0x9D0072B0
9D00728C  24100001   ADDIU S0, ZERO, 1
508:                 			rcvr_spi();
9D007290  0F4020B7   JAL writeSPI
9D007294  240400FF   ADDIU A0, ZERO, 255
509:                 			if (rcvr_datablock(buff, 64))
9D007298  02202021   ADDU A0, S1, ZERO
9D00729C  0F401A7B   JAL 0x9D0069EC
9D0072A0  24050040   ADDIU A1, ZERO, 64
510:                 				res = RES_OK;
511:                 		}
512:                 		break;
513:                 
514:                 	default:
515:                 		res = RES_PARERR;
9D0072AC  24100004   ADDIU S0, ZERO, 4
516:                 	}
517:                 
518:                 	deselect();
9D0072B0  0F4020D3   JAL disableSD
9D0072B4  00000000   NOP
519:                 
520:                 	return res;
521:                 }
9D0072B8  02001021   ADDU V0, S0, ZERO
9D0072BC  8FBF002C   LW RA, 44(SP)
9D0072C0  8FB20028   LW S2, 40(SP)
9D0072C4  8FB10024   LW S1, 36(SP)
9D0072C8  8FB00020   LW S0, 32(SP)
9D0072CC  03E00008   JR RA
9D0072D0  27BD0030   ADDIU SP, SP, 48
522:                 
523:                 /*-----------------------------------------------------------------------*/
524:                 /* Device Timer Interrupt Procedure  (Platform dependent)                */
525:                 /*-----------------------------------------------------------------------*/
526:                 /* This function must be called in period of 1ms                         */
527:                 /*
528:                 void disk_timerproc(void) {
529:                 	static WORD pv;
530:                 	WORD p;
531:                 	PF_BYTE s;
532:                 	UINT16 n;
533:                 
534:                 	n = Timer1; // 1000Hz decrement timer
535:                 	if (n)
536:                 		Timer1 = --n;
537:                 	n = Timer2;
538:                 	if (n)
539:                 		Timer2 = --n;
540:                 
541:                 	p = pv;
542:                 	pv = getCD() & getWP(); // Sample socket switch
543:                 
544:                 	if (p == pv) { // Have contacts stabled?
545:                 		s = Stat;
546:                 
547:                 		if (p & getWP()) // WP is H (write protected)
548:                 			s |= STA_PROTECT;
549:                 		else
550:                 			//* WP is L (write enabled)
551:                 			s &= ~STA_PROTECT;
552:                 
553:                 		if (p & getCD()) // INS = H (Socket empty)
554:                 			s |= (STA_NODISK | STA_NOINIT);
555:                 		else
556:                 			// INS = L (Card inserted)
557:                 			s &= ~STA_NODISK;
558:                 
559:                 		Stat = s;
560:                 	}
561:                 }
562:                 */
563:                 
564:                 /*---------------------------------------------------------*/
565:                 /* User Provided RTC Function for FatFs module             */
566:                 /*---------------------------------------------------------*/
567:                 /* This is a real time clock service to be called from     */
568:                 /* FatFs module. Any valid time must be returned even if   */
569:                 /* the system does not support an RTC.                     */
570:                 /* This function is not required in read-only cfg.         */
571:                 
572:                 /*	The current time is returned packed into a DWORD
573:                 	(32 bit) value. The bit fields are as follows:
574:                 		bits 31:25	Year from 1980 (0..127)
575:                 		bits 24:21	Month (1..12)
576:                 		bits 20:16	Day in month (1..31)
577:                 		bits 15:11	Hour (0..23)
578:                 		bits 10:05	Minute (0..59)
579:                 		bits 04:00	Second / 2 (0..29)						*/
580:                 
581:                 DWORD get_fattime(void) {
582:                 	DWORD tmr = 0;
583:                 
584:                 // Pre-processor commands added so only use RTCC if the board is known
585:                 // to support the RTCC ** Added 07 May 2012
586:                 
587:                 // For boards known to support the RTCC library
588:                 
589:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
590:                 	rtccTime pTm, cTm;
591:                 	rtccDate pDt, cDt;
592:                 
593:                 	RTCC_GetTimeDate(&pTm, &pDt);	// get time and date from RTC
594:                 											// assumes RTC has been set and is running
595:                 											// OK - could be expanded to check that RTC
596:                 											// is running and that a valid value is
597:                 											// being returned by the RTC
598:                 	cTm = RTCC_ConvertTime(&pTm);	// convert time from bcd to decimal format
599:                 	cDt = RTCC_ConvertDate(&pDt);	// convert date from bcd to decimal format
600:                 
601:                 	/* Pack date and time into a DWORD variable */
602:                 //	tmr = (((DWORD) pDt.year - 80)) | ((DWORD) pDt.mon) | ((DWORD) pDt.mday)
603:                 //			| (WORD) (pTm.hour) | (WORD) (pTm.min) | (WORD) (pTm.sec);
604:                 	tmr = cDt.year + 20;
605:                    
606:                   // Correction according to a newer rtcc library, with diff struct members.
607:                   
608:                 	 tmr = (tmr << 4) | cDt.month;		// shifts left 4 bits and adds monthth
609:                 	tmr = (tmr << 5) | cDt.dayofmonth;		// shifts left 5 bits and adds m.day
610:                 	tmr = (tmr << 5) | cTm.hours;		// shifts left 5 bits and adds hour
611:                 	tmr = (tmr << 6) | cTm.minutes;		// shift left 6 bits and adds minutes
612:                 	tmr = (tmr << 5) | (cTm.seconds/2);	// shifts left 5 bits and adds seconds/2
613:                 
614:                 //	For other boards use a fixed date and time of 01 Jan 2012 12:00:00
615:                 #else
616:                      tmr = 12 + 20;
617:                      tmr = (tmr << 4) | 1;       // shifts left 4 bits and adds month
618:                      tmr = (tmr << 5) | 1;    	// shifts left 5 bits and adds m.day
619:                      tmr = (tmr << 5) | 12;    	// shifts left 5 bits and adds hour
620:                      tmr = (tmr << 6) | 0;       // shift left 6 bits and adds minutes
621:                      tmr = (tmr << 5) | (0/2);   // shifts left 5 bits and adds seconds/2
622:                 #endif
623:                 
624:                 	return tmr;
625:                 }
9D0072D4  3C024021   LUI V0, 16417
9D0072D8  03E00008   JR RA
9D0072DC  24426000   ADDIU V0, V0, 24576
626:                 
627:                 void put_rc(FRESULT rc) {
628:                 	const char *str =
629:                                         "OK\0" "DISK_ERR\0" "INT_ERR\0" "NOT_READY\0" "NO_FILE\0" "NO_PATH\0"
630:                                                 "INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
631:                                                 "INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
632:                                                 "LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0";
633:                 	FRESULT i;
634:                 
635:                 	for (i = 0; i != rc && *str; i++) {
636:                 		while (*str++)
637:                 			;
638:                 	}
639:                 	//CDCprintln("rc=%u FR_%s", (UINT16) rc, str);
640:                         print("rc=");
641:                         print_int(rc,5);
642:                         cursor_right();
643:                         print(str);
644:                         put_char('\r');
645:                 }
646:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/HardwareProfile.c  -----------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   HardwareProfile.h
21:                   * Author: Jacques Deschênes
22:                   * Description: configuration hardware spécifique, assignation des périphériques
23:                   *     UART2 assigné à PB10,PB11
24:                   * Created on 17 avril 2013, 14:41
25:                   *
26:                   */
27:                  
28:                  #include "HardwareProfile.h"
29:                  #include <plib.h>
30:                  #include "../sound.h"
31:                  
32:                  volatile unsigned int  sys_tick; // compteur pour les milli-secondes
33:                  
34:                  
35:                  void HardwareInit(){
9D008FE0  27BDFFE8   ADDIU SP, SP, -24
9D008FE4  AFBF0014   SW RA, 20(SP)
36:                     SYSTEMConfig(mGetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
37:                     INTEnableSystemMultiVectoredInt();
9D00900C  0F402ADC   JAL INTEnableSystemMultiVectoredInt
9D009010  00000000   NOP
38:                     // activation du PROXIMITY TIMER pour les interruption inférieures à IPL=7
39:                  //   INTCONbits.TPC=0;
40:                  //   IPTMRCLR=0xFFFFFFFF;
41:                  //   INTCONbits.TPC=7;
42:                  //   IPTMR=CORE_TICK_RATE/2;
43:                      // configure coretimer pour le sys_tick
44:                  #ifdef USE_CORE_TIMER
45:                     OpenCoreTimer(CORE_TICK_RATE);
9D009014  0F402B68   JAL OpenCoreTimer
9D009018  2404493E   ADDIU A0, ZERO, 18750
46:                     mConfigIntCoreTimer((CT_INT_ON | CT_INT_PRIOR_1 | CT_INT_SUB_PRIOR_0));
9D00901C  24020001   ADDIU V0, ZERO, 1
9D009020  3C03BF88   LUI V1, -16504
9D009024  AC621034   SW V0, 4148(V1)
9D009028  3C06BF88   LUI A2, -16504
9D00902C  2403001C   ADDIU V1, ZERO, 28
9D009030  ACC31094   SW V1, 4244(A2)
9D009034  3C05BF88   LUI A1, -16504
9D009038  24030004   ADDIU V1, ZERO, 4
9D00903C  ACA31098   SW V1, 4248(A1)
9D009040  24040003   ADDIU A0, ZERO, 3
9D009044  ACC41094   SW A0, 4244(A2)
9D009048  ACA01098   SW ZERO, 4248(A1)
9D00904C  3C05BF88   LUI A1, -16504
9D009050  ACA21064   SW V0, 4196(A1)
9D009054  3C05BF88   LUI A1, -16504
9D009058  ACA21068   SW V0, 4200(A1)
47:                  #endif
48:                     // désactivation de toutes les entrée analogiques.
49:                     ANSELBCLR=0xFFFFFFFF;
9D00905C  3C05BF88   LUI A1, -16504
9D009060  2406FFFF   ADDIU A2, ZERO, -1
9D009064  ACA66104   SW A2, 24836(A1)
50:                     ANSELACLR=0xFFFFFFFF;
9D009068  3C07BF88   LUI A3, -16504
9D00906C  ACE66004   SW A2, 24580(A3)
51:                      // configuration PB10 sortie et PB11 entrée
52:                     mPORTBSetBits(TX); // mettre à Vdd pour ne pas généré un faux start bit.
9D009070  24060400   ADDIU A2, ZERO, 1024
9D009074  3C07BF88   LUI A3, -16504
9D009078  ACE66138   SW A2, 24888(A3)
53:                     mPORTBSetPinsDigitalOut(TX);      // sortie PB10(Tx), transmission UART2
9D00907C  3C07BF88   LUI A3, -16504
9D009080  ACE66114   SW A2, 24852(A3)
9D009084  ACA66104   SW A2, 24836(A1)
54:                     mPORTBSetPinsDigitalIn (RX);      // entrée PB11(Rx), réception UART2
9D009088  24060800   ADDIU A2, ZERO, 2048
9D00908C  3C08BF88   LUI T0, -16504
9D009090  AD066118   SW A2, 24856(T0)
9D009094  ACA66104   SW A2, 24836(A1)
55:                     // assignation des périphériques aux broches
56:                     // l'information se trouve dans pps.h
57:                     PPSUnLock;                     // déverrouillage configuration assignation périphérique
58:                     //clavier
59:                     I2C1CONbits.DISSLW=1; // voir pic32mx1xxx/2xxx-errata.pdf rev. E, point 9
9D009098  3C05BF80   LUI A1, -16512
9D00909C  8CA65000   LW A2, 20480(A1)
9D0090A0  7C464A44   INS A2, V0, 9, 1
9D0090A4  ACA65000   SW A2, 20480(A1)
60:                     RPA0R=0;  // pas de périphérique sur RA0 (keyboard clock)
9D0090A8  3C02BF81   LUI V0, -16511
9D0090AC  AC40FB00   SW ZERO, -1280(V0)
61:                     RPA1R=0;  // pas de périphérique sur RA1 (keyboard data)
9D0090B0  3C02BF81   LUI V0, -16511
9D0090B4  AC40FB04   SW ZERO, -1276(V0)
62:                     RPB3R=0; //  pas de périphérique sur RB3 (status LED)
9D0090B8  3C02BF81   LUI V0, -16511
9D0090BC  AC40FB38   SW ZERO, -1224(V0)
63:                     RPB15R=0; // pad de périphérique sur RB15
9D0090C0  3C02BF81   LUI V0, -16511
9D0090C4  AC40FB68   SW ZERO, -1176(V0)
64:                     TRISBCLR=STATUS_LED; // broche status LED en sortie
9D0090C8  24020008   ADDIU V0, ZERO, 8
9D0090CC  ACE26114   SW V0, 24852(A3)
65:                     _status_off();
9D0090D0  3C02BF88   LUI V0, -16504
9D0090D4  8C466120   LW A2, 24864(V0)
9D0090D8  2405FFF7   ADDIU A1, ZERO, -9
9D0090DC  00C52824   AND A1, A2, A1
9D0090E0  AC456120   SW A1, 24864(V0)
66:                     PPSOutput(4, RPB10, U2TX);  // assignation U2TX sur PB10, (groupe, pin, fonction)
9D0090E4  3C02BF81   LUI V0, -16511
9D0090E8  8C46FB54   LW A2, -1196(V0)
9D0090EC  24050002   ADDIU A1, ZERO, 2
9D0090F0  7CA61804   INS A2, A1, 0, 4
9D0090F4  AC46FB54   SW A2, -1196(V0)
67:                     PPSInput (2, U2RX, RPB11);  // assignation U2RX sur PB11, (groupe, fonction, pin)
9D0090F8  3C02BF81   LUI V0, -16511
9D0090FC  8C46FA58   LW A2, -1448(V0)
9D009100  7C861804   INS A2, A0, 0, 4
9D009104  AC46FA58   SW A2, -1448(V0)
68:                     PPSOutput(2,RPB5,OC2); // 5=OC2  sur PB5 sortie synchronistaiton ntsc
9D009108  3C06BF81   LUI A2, -16511
9D00910C  8CC7FB40   LW A3, -1216(A2)
9D009110  24020005   ADDIU V0, ZERO, 5
9D009114  7C471804   INS A3, V0, 0, 4
9D009118  ACC7FB40   SW A3, -1216(A2)
69:                     PPSOutput(1,RPB4,OC1);  // 5=OC1 impulsion déclenchant SPI , Fsync vidéo
9D00911C  3C06BF81   LUI A2, -16511
9D009120  8CC7FB3C   LW A3, -1220(A2)
9D009124  7C471804   INS A3, V0, 0, 4
9D009128  ACC7FB3C   SW A3, -1220(A2)
70:                     PPSOutput(3,RPB6,SDO1); // 3=SDO1 sortie SPI1 (vidéo)
9D00912C  3C06BF81   LUI A2, -16511
9D009130  8CC7FB44   LW A3, -1212(A2)
9D009134  7C871804   INS A3, A0, 0, 4
9D009138  ACC7FB44   SW A3, -1212(A2)
71:                     PPSOutput(4,RPB9,OC3); // OC3 sortie audio.
9D00913C  3C04BF81   LUI A0, -16511
9D009140  8C86FB50   LW A2, -1200(A0)
9D009144  7C461804   INS A2, V0, 0, 4
9D009148  AC86FB50   SW A2, -1200(A0)
72:                     PPSInput(1,SS1,RPB7); // entrée Fsync sur RPB7
9D00914C  3C02BF81   LUI V0, -16511
9D009150  8C44FA88   LW A0, -1400(V0)
9D009154  7C641804   INS A0, V1, 0, 4
9D009158  AC44FA88   SW A0, -1400(V0)
73:                     PPSInput(3,SDI2,RPA4); // entrée SDI pour carte SD
9D00915C  3C02BF81   LUI V0, -16511
9D009160  8C44FA90   LW A0, -1392(V0)
9D009164  7CA41804   INS A0, A1, 0, 4
9D009168  AC44FA90   SW A0, -1392(V0)
74:                     PPSOutput(2,RPB8,SDO2); // sortie commande carte SD
9D00916C  3C02BF81   LUI V0, -16511
9D009170  8C44FB4C   LW A0, -1204(V0)
9D009174  7C641804   INS A0, V1, 0, 4
9D009178  AC44FB4C   SW A0, -1204(V0)
75:                     PPSLock;                       // reverrouille pour éviter assignation accidentelle.
76:                  }
9D00917C  8FBF0014   LW RA, 20(SP)
9D009180  03E00008   JR RA
9D009184  27BD0018   ADDIU SP, SP, 24
77:                  
78:                  inline unsigned int ticks(void){
79:                      return sys_tick;
9D009188  8F828058   LW V0, -32680(GP)
80:                  } //ticks()
9D00918C  03E00008   JR RA
9D009190  00000000   NOP
81:                  
82:                  inline void delay_us(unsigned int usec){
83:                      for (usec=usec*(CLK_PER_USEC/3);usec;usec--);
9D009194  2402000C   ADDIU V0, ZERO, 12
9D009198  70821002   MUL V0, A0, V0
9D00919C  10400003   BEQ V0, ZERO, 0x9D0091AC
9D0091A0  2442FFFF   ADDIU V0, V0, -1
9D0091A4  1440FFFF   BNE V0, ZERO, 0x9D0091A4
9D0091A8  2442FFFF   ADDIU V0, V0, -1
9D0091AC  03E00008   JR RA
9D0091B0  00000000   NOP
84:                  }//delay_us()
85:                  
86:                  void delay_ms(unsigned int msec){
87:                  #ifdef USE_CORE_TIMER
88:                      unsigned int t0;
89:                      t0=sys_tick+msec;
9D0091B4  8F828058   LW V0, -32680(GP)
9D0091B8  00821021   ADDU V0, A0, V0
90:                      while (sys_tick!=t0);
9D0091BC  8F838058   LW V1, -32680(GP)
9D0091C0  1462FFFE   BNE V1, V0, 0x9D0091BC
9D0091C4  00000000   NOP
91:                  #else
92:                      while (msec--)
93:                          delay_us(1000);
94:                  #endif
95:                  } // delay_ms()
9D0091C8  03E00008   JR RA
9D0091CC  00000000   NOP
96:                  
97:                  #ifdef USE_CORE_TIMER
98:                    //déclaration du gestionnaire d'interruption
99:                     void __ISR(_CORE_TIMER_VECTOR, IPL1SOFT)  CoreTimerHandler(void){
9D0091D0  415DE800   RDPGPR SP, SP
9D0091D4  401A7000   MFC0 K0, EPC
9D0091D8  401B6000   MFC0 K1, Status
9D0091DC  27BDFFE8   ADDIU SP, SP, -24
9D0091E0  AFBA0014   SW K0, 20(SP)
9D0091E4  401A6002   MFC0 K0, SRSCtl
9D0091E8  AFBB0010   SW K1, 16(SP)
9D0091EC  AFBA000C   SW K0, 12(SP)
9D0091F0  7C1B7844   INS K1, ZERO, 1, 15
9D0091F4  377B0400   ORI K1, K1, 1024
9D0091F8  409B6000   MTC0 K1, Status
9D0091FC  AFA30004   SW V1, 4(SP)
9D009200  AFA20000   SW V0, 0(SP)
100:                        sys_tick++;
9D009204  8F828058   LW V0, -32680(GP)
9D009208  24420001   ADDIU V0, V0, 1
9D00920C  AF828058   SW V0, -32680(GP)
101:                        __asm__("mfc0 $v0, $11");
9D009210  40025800   MFC0 V0, Compare
102:                        __asm__("addiu $v0,$v0,%0"::"I"(CORE_TICK_RATE));
9D009214  2442493E   ADDIU V0, V0, 18750
103:                        __asm__("mtc0 $v0, $11");
9D009218  40825800   MTC0 V0, Compare
104:                        if (tone_on && !(--duration)){
9D00921C  93828048   LBU V0, -32696(GP)
9D009220  304200FF   ANDI V0, V0, 255
9D009224  1040000C   BEQ V0, ZERO, 0x9D009258
9D009228  24030001   ADDIU V1, ZERO, 1
9D00922C  8F82808C   LW V0, -32628(GP)
9D009230  2442FFFF   ADDIU V0, V0, -1
9D009234  AF82808C   SW V0, -32628(GP)
9D009238  8F82808C   LW V0, -32628(GP)
9D00923C  14400005   BNE V0, ZERO, 0x9D009254
9D009240  3C02BF80   LUI V0, -16512
105:                                mTone_off();
9D009244  8C433400   LW V1, 13312(V0)
9D009248  7C037BC4   INS V1, ZERO, 15, 1
9D00924C  AC433400   SW V1, 13312(V0)
106:                                tone_on=0;
9D009250  A3808048   SB ZERO, -32696(GP)
107:                        }
108:                        mCTClearIntFlag();
9D009254  24030001   ADDIU V1, ZERO, 1
9D009258  3C02BF88   LUI V0, -16504
9D00925C  AC431034   SW V1, 4148(V0)
109:                    };
9D009260  8FA30004   LW V1, 4(SP)
9D009264  8FA20000   LW V0, 0(SP)
9D009268  41606000   DI ZERO
9D00926C  000000C0   EHB
9D009270  8FBA0014   LW K0, 20(SP)
9D009274  8FBB0010   LW K1, 16(SP)
9D009278  409A7000   MTC0 K0, EPC
9D00927C  8FBA000C   LW K0, 12(SP)
9D009280  27BD0018   ADDIU SP, SP, 24
9D009284  409A6002   MTC0 K0, SRSCtl
9D009288  41DDE800   WRPGPR SP, SP
9D00928C  409B6000   MTC0 K1, Status
9D009290  42000018   ERET
110:                 #endif
111:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/editor.c  -----------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   editor.h
20:                   * Author: Jacques Deschênes
21:                   *
22:                   * Created on 18 septembre 2013, 07:18
23:                   * Description: un éditeur simple pour le VPC-32
24:                   *
25:                   */
26:                  
27:                  
28:                  #include "hardware/HardwareProfile.h"
29:                  #include "hardware/keyboard.h"
30:                  #include "console.h"
31:                  
32:                  
33:                  void ed(char *file_name){
9D00ABA4  27BDFFE8   ADDIU SP, SP, -24
9D00ABA8  AFBF0014   SW RA, 20(SP)
34:                      if (comm_channel!=LOCAL_CON){
9D00ABAC  93848038   LBU A0, -32712(GP)
9D00ABB0  10800006   BEQ A0, ZERO, 0x9D00ABCC
9D00ABB4  8FBF0014   LW RA, 20(SP)
35:                          print(comm_channel, "Cet editeur fonctionne seulement sur la console locale\r");
9D00ABB8  7C042420   SEB A0, A0
9D00ABBC  3C059D01   LUI A1, -25343
9D00ABC0  0F401DDD   JAL print
9D00ABC4  24A5AA90   ADDIU A1, A1, -21872
36:                          return;
37:                      }
38:                  
39:                  } // ed()
9D00ABC8  8FBF0014   LW RA, 20(SP)
9D00ABCC  03E00008   JR RA
9D00ABD0  27BD0018   ADDIU SP, SP, 24
40:                  
41:                  
42:                  
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/console.c  ----------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   *  Name: console.c
21:                   *  Description: text console for NTSC video output
22:                   *  Author: Jacques Deschênes
23:                   *  Date Created: 2013-09-06
24:                   */
25:                  
26:                  #include "console.h"
27:                  #include "hardware/HardwareProfile.h"
28:                  #include "hardware/serial_comm.h"
29:                  #include "hardware/keyboard.h"
30:                  
31:                  #define X_OFS  ((HRES%CWIDTH)/2)  // offset vidéo position curseur x
32:                  #define Y_OFS  ((VRES%CHEIGHT)/2)  // offset vidéo position curseur y
33:                  
34:                  // indicateurs booléens
35:                  #define CUR_SHOW 1  // curseur actif
36:                  #define CUR_VIS  2  // curseur visible
37:                  
38:                  
39:                  static unsigned short cx=X_OFS, cy=Y_OFS;  // coordonnée courante du curseur texte en pixels.
40:                  static unsigned char tab_width=TAB_WIDTH;
41:                  static cursor_t cur_shape=CR_UNDER;
42:                  static unsigned short flags=0;
43:                  
44:                  unsigned char comm_channel=LOCAL_CON;
45:                  
46:                  
47:                  void scroll_up(void){
9D00739C  27BDFFE8   ADDIU SP, SP, -24
9D0073A0  AFBF0014   SW RA, 20(SP)
9D0073A4  AFB00010   SW S0, 16(SP)
48:                      char *src, *dst;
49:                      dst = (char*)video_bmp+Y_OFS*HRES/8;
9D0073A8  3C10A000   LUI S0, -24576
9D0073AC  26100080   ADDIU S0, S0, 128
50:                      src = (char*)video_bmp +(CHEIGHT+Y_OFS)*HRES/8;
51:                      memmove(dst,src,(LINE_PER_SCREEN-1)*CHEIGHT*HRES/8);
9D0073B0  26040078   ADDIU A0, S0, 120
9D0073B4  260501B8   ADDIU A1, S0, 440
9D0073B8  0F4029E3   JAL memmove
9D0073BC  240621C0   ADDIU A2, ZERO, 8640
52:                      dst= (char*)video_bmp+(CHEIGHT*(LINE_PER_SCREEN-1)+Y_OFS)*HRES/8;
53:                      memset(dst,0,HRES/8*CHEIGHT);
9D0073C0  26042238   ADDIU A0, S0, 8760
9D0073C4  00002821   ADDU A1, ZERO, ZERO
9D0073C8  0F402973   JAL 0x9D00A5CC
9D0073CC  24060140   ADDIU A2, ZERO, 320
54:                  }//scroll_up();
9D0073D0  8FBF0014   LW RA, 20(SP)
9D0073D4  8FB00010   LW S0, 16(SP)
9D0073D8  03E00008   JR RA
9D0073DC  27BD0018   ADDIU SP, SP, 24
55:                  
56:                  void scroll_down(void){
9D0073E0  27BDFFE8   ADDIU SP, SP, -24
9D0073E4  AFBF0014   SW RA, 20(SP)
9D0073E8  AFB00010   SW S0, 16(SP)
57:                      char *src, *dst;
58:                      src = (char*)video_bmp+Y_OFS*HRES/8;
9D0073EC  3C04A000   LUI A0, -24576
9D0073F0  24840080   ADDIU A0, A0, 128
9D0073F4  24900078   ADDIU S0, A0, 120
59:                      dst = (char*)video_bmp+(CHEIGHT+Y_OFS)*HRES/8;
60:                      memmove(dst,src,(LINE_PER_SCREEN-1)*CHEIGHT*HRES/8);
9D0073F8  248401B8   ADDIU A0, A0, 440
9D0073FC  02002821   ADDU A1, S0, ZERO
9D007400  0F4029E3   JAL memmove
9D007404  240621C0   ADDIU A2, ZERO, 8640
61:                      dst=(char*)video_bmp+Y_OFS*HRES/8;
62:                      memset(dst,0,HRES/8*CHEIGHT);
9D007408  02002021   ADDU A0, S0, ZERO
9D00740C  00002821   ADDU A1, ZERO, ZERO
9D007410  0F402973   JAL 0x9D00A5CC
9D007414  24060140   ADDIU A2, ZERO, 320
63:                  }//scroll_down()
9D007418  8FBF0014   LW RA, 20(SP)
9D00741C  8FB00010   LW S0, 16(SP)
9D007420  03E00008   JR RA
9D007424  27BD0018   ADDIU SP, SP, 24
64:                  
65:                  
66:                  void cursor_right(void){
9D007428  27BDFFE8   ADDIU SP, SP, -24
9D00742C  AFBF0014   SW RA, 20(SP)
67:                      cx += CWIDTH;
9D007430  9782801C   LHU V0, -32740(GP)
9D007434  24420006   ADDIU V0, V0, 6
9D007438  3042FFFF   ANDI V0, V0, -1
9D00743C  A782801C   SH V0, -32740(GP)
68:                      if (cx>(CHAR_PER_LINE*CWIDTH)){
9D007440  2C42013F   SLTIU V0, V0, 319
9D007444  1440000E   BNE V0, ZERO, 0x9D007480
9D007448  24020001   ADDIU V0, ZERO, 1
69:                          cx = X_OFS;
9D00744C  A782801C   SH V0, -32740(GP)
70:                          cy += CHEIGHT;
9D007450  9782801E   LHU V0, -32738(GP)
9D007454  24420008   ADDIU V0, V0, 8
9D007458  3042FFFF   ANDI V0, V0, -1
9D00745C  A782801E   SH V0, -32738(GP)
71:                          if (cy>(LINE_PER_SCREEN*CHEIGHT)){
9D007460  2C4200E1   SLTIU V0, V0, 225
9D007464  14400007   BNE V0, ZERO, 0x9D007484
9D007468  8FBF0014   LW RA, 20(SP)
72:                              scroll_up();
9D00746C  0F401CE7   JAL scroll_up
9D007470  00000000   NOP
73:                              cy -= CHEIGHT;
9D007474  9782801E   LHU V0, -32738(GP)
9D007478  2442FFF8   ADDIU V0, V0, -8
9D00747C  A782801E   SH V0, -32738(GP)
74:                          }
75:                      }
76:                  } // cursor_right()
9D007480  8FBF0014   LW RA, 20(SP)
9D007484  03E00008   JR RA
9D007488  27BD0018   ADDIU SP, SP, 24
77:                  
78:                  void cursor_left(void){
9D00748C  27BDFFE8   ADDIU SP, SP, -24
9D007490  AFBF0014   SW RA, 20(SP)
79:                      if (cx>=(X_OFS+CWIDTH)){
9D007494  9782801C   LHU V0, -32740(GP)
9D007498  2C430007   SLTIU V1, V0, 7
9D00749C  54600004   BNEL V1, ZERO, 0x9D0074B0
9D0074A0  24020139   ADDIU V0, ZERO, 313
80:                          cx -= CWIDTH;
9D0074A4  2442FFFA   ADDIU V0, V0, -6
9D0074A8  0B401D35   J 0x9D0074D4
9D0074AC  A782801C   SH V0, -32740(GP)
81:                      }else{
82:                          cx = X_OFS+CWIDTH*(CHAR_PER_LINE-1);
9D0074B0  A782801C   SH V0, -32740(GP)
83:                          if (cy>=(Y_OFS+CHEIGHT)){
9D0074B4  9782801E   LHU V0, -32738(GP)
9D0074B8  2C43000B   SLTIU V1, V0, 11
9D0074BC  14600003   BNE V1, ZERO, 0x9D0074CC
9D0074C0  2442FFF8   ADDIU V0, V0, -8
84:                              cy -= CHEIGHT;
9D0074C4  0B401D35   J 0x9D0074D4
9D0074C8  A782801E   SH V0, -32738(GP)
85:                          }else{
86:                              scroll_down();
9D0074CC  0F401CF8   JAL scroll_down
9D0074D0  00000000   NOP
87:                          }
88:                      }
89:                  }// cursor_left()
9D0074D4  8FBF0014   LW RA, 20(SP)
9D0074D8  03E00008   JR RA
9D0074DC  27BD0018   ADDIU SP, SP, 24
90:                  
91:                  void cursor_up(void){
9D0074E0  27BDFFE8   ADDIU SP, SP, -24
9D0074E4  AFBF0014   SW RA, 20(SP)
92:                      if (cy>=(Y_OFS+CHEIGHT)){
9D0074E8  9782801E   LHU V0, -32738(GP)
9D0074EC  2C43000B   SLTIU V1, V0, 11
9D0074F0  14600003   BNE V1, ZERO, 0x9D007500
9D0074F4  2442FFF8   ADDIU V0, V0, -8
93:                          cy -= CHEIGHT;
9D0074F8  0B401D42   J 0x9D007508
9D0074FC  A782801E   SH V0, -32738(GP)
94:                      }else{
95:                          scroll_down();
9D007500  0F401CF8   JAL scroll_down
9D007504  00000000   NOP
96:                      }
97:                  }// cursor_up()
9D007508  8FBF0014   LW RA, 20(SP)
9D00750C  03E00008   JR RA
9D007510  27BD0018   ADDIU SP, SP, 24
98:                  
99:                  void cursor_down(void){
9D007514  27BDFFE8   ADDIU SP, SP, -24
9D007518  AFBF0014   SW RA, 20(SP)
100:                     if (cy<=(Y_OFS+(CHEIGHT*(LINE_PER_SCREEN-2)))){
9D00751C  9782801E   LHU V0, -32738(GP)
9D007520  2C4300D4   SLTIU V1, V0, 212
9D007524  10600003   BEQ V1, ZERO, 0x9D007534
9D007528  24420008   ADDIU V0, V0, 8
101:                         cy += CHEIGHT;
9D00752C  0B401D4F   J 0x9D00753C
9D007530  A782801E   SH V0, -32738(GP)
102:                     }else{
103:                         scroll_up();
9D007534  0F401CE7   JAL scroll_up
9D007538  00000000   NOP
104:                     }
105:                 }//cursor_down()
9D00753C  8FBF0014   LW RA, 20(SP)
9D007540  03E00008   JR RA
9D007544  27BD0018   ADDIU SP, SP, 24
106:                 
107:                 void crlf(void){
9D007548  27BDFFE8   ADDIU SP, SP, -24
9D00754C  AFBF0014   SW RA, 20(SP)
108:                     cx=X_OFS;
9D007550  24020001   ADDIU V0, ZERO, 1
9D007554  A782801C   SH V0, -32740(GP)
109:                     if (cy==(Y_OFS+(LINE_PER_SCREEN-1)*CHEIGHT)){
9D007558  9782801E   LHU V0, -32738(GP)
9D00755C  240300DB   ADDIU V1, ZERO, 219
9D007560  14430005   BNE V0, V1, 0x9D007578
9D007564  24420008   ADDIU V0, V0, 8
110:                         scroll_up();
9D007568  0F401CE7   JAL scroll_up
9D00756C  00000000   NOP
111:                     }else{
112:                         cy += CHEIGHT;
9D007578  A782801E   SH V0, -32738(GP)
113:                     }
114:                 }//crlf()
9D007570  0B401D60   J 0x9D007580
9D007574  8FBF0014   LW RA, 20(SP)
9D00757C  8FBF0014   LW RA, 20(SP)
9D007580  03E00008   JR RA
9D007584  27BD0018   ADDIU SP, SP, 24
115:                 
116:                 void put_char(dev_t channel, char c){
9D007588  27BDFFE8   ADDIU SP, SP, -24
9D00758C  AFBF0014   SW RA, 20(SP)
9D007590  7C042420   SEB A0, A0
9D007594  7C052C20   SEB A1, A1
9D007688  24660001   ADDIU A2, V1, 1
9D00768C  2404000A   ADDIU A0, ZERO, 10
9D007690  70644802   MUL T1, V1, A0
9D007694  01282021   ADDU A0, T1, T0
9D007698  00044080   SLL T0, A0, 2
9D00769C  3C04A000   LUI A0, -24576
9D0076A0  24840080   ADDIU A0, A0, 128
9D0076A4  00882021   ADDU A0, A0, T0
9D0076A8  3C089D01   LUI T0, -25343
9D0076AC  25099294   ADDIU T1, T0, -28012
9D0076B0  24080007   ADDIU T0, ZERO, 7
9D0076B4  70A85002   MUL T2, A1, T0
9D0076B8  01492821   ADDU A1, T2, T1
9D0076BC  24630008   ADDIU V1, V1, 8
117:                     register int i,l,r,b,x,y;
118:                     x=cx;
9D007598  9782801C   LHU V0, -32740(GP)
119:                     y=cy;
120:                     if (channel==LOCAL_CON){
9D00759C  14800062   BNE A0, ZERO, 0x9D007728
9D0075A0  9783801E   LHU V1, -32738(GP)
121:                         switch (c){
9D0075A4  24040009   ADDIU A0, ZERO, 9
9D0075A8  10A4000B   BEQ A1, A0, 0x9D0075D8
9D0075AC  2404000D   ADDIU A0, ZERO, 13
9D0075B0  10A40005   BEQ A1, A0, 0x9D0075C8
9D0075B4  24040008   ADDIU A0, ZERO, 8
9D0075B8  14A4001F   BNE A1, A0, 0x9D007638
9D0075BC  28A40020   SLTI A0, A1, 32
9D0075C0  0B401D8A   J 0x9D007628
9D0075C4  00000000   NOP
122:                             case CR:
123:                                 crlf();
9D0075C8  0F401D52   JAL crlf
9D0075CC  00000000   NOP
124:                                 break;
9D0075D0  0B401DCD   J 0x9D007734
9D0075D4  8FBF0014   LW RA, 20(SP)
125:                             case TAB:
126:                                 cx += (cx%tab_width);
9D0075D8  93848020   LBU A0, -32736(GP)
9D0075DC  0044001A   DIV V0, A0
9D0075E0  008001F4   TEQ A0, ZERO
9D0075E4  00002010   MFHI A0, 0
9D0075E8  00441021   ADDU V0, V0, A0
9D0075EC  3042FFFF   ANDI V0, V0, -1
9D0075F0  A782801C   SH V0, -32740(GP)
127:                                 if (cx>=(X_OFS+CHAR_PER_LINE*CWIDTH)){
9D0075F4  2C42013F   SLTIU V0, V0, 319
9D0075F8  1440004D   BNE V0, ZERO, 0x9D007730
9D0075FC  24020001   ADDIU V0, ZERO, 1
128:                                     cx = X_OFS;
9D007600  A782801C   SH V0, -32740(GP)
129:                                     if (cy==(Y_OFS+(LINE_PER_SCREEN-1)*CHEIGHT)){
9D007604  240200DB   ADDIU V0, ZERO, 219
9D007608  14620005   BNE V1, V0, 0x9D007620
9D00760C  24630008   ADDIU V1, V1, 8
130:                                         scroll_up();
9D007610  0F401CE7   JAL scroll_up
9D007614  00000000   NOP
131:                                     }else{
132:                                         cy += CHEIGHT;
9D007620  0B401DCC   J 0x9D007730
9D007624  A783801E   SH V1, -32738(GP)
133:                                     }
134:                                 }
135:                                 break;
136:                             case '\b':
137:                                 cursor_left();
9D007628  0F401D23   JAL cursor_left
9D00762C  00000000   NOP
138:                                 break;
9D007630  0B401DCD   J 0x9D007734
9D007634  8FBF0014   LW RA, 20(SP)
139:                             default:
140:                                 if ((c<32) || (c>(FONT_SIZE+32))) break;
9D007638  1480003D   BNE A0, ZERO, 0x9D007730
9D00763C  24A5FFE0   ADDIU A1, A1, -32
141:                                 c -=32;
9D007640  7C052C20   SEB A1, A1
142:                                 b=x>>5;
9D007644  00024143   SRA T0, V0, 5
143:                                 r=0;
144:                                 l=27-(x&0x1f);
9D007648  3042001F   ANDI V0, V0, 31
9D00764C  2406001B   ADDIU A2, ZERO, 27
9D007650  00C21023   SUBU V0, A2, V0
145:                                 if (l<0){
146:                                     r=-l;
9D007654  00023023   SUBU A2, ZERO, V0
9D007658  28470000   SLTI A3, V0, 0
9D00765C  0007300A   MOVZ A2, ZERO, A3
9D007660  00C03821   ADDU A3, A2, ZERO
147:                                 }
148:                                 for (i=0;i<7;i++){
9D007710  14C3FFEB   BNE A2, V1, 0x9D0076C0
9D007714  24A50001   ADDIU A1, A1, 1
149:                                     if (r){
9D0076C0  10E0000C   BEQ A3, ZERO, 0x9D0076F4
9D0076C4  8C890000   LW T1, 0(A0)
150:                                         video_bmp[y][b] &= ~(0x1f>>r);
9D007664  240C001F   ADDIU T4, ZERO, 31
9D007668  00CC7007   SRAV T6, T4, A2
9D00766C  000E7027   NOR T6, ZERO, T6
9D0076CC  01C94824   AND T1, T6, T1
151:                                         video_bmp[y][b] |= font5x7[c][i]>>r;
9D0076C8  90A80000   LBU T0, 0(A1)
9D0076D0  00E85007   SRAV T2, T0, A3
9D0076D4  012A4825   OR T1, T1, T2
9D0076D8  AC890000   SW T1, 0(A0)
152:                                         video_bmp[y][b+1] &= ~(0x1f<<32-r);
9D007670  240B0020   ADDIU T3, ZERO, 32
9D007674  01665823   SUBU T3, T3, A2
9D007678  016C6804   SLLV T5, T4, T3
9D00767C  000D6827   NOR T5, ZERO, T5
9D0076DC  8C890004   LW T1, 4(A0)
9D0076E0  01A94824   AND T1, T5, T1
153:                                         video_bmp[y][b+1] |= font5x7[c][i]<<(32-r);
9D0076E4  01684004   SLLV T0, T0, T3
9D0076E8  01284025   OR T0, T1, T0
9D0076EC  0B401DC2   J 0x9D007708
9D0076F0  AC880004   SW T0, 4(A0)
154:                                         y++;
155:                                     } else{
156:                                         video_bmp[y][b] &= ~(0x1f<<l);
9D007680  004C6004   SLLV T4, T4, V0
9D007684  000C6027   NOR T4, ZERO, T4
9D0076F4  01894824   AND T1, T4, T1
157:                                         video_bmp[y++][b] |= font5x7[c][i]<<l;
9D0076F8  90A80000   LBU T0, 0(A1)
9D0076FC  00484004   SLLV T0, T0, V0
9D007700  01284025   OR T0, T1, T0
9D007704  AC880000   SW T0, 0(A0)
9D007708  24C60001   ADDIU A2, A2, 1
9D00770C  24840028   ADDIU A0, A0, 40
158:                                     }
159:                                 }
160:                                 cursor_right();
9D007718  0F401D0A   JAL cursor_right
9D00771C  00000000   NOP
161:                         }//switch(c)
162:                     }else{
163:                         UartPutch(channel,c);
9D007728  0F4021BA   JAL UartPutch
9D00772C  00000000   NOP
164:                     }
165:                 }//put_char()
9D007618  0B401DCD   J 0x9D007734
9D00761C  8FBF0014   LW RA, 20(SP)
9D007720  0B401DCD   J 0x9D007734
9D007724  8FBF0014   LW RA, 20(SP)
9D007730  8FBF0014   LW RA, 20(SP)
9D007734  03E00008   JR RA
9D007738  27BD0018   ADDIU SP, SP, 24
166:                 
167:                 void clear_screen(){
9D00773C  27BDFFE8   ADDIU SP, SP, -24
9D007740  AFBF0014   SW RA, 20(SP)
168:                     memset(video_bmp,0,HRES/8*VRES);
9D007744  3C04A000   LUI A0, -24576
9D007748  24840080   ADDIU A0, A0, 128
9D00774C  00002821   ADDU A1, ZERO, ZERO
9D007750  0F402973   JAL 0x9D00A5CC
9D007754  240623F0   ADDIU A2, ZERO, 9200
169:                     cx=X_OFS;
9D007758  24020001   ADDIU V0, ZERO, 1
9D00775C  A782801C   SH V0, -32740(GP)
170:                     cy=Y_OFS;
9D007760  24020003   ADDIU V0, ZERO, 3
9D007764  A782801E   SH V0, -32738(GP)
171:                 } // clear_screen()
9D007768  8FBF0014   LW RA, 20(SP)
9D00776C  03E00008   JR RA
9D007770  27BD0018   ADDIU SP, SP, 24
172:                 
173:                 void print(dev_t channel, const char *text){
9D007774  27BDFFE8   ADDIU SP, SP, -24
9D007778  AFBF0014   SW RA, 20(SP)
9D00777C  AFB00010   SW S0, 16(SP)
9D007780  7C042420   SEB A0, A0
174:                     if (channel==LOCAL_CON){
9D007784  1480000C   BNE A0, ZERO, 0x9D0077B8
9D007788  00A08021   ADDU S0, A1, ZERO
175:                         while (*text){
9D00778C  80A50000   LB A1, 0(A1)
9D007790  10A0000C   BEQ A1, ZERO, 0x9D0077C4
9D007794  8FBF0014   LW RA, 20(SP)
9D0077A4  82050000   LB A1, 0(S0)
9D0077A8  14A0FFFC   BNE A1, ZERO, 0x9D00779C
9D0077AC  26100001   ADDIU S0, S0, 1
176:                             put_char(channel, *text++);
9D007798  26100001   ADDIU S0, S0, 1
9D00779C  0F401D62   JAL put_char
9D0077A0  00002021   ADDU A0, ZERO, ZERO
177:                         }
178:                     }else{
179:                         UartPrint(channel,text);
9D0077B8  0F4021F2   JAL UartPrint
9D0077BC  00000000   NOP
180:                     }
181:                 }// print()
9D0077B0  0B401DF1   J 0x9D0077C4
9D0077B4  8FBF0014   LW RA, 20(SP)
9D0077C0  8FBF0014   LW RA, 20(SP)
9D0077C4  8FB00010   LW S0, 16(SP)
9D0077C8  03E00008   JR RA
9D0077CC  27BD0018   ADDIU SP, SP, 24
182:                 
183:                 void print_hex(dev_t channel, unsigned int hex, unsigned char width){
9D0077D0  27BDFFD8   ADDIU SP, SP, -40
9D0077D4  AFBF0024   SW RA, 36(SP)
9D0077D8  7C042420   SEB A0, A0
184:                     char c[12], *d;
185:                     int i;
186:                     c[11]=0;
9D0077DC  A3A0001B   SB ZERO, 27(SP)
187:                     d= &c[10];
188:                     for(i=width;i>=0||hex;i--){
9D0077E0  30C600FF   ANDI A2, A2, 255
9D0077E4  0B401E06   J 0x9D007818
9D0077E8  27A2001A   ADDIU V0, SP, 26
9D007814  24C6FFFF   ADDIU A2, A2, -1
9D007818  04C1FFF4   BGEZ A2, 0x9D0077EC
9D00781C  30A3000F   ANDI V1, A1, 15
9D007820  14A0FFF3   BNE A1, ZERO, 0x9D0077F0
9D007824  2867000A   SLTI A3, V1, 10
189:                         *d=(hex%16);
190:                         if (*d<10)
9D0077EC  2867000A   SLTI A3, V1, 10
9D0077F0  10E00004   BEQ A3, ZERO, 0x9D007804
9D0077F4  A0430000   SB V1, 0(V0)
191:                             *d += '0';
9D0077F8  24630030   ADDIU V1, V1, 48
9D0077FC  0B401E03   J 0x9D00780C
9D007800  A0430000   SB V1, 0(V0)
192:                         else
193:                             *d += 'A'-10;
9D007804  24630037   ADDIU V1, V1, 55
9D007808  A0430000   SB V1, 0(V0)
194:                         hex /=16;
9D00780C  00052902   SRL A1, A1, 4
195:                         d--;
9D007810  2442FFFF   ADDIU V0, V0, -1
196:                     }
197:                     print(channel, ++d);
9D007828  0F401DDD   JAL print
9D00782C  24450001   ADDIU A1, V0, 1
198:                 } // print_hex()
9D007830  8FBF0024   LW RA, 36(SP)
9D007834  03E00008   JR RA
9D007838  27BD0028   ADDIU SP, SP, 40
199:                 
200:                 void print_int(dev_t channel, int number, unsigned short width){ // imprime entier,width inclus le signe
9D00783C  27BDFFD8   ADDIU SP, SP, -40
9D007840  AFBF0024   SW RA, 36(SP)
9D007844  7C042420   SEB A0, A0
201:                     int sign=0, i;
202:                     char str[14], *d;
203:                     str[13]=0;
9D007848  30C2FFFF   ANDI V0, A2, -1
9D00784C  2C42000E   SLTIU V0, V0, 14
9D007850  14400002   BNE V0, ZERO, 0x9D00785C
9D007854  A3A0001D   SB ZERO, 29(SP)
9D007858  2406000D   ADDIU A2, ZERO, 13
9D00785C  30C6FFFF   ANDI A2, A2, -1
204:                     d=&str[12];
9D007878  27A2001C   ADDIU V0, SP, 28
9D0078B4  27A2001C   ADDIU V0, SP, 28
205:                     if (width>13){width=13;}
206:                     if (number<0){
9D007860  04A10003   BGEZ A1, 0x9D007870
9D007864  00004021   ADDU T0, ZERO, ZERO
207:                         sign=1;
9D00786C  24080001   ADDIU T0, ZERO, 1
208:                         number = -number;
9D007868  00052823   SUBU A1, ZERO, A1
209:                     }
210:                     //for (i=--width;i>=0||number;i--){
211:                     i=width;
212:                     while (number>0){
9D007870  18A00010   BLEZ A1, 0x9D0078B4
9D007874  00C04821   ADDU T1, A2, ZERO
9D00789C  1CA0FFF8   BGTZ A1, 0x9D007880
9D0078A0  24C6FFFF   ADDIU A2, A2, -1
213:                        *d--=(number%10)+'0';
9D00787C  2403000A   ADDIU V1, ZERO, 10
9D007880  00A3001A   DIV A1, V1
9D007884  006001F4   TEQ V1, ZERO
9D007888  00003810   MFHI A3, 0
9D00788C  00002812   MFLO A1, 0
9D007890  24E70030   ADDIU A3, A3, 48
9D007894  A0470000   SB A3, 0(V0)
9D007898  2442FFFF   ADDIU V0, V0, -1
214:                         number /= 10;
215:                         i--;
216:                     }
217:                     if (i==width){
9D0078A4  15260008   BNE T1, A2, 0x9D0078C8
9D0078A8  24030030   ADDIU V1, ZERO, 48
218:                         *d--='0';
9D0078AC  0B401E30   J 0x9D0078C0
9D0078B0  A0430000   SB V1, 0(V0)
9D0078B8  24030030   ADDIU V1, ZERO, 48
9D0078BC  A0430000   SB V1, 0(V0)
9D0078C0  2442FFFF   ADDIU V0, V0, -1
219:                         i--;
9D0078C4  24C6FFFF   ADDIU A2, A2, -1
220:                     }
221:                     while (i>0){
9D0078C8  1CC0000C   BGTZ A2, 0x9D0078FC
9D0078CC  00000000   NOP
222:                         *d--=' ';
223:                     }
224:                     if (sign){*d='-';}else{*d=' ';}
9D0078D0  11000004   BEQ T0, ZERO, 0x9D0078E4
9D0078D4  24030020   ADDIU V1, ZERO, 32
9D0078D8  2403002D   ADDIU V1, ZERO, 45
9D0078DC  0B401E3A   J 0x9D0078E8
9D0078E0  A0430000   SB V1, 0(V0)
9D0078E4  A0430000   SB V1, 0(V0)
225:                     
226:                     print(channel, d);
9D0078E8  0F401DDD   JAL print
9D0078EC  00402821   ADDU A1, V0, ZERO
227:                 }// print_int()
9D0078F0  8FBF0024   LW RA, 36(SP)
9D0078F4  03E00008   JR RA
9D0078F8  27BD0028   ADDIU SP, SP, 40
9D0078FC  0B401E3F   J 0x9D0078FC
9D007900  00000000   NOP
228:                 
229:                 void set_tab_width(unsigned char width){
230:                     tab_width=width;
231:                 }// set_tab_width()
9D007904  03E00008   JR RA
9D007908  A3848020   SB A0, -32736(GP)
232:                 
233:                 void clear_eol(void){
9D00790C  27BDFFE0   ADDIU SP, SP, -32
9D007910  AFBF001C   SW RA, 28(SP)
9D007914  AFB10018   SW S1, 24(SP)
9D007918  AFB00014   SW S0, 20(SP)
234:                     int x,y;
235:                     x=cx;
9D00791C  9790801C   LHU S0, -32740(GP)
236:                     y=cy;
237:                     while (cx<(X_OFS+CWIDTH*(CHAR_PER_LINE-1))){
9D007920  2E020139   SLTIU V0, S0, 313
9D007924  1040000A   BEQ V0, ZERO, 0x9D007950
9D007928  9791801E   LHU S1, -32738(GP)
9D007940  9782801C   LHU V0, -32740(GP)
9D007944  2C420139   SLTIU V0, V0, 313
9D007948  1440FFF9   BNE V0, ZERO, 0x9D007930
9D00794C  00002021   ADDU A0, ZERO, ZERO
238:                         put_char(LOCAL_CON, 32);
9D00792C  00002021   ADDU A0, ZERO, ZERO
9D007930  0F401D62   JAL put_char
9D007934  24050020   ADDIU A1, ZERO, 32
239:                         cursor_right();
9D007938  0F401D0A   JAL cursor_right
9D00793C  00000000   NOP
240:                     }
241:                     put_char(LOCAL_CON, 32);
9D007950  00002021   ADDU A0, ZERO, ZERO
9D007954  0F401D62   JAL put_char
9D007958  24050020   ADDIU A1, ZERO, 32
242:                     cx=x;
9D00795C  A790801C   SH S0, -32740(GP)
243:                     cy=y;
9D007960  A791801E   SH S1, -32738(GP)
244:                 }// clear_eol()
9D007964  8FBF001C   LW RA, 28(SP)
9D007968  8FB10018   LW S1, 24(SP)
9D00796C  8FB00014   LW S0, 20(SP)
9D007970  03E00008   JR RA
9D007974  27BD0020   ADDIU SP, SP, 32
245:                 
246:                 text_coord_t get_curpos(){
9D007978  00801021   ADDU V0, A0, ZERO
247:                     text_coord_t cpos;
248:                     cpos.x = (cx-X_OFS)/CWIDTH;
9D007994  9783801C   LHU V1, -32740(GP)
9D007998  2463FFFF   ADDIU V1, V1, -1
9D00799C  3C052AAA   LUI A1, 10922
9D0079A0  34A5AAAB   ORI A1, A1, -21845
9D0079A4  00650018   MULT 0, V1, A1
9D0079A8  00031FC3   SRA V1, V1, 31
9D0079AC  00003810   MFHI A3, 0
9D0079B0  00E31823   SUBU V1, A3, V1
9D0079B4  A4430000   SH V1, 0(V0)
249:                     cpos.y = (cy-Y_OFS)/CHEIGHT;
9D00797C  9784801E   LHU A0, -32738(GP)
9D007980  2483FFFD   ADDIU V1, A0, -3
9D007984  24840004   ADDIU A0, A0, 4
9D007988  28650000   SLTI A1, V1, 0
9D00798C  0065200A   MOVZ A0, V1, A1
9D007990  7C8478C0   EXT A0, A0, 3, 16
250:                     return cpos;
251:                 } // get_cursor_pos()
9D0079B8  03E00008   JR RA
9D0079BC  A4440002   SH A0, 2(V0)
252:                 
253:                 void set_curpos(unsigned short x, unsigned short y){// {x,y} coordonnée caractère
9D0079C0  3084FFFF   ANDI A0, A0, -1
254:                     if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
9D0079C4  2C820035   SLTIU V0, A0, 53
9D0079C8  1040000A   BEQ V0, ZERO, 0x9D0079F4
9D0079CC  30A5FFFF   ANDI A1, A1, -1
9D0079D0  2CA2001C   SLTIU V0, A1, 28
9D0079D4  10400007   BEQ V0, ZERO, 0x9D0079F4
9D0079D8  24020006   ADDIU V0, ZERO, 6
255:                         return;
256:                     cx=x*CWIDTH+X_OFS;
9D0079DC  70822002   MUL A0, A0, V0
9D0079E0  24840001   ADDIU A0, A0, 1
9D0079E4  A784801C   SH A0, -32740(GP)
257:                     cy=y*CHEIGHT+Y_OFS;
9D0079E8  000528C0   SLL A1, A1, 3
9D0079EC  24A50003   ADDIU A1, A1, 3
9D0079F0  A785801E   SH A1, -32738(GP)
9D0079F4  03E00008   JR RA
9D0079F8  00000000   NOP
258:                 }//set_curpos()
259:                 
260:                 void invert_char(void){// inverse vidéo du caractère à la position courante
9D007A38  24A30001   ADDIU V1, A1, 1
9D007A3C  2402000A   ADDIU V0, ZERO, 10
9D007A40  70A25002   MUL T2, A1, V0
9D007A44  01461021   ADDU V0, T2, A2
9D007A48  00023080   SLL A2, V0, 2
9D007A4C  3C02A000   LUI V0, -24576
9D007A50  24420080   ADDIU V0, V0, 128
9D007A54  00461021   ADDU V0, V0, A2
9D007A58  24A50009   ADDIU A1, A1, 9
261:                     register int i,l,r,b,x,y;
262:                     x=cx;
9D0079FC  9787801C   LHU A3, -32740(GP)
263:                     y=cy;
9D007A00  9785801E   LHU A1, -32738(GP)
264:                     b=x>>5;
9D007A04  00073143   SRA A2, A3, 5
265:                     r=0;
266:                     l=27-(x&0x1f);
9D007A08  30E7001F   ANDI A3, A3, 31
9D007A0C  2403001B   ADDIU V1, ZERO, 27
9D007A10  00673823   SUBU A3, V1, A3
267:                     if (l<0){
268:                         r=-l;
9D007A14  00071823   SUBU V1, ZERO, A3
9D007A18  28E40000   SLTI A0, A3, 0
9D007A1C  0004180A   MOVZ V1, ZERO, A0
9D007A20  00602021   ADDU A0, V1, ZERO
269:                     }
270:                     for (i=8;i;i--){
9D007A88  1465FFF4   BNE V1, A1, 0x9D007A5C
9D007A8C  24420028   ADDIU V0, V0, 40
271:                         if (r){
9D007A5C  10800007   BEQ A0, ZERO, 0x9D007A7C
9D007A60  8C460000   LW A2, 0(V0)
272:                             video_bmp[y][b] ^= (0x1f>>r);
9D007A24  2403001F   ADDIU V1, ZERO, 31
9D007A28  00834807   SRAV T1, V1, A0
9D007A64  00C93026   XOR A2, A2, T1
9D007A68  AC460000   SW A2, 0(V0)
273:                             video_bmp[y][b+1] ^= (0x1f<<32-r);
9D007A2C  00044023   SUBU T0, ZERO, A0
9D007A30  01034004   SLLV T0, V1, T0
9D007A6C  8C460004   LW A2, 4(V0)
9D007A70  00C83026   XOR A2, A2, T0
9D007A74  0B401EA1   J 0x9D007A84
9D007A78  AC460004   SW A2, 4(V0)
274:                             y++;
275:                         } else{
276:                             video_bmp[y++][b] ^= (0x1f<<l);
9D007A34  00E33804   SLLV A3, V1, A3
9D007A7C  00C73026   XOR A2, A2, A3
9D007A80  AC460000   SW A2, 0(V0)
9D007A84  24630001   ADDIU V1, V1, 1
277:                         }
278:                     }
279:                 }//invert_char()
9D007A90  03E00008   JR RA
9D007A94  00000000   NOP
280:                 
281:                 static void toggle_underscore(void){
282:                     register int l,r,b,x;
283:                     x=cx;
9D0072E0  9782801C   LHU V0, -32740(GP)
284:                     b=x>>5;
9D0072E4  00025143   SRA T2, V0, 5
285:                     r=0;
286:                     l=27-(x&0x1f);
9D0072E8  3042001F   ANDI V0, V0, 31
9D0072EC  2403001B   ADDIU V1, ZERO, 27
9D0072F0  00621023   SUBU V0, V1, V0
287:                     if (l<0){
9D0072F4  0441001B   BGEZ V0, 0x9D007364
9D0072F8  9783801E   LHU V1, -32738(GP)
288:                         r=-l;
9D0072FC  00022023   SUBU A0, ZERO, V0
289:                     }
290:                     if (r){
9D007300  10800018   BEQ A0, ZERO, 0x9D007364
9D007304  2405000A   ADDIU A1, ZERO, 10
291:                         video_bmp[cy+CHEIGHT-1][b] ^= (0x1f>>r);
9D007308  9782801E   LHU V0, -32738(GP)
9D00730C  24420007   ADDIU V0, V0, 7
9D007310  70451002   MUL V0, V0, A1
9D007314  004A3821   ADDU A3, V0, T2
9D007318  00073880   SLL A3, A3, 2
9D00731C  3C06A000   LUI A2, -24576
9D007320  24C60080   ADDIU A2, A2, 128
9D007324  00E63821   ADDU A3, A3, A2
9D007328  2405001F   ADDIU A1, ZERO, 31
9D00732C  00854807   SRAV T1, A1, A0
9D007330  8CE80000   LW T0, 0(A3)
9D007334  01284026   XOR T0, T1, T0
9D007338  ACE80000   SW T0, 0(A3)
292:                         video_bmp[cy+CHEIGHT-1][b+1] ^= (0x1f<<32-r);
9D00733C  25430001   ADDIU V1, T2, 1
9D007340  00431021   ADDU V0, V0, V1
9D007344  00021080   SLL V0, V0, 2
9D007348  00461021   ADDU V0, V0, A2
9D00734C  00042023   SUBU A0, ZERO, A0
9D007350  00852804   SLLV A1, A1, A0
9D007354  8C430000   LW V1, 0(V0)
9D007358  00A32826   XOR A1, A1, V1
9D00735C  03E00008   JR RA
9D007360  AC450000   SW A1, 0(V0)
293:                     } else{
294:                         video_bmp[cy+CHEIGHT-1][b] ^= (0x1f<<l);
9D007364  24630007   ADDIU V1, V1, 7
9D007368  2404000A   ADDIU A0, ZERO, 10
9D00736C  70642802   MUL A1, V1, A0
9D007370  00AA1821   ADDU V1, A1, T2
9D007374  00031880   SLL V1, V1, 2
9D007378  3C04A000   LUI A0, -24576
9D00737C  24840080   ADDIU A0, A0, 128
9D007380  00641821   ADDU V1, V1, A0
9D007384  2404001F   ADDIU A0, ZERO, 31
9D007388  00441004   SLLV V0, A0, V0
9D00738C  8C640000   LW A0, 0(V1)
9D007390  00441026   XOR V0, V0, A0
9D007394  03E00008   JR RA
9D007398  AC620000   SW V0, 0(V1)
295:                     }
296:                 }//toggle_underscore()
297:                 
298:                 void show_cursor(BOOL show){
9D007A98  27BDFFE8   ADDIU SP, SP, -24
9D007A9C  AFBF0014   SW RA, 20(SP)
299:                     if (show){
9D007AA0  10800011   BEQ A0, ZERO, 0x9D007AE8
9D007AA4  AFB00010   SW S0, 16(SP)
300:                         flags |= CUR_SHOW;
9D007AA8  9782803A   LHU V0, -32710(GP)
9D007AAC  34420001   ORI V0, V0, 1
301:                         flags ^= CUR_VIS;
9D007AB0  38420002   XORI V0, V0, 2
9D007AB4  A782803A   SH V0, -32710(GP)
302:                         if (cur_shape==CR_BLOCK){
9D007AB8  24020001   ADDIU V0, ZERO, 1
9D007ABC  8F83803C   LW V1, -32708(GP)
9D007AC0  14620005   BNE V1, V0, 0x9D007AD8
9D007AC4  00000000   NOP
303:                             invert_char();
9D007AC8  0F401E7F   JAL invert_char
9D007ACC  00000000   NOP
304:                         }else{
305:                             toggle_underscore();
9D007AD8  0F401CB8   JAL 0x9D0072E0
9D007ADC  00000000   NOP
306:                         }
307:                     }else{
308:                         if (flags & CUR_VIS){
9D007AE8  9790803A   LHU S0, -32710(GP)
9D007AEC  32020002   ANDI V0, S0, 2
9D007AF0  1040000D   BEQ V0, ZERO, 0x9D007B28
9D007AF4  9782803A   LHU V0, -32710(GP)
309:                             if (cur_shape==CR_BLOCK){
9D007AF8  24020001   ADDIU V0, ZERO, 1
9D007AFC  8F83803C   LW V1, -32708(GP)
9D007B00  14620005   BNE V1, V0, 0x9D007B18
9D007B04  00000000   NOP
310:                                 invert_char();
9D007B08  0F401E7F   JAL invert_char
9D007B0C  3210FFFD   ANDI S0, S0, -3
311:                             }else{
312:                                 toggle_underscore();
9D007B18  0F401CB8   JAL 0x9D0072E0
9D007B1C  3210FFFD   ANDI S0, S0, -3
313:                             }
314:                             flags &= ~CUR_VIS;
9D007B10  0B401EC9   J 0x9D007B24
9D007B14  A790803A   SH S0, -32710(GP)
9D007B20  A790803A   SH S0, -32710(GP)
315:                         }
316:                         flags &= ~CUR_SHOW;
9D007B24  9782803A   LHU V0, -32710(GP)
9D007B28  3042FFFE   ANDI V0, V0, -2
9D007B2C  A782803A   SH V0, -32710(GP)
317:                     }
318:                 
319:                 }// show_cursor()
9D007AD0  0B401ECD   J 0x9D007B34
9D007AD4  8FBF0014   LW RA, 20(SP)
9D007AE0  0B401ECD   J 0x9D007B34
9D007AE4  8FBF0014   LW RA, 20(SP)
9D007B30  8FBF0014   LW RA, 20(SP)
9D007B34  8FB00010   LW S0, 16(SP)
9D007B38  03E00008   JR RA
9D007B3C  27BD0018   ADDIU SP, SP, 24
320:                 
321:                 void set_cursor(cursor_t shape){
9D007B40  27BDFFE8   ADDIU SP, SP, -24
9D007B44  AFBF0014   SW RA, 20(SP)
9D007B48  AFB00010   SW S0, 16(SP)
322:                     if (flags & CUR_VIS){
9D007B4C  9782803A   LHU V0, -32710(GP)
9D007B50  30420002   ANDI V0, V0, 2
9D007B54  10400008   BEQ V0, ZERO, 0x9D007B78
9D007B58  00808021   ADDU S0, A0, ZERO
323:                         show_cursor(FALSE);
9D007B5C  0F401EA6   JAL show_cursor
9D007B60  00002021   ADDU A0, ZERO, ZERO
324:                         cur_shape=shape;
9D007B64  AF90803C   SW S0, -32708(GP)
325:                         show_cursor(TRUE);
9D007B68  0F401EA6   JAL show_cursor
9D007B6C  24040001   ADDIU A0, ZERO, 1
326:                     }else{
327:                         cur_shape=shape;
9D007B78  AF84803C   SW A0, -32708(GP)
328:                     }
329:                 }// set_cursor()
9D007B70  0B401EE0   J 0x9D007B80
9D007B74  8FBF0014   LW RA, 20(SP)
9D007B7C  8FBF0014   LW RA, 20(SP)
9D007B80  8FB00010   LW S0, 16(SP)
9D007B84  03E00008   JR RA
9D007B88  27BD0018   ADDIU SP, SP, 24
330:                 
331:                 unsigned short get_key(dev_t channel){ // lecture touche clavier, retourne 0 s'il n'y a pas de touche ou touche relâchée.
9D007B8C  27BDFFE8   ADDIU SP, SP, -24
9D007B90  7C042420   SEB A0, A0
332:                     unsigned short code;
333:                     if (channel==LOCAL_CON){
9D007B94  1480000C   BNE A0, ZERO, 0x9D007BC8
9D007B98  AFBF0014   SW RA, 20(SP)
334:                         code=  KbdScancode();
9D007B9C  0F4017A8   JAL KbdScancode
9D007BA0  00000000   NOP
9D007BA4  00402021   ADDU A0, V0, ZERO
9D007BA8  3042FFFF   ANDI V0, V0, -1
335:                         if (!(code & FN_BIT)){
9D007BAC  30430200   ANDI V1, V0, 512
9D007BB0  14600009   BNE V1, ZERO, 0x9D007BD8
9D007BB4  8FBF0014   LW RA, 20(SP)
336:                             code = KbdKey(code);
9D007BB8  0F401681   JAL KbdKey
9D007BBC  00000000   NOP
9D007BC0  0B401EF5   J 0x9D007BD4
9D007BC4  3042FFFF   ANDI V0, V0, -1
337:                         }
338:                     }else{
339:                         code=UartGetch(STDIN);
9D007BC8  0F4021AD   JAL UartGetch
9D007BCC  24040001   ADDIU A0, ZERO, 1
9D007BD0  3042FFFF   ANDI V0, V0, -1
340:                         if (code==-1){
341:                             code=0;
342:                         }
343:                     }
344:                     return code;
345:                 }//get_key()
9D007BD4  8FBF0014   LW RA, 20(SP)
9D007BD8  03E00008   JR RA
9D007BDC  27BD0018   ADDIU SP, SP, 24
346:                 
347:                 unsigned short wait_key(dev_t channel){ // attend qu'une touche soit enfoncée et retourne sa valeur.
9D007BE0  27BDFFE0   ADDIU SP, SP, -32
9D007BE4  AFBF001C   SW RA, 28(SP)
9D007BE8  AFB10018   SW S1, 24(SP)
9D007BEC  AFB00014   SW S0, 20(SP)
348:                     unsigned short key;
349:                     unsigned int t0;
350:                     t0=ticks()+500;
9D007BF0  0F402462   JAL ticks
9D007BF4  7C048420   SEB S0, A0
351:                     if (channel==LOCAL_CON){
9D007BF8  12000013   BEQ S0, ZERO, 0x9D007C48
9D007BFC  245101F4   ADDIU S1, V0, 500
352:                         while (!(key=get_key(channel))){
9D007C48  0F401EE3   JAL get_key
9D007C4C  00002021   ADDU A0, ZERO, ZERO
9D007C50  1040FFED   BEQ V0, ZERO, 0x9D007C08
9D007C54  00408021   ADDU S0, V0, ZERO
353:                             if (ticks()==t0){
9D007C08  0F402462   JAL ticks
9D007C0C  00000000   NOP
9D007C10  1451000D   BNE V0, S1, 0x9D007C48
9D007C14  9782803A   LHU V0, -32710(GP)
354:                                 if (flags & CUR_SHOW){
9D007C18  30420001   ANDI V0, V0, 1
9D007C1C  10400005   BEQ V0, ZERO, 0x9D007C34
9D007C20  00000000   NOP
355:                                     show_cursor(FALSE);
9D007C24  0F401EA6   JAL show_cursor
9D007C28  00002021   ADDU A0, ZERO, ZERO
9D007C2C  0B401F0F   J 0x9D007C3C
9D007C30  00000000   NOP
356:                                 }else{
357:                                     show_cursor(TRUE);
9D007C34  0F401EA6   JAL show_cursor
9D007C38  24040001   ADDIU A0, ZERO, 1
358:                                 }
359:                                 t0=ticks()+500;
9D007C3C  0F402462   JAL ticks
9D007C40  00000000   NOP
9D007C44  245101F4   ADDIU S1, V0, 500
360:                             }
361:                         };
362:                         show_cursor(FALSE);
9D007C58  0F401EA6   JAL show_cursor
9D007C5C  00002021   ADDU A0, ZERO, ZERO
363:                     }else{
364:                         key=UartWaitch(STDIN,0);
9D007C00  0B401F1A   J 0x9D007C68
9D007C04  24040001   ADDIU A0, ZERO, 1
9D007C68  0F4021C8   JAL UartWaitch
9D007C6C  00002821   ADDU A1, ZERO, ZERO
9D007C70  3050FFFF   ANDI S0, V0, -1
365:                     }
366:                     return key;
367:                 }//wait_key()
9D007C60  0B401F1E   J 0x9D007C78
9D007C64  02001021   ADDU V0, S0, ZERO
9D007C74  02001021   ADDU V0, S0, ZERO
9D007C78  8FBF001C   LW RA, 28(SP)
9D007C7C  8FB10018   LW S1, 24(SP)
9D007C80  8FB00014   LW S0, 20(SP)
9D007C84  03E00008   JR RA
9D007C88  27BD0020   ADDIU SP, SP, 32
368:                 
369:                 unsigned char readline(dev_t channel, unsigned char *ibuff,unsigned char max_char){ // lit une ligne au clavier, retourne la longueur de texte.
9D007C8C  27BDFFD0   ADDIU SP, SP, -48
9D007C90  AFBF002C   SW RA, 44(SP)
9D007C94  AFB50028   SW S5, 40(SP)
9D007C98  AFB40024   SW S4, 36(SP)
9D007C9C  AFB30020   SW S3, 32(SP)
9D007CA0  AFB2001C   SW S2, 28(SP)
9D007CA4  AFB10018   SW S1, 24(SP)
9D007CA8  AFB00014   SW S0, 20(SP)
9D007CAC  00A09821   ADDU S3, A1, ZERO
9D007CB0  7C042420   SEB A0, A0
370:                     unsigned char c=0, count=0;
371:                     if (channel==LOCAL_CON){
9D007CB4  14800025   BNE A0, ZERO, 0x9D007D4C
9D007CB8  30D400FF   ANDI S4, A2, 255
9D007CBC  00008021   ADDU S0, ZERO, ZERO
372:                         while ((c!='\r') && (count<=max_char)){
9D007D18  0B401F4F   J 0x9D007D3C
9D007D1C  0290102B   SLTU V0, S4, S0
9D007D38  0290102B   SLTU V0, S4, S0
9D007D3C  1040FFE4   BEQ V0, ZERO, 0x9D007CD0
9D007D40  00000000   NOP
373:                             c=wait_key(channel);
9D007CD0  0F401EF8   JAL wait_key
9D007CD4  00002021   ADDU A0, ZERO, ZERO
9D007CD8  304200FF   ANDI V0, V0, 255
374:                             if (c==CR){
9D007CC0  2411000D   ADDIU S1, ZERO, 13
9D007CDC  14510005   BNE V0, S1, 0x9D007CF4
9D007CE0  00002021   ADDU A0, ZERO, ZERO
375:                                 put_char(channel,'\r');
9D007CE4  0F401D62   JAL put_char
9D007CE8  2405000D   ADDIU A1, ZERO, 13
376:                                 break;
9D007CEC  0B401F57   J 0x9D007D5C
9D007CF0  A2600000   SB ZERO, 0(S3)
377:                             }else if (c==BS){
9D007CC4  24120008   ADDIU S2, ZERO, 8
9D007CF4  5452000A   BNEL V0, S2, 0x9D007D20
9D007CF8  A2620000   SB V0, 0(S3)
378:                                 if (count){
9D007CFC  1200FFF4   BEQ S0, ZERO, 0x9D007CD0
9D007D00  00002021   ADDU A0, ZERO, ZERO
379:                                     ibuff--;
9D007D04  2673FFFF   ADDIU S3, S3, -1
380:                                     count--;
9D007D08  2610FFFF   ADDIU S0, S0, -1
9D007D0C  321000FF   ANDI S0, S0, 255
381:                                     print(channel,"\b \b");
9D007CC8  3C159D01   LUI S5, -25343
9D007CCC  26B5ADF0   ADDIU S5, S5, -21008
9D007D10  0F401DDD   JAL print
9D007D14  02A02821   ADDU A1, S5, ZERO
382:                                 }
383:                             }else if ((c & FN_BIT)==0){
384:                                 *ibuff++=c;
9D007D20  26730001   ADDIU S3, S3, 1
385:                                 count++;
9D007D24  26100001   ADDIU S0, S0, 1
9D007D28  321000FF   ANDI S0, S0, 255
386:                                 put_char(channel, c);
9D007D2C  00002021   ADDU A0, ZERO, ZERO
9D007D30  0F401D62   JAL put_char
9D007D34  7C022C20   SEB A1, V0
387:                             }
388:                         }// while
389:                         *ibuff=(char)0;
9D007D44  0B401F57   J 0x9D007D5C
9D007D48  A2600000   SB ZERO, 0(S3)
390:                     }else{
391:                         count=UartReadln(STDIN,ibuff,max_char);
9D007D4C  24040001   ADDIU A0, ZERO, 1
9D007D50  0F40220E   JAL UartReadln
9D007D54  02803021   ADDU A2, S4, ZERO
9D007D58  305000FF   ANDI S0, V0, 255
392:                     }
393:                     return count;
394:                 } // readline()
9D007D5C  02001021   ADDU V0, S0, ZERO
9D007D60  8FBF002C   LW RA, 44(SP)
9D007D64  8FB50028   LW S5, 40(SP)
9D007D68  8FB40024   LW S4, 36(SP)
9D007D6C  8FB30020   LW S3, 32(SP)
9D007D70  8FB2001C   LW S2, 28(SP)
9D007D74  8FB10018   LW S1, 24(SP)
9D007D78  8FB00014   LW S0, 20(SP)
9D007D7C  03E00008   JR RA
9D007D80  27BD0030   ADDIU SP, SP, 48
