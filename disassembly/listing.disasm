Disassembly Listing for vpc-32
Generated From:
C:/Users/Jacques/Documents/GitHub/VPC-32.X/dist/default/production/VPC-32.X.production.elf
2013-09-01 10:36:03

---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/uart.h  ---------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: Constants & Data Types
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  //DOM-IGNORE-BEGIN
74:                  /****
75:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
76:                         the device file.  Also the UART register set could also be placed there
77:                  *****/
78:                  typedef struct
79:                  {
80:                  	volatile UINT	reg;
81:                  	volatile UINT	clr;
82:                  	volatile UINT	set;
83:                  	volatile UINT	inv;
84:                  }REG_SET;
85:                  
86:                  typedef struct
87:                  {
88:                  	volatile REG_SET	mode;
89:                  	volatile REG_SET	sta;
90:                  	volatile REG_SET    tx;
91:                  	volatile REG_SET	rx;
92:                  	volatile REG_SET	brg;
93:                  }UART_REGS;
94:                  
95:                  extern UART_REGS * const uartReg[];
96:                  //DOM-IGNORE-END
97:                  
98:                  // *****************************************************************************
99:                  /* UART Module
100:                 
101:                   Summary:
102:                     UART modules supported.
103:                 
104:                   Description:
105:                     This enumeration identifies the available UART modules.
106:                 */
107:                 
108:                 typedef enum
109:                 {
110:                 #if defined _UART1
111:                     // UART1 Module ID.
112:                     UART1 = 0,
113:                 #endif
114:                 #if defined _UART2
115:                     // UART2 Module ID.
116:                     UART2,
117:                 #endif
118:                 #ifdef _UART3
119:                     // UART3 Module ID.
120:                     UART3,
121:                 #endif
122:                 #ifdef _UART4
123:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
124:                     UART4,
125:                 #endif
126:                 #ifdef _UART5
127:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
128:                     UART5,
129:                 #endif
130:                 #ifdef _UART6
131:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
132:                     UART6,
133:                 #endif
134:                     // Number of available UART modules.
135:                     UART_NUMBER_OF_MODULES
136:                 
137:                 } UART_MODULE;
138:                 
139:                 
140:                 // *****************************************************************************
141:                 /* UART Enable Modes
142:                 
143:                   Summary:
144:                     Operating modes of UART.
145:                 
146:                   Description:
147:                     This enumeration defines the supported modes in which the UART may be
148:                     enabled or disbled.
149:                 
150:                   Remarks:
151:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
152:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
153:                     has been pre-loaded with data.
154:                 
155:                     The caller should not rely on the specific numbers assigned to any of these
156:                     values as they may change from one processor to the next.
157:                 */
158:                 
159:                 typedef enum
160:                 {
161:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
162:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
163:                 
164:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
165:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
166:                 
167:                 
168:                     // UART Module, receiver and transmitter functionality is not.
169:                     // enabled or disabled
170:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
171:                 
172:                     // UART Module receiver.
173:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
174:                 
175:                     // UART Module transmitter.
176:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
177:                 
178:                 
179:                 } UART_ENABLE_MODE;
180:                 
181:                 // *****************************************************************************
182:                 /* UART Enable Helper Macro
183:                 
184:                   Summary:
185:                     Macro for enabling module operating modes.
186:                 
187:                   Description:
188:                     This macro creates the proper flags for enabling operating modes of the UART module.
189:                 
190:                   Example:
191:                     <code>
192:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
193:                     </code>
194:                 
195:                   Remarks:
196:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
197:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
198:                     has been pre-loaded with data.
199:                 */
200:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
201:                 
202:                 // *****************************************************************************
203:                 /* UART Disable Helper Macro
204:                 
205:                   Summary:
206:                     Macro for disabling module operating modes.
207:                 
208:                   Description:
209:                     This macro creates the proper flags for disabling operating modes of the UART module.
210:                 
211:                   Example:
212:                     <code>
213:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
214:                     </code>
215:                 
216:                 */
217:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
218:                 
219:                 // *****************************************************************************
220:                 /* UART Configuration Settings
221:                 
222:                   Summary:
223:                     Supported configuration flags for the UART module.
224:                 
225:                   Description:
226:                     This enumeration defines the various configuration options for the UART
227:                     module.  These values can be OR'd together to create a configuration mask
228:                     passed to the UARTConfigure routine.
229:                 
230:                   Remarks:
231:                     Several of the configuration options are mutually exclusive:
232:                     * Only one of the "ENABLE_PINS" modes can be used at a time
233:                     * Only one of the "RTS_WHEN" modes can be used at a time
234:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
235:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
236:                 
237:                     The caller should not rely on the specific numbers assigned to any of these
238:                     values as they may change from one processor ot the next.
239:                 */
240:                 
241:                 typedef enum
242:                 {
243:                     // Enables high-speed range of the UART (see UARTSetBitRate).
244:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
245:                 
246:                     // Inverts polarity of data interpretation the received (RX) pin.
247:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
248:                 
249:                     // Enables UART TX-to-RX Loop-back mode.
250:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
251:                 
252:                     // Enables Wake-up of the part when a start bit is received.
253:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
254:                 
255:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
256:                     // cannot be used in bit-clock/IrDA mode).
257:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
258:                 
259:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
260:                     // cannot be used in CTS/RTS mode).
261:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
262:                 
263:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
264:                     // be used in RTS-Only mode).
265:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
266:                 
267:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
268:                     // the default mode and this parameter can be left out if it is desired).
269:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
270:                 
271:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
272:                     // is not full (i.e., the UART is ready to receive data).  This is also known
273:                     // as "RTS Flow-Control Mode".
274:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
275:                 
276:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
277:                     // is not empty (i.e., when the UART has data ready to send).  This is also
278:                     // known as "RTS Simplex Mode".
279:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
280:                 
281:                     // Enable the IrDA encoder/decoder.
282:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
283:                 
284:                     // Enables stopping of the UART operation to save power when the core has
285:                     // been put in idle mode.
286:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
287:                 
288:                     // Inverts the polarity of data sent on the transmit (TX) pin.
289:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
290:                 
291:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
292:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
293:                     // Note:  The address must still be set using UARTEnableAddressDetect
294:                     // to support IEEE-485 protocol.
295:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
296:                 
297:                 } UART_CONFIGURATION;
298:                 
299:                 
300:                 // *****************************************************************************
301:                 /* UART FIFO Modes
302:                 
303:                   Summary:
304:                     Supported FIFO modes for the UART module.
305:                 
306:                   Description:
307:                     This enumeration defines supported FIFO modes that determine when the Tx
308:                     and Rx interrupts will occur.
309:                 
310:                   Remarks:
311:                     These modes consist of two sets of mutially exclusive modes:
312:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
313:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
314:                 
315:                     The caller should not rely on the specific numbers assigned to any of these
316:                     values as they may change from one processor ot the next.
317:                 
318:                 */
319:                 
320:                 typedef enum
321:                 {
322:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
323:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
324:                 
325:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
326:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
327:                 
328:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
329:                     // full (i.e. there is space available for more data)  This is the default.
330:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
331:                 
332:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
333:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
334:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
337:                     // (three-quarter) full.
338:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
339:                 
340:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
341:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
342:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
343:                 
344:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
345:                     // data.
346:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
347:                 
348:                 } UART_FIFO_MODE;
349:                 
350:                 
351:                 // *****************************************************************************
352:                 /* UART Line Control Mode
353:                 
354:                   Summary:
355:                     UART line control mode.
356:                 
357:                   Description:
358:                     This data type defines the supported line control modes for the UART.
359:                 
360:                   Remarks:
361:                     Some of the line-control options are mutually exclusive:
362:                     * Only one of the "DATA_SIZE" options can be used at a time
363:                     * Only one of the "PARITY" options can be used at a time
364:                     * Only one of the "STOP_BITS" options can be used at a time
365:                 
366:                     The caller should not rely on the specific numbers assigned to any of these
367:                     values as they may change from one processor ot the next.
368:                 */
369:                 
370:                 typedef enum
371:                 {
372:                     // Sets the data transfer size to 8-bits per frame.
373:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
374:                 
375:                     // Sets the data transfer size to 9-bits per frame.
376:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
377:                 
378:                     // Enables parity bit generation for odd parity.
379:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
380:                 
381:                     // Enables parity bit generation for even parity.
382:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
383:                 
384:                     // Disables parity bit generation.
385:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
386:                 
387:                     // Enables generation of 2 stop bits per frame.
388:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
389:                 
390:                     // Enables generation of 1 stop bit per frame (default).
391:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
392:                 
393:                 } UART_LINE_CONTROL_MODE;
394:                 
395:                 
396:                 // *****************************************************************************
397:                 /* UART Line Status Flags
398:                 
399:                   Summary:
400:                     UART line-status bitmask flags.
401:                 
402:                   Description:
403:                     This enumeration defines the UART line-status bits.  These values are
404:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
405:                 
406:                   Remarks:
407:                     The caller should not rely on the specific numbers assigned to any of these
408:                     values as they may change from one processor ot the next.
409:                 */
410:                 
411:                 typedef enum
412:                 {
413:                     // The transmitter is able to accept data to transmit.
414:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
415:                 
416:                     // The transmitter is empty (no data is available to transmit).
417:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
418:                 
419:                     // The receiver is currently idle.
420:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
421:                 
422:                     // A received data parity error was detected.
423:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
424:                 
425:                     // Data was received that violated the framing protocol (the data word did
426:                     // not start or stop at the appropriate place).  Note:  A break condition
427:                     // will always indicate a framing error.
428:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
429:                 
430:                     // The UART has received more data than it can buffer.  Data has been lost.
431:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
432:                 
433:                     // UART data has been received and is avaiable in the FIFO.
434:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
435:                 
436:                 } UART_LINE_STATUS;
437:                 
438:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
439:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
440:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
441:                 
442:                 
443:                 
444:                 // *****************************************************************************
445:                 /* UART Data
446:                 
447:                   Summary:
448:                     UART data.
449:                 
450:                   Description:
451:                     This data type defines the supported data sizes for the UART.
452:                 */
453:                 
454:                 typedef union
455:                 {
456:                     // 8-bit data
457:                     struct
458:                     {
459:                         UINT16  data8bit    : 8;
460:                     };
461:                 
462:                     // 9-bit data
463:                     struct
464:                     {
465:                         UINT16  data9bit    : 9;
466:                     };
467:                 
468:                     UINT16 __data;
469:                 } UART_DATA;
470:                 
471:                 
472:                 // *****************************************************************************
473:                 // *****************************************************************************
474:                 // Section: UART Peripheral Library Interface Routines
475:                 // *****************************************************************************
476:                 // *****************************************************************************
477:                 
478:                 
479:                 /*******************************************************************************
480:                   Function:
481:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
482:                 
483:                   Summary:
484:                     Enables or disables the given UART module in the desired mode.
485:                 
486:                   Description:
487:                     This routine enables or disables the given UART module in the desired mode.
488:                 
489:                   Precondition:
490:                     The UART module should be appropriately configured before being enabled.
491:                 
492:                   Parameters:
493:                     id    - Identifies the desired UART module.
494:                 
495:                     mode  - Identifies the desired mode of UART operation.
496:                 
497:                   Returns:
498:                     None
499:                 
500:                   Example:
501:                     <code>
502:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
503:                     </code>
504:                 
505:                   Remarks:
506:                     Enabling UART transmissions will immediately cause a TX interrupt to
507:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
508:                     was pre-loaded with data.
509:                   *****************************************************************************/
510:                 
511:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
512:                 
513:                 
514:                 /*******************************************************************************
515:                   Function:
516:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
517:                 
518:                   Summary:
519:                     UART module configuration routine.
520:                 
521:                   Description:
522:                     This routine allows the caller to configure various features of the UART
523:                     module for desired operation.
524:                 
525:                   Precondition:
526:                     None
527:                 
528:                   Parameters:
529:                     id      - Identifies the desired UART module.
530:                 
531:                     flags   - Bit-wise OR of the desired module configuration settings.
532:                 
533:                   Returns:
534:                     None
535:                 
536:                   Example:
537:                     <code>
538:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
539:                     </code>
540:                 
541:                   Remarks:
542:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
543:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
544:                     of these values will result in a value that is not explicitly defined in
545:                     the enumeration.
546:                   *****************************************************************************/
547:                 
548:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
549:                 
550:                 
551:                 /*******************************************************************************
552:                   Function:
553:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
554:                 
555:                   Summary:
556:                     Controls UART module TX and RX FIFO operation.
557:                 
558:                   Description:
559:                     This routine allows the caller to configure when interrupts occur relative
560:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
561:                     or empty the FIFOs are).
562:                 
563:                   Precondition:
564:                     None
565:                 
566:                   Parameters:
567:                     id      - Identifies the desired UART module.
568:                 
569:                     mode    - Bit-wise OR of the desired FIFO mode values.
570:                 
571:                   Returns:
572:                     None
573:                 
574:                   Example:
575:                     <code>
576:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
577:                     </code>
578:                 
579:                   Remarks:
580:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
581:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
582:                     of these values will result in a value that is not explicitly defined in
583:                     the enumeration.
584:                   *****************************************************************************/
585:                 
586:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
587:                 
588:                 
589:                 /*******************************************************************************
590:                   Function:
591:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
592:                 
593:                   Summary:
594:                     Routine to set the UART module's desired data data rate.
595:                 
596:                   Description:
597:                     This routine allows the caller to set the desired data rate for the UART.
598:                 
599:                   Precondition:
600:                     The source clock's frequency must be operating at the frequency passed in the
601:                     "sourceClock" parameter.
602:                 
603:                   Parameters:
604:                     id          - Identifies the desired UART module.
605:                 
606:                     sourceClock - Frequency (Hz) of the source clock being provided to the
607:                                   UART module.
608:                 
609:                     dataRate     - Desired data rate (bits per second).
610:                 
611:                   Returns:
612:                     Actual bit rate selected
613:                 
614:                   Example:
615:                     <code>
616:                 	#define PERIPHERAL_CLOCK    10000000
617:                 	#define DESIRED_DATA_RATE   19200
618:                 	
619:                 	UINT32    actualDataRate;
620:                 
621:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
622:                     </code>
623:                 
624:                   Remarks:
625:                     Actual data rate selected may be slightly different than the data rate
626:                     requested due to truncation error.
627:                 
628:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
629:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
630:                     the maximum data rate is sourceClock/4.
631:                   *****************************************************************************/
632:                 
633:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
634:                 
635:                 
636:                 /*******************************************************************************
637:                   Function:
638:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
639:                 
640:                   Summary:
641:                     Routine to get the UART module's current data data rate.
642:                 
643:                   Description:
644:                     This routine allows the caller to get the current data rate for the UART module.
645:                 
646:                   Precondition:
647:                     The source clock's frequency must be operating at the frequency passed in the
648:                     "sourceClock" parameter.
649:                 
650:                   Parameters:
651:                     id          - Identifies the desired UART module.
652:                 
653:                     sourceClock - Frequency (Hz) of the source clock being provided to the
654:                                   UART module.
655:                 
656:                   Returns:
657:                     The UART's current data rate (bits per second).
658:                 
659:                   Example:
660:                     <code>
661:                 	#define PERIPHERAL_CLOCK    10000000
662:                 	
663:                 	UINT32    currentDataRate;
664:                 
665:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
666:                     </code>
667:                 
668:                   Remarks:
669:                     The current (actual) data rate returned may be slightly different than bit
670:                     rate requested due to truncation error.
671:                   *****************************************************************************/
672:                 
673:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
674:                 
675:                 
676:                 /*******************************************************************************
677:                   Function:
678:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
679:                 
680:                   Summary:
681:                     Routine to set the UART module's desired line control parameters.
682:                 
683:                   Description:
684:                     This routine allows the caller to select the desired size of the UART data
685:                     frame, the generation of parity and framing parameters (collectively
686:                     referred to as the "line control" mode).
687:                 
688:                   Precondition:
689:                 
690:                   Parameters:
691:                     id      - Identifies the desired UART module.
692:                 
693:                     mode    - This is a bit-wise OR of the desired line control mode flags.
694:                 
695:                   Returns:
696:                     None
697:                 
698:                   Example:
699:                     <code>
700:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
701:                     </code>
702:                 
703:                   Remarks:
704:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
705:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
706:                     of these values will result in a value that is not explicitly defined in
707:                     the enumeration.
708:                   *****************************************************************************/
709:                 
710:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
711:                 
712:                 
713:                 /*******************************************************************************
714:                   Function:
715:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
716:                 
717:                   Summary:
718:                     Provides current UART line status.
719:                 
720:                   Description:
721:                     This routine allows the caller to get the current line status of the UART,
722:                     indicating the current state of the transmitter and receiver buffers, and
723:                     if any errors have occurred.
724:                 
725:                   Precondition:
726:                     None
727:                 
728:                   Parameters:
729:                     id      - Identifies the desired UART module.
730:                 
731:                   Returns:
732:                     A bit-wise OR of the current line status flags.
733:                 
734:                   Example:
735:                     <code>
736:                     UART_LINE_STATUS lineStatus;
737:                 	
738:                 	lineStatus = UARTGetLineStatus(UART1);
739:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
740:                     {
741:                         // Handle receiver error
742:                     }
743:                     </code>
744:                 
745:                   Remarks:
746:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
747:                     status flag.
748:                 
749:                     The receiver line status flags are only valid when data has been received
750:                     and for the data at the top of the RX FIFO.
751:                 
752:                     Note that the bitmask resulting from the bit-wise OR of these values will
753:                     result in a value that is not explicitly defined in the enumeration.
754:                   *****************************************************************************/
755:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
756:                 {
757:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
758:                 }
759:                 
760:                 
761:                 /*******************************************************************************
762:                   Function:
763:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
764:                 
765:                   Summary:
766:                     Routine to detect if the transmitter is ready to accept data to transmit.
767:                 
768:                   Description:
769:                     This routine determines if the transmitter is ready to accept more data to
770:                     be transmitted.
771:                 
772:                   Precondition:
773:                     The UART module should have been appropriately configured and enabled.
774:                 
775:                   Parameters:
776:                     id      - Identifies the desired UART module.
777:                 
778:                   Returns:
779:                     Boolean identifying whether or not the transmitter is ready:
780:                     * TRUE    - If the transmitter is ready to accept more data
781:                     * FALSE   - If the transmitter is not ready to accept more data
782:                 
783:                   Example:
784:                     <code>
785:                     unsigned char data;
786:                 	
787:                 	data = 'a';
788:                 	
789:                 	if (UARTTransmitterIsReady(UART1))
790:                     {
791:                         UARTSendDataByte(UART1, data);
792:                     }
793:                     </code>
794:                 
795:                   Remarks:
796:                   *****************************************************************************/
797:                 
798:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
799:                 {
800:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D001470  00042080   SLL A0, A0, 2
9D001474  3C029D00   LUI V0, -25344
9D001478  24422834   ADDIU V0, V0, 10292
9D00147C  00822021   ADDU A0, A0, V0
9D001480  8C830000   LW V1, 0(A0)
9D001484  8C620010   LW V0, 16(V1)
9D001488  30420200   ANDI V0, V0, 512
9D00155C  3C029D00   LUI V0, -25344
9D001560  24422834   ADDIU V0, V0, 10292
9D001564  00621021   ADDU V0, V1, V0
9D001568  8C430000   LW V1, 0(V0)
9D00156C  8C620010   LW V0, 16(V1)
9D001570  30420200   ANDI V0, V0, 512
801:                 }
802:                 
803:                 
804:                 /*******************************************************************************
805:                   Function:
806:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
807:                 
808:                   Summary:
809:                     Routine to send a byte of data.
810:                 
811:                   Description:
812:                     This routine allows the caller to send a byte of data.
813:                 
814:                   Precondition:
815:                     The UART should have been appropriately configured.  The configuration must
816:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
817:                     have been ready, although not necessarily enabled yet.
818:                 
819:                   Parameters:
820:                     id      - Identifies the desired UART module.
821:                 
822:                     data    - Data byte to be sent.
823:                 
824:                   Returns:
825:                     None
826:                 
827:                   Example:
828:                     <code>
829:                 	unsigned char data;
830:                 	
831:                 	data = 'a';
832:                 	
833:                     if (UARTTransmitterIsReady(UART1))
834:                     {
835:                         UARTSendDataByte(UART1, data);
836:                     }
837:                     </code>
838:                 
839:                   Remarks:
840:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
841:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
842:                     data.
843:                   *****************************************************************************/
844:                 
845:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
846:                 {
847:                     uartReg[id]->tx.reg = data;
9D001494  30A500FF   ANDI A1, A1, 255
9D001498  AC650020   SW A1, 32(V1)
9D001580  30C600FF   ANDI A2, A2, 255
9D001584  AC660020   SW A2, 32(V1)
848:                 }
849:                 
850:                 
851:                 /*******************************************************************************
852:                   Function:
853:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
854:                 
855:                   Summary:
856:                     Routine to send data through the UART.
857:                 
858:                   Description:
859:                     This routine allows the caller to send data of any permitted size through
860:                     the UART.
861:                 
862:                   Precondition:
863:                     The UART module should have been appropriately configured.  The configuration must
864:                     have been for desired data size.  The transmitter must have been ready,
865:                     although not necessarily enabled yet.
866:                 
867:                   Parameters:
868:                     id      - Identifies the desired UART module.
869:                 
870:                     data    - Data to be sent.
871:                 
872:                   Returns:
873:                     None
874:                 
875:                   Example:
876:                     <code>
877:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
878:                 	
879:                 	if (UARTTransmitterIsReady(UART1))
880:                     {
881:                         UARTSendData(UART1, data);
882:                     }
883:                     </code>
884:                 
885:                   Remarks:
886:                     Size of the data word size depends on the current configuration (see
887:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
888:                   *****************************************************************************/
889:                 
890:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
891:                 {
892:                     uartReg[id]->tx.reg = data.__data;
893:                 }
894:                 
895:                 /*******************************************************************************
896:                   Function:
897:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
898:                 
899:                   Summary:
900:                     Routine to detect if the UART module has finshed transmitting the most recent
901:                     data.
902:                 
903:                   Description:
904:                     This routine determines if the transmitter has finished sending all
905:                     available data.
906:                 
907:                   Preconditions:
908:                     The UART module should have been appropriately configured and enabled and data
909:                     sent to the UART TX buffer.
910:                 
911:                   Parameters:
912:                     id      - Identifies the desired UART module.
913:                 
914:                   Returns:
915:                     Boolean identifying if the transmission has completed:
916:                     * TRUE    - If the transmitter has completed sending the data
917:                     * FALSE   - If the transmitter is still busy sending the data
918:                 
919:                   Example:
920:                     <code>
921:                 	if (UARTTransmissionHasCompleted(UART1))
922:                     {
923:                         // Perform any tasks necessary when all data has been sent
924:                     }
925:                     </code>
926:                 
927:                   Remarks:
928:                   *****************************************************************************/
929:                 
930:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
931:                 {
932:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
9D001594  00042080   SLL A0, A0, 2
9D001598  3C029D00   LUI V0, -25344
9D00159C  24422834   ADDIU V0, V0, 10292
9D0015A0  00822021   ADDU A0, A0, V0
9D0015A4  8C830000   LW V1, 0(A0)
9D0015A8  8C620010   LW V0, 16(V1)
9D0015AC  30420100   ANDI V0, V0, 256
933:                 }
934:                 
935:                 
936:                 /*******************************************************************************
937:                   Function:
938:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
939:                 
940:                   Summary:
941:                     Routine to detect if the receiver has data available.
942:                 
943:                   Description:
944:                     This routine determines if the receiver has data available to be read.
945:                 
946:                   Precondition:
947:                     The UART module must have been configured appropriately and enabled. A complete
948:                     data frame must have been sent to the UART before it will return a TRUE.
949:                 
950:                   Parameters:
951:                     id      - Identifies the desired UART module.
952:                 
953:                   Returns:
954:                     Boolean identifying whether or not data is available:
955:                     * TRUE    - If the receiver has data available
956:                     * FALSE   - If the receiver does not have data availble
957:                 
958:                   Example:
959:                     <code>
960:                     UART_DATA data;
961:                 	
962:                 	if (UARTReceivedDataIsAvailable(UART1))
963:                     {
964:                         data = UARTGetData(UART1);
965:                     }
966:                     </code>
967:                 
968:                   Remarks:
969:                     This routine provides the same information as the UART_DATA_READY line
970:                     status flag.
971:                   *****************************************************************************/
972:                 
973:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
974:                 {
975:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
9D001438  00042080   SLL A0, A0, 2
9D00143C  3C029D00   LUI V0, -25344
9D001440  24422834   ADDIU V0, V0, 10292
9D001444  00822021   ADDU A0, A0, V0
9D001448  8C830000   LW V1, 0(A0)
9D00144C  8C640010   LW A0, 16(V1)
9D001450  30840001   ANDI A0, A0, 1
9D0014C0  00048080   SLL S0, A0, 2
9D0014C4  3C029D00   LUI V0, -25344
9D0014C8  24422834   ADDIU V0, V0, 10292
9D0014CC  02028021   ADDU S0, S0, V0
9D0014D0  8E030000   LW V1, 0(S0)
9D0014D4  8C620010   LW V0, 16(V1)
9D0014D8  30420001   ANDI V0, V0, 1
9D0014F8  3C029D00   LUI V0, -25344
9D0014FC  24422834   ADDIU V0, V0, 10292
9D001508  8C430010   LW V1, 16(V0)
9D00150C  30630001   ANDI V1, V1, 1
9D0015F0  00041080   SLL V0, A0, 2
9D0015F4  3C129D00   LUI S2, -25344
9D0015F8  26522834   ADDIU S2, S2, 10292
9D0015FC  00529021   ADDU S2, V0, S2
9D001608  8C430010   LW V1, 16(V0)
9D00160C  30630001   ANDI V1, V1, 1
9D0016C4  00042080   SLL A0, A0, 2
9D0016C8  3C029D00   LUI V0, -25344
9D0016CC  24422834   ADDIU V0, V0, 10292
9D0016D0  00822021   ADDU A0, A0, V0
9D0016D4  8C830000   LW V1, 0(A0)
9D0016D8  8C640010   LW A0, 16(V1)
9D0016DC  30840001   ANDI A0, A0, 1
976:                 }
977:                 
978:                 
979:                 /*******************************************************************************
980:                   Function:
981:                     BYTE UARTGetDataByte ( UART_MODULE id )
982:                 
983:                   Summary:
984:                     Routine to get a byte of data received by the UART.
985:                 
986:                   Description:
987:                     This routine allows the caller to read a byte of data received by the UART.
988:                 
989:                   Precondition:
990:                     The UART module must have been appropriately configured, the configuration must
991:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
992:                     been enabled.  Also, a complete data frame must have been received by the UART.
993:                 
994:                   Parameters:
995:                     id      - Identifies the desired UART module.
996:                 
997:                   Returns:
998:                     A byte of data received by the UART.
999:                 
1000:                  Example:
1001:                    <code>
1002:                    unsigned char data;
1003:                	
1004:                	if (UARTReceivedDataIsAvailable(UART1))
1005:                    {
1006:                        data = UARTGetDataByte(UART1);
1007:                    }
1008:                    </code>
1009:                
1010:                  Remarks:
1011:                    This routine is optimized for receiving 8-bit data through the UART.
1012:                  *****************************************************************************/
1013:                
1014:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1015:                {
1016:                    return (BYTE)uartReg[id]->rx.reg;
9D00145C  8C620030   LW V0, 48(V1)
9D0014E4  8C620030   LW V0, 48(V1)
9D001518  8C420030   LW V0, 48(V0)
9D001618  8C450030   LW A1, 48(V0)
9D0016E8  8C630030   LW V1, 48(V1)
1017:                }
1018:                
1019:                
1020:                /*******************************************************************************
1021:                  Function:
1022:                    UART_DATA UARTGetData ( UART_MODULE id )
1023:                
1024:                  Summary:
1025:                    Routine to get data received by the UART.
1026:                
1027:                  Description:
1028:                    This routine allows the caller to read a data word received by the UART.
1029:                
1030:                  Precondition:
1031:                    The module must have been appropriately configured, the UART module must have been
1032:                    enabled, and a complete data frame must have been received by the UART.
1033:                
1034:                  Parameters:
1035:                    id      - Identifies the desired UART module.
1036:                
1037:                  Returns:
1038:                    Data received by the UART.
1039:                
1040:                  Example:
1041:                    <code>
1042:                    UART_DATA data;
1043:                	
1044:                	if (UARTReceivedDataIsAvailable(UART1))
1045:                    {
1046:                        data = UARTGetData(UART1);
1047:                    }
1048:                    </code>
1049:                
1050:                  Remarks:
1051:                    Size of the data word depends on the current configuration (see
1052:                    UARTSetLineControl).
1053:                  *****************************************************************************/
1054:                
1055:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1056:                {
1057:                    UART_DATA data;
1058:                
1059:                    data.__data = uartReg[id]->rx.reg;
1060:                
1061:                    return data;
1062:                }
1063:                
1064:                
1065:                /*******************************************************************************
1066:                  Function:
1067:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1068:                
1069:                  Summary:
1070:                    Routine to program the address for which the UART module may watch.
1071:                
1072:                  Description:
1073:                    This routine programs the 8-bit address for which the module may watch.
1074:                
1075:                  Precondition:
1076:                    None
1077:                
1078:                  Parameters:
1079:                    id      - Identifies the desired UART module.
1080:                
1081:                    address - 8-bit address for which the module will watch.
1082:                
1083:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1084:                              * TRUE - Enable address watch mode
1085:                              * FALSE - Disable address watch mode
1086:                
1087:                  Returns:
1088:                    None.
1089:                
1090:                  Example:
1091:                    <code>
1092:                    #define SLAVE_ADDRESS  0x42
1093:                	
1094:                	UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1095:                    </code>
1096:                
1097:                  Remarks:
1098:                    The module can be placed into a mode where it will ignore all data received
1099:                    until it identifies the programmed adress.  After the programmed address
1100:                    has been identified, it will begin receiving data normally.  This mode is
1101:                    particularly useful for supporting the IEEE-485 protocol.
1102:                  *****************************************************************************/
1103:                
1104:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1105:                
1106:                
1107:                /*******************************************************************************
1108:                  Function:
1109:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1110:                
1111:                  Summary:
1112:                    Routine to enable or disable recognition of the programmed address byte.
1113:                
1114:                  Description:
1115:                    This routine can enable or disable the "address watch" mode.  In this mode,
1116:                    the UART module will ignore all data until it recognizes the programmed address.
1117:                
1118:                  Precondition:
1119:                    UART should have already been enabled and set with watch address.
1120:                
1121:                  Parameters:
1122:                    id      - Identifies the desired UART module.
1123:                
1124:                    watch   - Determines if the "address watch" mode will be enabled or
1125:                              disabled.
1126:                              * TRUE - Enable address watch mode
1127:                              * FALSE - Disable address watch mode
1128:                
1129:                  Returns:
1130:                    None.
1131:                
1132:                  Example:
1133:                    <code>
1134:                    #define SLAVE_ADDRESS 0x42
1135:                	
1136:                	// Set the address, but don't enable the watch until later,
1137:                	// UART continues to receive data normally
1138:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1139:                
1140:                    // ...
1141:                
1142:                    // Now begin to ignore all UART traffic until we are addressed
1143:                    UARTWatchForAddress(UART1, TRUE);
1144:                    </code>
1145:                
1146:                  Remarks:
1147:                    The UART module can be placed into a mode where it will ignore all data received
1148:                    until it identifies the programmed address.  After the programmed address
1149:                    has been identified, it will begin receiving data normally.  This mode is
1150:                    particularly useful for supporting the IEEE-485 protocol.
1151:                  *****************************************************************************/
1152:                
1153:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1154:                
1155:                
1156:                /*******************************************************************************
1157:                  Function:
1158:                    void UARTSendBreak ( UART_MODULE id )
1159:                
1160:                  Summary:
1161:                    Routine to send a break signal from the UART.
1162:                
1163:                  Description:
1164:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1165:                
1166:                  Precondition:
1167:                    The UART should have been appropriately configured.  The transmitter should
1168:                    be idle, although not necessarily enabled yet.
1169:                
1170:                  Parameters:
1171:                    id      - Identifies the desired UART module.
1172:                
1173:                  Returns:
1174:                    None
1175:                
1176:                  Example:
1177:                    <code>
1178:                    if (UARTTransmissionHasCompleted(UART1))
1179:                    {
1180:                        UARTSendBreak(UART1);
1181:                    }
1182:                    </code>
1183:                
1184:                  Remarks:
1185:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1186:                    data may be pre-loaded into the FIFO and it will be send immediately
1187:                    following the break signal.
1188:                  *****************************************************************************/
1189:                
1190:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1191:                {
1192:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1193:                }
1194:                
1195:                
1196:                /*******************************************************************************
1197:                  Function:
1198:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1199:                
1200:                  Summary:
1201:                    Routine to automatically determine the data rate (bits-per-second) of an
1202:                    external transmitter to the UART.
1203:                
1204:                  Description:
1205:                    This routine initiates the process of automatically determining the data
1206:                    rate (bits-per-second) of an external transmitter to the UART.
1207:                
1208:                  Precondition:
1209:                    The UART should have been appropriately configured.  The transmitter should
1210:                    be idle, although not necessarily enabled yet.
1211:                
1212:                  Parameters:
1213:                    id      - Identifies the desired UART module.
1214:                
1215:                  Returns:
1216:                    None
1217:                
1218:                  Example:
1219:                    <code>
1220:                	// See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1221:                	// methods to detect a Break.
1222:                	
1223:                    if (breakDetected && useAutoRateDetect) 
1224:                    {
1225:                        UARTStartAutoDataRateDetect (UART1);
1226:                    }
1227:                    </code>
1228:                
1229:                  Remarks:
1230:                    The UART module begins measuring the data rate beginning at the next start
1231:                    bit.  The external transmitter should send an alternating pattern (0x55)
1232:                    for the byte to be measured for an effective rate detection.  To ensure
1233:                    an effective measurement sequence, this can be done immediately following
1234:                    a break reception. It is important that this UART module is not
1235:                	transmitting data while it is trying to detect RX baud rate, see the 
1236:                	"PIC32 Family Reference Manual, Sect. 21 UART".
1237:                  *****************************************************************************/
1238:                
1239:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1240:                {
1241:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1242:                }
1243:                
1244:                
1245:                
1246:                /*******************************************************************************
1247:                  Function:
1248:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1249:                
1250:                  Summary:
1251:                    Routine to identify when automatic data rate detection has completed.
1252:                
1253:                  Description:
1254:                    This routine checks to see if automatic data rate detection has completed.
1255:                
1256:                  Precondition:
1257:                    Automatic rate detection should have been previously started.
1258:                
1259:                  Parameters:
1260:                    id      - Identifies the desired UART module.
1261:                
1262:                  Returns:
1263:                    * TRUE    - Indicates that automatic rate detection has completed.
1264:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1265:                
1266:                  Example:
1267:                    <code>
1268:                    #define PERIPHERAL_CLOCK    10000000
1269:                	
1270:                	UINT32 currentRate;
1271:                	
1272:                	if (UARTDataRateDetected(UART1))
1273:                    {
1274:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1275:                    }
1276:                    </code>
1277:                
1278:                  Remarks:
1279:                    This routine returns FALSE after automatic rate detection
1280:                    has been started but before rate is detectdd, it will return TRUE
1281:                	at any other time.
1282:                  *****************************************************************************/
1283:                
1284:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1285:                {
1286:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1287:                }
1288:                
1289:                #ifdef __cplusplus
1290:                  }
1291:                #endif
1292:                
1293:                #endif // _UART_h_
1294:                
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
118:                         pb_clock >>= 1;
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
170:                     {
171:                         wait_states++;
172:                         sys_clock -= FLASH_SPEED_HZ;
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
176:                     mCheConfigure(wait_states);
177:                     INTRestoreInterrupts(int_status);
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
227:                     {
228:                         wait_states++;
229:                         sys_clock -= FLASH_SPEED_HZ;
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
233:                     mCheConfigure(wait_states);
234:                     INTRestoreInterrupts(int_status);
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
279:                 
280:                     int_status=INTDisableInterrupts();
281:                 
282:                     mBMXDisableDRMWaitState();
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
286:                     cache_status |= CHE_CONF_PF_ALL;
287:                     mCheConfigure(cache_status);
288:                     CheKseg0CacheOn();
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
9D001D40  0F400A0B   JAL INTDisableInterrupts
9D001D44  00000000   NOP
342:                 
343:                     mBMXDisableDRMWaitState();
9D001D48  24040040   ADDIU A0, ZERO, 64
9D001D4C  3C03BF88   LUI V1, -16504
9D001D50  AC642004   SW A0, 8196(V1)
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
358:                     {
359:                         cache_status = mCheGetCon();
360:                         cache_status |= CHE_CONF_PF_ALL;
361:                         mCheConfigure(cache_status);
362:                         CheKseg0CacheOn();
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
367:                     pb_clk >>= OSCCONbits.PBDIV;
9D001D54  3C03BF81   LUI V1, -16511
9D001D58  8C63F000   LW V1, -4096(V1)
368:                 
369:                     INTRestoreInterrupts(int_status);
9D001D5C  0F4009F0   JAL INTRestoreInterrupts
9D001D60  00402021   ADDU A0, V0, ZERO
370:                 
371:                     return pb_clk;
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/vpc-32.c  -----------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /* 
20:                   * File:   vpc-32.c
21:                   * Author: Jacques Deschênes
22:                   *
23:                   * Created on 26 août 2013, 07:38
24:                   */
25:                  
26:                  #include <stdio.h>
27:                  #include <stdlib.h>
28:                  #include <plib.h>
29:                  #include "hardware/HardwareProfile.h"
30:                  #include "hardware/ntsc.h"
31:                  #include "hardware/font.h"
32:                  #include "hardware/serial_comm.h"
33:                  #include "hardware/keyboard.h"
34:                  
35:                  // PIC32MX150F128B Configuration Bit Settings
36:                  #include <xc.h>
37:                  
38:                  // DEVCFG3
39:                  // USERID = No Setting
40:                  #pragma config PMDL1WAY = OFF           // permet plusieurs configurations des périphériques.
41:                  #pragma config IOL1WAY = OFF            // permet plusieurs configuration des broches.
42:                  
43:                  // DEVCFG2
44:                  #pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
45:                  #if SYSCLK==40000000L
46:                  #pragma config FPLLMUL = MUL_16         // SYSCLK=40Mhz
47:                  #else
48:                  #pragma config FPLLMUL = MUL_15          // PLL Multiplier (15x Multiplier) SYSCLK=37,5Mhz
49:                  #endif
50:                  #pragma config FPLLODIV = DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)
51:                  
52:                  // DEVCFG1
53:                  #pragma config FNOSC = PRIPLL           // Oscillator Selection Bits (Primary Osc w/PLL (XT+,HS+,EC+PLL))
54:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
55:                  #pragma config IESO = OFF               // Internal/External Switch Over (Disabled)
56:                  #pragma config POSCMOD = HS             // Primary Oscillator Configuration (XT osc mode)
57:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
58:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
59:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
60:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
61:                  
62:                  // DEVCFG0
63:                  #pragma config JTAGEN = OFF             // JTAG Enable (JTAG Disabled)
64:                  #pragma config ICESEL = ICS_PGx1        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
65:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
66:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
67:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
68:                  
69:                  
70:                  void put_char(int x, int y, char c){
9D000EB4  7C063420   SEB A2, A2
9D000F08  2402000A   ADDIU V0, ZERO, 10
9D000F0C  70A23802   MUL A3, A1, V0
9D000F10  00E81021   ADDU V0, A3, T0
9D000F14  00021080   SLL V0, V0, 2
9D000F18  3C05A000   LUI A1, -24576
9D000F1C  24A50020   ADDIU A1, A1, 32
9D000F20  00A22821   ADDU A1, A1, V0
9D000F24  24020007   ADDIU V0, ZERO, 7
9D000F28  70C23802   MUL A3, A2, V0
9D000F2C  3C089D00   LUI T0, -25344
9D000F30  25081A4C   ADDIU T0, T0, 6732
9D000F34  01071021   ADDU V0, T0, A3
9D000F38  25080007   ADDIU T0, T0, 7
9D000F3C  01073821   ADDU A3, T0, A3
71:                      register int i,l,r,b;
72:                      if (c<32) return;
9D000EB8  28C20020   SLTI V0, A2, 32
9D000EBC  14400035   BNE V0, ZERO, 0x9D000F94
9D000EC0  24C6FFE0   ADDIU A2, A2, -32
73:                      c -=32;
9D000EC4  7C063420   SEB A2, A2
74:                      b=x>>5;
9D000EC8  00044143   SRA T0, A0, 5
75:                      r=0;
76:                      l=27-(x&0x1f);
9D000ECC  3084001F   ANDI A0, A0, 31
9D000ED0  2403001B   ADDIU V1, ZERO, 27
9D000ED4  00642023   SUBU A0, V1, A0
77:                      if (l<0){
78:                          r=-l;
9D000ED8  00041823   SUBU V1, ZERO, A0
9D000EDC  28870000   SLTI A3, A0, 0
9D000EE0  0007180A   MOVZ V1, ZERO, A3
79:                      }
80:                      for (i=0;i<7;i++){
9D000F8C  1447FFEC   BNE V0, A3, 0x9D000F40
9D000F90  24A50028   ADDIU A1, A1, 40
9D000F94  03E00008   JR RA
9D000F98  00000000   NOP
81:                          if (r){
9D000F40  1060000C   BEQ V1, ZERO, 0x9D000F74
9D000F44  8CA80000   LW T0, 0(A1)
82:                              video_bmp[y][b] &= ~(0x1f>>r);
9D000EE4  240B001F   ADDIU T3, ZERO, 31
9D000EE8  006B6807   SRAV T5, T3, V1
9D000EEC  000D6827   NOR T5, ZERO, T5
9D000F4C  01A84024   AND T0, T5, T0
83:                              video_bmp[y][b] |= font[c][i]>>r;
9D000F48  90460000   LBU A2, 0(V0)
9D000F50  00664807   SRAV T1, A2, V1
9D000F54  01094025   OR T0, T0, T1
9D000F58  ACA80000   SW T0, 0(A1)
84:                              video_bmp[y][b+1] &= ~(0x1f<<32-r);
9D000EF0  240A0020   ADDIU T2, ZERO, 32
9D000EF4  01435023   SUBU T2, T2, V1
9D000EF8  014B6004   SLLV T4, T3, T2
9D000EFC  000C6027   NOR T4, ZERO, T4
9D000F5C  8CA80004   LW T0, 4(A1)
9D000F60  01884024   AND T0, T4, T0
85:                              video_bmp[y][b+1] |= font[c][i]<<(32-r);
9D000F64  01463004   SLLV A2, A2, T2
9D000F68  01063025   OR A2, T0, A2
9D000F6C  0B4003E2   J 0x9D000F88
9D000F70  ACA60004   SW A2, 4(A1)
86:                              y++;
87:                          } else{
88:                              video_bmp[y][b] &= ~(0x1f<<l);
9D000F00  008B5804   SLLV T3, T3, A0
9D000F04  000B5827   NOR T3, ZERO, T3
9D000F74  01684024   AND T0, T3, T0
89:                              video_bmp[y++][b] |= font[c][i]<<l;
9D000F78  90460000   LBU A2, 0(V0)
9D000F7C  00863004   SLLV A2, A2, A0
9D000F80  01063025   OR A2, T0, A2
9D000F84  ACA60000   SW A2, 0(A1)
9D000F88  24420001   ADDIU V0, V0, 1
90:                          }
91:                      }
92:                  }//put)char()
93:                  
94:                  const char *msg2=" test video ntsc ";
95:                  const char *msg1="01234567890123456789012345678901234567890123456789012"; // 53 caractères par ligne
96:                  
97:                  void print(int x, int y, const char *text){
9D000F9C  27BDFFE0   ADDIU SP, SP, -32
9D000FA0  AFBF001C   SW RA, 28(SP)
9D000FA4  AFB20018   SW S2, 24(SP)
9D000FA8  AFB10014   SW S1, 20(SP)
9D000FAC  AFB00010   SW S0, 16(SP)
9D000FB0  00808021   ADDU S0, A0, ZERO
9D000FB4  00A09021   ADDU S2, A1, ZERO
98:                      while (*text){
9D000FB8  0B4003F6   J 0x9D000FD8
9D000FBC  00C08821   ADDU S1, A2, ZERO
9D000FD8  82260000   LB A2, 0(S1)
9D000FDC  14C0FFF8   BNE A2, ZERO, 0x9D000FC0
9D000FE0  02002021   ADDU A0, S0, ZERO
99:                          put_char(x, y, *text++);
9D000FC0  0F4003AD   JAL put_char
9D000FC4  02402821   ADDU A1, S2, ZERO
100:                         x += 6;
9D000FC8  26100006   ADDIU S0, S0, 6
101:                         if (x>HRES-6) break;
9D000FCC  2A02013B   SLTI V0, S0, 315
9D000FD0  10400004   BEQ V0, ZERO, 0x9D000FE4
9D000FD4  26310001   ADDIU S1, S1, 1
102:                     }
103:                 }// print()
9D000FE4  8FBF001C   LW RA, 28(SP)
9D000FE8  8FB20018   LW S2, 24(SP)
9D000FEC  8FB10014   LW S1, 20(SP)
9D000FF0  8FB00010   LW S0, 16(SP)
9D000FF4  03E00008   JR RA
9D000FF8  27BD0020   ADDIU SP, SP, 32
104:                 
105:                 void test_pattern(void){
9D000FFC  27BDFFE8   ADDIU SP, SP, -24
9D001000  AFBF0014   SW RA, 20(SP)
9D001004  3C06A000   LUI A2, -24576
9D001008  24C60020   ADDIU A2, A2, 32
9D00100C  00C03821   ADDU A3, A2, ZERO
9D001010  24C523F0   ADDIU A1, A2, 9200
9D001014  00C01021   ADDU V0, A2, ZERO
9D001034  24E30028   ADDIU V1, A3, 40
9D001058  24E71AE8   ADDIU A3, A3, 6888
106:                     int i,j;
107:                     for (i=0;i<VRES;i++){
9D00102C  5445FFFD   BNEL V0, A1, 0x9D001024
9D001030  AC440000   SW A0, 0(V0)
108:                         video_bmp[i][0]=0x80000000;
9D001018  3C048000   LUI A0, -32768
9D001020  AC440000   SW A0, 0(V0)
109:                         video_bmp[i][HRES/32-1]=1;
9D00101C  24030001   ADDIU V1, ZERO, 1
9D001024  AC430024   SW V1, 36(V0)
9D001028  24420028   ADDIU V0, V0, 40
110:                     }
111:                     for (i=0;i<HRES/32;i++){
9D001048  54C3FFFD   BNEL A2, V1, 0x9D001040
9D00104C  ACC20000   SW V0, 0(A2)
9D001050  3C02A000   LUI V0, -24576
9D001054  24420910   ADDIU V0, V0, 2320
112:                         video_bmp[0][i]=0xffffffff;
9D001038  2402FFFF   ADDIU V0, ZERO, -1
9D00103C  ACC20000   SW V0, 0(A2)
113:                         video_bmp[VRES-1][i]=0xffffffff;
9D001040  ACC223C8   SW V0, 9160(A2)
9D001044  24C60004   ADDIU A2, A2, 4
114:                     }
115:                     for (i=VRES/4;i<VRES/2+VRES/4;i++){
9D001090  5447FFFB   BNEL V0, A3, 0x9D001080
9D001094  AC460000   SW A2, 0(V0)
116:                         video_bmp[i][2]=0xFF00FF00;
9D00105C  3C06FF00   LUI A2, -256
9D001060  34C6FF00   ORI A2, A2, -256
9D00107C  AC460000   SW A2, 0(V0)
117:                         video_bmp[i][3]=0xF0F0F0F0;
9D001064  3C05F0F0   LUI A1, -3856
9D001068  34A5F0F0   ORI A1, A1, -3856
9D001080  AC450004   SW A1, 4(V0)
118:                         video_bmp[i][4]=0xcccccccc;
9D00106C  3C04CCCC   LUI A0, -13108
9D001070  3484CCCC   ORI A0, A0, -13108
9D001084  AC440008   SW A0, 8(V0)
119:                         video_bmp[i][5]=0xaaaaaaaa;
9D001074  3C03AAAA   LUI V1, -21846
9D001078  3463AAAA   ORI V1, V1, -21846
9D001088  AC43000C   SW V1, 12(V0)
9D00108C  24420028   ADDIU V0, V0, 40
120:                     }//i
121:                     print(2,3,msg1);
9D001098  24040002   ADDIU A0, ZERO, 2
9D00109C  24050003   ADDIU A1, ZERO, 3
9D0010A0  0F4003E7   JAL print
9D0010A4  8F868014   LW A2, -32748(GP)
122:                     print(2,12,msg2);
9D0010A8  24040002   ADDIU A0, ZERO, 2
9D0010AC  2405000C   ADDIU A1, ZERO, 12
9D0010B0  0F4003E7   JAL print
9D0010B4  8F868010   LW A2, -32752(GP)
123:                 }//test_pattern()
9D0010B8  8FBF0014   LW RA, 20(SP)
9D0010BC  03E00008   JR RA
9D0010C0  27BD0018   ADDIU SP, SP, 24
124:                 
125:                 void digit(char d){
9D0010C4  27BDFFD8   ADDIU SP, SP, -40
9D0010C8  AFBF0024   SW RA, 36(SP)
9D0010CC  AFB40020   SW S4, 32(SP)
9D0010D0  AFB3001C   SW S3, 28(SP)
9D0010D4  AFB20018   SW S2, 24(SP)
9D0010D8  AFB10014   SW S1, 20(SP)
9D0010DC  7C042420   SEB A0, A0
126:                     while (d--){
9D0010E0  10800011   BEQ A0, ZERO, 0x9D001128
9D0010E4  AFB00010   SW S0, 16(SP)
9D0010E8  2490FFFF   ADDIU S0, A0, -1
9D0010EC  7C108420   SEB S0, S0
9D0010FC  2414FFFF   ADDIU S4, ZERO, -1
9D001118  2610FFFF   ADDIU S0, S0, -1
9D00111C  7C108420   SEB S0, S0
9D001120  1614FFF7   BNE S0, S4, 0x9D001100
9D001124  00000000   NOP
127:                         _status_on();
9D0010F0  3C12BF88   LUI S2, -16504
9D0010F4  24110008   ADDIU S1, ZERO, 8
9D001100  AE516138   SW S1, 24888(S2)
128:                         delay_ms(400);
9D001104  0F4007B2   JAL delay_ms
9D001108  24040190   ADDIU A0, ZERO, 400
129:                         _status_off();
9D0010F8  3C13BF88   LUI S3, -16504
9D00110C  AE716134   SW S1, 24884(S3)
130:                         delay_ms(300);
9D001110  0F4007B2   JAL delay_ms
9D001114  2404012C   ADDIU A0, ZERO, 300
131:                     }
132:                 }//digit()
9D001128  8FBF0024   LW RA, 36(SP)
9D00112C  8FB40020   LW S4, 32(SP)
9D001130  8FB3001C   LW S3, 28(SP)
9D001134  8FB20018   LW S2, 24(SP)
9D001138  8FB10014   LW S1, 20(SP)
9D00113C  8FB00010   LW S0, 16(SP)
9D001140  03E00008   JR RA
9D001144  27BD0028   ADDIU SP, SP, 40
133:                 void error_code_status(int code){
9D001148  27BDFFE8   ADDIU SP, SP, -24
9D00114C  AFBF0014   SW RA, 20(SP)
9D001150  AFB00010   SW S0, 16(SP)
134:                     char d;
135:                     code &= 255;
9D001154  309000FF   ANDI S0, A0, 255
136:                     d=code/100;
9D001158  24020064   ADDIU V0, ZERO, 100
9D00115C  0202001A   DIV S0, V0
9D001160  004001F4   TEQ V0, ZERO
9D001164  00008010   MFHI S0, 0
9D001168  00001012   MFLO V0, 0
137:                     digit(d);
9D00116C  0F400431   JAL digit
9D001170  7C022420   SEB A0, V0
138:                     delay_ms(500);
9D001174  0F4007B2   JAL delay_ms
9D001178  240401F4   ADDIU A0, ZERO, 500
139:                     code = code % 100;
140:                     d= code/10;
9D00117C  2404000A   ADDIU A0, ZERO, 10
9D001180  0204001A   DIV S0, A0
9D001184  008001F4   TEQ A0, ZERO
9D001188  00008010   MFHI S0, 0
141:                     digit(d);
9D00118C  0F400431   JAL digit
9D001190  00002012   MFLO A0, 0
142:                     delay_ms(500);
9D001194  0F4007B2   JAL delay_ms
9D001198  240401F4   ADDIU A0, ZERO, 500
143:                     code = code % 10;
144:                     digit(code);
9D00119C  0F400431   JAL digit
9D0011A0  02002021   ADDU A0, S0, ZERO
145:                 }//error_code_status()
9D0011A4  8FBF0014   LW RA, 20(SP)
9D0011A8  8FB00010   LW S0, 16(SP)
9D0011AC  03E00008   JR RA
9D0011B0  27BD0018   ADDIU SP, SP, 24
146:                 
147:                 void main(void) {
9D0011B4  27BDFFD0   ADDIU SP, SP, -48
9D0011B8  AFBF002C   SW RA, 44(SP)
9D0011BC  AFB60028   SW S6, 40(SP)
9D0011C0  AFB50024   SW S5, 36(SP)
9D0011C4  AFB40020   SW S4, 32(SP)
9D0011C8  AFB3001C   SW S3, 28(SP)
9D0011CC  AFB20018   SW S2, 24(SP)
9D0011D0  AFB10014   SW S1, 20(SP)
148:                     int code;
149:                     HardwareInit();
9D0011D4  0F40074E   JAL HardwareInit
9D0011D8  AFB00010   SW S0, 16(SP)
150:                     UartInit(STDIO,9600,DEFAULT_LINE_CTRL);
9D0011DC  24040001   ADDIU A0, ZERO, 1
9D0011E0  24052580   ADDIU A1, ZERO, 9600
9D0011E4  0F4004F1   JAL UartInit
9D0011E8  00003021   ADDU A2, ZERO, ZERO
151:                     ln_cnt=0;
9D0011EC  AF808028   SW ZERO, -32728(GP)
152:                     video=0;
9D0011F0  AF808024   SW ZERO, -32732(GP)
153:                     test_pattern();
9D0011F4  0F4003FF   JAL test_pattern
9D0011F8  00000000   NOP
154:                     VideoInit();
9D0011FC  0F4005C3   JAL VideoInit
9D001200  00000000   NOP
155:                     delay_ms(750);
9D001204  0F4007B2   JAL delay_ms
9D001208  240402EE   ADDIU A0, ZERO, 750
156:                     if ((code=KeyboardInit())==1){
9D00120C  0F400196   JAL KeyboardInit
9D001210  00000000   NOP
9D001214  24030001   ADDIU V1, ZERO, 1
9D001218  14430017   BNE V0, V1, 0x9D001278
9D00121C  00000000   NOP
157:                         SetKbdLeds(F_NUM);
9D001220  0F4001D0   JAL SetKbdLeds
9D001224  24040002   ADDIU A0, ZERO, 2
158:                         delay_ms(300);
9D001228  0F4007B2   JAL delay_ms
9D00122C  2404012C   ADDIU A0, ZERO, 300
159:                         SetKbdLeds(F_CAPS);
9D001230  0F4001D0   JAL SetKbdLeds
9D001234  24040004   ADDIU A0, ZERO, 4
160:                         delay_ms(300);
9D001238  0F4007B2   JAL delay_ms
9D00123C  2404012C   ADDIU A0, ZERO, 300
161:                         SetKbdLeds(F_SCROLL);
9D001240  0F4001D0   JAL SetKbdLeds
9D001244  24040001   ADDIU A0, ZERO, 1
162:                         delay_ms(300);
9D001248  0F4007B2   JAL delay_ms
9D00124C  2404012C   ADDIU A0, ZERO, 300
163:                         SetKbdLeds(0);
9D001250  0F4001D0   JAL SetKbdLeds
9D001254  00002021   ADDU A0, ZERO, ZERO
164:                     }else{
165:                         error_code_status(-code);
9D001278  0F400452   JAL error_code_status
9D00127C  00022023   SUBU A0, ZERO, V0
166:                     }
167:                     short scancode,key;
168:                     int x=1,y=20;
169:                     while(1){
170:                         if ((scancode=GetScancode())){
9D001288  0F400008   JAL GetScancode
9D00128C  00000000   NOP
9D001290  1040FFFD   BEQ V0, ZERO, 0x9D001288
9D001294  00000000   NOP
171:                             if (scancode>0){
9D001298  58400020   BLEZL V0, 0x9D00131C
9D00129C  304201FF   ANDI V0, V0, 511
172:                                 switch (scancode){
9D0012A0  10510005   BEQ V0, S1, 0x9D0012B8
9D0012A4  24030066   ADDIU V1, ZERO, 102
9D0012A8  50430009   BEQL V0, V1, 0x9D0012D0
9D0012AC  2610FFFA   ADDIU S0, S0, -6
9D0012B0  1453000D   BNE V0, S3, 0x9D0012E8
9D0012B4  00000000   NOP
173:                                     case LSHIFT:
174:                                     case RSHIFT:
175:                                         rx_flags |= F_SHIFT;
9D0012B8  9382801E   LBU V0, -32738(GP)
9D0012BC  304200FF   ANDI V0, V0, 255
9D0012C0  34420008   ORI V0, V0, 8
9D0012C4  A382801E   SB V0, -32738(GP)
176:                                         break;
9D0012C8  0B4004A2   J 0x9D001288
9D0012CC  00000000   NOP
177:                                     case BKSP:
178:                                         x -= 6;
179:                                         put_char(x,y,32);
9D0012D0  02002021   ADDU A0, S0, ZERO
9D0012D4  02402821   ADDU A1, S2, ZERO
9D0012D8  0F4003AD   JAL put_char
9D0012DC  24060020   ADDIU A2, ZERO, 32
180:                                         break;
9D0012E0  0B4004A2   J 0x9D001288
9D0012E4  00000000   NOP
181:                                     default:
182:                                         put_char(x, y, GetKey(scancode)&127);
9D0012E8  0F400098   JAL GetKey
9D0012EC  00402021   ADDU A0, V0, ZERO
9D0012F0  02002021   ADDU A0, S0, ZERO
9D0012F4  02402821   ADDU A1, S2, ZERO
9D0012F8  0F4003AD   JAL put_char
9D0012FC  3046007F   ANDI A2, V0, 127
183:                                         x += 6;
9D001300  26100006   ADDIU S0, S0, 6
184:                                         if (x>=(53*6+1)){
9D001304  2A02013F   SLTI V0, S0, 319
9D001308  1440FFDF   BNE V0, ZERO, 0x9D001288
9D00130C  00000000   NOP
185:                                             y +=8;
9D001310  26520008   ADDIU S2, S2, 8
186:                                             x=1;
9D001258  24120014   ADDIU S2, ZERO, 20
9D00125C  24100001   ADDIU S0, ZERO, 1
9D001280  0B400497   J 0x9D00125C
9D001284  24120014   ADDIU S2, ZERO, 20
9D001314  0B4004A2   J 0x9D001288
9D001318  24100001   ADDIU S0, ZERO, 1
187:                                         }
188:                                 }
189:                             }else switch (scancode&511){
9D001260  24140058   ADDIU S4, ZERO, 88
9D001268  24110059   ADDIU S1, ZERO, 89
9D00126C  24150077   ADDIU S5, ZERO, 119
9D001270  0B4004A2   J 0x9D001288
9D001274  24130012   ADDIU S3, ZERO, 18
9D00131C  1054001C   BEQ V0, S4, 0x9D001390
9D001320  28430059   SLTI V1, V0, 89
9D001324  10600005   BEQ V1, ZERO, 0x9D00133C
9D001328  00000000   NOP
9D00132C  1453FFD6   BNE V0, S3, 0x9D001288
9D001330  00000000   NOP
9D001334  0B4004D5   J 0x9D001354
9D001338  00000000   NOP
9D00133C  10510005   BEQ V0, S1, 0x9D001354
9D001340  00000000   NOP
9D001344  1455FFD0   BNE V0, S5, 0x9D001288
9D001348  00000000   NOP
9D00134C  0B4004DB   J 0x9D00136C
9D001350  00000000   NOP
190:                                 case LSHIFT:
191:                                 case RSHIFT:
192:                                     rx_flags &= ~F_SHIFT;
9D001264  2416FFF7   ADDIU S6, ZERO, -9
9D001354  9382801E   LBU V0, -32738(GP)
9D001358  304200FF   ANDI V0, V0, 255
9D00135C  00561024   AND V0, V0, S6
9D001360  A382801E   SB V0, -32738(GP)
193:                                     break;
9D001364  0B4004A2   J 0x9D001288
9D001368  00000000   NOP
194:                                 case LCTRL:
195:                                 case RCTRL:
196:                                     break;
197:                                 case LALT:
198:                                 case RALT:
199:                                     break;
200:                                 case NUM_LOCK:
201:                                     kbd_leds ^= F_NUM;
9D00136C  9382801F   LBU V0, -32737(GP)
9D001370  304200FF   ANDI V0, V0, 255
9D001374  38420002   XORI V0, V0, 2
9D001378  A382801F   SB V0, -32737(GP)
202:                                     SetKbdLeds(kbd_leds);
9D00137C  9384801F   LBU A0, -32737(GP)
9D001380  0F4001D0   JAL SetKbdLeds
9D001384  308400FF   ANDI A0, A0, 255
203:                                     break;
9D001388  0B4004A2   J 0x9D001288
9D00138C  00000000   NOP
204:                                 case CAPS_LOCK:
205:                                     kbd_leds ^= F_CAPS;
9D001390  9382801F   LBU V0, -32737(GP)
9D001394  304200FF   ANDI V0, V0, 255
9D001398  38420004   XORI V0, V0, 4
9D00139C  A382801F   SB V0, -32737(GP)
206:                                     rx_flags ^= F_CAPS;
9D0013A0  9382801E   LBU V0, -32738(GP)
9D0013A4  304200FF   ANDI V0, V0, 255
9D0013A8  38420004   XORI V0, V0, 4
9D0013AC  A382801E   SB V0, -32738(GP)
207:                                     SetKbdLeds(kbd_leds);
9D0013B0  9384801F   LBU A0, -32737(GP)
9D0013B4  0F4001D0   JAL SetKbdLeds
9D0013B8  308400FF   ANDI A0, A0, 255
9D0013BC  0B4004A2   J 0x9D001288
9D0013C0  00000000   NOP
208:                                     break;
209:                 
210:                             }
211:                         }
212:                     }
213:                 }
214:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/serial_comm.c  ---------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   uart.h
20:                   * Author: Jacques Deschênes
21:                   * Description: fonctions de bas niveau pour communication UART avec le PC
22:                   * Created on 17 avril 2013, 14:48
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "serial_comm.h"
27:                  #include "HardwareProfile.h"
28:                  
29:                  static char unget;
30:                  
31:                  void UartInit(UART_MODULE channel, int baudrate, UART_LINE_CONTROL_MODE LineCtrl){
9D0013C4  27BDFFE0   ADDIU SP, SP, -32
9D0013C8  AFBF001C   SW RA, 28(SP)
9D0013CC  AFB20018   SW S2, 24(SP)
9D0013D0  AFB10014   SW S1, 20(SP)
9D0013D4  AFB00010   SW S0, 16(SP)
9D0013D8  00808021   ADDU S0, A0, ZERO
9D0013DC  00A09021   ADDU S2, A1, ZERO
9D0013E0  00C08821   ADDU S1, A2, ZERO
32:                  /*initialise le périphérique UART*/
33:                     // Configure UART, information dans uart.h
34:                     UARTConfigure(channel, UART_ENABLE_PINS_TX_RX_ONLY); // pas de contrôle de flux matériel.
9D0013E4  0F400930   JAL UARTConfigure
9D0013E8  00002821   ADDU A1, ZERO, ZERO
35:                     UARTSetLineControl(channel, LineCtrl);
9D0013EC  02002021   ADDU A0, S0, ZERO
9D0013F0  0F4009BE   JAL UARTSetLineControl
9D0013F4  02202821   ADDU A1, S1, ZERO
36:                     UARTSetDataRate(channel, mGetPeripheralClock(), baudrate);
9D0013F8  02002021   ADDU A0, S0, ZERO
9D0013FC  3C05023C   LUI A1, 572
9D001400  24A53460   ADDIU A1, A1, 13408
9D001404  0F4008C2   JAL UARTSetDataRate
9D001408  02403021   ADDU A2, S2, ZERO
37:                     // activation du périphérique
38:                     UARTEnable(channel, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D00140C  02002021   ADDU A0, S0, ZERO
9D001410  0F4008A2   JAL UARTEnable
9D001414  24050087   ADDIU A1, ZERO, 135
39:                     unget=-1;
9D001418  2402FFFF   ADDIU V0, ZERO, -1
9D00141C  A3828018   SB V0, -32744(GP)
40:                  };
9D001420  8FBF001C   LW RA, 28(SP)
9D001424  8FB20018   LW S2, 24(SP)
9D001428  8FB10014   LW S1, 20(SP)
9D00142C  8FB00010   LW S0, 16(SP)
9D001430  03E00008   JR RA
9D001434  27BD0020   ADDIU SP, SP, 32
41:                  
42:                  char UartGetch(UART_MODULE channel){
43:                  /*lecture d'un caractère retourne -1 si aucun disponible*/
44:                      char ch;
45:                      if (!unget==-1) {
46:                          ch=unget;
47:                          unget=-1;
48:                          return ch;
49:                      }else{
50:                          if (UARTReceivedDataIsAvailable (channel)){
9D001454  10800003   BEQ A0, ZERO, 0x9D001464
9D001458  2402FFFF   ADDIU V0, ZERO, -1
51:                                 return UARTGetDataByte(channel);
9D001460  7C021420   SEB V0, V0
52:                          }else{
53:                              return -1;
54:                          }
55:                      }
56:                  };
9D001464  03E00008   JR RA
9D001468  00000000   NOP
57:                  
58:                  void UartPutch(UART_MODULE channel, char c){
9D00146C  7C052C20   SEB A1, A1
59:                  /*Envoie d'un caractère*/
60:                      while(!UARTTransmitterIsReady(channel));
9D00148C  1440FFFD   BNE V0, ZERO, 0x9D001484
9D001490  00000000   NOP
61:                        UARTSendDataByte(channel, c);
62:                  };
9D00149C  03E00008   JR RA
9D0014A0  00000000   NOP
63:                  
64:                  char UartWaitch(UART_MODULE channel, int delay){
9D0014A4  27BDFFE0   ADDIU SP, SP, -32
9D0014A8  AFBF001C   SW RA, 28(SP)
9D0014AC  AFB10018   SW S1, 24(SP)
9D0014B0  AFB00014   SW S0, 20(SP)
9D0014B4  00808021   ADDU S0, A0, ZERO
65:                  /*attend un caractère pour un temps spécifié par delay
66:                  *retourne -1 si aucun reçu avant expiration du délais
67:                  */
68:                      int t;
69:                      char ch;
70:                      if (!unget==-1){
71:                          ch=unget;
72:                          unget=-1;
73:                          return unget;
74:                      }
75:                      if (!delay) while (1) if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D0014B8  14A0000D   BNE A1, ZERO, 0x9D0014F0
9D0014BC  00A08821   ADDU S1, A1, ZERO
9D0014DC  1040FFFD   BEQ V0, ZERO, 0x9D0014D4
9D0014E0  00000000   NOP
9D0014E8  0B40054F   J 0x9D00153C
9D0014EC  7C021420   SEB V0, V0
76:                      t=ticks()+delay;
9D0014F0  0F4007A7   JAL ticks
9D0014F4  00108080   SLL S0, S0, 2
77:                      while (ticks()<delay){
9D001500  0B400549   J 0x9D001524
9D001504  02028021   ADDU S0, S0, V0
9D001524  0F4007A7   JAL ticks
9D001528  00000000   NOP
9D00152C  0051102B   SLTU V0, V0, S1
9D001530  5440FFF5   BNEL V0, ZERO, 0x9D001508
9D001534  8E020000   LW V0, 0(S0)
78:                         if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D001510  10600004   BEQ V1, ZERO, 0x9D001524
9D001514  00000000   NOP
9D00151C  0B40054F   J 0x9D00153C
9D001520  7C021420   SEB V0, V0
79:                      }
80:                      return -1;
9D001538  2402FFFF   ADDIU V0, ZERO, -1
81:                  }
9D00153C  8FBF001C   LW RA, 28(SP)
9D001540  8FB10018   LW S1, 24(SP)
9D001544  8FB00014   LW S0, 20(SP)
9D001548  03E00008   JR RA
9D00154C  27BD0020   ADDIU SP, SP, 32
82:                  
83:                  void UartPrint(UART_MODULE channel, const char* str){
84:                  /* envoie la chaine de caractère str via le UART */
85:                     while(*str != (char)0)
9D001550  80A60000   LB A2, 0(A1)
9D001554  10C0000F   BEQ A2, ZERO, 0x9D001594
9D001558  00041880   SLL V1, A0, 2
9D001588  80A60000   LB A2, 0(A1)
9D00158C  14C0FFF7   BNE A2, ZERO, 0x9D00156C
9D001590  00000000   NOP
86:                     {
87:                        while(!UARTTransmitterIsReady(channel));
9D001574  1440FFFD   BNE V0, ZERO, 0x9D00156C
9D001578  00000000   NOP
88:                        UARTSendDataByte(channel, *str++);
9D00157C  24A50001   ADDIU A1, A1, 1
89:                     }
90:                     while(!UARTTransmissionHasCompleted(channel));
9D0015B0  1040FFFD   BEQ V0, ZERO, 0x9D0015A8
9D0015B4  00000000   NOP
91:                  };
9D0015B8  03E00008   JR RA
9D0015BC  00000000   NOP
92:                  
93:                  int UartReadln(UART_MODULE channel, char *buffer, int buff_len){
9D0015C0  27BDFFD0   ADDIU SP, SP, -48
9D0015C4  AFBF002C   SW RA, 44(SP)
9D0015C8  AFB50028   SW S5, 40(SP)
9D0015CC  AFB40024   SW S4, 36(SP)
9D0015D0  AFB30020   SW S3, 32(SP)
9D0015D4  AFB2001C   SW S2, 28(SP)
9D0015D8  AFB10018   SW S1, 24(SP)
9D0015DC  AFB00014   SW S0, 20(SP)
9D0015E0  00809821   ADDU S3, A0, ZERO
9D0015E4  00A0A021   ADDU S4, A1, ZERO
9D0015E8  00C08821   ADDU S1, A2, ZERO
94:                  /* lecture d'une chaine se terminant par '\r'
95:                   *  complète la chaine avec un zéro
96:                   *  retourne le nombre de caractère dans le buffer.
97:                   */
98:                      int count=0;
9D0015EC  00008021   ADDU S0, ZERO, ZERO
99:                      char c;
100:                     if (!unget==-1){
101:                         c=unget;
102:                         unget=-1;
103:                         *buffer++=c;
104:                         if (c==CR) return;
105:                     }
106:                     while (count < (buff_len-1)){
9D001600  0B40059A   J 0x9D001668
9D001604  3C159D00   LUI S5, -25344
9D001650  0B40059B   J 0x9D00166C
9D001654  2622FFFF   ADDIU V0, S1, -1
9D001668  2622FFFF   ADDIU V0, S1, -1
9D00166C  0202102A   SLT V0, S0, V0
9D001670  5440FFE5   BNEL V0, ZERO, 0x9D001608
9D001674  8E420000   LW V0, 0(S2)
107:                         if (UARTReceivedDataIsAvailable(channel)){
9D001610  50600016   BEQL V1, ZERO, 0x9D00166C
9D001614  2622FFFF   ADDIU V0, S1, -1
108:                             c = UARTGetDataByte(channel);
9D00161C  7C052C20   SEB A1, A1
109:                             if (c==CR) break;
9D001620  2402000D   ADDIU V0, ZERO, 13
9D001624  10A20014   BEQ A1, V0, 0x9D001678
9D001628  24020008   ADDIU V0, ZERO, 8
110:                             if (c==BS){
9D00162C  54A2000A   BNEL A1, V0, 0x9D001658
9D001630  A2850000   SB A1, 0(S4)
111:                                 if (count){
9D001634  5200000D   BEQL S0, ZERO, 0x9D00166C
9D001638  2622FFFF   ADDIU V0, S1, -1
112:                                     buffer--;
9D00163C  2694FFFF   ADDIU S4, S4, -1
113:                                     count--;
9D001640  2610FFFF   ADDIU S0, S0, -1
114:                                     UartPrint(channel,"\b \b");
9D001644  02602021   ADDU A0, S3, ZERO
9D001648  0F400554   JAL UartPrint
9D00164C  26A52854   ADDIU A1, S5, 10324
115:                                 }
116:                             }else{
117:                                 *buffer++=c;
9D001658  26940001   ADDIU S4, S4, 1
118:                                 count++;
9D00165C  26100001   ADDIU S0, S0, 1
119:                                 UartPutch(channel,c);
9D001660  0F40051B   JAL UartPutch
9D001664  02602021   ADDU A0, S3, ZERO
120:                             }
121:                             
122:                         }
123:                     }
124:                     if (count) *buffer = (char)0;
9D001678  56000001   BNEL S0, ZERO, 0x9D001680
9D00167C  A2800000   SB ZERO, 0(S4)
125:                     UartPutch(channel,'\r');
9D001680  02602021   ADDU A0, S3, ZERO
9D001684  0F40051B   JAL UartPutch
9D001688  2405000D   ADDIU A1, ZERO, 13
126:                     return count;
127:                 }
9D00168C  02001021   ADDU V0, S0, ZERO
9D001690  8FBF002C   LW RA, 44(SP)
9D001694  8FB50028   LW S5, 40(SP)
9D001698  8FB40024   LW S4, 36(SP)
9D00169C  8FB30020   LW S3, 32(SP)
9D0016A0  8FB2001C   LW S2, 28(SP)
9D0016A4  8FB10018   LW S1, 24(SP)
9D0016A8  8FB00014   LW S0, 20(SP)
9D0016AC  03E00008   JR RA
9D0016B0  27BD0030   ADDIU SP, SP, 48
128:                 
129:                 int UartReceivedBreak(UART_MODULE channel){
130:                    char ch;
131:                    if (unget==-1 && UARTReceivedDataIsAvailable(channel)) {
9D0016B4  83858018   LB A1, -32744(GP)
9D0016B8  2403FFFF   ADDIU V1, ZERO, -1
9D0016BC  14A30011   BNE A1, V1, 0x9D001704
9D0016C0  00001021   ADDU V0, ZERO, ZERO
9D0016E0  10800008   BEQ A0, ZERO, 0x9D001704
9D0016E4  00001021   ADDU V0, ZERO, ZERO
132:                        ch=UARTGetDataByte(channel);
9D0016EC  7C031C20   SEB V1, V1
133:                        if (ch==ESC) return 1; else unget=ch;
9D0016F0  2404001B   ADDIU A0, ZERO, 27
9D0016F4  10640003   BEQ V1, A0, 0x9D001704
9D0016F8  24020001   ADDIU V0, ZERO, 1
9D0016FC  A3838018   SB V1, -32744(GP)
134:                    }
135:                    return 0;
9D001700  00001021   ADDU V0, ZERO, ZERO
136:                 }
9D001704  03E00008   JR RA
9D001708  00000000   NOP
137:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/ntsc.c  ----------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /* 
19:                   * File:   test-ntsc.c
20:                   * Author: Jacques Deschênes
21:                   * Description: test génération signal vidéo NTSC sur PIC32MX150F128B.
22:                   * Created on 20 août 2013, 08:48
23:                   */
24:                  
25:                  #include <stdio.h>
26:                  #include <stdlib.h>
27:                  #include <sys/attribs.h>
28:                  #include <plib.h>
29:                  #include "HardwareProfile.h"
30:                  #include "ntsc.h"
31:                  
32:                  /*
33:                   *  la fréqueence PBCLK influence la largeur des pixels vidéo. Comme PBCLK==SYSCLK
34:                   *  on peut allonger les pixels en diminuant la fréquence légèrement.
35:                   *  pour une résolution horizontale de 320 pixels et une fréquence de 40Mhz le
36:                   *  meilleur diviseur pour le générateur BGR du SPI est de 2 ce qui donne
37:                   *  une fréquence de pixel de  40e6/(2*(2+1)=6,67Mhz et la durée total d'une
38:                   *  ligne vidéo est donc de 320/6,67e6= 48µSec.
39:                   *  En principe pour le standard NTSC on dispose de 52µSec par ligne vidéo.
40:                   *  En pratique on est plutôt à 51µSec. Donc ici on a 3µSec inutilisées.
41:                   *  en résuidant SYSCLK à 37,5Mhz on a 51,2µSec par ligne vidéo. Les pixels
42:                   *  sont donc moins compressé horizontalement. Mais sur certains téléviseurs
43:                   *  on peut perdre quelques pixels en bout de ligne.
44:                   *  la constante SPI_DLY doit-être ajustée en fonction de PBCLK pour que les
45:                   *  320 pixels horizontals soient visibles.
46:                   */
47:                  
48:                  #define PWM_PERIOD (SYSCLK/15748)-1
49:                  #define HSYNC  (SYSCLK/212766)  // 4,7µSec
50:                  #define FIRST_LINE 27   //première ligne de scan visible
51:                  #define LAST_LINE  256  // dernière ligne de scan visible
52:                  #define BITCLK HRES * 1000000L/52 // 52µSec c'est le temps que dure 1 ligne vidéo.
53:                  #if SYSCLK==40000000L
54:                  #define SPI_DLY HSYNC+90 // délais en début de ligne avant l'envoie du signal vidéo.
55:                  #else
56:                  #define SPI_DLY HSYNC+30 // délais en début de ligne avant l'envoie du signal vidéo.
57:                  #endif
58:                  #define _enable_video_out()  SPI1CONSET =(1<<15)
59:                  #define _disable_video_out() SPI1CONCLR =(1<<15)
60:                  
61:                  unsigned int video_bmp[VRES][HRES/32]; // video bitmap 7168 octets
62:                  volatile unsigned int ln_cnt;
63:                  volatile unsigned int video;
64:                  volatile int *DmaSrc;
65:                  
66:                  
67:                  
68:                  void VideoInit(void){
9D00170C  27BDFFD8   ADDIU SP, SP, -40
9D001710  AFBF0024   SW RA, 36(SP)
9D001714  AFB20020   SW S2, 32(SP)
9D001718  AFB1001C   SW S1, 28(SP)
9D00171C  AFB00018   SW S0, 24(SP)
69:                      //configuration PWM sur OC2 pour SYNC, utilisation TIMER2
70:                      T2CON = 0;
9D001720  3C02BF80   LUI V0, -16512
9D001724  AC400800   SW ZERO, 2048(V0)
71:                      PR2=PWM_PERIOD;
9D001728  2403094C   ADDIU V1, ZERO, 2380
9D00172C  3C02BF80   LUI V0, -16512
9D001730  AC430820   SW V1, 2080(V0)
72:                      OC2CONbits.OCM = 5; // mode train d'impulsion
9D001734  3C02BF80   LUI V0, -16512
9D001738  8C433200   LW V1, 12800(V0)
9D00173C  24120005   ADDIU S2, ZERO, 5
9D001740  7E431004   INS V1, S2, 0, 3
9D001744  AC433200   SW V1, 12800(V0)
73:                      OC2RS = 0; 
9D001748  3C03BF80   LUI V1, -16512
9D00174C  AC603220   SW ZERO, 12832(V1)
74:                      OC2R = HSYNC;
9D001750  240400B0   ADDIU A0, ZERO, 176
9D001754  3C03BF80   LUI V1, -16512
9D001758  AC643210   SW A0, 12816(V1)
75:                      IFS0bits.T2IF=0;
9D00175C  3C03BF88   LUI V1, -16504
9D001760  8C641030   LW A0, 4144(V1)
9D001764  7C044A44   INS A0, ZERO, 9, 1
9D001768  AC641030   SW A0, 4144(V1)
76:                      IEC0bits.T2IE=1;
9D00176C  3C03BF88   LUI V1, -16504
9D001770  8C641060   LW A0, 4192(V1)
9D001774  24110001   ADDIU S1, ZERO, 1
9D001778  7E244A44   INS A0, S1, 9, 1
9D00177C  AC641060   SW A0, 4192(V1)
77:                      IPC2bits.T2IP=7;
9D001780  3C03BF88   LUI V1, -16504
9D001784  8C6410B0   LW A0, 4272(V1)
9D001788  24050007   ADDIU A1, ZERO, 7
9D00178C  7CA42084   INS A0, A1, 2, 3
9D001790  AC6410B0   SW A0, 4272(V1)
78:                      IPC2bits.T2IS=3;
9D001794  8C6410B0   LW A0, 4272(V1)
9D001798  24050003   ADDIU A1, ZERO, 3
9D00179C  7CA40804   INS A0, A1, 0, 2
9D0017A0  AC6410B0   SW A0, 4272(V1)
79:                      OC2CONbits.ON =1;  // activation
9D0017A4  8C433200   LW V1, 12800(V0)
9D0017A8  7E237BC4   INS V1, S1, 15, 1
9D0017AC  AC433200   SW V1, 12800(V0)
80:                      T2CONbits.ON=1;  // activation
9D0017B0  3C02BF80   LUI V0, -16512
9D0017B4  8C430800   LW V1, 2048(V0)
9D0017B8  7E237BC4   INS V1, S1, 15, 1
9D0017BC  AC430800   SW V1, 2048(V0)
81:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
82:                      OC1CONbits.OCM = 5; //mode train d'impulsion
9D0017C0  3C02BF80   LUI V0, -16512
9D0017C4  8C433000   LW V1, 12288(V0)
9D0017C8  7E431004   INS V1, S2, 0, 3
9D0017CC  AC433000   SW V1, 12288(V0)
83:                      OC1RS=0;
9D0017D0  3C03BF80   LUI V1, -16512
9D0017D4  AC603020   SW ZERO, 12320(V1)
84:                      OC1R=HSYNC+SPI_DLY;
9D0017D8  2404017E   ADDIU A0, ZERO, 382
9D0017DC  3C03BF80   LUI V1, -16512
9D0017E0  AC643010   SW A0, 12304(V1)
85:                      OC1CONbits.ON=1;
9D0017E4  8C433000   LW V1, 12288(V0)
9D0017E8  7E237BC4   INS V1, S1, 15, 1
9D0017EC  AC433000   SW V1, 12288(V0)
86:                      // configuration SPI pour sortie vidéo
87:                      // configure le DMA
88:                      DmaChnOpen(0,0,DMA_OPEN_DEFAULT);
9D0017F0  00002021   ADDU A0, ZERO, ZERO
9D0017F4  00002821   ADDU A1, ZERO, ZERO
9D0017F8  0F4007DE   JAL DmaChnOpen
9D0017FC  00003021   ADDU A2, ZERO, ZERO
89:                      DmaChnSetEventControl(0,DMA_EV_START_IRQ_EN|
9D001800  00002021   ADDU A0, ZERO, ZERO
9D001804  0F400993   JAL DmaChnWriteEventControlFlags
9D001808  24052610   ADDIU A1, ZERO, 9744
90:                                            DMA_EV_START_IRQ(_SPI1_TX_IRQ));
91:                      DmaChnSetTxfer(0,(void *)DmaSrc,(void *)&SPI1BUF,HRES/8,4,4);
9D00180C  24020004   ADDIU V0, ZERO, 4
9D001810  AFA20010   SW V0, 16(SP)
9D001814  AFA20014   SW V0, 20(SP)
9D001818  00002021   ADDU A0, ZERO, ZERO
9D00181C  8F858020   LW A1, -32736(GP)
9D001820  3C06BF80   LUI A2, -16512
9D001824  24C65820   ADDIU A2, A2, 22560
9D001828  0F40087C   JAL DmaChnSetTxfer
9D00182C  24070028   ADDIU A3, ZERO, 40
92:                      // configuration du SPI canal 1
93:                      SPI1CONbits.DISSDI=1; // SDI n'est pas utilisé.
9D001830  3C10BF80   LUI S0, -16512
9D001834  8E025800   LW V0, 22528(S0)
9D001838  7E222104   INS V0, S1, 4, 1
9D00183C  AE025800   SW V0, 22528(S0)
94:                      SPI1CONbits.FRMEN=1; // frame mode
9D001840  8E025800   LW V0, 22528(S0)
9D001844  7E22FFC4   INS V0, S1, 31, 1
9D001848  AE025800   SW V0, 22528(S0)
95:                      SPI1CONbits.FRMCNT=5; // 32 octets par frame.
9D00184C  8E025800   LW V0, 22528(S0)
9D001850  7E42D604   INS V0, S2, 24, 3
9D001854  AE025800   SW V0, 22528(S0)
96:                      SPI1CONbits.FRMPOL=1; // sync sur transition montante
9D001858  8E025800   LW V0, 22528(S0)
9D00185C  7E22EF44   INS V0, S1, 29, 1
9D001860  AE025800   SW V0, 22528(S0)
97:                      SPI1CONbits.FRMSYNC=1; // synchronisation esclave
9D001864  8E025800   LW V0, 22528(S0)
9D001868  7E22F784   INS V0, S1, 30, 1
9D00186C  AE025800   SW V0, 22528(S0)
98:                      SPI1CONbits.MSTEN=1; // SPI maître
9D001870  8E025800   LW V0, 22528(S0)
9D001874  7E222944   INS V0, S1, 5, 1
9D001878  AE025800   SW V0, 22528(S0)
99:                     // SPI1CONbits.SPIFE=1; // synchronisation sur clock premier bit.
100:                     SPI1CONbits.MODE32=1; // mode 32 bits
9D00187C  8E025800   LW V0, 22528(S0)
9D001880  7E225AC4   INS V0, S1, 11, 1
9D001884  AE025800   SW V0, 22528(S0)
101:                     SPI1CONbits.STXISEL=1; // interruption sur TBE
9D001888  8E025800   LW V0, 22528(S0)
9D00188C  7E221884   INS V0, S1, 2, 2
9D001890  AE025800   SW V0, 22528(S0)
102:                     SpiChnSetBitRate(SPI_CHANNEL1, PBCLK, BITCLK);
9D001894  24040001   ADDIU A0, ZERO, 1
9D001898  3C05023C   LUI A1, 572
9D00189C  24A53460   ADDIU A1, A1, 13408
9D0018A0  3C06005D   LUI A2, 93
9D0018A4  0F400921   JAL SpiChnSetBitRate
9D0018A8  34C6E676   ORI A2, A2, -6538
103:                     SPI1CONbits.ON=1;
9D0018AC  8E025800   LW V0, 22528(S0)
9D0018B0  7E227BC4   INS V0, S1, 15, 1
9D0018B4  AE025800   SW V0, 22528(S0)
104:                 }//init_video()
9D0018B8  8FBF0024   LW RA, 36(SP)
9D0018BC  8FB20020   LW S2, 32(SP)
9D0018C0  8FB1001C   LW S1, 28(SP)
9D0018C4  8FB00018   LW S0, 24(SP)
9D0018C8  03E00008   JR RA
9D0018CC  27BD0028   ADDIU SP, SP, 40
105:                 
106:                 
107:                 
108:                 void __ISR(_TIMER_2_VECTOR,IPL7AUTO) tmr2_isr(void){
9D0018D0  415DE800   RDPGPR SP, SP
9D0018D4  401B7000   MFC0 K1, EPC
9D0018D8  401A6002   MFC0 K0, SRSCtl
9D0018DC  27BDFFE0   ADDIU SP, SP, -32
9D0018E0  401B6000   MFC0 K1, Status
9D0018E4  AFBA001C   SW K0, 28(SP)
9D0018E8  AFBB0018   SW K1, 24(SP)
9D0018EC  7C1B7844   INS K1, ZERO, 1, 15
9D0018F0  377B1C00   ORI K1, K1, 7168
9D0018F4  409B6000   MTC0 K1, Status
9D0018F8  AFA30008   SW V1, 8(SP)
9D0018FC  AFA20004   SW V0, 4(SP)
9D001900  AFA4000C   SW A0, 12(SP)
109:                     _disable_video_out();
9D001904  34038000   ORI V1, ZERO, -32768
9D001908  3C02BF80   LUI V0, -16512
9D00190C  AC435804   SW V1, 22532(V0)
110:                     ln_cnt++;
9D001910  8F828028   LW V0, -32728(GP)
9D001914  24420001   ADDIU V0, V0, 1
9D001918  AF828028   SW V0, -32728(GP)
111:                     switch (ln_cnt){
9D00191C  8F828028   LW V0, -32728(GP)
9D001920  2403001A   ADDIU V1, ZERO, 26
9D001924  1043001C   BEQ V0, V1, 0x9D001998
9D001928  2C43001B   SLTIU V1, V0, 27
9D00192C  10600009   BEQ V1, ZERO, 0x9D001954
9D001930  24030101   ADDIU V1, ZERO, 257
9D001934  24030001   ADDIU V1, ZERO, 1
9D001938  1043000D   BEQ V0, V1, 0x9D001970
9D00193C  2403089C   ADDIU V1, ZERO, 2204
9D001940  24030004   ADDIU V1, ZERO, 4
9D001944  1443001D   BNE V0, V1, 0x9D0019BC
9D001948  240300B0   ADDIU V1, ZERO, 176
9D001954  10430016   BEQ V0, V1, 0x9D0019B0
9D001958  00000000   NOP
9D00195C  24030106   ADDIU V1, ZERO, 262
9D001960  14430016   BNE V0, V1, 0x9D0019BC
9D001964  00000000   NOP
9D001968  0B400663   J 0x9D00198C
9D00196C  00000000   NOP
112:                         case 1:  // début vsync
113:                             OC2R=PWM_PERIOD-HSYNC;
9D001970  3C02BF80   LUI V0, -16512
9D001974  AC433210   SW V1, 12816(V0)
114:                             break;
9D001978  0B400684   J 0x9D001A10
9D00197C  24030200   ADDIU V1, ZERO, 512
115:                         case 4: // fin vsync
116:                             OC2R=HSYNC;
9D00194C  0B400660   J 0x9D001980
9D001950  3C02BF80   LUI V0, -16512
9D001980  AC433210   SW V1, 12816(V0)
117:                             break;
9D001984  0B400684   J 0x9D001A10
9D001988  24030200   ADDIU V1, ZERO, 512
118:                         case 262:  //fin du frame
119:                             ln_cnt=0;
9D00198C  AF808028   SW ZERO, -32728(GP)
120:                             break;
9D001990  0B400684   J 0x9D001A10
9D001994  24030200   ADDIU V1, ZERO, 512
121:                   
122:                         case FIRST_LINE-1:
123:                             video=1;
9D001998  24020001   ADDIU V0, ZERO, 1
9D00199C  AF828024   SW V0, -32732(GP)
124:                             DmaSrc=(void*)&video_bmp[0];
9D0019A0  3C02A000   LUI V0, -24576
9D0019A4  24420020   ADDIU V0, V0, 32
125:                             break;
9D0019A8  0B400683   J 0x9D001A0C
9D0019AC  AF828020   SW V0, -32736(GP)
126:                         case LAST_LINE+1:
127:                             video=0;
9D0019B0  AF808024   SW ZERO, -32732(GP)
128:                             break;
9D0019B4  0B400684   J 0x9D001A10
9D0019B8  24030200   ADDIU V1, ZERO, 512
129:                         default:
130:                             if (video){
9D0019BC  8F828024   LW V0, -32732(GP)
9D0019C0  10400012   BEQ V0, ZERO, 0x9D001A0C
9D0019C4  34038000   ORI V1, ZERO, -32768
131:                                 _enable_video_out();
9D0019C8  3C02BF80   LUI V0, -16512
9D0019CC  AC435808   SW V1, 22536(V0)
132:                                 IFS1bits.SPI1TXIF=1;
9D0019D0  3C02BF88   LUI V0, -16504
9D0019D4  8C431040   LW V1, 4160(V0)
9D0019D8  24040001   ADDIU A0, ZERO, 1
9D0019DC  7C833184   INS V1, A0, 6, 1
9D0019E0  AC431040   SW V1, 4160(V0)
133:                                 DCH0SSA=KVA_TO_PA((void *)DmaSrc);
9D0019E4  8F828020   LW V0, -32736(GP)
9D0019E8  7C44E000   EXT A0, V0, 0, 29
9D0019EC  3C03BF88   LUI V1, -16504
9D0019F0  AC643090   SW A0, 12432(V1)
134:                                 DmaSrc +=HRES/32;
9D0019F4  24420028   ADDIU V0, V0, 40
9D0019F8  AF828020   SW V0, -32736(GP)
135:                                 DCH0CON |=128;
9D0019FC  3C02BF88   LUI V0, -16504
9D001A00  8C433060   LW V1, 12384(V0)
9D001A04  34630080   ORI V1, V1, 128
9D001A08  AC433060   SW V1, 12384(V0)
136:                                 //DmaChnEnable(0);
137:                             }
138:                     }//switch (ln_cnt)
139:                     mT2ClearIntFlag();
9D001A0C  24030200   ADDIU V1, ZERO, 512
9D001A10  3C02BF88   LUI V0, -16504
9D001A14  AC431034   SW V1, 4148(V0)
140:                 }//tmr2_isr()
9D001A18  8FA2001C   LW V0, 28(SP)
9D001A1C  3042000F   ANDI V0, V0, 15
9D001A20  14400004   BNE V0, ZERO, 0x9D001A34
9D001A24  8FBB0018   LW K1, 24(SP)
9D001A28  8FA4000C   LW A0, 12(SP)
9D001A2C  8FA30008   LW V1, 8(SP)
9D001A30  8FA20004   LW V0, 4(SP)
9D001A34  8FBA001C   LW K0, 28(SP)
9D001A38  27BD0020   ADDIU SP, SP, 32
9D001A3C  409A6002   MTC0 K0, SRSCtl
9D001A40  41DDE800   WRPGPR SP, SP
9D001A44  409B6000   MTC0 K1, Status
9D001A48  42000018   ERET
141:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/keyboard.c  ------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * Name: keyboard.c
20:                   * Author: Jacques Deschênes
21:                   * Description:  interface avec clavier PS/2
22:                   * Date: 2013-08-26
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "hardwareProfile.h"
27:                  #include "keyboard.h"
28:                  #include "QWERTY.h"
29:                  
30:                  #define KBD_CLK 1  // SET/CLR bit
31:                  #define KBD_DAT 2  // SET/CLR bit
32:                  
33:                  volatile unsigned char kbd_queue[32]; // file circulaire pour les codes reçus du clavier.
34:                  volatile unsigned char head=0, tail=0; // tête et queue de la file
35:                  volatile unsigned char  in_byte=0, bit_cnt=0, parity=0, rx_flags=0, kbd_leds=0;
36:                  
37:                  int KeyboardInit(){ // initialisation E/S et RAZ clavier
9D000658  27BDFFE8   ADDIU SP, SP, -24
9D00065C  AFBF0014   SW RA, 20(SP)
38:                      unsigned char c;
39:                  
40:                      head=0;
9D000660  A3808019   SB ZERO, -32743(GP)
41:                      tail=0;
9D000664  A380801A   SB ZERO, -32742(GP)
42:                      in_byte=0;
9D000668  A380801B   SB ZERO, -32741(GP)
43:                      bit_cnt=0;
9D00066C  A380801C   SB ZERO, -32740(GP)
44:                      parity=0;
9D000670  A380801D   SB ZERO, -32739(GP)
45:                      rx_flags=0;
9D000674  A380801E   SB ZERO, -32738(GP)
46:                      kbd_leds=0;
9D000678  A380801F   SB ZERO, -32737(GP)
47:                      TRISASET=KBD_CLK|KBD_DAT;
9D00067C  24040003   ADDIU A0, ZERO, 3
9D000680  3C02BF88   LUI V0, -16504
9D000684  AC446018   SW A0, 24600(V0)
48:                      INTCONbits.INT4EP=0; // interruption sur transition descendante
9D000688  3C02BF88   LUI V0, -16504
9D00068C  8C431000   LW V1, 4096(V0)
9D000690  7C032104   INS V1, ZERO, 4, 1
9D000694  AC431000   SW V1, 4096(V0)
49:                      IPC4bits.INT4IP=6; // priorité 4
9D000698  3C02BF88   LUI V0, -16504
9D00069C  8C4310D0   LW V1, 4304(V0)
9D0006A0  24050006   ADDIU A1, ZERO, 6
9D0006A4  7CA3E684   INS V1, A1, 26, 3
9D0006A8  AC4310D0   SW V1, 4304(V0)
50:                      IPC4bits.INT4IS=3;  // sous-priorité 3.
9D0006AC  8C4310D0   LW V1, 4304(V0)
9D0006B0  7C83CE04   INS V1, A0, 24, 2
9D0006B4  AC4310D0   SW V1, 4304(V0)
51:                      while (!PORTAbits.RA0);
9D0006B8  3C03BF88   LUI V1, -16504
9D0006BC  8C626020   LW V0, 24608(V1)
9D0006C0  30420001   ANDI V0, V0, 1
9D0006C4  1040FFFD   BEQ V0, ZERO, 0x9D0006BC
9D0006C8  3C02BF88   LUI V0, -16504
52:                      IFS0bits.INT4IF=0; // RAZ indicateur interruption
9D0006CC  8C431030   LW V1, 4144(V0)
9D0006D0  7C03BDC4   INS V1, ZERO, 23, 1
9D0006D4  AC431030   SW V1, 4144(V0)
53:                      IEC0SET = _IEC0_INT4IE_MASK; // activation interruption externe 4 (KBD_CLK)
9D0006D8  3C030080   LUI V1, 128
9D0006DC  3C02BF88   LUI V0, -16504
9D0006E0  AC431068   SW V1, 4200(V0)
54:                      if (!KbdSend(KBD_RESET)){
9D0006E4  0F400116   JAL KbdSend
9D0006E8  2404FFFF   ADDIU A0, ZERO, -1
9D0006EC  10400010   BEQ V0, ZERO, 0x9D000730
9D0006F0  2403FFFF   ADDIU V1, ZERO, -1
55:                              return -1;
56:                      }
57:                      while ((rx_flags & F_ERROR+F_RCVD)==0); // attend résultat BAT
9D0006F4  9382801E   LBU V0, -32738(GP)
9D0006F8  30420003   ANDI V0, V0, 3
9D0006FC  1040FFFD   BEQ V0, ZERO, 0x9D0006F4
9D000700  00000000   NOP
58:                      if (rx_flags & F_ERROR)
9D000704  9382801E   LBU V0, -32738(GP)
9D000708  30420001   ANDI V0, V0, 1
9D00070C  14400008   BNE V0, ZERO, 0x9D000730
9D000710  2403FFFE   ADDIU V1, ZERO, -2
59:                              return -2;
60:                      c=GetScancode();
9D000714  0F400008   JAL GetScancode
9D000718  00000000   NOP
9D00071C  304200FF   ANDI V0, V0, 255
61:                      if (c!=BAT_OK)
62:                              return -c;
9D000720  00021823   SUBU V1, ZERO, V0
9D000724  384200AA   XORI V0, V0, 170
9D000728  24040001   ADDIU A0, ZERO, 1
9D00072C  0082180A   MOVZ V1, A0, V0
63:                      return 1;
64:                  } //KeyboardInit()
9D000730  00601021   ADDU V0, V1, ZERO
9D000734  8FBF0014   LW RA, 20(SP)
9D000738  03E00008   JR RA
9D00073C  27BD0018   ADDIU SP, SP, 24
65:                  
66:                  #define COMPLETED 1
67:                  #define RELEASE 2
68:                  #define EXTENDED 4
69:                  #define PRN_KEY 8
70:                  #define PAUSE_KEY 16
71:                  
72:                  short GetScancode(){  // obtient le code clavier en tête de la file
73:                  	unsigned int i, flags;
74:                  	short code;
75:                  	code = 0;
9D000020  00001021   ADDU V0, ZERO, ZERO
76:                  	flags=0;
9D000024  00002821   ADDU A1, ZERO, ZERO
77:                  	while (!(flags & COMPLETED)){
9D00024C  30A30001   ANDI V1, A1, 1
9D000250  1060FF7C   BEQ V1, ZERO, 0x9D000044
9D000254  30A30010   ANDI V1, A1, 16
9D000258  0B400071   J 0x9D0001C4
9D00025C  00000000   NOP
78:                              if (head!=tail){
9D000044  93848019   LBU A0, -32743(GP)
9D000048  308400FF   ANDI A0, A0, 255
9D00004C  9383801A   LBU V1, -32742(GP)
9D000050  306300FF   ANDI V1, V1, 255
9D000054  1083005B   BEQ A0, V1, 0x9D0001C4
9D000058  30A30010   ANDI V1, A1, 16
79:                                  code = kbd_queue[head];
9D000028  3C07A000   LUI A3, -24576
9D00002C  24E72410   ADDIU A3, A3, 9232
9D00005C  93828019   LBU V0, -32743(GP)
9D000060  304200FF   ANDI V0, V0, 255
9D000064  00471021   ADDU V0, V0, A3
9D000068  90420000   LBU V0, 0(V0)
9D00006C  304200FF   ANDI V0, V0, 255
80:                                  head++;
9D000070  93838019   LBU V1, -32743(GP)
9D000074  24630001   ADDIU V1, V1, 1
9D000078  306300FF   ANDI V1, V1, 255
9D00007C  A3838019   SB V1, -32743(GP)
81:                                  head &= 31;
9D000080  93838019   LBU V1, -32743(GP)
9D000084  3063001F   ANDI V1, V1, 31
9D000088  A3838019   SB V1, -32743(GP)
82:                                  if (code==XTD_KEY){
9D000030  240600E0   ADDIU A2, ZERO, 224
9D00008C  14460003   BNE V0, A2, 0x9D00009C
9D000090  00000000   NOP
83:                                          flags |= EXTENDED;
9D000094  0B400066   J 0x9D000198
9D000098  34A50004   ORI A1, A1, 4
84:                                  }else if (code==KEY_REL){
9D000034  240800F0   ADDIU T0, ZERO, 240
9D00009C  14480003   BNE V0, T0, 0x9D0000AC
9D0000A0  00000000   NOP
85:                                          flags |= RELEASE;
9D0000A4  0B400066   J 0x9D000198
9D0000A8  34A50002   ORI A1, A1, 2
86:                                  }else if (code==0xE1){ // PAUSE
9D000038  240900E1   ADDIU T1, ZERO, 225
9D0000AC  14490014   BNE V0, T1, 0x9D000100
9D0000B0  30A30004   ANDI V1, A1, 4
9D0000B4  24050007   ADDIU A1, ZERO, 7
87:                                          for (i=7;i;i--){     // élimine les 7 prochains caractères
9D0000F0  14A0FFF1   BNE A1, ZERO, 0x9D0000B8
9D0000F4  00000000   NOP
88:                                                  while (head==tail);
9D0000B8  93848019   LBU A0, -32743(GP)
9D0000BC  308400FF   ANDI A0, A0, 255
9D0000C0  9383801A   LBU V1, -32742(GP)
9D0000C4  306300FF   ANDI V1, V1, 255
9D0000C8  1083FFFB   BEQ A0, V1, 0x9D0000B8
9D0000CC  00000000   NOP
89:                                                  head++;
9D0000D0  93838019   LBU V1, -32743(GP)
9D0000D4  24630001   ADDIU V1, V1, 1
9D0000D8  306300FF   ANDI V1, V1, 255
9D0000DC  A3838019   SB V1, -32743(GP)
90:                                                  head &= 31;
9D0000E0  93838019   LBU V1, -32743(GP)
9D0000E4  3063001F   ANDI V1, V1, 31
9D0000E8  A3838019   SB V1, -32743(GP)
9D0000EC  24A5FFFF   ADDIU A1, A1, -1
91:                                          }
92:                                          flags = COMPLETED+PAUSE_KEY;
9D0000F8  0B400093   J 0x9D00024C
9D0000FC  24050011   ADDIU A1, ZERO, 17
93:                                  }else if ((flags&EXTENDED)&& (code==0x12)){ // touche PRINT SCREEN enfoncée
9D00003C  240A0012   ADDIU T2, ZERO, 18
9D000100  50600025   BEQL V1, ZERO, 0x9D000198
9D000104  34A50001   ORI A1, A1, 1
9D000108  144A0011   BNE V0, T2, 0x9D000150
9D00010C  00000000   NOP
9D000110  24050002   ADDIU A1, ZERO, 2
94:                                          for (i=2;i;i--){ // élimine les 2 codes suivants
9D000140  14A0FFF4   BNE A1, ZERO, 0x9D000114
9D000144  00000000   NOP
95:                                                  while (head==tail);
9D000114  93848019   LBU A0, -32743(GP)
9D000118  308400FF   ANDI A0, A0, 255
9D00011C  9383801A   LBU V1, -32742(GP)
9D000120  306300FF   ANDI V1, V1, 255
9D000124  1083FFFB   BEQ A0, V1, 0x9D000114
9D000128  00000000   NOP
96:                                                  head++;
9D00012C  93838019   LBU V1, -32743(GP)
9D000130  24630001   ADDIU V1, V1, 1
9D000134  306300FF   ANDI V1, V1, 255
9D000138  A3838019   SB V1, -32743(GP)
9D00013C  24A5FFFF   ADDIU A1, A1, -1
97:                                          }
98:                                          flags = COMPLETED+PRN_KEY;
9D000148  0B400093   J 0x9D00024C
9D00014C  24050009   ADDIU A1, ZERO, 9
99:                                  }else if ((flags&EXTENDED)&& (code==0x7c)){ // touche PRINT SCREEN relâchée
9D000040  240B007C   ADDIU T3, ZERO, 124
9D000150  144B0011   BNE V0, T3, 0x9D000198
9D000154  34A50001   ORI A1, A1, 1
9D000158  24050004   ADDIU A1, ZERO, 4
100:                                         for (i=4;i;i--){ // élimine les 4 codes suivants
9D000188  14A0FFF4   BNE A1, ZERO, 0x9D00015C
9D00018C  00000000   NOP
101:                                                 while (head==tail);
9D00015C  93848019   LBU A0, -32743(GP)
9D000160  308400FF   ANDI A0, A0, 255
9D000164  9383801A   LBU V1, -32742(GP)
9D000168  306300FF   ANDI V1, V1, 255
9D00016C  1083FFFB   BEQ A0, V1, 0x9D00015C
9D000170  00000000   NOP
102:                                                 head++;
9D000174  93838019   LBU V1, -32743(GP)
9D000178  24630001   ADDIU V1, V1, 1
9D00017C  306300FF   ANDI V1, V1, 255
9D000180  A3838019   SB V1, -32743(GP)
9D000184  24A5FFFF   ADDIU A1, A1, -1
103:                                         }
104:                                         flags = COMPLETED+PRN_KEY+RELEASE;
9D000190  0B400093   J 0x9D00024C
9D000194  2405000B   ADDIU A1, ZERO, 11
105:                                 }else{
106:                                         flags |=COMPLETED;
107:                                 }
108:                                 if (!(flags & COMPLETED)){
9D000198  30A30001   ANDI V1, A1, 1
9D00019C  14600009   BNE V1, ZERO, 0x9D0001C4
9D0001A0  30A30010   ANDI V1, A1, 16
109:                                         while (head==tail); // attend touche suivante
9D0001A4  93848019   LBU A0, -32743(GP)
9D0001A8  308400FF   ANDI A0, A0, 255
9D0001AC  9383801A   LBU V1, -32742(GP)
9D0001B0  306300FF   ANDI V1, V1, 255
9D0001B4  1083FFFB   BEQ A0, V1, 0x9D0001A4
9D0001B8  00000000   NOP
9D0001BC  0B400011   J 0x9D000044
9D0001C0  00000000   NOP
110:                                 }
111:                             }else{
112:                                     break;
113:                             }
114:                 	}
115:                 	if (flags & PAUSE_KEY){
9D0001C4  54600004   BNEL V1, ZERO, 0x9D0001D8
9D0001C8  240201E1   ADDIU V0, ZERO, 481
116:                 		code = PAUSE;
117:                 	}else if (flags & PRN_KEY){
9D0001CC  30A40008   ANDI A0, A1, 8
118:                 		code = PRN;
9D0001D0  24030112   ADDIU V1, ZERO, 274
9D0001D4  0064100B   MOVN V0, V1, A0
119:                 	}
120:                 	if (flags & RELEASE){
9D0001D8  30A30002   ANDI V1, A1, 2
9D0001DC  10600004   BEQ V1, ZERO, 0x9D0001F0
9D0001E0  30A50004   ANDI A1, A1, 4
121:                 		code |= REL_BIT; // négatif pour touche relâchée
9D0001E4  24038000   ADDIU V1, ZERO, -32768
9D0001E8  00431025   OR V0, V0, V1
9D0001EC  7C021620   SEH V0, V0
122:                 	}
123:                 	if (flags & EXTENDED){
9D0001F0  10A00003   BEQ A1, ZERO, 0x9D000200
9D0001F4  3C03BF88   LUI V1, -16504
124:                 		code |= XT_BIT; //
9D0001F8  34420100   ORI V0, V0, 256
9D0001FC  7C021620   SEH V0, V0
125:                 	}
126:                         IEC0bits.INT4IE=0; // section critique désactive interruption
9D000200  8C641060   LW A0, 4192(V1)
9D000204  7C04BDC4   INS A0, ZERO, 23, 1
9D000208  AC641060   SW A0, 4192(V1)
127:                 	if (head==tail){
9D00020C  93848019   LBU A0, -32743(GP)
9D000210  308400FF   ANDI A0, A0, 255
9D000214  9383801A   LBU V1, -32742(GP)
9D000218  306300FF   ANDI V1, V1, 255
9D00021C  14830005   BNE A0, V1, 0x9D000234
9D000220  3C03BF88   LUI V1, -16504
128:                 		rx_flags &= ~F_RCVD;
9D000224  9383801E   LBU V1, -32738(GP)
9D000228  306300FD   ANDI V1, V1, 253
9D00022C  A383801E   SB V1, -32738(GP)
129:                 	}
130:                         IEC0bits.INT4IE=1; // fin section critique réactive interruption
9D000230  3C03BF88   LUI V1, -16504
9D000234  8C641060   LW A0, 4192(V1)
9D000238  24050001   ADDIU A1, ZERO, 1
9D00023C  7CA4BDC4   INS A0, A1, 23, 1
9D000240  AC641060   SW A0, 4192(V1)
131:                 	return code;
132:                 }// GetScancode()
9D000244  03E00008   JR RA
9D000248  00000000   NOP
133:                 
134:                 extern const t_scan2key translate[],alt_char[],xt_char[],shifted_key[];
135:                 
136:                 short GetKey(short scancode){  // obtient la transcription du code en ASCII
9D000260  7C042620   SEH A0, A0
137:                 	int a,i;
138:                 	a=0;
9D0002D0  0B400111   J 0x9D000444
9D0002D4  00001021   ADDU V0, ZERO, ZERO
139:                 	if (scancode & XT_BIT){
9D000264  3085FFFF   ANDI A1, A0, -1
9D000268  30A20100   ANDI V0, A1, 256
9D00026C  1040001A   BEQ V0, ZERO, 0x9D0002D8
9D000270  2402004A   ADDIU V0, ZERO, 74
140:                 		i=0;
141:                 		while (xt_char[i].code){
9D000280  3C059D00   LUI A1, -25344
9D000284  0B4000AE   J 0x9D0002B8
9D000288  24A521E8   ADDIU A1, A1, 8680
9D0002BC  00021840   SLL V1, V0, 1
9D0002C0  00651821   ADDU V1, V1, A1
9D0002C4  90630000   LBU V1, 0(V1)
9D0002C8  1460FFF0   BNE V1, ZERO, 0x9D00028C
9D0002CC  00000000   NOP
142:                 			if (xt_char[i].code==scancode){
9D000274  10820009   BEQ A0, V0, 0x9D00029C
9D000278  00803021   ADDU A2, A0, ZERO
9D00027C  00001021   ADDU V0, ZERO, ZERO
9D00028C  5466000B   BNEL V1, A2, 0x9D0002BC
9D000290  24420001   ADDIU V0, V0, 1
9D00029C  00001021   ADDU V0, ZERO, ZERO
143:                 				a=xt_char[i].ascii;
9D000294  0B4000A9   J 0x9D0002A4
9D000298  00021040   SLL V0, V0, 1
9D0002A0  00021040   SLL V0, V0, 1
9D0002A4  3C039D00   LUI V1, -25344
9D0002A8  246321E8   ADDIU V1, V1, 8680
9D0002AC  00431021   ADDU V0, V0, V1
144:                 				break;
9D0002B0  0B400111   J 0x9D000444
9D0002B4  90420001   LBU V0, 1(V0)
145:                 			}
146:                 			i++;
9D0002B8  24420001   ADDIU V0, V0, 1
147:                 		} // while (xt_char[i].code)
148:                 	}else if (rx_flags & F_SHIFT){
9D0002D8  9382801E   LBU V0, -32738(GP)
9D0002DC  30420008   ANDI V0, V0, 8
9D0002E0  14400007   BNE V0, ZERO, 0x9D000300
9D0002E4  30A500FF   ANDI A1, A1, 255
149:                 		i=0;
150:                 		while (shifted_key[i].code){
9D00030C  3C069D00   LUI A2, -25344
9D000310  0B4000D3   J 0x9D00034C
9D000314  24C621BC   ADDIU A2, A2, 8636
9D000350  00021840   SLL V1, V0, 1
9D000354  00661821   ADDU V1, V1, A2
9D000358  90630000   LBU V1, 0(V1)
9D00035C  1460FFEE   BNE V1, ZERO, 0x9D000318
9D000360  00000000   NOP
151:                 			if (shifted_key[i].code==(scancode&0xff)){
9D000300  2402000E   ADDIU V0, ZERO, 14
9D000304  10A20008   BEQ A1, V0, 0x9D000328
9D000308  00001021   ADDU V0, ZERO, ZERO
9D000318  5465000D   BNEL V1, A1, 0x9D000350
9D00031C  24420001   ADDIU V0, V0, 1
152:                 				a=shifted_key[i].ascii;
9D000320  0B4000CB   J 0x9D00032C
9D000324  00021040   SLL V0, V0, 1
9D000328  00021040   SLL V0, V0, 1
9D00032C  3C039D00   LUI V1, -25344
9D000330  246321BC   ADDIU V1, V1, 8636
9D000334  00431021   ADDU V0, V0, V1
9D000338  90420001   LBU V0, 1(V0)
153:                 				break;
154:                 			}
155:                 			i++;
9D00034C  24420001   ADDIU V0, V0, 1
156:                 		}// while (shifted_key.code)
157:                 		if (!a){
9D00033C  14400042   BNE V0, ZERO, 0x9D000448
9D000340  2403FF00   ADDIU V1, ZERO, -256
158:                 			i=0;
159:                 			while (translate[i].code){
9D000374  0B4000EE   J 0x9D0003B8
9D000378  24C62134   ADDIU A2, A2, 8500
9D0003BC  00021840   SLL V1, V0, 1
9D0003C0  00661821   ADDU V1, V1, A2
9D0003C4  90630000   LBU V1, 0(V1)
9D0003C8  1460FFEC   BNE V1, ZERO, 0x9D00037C
9D0003CC  00000000   NOP
9D0003D0  0B400111   J 0x9D000444
9D0003D4  00001021   ADDU V0, ZERO, ZERO
160:                 				if (translate[i].code==(scancode&0xff)){
9D000344  0B4000DA   J 0x9D000368
9D000348  2402001C   ADDIU V0, ZERO, 28
9D000364  2402001C   ADDIU V0, ZERO, 28
9D000368  10A20008   BEQ A1, V0, 0x9D00038C
9D00036C  3C069D00   LUI A2, -25344
9D000370  00001021   ADDU V0, ZERO, ZERO
9D00037C  5465000F   BNEL V1, A1, 0x9D0003BC
9D000380  24420001   ADDIU V0, V0, 1
9D00038C  00001021   ADDU V0, ZERO, ZERO
161:                 					a=translate[i].ascii;
9D000384  0B4000E5   J 0x9D000394
9D000388  00021040   SLL V0, V0, 1
9D000390  00021040   SLL V0, V0, 1
9D000394  3C039D00   LUI V1, -25344
9D000398  24632134   ADDIU V1, V1, 8500
9D00039C  00431021   ADDU V0, V0, V1
9D0003A0  90420001   LBU V0, 1(V0)
162:                 					break;
163:                 				}
164:                 				i++;
9D0003B8  24420001   ADDIU V0, V0, 1
165:                 			}// while (translate.code)
166:                 			if (a>='a' && a<='z'){
9D0003A4  2445FF9F   ADDIU A1, V0, -97
9D0003A8  2CA5001A   SLTIU A1, A1, 26
167:                 				a -=32;
9D0003AC  2443FFE0   ADDIU V1, V0, -32
9D0003B0  0B400111   J 0x9D000444
9D0003B4  0065100B   MOVN V0, V1, A1
168:                 			}
169:                 		} // if (!a)
170:                 	}else{
171:                 		i=0;
172:                 		while (translate[i].code){
9D0002F4  3C069D00   LUI A2, -25344
9D0002F8  0B400105   J 0x9D000414
9D0002FC  24C62134   ADDIU A2, A2, 8500
9D000418  00021840   SLL V1, V0, 1
9D00041C  00661821   ADDU V1, V1, A2
9D000420  90630000   LBU V1, 0(V1)
9D000424  1460FFEC   BNE V1, ZERO, 0x9D0003D8
9D000428  00000000   NOP
9D00042C  0B400111   J 0x9D000444
9D000430  00001021   ADDU V0, ZERO, ZERO
173:                 			if (translate[i].code==(scancode&0xff)){
9D0002E8  2402001C   ADDIU V0, ZERO, 28
9D0002EC  10A2003E   BEQ A1, V0, 0x9D0003E8
9D0002F0  00001021   ADDU V0, ZERO, ZERO
9D0003D8  5465000F   BNEL V1, A1, 0x9D000418
9D0003DC  24420001   ADDIU V0, V0, 1
174:                 				a=translate[i].ascii;
9D0003E0  0B4000FB   J 0x9D0003EC
9D0003E4  00021040   SLL V0, V0, 1
9D0003E8  00021040   SLL V0, V0, 1
9D0003EC  3C039D00   LUI V1, -25344
9D0003F0  24632134   ADDIU V1, V1, 8500
9D0003F4  00431021   ADDU V0, V0, V1
9D0003F8  90420001   LBU V0, 1(V0)
175:                 				break;
176:                 			}
177:                 			i++;
9D000414  24420001   ADDIU V0, V0, 1
178:                 		}// while (translate.code)
179:                 		if (a>='a' && a<='z' && (rx_flags & F_CAPS)){
9D0003FC  2443FF9F   ADDIU V1, V0, -97
9D000400  2C63001A   SLTIU V1, V1, 26
9D000404  1460000B   BNE V1, ZERO, 0x9D000434
9D000408  2403FF00   ADDIU V1, ZERO, -256
9D000434  9385801E   LBU A1, -32738(GP)
9D000438  30A50004   ANDI A1, A1, 4
180:                 			a -=32;
9D00043C  2443FFE0   ADDIU V1, V0, -32
9D000440  0065100B   MOVN V0, V1, A1
181:                 		}
182:                 	}
183:                 	return a|(scancode&0xff00);
9D00040C  0B400113   J 0x9D00044C
9D000410  00832024   AND A0, A0, V1
9D000444  2403FF00   ADDIU V1, ZERO, -256
9D000448  00832024   AND A0, A0, V1
9D00044C  00441025   OR V0, V0, A0
184:                 } // GetKey()
9D000450  03E00008   JR RA
9D000454  7C021620   SEH V0, V0
185:                 
186:                 int KbdSend(char cmd){  // envoie une commande au clavier
9D000458  27BDFFE8   ADDIU SP, SP, -24
9D00045C  AFBF0014   SW RA, 20(SP)
9D000460  7C042420   SEB A0, A0
187:                     register unsigned int dly;
188:                         bit_cnt=0;
9D000464  A380801C   SB ZERO, -32740(GP)
189:                 	parity=0;
9D000468  A380801D   SB ZERO, -32739(GP)
190:                 	IEC0CLR=_IEC0_INT4IE_MASK; // désactive les interruptions sur KBD_CLK
9D00046C  3C030080   LUI V1, 128
9D000470  3C02BF88   LUI V0, -16504
9D000474  AC431064   SW V1, 4196(V0)
191:                         TRISACLR = KBD_CLK; // MCU prend le contrôle de la ligne KBD_CLK
9D000478  24020001   ADDIU V0, ZERO, 1
9D00047C  3C03BF88   LUI V1, -16504
9D000480  AC626014   SW V0, 24596(V1)
192:                         LATACLR = KBD_CLK; //  mis à 0  KBD_CLK
9D000484  3C03BF88   LUI V1, -16504
9D000488  AC626034   SW V0, 24628(V1)
9D00048C  240204C5   ADDIU V0, ZERO, 1221
9D000490  2442FFFF   ADDIU V0, V0, -1
193:                         // délais minimum 100µsec
194:                         for (dly=(100/3*CLK_PER_USEC);dly;dly--);
9D000494  1440FFFF   BNE V0, ZERO, 0x9D000494
9D000498  2442FFFF   ADDIU V0, V0, -1
195:                         TRISACLR = KBD_DAT;	// prend le contrôle de la ligne KBD_DAT
9D00049C  24020002   ADDIU V0, ZERO, 2
9D0004A0  3C03BF88   LUI V1, -16504
9D0004A4  AC626014   SW V0, 24596(V1)
196:                 	LATACLR = KBD_DAT;   	// met KBD_DAT à zéro
9D0004A8  3C03BF88   LUI V1, -16504
9D0004AC  AC626034   SW V0, 24628(V1)
197:                 	TRISASET = KBD_CLK; 	// libère la ligne clock
9D0004B0  24030001   ADDIU V1, ZERO, 1
9D0004B4  3C02BF88   LUI V0, -16504
9D0004B8  AC436018   SW V1, 24600(V0)
198:                         while (!(PORTAbits.RA0)); // attend que la ligne revienne à 1
9D0004BC  3C03BF88   LUI V1, -16504
9D0004C0  8C626020   LW V0, 24608(V1)
9D0004C4  30420001   ANDI V0, V0, 1
9D0004C8  1040FFFD   BEQ V0, ZERO, 0x9D0004C0
9D0004CC  00000000   NOP
199:                         while (bit_cnt<8){      // envoie les 8 bits, le moins significatif en premier.
9D0004D0  9382801C   LBU V0, -32740(GP)
9D0004D4  304200FF   ANDI V0, V0, 255
9D0004D8  2C420008   SLTIU V0, V0, 8
9D0004DC  1040001F   BEQ V0, ZERO, 0x9D00055C
9D0004E0  3C02BF88   LUI V0, -16504
9D000548  9383801C   LBU V1, -32740(GP)
9D00054C  306300FF   ANDI V1, V1, 255
9D000550  2C630008   SLTIU V1, V1, 8
9D000554  1460FFE6   BNE V1, ZERO, 0x9D0004F0
9D000558  00042043   SRA A0, A0, 1
200:                 		while (PORTAbits.RA0);   // attend clock à 0
9D0004F0  8C436020   LW V1, 24608(V0)
9D0004F4  30630001   ANDI V1, V1, 1
9D0004F8  1460FFFD   BNE V1, ZERO, 0x9D0004F0
9D0004FC  30830001   ANDI V1, A0, 1
201:                                 if (cmd&1){
9D000500  10600008   BEQ V1, ZERO, 0x9D000524
9D000504  00000000   NOP
202:                 			LATASET = KBD_DAT;
9D0004EC  3C06BF88   LUI A2, -16504
9D000508  ACC56038   SW A1, 24632(A2)
203:                 			parity++;
9D00050C  9383801D   LBU V1, -32739(GP)
9D000510  24630001   ADDIU V1, V1, 1
9D000514  306300FF   ANDI V1, V1, 255
9D000518  A383801D   SB V1, -32739(GP)
9D00051C  0B40014A   J 0x9D000528
9D000520  00000000   NOP
204:                 		}else{
205:                 			LATACLR = KBD_DAT;
9D0004E4  3C07BF88   LUI A3, -16504
9D0004E8  24050002   ADDIU A1, ZERO, 2
9D000524  ACE56034   SW A1, 24628(A3)
206:                 		}
207:                 		cmd >>= 1;
208:                 		while (!(PORTAbits.RA0)); // attend clock à 1
9D000528  8C436020   LW V1, 24608(V0)
9D00052C  30630001   ANDI V1, V1, 1
9D000530  1060FFFD   BEQ V1, ZERO, 0x9D000528
9D000534  00000000   NOP
209:                 		bit_cnt++;				  // un bit de plus envoyé.
9D000538  9383801C   LBU V1, -32740(GP)
9D00053C  24630001   ADDIU V1, V1, 1
9D000540  306300FF   ANDI V1, V1, 255
9D000544  A383801C   SB V1, -32740(GP)
210:                 	}
211:                         while (PORTAbits.RA0);   // attend clock à 0
9D00055C  3C03BF88   LUI V1, -16504
9D000560  8C626020   LW V0, 24608(V1)
9D000564  30420001   ANDI V0, V0, 1
9D000568  1440FFFD   BNE V0, ZERO, 0x9D000560
9D00056C  00000000   NOP
212:                 	if (!(parity & 1)){
9D000570  9382801D   LBU V0, -32739(GP)
9D000574  30420001   ANDI V0, V0, 1
9D000578  14400005   BNE V0, ZERO, 0x9D000590
9D00057C  24030002   ADDIU V1, ZERO, 2
213:                 		LATASET = KBD_DAT;
9D000580  3C02BF88   LUI V0, -16504
9D000584  AC436038   SW V1, 24632(V0)
214:                 	}else{
215:                 		LATACLR = KBD_DAT;
9D000590  3C02BF88   LUI V0, -16504
9D000594  AC436034   SW V1, 24628(V0)
216:                 	}
217:                 	while (!(PORTAbits.RA0)); // attend clock à 1
9D000588  0B400167   J 0x9D00059C
9D00058C  3C03BF88   LUI V1, -16504
9D000598  3C03BF88   LUI V1, -16504
9D00059C  8C626020   LW V0, 24608(V1)
9D0005A0  30420001   ANDI V0, V0, 1
9D0005A4  1040FFFD   BEQ V0, ZERO, 0x9D00059C
9D0005A8  00000000   NOP
218:                 	while (PORTAbits.RA0);   // attend clock à 0
9D0005AC  3C03BF88   LUI V1, -16504
9D0005B0  8C626020   LW V0, 24608(V1)
9D0005B4  30420001   ANDI V0, V0, 1
9D0005B8  1440FFFD   BNE V0, ZERO, 0x9D0005B0
9D0005BC  3C02BF88   LUI V0, -16504
219:                 	TRISASET = KBD_DAT;  		// libère la ligne data
9D0005C0  24030002   ADDIU V1, ZERO, 2
9D0005C4  AC436018   SW V1, 24600(V0)
220:                 	while (!(PORTAbits.RA0)); // attend clock à 1
9D0005C8  3C03BF88   LUI V1, -16504
9D0005CC  8C626020   LW V0, 24608(V1)
9D0005D0  30420001   ANDI V0, V0, 1
9D0005D4  1040FFFD   BEQ V0, ZERO, 0x9D0005CC
9D0005D8  00000000   NOP
221:                 	while (PORTA & (KBD_DAT+KBD_CLK)); 	// attend que le clavier mette data et clock à 0
9D0005DC  3C03BF88   LUI V1, -16504
9D0005E0  8C626020   LW V0, 24608(V1)
9D0005E4  30420003   ANDI V0, V0, 3
9D0005E8  1440FFFD   BNE V0, ZERO, 0x9D0005E0
9D0005EC  3C04BF88   LUI A0, -16504
222:                 	while (!((PORTA & (KBD_DAT+KBD_CLK))==(KBD_DAT+KBD_CLK))); // attend que les 2 lignes reviennent à 1.
9D0005F0  24030003   ADDIU V1, ZERO, 3
9D0005F4  8C826020   LW V0, 24608(A0)
9D0005F8  30420003   ANDI V0, V0, 3
9D0005FC  1443FFFD   BNE V0, V1, 0x9D0005F4
9D000600  00000000   NOP
223:                 	bit_cnt=0;
9D000604  A380801C   SB ZERO, -32740(GP)
224:                         IFS0CLR=_IFS0_INT4IF_MASK;
9D000608  3C020080   LUI V0, 128
9D00060C  3C03BF88   LUI V1, -16504
9D000610  AC621034   SW V0, 4148(V1)
225:                 	IEC0SET = _IEC0_INT4IE_MASK; // réactivation interruption
9D000614  3C03BF88   LUI V1, -16504
9D000618  AC621068   SW V0, 4200(V1)
226:                         while ((rx_flags & F_ERROR+F_RCVD)==0); // attend keyboard ACK
9D00061C  9382801E   LBU V0, -32738(GP)
9D000620  30420003   ANDI V0, V0, 3
9D000624  1040FFFD   BEQ V0, ZERO, 0x9D00061C
9D000628  00000000   NOP
227:                 	if ((rx_flags & F_ERROR) || (GetScancode()!=KBD_ACK)){
9D00062C  9383801E   LBU V1, -32738(GP)
9D000630  30630001   ANDI V1, V1, 1
9D000634  14600005   BNE V1, ZERO, 0x9D00064C
9D000638  00001021   ADDU V0, ZERO, ZERO
9D00063C  0F400008   JAL GetScancode
9D000640  00000000   NOP
228:                 		return 0;
9D000644  384200FA   XORI V0, V0, 250
9D000648  2C420001   SLTIU V0, V0, 1
229:                 	}else{
230:                 		return 1;
231:                 	}
232:                 } // KbdSend()
9D00064C  8FBF0014   LW RA, 20(SP)
9D000650  03E00008   JR RA
9D000654  27BD0018   ADDIU SP, SP, 24
233:                 
234:                 int SetKbdLeds(unsigned int leds_state){ // contrôle l'état des LEDS du clavier
9D000740  27BDFFE8   ADDIU SP, SP, -24
9D000744  AFBF0014   SW RA, 20(SP)
9D000748  AFB00010   SW S0, 16(SP)
9D00074C  00808021   ADDU S0, A0, ZERO
235:                 	if (!KbdSend(KBD_LED)){
9D000750  0F400116   JAL KbdSend
9D000754  2404FFED   ADDIU A0, ZERO, -19
9D000758  10400004   BEQ V0, ZERO, 0x9D00076C
9D00075C  00001821   ADDU V1, ZERO, ZERO
236:                 		return 0;
9D000768  0002182B   SLTU V1, ZERO, V0
237:                 	}
238:                 	if (!KbdSend(leds_state)){
9D000760  0F400116   JAL KbdSend
9D000764  7C102420   SEB A0, S0
239:                 		return 0;
240:                 	}
241:                 	return 1;
242:                 } // SetKbdLeds()
9D00076C  00601021   ADDU V0, V1, ZERO
9D000770  8FBF0014   LW RA, 20(SP)
9D000774  8FB00010   LW S0, 16(SP)
9D000778  03E00008   JR RA
9D00077C  27BD0018   ADDIU SP, SP, 24
243:                 
244:                 void __ISR(_EXTERNAL_4_VECTOR,IPL6SOFT) kbd_clk_isr(void){
9D000780  415DE800   RDPGPR SP, SP
9D000784  401A7000   MFC0 K0, EPC
9D000788  401B6000   MFC0 K1, Status
9D00078C  27BDFFE0   ADDIU SP, SP, -32
9D000790  AFBA001C   SW K0, 28(SP)
9D000794  401A6002   MFC0 K0, SRSCtl
9D000798  AFBB0018   SW K1, 24(SP)
9D00079C  AFBA0014   SW K0, 20(SP)
9D0007A0  7C1B7844   INS K1, ZERO, 1, 15
9D0007A4  377B1800   ORI K1, K1, 6144
9D0007A8  409B6000   MTC0 K1, Status
9D0007AC  AFA4000C   SW A0, 12(SP)
9D0007B0  AFA30008   SW V1, 8(SP)
9D0007B4  AFA20004   SW V0, 4(SP)
245:                 	switch (bit_cnt){
9D0007B8  9382801C   LBU V0, -32740(GP)
9D0007BC  304200FF   ANDI V0, V0, 255
9D0007C0  24030009   ADDIU V1, ZERO, 9
9D0007C4  10430010   BEQ V0, V1, 0x9D000808
9D0007C8  2403000A   ADDIU V1, ZERO, 10
9D0007CC  10430028   BEQ V0, V1, 0x9D000870
9D0007D0  00000000   NOP
9D0007D4  1440003C   BNE V0, ZERO, 0x9D0008C8
9D0007D8  3C02BF88   LUI V0, -16504
246:                 	case 0:   // start bit
247:                 		if (!(PORTA & KBD_DAT)){
9D0007DC  8C426020   LW V0, 24608(V0)
9D0007E0  30420002   ANDI V0, V0, 2
9D0007E4  5440004D   BNEL V0, ZERO, 0x9D00091C
9D0007E8  3C030080   LUI V1, 128
248:                                     parity=0;
9D0007EC  A380801D   SB ZERO, -32739(GP)
249:                                     bit_cnt++;
9D0007F0  9382801C   LBU V0, -32740(GP)
9D0007F4  24420001   ADDIU V0, V0, 1
9D0007F8  304200FF   ANDI V0, V0, 255
9D0007FC  A382801C   SB V0, -32740(GP)
250:                                 }
251:                 		break;
252:                 	case 9:   // paritée
253:                 		if (PORTA & KBD_DAT)
9D000808  3C02BF88   LUI V0, -16504
9D00080C  8C426020   LW V0, 24608(V0)
9D000810  30420002   ANDI V0, V0, 2
9D000814  10400005   BEQ V0, ZERO, 0x9D00082C
9D000818  00000000   NOP
254:                 			parity++;
9D00081C  9382801D   LBU V0, -32739(GP)
9D000820  24420001   ADDIU V0, V0, 1
9D000824  304200FF   ANDI V0, V0, 255
9D000828  A382801D   SB V0, -32739(GP)
255:                 		if (!(parity & 1)){
9D00082C  9382801D   LBU V0, -32739(GP)
9D000830  30420001   ANDI V0, V0, 1
9D000834  14400008   BNE V0, ZERO, 0x9D000858
9D000838  00000000   NOP
256:                 			rx_flags |= F_ERROR;
9D00083C  9382801E   LBU V0, -32738(GP)
9D000840  304200FF   ANDI V0, V0, 255
9D000844  34420001   ORI V0, V0, 1
9D000848  A382801E   SB V0, -32738(GP)
257:                                         IEC0CLR = _IEC0_INT4IE_MASK; // désactive l'interruption
9D00084C  3C030080   LUI V1, 128
9D000850  3C02BF88   LUI V0, -16504
9D000854  AC431064   SW V1, 4196(V0)
258:                 		}
259:                 		bit_cnt++;
9D000858  9382801C   LBU V0, -32740(GP)
9D00085C  24420001   ADDIU V0, V0, 1
9D000860  304200FF   ANDI V0, V0, 255
9D000864  A382801C   SB V0, -32740(GP)
260:                 		break;
9D000868  0B400247   J 0x9D00091C
9D00086C  3C030080   LUI V1, 128
261:                 	case 10:  // stop bit
262:                 		kbd_queue[tail]=in_byte;
9D000870  9384801A   LBU A0, -32742(GP)
9D000874  308400FF   ANDI A0, A0, 255
9D000878  9383801B   LBU V1, -32741(GP)
9D00087C  306300FF   ANDI V1, V1, 255
9D000880  3C02A000   LUI V0, -24576
9D000884  24422410   ADDIU V0, V0, 9232
9D000888  00821021   ADDU V0, A0, V0
9D00088C  A0430000   SB V1, 0(V0)
263:                 		tail++;
9D000890  9382801A   LBU V0, -32742(GP)
9D000894  24420001   ADDIU V0, V0, 1
9D000898  304200FF   ANDI V0, V0, 255
9D00089C  A382801A   SB V0, -32742(GP)
264:                 		tail &=31;
9D0008A0  9382801A   LBU V0, -32742(GP)
9D0008A4  3042001F   ANDI V0, V0, 31
9D0008A8  A382801A   SB V0, -32742(GP)
265:                 		bit_cnt=0;
9D0008AC  A380801C   SB ZERO, -32740(GP)
266:                 		rx_flags |= F_RCVD;
9D0008B0  9382801E   LBU V0, -32738(GP)
9D0008B4  304200FF   ANDI V0, V0, 255
9D0008B8  34420002   ORI V0, V0, 2
9D0008BC  A382801E   SB V0, -32738(GP)
267:                 		break;
9D0008C0  0B400247   J 0x9D00091C
9D0008C4  3C030080   LUI V1, 128
268:                 	default:
269:                 		in_byte >>=1;
9D0008C8  9382801B   LBU V0, -32741(GP)
9D0008CC  7C423040   EXT V0, V0, 1, 7
9D0008D0  A382801B   SB V0, -32741(GP)
270:                 		if(PORTA & KBD_DAT){
9D0008D4  3C02BF88   LUI V0, -16504
9D0008D8  8C426020   LW V0, 24608(V0)
9D0008DC  30420002   ANDI V0, V0, 2
9D0008E0  10400009   BEQ V0, ZERO, 0x9D000908
9D0008E4  00000000   NOP
271:                 			in_byte |=128;
9D0008E8  9382801B   LBU V0, -32741(GP)
9D0008EC  3042007F   ANDI V0, V0, 127
9D0008F0  34420080   ORI V0, V0, 128
9D0008F4  A382801B   SB V0, -32741(GP)
272:                 			parity++;
9D0008F8  9382801D   LBU V0, -32739(GP)
9D0008FC  24420001   ADDIU V0, V0, 1
9D000900  304200FF   ANDI V0, V0, 255
9D000904  A382801D   SB V0, -32739(GP)
273:                 		}
274:                 		bit_cnt++;
9D000908  9382801C   LBU V0, -32740(GP)
9D00090C  24420001   ADDIU V0, V0, 1
9D000910  304200FF   ANDI V0, V0, 255
9D000914  A382801C   SB V0, -32740(GP)
275:                 	}
276:                         mINT4ClearIntFlag();
9D000800  0B400247   J 0x9D00091C
9D000804  3C030080   LUI V1, 128
9D000918  3C030080   LUI V1, 128
9D00091C  3C02BF88   LUI V0, -16504
9D000920  AC431034   SW V1, 4148(V0)
277:                 } // kbd_clk_isr()
9D000924  8FA4000C   LW A0, 12(SP)
9D000928  8FA30008   LW V1, 8(SP)
9D00092C  8FA20004   LW V0, 4(SP)
9D000930  41606000   DI ZERO
9D000934  000000C0   EHB
9D000938  8FBA001C   LW K0, 28(SP)
9D00093C  8FBB0018   LW K1, 24(SP)
9D000940  409A7000   MTC0 K0, EPC
9D000944  8FBA0014   LW K0, 20(SP)
9D000948  27BD0020   ADDIU SP, SP, 32
9D00094C  409A6002   MTC0 K0, SRSCtl
9D000950  41DDE800   WRPGPR SP, SP
9D000954  409B6000   MTC0 K1, Status
9D000958  42000018   ERET
278:                 
279:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/HardwareProfile.c  -----------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   HardwareProfile.h
21:                   * Author: Jacques Deschênes
22:                   * Description: configuration hardware spécifique, assignation des périphériques
23:                   *     UART2 assigné à PB10,PB11
24:                   * Created on 17 avril 2013, 14:41
25:                   *
26:                   */
27:                  
28:                  #include "HardwareProfile.h"
29:                  #include <plib.h>
30:                  
31:                  volatile unsigned int  sys_tick; // compteur pour les milli-secondes
32:                  
33:                  
34:                  void HardwareInit(){
9D001D38  27BDFFE8   ADDIU SP, SP, -24
9D001D3C  AFBF0014   SW RA, 20(SP)
35:                     SYSTEMConfig(mGetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
36:                     INTEnableSystemMultiVectoredInt();
9D001D64  0F400986   JAL INTEnableSystemMultiVectoredInt
9D001D68  00000000   NOP
37:                     // activation du PROXIMITY TIMER pour les interruption inférieures à IPL=7
38:                  //   INTCONbits.TPC=0;
39:                  //   IPTMRCLR=0xFFFFFFFF;
40:                  //   INTCONbits.TPC=7;
41:                  //   IPTMR=CORE_TICK_RATE/2;
42:                      // configure coretimer pour le sys_tick
43:                  #ifdef USE_CORE_TIMER
44:                     OpenCoreTimer(CORE_TICK_RATE);
9D001D6C  0F400A02   JAL OpenCoreTimer
9D001D70  2404493E   ADDIU A0, ZERO, 18750
45:                     mConfigIntCoreTimer((CT_INT_ON | CT_INT_PRIOR_1 | CT_INT_SUB_PRIOR_0));
9D001D74  24020001   ADDIU V0, ZERO, 1
9D001D78  3C03BF88   LUI V1, -16504
9D001D7C  AC621034   SW V0, 4148(V1)
9D001D80  3C05BF88   LUI A1, -16504
9D001D84  2403001C   ADDIU V1, ZERO, 28
9D001D88  ACA31094   SW V1, 4244(A1)
9D001D8C  3C04BF88   LUI A0, -16504
9D001D90  24060004   ADDIU A2, ZERO, 4
9D001D94  AC861098   SW A2, 4248(A0)
9D001D98  24030003   ADDIU V1, ZERO, 3
9D001D9C  ACA31094   SW V1, 4244(A1)
9D001DA0  AC801098   SW ZERO, 4248(A0)
9D001DA4  3C04BF88   LUI A0, -16504
9D001DA8  AC821064   SW V0, 4196(A0)
9D001DAC  3C04BF88   LUI A0, -16504
9D001DB0  AC821068   SW V0, 4200(A0)
46:                  #endif
47:                     // désactivation de toutes les entrée analogiques.
48:                     ANSELBCLR=0xFFFFFFFF;
9D001DB4  3C04BF88   LUI A0, -16504
9D001DB8  2405FFFF   ADDIU A1, ZERO, -1
9D001DBC  AC856104   SW A1, 24836(A0)
49:                     ANSELACLR=0xFFFFFFFF;
9D001DC0  3C07BF88   LUI A3, -16504
9D001DC4  ACE56004   SW A1, 24580(A3)
50:                      // configuration PB10 sortie et PB11 entrée
51:                     mPORTBSetBits(TX); // mettre à Vdd pour ne pas généré un faux start bit.
9D001DC8  24050400   ADDIU A1, ZERO, 1024
9D001DCC  3C07BF88   LUI A3, -16504
9D001DD0  ACE56138   SW A1, 24888(A3)
52:                     mPORTBSetPinsDigitalOut(TX);      // sortie PB10(Tx), transmission UART2
9D001DD4  3C07BF88   LUI A3, -16504
9D001DD8  ACE56114   SW A1, 24852(A3)
9D001DDC  AC856104   SW A1, 24836(A0)
53:                     mPORTBSetPinsDigitalIn (RX);      // entrée PB11(Rx), réception UART2
9D001DE0  24050800   ADDIU A1, ZERO, 2048
9D001DE4  3C08BF88   LUI T0, -16504
9D001DE8  AD056118   SW A1, 24856(T0)
9D001DEC  AC856104   SW A1, 24836(A0)
54:                     // assignation des périphériques aux broches
55:                     // l'information se trouve dans pps.h
56:                     PPSUnLock;                     // déverrouillage configuration assignation périphérique
57:                     //clavier
58:                     I2C1CONbits.DISSLW=1; // voir pic32mx1xxx/2xxx-errata.pdf rev. E, point 9
9D001DF0  3C04BF80   LUI A0, -16512
9D001DF4  8C855000   LW A1, 20480(A0)
9D001DF8  7C454A44   INS A1, V0, 9, 1
9D001DFC  AC855000   SW A1, 20480(A0)
59:                     RPA0R=0;  // pas de périphérique sur RA0 (keyboard clock)
9D001E00  3C02BF81   LUI V0, -16511
9D001E04  AC40FB00   SW ZERO, -1280(V0)
60:                     RPA1R=0;  // pas de périphérique sur RA1 (keyboard data)
9D001E08  3C02BF81   LUI V0, -16511
9D001E0C  AC40FB04   SW ZERO, -1276(V0)
61:                     RPB3R=0; //  pas de périphérique sur RB3 (status LED)
9D001E10  3C02BF81   LUI V0, -16511
9D001E14  AC40FB38   SW ZERO, -1224(V0)
62:                     TRISBCLR=STATUS_LED; // broche status LED en sortie
9D001E18  24020008   ADDIU V0, ZERO, 8
9D001E1C  ACE26114   SW V0, 24852(A3)
63:                     _status_off();
9D001E20  3C04BF88   LUI A0, -16504
9D001E24  AC826134   SW V0, 24884(A0)
64:                     PPSOutput(4, RPB10, U2TX);  // assignation U2TX sur PB10, (groupe, pin, fonction)
9D001E28  3C02BF81   LUI V0, -16511
9D001E2C  8C44FB54   LW A0, -1196(V0)
9D001E30  24050002   ADDIU A1, ZERO, 2
9D001E34  7CA41804   INS A0, A1, 0, 4
9D001E38  AC44FB54   SW A0, -1196(V0)
65:                     PPSInput (2, U2RX, RPB11);  // assignation U2RX sur PB11, (groupe, fonction, pin)
9D001E3C  3C02BF81   LUI V0, -16511
9D001E40  8C44FA58   LW A0, -1448(V0)
9D001E44  7C641804   INS A0, V1, 0, 4
9D001E48  AC44FA58   SW A0, -1448(V0)
66:                     PPSOutput(2,RPB5,OC2); // 5=OC2  sur PB5 sortie synchronistaiton ntsc
9D001E4C  3C02BF81   LUI V0, -16511
9D001E50  8C44FB40   LW A0, -1216(V0)
9D001E54  24050005   ADDIU A1, ZERO, 5
9D001E58  7CA41804   INS A0, A1, 0, 4
9D001E5C  AC44FB40   SW A0, -1216(V0)
67:                     PPSOutput(1,RPB4,OC1);  // 5=OC1 impulsion déclenchant SPI , Fsync vidéo
9D001E60  3C02BF81   LUI V0, -16511
9D001E64  8C44FB3C   LW A0, -1220(V0)
9D001E68  7CA41804   INS A0, A1, 0, 4
9D001E6C  AC44FB3C   SW A0, -1220(V0)
68:                     PPSOutput(3,RPB6,SDO1); // 3=SDO1 sortie SPI1 (vidéo)
9D001E70  3C02BF81   LUI V0, -16511
9D001E74  8C44FB44   LW A0, -1212(V0)
9D001E78  7C641804   INS A0, V1, 0, 4
9D001E7C  AC44FB44   SW A0, -1212(V0)
69:                     PPSInput(1,SS1,RPB7); // entrée Fsync sur RPB7
9D001E80  3C02BF81   LUI V0, -16511
9D001E84  8C43FA88   LW V1, -1400(V0)
9D001E88  7CC31804   INS V1, A2, 0, 4
9D001E8C  AC43FA88   SW V1, -1400(V0)
70:                     PPSLock;                       // reverrouille pour éviter assignation accidentelle.
71:                  }
9D001E90  8FBF0014   LW RA, 20(SP)
9D001E94  03E00008   JR RA
9D001E98  27BD0018   ADDIU SP, SP, 24
72:                  
73:                  inline unsigned int ticks(void){
74:                      return sys_tick;
9D001E9C  8F82802C   LW V0, -32724(GP)
75:                  } //ticks()
9D001EA0  03E00008   JR RA
9D001EA4  00000000   NOP
76:                  
77:                  inline void delay_us(unsigned int usec){
78:                      for (usec=usec*(CLK_PER_USEC/3);usec;usec--);
9D001EA8  2402000C   ADDIU V0, ZERO, 12
9D001EAC  70821002   MUL V0, A0, V0
9D001EB0  10400003   BEQ V0, ZERO, 0x9D001EC0
9D001EB4  2442FFFF   ADDIU V0, V0, -1
9D001EB8  1440FFFF   BNE V0, ZERO, 0x9D001EB8
9D001EBC  2442FFFF   ADDIU V0, V0, -1
9D001EC0  03E00008   JR RA
9D001EC4  00000000   NOP
79:                  }//delay_us()
80:                  
81:                  void delay_ms(unsigned int msec){
82:                  #ifdef USE_CORE_TIMER
83:                      unsigned int t0;
84:                      t0=sys_tick+msec;
9D001EC8  8F82802C   LW V0, -32724(GP)
9D001ECC  00821021   ADDU V0, A0, V0
85:                      while (sys_tick<t0);
9D001ED0  8F83802C   LW V1, -32724(GP)
9D001ED4  0062182B   SLTU V1, V1, V0
9D001ED8  1460FFFD   BNE V1, ZERO, 0x9D001ED0
9D001EDC  00000000   NOP
86:                  #else
87:                      while (msec--)
88:                          delay_us(1000);
89:                  #endif
90:                  } // delay_ms()
9D001EE0  03E00008   JR RA
9D001EE4  00000000   NOP
91:                  
92:                  #ifdef USE_CORE_TIMER
93:                    //déclaration du gestionnaire d'interruption
94:                     void __ISR(_CORE_TIMER_VECTOR, IPL1SOFT)  CoreTimerHandler(void){
9D001EE8  415DE800   RDPGPR SP, SP
9D001EEC  401A7000   MFC0 K0, EPC
9D001EF0  401B6000   MFC0 K1, Status
9D001EF4  27BDFFE8   ADDIU SP, SP, -24
9D001EF8  AFBA0014   SW K0, 20(SP)
9D001EFC  401A6002   MFC0 K0, SRSCtl
9D001F00  AFBB0010   SW K1, 16(SP)
9D001F04  AFBA000C   SW K0, 12(SP)
9D001F08  7C1B7844   INS K1, ZERO, 1, 15
9D001F0C  377B0400   ORI K1, K1, 1024
9D001F10  409B6000   MTC0 K1, Status
9D001F14  AFA30004   SW V1, 4(SP)
9D001F18  AFA20000   SW V0, 0(SP)
95:                         sys_tick++;
9D001F1C  8F82802C   LW V0, -32724(GP)
9D001F20  24420001   ADDIU V0, V0, 1
9D001F24  AF82802C   SW V0, -32724(GP)
96:                         __asm__("addiu $v0, $zero, 0");
9D001F28  24020000   ADDIU V0, ZERO, 0
97:                         __asm__("mtc0 $v0, $9");
9D001F2C  40824800   MTC0 V0, Count
98:                         __asm__("addiu $v0,$zero,%0"::"I"(CORE_TICK_RATE));
9D001F30  2402493E   ADDIU V0, ZERO, 18750
99:                         __asm__("mtc0 $v0, $11");
9D001F34  40825800   MTC0 V0, Compare
100:                        mCTClearIntFlag();
9D001F38  24030001   ADDIU V1, ZERO, 1
9D001F3C  3C02BF88   LUI V0, -16504
9D001F40  AC431034   SW V1, 4148(V0)
101:                    };
9D001F44  8FA30004   LW V1, 4(SP)
9D001F48  8FA20000   LW V0, 0(SP)
9D001F4C  41606000   DI ZERO
9D001F50  000000C0   EHB
9D001F54  8FBA0014   LW K0, 20(SP)
9D001F58  8FBB0010   LW K1, 16(SP)
9D001F5C  409A7000   MTC0 K0, EPC
9D001F60  8FBA000C   LW K0, 12(SP)
9D001F64  27BD0018   ADDIU SP, SP, 24
9D001F68  409A6002   MTC0 K0, SRSCtl
9D001F6C  41DDE800   WRPGPR SP, SP
9D001F70  409B6000   MTC0 K1, Status
9D001F74  42000018   ERET
102:                 #endif
103:                 
