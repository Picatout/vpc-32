Disassembly Listing for vpc-32
Generated From:
C:/Users/Jacques/Documents/GitHub/VPC-32.X/dist/default/production/VPC-32.X.production.elf
2013-08-26 10:37:15

---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/uart.h  ---------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: Constants & Data Types
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  //DOM-IGNORE-BEGIN
74:                  /****
75:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
76:                         the device file.  Also the UART register set could also be placed there
77:                  *****/
78:                  typedef struct
79:                  {
80:                  	volatile UINT	reg;
81:                  	volatile UINT	clr;
82:                  	volatile UINT	set;
83:                  	volatile UINT	inv;
84:                  }REG_SET;
85:                  
86:                  typedef struct
87:                  {
88:                  	volatile REG_SET	mode;
89:                  	volatile REG_SET	sta;
90:                  	volatile REG_SET    tx;
91:                  	volatile REG_SET	rx;
92:                  	volatile REG_SET	brg;
93:                  }UART_REGS;
94:                  
95:                  extern UART_REGS * const uartReg[];
96:                  //DOM-IGNORE-END
97:                  
98:                  // *****************************************************************************
99:                  /* UART Module
100:                 
101:                   Summary:
102:                     UART modules supported.
103:                 
104:                   Description:
105:                     This enumeration identifies the available UART modules.
106:                 */
107:                 
108:                 typedef enum
109:                 {
110:                 #if defined _UART1
111:                     // UART1 Module ID.
112:                     UART1 = 0,
113:                 #endif
114:                 #if defined _UART2
115:                     // UART2 Module ID.
116:                     UART2,
117:                 #endif
118:                 #ifdef _UART3
119:                     // UART3 Module ID.
120:                     UART3,
121:                 #endif
122:                 #ifdef _UART4
123:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
124:                     UART4,
125:                 #endif
126:                 #ifdef _UART5
127:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
128:                     UART5,
129:                 #endif
130:                 #ifdef _UART6
131:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
132:                     UART6,
133:                 #endif
134:                     // Number of available UART modules.
135:                     UART_NUMBER_OF_MODULES
136:                 
137:                 } UART_MODULE;
138:                 
139:                 
140:                 // *****************************************************************************
141:                 /* UART Enable Modes
142:                 
143:                   Summary:
144:                     Operating modes of UART.
145:                 
146:                   Description:
147:                     This enumeration defines the supported modes in which the UART may be
148:                     enabled or disbled.
149:                 
150:                   Remarks:
151:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
152:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
153:                     has been pre-loaded with data.
154:                 
155:                     The caller should not rely on the specific numbers assigned to any of these
156:                     values as they may change from one processor to the next.
157:                 */
158:                 
159:                 typedef enum
160:                 {
161:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
162:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
163:                 
164:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
165:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
166:                 
167:                 
168:                     // UART Module, receiver and transmitter functionality is not.
169:                     // enabled or disabled
170:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
171:                 
172:                     // UART Module receiver.
173:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
174:                 
175:                     // UART Module transmitter.
176:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
177:                 
178:                 
179:                 } UART_ENABLE_MODE;
180:                 
181:                 // *****************************************************************************
182:                 /* UART Enable Helper Macro
183:                 
184:                   Summary:
185:                     Macro for enabling module operating modes.
186:                 
187:                   Description:
188:                     This macro creates the proper flags for enabling operating modes of the UART module.
189:                 
190:                   Example:
191:                     <code>
192:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
193:                     </code>
194:                 
195:                   Remarks:
196:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
197:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
198:                     has been pre-loaded with data.
199:                 */
200:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
201:                 
202:                 // *****************************************************************************
203:                 /* UART Disable Helper Macro
204:                 
205:                   Summary:
206:                     Macro for disabling module operating modes.
207:                 
208:                   Description:
209:                     This macro creates the proper flags for disabling operating modes of the UART module.
210:                 
211:                   Example:
212:                     <code>
213:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
214:                     </code>
215:                 
216:                 */
217:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
218:                 
219:                 // *****************************************************************************
220:                 /* UART Configuration Settings
221:                 
222:                   Summary:
223:                     Supported configuration flags for the UART module.
224:                 
225:                   Description:
226:                     This enumeration defines the various configuration options for the UART
227:                     module.  These values can be OR'd together to create a configuration mask
228:                     passed to the UARTConfigure routine.
229:                 
230:                   Remarks:
231:                     Several of the configuration options are mutually exclusive:
232:                     * Only one of the "ENABLE_PINS" modes can be used at a time
233:                     * Only one of the "RTS_WHEN" modes can be used at a time
234:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
235:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
236:                 
237:                     The caller should not rely on the specific numbers assigned to any of these
238:                     values as they may change from one processor ot the next.
239:                 */
240:                 
241:                 typedef enum
242:                 {
243:                     // Enables high-speed range of the UART (see UARTSetBitRate).
244:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
245:                 
246:                     // Inverts polarity of data interpretation the received (RX) pin.
247:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
248:                 
249:                     // Enables UART TX-to-RX Loop-back mode.
250:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
251:                 
252:                     // Enables Wake-up of the part when a start bit is received.
253:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
254:                 
255:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
256:                     // cannot be used in bit-clock/IrDA mode).
257:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
258:                 
259:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
260:                     // cannot be used in CTS/RTS mode).
261:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
262:                 
263:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
264:                     // be used in RTS-Only mode).
265:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
266:                 
267:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
268:                     // the default mode and this parameter can be left out if it is desired).
269:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
270:                 
271:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
272:                     // is not full (i.e., the UART is ready to receive data).  This is also known
273:                     // as "RTS Flow-Control Mode".
274:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
275:                 
276:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
277:                     // is not empty (i.e., when the UART has data ready to send).  This is also
278:                     // known as "RTS Simplex Mode".
279:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
280:                 
281:                     // Enable the IrDA encoder/decoder.
282:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
283:                 
284:                     // Enables stopping of the UART operation to save power when the core has
285:                     // been put in idle mode.
286:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
287:                 
288:                     // Inverts the polarity of data sent on the transmit (TX) pin.
289:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
290:                 
291:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
292:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
293:                     // Note:  The address must still be set using UARTEnableAddressDetect
294:                     // to support IEEE-485 protocol.
295:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
296:                 
297:                 } UART_CONFIGURATION;
298:                 
299:                 
300:                 // *****************************************************************************
301:                 /* UART FIFO Modes
302:                 
303:                   Summary:
304:                     Supported FIFO modes for the UART module.
305:                 
306:                   Description:
307:                     This enumeration defines supported FIFO modes that determine when the Tx
308:                     and Rx interrupts will occur.
309:                 
310:                   Remarks:
311:                     These modes consist of two sets of mutially exclusive modes:
312:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
313:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
314:                 
315:                     The caller should not rely on the specific numbers assigned to any of these
316:                     values as they may change from one processor ot the next.
317:                 
318:                 */
319:                 
320:                 typedef enum
321:                 {
322:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
323:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
324:                 
325:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
326:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
327:                 
328:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
329:                     // full (i.e. there is space available for more data)  This is the default.
330:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
331:                 
332:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
333:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
334:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
337:                     // (three-quarter) full.
338:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
339:                 
340:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
341:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
342:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
343:                 
344:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
345:                     // data.
346:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
347:                 
348:                 } UART_FIFO_MODE;
349:                 
350:                 
351:                 // *****************************************************************************
352:                 /* UART Line Control Mode
353:                 
354:                   Summary:
355:                     UART line control mode.
356:                 
357:                   Description:
358:                     This data type defines the supported line control modes for the UART.
359:                 
360:                   Remarks:
361:                     Some of the line-control options are mutually exclusive:
362:                     * Only one of the "DATA_SIZE" options can be used at a time
363:                     * Only one of the "PARITY" options can be used at a time
364:                     * Only one of the "STOP_BITS" options can be used at a time
365:                 
366:                     The caller should not rely on the specific numbers assigned to any of these
367:                     values as they may change from one processor ot the next.
368:                 */
369:                 
370:                 typedef enum
371:                 {
372:                     // Sets the data transfer size to 8-bits per frame.
373:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
374:                 
375:                     // Sets the data transfer size to 9-bits per frame.
376:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
377:                 
378:                     // Enables parity bit generation for odd parity.
379:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
380:                 
381:                     // Enables parity bit generation for even parity.
382:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
383:                 
384:                     // Disables parity bit generation.
385:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
386:                 
387:                     // Enables generation of 2 stop bits per frame.
388:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
389:                 
390:                     // Enables generation of 1 stop bit per frame (default).
391:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
392:                 
393:                 } UART_LINE_CONTROL_MODE;
394:                 
395:                 
396:                 // *****************************************************************************
397:                 /* UART Line Status Flags
398:                 
399:                   Summary:
400:                     UART line-status bitmask flags.
401:                 
402:                   Description:
403:                     This enumeration defines the UART line-status bits.  These values are
404:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
405:                 
406:                   Remarks:
407:                     The caller should not rely on the specific numbers assigned to any of these
408:                     values as they may change from one processor ot the next.
409:                 */
410:                 
411:                 typedef enum
412:                 {
413:                     // The transmitter is able to accept data to transmit.
414:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
415:                 
416:                     // The transmitter is empty (no data is available to transmit).
417:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
418:                 
419:                     // The receiver is currently idle.
420:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
421:                 
422:                     // A received data parity error was detected.
423:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
424:                 
425:                     // Data was received that violated the framing protocol (the data word did
426:                     // not start or stop at the appropriate place).  Note:  A break condition
427:                     // will always indicate a framing error.
428:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
429:                 
430:                     // The UART has received more data than it can buffer.  Data has been lost.
431:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
432:                 
433:                     // UART data has been received and is avaiable in the FIFO.
434:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
435:                 
436:                 } UART_LINE_STATUS;
437:                 
438:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
439:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
440:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
441:                 
442:                 
443:                 
444:                 // *****************************************************************************
445:                 /* UART Data
446:                 
447:                   Summary:
448:                     UART data.
449:                 
450:                   Description:
451:                     This data type defines the supported data sizes for the UART.
452:                 */
453:                 
454:                 typedef union
455:                 {
456:                     // 8-bit data
457:                     struct
458:                     {
459:                         UINT16  data8bit    : 8;
460:                     };
461:                 
462:                     // 9-bit data
463:                     struct
464:                     {
465:                         UINT16  data9bit    : 9;
466:                     };
467:                 
468:                     UINT16 __data;
469:                 } UART_DATA;
470:                 
471:                 
472:                 // *****************************************************************************
473:                 // *****************************************************************************
474:                 // Section: UART Peripheral Library Interface Routines
475:                 // *****************************************************************************
476:                 // *****************************************************************************
477:                 
478:                 
479:                 /*******************************************************************************
480:                   Function:
481:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
482:                 
483:                   Summary:
484:                     Enables or disables the given UART module in the desired mode.
485:                 
486:                   Description:
487:                     This routine enables or disables the given UART module in the desired mode.
488:                 
489:                   Precondition:
490:                     The UART module should be appropriately configured before being enabled.
491:                 
492:                   Parameters:
493:                     id    - Identifies the desired UART module.
494:                 
495:                     mode  - Identifies the desired mode of UART operation.
496:                 
497:                   Returns:
498:                     None
499:                 
500:                   Example:
501:                     <code>
502:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
503:                     </code>
504:                 
505:                   Remarks:
506:                     Enabling UART transmissions will immediately cause a TX interrupt to
507:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
508:                     was pre-loaded with data.
509:                   *****************************************************************************/
510:                 
511:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
512:                 
513:                 
514:                 /*******************************************************************************
515:                   Function:
516:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
517:                 
518:                   Summary:
519:                     UART module configuration routine.
520:                 
521:                   Description:
522:                     This routine allows the caller to configure various features of the UART
523:                     module for desired operation.
524:                 
525:                   Precondition:
526:                     None
527:                 
528:                   Parameters:
529:                     id      - Identifies the desired UART module.
530:                 
531:                     flags   - Bit-wise OR of the desired module configuration settings.
532:                 
533:                   Returns:
534:                     None
535:                 
536:                   Example:
537:                     <code>
538:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
539:                     </code>
540:                 
541:                   Remarks:
542:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
543:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
544:                     of these values will result in a value that is not explicitly defined in
545:                     the enumeration.
546:                   *****************************************************************************/
547:                 
548:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
549:                 
550:                 
551:                 /*******************************************************************************
552:                   Function:
553:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
554:                 
555:                   Summary:
556:                     Controls UART module TX and RX FIFO operation.
557:                 
558:                   Description:
559:                     This routine allows the caller to configure when interrupts occur relative
560:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
561:                     or empty the FIFOs are).
562:                 
563:                   Precondition:
564:                     None
565:                 
566:                   Parameters:
567:                     id      - Identifies the desired UART module.
568:                 
569:                     mode    - Bit-wise OR of the desired FIFO mode values.
570:                 
571:                   Returns:
572:                     None
573:                 
574:                   Example:
575:                     <code>
576:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
577:                     </code>
578:                 
579:                   Remarks:
580:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
581:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
582:                     of these values will result in a value that is not explicitly defined in
583:                     the enumeration.
584:                   *****************************************************************************/
585:                 
586:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
587:                 
588:                 
589:                 /*******************************************************************************
590:                   Function:
591:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
592:                 
593:                   Summary:
594:                     Routine to set the UART module's desired data data rate.
595:                 
596:                   Description:
597:                     This routine allows the caller to set the desired data rate for the UART.
598:                 
599:                   Precondition:
600:                     The source clock's frequency must be operating at the frequency passed in the
601:                     "sourceClock" parameter.
602:                 
603:                   Parameters:
604:                     id          - Identifies the desired UART module.
605:                 
606:                     sourceClock - Frequency (Hz) of the source clock being provided to the
607:                                   UART module.
608:                 
609:                     dataRate     - Desired data rate (bits per second).
610:                 
611:                   Returns:
612:                     Actual bit rate selected
613:                 
614:                   Example:
615:                     <code>
616:                 	#define PERIPHERAL_CLOCK    10000000
617:                 	#define DESIRED_DATA_RATE   19200
618:                 	
619:                 	UINT32    actualDataRate;
620:                 
621:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
622:                     </code>
623:                 
624:                   Remarks:
625:                     Actual data rate selected may be slightly different than the data rate
626:                     requested due to truncation error.
627:                 
628:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
629:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
630:                     the maximum data rate is sourceClock/4.
631:                   *****************************************************************************/
632:                 
633:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
634:                 
635:                 
636:                 /*******************************************************************************
637:                   Function:
638:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
639:                 
640:                   Summary:
641:                     Routine to get the UART module's current data data rate.
642:                 
643:                   Description:
644:                     This routine allows the caller to get the current data rate for the UART module.
645:                 
646:                   Precondition:
647:                     The source clock's frequency must be operating at the frequency passed in the
648:                     "sourceClock" parameter.
649:                 
650:                   Parameters:
651:                     id          - Identifies the desired UART module.
652:                 
653:                     sourceClock - Frequency (Hz) of the source clock being provided to the
654:                                   UART module.
655:                 
656:                   Returns:
657:                     The UART's current data rate (bits per second).
658:                 
659:                   Example:
660:                     <code>
661:                 	#define PERIPHERAL_CLOCK    10000000
662:                 	
663:                 	UINT32    currentDataRate;
664:                 
665:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
666:                     </code>
667:                 
668:                   Remarks:
669:                     The current (actual) data rate returned may be slightly different than bit
670:                     rate requested due to truncation error.
671:                   *****************************************************************************/
672:                 
673:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
674:                 
675:                 
676:                 /*******************************************************************************
677:                   Function:
678:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
679:                 
680:                   Summary:
681:                     Routine to set the UART module's desired line control parameters.
682:                 
683:                   Description:
684:                     This routine allows the caller to select the desired size of the UART data
685:                     frame, the generation of parity and framing parameters (collectively
686:                     referred to as the "line control" mode).
687:                 
688:                   Precondition:
689:                 
690:                   Parameters:
691:                     id      - Identifies the desired UART module.
692:                 
693:                     mode    - This is a bit-wise OR of the desired line control mode flags.
694:                 
695:                   Returns:
696:                     None
697:                 
698:                   Example:
699:                     <code>
700:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
701:                     </code>
702:                 
703:                   Remarks:
704:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
705:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
706:                     of these values will result in a value that is not explicitly defined in
707:                     the enumeration.
708:                   *****************************************************************************/
709:                 
710:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
711:                 
712:                 
713:                 /*******************************************************************************
714:                   Function:
715:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
716:                 
717:                   Summary:
718:                     Provides current UART line status.
719:                 
720:                   Description:
721:                     This routine allows the caller to get the current line status of the UART,
722:                     indicating the current state of the transmitter and receiver buffers, and
723:                     if any errors have occurred.
724:                 
725:                   Precondition:
726:                     None
727:                 
728:                   Parameters:
729:                     id      - Identifies the desired UART module.
730:                 
731:                   Returns:
732:                     A bit-wise OR of the current line status flags.
733:                 
734:                   Example:
735:                     <code>
736:                     UART_LINE_STATUS lineStatus;
737:                 	
738:                 	lineStatus = UARTGetLineStatus(UART1);
739:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
740:                     {
741:                         // Handle receiver error
742:                     }
743:                     </code>
744:                 
745:                   Remarks:
746:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
747:                     status flag.
748:                 
749:                     The receiver line status flags are only valid when data has been received
750:                     and for the data at the top of the RX FIFO.
751:                 
752:                     Note that the bitmask resulting from the bit-wise OR of these values will
753:                     result in a value that is not explicitly defined in the enumeration.
754:                   *****************************************************************************/
755:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
756:                 {
757:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
758:                 }
759:                 
760:                 
761:                 /*******************************************************************************
762:                   Function:
763:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
764:                 
765:                   Summary:
766:                     Routine to detect if the transmitter is ready to accept data to transmit.
767:                 
768:                   Description:
769:                     This routine determines if the transmitter is ready to accept more data to
770:                     be transmitted.
771:                 
772:                   Precondition:
773:                     The UART module should have been appropriately configured and enabled.
774:                 
775:                   Parameters:
776:                     id      - Identifies the desired UART module.
777:                 
778:                   Returns:
779:                     Boolean identifying whether or not the transmitter is ready:
780:                     * TRUE    - If the transmitter is ready to accept more data
781:                     * FALSE   - If the transmitter is not ready to accept more data
782:                 
783:                   Example:
784:                     <code>
785:                     unsigned char data;
786:                 	
787:                 	data = 'a';
788:                 	
789:                 	if (UARTTransmitterIsReady(UART1))
790:                     {
791:                         UARTSendDataByte(UART1, data);
792:                     }
793:                     </code>
794:                 
795:                   Remarks:
796:                   *****************************************************************************/
797:                 
798:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
799:                 {
800:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D000154  3C029D00   LUI V0, -25344
9D000158  8FC30000   LW V1, 0(S8)
9D00015C  00031880   SLL V1, V1, 2
9D000160  24422380   ADDIU V0, V0, 9088
9D000164  00621021   ADDU V0, V1, V0
9D000168  8C420000   LW V0, 0(V0)
9D00016C  8C420010   LW V0, 16(V0)
9D000170  30420200   ANDI V0, V0, 512
9D000174  14400004   BNE V0, ZERO, 0x9D000188
9D000178  00000000   NOP
9D00017C  24020001   ADDIU V0, ZERO, 1
9D000180  0B400063   J 0x9D00018C
9D000184  00000000   NOP
9D000188  00001021   ADDU V0, ZERO, ZERO
9D000334  3C029D00   LUI V0, -25344
9D000338  8FC30000   LW V1, 0(S8)
9D00033C  00031880   SLL V1, V1, 2
9D000340  24422380   ADDIU V0, V0, 9088
9D000344  00621021   ADDU V0, V1, V0
9D000348  8C420000   LW V0, 0(V0)
9D00034C  8C420010   LW V0, 16(V0)
9D000350  30420200   ANDI V0, V0, 512
9D000354  14400004   BNE V0, ZERO, 0x9D000368
9D000358  00000000   NOP
9D00035C  24020001   ADDIU V0, ZERO, 1
9D000360  0B4000DB   J 0x9D00036C
9D000364  00000000   NOP
9D000368  00001021   ADDU V0, ZERO, ZERO
801:                 }
802:                 
803:                 
804:                 /*******************************************************************************
805:                   Function:
806:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
807:                 
808:                   Summary:
809:                     Routine to send a byte of data.
810:                 
811:                   Description:
812:                     This routine allows the caller to send a byte of data.
813:                 
814:                   Precondition:
815:                     The UART should have been appropriately configured.  The configuration must
816:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
817:                     have been ready, although not necessarily enabled yet.
818:                 
819:                   Parameters:
820:                     id      - Identifies the desired UART module.
821:                 
822:                     data    - Data byte to be sent.
823:                 
824:                   Returns:
825:                     None
826:                 
827:                   Example:
828:                     <code>
829:                 	unsigned char data;
830:                 	
831:                 	data = 'a';
832:                 	
833:                     if (UARTTransmitterIsReady(UART1))
834:                     {
835:                         UARTSendDataByte(UART1, data);
836:                     }
837:                     </code>
838:                 
839:                   Remarks:
840:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
841:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
842:                     data.
843:                   *****************************************************************************/
844:                 
845:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
846:                 {
847:                     uartReg[id]->tx.reg = data;
9D0001A4  3C029D00   LUI V0, -25344
9D0001A8  8FC30004   LW V1, 4(S8)
9D0001AC  00031880   SLL V1, V1, 2
9D0001B0  24422380   ADDIU V0, V0, 9088
9D0001B4  00621021   ADDU V0, V1, V0
9D0001B8  8C420000   LW V0, 0(V0)
9D0001BC  93C30008   LBU V1, 8(S8)
9D0001C0  AC430020   SW V1, 32(V0)
9D000398  3C029D00   LUI V0, -25344
9D00039C  8FC30004   LW V1, 4(S8)
9D0003A0  00031880   SLL V1, V1, 2
9D0003A4  24422380   ADDIU V0, V0, 9088
9D0003A8  00621021   ADDU V0, V1, V0
9D0003AC  8C420000   LW V0, 0(V0)
9D0003B0  93C30008   LBU V1, 8(S8)
9D0003B4  AC430020   SW V1, 32(V0)
848:                 }
849:                 
850:                 
851:                 /*******************************************************************************
852:                   Function:
853:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
854:                 
855:                   Summary:
856:                     Routine to send data through the UART.
857:                 
858:                   Description:
859:                     This routine allows the caller to send data of any permitted size through
860:                     the UART.
861:                 
862:                   Precondition:
863:                     The UART module should have been appropriately configured.  The configuration must
864:                     have been for desired data size.  The transmitter must have been ready,
865:                     although not necessarily enabled yet.
866:                 
867:                   Parameters:
868:                     id      - Identifies the desired UART module.
869:                 
870:                     data    - Data to be sent.
871:                 
872:                   Returns:
873:                     None
874:                 
875:                   Example:
876:                     <code>
877:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
878:                 	
879:                 	if (UARTTransmitterIsReady(UART1))
880:                     {
881:                         UARTSendData(UART1, data);
882:                     }
883:                     </code>
884:                 
885:                   Remarks:
886:                     Size of the data word size depends on the current configuration (see
887:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
888:                   *****************************************************************************/
889:                 
890:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
891:                 {
892:                     uartReg[id]->tx.reg = data.__data;
893:                 }
894:                 
895:                 /*******************************************************************************
896:                   Function:
897:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
898:                 
899:                   Summary:
900:                     Routine to detect if the UART module has finshed transmitting the most recent
901:                     data.
902:                 
903:                   Description:
904:                     This routine determines if the transmitter has finished sending all
905:                     available data.
906:                 
907:                   Preconditions:
908:                     The UART module should have been appropriately configured and enabled and data
909:                     sent to the UART TX buffer.
910:                 
911:                   Parameters:
912:                     id      - Identifies the desired UART module.
913:                 
914:                   Returns:
915:                     Boolean identifying if the transmission has completed:
916:                     * TRUE    - If the transmitter has completed sending the data
917:                     * FALSE   - If the transmitter is still busy sending the data
918:                 
919:                   Example:
920:                     <code>
921:                 	if (UARTTransmissionHasCompleted(UART1))
922:                     {
923:                         // Perform any tasks necessary when all data has been sent
924:                     }
925:                     </code>
926:                 
927:                   Remarks:
928:                   *****************************************************************************/
929:                 
930:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
931:                 {
932:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
9D0003D0  3C029D00   LUI V0, -25344
9D0003D4  8FC3000C   LW V1, 12(S8)
9D0003D8  00031880   SLL V1, V1, 2
9D0003DC  24422380   ADDIU V0, V0, 9088
9D0003E0  00621021   ADDU V0, V1, V0
9D0003E4  8C420000   LW V0, 0(V0)
9D0003E8  8C420010   LW V0, 16(V0)
9D0003EC  30420100   ANDI V0, V0, 256
9D0003F0  10400004   BEQ V0, ZERO, 0x9D000404
9D0003F4  00000000   NOP
9D0003F8  24020001   ADDIU V0, ZERO, 1
9D0003FC  0B400102   J 0x9D000408
9D000400  00000000   NOP
9D000404  00001021   ADDU V0, ZERO, ZERO
933:                 }
934:                 
935:                 
936:                 /*******************************************************************************
937:                   Function:
938:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
939:                 
940:                   Summary:
941:                     Routine to detect if the receiver has data available.
942:                 
943:                   Description:
944:                     This routine determines if the receiver has data available to be read.
945:                 
946:                   Precondition:
947:                     The UART module must have been configured appropriately and enabled. A complete
948:                     data frame must have been sent to the UART before it will return a TRUE.
949:                 
950:                   Parameters:
951:                     id      - Identifies the desired UART module.
952:                 
953:                   Returns:
954:                     Boolean identifying whether or not data is available:
955:                     * TRUE    - If the receiver has data available
956:                     * FALSE   - If the receiver does not have data availble
957:                 
958:                   Example:
959:                     <code>
960:                     UART_DATA data;
961:                 	
962:                 	if (UARTReceivedDataIsAvailable(UART1))
963:                     {
964:                         data = UARTGetData(UART1);
965:                     }
966:                     </code>
967:                 
968:                   Remarks:
969:                     This routine provides the same information as the UART_DATA_READY line
970:                     status flag.
971:                   *****************************************************************************/
972:                 
973:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
974:                 {
975:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
9D0000C0  3C029D00   LUI V0, -25344
9D0000C4  8FC30000   LW V1, 0(S8)
9D0000C8  00031880   SLL V1, V1, 2
9D0000CC  24422380   ADDIU V0, V0, 9088
9D0000D0  00621021   ADDU V0, V1, V0
9D0000D4  8C420000   LW V0, 0(V0)
9D0000D8  8C420010   LW V0, 16(V0)
9D0000DC  30420001   ANDI V0, V0, 1
9D00020C  3C029D00   LUI V0, -25344
9D000210  8FC30004   LW V1, 4(S8)
9D000214  00031880   SLL V1, V1, 2
9D000218  24422380   ADDIU V0, V0, 9088
9D00021C  00621021   ADDU V0, V1, V0
9D000220  8C420000   LW V0, 0(V0)
9D000224  8C420010   LW V0, 16(V0)
9D000228  30420001   ANDI V0, V0, 1
9D000280  3C029D00   LUI V0, -25344
9D000284  8FC3000C   LW V1, 12(S8)
9D000288  00031880   SLL V1, V1, 2
9D00028C  24422380   ADDIU V0, V0, 9088
9D000290  00621021   ADDU V0, V1, V0
9D000294  8C420000   LW V0, 0(V0)
9D000298  8C420010   LW V0, 16(V0)
9D00029C  30420001   ANDI V0, V0, 1
9D000454  3C029D00   LUI V0, -25344
9D000458  8FC30018   LW V1, 24(S8)
9D00045C  00031880   SLL V1, V1, 2
9D000460  24422380   ADDIU V0, V0, 9088
9D000464  00621021   ADDU V0, V1, V0
9D000468  8C420000   LW V0, 0(V0)
9D00046C  8C420010   LW V0, 16(V0)
9D000470  30420001   ANDI V0, V0, 1
9D0005CC  3C029D00   LUI V0, -25344
9D0005D0  8FC30004   LW V1, 4(S8)
9D0005D4  00031880   SLL V1, V1, 2
9D0005D8  24422380   ADDIU V0, V0, 9088
9D0005DC  00621021   ADDU V0, V1, V0
9D0005E0  8C420000   LW V0, 0(V0)
9D0005E4  8C420010   LW V0, 16(V0)
9D0005E8  30420001   ANDI V0, V0, 1
976:                 }
977:                 
978:                 
979:                 /*******************************************************************************
980:                   Function:
981:                     BYTE UARTGetDataByte ( UART_MODULE id )
982:                 
983:                   Summary:
984:                     Routine to get a byte of data received by the UART.
985:                 
986:                   Description:
987:                     This routine allows the caller to read a byte of data received by the UART.
988:                 
989:                   Precondition:
990:                     The UART module must have been appropriately configured, the configuration must
991:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
992:                     been enabled.  Also, a complete data frame must have been received by the UART.
993:                 
994:                   Parameters:
995:                     id      - Identifies the desired UART module.
996:                 
997:                   Returns:
998:                     A byte of data received by the UART.
999:                 
1000:                  Example:
1001:                    <code>
1002:                    unsigned char data;
1003:                	
1004:                	if (UARTReceivedDataIsAvailable(UART1))
1005:                    {
1006:                        data = UARTGetDataByte(UART1);
1007:                    }
1008:                    </code>
1009:                
1010:                  Remarks:
1011:                    This routine is optimized for receiving 8-bit data through the UART.
1012:                  *****************************************************************************/
1013:                
1014:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1015:                {
1016:                    return (BYTE)uartReg[id]->rx.reg;
9D0000F0  3C029D00   LUI V0, -25344
9D0000F4  8FC30004   LW V1, 4(S8)
9D0000F8  00031880   SLL V1, V1, 2
9D0000FC  24422380   ADDIU V0, V0, 9088
9D000100  00621021   ADDU V0, V1, V0
9D000104  8C420000   LW V0, 0(V0)
9D000108  8C420030   LW V0, 48(V0)
9D00010C  304200FF   ANDI V0, V0, 255
9D00023C  3C029D00   LUI V0, -25344
9D000240  8FC30008   LW V1, 8(S8)
9D000244  00031880   SLL V1, V1, 2
9D000248  24422380   ADDIU V0, V0, 9088
9D00024C  00621021   ADDU V0, V1, V0
9D000250  8C420000   LW V0, 0(V0)
9D000254  8C420030   LW V0, 48(V0)
9D000258  304200FF   ANDI V0, V0, 255
9D0002B0  3C029D00   LUI V0, -25344
9D0002B4  8FC30010   LW V1, 16(S8)
9D0002B8  00031880   SLL V1, V1, 2
9D0002BC  24422380   ADDIU V0, V0, 9088
9D0002C0  00621021   ADDU V0, V1, V0
9D0002C4  8C420000   LW V0, 0(V0)
9D0002C8  8C420030   LW V0, 48(V0)
9D0002CC  304200FF   ANDI V0, V0, 255
9D000484  3C029D00   LUI V0, -25344
9D000488  8FC3001C   LW V1, 28(S8)
9D00048C  00031880   SLL V1, V1, 2
9D000490  24422380   ADDIU V0, V0, 9088
9D000494  00621021   ADDU V0, V1, V0
9D000498  8C420000   LW V0, 0(V0)
9D00049C  8C420030   LW V0, 48(V0)
9D0004A0  304200FF   ANDI V0, V0, 255
9D0005FC  3C029D00   LUI V0, -25344
9D000600  8FC30008   LW V1, 8(S8)
9D000604  00031880   SLL V1, V1, 2
9D000608  24422380   ADDIU V0, V0, 9088
9D00060C  00621021   ADDU V0, V1, V0
9D000610  8C420000   LW V0, 0(V0)
9D000614  8C420030   LW V0, 48(V0)
9D000618  304200FF   ANDI V0, V0, 255
1017:                }
1018:                
1019:                
1020:                /*******************************************************************************
1021:                  Function:
1022:                    UART_DATA UARTGetData ( UART_MODULE id )
1023:                
1024:                  Summary:
1025:                    Routine to get data received by the UART.
1026:                
1027:                  Description:
1028:                    This routine allows the caller to read a data word received by the UART.
1029:                
1030:                  Precondition:
1031:                    The module must have been appropriately configured, the UART module must have been
1032:                    enabled, and a complete data frame must have been received by the UART.
1033:                
1034:                  Parameters:
1035:                    id      - Identifies the desired UART module.
1036:                
1037:                  Returns:
1038:                    Data received by the UART.
1039:                
1040:                  Example:
1041:                    <code>
1042:                    UART_DATA data;
1043:                	
1044:                	if (UARTReceivedDataIsAvailable(UART1))
1045:                    {
1046:                        data = UARTGetData(UART1);
1047:                    }
1048:                    </code>
1049:                
1050:                  Remarks:
1051:                    Size of the data word depends on the current configuration (see
1052:                    UARTSetLineControl).
1053:                  *****************************************************************************/
1054:                
1055:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1056:                {
1057:                    UART_DATA data;
1058:                
1059:                    data.__data = uartReg[id]->rx.reg;
1060:                
1061:                    return data;
1062:                }
1063:                
1064:                
1065:                /*******************************************************************************
1066:                  Function:
1067:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1068:                
1069:                  Summary:
1070:                    Routine to program the address for which the UART module may watch.
1071:                
1072:                  Description:
1073:                    This routine programs the 8-bit address for which the module may watch.
1074:                
1075:                  Precondition:
1076:                    None
1077:                
1078:                  Parameters:
1079:                    id      - Identifies the desired UART module.
1080:                
1081:                    address - 8-bit address for which the module will watch.
1082:                
1083:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1084:                              * TRUE - Enable address watch mode
1085:                              * FALSE - Disable address watch mode
1086:                
1087:                  Returns:
1088:                    None.
1089:                
1090:                  Example:
1091:                    <code>
1092:                    #define SLAVE_ADDRESS  0x42
1093:                	
1094:                	UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1095:                    </code>
1096:                
1097:                  Remarks:
1098:                    The module can be placed into a mode where it will ignore all data received
1099:                    until it identifies the programmed adress.  After the programmed address
1100:                    has been identified, it will begin receiving data normally.  This mode is
1101:                    particularly useful for supporting the IEEE-485 protocol.
1102:                  *****************************************************************************/
1103:                
1104:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1105:                
1106:                
1107:                /*******************************************************************************
1108:                  Function:
1109:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1110:                
1111:                  Summary:
1112:                    Routine to enable or disable recognition of the programmed address byte.
1113:                
1114:                  Description:
1115:                    This routine can enable or disable the "address watch" mode.  In this mode,
1116:                    the UART module will ignore all data until it recognizes the programmed address.
1117:                
1118:                  Precondition:
1119:                    UART should have already been enabled and set with watch address.
1120:                
1121:                  Parameters:
1122:                    id      - Identifies the desired UART module.
1123:                
1124:                    watch   - Determines if the "address watch" mode will be enabled or
1125:                              disabled.
1126:                              * TRUE - Enable address watch mode
1127:                              * FALSE - Disable address watch mode
1128:                
1129:                  Returns:
1130:                    None.
1131:                
1132:                  Example:
1133:                    <code>
1134:                    #define SLAVE_ADDRESS 0x42
1135:                	
1136:                	// Set the address, but don't enable the watch until later,
1137:                	// UART continues to receive data normally
1138:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1139:                
1140:                    // ...
1141:                
1142:                    // Now begin to ignore all UART traffic until we are addressed
1143:                    UARTWatchForAddress(UART1, TRUE);
1144:                    </code>
1145:                
1146:                  Remarks:
1147:                    The UART module can be placed into a mode where it will ignore all data received
1148:                    until it identifies the programmed address.  After the programmed address
1149:                    has been identified, it will begin receiving data normally.  This mode is
1150:                    particularly useful for supporting the IEEE-485 protocol.
1151:                  *****************************************************************************/
1152:                
1153:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1154:                
1155:                
1156:                /*******************************************************************************
1157:                  Function:
1158:                    void UARTSendBreak ( UART_MODULE id )
1159:                
1160:                  Summary:
1161:                    Routine to send a break signal from the UART.
1162:                
1163:                  Description:
1164:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1165:                
1166:                  Precondition:
1167:                    The UART should have been appropriately configured.  The transmitter should
1168:                    be idle, although not necessarily enabled yet.
1169:                
1170:                  Parameters:
1171:                    id      - Identifies the desired UART module.
1172:                
1173:                  Returns:
1174:                    None
1175:                
1176:                  Example:
1177:                    <code>
1178:                    if (UARTTransmissionHasCompleted(UART1))
1179:                    {
1180:                        UARTSendBreak(UART1);
1181:                    }
1182:                    </code>
1183:                
1184:                  Remarks:
1185:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1186:                    data may be pre-loaded into the FIFO and it will be send immediately
1187:                    following the break signal.
1188:                  *****************************************************************************/
1189:                
1190:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1191:                {
1192:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1193:                }
1194:                
1195:                
1196:                /*******************************************************************************
1197:                  Function:
1198:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1199:                
1200:                  Summary:
1201:                    Routine to automatically determine the data rate (bits-per-second) of an
1202:                    external transmitter to the UART.
1203:                
1204:                  Description:
1205:                    This routine initiates the process of automatically determining the data
1206:                    rate (bits-per-second) of an external transmitter to the UART.
1207:                
1208:                  Precondition:
1209:                    The UART should have been appropriately configured.  The transmitter should
1210:                    be idle, although not necessarily enabled yet.
1211:                
1212:                  Parameters:
1213:                    id      - Identifies the desired UART module.
1214:                
1215:                  Returns:
1216:                    None
1217:                
1218:                  Example:
1219:                    <code>
1220:                	// See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1221:                	// methods to detect a Break.
1222:                	
1223:                    if (breakDetected && useAutoRateDetect) 
1224:                    {
1225:                        UARTStartAutoDataRateDetect (UART1);
1226:                    }
1227:                    </code>
1228:                
1229:                  Remarks:
1230:                    The UART module begins measuring the data rate beginning at the next start
1231:                    bit.  The external transmitter should send an alternating pattern (0x55)
1232:                    for the byte to be measured for an effective rate detection.  To ensure
1233:                    an effective measurement sequence, this can be done immediately following
1234:                    a break reception. It is important that this UART module is not
1235:                	transmitting data while it is trying to detect RX baud rate, see the 
1236:                	"PIC32 Family Reference Manual, Sect. 21 UART".
1237:                  *****************************************************************************/
1238:                
1239:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1240:                {
1241:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1242:                }
1243:                
1244:                
1245:                
1246:                /*******************************************************************************
1247:                  Function:
1248:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1249:                
1250:                  Summary:
1251:                    Routine to identify when automatic data rate detection has completed.
1252:                
1253:                  Description:
1254:                    This routine checks to see if automatic data rate detection has completed.
1255:                
1256:                  Precondition:
1257:                    Automatic rate detection should have been previously started.
1258:                
1259:                  Parameters:
1260:                    id      - Identifies the desired UART module.
1261:                
1262:                  Returns:
1263:                    * TRUE    - Indicates that automatic rate detection has completed.
1264:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1265:                
1266:                  Example:
1267:                    <code>
1268:                    #define PERIPHERAL_CLOCK    10000000
1269:                	
1270:                	UINT32 currentRate;
1271:                	
1272:                	if (UARTDataRateDetected(UART1))
1273:                    {
1274:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1275:                    }
1276:                    </code>
1277:                
1278:                  Remarks:
1279:                    This routine returns FALSE after automatic rate detection
1280:                    has been started but before rate is detectdd, it will return TRUE
1281:                	at any other time.
1282:                  *****************************************************************************/
1283:                
1284:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1285:                {
1286:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1287:                }
1288:                
1289:                #ifdef __cplusplus
1290:                  }
1291:                #endif
1292:                
1293:                #endif // _UART_h_
1294:                
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
9D001138  8FC20020   LW V0, 32(S8)
9D00113C  AFC20024   SW V0, 36(S8)
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D001140  8FC30020   LW V1, 32(S8)
9D001144  3C0204C4   LUI V0, 1220
9D001148  3442B401   ORI V0, V0, -19455
9D00114C  0062102B   SLTU V0, V1, V0
9D001150  14400008   BNE V0, ZERO, 0x9D001174
9D001154  00000000   NOP
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
9D001158  3C020008   LUI V0, 8
9D00115C  AFC20028   SW V0, 40(S8)
118:                         pb_clock >>= 1;
9D001160  8FC20024   LW V0, 36(S8)
9D001164  00021042   SRL V0, V0, 1
9D001168  AFC20024   SW V0, 36(S8)
9D00116C  0B40045E   J 0x9D001178
9D001170  00000000   NOP
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
9D001174  AFC00028   SW ZERO, 40(S8)
9D001178  8FC20028   LW V0, 40(S8)
9D00117C  AFC2002C   SW V0, 44(S8)
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
170:                     {
171:                         wait_states++;
172:                         sys_clock -= FLASH_SPEED_HZ;
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
176:                     mCheConfigure(wait_states);
177:                     INTRestoreInterrupts(int_status);
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
227:                     {
228:                         wait_states++;
229:                         sys_clock -= FLASH_SPEED_HZ;
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
233:                     mCheConfigure(wait_states);
234:                     INTRestoreInterrupts(int_status);
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
279:                 
280:                     int_status=INTDisableInterrupts();
281:                 
282:                     mBMXDisableDRMWaitState();
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
286:                     cache_status |= CHE_CONF_PF_ALL;
287:                     mCheConfigure(cache_status);
288:                     CheKseg0CacheOn();
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
9D0010EC  0F4008DE   JAL INTDisableInterrupts
9D0010F0  00000000   NOP
9D0010F4  AFC20018   SW V0, 24(S8)
342:                 
343:                     mBMXDisableDRMWaitState();
9D0010F8  3C02BF88   LUI V0, -16504
9D0010FC  24030040   ADDIU V1, ZERO, 64
9D001100  AC432004   SW V1, 8196(V0)
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
9D001104  8FC20014   LW V0, 20(S8)
9D001108  30420001   ANDI V0, V0, 1
9D00110C  304200FF   ANDI V0, V0, 255
9D001110  10400003   BEQ V0, ZERO, 0x9D001120
9D001114  00000000   NOP
9D001118  8FC20010   LW V0, 16(S8)
9D00111C  AFC2001C   SW V0, 28(S8)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
9D001120  8FC20014   LW V0, 20(S8)
9D001124  30420002   ANDI V0, V0, 2
9D001128  10400065   BEQ V0, ZERO, 0x9D0012C0
9D00112C  00000000   NOP
9D001130  8FC20010   LW V0, 16(S8)
9D001134  AFC20020   SW V0, 32(S8)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
358:                     {
359:                         cache_status = mCheGetCon();
360:                         cache_status |= CHE_CONF_PF_ALL;
361:                         mCheConfigure(cache_status);
362:                         CheKseg0CacheOn();
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
9D0012C0  8FC20010   LW V0, 16(S8)
9D0012C4  AFC20044   SW V0, 68(S8)
367:                     pb_clk >>= OSCCONbits.PBDIV;
9D0012C8  3C02BF81   LUI V0, -16511
9D0012CC  8C42F000   LW V0, -4096(V0)
9D0012D0  7C420CC0   EXT V0, V0, 19, 2
9D0012D4  304200FF   ANDI V0, V0, 255
9D0012D8  8FC30044   LW V1, 68(S8)
9D0012DC  00431006   SRLV V0, V1, V0
9D0012E0  AFC20044   SW V0, 68(S8)
368:                 
369:                     INTRestoreInterrupts(int_status);
9D0012E4  8FC40018   LW A0, 24(S8)
9D0012E8  0F4008BF   JAL INTRestoreInterrupts
9D0012EC  00000000   NOP
370:                 
371:                     return pb_clk;
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/osc.h  ----------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the ?Company?) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Company?s customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  #define _OSC_
47:                  
48:                  /*********************************************************************
49:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
50:                   *
51:                   * Description:	    Sets Osc options and clock source
52:                   *
53:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
54:                   *
55:                   * Inputs:	    	Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
56:                   *
57:                   * Output:          None
58:                   *
59:                   * Example:	    	OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
60:                   *
61:                   * Note:	    	Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
62:                   * 		     		source and then switches to the new clock source
63:                   *
64:                   *		    		Unused parameters are set to zero/default values.
65:                   ********************************************************************/
66:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
67:                  
68:                  	/******************************************************************************
69:                  	 * Available options for source parameter
70:                  	 *****************************************************************************/
71:                  		// CPU Oscillator modes - values are mutually exclusive
72:                  		#define OSC_FRC_DIV 	(7 << _OSCCON_NOSC_POSITION)
73:                  		#define OSC_FRC_DIV16 	(6 << _OSCCON_NOSC_POSITION)
74:                  		#define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
75:                  		#define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
76:                  		#define OSC_POSC_PLL 	(3 << _OSCCON_NOSC_POSITION)
77:                  		#define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
78:                  		#define OSC_FRC_PLL 	(1 << _OSCCON_NOSC_POSITION)
79:                  		#define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
80:                  
81:                  	/******************************************************************************
82:                  	 * Available options for mult parameter
83:                  	 *****************************************************************************/
84:                  		// CPU PLL multiplier values - values are mutually exclusive
85:                  		#define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
86:                  		#define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
87:                  		#define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
88:                  		#define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
89:                  		#define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
90:                  		#define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
91:                  		#define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
92:                  		#define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
93:                  
94:                  	/******************************************************************************
95:                  	 * Available options for post parameter
96:                  	 *****************************************************************************/
97:                  		// CPU PLL output divisor values - values are mutuallye exclusive
98:                  		#define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
99:                  		#define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
100:                 		#define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
101:                 		#define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
102:                 		#define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
103:                 		#define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
104:                 		#define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
105:                 		#define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
106:                 
107:                 	/******************************************************************************
108:                 	 * Available options for div parameter
109:                 	 *****************************************************************************/
110:                 		// CPU FRC output divisor values - values are mutually exclusive
111:                 		#define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
112:                 		#define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
113:                 		#define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
114:                 		#define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
115:                 		#define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
116:                 		#define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
117:                 		#define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
118:                 		#define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
119:                 	/***********************************
120:                 	 * End parameter values
121:                 	 ************************************/
122:                 
123:                 #if (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || \
124:                     (__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 370) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450) || (__PIC32_FEATURE_SET__ == 470))
125:                 	
126:                 		// Reference Oscillator Source Select bits - values are mutually exclusive
127:                 	#define OSC_REFOCON_REFCLKI	 	(7 << _REFOCON_ROSEL_POSITION )
128:                 	#define OSC_REFOCON_SYSPLL 		(7 << _REFOCON_ROSEL_POSITION )
129:                 	#define OSC_REFOCON_USBPLL 		(6 << _REFOCON_ROSEL_POSITION )
130:                 	#define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
131:                 	#define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
132:                 	#define OSC_REFOCON_FRC 		(3 << _REFOCON_ROSEL_POSITION )
133:                 	#define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
134:                 	#define OSC_REFOCON_PBCLK 		(1 << _REFOCON_ROSEL_POSITION )
135:                 	#define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
136:                 		
137:                 	typedef enum
138:                 	{		
139:                 		OSC_REFOCON_RLSPEN		=(1 << _REFOCON_RSLP_POSITION )	,
140:                 		OSC_REFOCON_OE			=(1 << _REFOCON_OE_POSITION ),
141:                 		OSC_REFOCON_SIDLEN		=(1 << _REFOCON_SIDL_POSITION ),
142:                 		OSC_REFOCON_ON			=(1 << _REFOCON_ON_POSITION )
143:                 	} OSCREFConfigFlags;
144:                 	
145:                 	void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
146:                 	 
147:                 
148:                 	#define mOSCREFOTRIMSet(trim) 		(REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
149:                 
150:                 #endif
151:                 
152:                 	 
153:                 	 
154:                 	 
155:                 /*********************************************************************
156:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
157:                  *
158:                  * Description:	Configures peripheral bus divisor
159:                  *
160:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
161:                  *
162:                  * Inputs:    oscPbDiv - desired PB divider
163:                  *
164:                  * Output:      None
165:                  *
166:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
167:                  *
168:                  ********************************************************************/
169:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
170:                 {
171:                 	unsigned int dma_status;
172:                 	unsigned int int_status;
173:                 	__OSCCONbits_t oscBits;
174:                 
175:                 	mSYSTEMUnlock(int_status, dma_status);
9D001180  0F4008DE   JAL INTDisableInterrupts
9D001184  00000000   NOP
9D001188  AFC20030   SW V0, 48(S8)
9D0011D0  AFC20038   SW V0, 56(S8)
9D0011D4  3C02BF81   LUI V0, -16511
9D0011D8  AC40F230   SW ZERO, -3536(V0)
9D0011DC  3C02BF81   LUI V0, -16511
9D0011E0  3C03AA99   LUI V1, -21863
9D0011E4  34636655   ORI V1, V1, 26197
9D0011E8  AC43F230   SW V1, -3536(V0)
9D0011EC  3C02BF81   LUI V0, -16511
9D0011F0  3C035566   LUI V1, 21862
9D0011F4  346399AA   ORI V1, V1, -26198
9D0011F8  AC43F230   SW V1, -3536(V0)
176:                 	
177:                 	oscBits.w=OSCCON;		// read to be in sync. flush any pending write
9D0011FC  3C02BF81   LUI V0, -16511
9D001200  8C42F000   LW V0, -4096(V0)
9D001204  AFC20048   SW V0, 72(S8)
178:                 	oscBits.PBDIV=0;
9D001208  8FC20048   LW V0, 72(S8)
9D00120C  7C02A4C4   INS V0, ZERO, 19, 2
9D001210  AFC20048   SW V0, 72(S8)
179:                 	oscBits.w|=oscPbDiv;	
9D001214  8FC30048   LW V1, 72(S8)
9D001218  8FC2002C   LW V0, 44(S8)
9D00121C  00621025   OR V0, V1, V0
9D001220  AFC20048   SW V0, 72(S8)
180:                 	OSCCON=oscBits.w;		// write back
9D001224  8FC30048   LW V1, 72(S8)
9D001228  3C02BF81   LUI V0, -16511
9D00122C  AC43F000   SW V1, -4096(V0)
181:                 	oscBits.w=OSCCON;		// make sure the write occurred before returning from this function
9D001230  3C02BF81   LUI V0, -16511
9D001234  8C42F000   LW V0, -4096(V0)
9D001238  AFC20048   SW V0, 72(S8)
182:                 	
183:                 	mSYSTEMLock(int_status, dma_status);
9D00123C  3C02BF81   LUI V0, -16511
9D001240  3C033333   LUI V1, 13107
9D001244  34633333   ORI V1, V1, 13107
9D001248  AC43F230   SW V1, -3536(V0)
9D00124C  8FC20038   LW V0, 56(S8)
9D001250  AFC2003C   SW V0, 60(S8)
9D0012B4  8FC40030   LW A0, 48(S8)
9D0012B8  0F4008BF   JAL INTRestoreInterrupts
9D0012BC  00000000   NOP
184:                 }
185:                 
186:                 #define		mOSCSetPBDIV		OSCSetPBDIV		// backward compatibility
187:                 
188:                 
189:                 
190:                 	/******************************************************************************
191:                 	 * Available options for config parameter
192:                 	 *****************************************************************************/
193:                 		// CPU Peripheral Bus divisor values - values are mutually exclusive
194:                 		#define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
195:                 		#define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
196:                 		#define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
197:                 		#define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
198:                 	/***********************************
199:                 	 * End config parameter values
200:                 	 ************************************/
201:                 
202:                 
203:                 /*********************************************************************
204:                  * Function:    mOSCGetPBDIV()
205:                  *
206:                  * Description:	Reads peripheral bus divisor
207:                  *
208:                  * PreCondition:None
209:                  *
210:                  * Inputs:	  	None
211:                  *
212:                  * Output:      None
213:                  *
214:                  * Example:	  	mOSCGetPBDIV()
215:                  *
216:                  ********************************************************************/
217:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
218:                 
219:                 
220:                 /*********************************************************************
221:                  * Function:    mOSCClockFailStatus()
222:                  *
223:                  * Description:	Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
224:                  *
225:                  * PreCondition: None
226:                  *
227:                  * Inputs:	  	None
228:                  *
229:                  * Output:      None
230:                  *
231:                  * Example:	  	mOSCClockFailStatus()
232:                  *
233:                  ********************************************************************/
234:                 #define mOSCClockFailStatus (OSCCONbits.CF)
235:                 
236:                 
237:                 /*********************************************************************
238:                  * Function:      	mOSCEnableSOSC()
239:                  *
240:                  * Description:	  	Enables the LPRC
241:                  *
242:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
243:                  *
244:                  * Inputs:	  		None
245:                  *
246:                  * Output:        	None
247:                  *
248:                  * Example:	  		mOSCEnableSOSC()
249:                  *
250:                  ********************************************************************/
251:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
252:                 
253:                 
254:                 /*********************************************************************
255:                  * Function:      	mOSCDisableSOSC(config)
256:                  *
257:                  * Description:	  	Disables SOSC
258:                  *
259:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
260:                  *
261:                  * Inputs:	  		None
262:                  *
263:                  * Output:        	None
264:                  *
265:                  * Example:	  		mOSCDisableSOSC()
266:                  *
267:                  ********************************************************************/
268:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
269:                 
270:                 
271:                 
272:                 #endif
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/dma_1xx_2xx.h  --------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:    xc.h
8:                    *                  int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Compiler:        MPLAB XC32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the ?Company?) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Company?s customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_H_
43:                  #define _DMA_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  
48:                  // DMA definitions
49:                  
50:                  #ifdef _DMAC0
51:                      #define _DMA_CHANNELS       // DMA channels exist
52:                  
53:                  
54:                  // existent DMA channels
55:                      typedef enum
56:                      {
57:                          DMA_CHANNEL0,
58:                      #ifdef _DMAC1
59:                          DMA_CHANNEL1,
60:                      # ifdef _DMAC2
61:                          DMA_CHANNEL2,
62:                      #  ifdef _DMAC3
63:                          DMA_CHANNEL3,
64:                      #  endif// _DMAC3
65:                      # endif // _DMAC2
66:                      #endif  // _DMAC1
67:                          //  add/remove DMA channel as needed here
68:                  
69:                          DMA_CHANNELS    // number of current available channels
70:                      }DmaChannel;
71:                  
72:                  
73:                      // Relative Dma channels priority, between each other
74:                      typedef enum
75:                      {
76:                          DMA_CHN_PRI0,
77:                          DMA_CHN_PRI1,
78:                          DMA_CHN_PRI2,
79:                          DMA_CHN_PRI3
80:                      }DmaChannelPri;
81:                  
82:                  
83:                  
84:                      // high level definitions for the API functions
85:                  
86:                      typedef enum
87:                      {
88:                          DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
89:                          DMA_OPEN_AUTO   = _DCH0CON_CHAEN_MASK,                  // DMA channel is auto enabled
90:                          DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),   // DMA channel is chained to lower channel
91:                          DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),             // DMA channel is chained to higher channel
92:                          DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,                  // events detection enabled while channel off
93:                          DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,                   // DMA channel is enabled after open
94:                          DMA_OPEN_MATCH  = 0x80000000,                           // DMA channel stops on match
95:                      }DmaOpenFlags;  // flags for the channel open
96:                  
97:                  
98:                      typedef enum
99:                      {
100:                         DMA_EV_ERR =            0x1,        // address error event
101:                         DMA_EV_ABORT =          0x2,        // transfer abort event
102:                         DMA_EV_CELL_DONE =      0x4,        // cell transfer complete event
103:                         DMA_EV_BLOCK_DONE =     0x8,        // block transfer complete event
104:                         DMA_EV_DST_HALF =       0x10,       // destination half event
105:                         DMA_EV_DST_FULL =       0x20,       // destination full event
106:                         DMA_EV_SRC_HALF =       0x40,       // source half event
107:                         DMA_EV_SRC_FULL =       0x80,       // source full event
108:                 
109:                         DMA_EV_ALL_EVNTS=       (DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
110:                                                     DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)                // all available events
111:                     }DmaEvFlags;    // flags for controlling the DMA channel events; Bit fields from the processor header file.
112:                 
113:                 
114:                     typedef enum
115:                     {
116:                         DMA_TXFER_OK,           // the transfer was performed successfully
117:                         DMA_TXFER_ADD_ERR,      // address error while performing the transfer
118:                         DMA_TXFER_ABORT,        // the DMA transfer was aborted
119:                         DMA_TXFER_BC_ERR,       // block complete not set after the DMA transfer performed
120:                         DMA_TXFER_CC_ERR,       // cell complete not set after the DMA transfer performed
121:                         DMA_TXFER_TMO           // DMA transfer timeout
122:                     }DmaTxferRes;       // DMA transfer result
123:                 
124:                     typedef enum
125:                     {
126:                         DMA_WAIT_NOT,       // don't wait for the transfer to complete, return immediately
127:                         DMA_WAIT_CELL,      // wait for the cell transfer to complete, than return
128:                         DMA_WAIT_BLOCK      // wait for the block transfer to complete, than return
129:                     }DmaWaitMode;       // DMA transfer wait mode
130:                 
131:                     typedef enum
132:                     {
133:                         DMA_CHKSUM_CRC,     // LFSR CRC
134:                         DMA_CHKSUM_IP,      // IP Checksum
135:                     }DmaChksumType;     // DMA SFM supported checksum types
136:                 
137:                     typedef enum
138:                     {
139:                         DMA_BITO_MSb,       // MSb first (not reflected)
140:                         DMA_BITO_LSb,       // LSb first (reflected)
141:                     }DmaBitOrder;       // DMA SFM supported bit ordering
142:                 
143:                     typedef enum
144:                     {
145:                         DMA_REORDER_NOT,    // no reordering, destination matches the source
146:                         DMA_REORDER_ENDIAN, // change endianess on word (32 bit) boundaries: LE<->BE
147:                         DMA_REORDER_SWAP_HALF,  // swap half words (16 bit) within word (32 bit)
148:                         DMA_REORDER_SWAP_BYTE,  // swap bytes within half word (16 bit)
149:                     }DmaReorderMode;    // DMA SFM supported re-ordering modes
150:                 
151:                 
152:                     /*********************************************************************
153:                      * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
154:                      *
155:                      * PreCondition:    chPri  - valid channel priority, 0-3
156:                      *
157:                      * Input:           chn    - channel to be configured in the DMA controller
158:                      *                  chPri  - the priority given to the channel, 0-3
159:                      *                  oFlags - orred flags specifying the open mode:
160:                      *                           DMA_OPEN_DEFAULT: DMA default operation mode
161:                      *                           DMA_OPEN_AUTO: DMA channel is auto enabled
162:                      *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
163:                      *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
164:                      *                           DMA_OPEN_DET_EN: events detection enabled while channel off
165:                      *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
166:                      *                           DMA_OPEN_MATCH:    DMA channel stops on match
167:                      *
168:                      *
169:                      *
170:                      * Output:          None
171:                      *
172:                      * Side Effects:    None
173:                      *
174:                      * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
175:                      *
176:                      * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
177:                      *                  Use the low level functions to address special settings.
178:                      *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
179:                      *                  After that the channel is configured.
180:                      *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
181:                      *                  if DMA_OPEN_ENABLE flag was not specified.
182:                      *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
183:                      *                  This way, the transfer will occur correctly together with CRC calculation.
184:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
185:                      *                  User has to call event channel functions to enable the event flags if needed.
186:                      *
187:                      * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
188:                      ********************************************************************/
189:                      void           DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
190:                 
191:                     /*********************************************************************
192:                      * Function:        void DmaChnEnable(DmaChannel chn)
193:                      *
194:                      * PreCondition:    None
195:                      *
196:                      * Input:           chn     - channel to be enabled
197:                      *
198:                      * Output:          None
199:                      *
200:                      * Side Effects:    None
201:                      *
202:                      * Overview:        The function enables a previously configured DMA channel.
203:                      *
204:                      * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
205:                      *
206:                      * Example:         DmaChnEnable(DMA_CHANNEL3);
207:                      ********************************************************************/
208:                      void           DmaChnEnable(DmaChannel chn);
209:                 
210:                     /*********************************************************************
211:                      * Function:        void DmaChnDisable(DmaChannel chn)
212:                      *
213:                      * PreCondition:    None
214:                      *
215:                      * Input:           chn     - selected channel in the DMA controller
216:                      *
217:                      * Output:          None
218:                      *
219:                      * Side Effects:    None
220:                      *
221:                      * Overview:        The function disables a DMA channel. The channel operation stops.
222:                      *
223:                      * Note:            None.
224:                      *
225:                      * Example:         DmaChnDisable(DMA_CHANNEL3);
226:                      ********************************************************************/
227:                      void           DmaChnDisable(DmaChannel chn);
228:                 
229:                     /*********************************************************************
230:                      * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
231:                      *
232:                      * PreCondition:    chn     - valid DMA channel
233:                      *              - vSrcAdd, vDstAdd  - valid pointers
234:                      *                              - 0 < srcSize <= DmaGetMaxTxferSize()
235:                      *                              - 0 < dstSize <= DmaGetMaxTxferSize()
236:                      *                              - 0 < cellSize <= DmaGetMaxTxferSize()
237:                      *
238:                      * Input:           chn         - DMA channel number
239:                      *                              - vSrcAdd: source of the DMA transfer
240:                      *                              - vDstAdd: destination of the DMA transfer
241:                      *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
242:                      *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
243:                      *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
244:                      *
245:                      * Output:          None
246:                      *
247:                      * Side Effects:    None
248:                      *
249:                      * Overview:        The function sets the transfer characteristics for a DMA channel transfer:
250:                      *                  the source and the destination addresses.
251:                      *                  the source and destination lengths
252:                      *                  and the number of bytes transferred per event.
253:                      *
254:                      * Note:            The function clears the existing DMA channel event flags.
255:                      *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
256:                      *
257:                      * Example:         DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
258:                      ********************************************************************/
259:                      void           DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
260:                 
261:                 
262:                     /*********************************************************************
263:                      * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
264:                      *
265:                      * PreCondition:    chn     - valid DMA channel
266:                      *
267:                      * Input:           chn     - DMA channel number
268:                      *              - vSrcAdd: source (virtual) of the DMA transfer
269:                      * Output:          None
270:                      *
271:                      * Side Effects:    None
272:                      *
273:                      * Overview:        The function is a helper to set directly the transfer source address.
274:                      *
275:                      * Note:            None.
276:                      *
277:                      * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
278:                      ********************************************************************/
279:                      void           DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
280:                 
281:                     /*********************************************************************
282:                      * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
283:                      *
284:                      * PreCondition:    chn     - valid DMA channel
285:                      *
286:                      * Input:           chn         - DMA channel number
287:                      *                              - vDstAdd: destination (virtual) of the DMA transfer
288:                      * Output:          None
289:                      *
290:                      * Side Effects:    None
291:                      *
292:                      * Overview:        The function is a helper to set directly the transfer destination address.
293:                      *
294:                      * Note:            None
295:                      *
296:                      * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
297:                      ********************************************************************/
298:                      void           DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
299:                 
300:                     /*********************************************************************
301:                      * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
302:                      *
303:                      * PreCondition:    chn - valid DMA channel
304:                      *
305:                      * Input:           chn     - DMA channel number
306:                      *                  pattern -  the match pattern
307:                      *
308:                      * Output:          None
309:                      *
310:                      * Side Effects:    None
311:                      *
312:                      * Overview:        The function sets the curent match pattern for the selected DMA channel.
313:                      *
314:                      * Note:            None.
315:                      *
316:                      * Example:         DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
317:                      ********************************************************************/
318:                      void           DmaChnSetMatchPattern(DmaChannel chn, int pattern);
319:                 
320:                     /*********************************************************************
321:                      * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
322:                      *
323:                      * PreCondition:    chn - valid DMA channel
324:                      *
325:                      * Input:           chn     - DMA channel number
326:                      *
327:                      * Output:          The channel match pattern.
328:                      *
329:                      * Side Effects:    None
330:                      *
331:                      * Overview:        The function retrieves the curent match pattern for the selected DMA channel.
332:                      *
333:                      * Note:            None.
334:                      *
335:                      * Example:         int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
336:                      ********************************************************************/
337:                      int            DmaChnGetMatchPattern(DmaChannel chn);
338:                 
339:                     /*********************************************************************
340:                      * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
341:                      *
342:                      * PreCondition:    chn - valid DMA channel
343:                      *
344:                      * Input:           chn     - DMA channel number
345:                      *                  wMode   - if DMA_WAIT_NOT, return immediately
346:                      *                          - if DMA_WAIT_CELL, return after the cell transfer complete
347:                      *                          - if DMA_WAIT_BLOCK, return after the whole transfer is done
348:                      *                  retries - retry counter: if transfer not complete after so many retries, return with tmo.
349:                      *                              If 0, wait forever.
350:                      *
351:                      * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
352:                      *                  an DmaTxferRes error code  otherwise
353:                      *
354:                      * Side Effects:    None
355:                      *
356:                      * Overview:        The function initiates (forces) a DMA transfer for the selected DMA channel.
357:                      *                  The DMA channel is enabled.
358:                      *                  If waiting for the transfer completion needed (user doesn't use an ISR to catch
359:                      *                  this event) the function will periodically query the DMA controller for the
360:                      *                  transfer completion status.
361:                      *                  If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
362:                      *                  the block transfer than the function will re-force the transfer for each cell.
363:                      *
364:                      * Note:            This function can not ne used when the DMA channel is triggerred
365:                      *                  by hardware interrupt requests.
366:                      *                  This is because the transfers are software forced, theere is no
367:                      *                  wait for the occurrence of the hardware trigger.
368:                      *
369:                      * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
370:                      ********************************************************************/
371:                      DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
372:                 
373:                     /*********************************************************************
374:                      * Function:        void DmaChnForceTxfer(DmaChannel chn)
375:                      *
376:                      * PreCondition:    chn - valid DMA channel
377:                      *
378:                      * Input:           chn     - DMA channel number
379:                      *
380:                      * Output:          None
381:                      *
382:                      * Side Effects:    None
383:                      *
384:                      * Overview:        The function forces a DMA transfer to occur for the selected DMA channel.
385:                      *
386:                      * Note:            None.
387:                      *
388:                      * Example:         DmaChnForceTxfer(DMA_CHANNEL3);
389:                      ********************************************************************/
390:                      void           DmaChnForceTxfer(DmaChannel chn);
391:                 
392:                     /*********************************************************************
393:                      * Function:        void DmaChnAbortTxfer(DmaChannel chn)
394:                      *
395:                      * PreCondition:    chn - valid DMA channel
396:                      *
397:                      * Input:           chn     - DMA channel number
398:                      *
399:                      * Output:          None
400:                      *
401:                      * Side Effects:    None
402:                      *
403:                      * Overview:        The function aborts a current undergoing DMA transfer for the selected DMA channel.
404:                      *
405:                      * Note:            None.
406:                      *
407:                      * Example:         DmaChnAbortTxfer(DMA_CHANNEL3);
408:                      ********************************************************************/
409:                      void           DmaChnAbortTxfer(DmaChannel chn);
410:                 
411:                     // High level channel event and interrupt control functions
412:                 
413:                     /*********************************************************************
414:                      * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
415:                      *
416:                      * PreCondition:    chn - valid DMA channel
417:                      *
418:                      * Input:           chn     - DMA channel number
419:                      *                  eFlags  - event flags with the following significance:
420:                      *                              - DMA_EV_ERR: address error event
421:                      *                              - DMA_EV_ABORT: transfer abort event
422:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
423:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
424:                      *                              - DMA_EV_DST_HALF: destination half event
425:                      *                              - DMA_EV_DST_FULL: destination full event
426:                      *                              - DMA_EV_SRC_HALF: source half event
427:                      *                              - DMA_EV_SRC_FULL: source full event
428:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
429:                      *
430:                      * Output:          None
431:                      *
432:                      * Side Effects:    None
433:                      *
434:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
435:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
436:                      *                  enabled for the selected channel, the other channel event flags won't be touched.
437:                      *
438:                      * Note:            None.
439:                      *
440:                      * Example:         DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
441:                      ********************************************************************/
442:                      void           DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
443:                 
444:                     /*********************************************************************
445:                      * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
446:                      *
447:                      * PreCondition:    chn - valid DMA channel
448:                      *
449:                      * Input:           chn     - DMA channel number
450:                      *                  eFlags  - event flags with the following significance:
451:                      *                              - DMA_EV_ERR: address error event
452:                      *                              - DMA_EV_ABORT: transfer abort event
453:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
454:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
455:                      *                              - DMA_EV_DST_HALF: destination half event
456:                      *                              - DMA_EV_DST_FULL: destination full event
457:                      *                              - DMA_EV_SRC_HALF: source half event
458:                      *                              - DMA_EV_SRC_FULL: source full event
459:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
460:                      *
461:                      * Output:          None
462:                      *
463:                      * Side Effects:    None
464:                      *
465:                      * Overview:        The function clears the event enable flags for the selected DMA channel.
466:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
467:                      *                  disabled for the selected channel, the other channel event flags won't be touched.
468:                      *
469:                      * Note:            None.
470:                      *
471:                      * Example:         DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
472:                      ********************************************************************/
473:                      void           DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
474:                 
475:                     /*********************************************************************
476:                      * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
477:                      *
478:                      * PreCondition:    chn - valid DMA channel
479:                      *
480:                      * Input:           chn     - DMA channel number
481:                      *                  eFlags  - event flags with the following significance:
482:                      *                              - DMA_EV_ERR: address error event
483:                      *                              - DMA_EV_ABORT: transfer abort event
484:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
485:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
486:                      *                              - DMA_EV_DST_HALF: destination half event
487:                      *                              - DMA_EV_DST_FULL: destination full event
488:                      *                              - DMA_EV_SRC_HALF: source half event
489:                      *                              - DMA_EV_SRC_FULL: source full event
490:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
491:                      *
492:                      * Output:          None
493:                      *
494:                      * Side Effects:    None
495:                      *
496:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
497:                      *                  The channel event flags are forced to the eFlags value.
498:                      *
499:                      * Note:            None.
500:                      *
501:                      * Example:         DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
502:                      ********************************************************************/
503:                      void           DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
504:                 
505:                     /*********************************************************************
506:                      * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
507:                      *
508:                      * PreCondition:    chn - valid DMA channel
509:                      *
510:                      * Input:           chn     - DMA channel number
511:                      *
512:                      * Output:          - event flags with the following significance:
513:                      *                      - DMA_EV_ERR: address error event
514:                      *                      - DMA_EV_ABORT: transfer abort event
515:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
516:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
517:                      *                      - DMA_EV_DST_HALF: destination half event
518:                      *                      - DMA_EV_DST_FULL: destination full event
519:                      *                      - DMA_EV_SRC_HALF: source half event
520:                      *                      - DMA_EV_SRC_FULL: source full event
521:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
522:                      *
523:                      * Side Effects:    None
524:                      *
525:                      * Overview:        The function returns the event enabled flags for the selected DMA channel.
526:                      *
527:                      * Note:            None.
528:                      *
529:                      * Example:         DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
530:                      ********************************************************************/
531:                      DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn);
532:                 
533:                     /*********************************************************************
534:                      * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
535:                      *
536:                      * PreCondition:    chn - valid DMA channel
537:                      *
538:                      * Input:           chn     - DMA channel number
539:                      *                  eFlags  - event flags with the following significance:
540:                      *                              - DMA_EV_ERR: address error event
541:                      *                              - DMA_EV_ABORT: transfer abort event
542:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
543:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
544:                      *                              - DMA_EV_DST_HALF: destination half event
545:                      *                              - DMA_EV_DST_FULL: destination full event
546:                      *                              - DMA_EV_SRC_HALF: source half event
547:                      *                              - DMA_EV_SRC_FULL: source full event
548:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
549:                      *
550:                      * Output:          None
551:                      *
552:                      * Side Effects:    None
553:                      *
554:                      * Overview:        The function clears the event flags for the selected DMA channel.
555:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
556:                      *                  cleared for the selected channel, the other channel event flags won't be touched.
557:                      *
558:                      * Note:            None.
559:                      *
560:                      * Example:         DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
561:                      ********************************************************************/
562:                      void           DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
563:                 
564:                     /*********************************************************************
565:                      * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
566:                      *
567:                      * PreCondition:    chn - valid DMA channel
568:                      *
569:                      * Input:           chn     - DMA channel number
570:                      *
571:                      * Output:          event flags with the following significance:
572:                      *                      - DMA_EV_ERR: address error event
573:                      *                      - DMA_EV_ABORT: transfer abort event
574:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
575:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
576:                      *                      - DMA_EV_DST_HALF: destination half event
577:                      *                      - DMA_EV_DST_FULL: destination full event
578:                      *                      - DMA_EV_SRC_HALF: source half event
579:                      *                      - DMA_EV_SRC_FULL: source full event
580:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
581:                      *
582:                      * Side Effects:    None
583:                      *
584:                      * Overview:        The function returns the event flags for the selected DMA channel.
585:                      *
586:                      * Note:            None.
587:                      *
588:                      * Example:         DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
589:                      ********************************************************************/
590:                      DmaEvFlags DmaChnGetEvFlags(DmaChannel chn);
591:                 
592:                 
593:                     // high level helpers for fast strcpy/memcpy transfers
594:                 
595:                     /*********************************************************************
596:                      * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
597:                      *
598:                      * PreCondition:    chn     - a valid DMA channel
599:                      *                  s1, s2  - valid memory pointers
600:                      *                  n>0, n<=DmaGetMaxTxferSize()
601:                      *
602:                      * Input:           s1      - destination pointer
603:                      *                  s2      - source pointer
604:                      *                  n       - number of bytes to transfer
605:                      *                  chn     - the DMA channel to perform the transfer
606:                      *                  chPri   - the desired channel priority
607:                      *
608:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
609:                      *                  an DmaTxferRes error code  otherwise
610:                      *
611:                      * Side Effects:    None
612:                      *
613:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
614:                      *          Then it copies one block of memory from source to destination.
615:                      *
616:                      *
617:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
618:                      *                    This way, the transfer will occur correctly together with checksum calculation.
619:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
620:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
621:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
622:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
623:                      *
624:                      * Example:     res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
625:                      ********************************************************************/
626:                      DmaTxferRes    DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
627:                 
628:                     /*********************************************************************
629:                      * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
630:                      *
631:                      * PreCondition:    chn     - a valid DMA channel
632:                      *                  s1, s2  - valid memory pointers
633:                      *
634:                      * Input:           s1      - destination pointer
635:                      *                  s2      - source pointer
636:                      *                  chn     - the DMA channel to perform the transfer
637:                      *                  chPri   - the desired channel priority
638:                      *
639:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
640:                      *                  an DmaTxferRes error code  otherwise
641:                      *
642:                      * Side Effects:    None
643:                      *
644:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
645:                      *          Then it copies one zero terminated string from source to destination.
646:                      *
647:                      *
648:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
649:                      *                    This way, the transfer will occur correctly together with checksum calculation.
650:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
651:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
652:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
653:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
654:                      *
655:                      *
656:                      * Example:     res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
657:                      *********************************************************************/
658:                      DmaTxferRes    DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
659:                 
660:                     /*********************************************************************
661:                      * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
662:                      *
663:                      * PreCondition:    chn     - a valid DMA channel
664:                      *              - s1, s2    - valid memory pointers
665:                      *                              - 0 < n <= DmaGetMaxTxferSize()
666:                      *
667:                      * Input:           s1      - destination pointer
668:                      *                  s2      - source pointer
669:                      *                  n   - max number of bytes to transfer
670:                      *                  chn     - the DMA channel to perform the transfer
671:                      *                  chPri   - the desired channel priority
672:                      *
673:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
674:                      *                  an DmaTxferRes error code  otherwise
675:                      *
676:                      * Side Effects:    None
677:                      *
678:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
679:                      *          Then it copies one zero terminated string from source to destination.
680:                      *          It copies no more than n characters from s2.
681:                      *
682:                      *
683:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
684:                      *                    This way, the transfer will occur correctly together with checksum calculation.
685:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
686:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
687:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
688:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
689:                      *
690:                      *
691:                      * Example:     res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
692:                      ********************************************************************/
693:                      DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
694:                 
695:                     /*********************************************************************
696:                      * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
697:                      *
698:                      * PreCondition:    chn    - a valid DMA channel
699:                      *                  d, s   - valid memory pointer
700:                      *                  n>0, n<=DmaGetMaxTxferSize()
701:                      *
702:                      * Input:           d     - address where to deposit the result
703:                      *                  s     - source buffer pointer
704:                      *                  n     - number of bytes in the pointer
705:                      *                  chn   - the DMA channel to use
706:                      *                  chPri - the desired channel priority
707:                      *
708:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
709:                      *                  an DmaTxferRes error code  otherwise
710:                      *
711:                      * Side Effects:    None
712:                      *
713:                      * Overview:        The function is a helper that calculates the CRC of a memory block.
714:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
715:                      *
716:                      *
717:                      * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
718:                      *                  - No transfer is done, just the CRC is calculated.
719:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
720:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
721:                      *                  - The checksum type is switched to CRC.
722:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
723:                      *
724:                      * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
725:                      ********************************************************************/
726:                      DmaTxferRes    DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
727:                 
728:                     /*********************************************************************
729:                      * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
730:                      *
731:                      * PreCondition:    chn    - a valid DMA channel
732:                      *                  d, s   - valid memory pointer
733:                      *                  n>0, n<=DmaGetMaxTxferSize()
734:                      *
735:                      * Input:           d     - address where to deposit the result
736:                      *                  s     - source buffer pointer
737:                      *                  n     - number of bytes in the pointer
738:                      *                  chn   - the DMA channel to use
739:                      *                  chPri - the desired channel priority
740:                      *
741:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
742:                      *                  an DmaTxferRes error code  otherwise
743:                      *
744:                      * Side Effects:    None
745:                      *
746:                      * Overview:        The function is a helper that calculates the IP checksum of a memory block.
747:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
748:                      *
749:                      *
750:                      * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
751:                      *                  - No transfer is done, just the checksum is calculated.
752:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
753:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
754:                      *                  - The checksum type is switched to IP checksum.
755:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
756:                      *
757:                      * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
758:                      ********************************************************************/
759:                      DmaTxferRes    DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
760:                 
761:                     // High level Special Function Module (SFM) functions
762:                 
763:                     /*********************************************************************
764:                      * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
765:                      *
766:                      * PreCondition:    cType, bitO, rMode - valid values
767:                      *
768:                      * Input:           cType - checksum type to be calculated: CRC or IP Checksum
769:                      *                  bitO  - the bit order to be used MSb or LSb first
770:                      *                  rMode - the reordering mode of the bytes when calculating the checksum
771:                      *
772:                      * Output:          None
773:                      *
774:                      * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
775:                      *
776:                      * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
777:                      *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
778:                      *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first)
779:                      *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
780:                      *                      All these values affect the way the checksum is calculated.
781:                      *
782:                      * Note:            None
783:                      *
784:                      * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
785:                      ********************************************************************/
786:                     extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
787:                     {
788:                         DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
789:                         DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
790:                     }
791:                 
792:                     /*********************************************************************
793:                      * Function:        void DmaSfmTxferReorder(int enable)
794:                      *
795:                      * PreCondition:    None
796:                      *
797:                      * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
798:                      *
799:                      * Output:          None
800:                      *
801:                      * Side Effects:    None
802:                      *
803:                      * Overview:        The function configures the data transfer re-ordering of the SFM module.
804:                      *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
805:                      *                  Otherwise the data is written to the destination un-modified.
806:                      *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
807:                      *
808:                      *
809:                      * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
810:                      *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
811:                      *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
812:                      *                    Un-aligned transfers are not supported (undefined behavior)!
813:                      *
814:                      * Example:         DmaSfmTxferReorder();
815:                      ********************************************************************/
816:                     extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
817:                     {
818:                         DCRCCONCLR=_DCRCCON_WBO_MASK;
819:                         DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
820:                     }
821:                 
822:                 
823:                      /*********************************************************************
824:                      * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
825:                      *
826:                      * PreCondition:    pLen   - valid polynomial length within 1-32
827:                      *
828:                      * Input:           polynomial  - the layout of the CRC generator
829:                      *                  pLen        - the length of the CRC generator polynomial
830:                      *                  seed        - the initial seed of the CRC generator
831:                      *
832:                      * Output:          None
833:                      *
834:                      * Side Effects:    None
835:                      *
836:                      * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
837:                      *                  - the length of the CRC generator polynomial, pLen;
838:                      *                  - the function sets the layout of the shift stages that take place in the CRC generation.
839:                      *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
840:                      *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
841:                      *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
842:                      *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
843:                      *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
844:                      *                  - the function sets the seed of the CRC generator. This is the initial data present in the
845:                      *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
846:                      *
847:                      * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
848:                      *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
849:                      *                    Upon the transfer completion the calculated CRC is stored at the destination address.
850:                      *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
851:                      *                    the CrcResult() function.
852:                      *                  - The CRC module should be configured before enabled.
853:                      *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
854:                      *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
855:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
856:                      *
857:                      * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
858:                      ********************************************************************/
859:                     extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
860:                     {
861:                         DCRCCONCLR=_DCRCCON_PLEN_MASK;
862:                         DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
863:                         DCRCDATA=seed;
864:                         DCRCXOR=polynomial;
865:                     }
866:                 
867:                     #define DmaCrcConfigure DmaSfmCrcConfigure  // PIC32_3xx backward compatibility name
868:                 
869:                 
870:                     /*********************************************************************
871:                      * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
872:                      *
873:                      * PreCondition:    chn    - valid DMA channel
874:                      *
875:                      * Input:           chn         - the DMA channel to be attached to the checksum module.
876:                      *                  appendMode  - if TRUE the data passed to the checksum generator is not transferred to destination
877:                      *                                but it's written to the destination address when the block transfer is complete.
878:                      *                              - if FALSE the data is transferred normally while the checksum is calculated.
879:                      *                                The checksum will be available using the DmaSfmChecksum function.
880:                      *
881:                      * Output:          None
882:                      *
883:                      * Side Effects:    None
884:                      *
885:                      * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
886:                      *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
887:                      *                  is complete, the checksum result is available in the checksum data register.
888:                      *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
889:                 
890:                      *
891:                      * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
892:                      *
893:                      * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
894:                      ********************************************************************/
895:                     void            DmaSfmAttachChannel(DmaChannel chn, int appendMode);
896:                     #define         CrcAttachChannel    DmaSfmAttachChannel     // PIC32_3xx backward compatibility name
897:                 
898:                     /*********************************************************************
899:                      * Function:        unsigned int DmaSfmChecksum(void)
900:                      *
901:                      * PreCondition:    None
902:                      *
903:                      * Input:           None
904:                      *
905:                      * Output:          the current value of the checksum generator.
906:                      *
907:                      * Side Effects:    None
908:                      *
909:                      * Overview:        The function returns the calculated checksum value.
910:                      *
911:                      * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
912:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
913:                      *
914:                      * Example:         unsigned int myChk=DmaSfmChecksum();
915:                      ********************************************************************/
916:                     extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
917:                     {
918:                         return DCRCDATA;
919:                     }
920:                     #define     CrcResult   DmaSfmChecksum      // PIC32_3xx backward compatibility name
921:                     #define     DmaCrcGetValue  DmaSfmChecksum      // PIC32_3xx backward compatibility name
922:                 
923:                 
924:                     /*********************************************************************
925:                      * Function:        void DmaSfmSetSeed(unsigned int seed)
926:                      *
927:                      * PreCondition:    None
928:                      *
929:                      * Input:           seed    - the initial seed of the checksum generator
930:                      *
931:                      * Output:          None
932:                      *
933:                      * Side Effects:    None
934:                      *
935:                      * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
936:                      *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
937:                      *
938:                      * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
939:                      *
940:                      * Example:         DmaSfmSetSeed(0xffffffff);
941:                      ********************************************************************/
942:                     extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
943:                     {
944:                         DCRCDATA=seed;
945:                     }
946:                     #define     DmaCrcSetSeed   DmaSfmSetSeed       // PIC32_3xx backward compatibility name
947:                 
948:                 
949:                 /*********************  end of high level functions ****************************************/
950:                 
951:                     // low level definitions for the API functions
952:                 
953:                 
954:                     typedef struct
955:                     {
956:                         union
957:                         {
958:                             struct
959:                             {
960:                                 unsigned int chn:   3;      // last active DMA channel
961:                                 unsigned int rdOp:  1;      // last DMA operation, read if 1, write if 0
962:                             };
963:                             unsigned int    w;                      // word access
964:                         }lastAccess;
965:                         void*   lastAddress;        // most recent DMA address
966:                     }DmaStatus;         // DMA controller status
967:                 
968:                     typedef enum
969:                     {
970:                         DMA_GFLG_SUSPEND =  _DMACON_SUSPEND_MASK,   // suspend DMA controller operation
971:                         DMA_GFLG_ON =       _DMACON_ON_MASK,        // DMA module enabled/desabled
972:                         //
973:                         DMA_GFLG_ALL_FLAGS= DMA_GFLG_SUSPEND|DMA_GFLG_ON        // all flags
974:                     }DmaGlblFlags;  // flags for controlling global DMA controller behavior. From processor header file.
975:                 
976:                 
977:                 
978:                 
979:                     typedef enum
980:                     {
981:                         DMA_EV_ABORT_IRQ_EN =       _DCH0ECON_AIRQEN_MASK,
982:                         DMA_EV_START_IRQ_EN =       _DCH0ECON_SIRQEN_MASK,
983:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
984:                         // the start and abort IRQ signals
985:                         DMA_EV_MATCH_EN =           _DCH0ECON_PATEN_MASK,
986:                 
987:                 
988:                         // compiler use only field
989:                         _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
990:                     }DmaEvCtrlFlags;    // DMA channel event control fields accessibile as flags
991:                     // also part of DmaEvCtrlFlags:
992:                     #define DMA_EV_START_IRQ(irq)   (DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
993:                     #define DMA_EV_ABORT_IRQ(irq)   (DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
994:                 
995:                     // DMA channel event control as a structure:
996:                     #define DmaEvCtrl   __DCH0ECONbits_t
997:                 
998:                 
999:                 
1000:                
1001:                    typedef enum
1002:                    {
1003:                        DMA_CTL_AUTO_EN =       _DCH0CON_CHAEN_MASK,
1004:                        DMA_CTL_CHAIN_EN =      _DCH0CON_CHCHN_MASK,
1005:                        DMA_CTL_DET_EN =        _DCH0CON_CHAED_MASK,
1006:                        DMA_CTL_CHN_EN =        _DCH0CON_CHEN_MASK,
1007:                        DMA_CTL_CHAIN_DIR =     _DCH0CON_CHCHNS_MASK,
1008:                        // use the DMA_CTL_PRI() below for selecting the DMA
1009:                        // channel priority
1010:                    }DmaChnCtrlFlags;   // controlling the DMA channel with flags
1011:                    // also part of DmaChnCtrlFlags:
1012:                    #define DMA_CTL_PRI(pri)    ((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1013:                
1014:                    // DMA channel control as a structure:
1015:                    #define DmaChnCtrl      __DCH0CONbits_t
1016:                
1017:                    typedef struct
1018:                    {
1019:                        void*   vSrcAdd;        // source of the DMA transfer, virtual
1020:                        void*   vDstAdd;        // destination of the DMA transfer, virtual
1021:                        int srcSize;        // source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1022:                        int dstSize;        // destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1023:                        int cellSize;       // no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1024:                    }DmaTxferCtrl;      // transfer setting: the transfer source, destination addresses and size, cell size
1025:                
1026:                
1027:                    /********************** low level DMA channel functions *******************************/
1028:                
1029:                
1030:                
1031:                    // Global DMA controller functions
1032:                
1033:                    /*********************************************************************
1034:                     * Function:        void DmaEnable(int enable)
1035:                     *
1036:                     * PreCondition:    None
1037:                     *
1038:                     * Input:           enable - boolean to enable/disable the DMA controller
1039:                     *
1040:                     * Output:          None
1041:                     *
1042:                     * Side Effects:    None
1043:                     *
1044:                     * Overview:       The function enables/disables the DMA controller.
1045:                     *
1046:                     * Note:           None.
1047:                     *
1048:                     * Example:        DmaEnable(1);
1049:                     ********************************************************************/
1050:                    extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1051:                    {
1052:                        if(enable)
1053:                        {
1054:                            DMACONSET=_DMACON_ON_MASK;
1055:                        }
1056:                        else
1057:                        {
1058:                            DMACONCLR=_DMACON_ON_MASK;
1059:                            while(DMACONbits.ON);       // wait to take effect
1060:                        }
1061:                    }
1062:                
1063:                    /*********************************************************************
1064:                     * Function:        void DmaReset(void)
1065:                     *
1066:                     * PreCondition:    None
1067:                     *
1068:                     * Input:       None
1069:                     *
1070:                     * Output:          None
1071:                     *
1072:                     * Side Effects:    None
1073:                     *
1074:                     * Overview:        The function resets the DMA controller.
1075:                     *
1076:                     * Note:            None.
1077:                     *
1078:                     * Example:        DmaReset();
1079:                     ********************************************************************/
1080:                    #define            DmaReset()   DmaEnable(0)
1081:                
1082:                
1083:                    /*********************************************************************
1084:                     * Function:        int DmaSuspend(void)
1085:                     *
1086:                     * PreCondition:    None
1087:                     *
1088:                     * Input:       None
1089:                     *
1090:                     * Output:          true if the DMA was previously suspended, false otherwise
1091:                     *
1092:                     *
1093:                     * Side Effects:    None
1094:                     *
1095:                     * Overview:        The function suspends the DMA controller.
1096:                     *
1097:                     * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1098:                     *                  I.e. the function has to wait for the suspension to take place!
1099:                     *
1100:                     * Example:         int susp=DmaSuspend();
1101:                     ********************************************************************/
1102:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1103:                    {
1104:                        int suspSt;
1105:                        if(!(suspSt=DMACONbits.SUSPEND))
9D00118C  3C02BF88   LUI V0, -16504
9D001190  8C423000   LW V0, 12288(V0)
9D001194  7C420300   EXT V0, V0, 12, 1
9D001198  304200FF   ANDI V0, V0, 255
9D00119C  AFC20034   SW V0, 52(S8)
9D0011A0  8FC20034   LW V0, 52(S8)
9D0011A4  14400009   BNE V0, ZERO, 0x9D0011CC
9D0011A8  00000000   NOP
9D001260  3C02BF88   LUI V0, -16504
9D001264  8C423000   LW V0, 12288(V0)
9D001268  7C420300   EXT V0, V0, 12, 1
9D00126C  304200FF   ANDI V0, V0, 255
9D001270  AFC20040   SW V0, 64(S8)
9D001274  8FC20040   LW V0, 64(S8)
9D001278  1440000E   BNE V0, ZERO, 0x9D0012B4
9D00127C  00000000   NOP
1106:                        {
1107:                            DMACONSET=_DMACON_SUSPEND_MASK;     // suspend
9D0011AC  3C02BF88   LUI V0, -16504
9D0011B0  24031000   ADDIU V1, ZERO, 4096
9D0011B4  AC433008   SW V1, 12296(V0)
9D001280  3C02BF88   LUI V0, -16504
9D001284  24031000   ADDIU V1, ZERO, 4096
9D001288  AC433008   SW V1, 12296(V0)
1108:                            while((DMACONbits.DMABUSY));    // wait to be actually suspended
9D0011B8  3C02BF88   LUI V0, -16504
9D0011BC  8C423000   LW V0, 12288(V0)
9D0011C0  30420800   ANDI V0, V0, 2048
9D0011C4  1440FFFC   BNE V0, ZERO, 0x9D0011B8
9D0011C8  00000000   NOP
9D00128C  3C02BF88   LUI V0, -16504
9D001290  8C423000   LW V0, 12288(V0)
9D001294  30420800   ANDI V0, V0, 2048
9D001298  1440FFFC   BNE V0, ZERO, 0x9D00128C
9D00129C  00000000   NOP
9D0012A0  0B4004AD   J 0x9D0012B4
9D0012A4  00000000   NOP
1109:                        }
1110:                        return suspSt;
9D0011CC  8FC20034   LW V0, 52(S8)
1111:                    }
1112:                
1113:                
1114:                
1115:                    /*********************************************************************
1116:                     * Function:        void DmaResume(int susp)
1117:                     *
1118:                     * PreCondition:    None
1119:                     *
1120:                     * Input:       the desired DMA suspended state.
1121:                     *
1122:                     * Output:          None
1123:                     *
1124:                     * Side Effects:    None
1125:                     *
1126:                     * Overview:        The function restores the DMA controller activity to the old suspended mode.
1127:                     *
1128:                     * Note:            None.
1129:                     *
1130:                     * Example:         int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1131:                     ********************************************************************/
1132:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1133:                    {
1134:                        if(susp)
9D001254  8FC2003C   LW V0, 60(S8)
9D001258  10400013   BEQ V0, ZERO, 0x9D0012A8
9D00125C  00000000   NOP
1135:                        {
1136:                            DmaSuspend();
1137:                        }
1138:                        else
1139:                        {
1140:                            DMACONCLR=_DMACON_SUSPEND_MASK;     // resume DMA activity
9D0012A8  3C02BF88   LUI V0, -16504
9D0012AC  24031000   ADDIU V1, ZERO, 4096
9D0012B0  AC433004   SW V1, 12292(V0)
1141:                        }
1142:                    }
1143:                
1144:                    /*********************************************************************
1145:                     * Function:        void DmaGetStatus(DmaStatus* pStat)
1146:                     *
1147:                     * PreCondition:    pStat   - valid pointer
1148:                     *
1149:                     * Input:           pStat   - pointer to a DmaStatus structure to store the current DMA controller
1150:                     *                          status, carrying the following info:
1151:                     *                              - chn:  the last active DMA channel
1152:                     *                              - rdOp: the last DMA operation, read/write
1153:                     *                              - lastAddress: the most recent DMA address
1154:                     *
1155:                     * Output:          None
1156:                     *
1157:                     * Side Effects:    None
1158:                     *
1159:                     * Overview:        The function updates the info for the current DMA controller status.
1160:                     *                  It updates the last DMA: operation, channel used and address.
1161:                     *
1162:                     * Note:            None.
1163:                     *
1164:                     * Example:         DmaStatus stat; DmaGetStatus(&stat);
1165:                     ********************************************************************/
1166:                     void           DmaGetStatus(DmaStatus* pStat);
1167:                
1168:                    /*********************************************************************
1169:                     * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1170:                     *
1171:                     * PreCondition:    None
1172:                     *
1173:                     * Input:           gFlags - flags to be set, having the following fields:
1174:                     *          - DMA_GFLG_SUSPEND: DMA controller operation suspend
1175:                     *          - DMA_GFLG_ON: DMA controller enabled/desabled
1176:                     *          - DMA_GFLG_ALL_FLAGS: all flags
1177:                     *
1178:                     * Output:          None
1179:                     *
1180:                     * Side Effects:    None
1181:                     *
1182:                     * Overview:        The function affects the global behavior of the DMA controller.
1183:                     *                  It sets the specified flags. Any flag that is set in the gFlags will be
1184:                     *                  enabled, the other flags won't be touched.
1185:                     *
1186:                     * Note:            None.
1187:                     *
1188:                     * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1189:                     ********************************************************************/
1190:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1191:                    {
1192:                        DMACONSET=gFlags;
1193:                    }
1194:                
1195:                    /*********************************************************************
1196:                     * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1197:                     *
1198:                     * PreCondition:    None
1199:                     *
1200:                     * Input:           gFlags - flags to be cleared, having the following fields:
1201:                     *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1202:                     *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1203:                     *                               - DMA_GFLG_ALL_FLAGS: all flags
1204:                     *
1205:                     * Output:          None
1206:                     *
1207:                     * Side Effects:    None
1208:                     *
1209:                     * Overview:        The function affects the global behavior of the DMA controller.
1210:                     *                  It clears the specified flags. Any flag that is set in the gFlags will be
1211:                     *                  cleared, the other flags won't be touched.
1212:                     *
1213:                     * Note:            None.
1214:                     *
1215:                     * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1216:                     ********************************************************************/
1217:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1218:                    {
1219:                        DMACONCLR=gFlags;
1220:                    }
1221:                
1222:                
1223:                    /*********************************************************************
1224:                     * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1225:                     *
1226:                     * PreCondition:    None
1227:                     *
1228:                     * Input:           gFlags - flags to be set, having the following fields:
1229:                     *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1230:                     *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1231:                     *                                 - DMA_GFLG_ALL_FLAGS: all flags
1232:                     *
1233:                     * Output:          None
1234:                     *
1235:                     * Side Effects:    None
1236:                     *
1237:                     * Overview:        The function affects the global behavior of the DMA controller.
1238:                     *                  It forces the flags to have the specified gFlags value.
1239:                     *
1240:                     * Note:            None.
1241:                     *
1242:                     * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1243:                     ********************************************************************/
1244:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1245:                    {
1246:                        DMACON=gFlags;
1247:                    }
1248:                
1249:                    /*********************************************************************
1250:                     * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1251:                     *
1252:                     * PreCondition:    None
1253:                     *
1254:                     * Input:           None
1255:                     *
1256:                     * Output:          The current DMA controller flags settings.
1257:                     *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1258:                     *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1259:                     *
1260:                     * Side Effects:    None
1261:                     *
1262:                     * Overview:        The function returns the global flags of the DMA controller.
1263:                     *
1264:                     * Note:            None.
1265:                     *
1266:                     * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1267:                     ********************************************************************/
1268:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1269:                    {
1270:                        return (DmaGlblFlags)DMACON;
1271:                    }
1272:                
1273:                
1274:                    /*********************************************************************
1275:                     * Function:        int DmaGetMaxTxferSize(void)
1276:                     *
1277:                     * PreCondition:    None
1278:                     *
1279:                     * Input:           None
1280:                     *
1281:                     * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1282:                     *
1283:                     * Side Effects:    None
1284:                     *
1285:                     * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1286:                     *
1287:                     * Note:            Revision dependant.
1288:                     *
1289:                     * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1290:                     ********************************************************************/
1291:                    extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1292:                    {
1293:                        return 65536;
1294:                    }
1295:                
1296:                    // Direct Channel control functions
1297:                
1298:                    typedef enum
1299:                    {
1300:                        DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1301:                        DMA_CONFIG_AUTO = _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1302:                        DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK), // DMA channel is chained to lower channel
1303:                        DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),       // DMA channel is chained to higher channel
1304:                        DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,            // events detection enabled while channel off
1305:                        DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,             // DMA channel is enabled after open
1306:                        DMA_CONFIG_MATCH    = 0x80000000,                   // DMA channel stops on match
1307:                    }DmaConfigFlags;    // flags for the channel configuration
1308:                
1309:                
1310:                
1311:                    /*********************************************************************
1312:                     * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1313:                     *
1314:                     * PreCondition:    chPri  - valid channel priority, 0-3
1315:                     *
1316:                     * Input:           chn    - channel to be configured in the DMA controller
1317:                     *                  chPri  - the priority given to the channel, 0-3
1318:                     *                  cFlags - orred flags specifying the configuration:
1319:                     *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1320:                     *                           DMA_CONFIG_AUTO:   DMA channel is auto enabled
1321:                     *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1322:                     *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1323:                     *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1324:                     *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1325:                     *                           DMA_CONFIG_MATCH:  DMA channel stops on match
1326:                     *
1327:                     *
1328:                     *
1329:                     * Output:          None
1330:                     *
1331:                     * Side Effects:    None
1332:                     *
1333:                     * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1334:                     *
1335:                     * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1336:                     *                  The channel is just configured.
1337:                     *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1338:                     *                  if DMA_CONFIG_ENABLE flag was not specified.
1339:                     *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1340:                     *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1341:                     *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1342:                     *                  User has to call event channel functions to clear/enable the event flags if needed.
1343:                     *
1344:                     * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1345:                     ********************************************************************/
1346:                    void            DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1347:                
1348:                
1349:                    /*********************************************************************
1350:                     * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1351:                     *
1352:                     * PreCondition:    chn - valid DMA channel
1353:                     *
1354:                     * Input:           chn     - DMA channel number
1355:                     *
1356:                     * Output:          Current channel source pointer.
1357:                     *
1358:                     * Side Effects:    None
1359:                     *
1360:                     * Overview:        The function retrieves the current source pointer for the selected DMA channel.
1361:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1362:                     *
1363:                     * Note:            None
1364:                     *
1365:                     * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1366:                     ********************************************************************/
1367:                     int            DmaChnGetSrcPnt(DmaChannel chn);
1368:                
1369:                    /*********************************************************************
1370:                     * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1371:                     *
1372:                     * PreCondition:    chn - valid DMA channel
1373:                     *
1374:                     * Input:           chn     - DMA channel number
1375:                     *
1376:                     * Output:          Current channel destination pointer.
1377:                     *
1378:                     * Side Effects:    None
1379:                     *
1380:                     * Overview:        The function retrieves the current destination pointer for the selected DMA channel.
1381:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1382:                     *
1383:                     * Note:            None
1384:                     *
1385:                     * Example:         int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1386:                     ********************************************************************/
1387:                     int            DmaChnGetDstPnt(DmaChannel chn);
1388:                
1389:                    /*********************************************************************
1390:                     * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1391:                     *
1392:                     * PreCondition:    chn - valid DMA channel
1393:                     *
1394:                     * Input:           chn     - DMA channel number
1395:                     *
1396:                     * Output:          Current channel transfer pointer.
1397:                     *
1398:                     * Side Effects:    None
1399:                     *
1400:                     * Overview:        The function retrieves the current transfer progress pointer for the selected DMA channel.
1401:                     *                  It ranges 0 to DmaGetMaxTxferSize()-1.
1402:                     *
1403:                     * Note:            None
1404:                     *
1405:                     * Example:         int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1406:                     ********************************************************************/
1407:                     int            DmaChnGetCellPnt(DmaChannel chn);
1408:                
1409:                
1410:                
1411:                    /*********************************************************************
1412:                     * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1413:                     *
1414:                     * PreCondition:    chn - valid DMA channel
1415:                     *
1416:                     * Input:           chn         - DMA channel number
1417:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1418:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1419:                     *                                      - SIRQEN: enable/disable the start IRQ action
1420:                     *                                      - PATEN: enable/disable the pattern match and abort
1421:                     *                                  or any of the DmaEvCtrlFlags:
1422:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1423:                     *
1424:                     *
1425:                     * Output:          None
1426:                     *
1427:                     * Side Effects:    None
1428:                     *
1429:                     * Overview:        The function sets the events that start and abort the transfer
1430:                     *                  for the selected DMA channel.
1431:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1432:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1433:                     *
1434:                     * Note:            None.
1435:                     *
1436:                     * Example:         either:
1437:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1438:                     *                  or:
1439:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1440:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1441:                     *
1442:                     ********************************************************************/
1443:                     void           DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1444:                
1445:                
1446:                    /*********************************************************************
1447:                     * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1448:                     *
1449:                     * PreCondition:    chn - valid DMA channel
1450:                     *
1451:                     * Input:           chn         - DMA channel number
1452:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1453:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1454:                     *                                      - SIRQEN: enable/disable the start IRQ action
1455:                     *                                      - PATEN: enable/disable the pattern match and abort
1456:                     *                                  or any of the DmaEvCtrlFlags:
1457:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1458:                     *
1459:                     *
1460:                     * Output:          None
1461:                     *
1462:                     * Side Effects:    None
1463:                     *
1464:                     * Overview:        The function clears the events that start and abort the transfer
1465:                     *                  for the selected DMA channel.
1466:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1467:                     *                  disabled for the selected channel, the other channel event flags won't be touched.
1468:                     *
1469:                     * Note:            None.
1470:                     *
1471:                     * Example:         either:
1472:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1473:                     *                  or:
1474:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1475:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1476:                     *
1477:                     ********************************************************************/
1478:                     void           DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1479:                
1480:                
1481:                
1482:                    /*********************************************************************
1483:                     * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1484:                     *
1485:                     * PreCondition:    chn - valid DMA channel
1486:                     *
1487:                     * Input:           chn         - DMA channel number
1488:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1489:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1490:                     *                                      - SIRQEN: enable/disable the start IRQ action
1491:                     *                                      - PATEN: enable/disable the pattern match and abort
1492:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1493:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1494:                     *                                  or any of the DmaEvCtrlFlags:
1495:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1496:                     *
1497:                     *
1498:                     * Output:          None
1499:                     *
1500:                     * Side Effects:    None
1501:                     *
1502:                     * Overview:        The function writes the events that start and abort the transfer
1503:                     *                  for the selected DMA channel.
1504:                     *
1505:                     * Note:            None.
1506:                     *
1507:                     * Example:         either:
1508:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1509:                     *                  or:
1510:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1511:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1512:                     *
1513:                     ********************************************************************/
1514:                     void           DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1515:                
1516:                
1517:                
1518:                    /*********************************************************************
1519:                     * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1520:                     *
1521:                     * PreCondition:    chn - valid DMA channel
1522:                     *
1523:                     * Input:           chn         - DMA channel number
1524:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1525:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1526:                     *                                      - SIRQEN: enable/disable the start IRQ action
1527:                     *                                      - PATEN: enable/disable the pattern match and abort
1528:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1529:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1530:                     *                                  or any of the DmaEvCtrlFlags:
1531:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1532:                     *
1533:                     *
1534:                     * Output:          None
1535:                     *
1536:                     * Side Effects:    None
1537:                     *
1538:                     * Overview:        The function sets the events that start and abort the transfer
1539:                     *                  for the selected DMA channel.
1540:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1541:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1542:                     *
1543:                     * Note:           A shorter name for DmaChnWriteEventControlFlags();
1544:                     *
1545:                     * Example:         either:
1546:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1547:                     *                  or:
1548:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1549:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1550:                     *
1551:                     ********************************************************************/
1552:                    #define         DmaChnSetEventControl(chn, dmaEvCtrl)   DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1553:                
1554:                
1555:                    /*********************************************************************
1556:                     * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1557:                     *
1558:                     * PreCondition:    chn - valid DMA channel
1559:                     *
1560:                     * Input:           chn     - DMA channel number
1561:                     *
1562:                     * Output:          -   either a DmaEvCtrl structure field, carrying the following info:
1563:                     *                          - AIRQEN: enable/disable the abort IRQ action
1564:                     *                          - SIRQEN: enable/disable the start IRQ action
1565:                     *                          - PATEN: enable/disable the pattern match and abort
1566:                     *                          - CHSIRQ: IRQ number to start the DMA channel transfer
1567:                     *                          - CHAIRQ: IRQ number to abort the DMA channel transfer
1568:                     *                      or any of the DmaEvCtrlFlags:
1569:                     *                          DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1570:                     *
1571:                     *
1572:                     * Side Effects:    None
1573:                     *
1574:                     * Overview:        The function retrieves the events that start and abort the transfer
1575:                     *                  for the selected DMA channel.
1576:                     *
1577:                     * Note:            None.
1578:                     *
1579:                     * Example:         either:
1580:                     *                      DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1581:                     *                  or:
1582:                     *                      DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1583:                     *
1584:                     ********************************************************************/
1585:                     DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn);
1586:                
1587:                
1588:                    /*********************************************************************
1589:                     * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1590:                     *
1591:                     * PreCondition:    chn - valid DMA channel
1592:                     *
1593:                     * Input:           chn         - DMA channel number
1594:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1595:                     *                                      - autoEn: enable/disable the automatic mode
1596:                     *                                      - chainEn: enable/disable channel chaining
1597:                     *                                      - detectEn: enable/disable events detection when channel disabled
1598:                     *                                      - chEn: enable/disable channel functionality
1599:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1600:                     *                                  or any of the DmaChnCtrlFlags flags:
1601:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1602:                     *
1603:                     * Output:          None
1604:                     *
1605:                     * Side Effects:    None
1606:                     *
1607:                     * Overview:        The function sets the selected DMA channel control flags:
1608:                     *                  the chaining or auto mode, and events detection.
1609:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1610:                     *                  set for the selected channel, the other channel control flags won't be touched.
1611:                     *
1612:                     * Note:            None.
1613:                     *
1614:                     * Example:         either:
1615:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1616:                     *                  or:
1617:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1618:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1619:                     *
1620:                     ********************************************************************/
1621:                     void           DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1622:                
1623:                    /*********************************************************************
1624:                     * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1625:                     *
1626:                     * PreCondition:    chn - valid DMA channel
1627:                     *
1628:                     * Input:           chn         - DMA channel number
1629:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1630:                     *                                      - autoEn: enable/disable the automatic mode
1631:                     *                                      - chainEn: enable/disable channel chaining
1632:                     *                                      - detectEn: enable/disable events detection when channel disabled
1633:                     *                                      - chEn: enable/disable channel functionality
1634:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1635:                     *                                  or any of the DmaChnCtrlFlags flags:
1636:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1637:                     *
1638:                     * Output:          None
1639:                     *
1640:                     * Side Effects:    None
1641:                     *
1642:                     * Overview:        The function clears the selected DMA channel control flags:
1643:                     *                  the chaining or auto mode and events detection.
1644:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1645:                     *                  cleared for the selected channel, the other channel control flags won't be touched.
1646:                     *
1647:                     * Note:            None.
1648:                     *
1649:                     * Example:         either:
1650:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1651:                     *                  or:
1652:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1653:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1654:                     *
1655:                     ********************************************************************/
1656:                     void           DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1657:                
1658:                    /*********************************************************************
1659:                     * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1660:                     *
1661:                     * PreCondition:    chn - valid DMA channel
1662:                     *
1663:                     * Input:           chn         - DMA channel number
1664:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1665:                     *                                      - chPri: channel priority 0-3
1666:                     *                                      - autoEn: enable/disable the automatic mode
1667:                     *                                      - chainEn: enable/disable channel chaining
1668:                     *                                      - detectEn: enable/disable events detection when channel disabled
1669:                     *                                      - chEn: enable/disable channel functionality
1670:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1671:                     *                                  or any of the DmaChnCtrlFlags flags:
1672:                     *                                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1673:                     *
1674:                     * Output:          None
1675:                     *
1676:                     * Side Effects:    None
1677:                     *
1678:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1679:                     *                  the channel priority, chaining mode or auto and events detection.
1680:                     *
1681:                     * Note:            None.
1682:                     *
1683:                     * Example:         either:
1684:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1685:                     *                  or:
1686:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1687:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1688:                     *
1689:                     ********************************************************************/
1690:                     void           DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1691:                
1692:                    /*********************************************************************
1693:                     * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1694:                     *
1695:                     * PreCondition:    chn - valid DMA channel
1696:                     *
1697:                     * Input:       chn     - DMA channel number
1698:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1699:                     *                      - chPri: channel priority 0-3
1700:                     *                      - autoEn: enable/disable the automatic mode
1701:                     *                      - chainEn: enable/disable channel chaining
1702:                     *                      - detectEn: enable/disable events detection when channel disabled
1703:                     *                      - chEn: enable/disable channel functionality
1704:                     *                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1705:                     *                  or any of the DmaChnCtrlFlags flags:
1706:                     *                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1707:                     *
1708:                     * Output:          None
1709:                     *
1710:                     * Side Effects:    None
1711:                     *
1712:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1713:                     *                  the channel priority, chaining mode or auto and events detection.
1714:                     *
1715:                     * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1716:                     *
1717:                     * Example:         either:
1718:                     *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1719:                     *                  or:
1720:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1721:                     *          DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1722:                     *
1723:                     ********************************************************************/
1724:                    #define     DmaChnSetControl(chn, dmaChnCtrl)   DmaChnWriteControlFlags(chn, dmaChnCtrl)
1725:                
1726:                    /*********************************************************************
1727:                     * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1728:                     *
1729:                     * PreCondition:    chn - valid DMA channel
1730:                     *
1731:                     * Input:           chn         - DMA channel number
1732:                     *
1733:                     * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1734:                     *                          - chPri: channel priority 0-3
1735:                     *                          - autoEn: enable/disable the automatic mode
1736:                     *                          - chainEn: enable/disable channel chaining
1737:                     *                          - detectEn: enable/disable events detection when channel disabled
1738:                     *                          - chEn: enable/disable channel functionality
1739:                     *                          - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1740:                     *                      or any of the DmaChnCtrlFlags flags:
1741:                     *                          DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1742:                     *
1743:                     * Side Effects:    None
1744:                     *
1745:                     * Overview:        The function retrieves the current control settings for the selected DMA channel,
1746:                     *                  including the channel enable/disable status, the channel priority,
1747:                     *                  chaining mode, auto mode and events detection.
1748:                     *
1749:                     * Note:            None.
1750:                     *
1751:                     * Example:         either:
1752:                     *                      DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1753:                     *                  or:
1754:                     *                      DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1755:                     *
1756:                     ********************************************************************/
1757:                     DmaChnCtrlFlags    DmaChnGetControlFlags(DmaChannel chn);
1758:                
1759:                
1760:                    /*********************************************************************
1761:                     * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1762:                     *
1763:                     * PreCondition:    chn - valid DMA channel
1764:                     *
1765:                     * Input:           chn     - DMA channel number
1766:                     *
1767:                     * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1768:                     *
1769:                     * Side Effects:    None
1770:                     *
1771:                     * Overview:        The function returns the current event detection for the selected DMA channel.
1772:                     *
1773:                     * Note:            None.
1774:                     *
1775:                     * Example:         int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1776:                     *
1777:                     ********************************************************************/
1778:                     int            DmaChnGetEvDetect(DmaChannel chn);
1779:                
1780:                    /*********************************************************************
1781:                     * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1782:                     *
1783:                     * PreCondition:    chn     - valid DMA channel
1784:                     *                  pTxCtrl - valid pointer
1785:                     *
1786:                     * Input:           chn         - DMA channel number
1787:                     *                  pTxCtrl     - pointer to a DmaTxferCtrl that will carry the following info:
1788:                     *                              - vSrcAdd: source of the DMA transfer
1789:                     *                              - vDstAdd: destination of the DMA transfer
1790:                     *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1791:                     *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1792:                     *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1793:                     *                  mapToK0     - if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1794:                     *
1795:                     * Output:          None
1796:                     *
1797:                     * Side Effects:    None
1798:                     *
1799:                     * Overview:        The function retrieves the transfer characteristics for a DMA channel transfer:
1800:                     *                  the source and the destination addresses.
1801:                     *                  It also retrieves the source and destination lengths
1802:                     *                  and the number of bytes transferred per event.
1803:                     *
1804:                     * Note:            None
1805:                     *
1806:                     * Example:         DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1807:                     ********************************************************************/
1808:                     void           DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1809:                
1810:                    // Low level checksum functions
1811:                
1812:                    /*********************************************************************
1813:                     * Function:        void DmaSfmEnable(int enable)
1814:                     *
1815:                     * PreCondition:    None
1816:                     *
1817:                     * Input:           enable _ boolean to enable/disable the SFM functionality
1818:                     *
1819:                     * Output:          None
1820:                     *
1821:                     * Side Effects:    None
1822:                     *
1823:                     * Overview:        The function enables/diables the checksum module functionality.
1824:                     *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1825:                     *
1826:                     * Note:            The SFM module should be properly configured before enabled.
1827:                     *
1828:                     * Example:         DmaSfmEnable(1);
1829:                     ********************************************************************/
1830:                    extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1831:                    {
1832:                        if(enable)
1833:                        {
1834:                            DCRCCONSET=_DCRCCON_CRCEN_MASK;
1835:                        }
1836:                        else
1837:                        {
1838:                            DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1839:                        }
1840:                    }
1841:                    #define DmaCrcEnable    DmaSfmEnable        // PIC32_3xx backward compatibility
1842:                
1843:                
1844:                    /*********************************************************************
1845:                     * Function:        int DmaSfmGetEnable(void)
1846:                     *
1847:                     * PreCondition:    None
1848:                     *
1849:                     * Input:           None
1850:                     *
1851:                     * Output:          TRUE, if the SFM module is enabled
1852:                     *          FALSE otherwise
1853:                     *
1854:                     * Side Effects:    None
1855:                     *
1856:                     * Overview:        The function returns the SFM module enabling status.
1857:                     *
1858:                     * Note:            None
1859:                     *
1860:                     * Example:     int isSfmEnabled=DmaSfmGetEnable();
1861:                     ********************************************************************/
1862:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1863:                    {
1864:                        return DCRCCONbits.CRCEN!=0;
1865:                    }
1866:                    #define     DmaCrcGetEnable     DmaSfmGetEnable     // PIC32_3xx backward compatibility
1867:                
1868:                
1869:                    /*********************************************************************
1870:                     * Function:        void DmaSfmAppendEnable(int enable)
1871:                     *
1872:                     * PreCondition:    None
1873:                     *
1874:                     * Input:           enable _ boolean to enable/disable the SFM append mode
1875:                     *
1876:                     * Output:          None
1877:                     *
1878:                     * Side Effects:    None
1879:                     *
1880:                     * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1881:                     *                  the source data but does not write it to the destination address. The data it's just passed
1882:                     *                  to the checksum generator for CRC/IP checksum calculation.
1883:                     *                  When the block transfer is completed, the checksum result is written to the
1884:                     *                  DMA channel destination address.
1885:                     *
1886:                     * Note:            The SFM module should be properly configured before enabled.
1887:                     *
1888:                     * Example:         DmaSfmAppendModeEnable(TRUE);
1889:                     ********************************************************************/
1890:                    extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1891:                    {
1892:                        if(enable)
1893:                        {
1894:                            DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1895:                        }
1896:                        else
1897:                        {
1898:                            DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1899:                        }
1900:                    }
1901:                    #define     DmaCrcAppendModeEnable  DmaSfmAppendEnable  // PIC32_3xx backward compatibility
1902:                
1903:                
1904:                    /*********************************************************************
1905:                     * Function:        int DmaSfmGetAppendMode(void)
1906:                     *
1907:                     * PreCondition:    None
1908:                     *
1909:                     * Input:           None
1910:                     *
1911:                     * Output:          TRUE, if the SFM append mode is enabled
1912:                     *                  FALSE otherwise
1913:                     *
1914:                     * Side Effects:    None
1915:                     *
1916:                     * Overview:        The function returns the SFM module enabling status.
1917:                     *
1918:                     * Note:            None
1919:                     *
1920:                     * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1921:                     ********************************************************************/
1922:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1923:                    {
1924:                        return DCRCCONbits.CRCAPP!=0;
1925:                    }
1926:                    #define DmaCrcGetAppendMode DmaSfmGetAppendMode     // PIC32_3xx backward compatibility
1927:                
1928:                
1929:                    /*********************************************************************
1930:                     * Function:        void DmaSfmSetAttach(DmaChannel chn)
1931:                     *
1932:                     * PreCondition:    chn     - valid DMA channel
1933:                     *
1934:                     * Input:           chn - the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1935:                     *
1936:                     * Output:          None
1937:                     *
1938:                     * Side Effects:    None
1939:                     *
1940:                     * Overview:        The function directly attaches a DMA channel to the SFM module.
1941:                     *
1942:                     * Note:            None
1943:                     *
1944:                     * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1945:                     ********************************************************************/
1946:                    extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1947:                    {
1948:                        DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1949:                        DCRCCONSET=chn;
1950:                    }
1951:                    #define     DmaCrcSetAttach     DmaSfmSetAttach     // PIC32_3xx backward compatibility
1952:                
1953:                
1954:                    /*********************************************************************
1955:                     * Function:        DmaChannel DmaSfmGetAttach(void)
1956:                     *
1957:                     * PreCondition:    None
1958:                     *
1959:                     * Input:           None
1960:                     *
1961:                     * Output:          the DMA channel that is currently attached to the CRC module
1962:                     *
1963:                     * Side Effects:    None
1964:                     *
1965:                     * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1966:                     *
1967:                     * Note:            None
1968:                     *
1969:                     * Example:         DmaChannel chn=DmaSfmGetAttach();
1970:                     ********************************************************************/
1971:                    extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1972:                    {
1973:                        return (DmaChannel)DCRCCONbits.CRCCH;
1974:                    }
1975:                    #define     DmaCrcGetAttach     DmaSfmGetAttach     // PIC32_3xx backward compatibility
1976:                
1977:                    /*********************************************************************
1978:                     * Function:        void DmaCrcSetPLen(int pLen)
1979:                     *
1980:                     * PreCondition:    pLen - valid polynomial length within 1-32
1981:                     *
1982:                     * Input:           pLen    - the length of the CRC generator polynomial
1983:                     *
1984:                     * Output:          None
1985:                     *
1986:                     * Side Effects:    None
1987:                     *
1988:                     * Overview:        The length of the CRC generator polynomial is set as being pLen;
1989:                     *
1990:                     * Note:            None
1991:                     *
1992:                     * Example:         DmaCrcSetPLen(32);
1993:                     ********************************************************************/
1994:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
1995:                    {
1996:                        DCRCCONCLR=_DCRCCON_PLEN_MASK;
1997:                        DCRCCONSET=(pLen)-1;
1998:                    }
1999:                
2000:                    /*********************************************************************
2001:                     * Function:        int DmaCrcGetPLen(void)
2002:                     *
2003:                     * PreCondition:    None
2004:                     *
2005:                     * Input:           None
2006:                     *
2007:                     * Output:          the length of the CRC generator polynomial
2008:                     *
2009:                     * Side Effects:    None
2010:                     *
2011:                     * Overview:        The function returns the current length of the CRC generator polynomial.
2012:                     *                  It's always a number between 1 and 32.
2013:                     *
2014:                     * Note:            None
2015:                     *
2016:                     * Example:         int polyLen=DmaCrcGetPLen();
2017:                     ********************************************************************/
2018:                    extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2019:                    {
2020:                        return  DCRCCONbits.PLEN+1;
2021:                    }
2022:                
2023:                    /*********************************************************************
2024:                     * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2025:                     *
2026:                     * PreCondition:    None
2027:                     *
2028:                     * Input:           feedback - the layout of the CRC generator
2029:                     *
2030:                     * Output:          None
2031:                     *
2032:                     * Side Effects:    None
2033:                     *
2034:                     * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2035:                     *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2036:                     *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2037:                     *
2038:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2039:                     *
2040:                     * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2041:                     ********************************************************************/
2042:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2043:                    {
2044:                        DCRCXOR=feedback;
2045:                    }
2046:                
2047:                
2048:                    /*********************************************************************
2049:                     * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2050:                     *
2051:                     * PreCondition:    None
2052:                     *
2053:                     * Input:           None
2054:                     *
2055:                     * Output:          the current layout of the CRC generator
2056:                     *
2057:                     * Side Effects:    None
2058:                     *
2059:                     * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2060:                     *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2061:                     *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2062:                     *
2063:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2064:                     *
2065:                     * Example:         int feedback=DmaCrcGetShiftFeedback();
2066:                     ********************************************************************/
2067:                    extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2068:                    {
2069:                        return DCRCXOR;
2070:                    }
2071:                
2072:                
2073:                
2074:                    // Channel test/debug and special functions
2075:                
2076:                    /*********************************************************************
2077:                     * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2078:                     *
2079:                     * PreCondition:    chn - valid DMA channel
2080:                     *
2081:                     * Input:           chn     - DMA channel number
2082:                     *                  eFlags  - event flags with the following significance:
2083:                     *                              - DMA_EV_ERR: address error event
2084:                     *                              - DMA_EV_ABORT: transfer abort event
2085:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2086:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2087:                     *                              - DMA_EV_DST_HALF: destination half event
2088:                     *                              - DMA_EV_DST_FULL: destination full event
2089:                     *                              - DMA_EV_SRC_HALF: source half event
2090:                     *                              - DMA_EV_SRC_FULL: source full event
2091:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2092:                     *
2093:                     * Output:          None
2094:                     *
2095:                     * Side Effects:    None
2096:                     *
2097:                     * Overview:        The function sets the event flags for the selected DMA channel.
2098:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2099:                     *                  set for the selected channel, the other channel event flags won't be touched.
2100:                     *
2101:                     * Note:            This is intended as a channel test function.
2102:                     *
2103:                     * Example:         DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2104:                     ********************************************************************/
2105:                     void           DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2106:                
2107:                    /*********************************************************************
2108:                     * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2109:                     *
2110:                     * PreCondition:    chn - valid DMA channel
2111:                     *
2112:                     * Input:           chn     - DMA channel number
2113:                     *                  eFlags  - event flags with the following significance:
2114:                     *                              - DMA_EV_ERR: address error event
2115:                     *                              - DMA_EV_ABORT: transfer abort event
2116:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2117:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2118:                     *                              - DMA_EV_DST_HALF: destination half event
2119:                     *                              - DMA_EV_DST_FULL: destination full event
2120:                     *                              - DMA_EV_SRC_HALF: source half event
2121:                     *                              - DMA_EV_SRC_FULL: source full event
2122:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2123:                     *
2124:                     * Output:          None
2125:                     *
2126:                     * Side Effects:    None
2127:                     *
2128:                     * Overview:        The function writes the event flags for the selected DMA channel.
2129:                     *                  The channel event flags are forced to the eFlags value.
2130:                     *
2131:                     * Note:            This is intended as a channel test function.
2132:                     *
2133:                     * Example:         DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2134:                     ********************************************************************/
2135:                     void           DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2136:                
2137:                
2138:                    /********************************************************************
2139:                     * Include legacy DMA functions
2140:                     * New projects should not use them!
2141:                     * Note that interrupt functions are no longer provided.
2142:                     * The functions in the int.h should be used instead.
2143:                     ********************************************************************/
2144:                    #ifndef _PLIB_DISABLE_LEGACY
2145:                        #include <peripheral/legacy/dma_legacy.h>
2146:                    #endif
2147:                
2148:                
2149:                #else
2150:                    #undef _DMA_CHANNELS        // no DMA channels
2151:                #endif  // _DMAC0
2152:                
2153:                #endif /*_DMA_H_*/
2154:                
2155:                
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/vpc-32.c  -----------------------------------------------
1:                   /* 
2:                    * File:   vpc-32.c
3:                    * Author: Jacques
4:                    *
5:                    * Created on 26 août 2013, 07:38
6:                    */
7:                   
8:                   #include <stdio.h>
9:                   #include <stdlib.h>
10:                  #include <plib.h>
11:                  #include "hardware/HardwareProfile.h"
12:                  #include "hardware/ntsc.h"
13:                  #include "hardware/font.h"
14:                  #include "hardware/serial_comm.h"
15:                  
16:                  // PIC32MX150F128B Configuration Bit Settings
17:                  #include <xc.h>
18:                  
19:                  // DEVCFG3
20:                  // USERID = No Setting
21:                  #pragma config PMDL1WAY = OFF           // permet plusieurs configurations des périphériques.
22:                  #pragma config IOL1WAY = OFF            // permet plusieurs configuration des broches.
23:                  
24:                  // DEVCFG2
25:                  #pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
26:                  #if SYSCLK==40000000L
27:                  #pragma config FPLLMUL = MUL_16         // SYSCLK=40Mhz
28:                  #else
29:                  #pragma config FPLLMUL = MUL_15          // PLL Multiplier (15x Multiplier) SYSCLK=37,5Mhz
30:                  #endif
31:                  #pragma config FPLLODIV = DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)
32:                  
33:                  // DEVCFG1
34:                  #pragma config FNOSC = PRIPLL           // Oscillator Selection Bits (Primary Osc w/PLL (XT+,HS+,EC+PLL))
35:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
36:                  #pragma config IESO = OFF               // Internal/External Switch Over (Disabled)
37:                  #pragma config POSCMOD = HS             // Primary Oscillator Configuration (XT osc mode)
38:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
39:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
40:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
41:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
42:                  
43:                  // DEVCFG0
44:                  #pragma config JTAGEN = OFF             // JTAG Enable (JTAG Disabled)
45:                  #pragma config ICESEL = ICS_PGx1        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
46:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
47:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
48:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
49:                  
50:                  
51:                  void put_char(int x, int y, char c){
9D000BB4  27BDFFE8   ADDIU SP, SP, -24
9D000BB8  AFBE0014   SW S8, 20(SP)
9D000BBC  AFB30010   SW S3, 16(SP)
9D000BC0  AFB2000C   SW S2, 12(SP)
9D000BC4  AFB10008   SW S1, 8(SP)
9D000BC8  AFB00004   SW S0, 4(SP)
9D000BCC  03A0F021   ADDU S8, SP, ZERO
9D000BD0  AFC40018   SW A0, 24(S8)
9D000BD4  AFC5001C   SW A1, 28(S8)
9D000BD8  00C01021   ADDU V0, A2, ZERO
9D000BDC  A3C20020   SB V0, 32(S8)
52:                      register int i,l,r,b;
53:                      if (c>='a'){
9D000BE0  83C20020   LB V0, 32(S8)
9D000BE4  28420061   SLTI V0, V0, 97
9D000BE8  14400005   BNE V0, ZERO, 0x9D000C00
9D000BEC  00000000   NOP
54:                          c -= 32;
9D000BF0  93C20020   LBU V0, 32(S8)
9D000BF4  2442FFE0   ADDIU V0, V0, -32
9D000BF8  304200FF   ANDI V0, V0, 255
9D000BFC  A3C20020   SB V0, 32(S8)
55:                      }
56:                      c -=32;
9D000C00  93C20020   LBU V0, 32(S8)
9D000C04  2442FFE0   ADDIU V0, V0, -32
9D000C08  304200FF   ANDI V0, V0, 255
9D000C0C  A3C20020   SB V0, 32(S8)
57:                      b=x>>5;
9D000C10  8FC20018   LW V0, 24(S8)
9D000C14  00028943   SRA S1, V0, 5
58:                      r=0;
9D000C18  00009021   ADDU S2, ZERO, ZERO
59:                      l=27-(x&0x1f);
9D000C1C  8FC20018   LW V0, 24(S8)
9D000C20  3042001F   ANDI V0, V0, 31
9D000C24  2403001B   ADDIU V1, ZERO, 27
9D000C28  00629823   SUBU S3, V1, V0
60:                      if (l<0){
9D000C2C  06610002   BGEZ S3, 0x9D000C38
9D000C30  00000000   NOP
61:                          r=-l;
9D000C34  00139023   SUBU S2, ZERO, S3
62:                      }
63:                      for (i=0;i<7;i++){
9D000C38  00008021   ADDU S0, ZERO, ZERO
9D000C3C  0B400374   J 0x9D000DD0
9D000C40  00000000   NOP
9D000DCC  26100001   ADDIU S0, S0, 1
9D000DD0  2A020007   SLTI V0, S0, 7
9D000DD4  1440FF9B   BNE V0, ZERO, 0x9D000C44
9D000DD8  00000000   NOP
64:                          if (r){
9D000C44  12400043   BEQ S2, ZERO, 0x9D000D54
9D000C48  00000000   NOP
65:                              video_bmp[y][b] |= font[c][i]>>r;
9D000C4C  3C02A000   LUI V0, -24576
9D000C50  8FC4001C   LW A0, 28(S8)
9D000C54  2403000A   ADDIU V1, ZERO, 10
9D000C58  70831802   MUL V1, A0, V1
9D000C5C  00711821   ADDU V1, V1, S1
9D000C60  00031880   SLL V1, V1, 2
9D000C64  2442001C   ADDIU V0, V0, 28
9D000C68  00621021   ADDU V0, V1, V0
9D000C6C  8C430000   LW V1, 0(V0)
9D000C70  83C50020   LB A1, 32(S8)
9D000C74  3C029D00   LUI V0, -25344
9D000C78  24040007   ADDIU A0, ZERO, 7
9D000C7C  70A42002   MUL A0, A1, A0
9D000C80  00902021   ADDU A0, A0, S0
9D000C84  24421950   ADDIU V0, V0, 6480
9D000C88  00821021   ADDU V0, A0, V0
9D000C8C  90420000   LBU V0, 0(V0)
9D000C90  02421007   SRAV V0, V0, S2
9D000C94  00621825   OR V1, V1, V0
9D000C98  3C02A000   LUI V0, -24576
9D000C9C  8FC5001C   LW A1, 28(S8)
9D000CA0  2404000A   ADDIU A0, ZERO, 10
9D000CA4  70A42002   MUL A0, A1, A0
9D000CA8  00912021   ADDU A0, A0, S1
9D000CAC  00042080   SLL A0, A0, 2
9D000CB0  2442001C   ADDIU V0, V0, 28
9D000CB4  00821021   ADDU V0, A0, V0
9D000CB8  AC430000   SW V1, 0(V0)
66:                              video_bmp[y][b+1] |= font[c][i]<<(32-r);
9D000CBC  26240001   ADDIU A0, S1, 1
9D000CC0  26230001   ADDIU V1, S1, 1
9D000CC4  3C02A000   LUI V0, -24576
9D000CC8  8FC6001C   LW A2, 28(S8)
9D000CCC  2405000A   ADDIU A1, ZERO, 10
9D000CD0  70C52802   MUL A1, A2, A1
9D000CD4  00A31821   ADDU V1, A1, V1
9D000CD8  00031880   SLL V1, V1, 2
9D000CDC  2442001C   ADDIU V0, V0, 28
9D000CE0  00621021   ADDU V0, V1, V0
9D000CE4  8C430000   LW V1, 0(V0)
9D000CE8  83C60020   LB A2, 32(S8)
9D000CEC  3C029D00   LUI V0, -25344
9D000CF0  24050007   ADDIU A1, ZERO, 7
9D000CF4  70C52802   MUL A1, A2, A1
9D000CF8  00B02821   ADDU A1, A1, S0
9D000CFC  24421950   ADDIU V0, V0, 6480
9D000D00  00A21021   ADDU V0, A1, V0
9D000D04  90420000   LBU V0, 0(V0)
9D000D08  00402821   ADDU A1, V0, ZERO
9D000D0C  24020020   ADDIU V0, ZERO, 32
9D000D10  00521023   SUBU V0, V0, S2
9D000D14  00451004   SLLV V0, A1, V0
9D000D18  00621825   OR V1, V1, V0
9D000D1C  3C02A000   LUI V0, -24576
9D000D20  8FC6001C   LW A2, 28(S8)
9D000D24  2405000A   ADDIU A1, ZERO, 10
9D000D28  70C52802   MUL A1, A2, A1
9D000D2C  00A42021   ADDU A0, A1, A0
9D000D30  00042080   SLL A0, A0, 2
9D000D34  2442001C   ADDIU V0, V0, 28
9D000D38  00821021   ADDU V0, A0, V0
9D000D3C  AC430000   SW V1, 0(V0)
67:                              y++;
9D000D40  8FC2001C   LW V0, 28(S8)
9D000D44  24420001   ADDIU V0, V0, 1
9D000D48  AFC2001C   SW V0, 28(S8)
9D000D4C  0B400373   J 0x9D000DCC
9D000D50  00000000   NOP
68:                          } else{
69:                              video_bmp[y++][b] |= font[c][i]<<l;
9D000D54  8FC5001C   LW A1, 28(S8)
9D000D58  3C02A000   LUI V0, -24576
9D000D5C  2403000A   ADDIU V1, ZERO, 10
9D000D60  70A31802   MUL V1, A1, V1
9D000D64  00711821   ADDU V1, V1, S1
9D000D68  00031880   SLL V1, V1, 2
9D000D6C  2442001C   ADDIU V0, V0, 28
9D000D70  00621021   ADDU V0, V1, V0
9D000D74  8C430000   LW V1, 0(V0)
9D000D78  83C60020   LB A2, 32(S8)
9D000D7C  3C029D00   LUI V0, -25344
9D000D80  24040007   ADDIU A0, ZERO, 7
9D000D84  70C42002   MUL A0, A2, A0
9D000D88  00902021   ADDU A0, A0, S0
9D000D8C  24421950   ADDIU V0, V0, 6480
9D000D90  00821021   ADDU V0, A0, V0
9D000D94  90420000   LBU V0, 0(V0)
9D000D98  02621004   SLLV V0, V0, S3
9D000D9C  00621825   OR V1, V1, V0
9D000DA0  3C02A000   LUI V0, -24576
9D000DA4  2404000A   ADDIU A0, ZERO, 10
9D000DA8  70A42002   MUL A0, A1, A0
9D000DAC  00912021   ADDU A0, A0, S1
9D000DB0  00042080   SLL A0, A0, 2
9D000DB4  2442001C   ADDIU V0, V0, 28
9D000DB8  00821021   ADDU V0, A0, V0
9D000DBC  AC430000   SW V1, 0(V0)
9D000DC0  8FC2001C   LW V0, 28(S8)
9D000DC4  24420001   ADDIU V0, V0, 1
9D000DC8  AFC2001C   SW V0, 28(S8)
70:                          }
71:                      }
72:                  }//put)char()
9D000DDC  03C0E821   ADDU SP, S8, ZERO
9D000DE0  8FBE0014   LW S8, 20(SP)
9D000DE4  8FB30010   LW S3, 16(SP)
9D000DE8  8FB2000C   LW S2, 12(SP)
9D000DEC  8FB10008   LW S1, 8(SP)
9D000DF0  8FB00004   LW S0, 4(SP)
9D000DF4  27BD0018   ADDIU SP, SP, 24
9D000DF8  03E00008   JR RA
9D000DFC  00000000   NOP
73:                  
74:                  const char *msg2=" test video ntsc ";
75:                  const char *msg1="01234567890123456789012345678901234567890123456789012"; // 53 caractères par ligne
76:                  
77:                  void print(int x, int y, const char *text){
9D000E00  27BDFFE8   ADDIU SP, SP, -24
9D000E04  AFBF0014   SW RA, 20(SP)
9D000E08  AFBE0010   SW S8, 16(SP)
9D000E0C  03A0F021   ADDU S8, SP, ZERO
9D000E10  AFC40018   SW A0, 24(S8)
9D000E14  AFC5001C   SW A1, 28(S8)
9D000E18  AFC60020   SW A2, 32(S8)
78:                      while (*text){
9D000E1C  0B40039A   J 0x9D000E68
9D000E20  00000000   NOP
9D000E68  8FC20020   LW V0, 32(S8)
9D000E6C  80420000   LB V0, 0(V0)
9D000E70  1440FFEC   BNE V0, ZERO, 0x9D000E24
9D000E74  00000000   NOP
9D000E78  0B4003A1   J 0x9D000E84
9D000E7C  00000000   NOP
79:                          put_char(x, y, *text++);
9D000E24  8FC20020   LW V0, 32(S8)
9D000E28  80420000   LB V0, 0(V0)
9D000E2C  8FC30020   LW V1, 32(S8)
9D000E30  24630001   ADDIU V1, V1, 1
9D000E34  AFC30020   SW V1, 32(S8)
9D000E38  8FC40018   LW A0, 24(S8)
9D000E3C  8FC5001C   LW A1, 28(S8)
9D000E40  00403021   ADDU A2, V0, ZERO
9D000E44  0F4002ED   JAL put_char
9D000E48  00000000   NOP
80:                          x += 6;
9D000E4C  8FC20018   LW V0, 24(S8)
9D000E50  24420006   ADDIU V0, V0, 6
9D000E54  AFC20018   SW V0, 24(S8)
81:                          if (x>HRES-6) break;
9D000E58  8FC20018   LW V0, 24(S8)
9D000E5C  2842013B   SLTI V0, V0, 315
9D000E60  10400007   BEQ V0, ZERO, 0x9D000E80
9D000E64  00000000   NOP
9D000E80  00000000   NOP
82:                      }
83:                  }// print()
9D000E84  03C0E821   ADDU SP, S8, ZERO
9D000E88  8FBF0014   LW RA, 20(SP)
9D000E8C  8FBE0010   LW S8, 16(SP)
9D000E90  27BD0018   ADDIU SP, SP, 24
9D000E94  03E00008   JR RA
9D000E98  00000000   NOP
84:                  
85:                  void test_pattern(void){
9D000E9C  27BDFFE0   ADDIU SP, SP, -32
9D000EA0  AFBF001C   SW RA, 28(SP)
9D000EA4  AFBE0018   SW S8, 24(SP)
9D000EA8  03A0F021   ADDU S8, SP, ZERO
86:                      int i,j;
87:                      for (i=0;i<VRES;i++){
9D000EAC  AFC00010   SW ZERO, 16(S8)
9D000EB0  0B4003C1   J 0x9D000F04
9D000EB4  00000000   NOP
9D000EF8  8FC20010   LW V0, 16(S8)
9D000EFC  24420001   ADDIU V0, V0, 1
9D000F00  AFC20010   SW V0, 16(S8)
9D000F04  8FC20010   LW V0, 16(S8)
9D000F08  284200E6   SLTI V0, V0, 230
9D000F0C  1440FFEA   BNE V0, ZERO, 0x9D000EB8
9D000F10  00000000   NOP
88:                          video_bmp[i][0]=0x80000000;
9D000EB8  3C02A000   LUI V0, -24576
9D000EBC  8FC40010   LW A0, 16(S8)
9D000EC0  24030028   ADDIU V1, ZERO, 40
9D000EC4  70831802   MUL V1, A0, V1
9D000EC8  2442001C   ADDIU V0, V0, 28
9D000ECC  00621021   ADDU V0, V1, V0
9D000ED0  3C038000   LUI V1, -32768
9D000ED4  AC430000   SW V1, 0(V0)
89:                          video_bmp[i][HRES/32-1]=1;
9D000ED8  3C02A000   LUI V0, -24576
9D000EDC  8FC40010   LW A0, 16(S8)
9D000EE0  24030028   ADDIU V1, ZERO, 40
9D000EE4  70831802   MUL V1, A0, V1
9D000EE8  2442001C   ADDIU V0, V0, 28
9D000EEC  00621021   ADDU V0, V1, V0
9D000EF0  24030001   ADDIU V1, ZERO, 1
9D000EF4  AC430024   SW V1, 36(V0)
90:                      }
91:                      for (i=0;i<HRES/32;i++){
9D000F14  AFC00010   SW ZERO, 16(S8)
9D000F18  0B4003DA   J 0x9D000F68
9D000F1C  00000000   NOP
9D000F5C  8FC20010   LW V0, 16(S8)
9D000F60  24420001   ADDIU V0, V0, 1
9D000F64  AFC20010   SW V0, 16(S8)
9D000F68  8FC20010   LW V0, 16(S8)
9D000F6C  2842000A   SLTI V0, V0, 10
9D000F70  1440FFEB   BNE V0, ZERO, 0x9D000F20
9D000F74  00000000   NOP
92:                          video_bmp[0][i]=0xffffffff;
9D000F20  3C02A000   LUI V0, -24576
9D000F24  8FC30010   LW V1, 16(S8)
9D000F28  00031880   SLL V1, V1, 2
9D000F2C  2442001C   ADDIU V0, V0, 28
9D000F30  00621021   ADDU V0, V1, V0
9D000F34  2403FFFF   ADDIU V1, ZERO, -1
9D000F38  AC430000   SW V1, 0(V0)
93:                          video_bmp[VRES-1][i]=0xffffffff;
9D000F3C  3C02A000   LUI V0, -24576
9D000F40  8FC30010   LW V1, 16(S8)
9D000F44  246308F2   ADDIU V1, V1, 2290
9D000F48  00031880   SLL V1, V1, 2
9D000F4C  2442001C   ADDIU V0, V0, 28
9D000F50  00621021   ADDU V0, V1, V0
9D000F54  2403FFFF   ADDIU V1, ZERO, -1
9D000F58  AC430000   SW V1, 0(V0)
94:                      }
95:                      for (i=VRES/4;i<VRES/2+VRES/4;i++){
9D000F78  24020039   ADDIU V0, ZERO, 57
9D000F7C  AFC20010   SW V0, 16(S8)
9D000F80  0B400409   J 0x9D001024
9D000F84  00000000   NOP
9D001018  8FC20010   LW V0, 16(S8)
9D00101C  24420001   ADDIU V0, V0, 1
9D001020  AFC20010   SW V0, 16(S8)
9D001024  8FC20010   LW V0, 16(S8)
9D001028  284200AC   SLTI V0, V0, 172
9D00102C  1440FFD6   BNE V0, ZERO, 0x9D000F88
9D001030  00000000   NOP
96:                          video_bmp[i][2]=0xFF00FF00;
9D000F88  3C02A000   LUI V0, -24576
9D000F8C  8FC40010   LW A0, 16(S8)
9D000F90  24030028   ADDIU V1, ZERO, 40
9D000F94  70831802   MUL V1, A0, V1
9D000F98  2442001C   ADDIU V0, V0, 28
9D000F9C  00621021   ADDU V0, V1, V0
9D000FA0  3C03FF00   LUI V1, -256
9D000FA4  3463FF00   ORI V1, V1, -256
9D000FA8  AC430008   SW V1, 8(V0)
97:                          video_bmp[i][3]=0xF0F0F0F0;
9D000FAC  3C02A000   LUI V0, -24576
9D000FB0  8FC40010   LW A0, 16(S8)
9D000FB4  24030028   ADDIU V1, ZERO, 40
9D000FB8  70831802   MUL V1, A0, V1
9D000FBC  2442001C   ADDIU V0, V0, 28
9D000FC0  00621021   ADDU V0, V1, V0
9D000FC4  3C03F0F0   LUI V1, -3856
9D000FC8  3463F0F0   ORI V1, V1, -3856
9D000FCC  AC43000C   SW V1, 12(V0)
98:                          video_bmp[i][4]=0xcccccccc;
9D000FD0  3C02A000   LUI V0, -24576
9D000FD4  8FC40010   LW A0, 16(S8)
9D000FD8  24030028   ADDIU V1, ZERO, 40
9D000FDC  70831802   MUL V1, A0, V1
9D000FE0  2442001C   ADDIU V0, V0, 28
9D000FE4  00621021   ADDU V0, V1, V0
9D000FE8  3C03CCCC   LUI V1, -13108
9D000FEC  3463CCCC   ORI V1, V1, -13108
9D000FF0  AC430010   SW V1, 16(V0)
99:                          video_bmp[i][5]=0xaaaaaaaa;
9D000FF4  3C02A000   LUI V0, -24576
9D000FF8  8FC40010   LW A0, 16(S8)
9D000FFC  24030028   ADDIU V1, ZERO, 40
9D001000  70831802   MUL V1, A0, V1
9D001004  2442001C   ADDIU V0, V0, 28
9D001008  00621021   ADDU V0, V1, V0
9D00100C  3C03AAAA   LUI V1, -21846
9D001010  3463AAAA   ORI V1, V1, -21846
9D001014  AC430014   SW V1, 20(V0)
100:                     }//i
101:                     print(2,3,msg1);
9D001034  8F828014   LW V0, -32748(GP)
9D001038  24040002   ADDIU A0, ZERO, 2
9D00103C  24050003   ADDIU A1, ZERO, 3
9D001040  00403021   ADDU A2, V0, ZERO
9D001044  0F400380   JAL print
9D001048  00000000   NOP
102:                     print(2,12,msg2);
9D00104C  8F828010   LW V0, -32752(GP)
9D001050  24040002   ADDIU A0, ZERO, 2
9D001054  2405000C   ADDIU A1, ZERO, 12
9D001058  00403021   ADDU A2, V0, ZERO
9D00105C  0F400380   JAL print
9D001060  00000000   NOP
103:                 }//test_pattern()
9D001064  03C0E821   ADDU SP, S8, ZERO
9D001068  8FBF001C   LW RA, 28(SP)
9D00106C  8FBE0018   LW S8, 24(SP)
9D001070  27BD0020   ADDIU SP, SP, 32
9D001074  03E00008   JR RA
9D001078  00000000   NOP
104:                 
105:                 
106:                 void main(void) {
9D00107C  27BDFFE8   ADDIU SP, SP, -24
9D001080  AFBF0014   SW RA, 20(SP)
9D001084  AFBE0010   SW S8, 16(SP)
9D001088  03A0F021   ADDU S8, SP, ZERO
107:                     HardwareInit();
9D00108C  0F400432   JAL HardwareInit
9D001090  00000000   NOP
108:                     UartInit(STDIO,9600,DEFAULT_LINE_CTRL);
9D001094  24040001   ADDIU A0, ZERO, 1
9D001098  24052580   ADDIU A1, ZERO, 9600
9D00109C  00003021   ADDU A2, ZERO, ZERO
9D0010A0  0F400008   JAL UartInit
9D0010A4  00000000   NOP
109:                     ln_cnt=0;
9D0010A8  AF808028   SW ZERO, -32728(GP)
110:                     video=0;
9D0010AC  AF808024   SW ZERO, -32732(GP)
111:                     test_pattern();
9D0010B0  0F4003A7   JAL test_pattern
9D0010B4  00000000   NOP
112:                     VideoInit();
9D0010B8  0F40054B   JAL VideoInit
9D0010BC  00000000   NOP
113:                     while(1){
114:                     }
9D0010C0  0B400430   J 0x9D0010C0
9D0010C4  00000000   NOP
115:                 }
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/serial_comm.c  ---------------------------------
1:                   /*
2:                    * File:   uart.h
3:                    * Author: Jacques
4:                    * Description: fonctions de bas niveau pour communication UART avec le PC
5:                    * Created on 17 avril 2013, 14:48
6:                    */
7:                   
8:                   #include <plib.h>
9:                   #include "serial_comm.h"
10:                  #include "HardwareProfile.h"
11:                  
12:                  static char unget;
13:                  
14:                  void UartInit(UART_MODULE channel, int baudrate, UART_LINE_CONTROL_MODE LineCtrl){
9D000020  27BDFFE8   ADDIU SP, SP, -24
9D000024  AFBF0014   SW RA, 20(SP)
9D000028  AFBE0010   SW S8, 16(SP)
9D00002C  03A0F021   ADDU S8, SP, ZERO
9D000030  AFC40018   SW A0, 24(S8)
9D000034  AFC5001C   SW A1, 28(S8)
9D000038  AFC60020   SW A2, 32(S8)
15:                  /*initialise le périphérique UART*/
16:                     // Configure UART, information dans uart.h
17:                     UARTConfigure(channel, UART_ENABLE_PINS_TX_RX_ONLY); // pas de contrôle de flux matériel.
9D00003C  8FC40018   LW A0, 24(S8)
9D000040  00002821   ADDU A1, ZERO, ZERO
9D000044  0F4007EA   JAL UARTConfigure
9D000048  00000000   NOP
18:                     UARTSetLineControl(channel, LineCtrl);
9D00004C  8FC40018   LW A0, 24(S8)
9D000050  8FC50020   LW A1, 32(S8)
9D000054  0F400884   JAL UARTSetLineControl
9D000058  00000000   NOP
19:                     UARTSetDataRate(channel, mGetPeripheralClock(), baudrate);
9D00005C  8FC2001C   LW V0, 28(S8)
9D000060  8FC40018   LW A0, 24(S8)
9D000064  3C03023C   LUI V1, 572
9D000068  34653460   ORI A1, V1, 13408
9D00006C  00403021   ADDU A2, V0, ZERO
9D000070  0F40078E   JAL UARTSetDataRate
9D000074  00000000   NOP
20:                     // activation du périphérique
21:                     UARTEnable(channel, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D000078  8FC40018   LW A0, 24(S8)
9D00007C  24050087   ADDIU A1, ZERO, 135
9D000080  0F40076E   JAL UARTEnable
9D000084  00000000   NOP
22:                     unget=-1;
9D000088  2402FFFF   ADDIU V0, ZERO, -1
9D00008C  A3828018   SB V0, -32744(GP)
23:                  };
9D000090  03C0E821   ADDU SP, S8, ZERO
9D000094  8FBF0014   LW RA, 20(SP)
9D000098  8FBE0010   LW S8, 16(SP)
9D00009C  27BD0018   ADDIU SP, SP, 24
9D0000A0  03E00008   JR RA
9D0000A4  00000000   NOP
24:                  
25:                  char UartGetch(UART_MODULE channel){
9D0000A8  27BDFFF0   ADDIU SP, SP, -16
9D0000AC  AFBE000C   SW S8, 12(SP)
9D0000B0  03A0F021   ADDU S8, SP, ZERO
9D0000B4  AFC40010   SW A0, 16(S8)
9D0000B8  8FC20010   LW V0, 16(S8)
9D0000BC  AFC20000   SW V0, 0(S8)
26:                  /*lecture d'un caractère retourne -1 si aucun disponible*/
27:                      char ch;
28:                      if (!unget==-1) {
29:                          ch=unget;
30:                          unget=-1;
31:                          return ch;
32:                      }else{
33:                          if (UARTReceivedDataIsAvailable (channel)){
9D0000E0  1040000E   BEQ V0, ZERO, 0x9D00011C
9D0000E4  00000000   NOP
9D0000E8  8FC20010   LW V0, 16(S8)
9D0000EC  AFC20004   SW V0, 4(S8)
34:                                 return UARTGetDataByte(channel);
9D000110  7C021420   SEB V0, V0
9D000114  0B400048   J 0x9D000120
9D000118  00000000   NOP
35:                          }else{
36:                              return -1;
9D00011C  2402FFFF   ADDIU V0, ZERO, -1
37:                          }
38:                      }
39:                  };
9D000120  03C0E821   ADDU SP, S8, ZERO
9D000124  8FBE000C   LW S8, 12(SP)
9D000128  27BD0010   ADDIU SP, SP, 16
9D00012C  03E00008   JR RA
9D000130  00000000   NOP
40:                  
41:                  void UartPutch(UART_MODULE channel, char c){
9D000134  27BDFFE8   ADDIU SP, SP, -24
9D000138  AFBE0014   SW S8, 20(SP)
9D00013C  03A0F021   ADDU S8, SP, ZERO
9D000140  AFC40018   SW A0, 24(S8)
9D000144  00A01021   ADDU V0, A1, ZERO
9D000148  A3C2001C   SB V0, 28(S8)
42:                  /*Envoie d'un caractère*/
43:                      while(!UARTTransmitterIsReady(channel));
9D00014C  8FC20018   LW V0, 24(S8)
9D000150  AFC20000   SW V0, 0(S8)
9D00018C  1040FFEF   BEQ V0, ZERO, 0x9D00014C
9D000190  00000000   NOP
44:                        UARTSendDataByte(channel, c);
9D000194  93C2001C   LBU V0, 28(S8)
9D000198  8FC30018   LW V1, 24(S8)
9D00019C  AFC30004   SW V1, 4(S8)
9D0001A0  A3C20008   SB V0, 8(S8)
45:                  };
9D0001C4  03C0E821   ADDU SP, S8, ZERO
9D0001C8  8FBE0014   LW S8, 20(SP)
9D0001CC  27BD0018   ADDIU SP, SP, 24
9D0001D0  03E00008   JR RA
9D0001D4  00000000   NOP
46:                  
47:                  char UartWaitch(UART_MODULE channel, int delay){
9D0001D8  27BDFFE0   ADDIU SP, SP, -32
9D0001DC  AFBE001C   SW S8, 28(SP)
9D0001E0  03A0F021   ADDU S8, SP, ZERO
9D0001E4  AFC40020   SW A0, 32(S8)
9D0001E8  AFC50024   SW A1, 36(S8)
48:                  /*attend un caractère pour un temps spécifié par delay
49:                  *retourne -1 si aucun reçu avant expiration du délais
50:                  */
51:                      int t;
52:                      char ch;
53:                      if (!unget==-1){
54:                          ch=unget;
55:                          unget=-1;
56:                          return unget;
57:                      }
58:                      if (!delay) while (1) if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D0001EC  8FC20024   LW V0, 36(S8)
9D0001F0  1440001D   BNE V0, ZERO, 0x9D000268
9D0001F4  00000000   NOP
9D0001F8  0B400081   J 0x9D000204
9D0001FC  00000000   NOP
9D000204  8FC20020   LW V0, 32(S8)
9D000208  AFC20004   SW V0, 4(S8)
9D00022C  1040FFF4   BEQ V0, ZERO, 0x9D000200
9D000230  00000000   NOP
9D000234  8FC20020   LW V0, 32(S8)
9D000238  AFC20008   SW V0, 8(S8)
9D00025C  7C021420   SEB V0, V0
9D000260  0B4000BF   J 0x9D0002FC
9D000264  00000000   NOP
59:                      t=sys_tick;
9D000200  00000000   NOP
9D000268  8F828020   LW V0, -32736(GP)
9D00026C  AFC20000   SW V0, 0(S8)
60:                      while (sys_tick-t<delay){
9D000270  0B4000B7   J 0x9D0002DC
9D000274  00000000   NOP
9D000278  8FC20020   LW V0, 32(S8)
9D00027C  AFC2000C   SW V0, 12(S8)
9D0002DC  8F838020   LW V1, -32736(GP)
9D0002E0  8FC20000   LW V0, 0(S8)
9D0002E4  00621823   SUBU V1, V1, V0
9D0002E8  8FC20024   LW V0, 36(S8)
9D0002EC  0062102B   SLTU V0, V1, V0
9D0002F0  1440FFE1   BNE V0, ZERO, 0x9D000278
9D0002F4  00000000   NOP
61:                         if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D0002A0  1040000E   BEQ V0, ZERO, 0x9D0002DC
9D0002A4  00000000   NOP
9D0002A8  8FC20020   LW V0, 32(S8)
9D0002AC  AFC20010   SW V0, 16(S8)
9D0002D0  7C021420   SEB V0, V0
9D0002D4  0B4000BF   J 0x9D0002FC
9D0002D8  00000000   NOP
62:                      }
63:                      return -1;
9D0002F8  2402FFFF   ADDIU V0, ZERO, -1
64:                  }
9D0002FC  03C0E821   ADDU SP, S8, ZERO
9D000300  8FBE001C   LW S8, 28(SP)
9D000304  27BD0020   ADDIU SP, SP, 32
9D000308  03E00008   JR RA
9D00030C  00000000   NOP
65:                  
66:                  void UartPrint(UART_MODULE channel, const char* str){
9D000310  27BDFFE8   ADDIU SP, SP, -24
9D000314  AFBE0014   SW S8, 20(SP)
9D000318  03A0F021   ADDU S8, SP, ZERO
9D00031C  AFC40018   SW A0, 24(S8)
9D000320  AFC5001C   SW A1, 28(S8)
67:                  /* envoie la chaine de caractère str via le UART */
68:                     while(*str != (char)0)
9D000324  0B4000EE   J 0x9D0003B8
9D000328  00000000   NOP
9D0003B8  8FC2001C   LW V0, 28(S8)
9D0003BC  80420000   LB V0, 0(V0)
9D0003C0  1440FFDA   BNE V0, ZERO, 0x9D00032C
9D0003C4  00000000   NOP
69:                     {
70:                        while(!UARTTransmitterIsReady(channel));
9D00032C  8FC20018   LW V0, 24(S8)
9D000330  AFC20000   SW V0, 0(S8)
9D00036C  1040FFEF   BEQ V0, ZERO, 0x9D00032C
9D000370  00000000   NOP
71:                        UARTSendDataByte(channel, *str++);
9D000374  8FC2001C   LW V0, 28(S8)
9D000378  80420000   LB V0, 0(V0)
9D00037C  304200FF   ANDI V0, V0, 255
9D000380  8FC3001C   LW V1, 28(S8)
9D000384  24630001   ADDIU V1, V1, 1
9D000388  AFC3001C   SW V1, 28(S8)
9D00038C  8FC30018   LW V1, 24(S8)
9D000390  AFC30004   SW V1, 4(S8)
9D000394  A3C20008   SB V0, 8(S8)
72:                     }
73:                     while(!UARTTransmissionHasCompleted(channel));
9D0003C8  8FC20018   LW V0, 24(S8)
9D0003CC  AFC2000C   SW V0, 12(S8)
9D000408  1040FFEF   BEQ V0, ZERO, 0x9D0003C8
9D00040C  00000000   NOP
74:                  };
9D000410  03C0E821   ADDU SP, S8, ZERO
9D000414  8FBE0014   LW S8, 20(SP)
9D000418  27BD0018   ADDIU SP, SP, 24
9D00041C  03E00008   JR RA
9D000420  00000000   NOP
75:                  
76:                  int UartReadln(UART_MODULE channel, char *buffer, int buff_len){
9D000424  27BDFFD8   ADDIU SP, SP, -40
9D000428  AFBF0024   SW RA, 36(SP)
9D00042C  AFBE0020   SW S8, 32(SP)
9D000430  03A0F021   ADDU S8, SP, ZERO
9D000434  AFC40028   SW A0, 40(S8)
9D000438  AFC5002C   SW A1, 44(S8)
9D00043C  AFC60030   SW A2, 48(S8)
77:                  /* lecture d'une chaine se terminant par '\r'
78:                   *  complète la chaine avec un zéro
79:                   *  retourne le nombre de caractère dans le buffer.
80:                   */
81:                      int count=0;
9D000440  AFC00010   SW ZERO, 16(S8)
82:                      char c;
83:                      if (!unget==-1){
84:                          c=unget;
85:                          unget=-1;
86:                          *buffer++=c;
87:                          if (c==CR) return;
88:                      }
89:                      while (count < (buff_len-1)){
9D000444  0B400150   J 0x9D000540
9D000448  00000000   NOP
9D00044C  8FC20028   LW V0, 40(S8)
9D000450  AFC20018   SW V0, 24(S8)
9D000540  8FC20030   LW V0, 48(S8)
9D000544  2443FFFF   ADDIU V1, V0, -1
9D000548  8FC20010   LW V0, 16(S8)
9D00054C  0043102A   SLT V0, V0, V1
9D000550  1440FFBE   BNE V0, ZERO, 0x9D00044C
9D000554  00000000   NOP
9D000558  0B400159   J 0x9D000564
9D00055C  00000000   NOP
90:                          if (UARTReceivedDataIsAvailable(channel)){
9D000474  10400032   BEQ V0, ZERO, 0x9D000540
9D000478  00000000   NOP
9D00047C  8FC20028   LW V0, 40(S8)
9D000480  AFC2001C   SW V0, 28(S8)
91:                              c = UARTGetDataByte(channel);
9D0004A4  A3C20014   SB V0, 20(S8)
92:                              if (c==CR) break;
9D0004A8  83C30014   LB V1, 20(S8)
9D0004AC  2402000D   ADDIU V0, ZERO, 13
9D0004B0  1062002B   BEQ V1, V0, 0x9D000560
9D0004B4  00000000   NOP
9D000560  00000000   NOP
93:                              if (c==BS){
9D0004B8  83C30014   LB V1, 20(S8)
9D0004BC  24020008   ADDIU V0, ZERO, 8
9D0004C0  14620011   BNE V1, V0, 0x9D000508
9D0004C4  00000000   NOP
94:                                  if (count){
9D0004C8  8FC20010   LW V0, 16(S8)
9D0004CC  1040001C   BEQ V0, ZERO, 0x9D000540
9D0004D0  00000000   NOP
95:                                      buffer--;
9D0004D4  8FC2002C   LW V0, 44(S8)
9D0004D8  2442FFFF   ADDIU V0, V0, -1
9D0004DC  AFC2002C   SW V0, 44(S8)
96:                                      count--;
9D0004E0  8FC20010   LW V0, 16(S8)
9D0004E4  2442FFFF   ADDIU V0, V0, -1
9D0004E8  AFC20010   SW V0, 16(S8)
97:                                      UartPrint(channel,"\b \b");
9D0004EC  8FC40028   LW A0, 40(S8)
9D0004F0  3C029D00   LUI V0, -25344
9D0004F4  244523A0   ADDIU A1, V0, 9120
9D0004F8  0F4000C4   JAL UartPrint
9D0004FC  00000000   NOP
9D000500  0B400150   J 0x9D000540
9D000504  00000000   NOP
98:                                  }
99:                              }else{
100:                                 *buffer++=c;
9D000508  8FC2002C   LW V0, 44(S8)
9D00050C  93C30014   LBU V1, 20(S8)
9D000510  A0430000   SB V1, 0(V0)
9D000514  8FC2002C   LW V0, 44(S8)
9D000518  24420001   ADDIU V0, V0, 1
9D00051C  AFC2002C   SW V0, 44(S8)
101:                                 count++;
9D000520  8FC20010   LW V0, 16(S8)
9D000524  24420001   ADDIU V0, V0, 1
9D000528  AFC20010   SW V0, 16(S8)
102:                                 UartPutch(channel,c);
9D00052C  83C20014   LB V0, 20(S8)
9D000530  8FC40028   LW A0, 40(S8)
9D000534  00402821   ADDU A1, V0, ZERO
9D000538  0F40004D   JAL UartPutch
9D00053C  00000000   NOP
103:                             }
104:                             
105:                         }
106:                     }
107:                     if (count) *buffer = (char)0;
9D000564  8FC20010   LW V0, 16(S8)
9D000568  10400003   BEQ V0, ZERO, 0x9D000578
9D00056C  00000000   NOP
9D000570  8FC2002C   LW V0, 44(S8)
9D000574  A0400000   SB ZERO, 0(V0)
108:                     UartPutch(channel,'\r');
9D000578  8FC40028   LW A0, 40(S8)
9D00057C  2405000D   ADDIU A1, ZERO, 13
9D000580  0F40004D   JAL UartPutch
9D000584  00000000   NOP
109:                     return count;
9D000588  8FC20010   LW V0, 16(S8)
110:                 }
9D00058C  03C0E821   ADDU SP, S8, ZERO
9D000590  8FBF0024   LW RA, 36(SP)
9D000594  8FBE0020   LW S8, 32(SP)
9D000598  27BD0028   ADDIU SP, SP, 40
9D00059C  03E00008   JR RA
9D0005A0  00000000   NOP
111:                 
112:                 int UartReceivedBreak(UART_MODULE channel){
9D0005A4  27BDFFE8   ADDIU SP, SP, -24
9D0005A8  AFBE0014   SW S8, 20(SP)
9D0005AC  03A0F021   ADDU S8, SP, ZERO
9D0005B0  AFC40018   SW A0, 24(S8)
113:                    char ch;
114:                    if (unget==-1 && UARTReceivedDataIsAvailable(channel)) {
9D0005B4  83838018   LB V1, -32744(GP)
9D0005B8  2402FFFF   ADDIU V0, ZERO, -1
9D0005BC  14620021   BNE V1, V0, 0x9D000644
9D0005C0  00000000   NOP
9D0005C4  8FC20018   LW V0, 24(S8)
9D0005C8  AFC20004   SW V0, 4(S8)
9D0005EC  10400015   BEQ V0, ZERO, 0x9D000644
9D0005F0  00000000   NOP
9D0005F4  8FC20018   LW V0, 24(S8)
9D0005F8  AFC20008   SW V0, 8(S8)
115:                        ch=UARTGetDataByte(channel);
9D00061C  A3C20000   SB V0, 0(S8)
116:                        if (ch==ESC) return 1; else unget=ch;
9D000620  83C30000   LB V1, 0(S8)
9D000624  2402001B   ADDIU V0, ZERO, 27
9D000628  14620004   BNE V1, V0, 0x9D00063C
9D00062C  00000000   NOP
9D000630  24020001   ADDIU V0, ZERO, 1
9D000634  0B400192   J 0x9D000648
9D000638  00000000   NOP
9D00063C  93C20000   LBU V0, 0(S8)
9D000640  A3828018   SB V0, -32744(GP)
117:                    }
118:                    return 0;
9D000644  00001021   ADDU V0, ZERO, ZERO
119:                 }
9D000648  03C0E821   ADDU SP, S8, ZERO
9D00064C  8FBE0014   LW S8, 20(SP)
9D000650  27BD0018   ADDIU SP, SP, 24
9D000654  03E00008   JR RA
9D000658  00000000   NOP
120:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/ntsc.c  ----------------------------------------
1:                   /* 
2:                    * File:   test-ntsc.c
3:                    * Author: Jacques Deschênes
4:                    * Description: test génération signal vidéo NTSC sur PIC32MX150F128B.
5:                    * Created on 20 août 2013, 08:48
6:                    */
7:                   
8:                   #include <stdio.h>
9:                   #include <stdlib.h>
10:                  #include <sys/attribs.h>
11:                  #include <plib.h>
12:                  #include "HardwareProfile.h"
13:                  #include "ntsc.h"
14:                  
15:                  /*
16:                   *  la fréqueence PBCLK influence la largeur des pixels vidéo. Comme PBCLK==SYSCLK
17:                   *  on peut allonger les pixels en diminuant la fréquence légèrement.
18:                   *  pour une résolution horizontale de 320 pixels et une fréquence de 40Mhz le
19:                   *  meilleur diviseur pour le générateur BGR du SPI est de 2 ce qui donne
20:                   *  une fréquence de pixel de  40e6/(2*(2+1)=6,67Mhz et la durée total d'une
21:                   *  ligne vidéo est donc de 320/6,67e6= 48µSec.
22:                   *  En principe pour le standard NTSC on dispose de 52µSec par ligne vidéo.
23:                   *  En pratique on est plutôt à 51µSec. Donc ici on a 3µSec inutilisées.
24:                   *  en résuidant SYSCLK à 37,5Mhz on a 51,2µSec par ligne vidéo. Les pixels
25:                   *  sont donc moins compressé horizontalement. Mais sur certains téléviseurs
26:                   *  on peut perdre quelques pixels en bout de ligne.
27:                   *  la constante SPI_DLY doit-être ajustée en fonction de PBCLK pour que les
28:                   *  320 pixels horizontals soient visibles.
29:                   */
30:                  
31:                  #define PWM_PERIOD (SYSCLK/15748)-1
32:                  #define HSYNC  (SYSCLK/212766)  // 4,7µSec
33:                  #define FIRST_LINE 27   //première ligne de scan visible
34:                  #define LAST_LINE  256  // dernière ligne de scan visible
35:                  #define BITCLK HRES * 1000000L/52 // 52µSec c'est le temps que dure 1 ligne vidéo.
36:                  #if SYSCLK==40000000L
37:                  #define SPI_DLY HSYNC+90 // délais en début de ligne avant l'envoie du signal vidéo.
38:                  #else
39:                  #define SPI_DLY HSYNC+35 // délais en début de ligne avant l'envoie du signal vidéo.
40:                  #endif
41:                  #define _enable_video_out()  SPI1CONSET=(1<<15)
42:                  #define _disable_video_out() SPI1CONCLR=(1<<15)
43:                  
44:                  unsigned int video_bmp[VRES][HRES/32]; // video bitmap 7168 octets
45:                  volatile unsigned int ln_cnt;
46:                  volatile unsigned int video;
47:                  volatile int *DmaSrc;
48:                  
49:                  
50:                  
51:                  void VideoInit(void){
9D00152C  27BDFFE0   ADDIU SP, SP, -32
9D001530  AFBF001C   SW RA, 28(SP)
9D001534  AFBE0018   SW S8, 24(SP)
9D001538  03A0F021   ADDU S8, SP, ZERO
52:                      //configuration PWM sur OC2 pour SYNC, utilisation TIMER2
53:                      RPB5Rbits.RPB5R=5;  // 5=OC2  sortie SYNC
9D00153C  3C03BF81   LUI V1, -16511
9D001540  8C62FB40   LW V0, -1216(V1)
9D001544  24040005   ADDIU A0, ZERO, 5
9D001548  7C821804   INS V0, A0, 0, 4
9D00154C  AC62FB40   SW V0, -1216(V1)
54:                      T2CON = 0;
9D001550  3C02BF80   LUI V0, -16512
9D001554  AC400800   SW ZERO, 2048(V0)
55:                      PR2=PWM_PERIOD;
9D001558  3C02BF80   LUI V0, -16512
9D00155C  2403094C   ADDIU V1, ZERO, 2380
9D001560  AC430820   SW V1, 2080(V0)
56:                      OC2CONbits.OCM = 5; // mode train d'impulsion
9D001564  3C03BF80   LUI V1, -16512
9D001568  8C623200   LW V0, 12800(V1)
9D00156C  24040005   ADDIU A0, ZERO, 5
9D001570  7C821004   INS V0, A0, 0, 3
9D001574  AC623200   SW V0, 12800(V1)
57:                      OC2RS = 0; 
9D001578  3C02BF80   LUI V0, -16512
9D00157C  AC403220   SW ZERO, 12832(V0)
58:                      OC2R = HSYNC;
9D001580  3C02BF80   LUI V0, -16512
9D001584  240300B0   ADDIU V1, ZERO, 176
9D001588  AC433210   SW V1, 12816(V0)
59:                      IFS0bits.T2IF=0;
9D00158C  3C03BF88   LUI V1, -16504
9D001590  8C621030   LW V0, 4144(V1)
9D001594  7C024A44   INS V0, ZERO, 9, 1
9D001598  AC621030   SW V0, 4144(V1)
60:                      IEC0bits.T2IE=1;
9D00159C  3C03BF88   LUI V1, -16504
9D0015A0  8C621060   LW V0, 4192(V1)
9D0015A4  24040001   ADDIU A0, ZERO, 1
9D0015A8  7C824A44   INS V0, A0, 9, 1
9D0015AC  AC621060   SW V0, 4192(V1)
61:                      IPC2bits.T2IP=7;
9D0015B0  3C03BF88   LUI V1, -16504
9D0015B4  8C6210B0   LW V0, 4272(V1)
9D0015B8  24040007   ADDIU A0, ZERO, 7
9D0015BC  7C822084   INS V0, A0, 2, 3
9D0015C0  AC6210B0   SW V0, 4272(V1)
62:                      IPC2bits.T2IS=3;
9D0015C4  3C03BF88   LUI V1, -16504
9D0015C8  8C6210B0   LW V0, 4272(V1)
9D0015CC  24040003   ADDIU A0, ZERO, 3
9D0015D0  7C820804   INS V0, A0, 0, 2
9D0015D4  AC6210B0   SW V0, 4272(V1)
63:                      OC2CONbits.ON =1;  // activation
9D0015D8  3C03BF80   LUI V1, -16512
9D0015DC  8C623200   LW V0, 12800(V1)
9D0015E0  24040001   ADDIU A0, ZERO, 1
9D0015E4  7C827BC4   INS V0, A0, 15, 1
9D0015E8  AC623200   SW V0, 12800(V1)
64:                      T2CONbits.ON=1;  // activation
9D0015EC  3C03BF80   LUI V1, -16512
9D0015F0  8C620800   LW V0, 2048(V1)
9D0015F4  24040001   ADDIU A0, ZERO, 1
9D0015F8  7C827BC4   INS V0, A0, 15, 1
9D0015FC  AC620800   SW V0, 2048(V1)
65:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
66:                      RPB4Rbits.RPB4R=5; // 5=OC1 impulsion déclenchant SPI
9D001600  3C03BF81   LUI V1, -16511
9D001604  8C62FB3C   LW V0, -1220(V1)
9D001608  24040005   ADDIU A0, ZERO, 5
9D00160C  7C821804   INS V0, A0, 0, 4
9D001610  AC62FB3C   SW V0, -1220(V1)
67:                      OC1CONbits.OCM = 5; //mode train d'impulsion
9D001614  3C03BF80   LUI V1, -16512
9D001618  8C623000   LW V0, 12288(V1)
9D00161C  24040005   ADDIU A0, ZERO, 5
9D001620  7C821004   INS V0, A0, 0, 3
9D001624  AC623000   SW V0, 12288(V1)
68:                      OC1RS=0;
9D001628  3C02BF80   LUI V0, -16512
9D00162C  AC403020   SW ZERO, 12320(V0)
69:                      OC1R=HSYNC+SPI_DLY;
9D001630  3C02BF80   LUI V0, -16512
9D001634  24030183   ADDIU V1, ZERO, 387
9D001638  AC433010   SW V1, 12304(V0)
70:                      OC1CONbits.ON=1;
9D00163C  3C03BF80   LUI V1, -16512
9D001640  8C623000   LW V0, 12288(V1)
9D001644  24040001   ADDIU A0, ZERO, 1
9D001648  7C827BC4   INS V0, A0, 15, 1
9D00164C  AC623000   SW V0, 12288(V1)
71:                      // configuration SPI pour sortie vidéo
72:                      RPB6Rbits.RPB6R=3;  // 3=SDO1  sortie vidéo
9D001650  3C03BF81   LUI V1, -16511
9D001654  8C62FB44   LW V0, -1212(V1)
9D001658  24040003   ADDIU A0, ZERO, 3
9D00165C  7C821804   INS V0, A0, 0, 4
9D001660  AC62FB44   SW V0, -1212(V1)
73:                      SS1Rbits.SS1R=4; // entrée Fsync sur RPB7
9D001664  3C03BF81   LUI V1, -16511
9D001668  8C62FA88   LW V0, -1400(V1)
9D00166C  24040004   ADDIU A0, ZERO, 4
9D001670  7C821804   INS V0, A0, 0, 4
9D001674  AC62FA88   SW V0, -1400(V1)
74:                      // configure le DMA
75:                      DmaChnOpen(0,0,DMA_OPEN_DEFAULT);
9D001678  00002021   ADDU A0, ZERO, ZERO
9D00167C  00002821   ADDU A1, ZERO, ZERO
9D001680  00003021   ADDU A2, ZERO, ZERO
9D001684  0F4006D9   JAL DmaChnOpen
9D001688  00000000   NOP
76:                      DmaChnSetEventControl(0,DMA_EV_START_IRQ_EN|
9D00168C  00002021   ADDU A0, ZERO, ZERO
9D001690  24052610   ADDIU A1, ZERO, 9744
9D001694  0F400859   JAL DmaChnWriteEventControlFlags
9D001698  00000000   NOP
77:                                            DMA_EV_START_IRQ(_SPI1_TX_IRQ));
78:                      DmaChnSetTxfer(0,(void *)DmaSrc,(void *)&SPI1BUF,HRES/8,4,4);
9D00169C  8F82801C   LW V0, -32740(GP)
9D0016A0  24030004   ADDIU V1, ZERO, 4
9D0016A4  AFA30010   SW V1, 16(SP)
9D0016A8  24030004   ADDIU V1, ZERO, 4
9D0016AC  AFA30014   SW V1, 20(SP)
9D0016B0  00002021   ADDU A0, ZERO, ZERO
9D0016B4  00402821   ADDU A1, V0, ZERO
9D0016B8  3C02BF80   LUI V0, -16512
9D0016BC  24465820   ADDIU A2, V0, 22560
9D0016C0  24070028   ADDIU A3, ZERO, 40
9D0016C4  0F400748   JAL DmaChnSetTxfer
9D0016C8  00000000   NOP
79:                      // configuration du SPI canal 1
80:                      SPI1CONbits.DISSDI=1; // SDI n'est pas utilisé.
9D0016CC  3C03BF80   LUI V1, -16512
9D0016D0  8C625800   LW V0, 22528(V1)
9D0016D4  24040001   ADDIU A0, ZERO, 1
9D0016D8  7C822104   INS V0, A0, 4, 1
9D0016DC  AC625800   SW V0, 22528(V1)
81:                      SPI1CONbits.FRMEN=1; // frame mode
9D0016E0  3C03BF80   LUI V1, -16512
9D0016E4  8C625800   LW V0, 22528(V1)
9D0016E8  24040001   ADDIU A0, ZERO, 1
9D0016EC  7C82FFC4   INS V0, A0, 31, 1
9D0016F0  AC625800   SW V0, 22528(V1)
82:                      SPI1CONbits.FRMCNT=5; // 32 octets par frame.
9D0016F4  3C03BF80   LUI V1, -16512
9D0016F8  8C625800   LW V0, 22528(V1)
9D0016FC  24040005   ADDIU A0, ZERO, 5
9D001700  7C82D604   INS V0, A0, 24, 3
9D001704  AC625800   SW V0, 22528(V1)
83:                      SPI1CONbits.FRMPOL=1; // sync sur transition montante
9D001708  3C03BF80   LUI V1, -16512
9D00170C  8C625800   LW V0, 22528(V1)
9D001710  24040001   ADDIU A0, ZERO, 1
9D001714  7C82EF44   INS V0, A0, 29, 1
9D001718  AC625800   SW V0, 22528(V1)
84:                      SPI1CONbits.FRMSYNC=1; // synchronisation esclave
9D00171C  3C03BF80   LUI V1, -16512
9D001720  8C625800   LW V0, 22528(V1)
9D001724  24040001   ADDIU A0, ZERO, 1
9D001728  7C82F784   INS V0, A0, 30, 1
9D00172C  AC625800   SW V0, 22528(V1)
85:                      SPI1CONbits.MSTEN=1; // SPI maître
9D001730  3C03BF80   LUI V1, -16512
9D001734  8C625800   LW V0, 22528(V1)
9D001738  24040001   ADDIU A0, ZERO, 1
9D00173C  7C822944   INS V0, A0, 5, 1
9D001740  AC625800   SW V0, 22528(V1)
86:                     // SPI1CONbits.SPIFE=1; // synchronisation sur clock premier bit.
87:                      SPI1CONbits.MODE32=1; // mode 32 bits
9D001744  3C03BF80   LUI V1, -16512
9D001748  8C625800   LW V0, 22528(V1)
9D00174C  24040001   ADDIU A0, ZERO, 1
9D001750  7C825AC4   INS V0, A0, 11, 1
9D001754  AC625800   SW V0, 22528(V1)
88:                      SPI1CONbits.STXISEL=1; // interruption sur TBE
9D001758  3C03BF80   LUI V1, -16512
9D00175C  8C625800   LW V0, 22528(V1)
9D001760  24040001   ADDIU A0, ZERO, 1
9D001764  7C821884   INS V0, A0, 2, 2
9D001768  AC625800   SW V0, 22528(V1)
89:                      SpiChnSetBitRate(SPI_CHANNEL1, PBCLK, BITCLK);
9D00176C  24040001   ADDIU A0, ZERO, 1
9D001770  3C02023C   LUI V0, 572
9D001774  34453460   ORI A1, V0, 13408
9D001778  3C02005D   LUI V0, 93
9D00177C  3446E676   ORI A2, V0, -6538
9D001780  0F4007DB   JAL SpiChnSetBitRate
9D001784  00000000   NOP
90:                      SPI1CONbits.ON=1;
9D001788  3C03BF80   LUI V1, -16512
9D00178C  8C625800   LW V0, 22528(V1)
9D001790  24040001   ADDIU A0, ZERO, 1
9D001794  7C827BC4   INS V0, A0, 15, 1
9D001798  AC625800   SW V0, 22528(V1)
91:                  }//init_video()
9D00179C  03C0E821   ADDU SP, S8, ZERO
9D0017A0  8FBF001C   LW RA, 28(SP)
9D0017A4  8FBE0018   LW S8, 24(SP)
9D0017A8  27BD0020   ADDIU SP, SP, 32
9D0017AC  03E00008   JR RA
9D0017B0  00000000   NOP
92:                  
93:                  
94:                  #define DLY 10
95:                  void __ISR(_TIMER_2_VECTOR,IPL7SRS) tmr2_isr(void){
9D0017B4  415DE800   RDPGPR SP, SP
9D0017B8  401A7000   MFC0 K0, EPC
9D0017BC  401B6000   MFC0 K1, Status
9D0017C0  27BDFFD8   ADDIU SP, SP, -40
9D0017C4  AFBB0024   SW K1, 36(SP)
9D0017C8  7C1B7844   INS K1, ZERO, 1, 15
9D0017CC  377B1C00   ORI K1, K1, 7168
9D0017D0  409B6000   MTC0 K1, Status
9D0017D4  AFBF0014   SW RA, 20(SP)
9D0017D8  AFBE0010   SW S8, 16(SP)
9D0017DC  00001012   MFLO V0, 0
9D0017E0  AFA2001C   SW V0, 28(SP)
9D0017E4  00001810   MFHI V1, 0
9D0017E8  AFA30018   SW V1, 24(SP)
9D0017EC  03A0F021   ADDU S8, SP, ZERO
96:                      _disable_video_out();
9D0017F0  3C02BF80   LUI V0, -16512
9D0017F4  34038000   ORI V1, ZERO, -32768
9D0017F8  AC435804   SW V1, 22532(V0)
97:                      ln_cnt++;
9D0017FC  8F828028   LW V0, -32728(GP)
9D001800  24420001   ADDIU V0, V0, 1
9D001804  AF828028   SW V0, -32728(GP)
98:                      switch (ln_cnt){
9D001808  8F828028   LW V0, -32728(GP)
9D00180C  2403001A   ADDIU V1, ZERO, 26
9D001810  10430021   BEQ V0, V1, 0x9D001898
9D001814  00000000   NOP
9D001818  2C43001B   SLTIU V1, V0, 27
9D00181C  10600009   BEQ V1, ZERO, 0x9D001844
9D001820  00000000   NOP
9D001824  24030001   ADDIU V1, ZERO, 1
9D001828  1043000E   BEQ V0, V1, 0x9D001864
9D00182C  00000000   NOP
9D001830  24030004   ADDIU V1, ZERO, 4
9D001834  10430010   BEQ V0, V1, 0x9D001878
9D001838  00000000   NOP
9D00183C  0B400630   J 0x9D0018C0
9D001840  00000000   NOP
9D001844  24030101   ADDIU V1, ZERO, 257
9D001848  1043001A   BEQ V0, V1, 0x9D0018B4
9D00184C  00000000   NOP
9D001850  24030106   ADDIU V1, ZERO, 262
9D001854  1043000D   BEQ V0, V1, 0x9D00188C
9D001858  00000000   NOP
9D00185C  0B400630   J 0x9D0018C0
9D001860  00000000   NOP
99:                          case 1:  // début vsync
100:                             OC2R=PWM_PERIOD-HSYNC;
9D001864  3C02BF80   LUI V0, -16512
9D001868  2403089C   ADDIU V1, ZERO, 2204
9D00186C  AC433210   SW V1, 12816(V0)
101:                             break;
9D001870  0B400645   J 0x9D001914
9D001874  00000000   NOP
102:                         case 4: // fin vsync
103:                             OC2R=HSYNC;
9D001878  3C02BF80   LUI V0, -16512
9D00187C  240300B0   ADDIU V1, ZERO, 176
9D001880  AC433210   SW V1, 12816(V0)
104:                             break;
9D001884  0B400645   J 0x9D001914
9D001888  00000000   NOP
105:                         case 262:  //fin du frame
106:                             ln_cnt=0;
9D00188C  AF808028   SW ZERO, -32728(GP)
107:                             break;
9D001890  0B400645   J 0x9D001914
9D001894  00000000   NOP
108:                   
109:                         case FIRST_LINE-1:
110:                             video=1;
9D001898  24020001   ADDIU V0, ZERO, 1
9D00189C  AF828024   SW V0, -32732(GP)
111:                             DmaSrc=(void*)&video_bmp[0];
9D0018A0  3C02A000   LUI V0, -24576
9D0018A4  2442001C   ADDIU V0, V0, 28
9D0018A8  AF82801C   SW V0, -32740(GP)
112:                             break;
9D0018AC  0B400645   J 0x9D001914
9D0018B0  00000000   NOP
113:                         case LAST_LINE+1:
114:                             video=0;
9D0018B4  AF808024   SW ZERO, -32732(GP)
115:                             break;
9D0018B8  0B400645   J 0x9D001914
9D0018BC  00000000   NOP
116:                         default:
117:                             if (video){
9D0018C0  8F828024   LW V0, -32732(GP)
9D0018C4  10400013   BEQ V0, ZERO, 0x9D001914
9D0018C8  00000000   NOP
118:                                 _enable_video_out();
9D0018CC  3C02BF80   LUI V0, -16512
9D0018D0  34038000   ORI V1, ZERO, -32768
9D0018D4  AC435808   SW V1, 22536(V0)
119:                                 //SPI1BUF=0;
120:                                 IFS1bits.SPI1TXIF=1;
9D0018D8  3C03BF88   LUI V1, -16504
9D0018DC  8C621040   LW V0, 4160(V1)
9D0018E0  24040001   ADDIU A0, ZERO, 1
9D0018E4  7C823184   INS V0, A0, 6, 1
9D0018E8  AC621040   SW V0, 4160(V1)
121:                                 DCH0SSA=KVA_TO_PA((void *)DmaSrc);
9D0018EC  8F82801C   LW V0, -32740(GP)
9D0018F0  7C43E000   EXT V1, V0, 0, 29
9D0018F4  3C02BF88   LUI V0, -16504
9D0018F8  AC433090   SW V1, 12432(V0)
122:                                 DmaSrc +=HRES/32;
9D0018FC  8F82801C   LW V0, -32740(GP)
9D001900  24420028   ADDIU V0, V0, 40
9D001904  AF82801C   SW V0, -32740(GP)
123:                                 DmaChnEnable(0);
9D001908  00002021   ADDU A0, ZERO, ZERO
9D00190C  0F4008B6   JAL DmaChnEnable
9D001910  00000000   NOP
124:                             }
125:                     }//switch (ln_cnt)
126:                     mT2ClearIntFlag();
9D001914  3C02BF88   LUI V0, -16504
9D001918  24030200   ADDIU V1, ZERO, 512
9D00191C  AC431034   SW V1, 4148(V0)
127:                 }//tmr2_isr()
9D001920  03C0E821   ADDU SP, S8, ZERO
9D001924  8FA2001C   LW V0, 28(SP)
9D001928  00400013   MTLO V0, 0
9D00192C  8FA30018   LW V1, 24(SP)
9D001930  00600011   MTHI V1, 0
9D001934  8FBF0014   LW RA, 20(SP)
9D001938  8FBE0010   LW S8, 16(SP)
9D00193C  8FBB0024   LW K1, 36(SP)
9D001940  27BD0028   ADDIU SP, SP, 40
9D001944  41DDE800   WRPGPR SP, SP
9D001948  409B6000   MTC0 K1, Status
9D00194C  42000018   ERET
128:                 
---  C:/Users/Jacques/Documents/GitHub/VPC-32.X/hardware/HardwareProfile.c  -----------------------------
1:                   /*
2:                    * File:   HardwareProfile.h
3:                    * Author: Jacques
4:                    * Description: configuration hardware spécifique, assignation des périphériques
5:                    *     UART2 assigné à PB10,PB11
6:                    * Created on 17 avril 2013, 14:41
7:                    *
8:                    */
9:                   
10:                  #include "HardwareProfile.h"
11:                  #include <plib.h>
12:                  
13:                  void HardwareInit(){
9D0010C8  27BDFFA8   ADDIU SP, SP, -88
9D0010CC  AFBF0054   SW RA, 84(SP)
9D0010D0  AFBE0050   SW S8, 80(SP)
9D0010D4  03A0F021   ADDU S8, SP, ZERO
9D0010D8  3C02023C   LUI V0, 572
9D0010DC  34423460   ORI V0, V0, 13408
9D0010E0  AFC20010   SW V0, 16(S8)
9D0010E4  24020005   ADDIU V0, ZERO, 5
9D0010E8  AFC20014   SW V0, 20(S8)
14:                      SYSTEMConfig(mGetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
15:                      // configure coretimer pour le sys_tick
16:                     OpenCoreTimer(CORE_TICK_RATE);
9D0012F0  2404493E   ADDIU A0, ZERO, 18750
9D0012F4  0F4008D5   JAL OpenCoreTimer
9D0012F8  00000000   NOP
17:                     mConfigIntCoreTimer((CT_INT_ON | CT_INT_PRIOR_2 | CT_INT_SUB_PRIOR_0));
9D0012FC  3C02BF88   LUI V0, -16504
9D001300  24030001   ADDIU V1, ZERO, 1
9D001304  AC431034   SW V1, 4148(V0)
9D001308  3C02BF88   LUI V0, -16504
9D00130C  2403001C   ADDIU V1, ZERO, 28
9D001310  AC431094   SW V1, 4244(V0)
9D001314  3C02BF88   LUI V0, -16504
9D001318  24030008   ADDIU V1, ZERO, 8
9D00131C  AC431098   SW V1, 4248(V0)
9D001320  3C02BF88   LUI V0, -16504
9D001324  24030003   ADDIU V1, ZERO, 3
9D001328  AC431094   SW V1, 4244(V0)
9D00132C  3C02BF88   LUI V0, -16504
9D001330  AC401098   SW ZERO, 4248(V0)
9D001334  3C02BF88   LUI V0, -16504
9D001338  24030001   ADDIU V1, ZERO, 1
9D00133C  AC431064   SW V1, 4196(V0)
9D001340  3C02BF88   LUI V0, -16504
9D001344  24030001   ADDIU V1, ZERO, 1
9D001348  AC431068   SW V1, 4200(V0)
18:                     INTEnableSystemMultiVectoredInt();
9D00134C  0F400840   JAL INTEnableSystemMultiVectoredInt
9D001350  00000000   NOP
19:                  
20:                      // configuration PB10 sortie et PB11 entrée
21:                     mPORTBSetBits(TX); // mettre à Vdd pour ne pas généré un faux start bit.
9D001354  3C02BF88   LUI V0, -16504
9D001358  24030400   ADDIU V1, ZERO, 1024
9D00135C  AC436138   SW V1, 24888(V0)
22:                     mPORTBSetPinsDigitalOut(TX);      // sortie PB10(Tx), transmission UART2
9D001360  3C02BF88   LUI V0, -16504
9D001364  24030400   ADDIU V1, ZERO, 1024
9D001368  AC436114   SW V1, 24852(V0)
9D00136C  3C02BF88   LUI V0, -16504
9D001370  24030400   ADDIU V1, ZERO, 1024
9D001374  AC436104   SW V1, 24836(V0)
23:                     mPORTBSetPinsDigitalIn (RX);      // entrée PB11(Rx), réception UART2
9D001378  3C02BF88   LUI V0, -16504
9D00137C  24030800   ADDIU V1, ZERO, 2048
9D001380  AC436118   SW V1, 24856(V0)
9D001384  3C02BF88   LUI V0, -16504
9D001388  24030800   ADDIU V1, ZERO, 2048
9D00138C  AC436104   SW V1, 24836(V0)
24:                     // assignation du périphérique UART2 sur PB10 et PB11
25:                     // l'information se trouve dans pps.h
26:                     PPSUnLock;                     // déverrouillage configuration assignation périphérique
27:                     PPSOutput(4, RPB10, U2TX);  // assignation U2TX sur PB10, (groupe, pin, fonction)
9D001390  3C03BF81   LUI V1, -16511
9D001394  8C62FB54   LW V0, -1196(V1)
9D001398  24040002   ADDIU A0, ZERO, 2
9D00139C  7C821804   INS V0, A0, 0, 4
9D0013A0  AC62FB54   SW V0, -1196(V1)
28:                     PPSInput (2, U2RX, RPB11);  // assignation U2RX sur PB11, (groupe, fonction, pin)
9D0013A4  3C03BF81   LUI V1, -16511
9D0013A8  8C62FA58   LW V0, -1448(V1)
9D0013AC  24040003   ADDIU A0, ZERO, 3
9D0013B0  7C821804   INS V0, A0, 0, 4
9D0013B4  AC62FA58   SW V0, -1448(V1)
29:                     PPSLock;                       // reverrouille pour éviter assignation accidentelle.
30:                  }
9D0013B8  03C0E821   ADDU SP, S8, ZERO
9D0013BC  8FBF0054   LW RA, 84(SP)
9D0013C0  8FBE0050   LW S8, 80(SP)
9D0013C4  27BD0058   ADDIU SP, SP, 88
9D0013C8  03E00008   JR RA
9D0013CC  00000000   NOP
31:                  
32:                  
33:                    //déclaration du gestionnaire d'interruption
34:                     void __ISR(_CORE_TIMER_VECTOR, ipl2auto) CoreTimerHandler(void){
9D0013D0  415DE800   RDPGPR SP, SP
9D0013D4  401B7000   MFC0 K1, EPC
9D0013D8  401A6002   MFC0 K0, SRSCtl
9D0013DC  27BDFF88   ADDIU SP, SP, -120
9D0013E0  AFBB0074   SW K1, 116(SP)
9D0013E4  401B6000   MFC0 K1, Status
9D0013E8  AFBA0070   SW K0, 112(SP)
9D0013EC  AFBB006C   SW K1, 108(SP)
9D0013F0  7C1B7844   INS K1, ZERO, 1, 15
9D0013F4  377B0800   ORI K1, K1, 2048
9D0013F8  409B6000   MTC0 K1, Status
9D0013FC  AFA3001C   SW V1, 28(SP)
9D001400  AFA20018   SW V0, 24(SP)
9D001404  8FA30070   LW V1, 112(SP)
9D001408  3063000F   ANDI V1, V1, 15
9D00140C  14600012   BNE V1, ZERO, 0x9D001458
9D001410  00000000   NOP
9D001414  AFBF005C   SW RA, 92(SP)
9D001418  AFBE0058   SW S8, 88(SP)
9D00141C  AFB90054   SW T9, 84(SP)
9D001420  AFB80050   SW T8, 80(SP)
9D001424  AFAF004C   SW T7, 76(SP)
9D001428  AFAE0048   SW T6, 72(SP)
9D00142C  AFAD0044   SW T5, 68(SP)
9D001430  AFAC0040   SW T4, 64(SP)
9D001434  AFAB003C   SW T3, 60(SP)
9D001438  AFAA0038   SW T2, 56(SP)
9D00143C  AFA90034   SW T1, 52(SP)
9D001440  AFA80030   SW T0, 48(SP)
9D001444  AFA7002C   SW A3, 44(SP)
9D001448  AFA60028   SW A2, 40(SP)
9D00144C  AFA50024   SW A1, 36(SP)
9D001450  AFA40020   SW A0, 32(SP)
9D001454  AFA10014   SW AT, 20(SP)
9D001458  00001012   MFLO V0, 0
9D00145C  AFA20064   SW V0, 100(SP)
9D001460  00001810   MFHI V1, 0
9D001464  AFA30060   SW V1, 96(SP)
9D001468  03A0F021   ADDU S8, SP, ZERO
35:                         sys_tick++;
9D00146C  8F828020   LW V0, -32736(GP)
9D001470  24420001   ADDIU V0, V0, 1
9D001474  AF828020   SW V0, -32736(GP)
36:                         UpdateCoreTimer(CORE_TICK_RATE);
9D001478  2404493E   ADDIU A0, ZERO, 18750
9D00147C  0F4008D1   JAL UpdateCoreTimer
9D001480  00000000   NOP
37:                         mCTClearIntFlag();
9D001484  3C02BF88   LUI V0, -16504
9D001488  24030001   ADDIU V1, ZERO, 1
9D00148C  AC431034   SW V1, 4148(V0)
38:                     };
9D001490  03C0E821   ADDU SP, S8, ZERO
9D001494  8FA20064   LW V0, 100(SP)
9D001498  00400013   MTLO V0, 0
9D00149C  8FA30060   LW V1, 96(SP)
9D0014A0  00600011   MTHI V1, 0
9D0014A4  8FA20070   LW V0, 112(SP)
9D0014A8  3042000F   ANDI V0, V0, 15
9D0014AC  14400014   BNE V0, ZERO, 0x9D001500
9D0014B0  00000000   NOP
9D0014B4  8FBF005C   LW RA, 92(SP)
9D0014B8  8FBE0058   LW S8, 88(SP)
9D0014BC  8FB90054   LW T9, 84(SP)
9D0014C0  8FB80050   LW T8, 80(SP)
9D0014C4  8FAF004C   LW T7, 76(SP)
9D0014C8  8FAE0048   LW T6, 72(SP)
9D0014CC  8FAD0044   LW T5, 68(SP)
9D0014D0  8FAC0040   LW T4, 64(SP)
9D0014D4  8FAB003C   LW T3, 60(SP)
9D0014D8  8FAA0038   LW T2, 56(SP)
9D0014DC  8FA90034   LW T1, 52(SP)
9D0014E0  8FA80030   LW T0, 48(SP)
9D0014E4  8FA7002C   LW A3, 44(SP)
9D0014E8  8FA60028   LW A2, 40(SP)
9D0014EC  8FA50024   LW A1, 36(SP)
9D0014F0  8FA40020   LW A0, 32(SP)
9D0014F4  8FA3001C   LW V1, 28(SP)
9D0014F8  8FA20018   LW V0, 24(SP)
9D0014FC  8FA10014   LW AT, 20(SP)
9D001500  41606000   DI ZERO
9D001504  000000C0   EHB
9D001508  8FBA0074   LW K0, 116(SP)
9D00150C  8FBB006C   LW K1, 108(SP)
9D001510  409A7000   MTC0 K0, EPC
9D001514  8FBA0070   LW K0, 112(SP)
9D001518  27BD0078   ADDIU SP, SP, 120
9D00151C  409A6002   MTC0 K0, SRSCtl
9D001520  41DDE800   WRPGPR SP, SP
9D001524  409B6000   MTC0 K1, Status
9D001528  42000018   ERET
