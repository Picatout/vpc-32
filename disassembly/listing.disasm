Disassembly Listing for vpc-32
Generated From:
/home/jacques/MPLABXProjects/vpc-32/dist/default/production/vpc-32.production.elf
2015-09-01 21:17:20

---  /opt/microchip/xc32/v1.33/pic32mx/include/peripheral/uart.h  ---------------------------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file, 
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.  
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                  #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  // Section: Constants & Data Types
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  
84:                  //DOM-IGNORE-BEGIN
85:                  /****
86:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
87:                         the device file.  Also the UART register set could also be placed there
88:                  *****/
89:                  typedef struct
90:                  {
91:                  	volatile UINT	reg;
92:                  	volatile UINT	clr;
93:                  	volatile UINT	set;
94:                  	volatile UINT	inv;
95:                  }REG_SET;
96:                  
97:                  typedef struct
98:                  {
99:                  	volatile REG_SET	mode;
100:                 	volatile REG_SET	sta;
101:                 	volatile REG_SET    tx;
102:                 	volatile REG_SET	rx;
103:                 	volatile REG_SET	brg;
104:                 }UART_REGS;
105:                 
106:                 extern UART_REGS * const uartReg[];
107:                 //DOM-IGNORE-END
108:                 
109:                 // *****************************************************************************
110:                 /* UART Module
111:                 
112:                   Summary:
113:                     UART modules supported.
114:                 
115:                   Description:
116:                     This enumeration identifies the available UART modules.
117:                 */
118:                 
119:                 typedef enum
120:                 {
121:                 #if defined _UART1
122:                     // UART1 Module ID.
123:                     UART1 = 0,
124:                 #endif
125:                 #if defined _UART2
126:                     // UART2 Module ID.
127:                     UART2,
128:                 #endif
129:                 #ifdef _UART3
130:                     // UART3 Module ID.
131:                     UART3,
132:                 #endif
133:                 #ifdef _UART4
134:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
135:                     UART4,
136:                 #endif
137:                 #ifdef _UART5
138:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
139:                     UART5,
140:                 #endif
141:                 #ifdef _UART6
142:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
143:                     UART6,
144:                 #endif
145:                     // Number of available UART modules.
146:                     UART_NUMBER_OF_MODULES
147:                 
148:                 } UART_MODULE;
149:                 
150:                 
151:                 // *****************************************************************************
152:                 /* UART Enable Modes
153:                 
154:                   Summary:
155:                     Operating modes of UART.
156:                 
157:                   Description:
158:                     This enumeration defines the supported modes in which the UART may be
159:                     enabled or disbled.
160:                 
161:                   Remarks:
162:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
163:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
164:                     has been pre-loaded with data.
165:                 
166:                     The caller should not rely on the specific numbers assigned to any of these
167:                     values as they may change from one processor to the next.
168:                 */
169:                 
170:                 typedef enum
171:                 {
172:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
173:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
174:                 
175:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
176:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
177:                 
178:                 
179:                     // UART Module, receiver and transmitter functionality is not.
180:                     // enabled or disabled
181:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
182:                 
183:                     // UART Module receiver.
184:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
185:                 
186:                     // UART Module transmitter.
187:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
188:                 
189:                 
190:                 } UART_ENABLE_MODE;
191:                 
192:                 // *****************************************************************************
193:                 /* UART Enable Helper Macro
194:                 
195:                   Summary:
196:                     Macro for enabling module operating modes.
197:                 
198:                   Description:
199:                     This macro creates the proper flags for enabling operating modes of the UART module.
200:                 
201:                   Example:
202:                     <code>
203:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
204:                     </code>
205:                 
206:                   Remarks:
207:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
208:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
209:                     has been pre-loaded with data.
210:                 */
211:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
212:                 
213:                 // *****************************************************************************
214:                 /* UART Disable Helper Macro
215:                 
216:                   Summary:
217:                     Macro for disabling module operating modes.
218:                 
219:                   Description:
220:                     This macro creates the proper flags for disabling operating modes of the UART module.
221:                 
222:                   Example:
223:                     <code>
224:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
225:                     </code>
226:                 
227:                 */
228:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
229:                 
230:                 // *****************************************************************************
231:                 /* UART Configuration Settings
232:                 
233:                   Summary:
234:                     Supported configuration flags for the UART module.
235:                 
236:                   Description:
237:                     This enumeration defines the various configuration options for the UART
238:                     module.  These values can be OR'd together to create a configuration mask
239:                     passed to the UARTConfigure routine.
240:                 
241:                   Remarks:
242:                     Several of the configuration options are mutually exclusive:
243:                     * Only one of the "ENABLE_PINS" modes can be used at a time
244:                     * Only one of the "RTS_WHEN" modes can be used at a time
245:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
246:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
247:                 
248:                     The caller should not rely on the specific numbers assigned to any of these
249:                     values as they may change from one processor ot the next.
250:                 */
251:                 
252:                 typedef enum
253:                 {
254:                     // Enables high-speed range of the UART (see UARTSetBitRate).
255:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
256:                 
257:                     // Inverts polarity of data interpretation the received (RX) pin.
258:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
259:                 
260:                     // Enables UART TX-to-RX Loop-back mode.
261:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
262:                 
263:                     // Enables Wake-up of the part when a start bit is received.
264:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
265:                 
266:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
267:                     // cannot be used in bit-clock/IrDA mode).
268:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
269:                 
270:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
271:                     // cannot be used in CTS/RTS mode).
272:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
273:                 
274:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
275:                     // be used in RTS-Only mode).
276:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
277:                 
278:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
279:                     // the default mode and this parameter can be left out if it is desired).
280:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
281:                 
282:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
283:                     // is not full (i.e., the UART is ready to receive data).  This is also known
284:                     // as "RTS Flow-Control Mode".
285:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
286:                 
287:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
288:                     // is not empty (i.e., when the UART has data ready to send).  This is also
289:                     // known as "RTS Simplex Mode".
290:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
291:                 
292:                     // Enable the IrDA encoder/decoder.
293:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
294:                 
295:                     // Enables stopping of the UART operation to save power when the core has
296:                     // been put in idle mode.
297:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
298:                 
299:                     // Inverts the polarity of data sent on the transmit (TX) pin.
300:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
301:                 
302:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
303:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
304:                     // Note:  The address must still be set using UARTEnableAddressDetect
305:                     // to support IEEE-485 protocol.
306:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
307:                 
308:                 } UART_CONFIGURATION;
309:                 
310:                 
311:                 // *****************************************************************************
312:                 /* UART FIFO Modes
313:                 
314:                   Summary:
315:                     Supported FIFO modes for the UART module.
316:                 
317:                   Description:
318:                     This enumeration defines supported FIFO modes that determine when the Tx
319:                     and Rx interrupts will occur.
320:                 
321:                   Remarks:
322:                     These modes consist of two sets of mutially exclusive modes:
323:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
324:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
325:                 
326:                     The caller should not rely on the specific numbers assigned to any of these
327:                     values as they may change from one processor ot the next.
328:                 
329:                 */
330:                 
331:                 typedef enum
332:                 {
333:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
334:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
337:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
338:                 
339:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
340:                     // full (i.e. there is space available for more data)  This is the default.
341:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
342:                 
343:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
344:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
345:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
346:                 
347:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
348:                     // (three-quarter) full.
349:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
350:                 
351:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
352:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
353:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
354:                 
355:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
356:                     // data.
357:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
358:                 
359:                 } UART_FIFO_MODE;
360:                 
361:                 
362:                 // *****************************************************************************
363:                 /* UART Line Control Mode
364:                 
365:                   Summary:
366:                     UART line control mode.
367:                 
368:                   Description:
369:                     This data type defines the supported line control modes for the UART.
370:                 
371:                   Remarks:
372:                     Some of the line-control options are mutually exclusive:
373:                     * Only one of the "DATA_SIZE" options can be used at a time
374:                     * Only one of the "PARITY" options can be used at a time
375:                     * Only one of the "STOP_BITS" options can be used at a time
376:                 
377:                     The caller should not rely on the specific numbers assigned to any of these
378:                     values as they may change from one processor ot the next.
379:                 */
380:                 
381:                 typedef enum
382:                 {
383:                     // Sets the data transfer size to 8-bits per frame.
384:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
385:                 
386:                     // Sets the data transfer size to 9-bits per frame.
387:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
388:                 
389:                     // Enables parity bit generation for odd parity.
390:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
391:                 
392:                     // Enables parity bit generation for even parity.
393:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
394:                 
395:                     // Disables parity bit generation.
396:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
397:                 
398:                     // Enables generation of 2 stop bits per frame.
399:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
400:                 
401:                     // Enables generation of 1 stop bit per frame (default).
402:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
403:                 
404:                 } UART_LINE_CONTROL_MODE;
405:                 
406:                 
407:                 // *****************************************************************************
408:                 /* UART Line Status Flags
409:                 
410:                   Summary:
411:                     UART line-status bitmask flags.
412:                 
413:                   Description:
414:                     This enumeration defines the UART line-status bits.  These values are
415:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
416:                 
417:                   Remarks:
418:                     The caller should not rely on the specific numbers assigned to any of these
419:                     values as they may change from one processor ot the next.
420:                 */
421:                 
422:                 typedef enum
423:                 {
424:                     // The transmitter is able to accept data to transmit.
425:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
426:                 
427:                     // The transmitter is empty (no data is available to transmit).
428:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
429:                 
430:                     // The receiver is currently idle.
431:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
432:                 
433:                     // A received data parity error was detected.
434:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
435:                 
436:                     // Data was received that violated the framing protocol (the data word did
437:                     // not start or stop at the appropriate place).  Note:  A break condition
438:                     // will always indicate a framing error.
439:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
440:                 
441:                     // The UART has received more data than it can buffer.  Data has been lost.
442:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
443:                 
444:                     // UART data has been received and is avaiable in the FIFO.
445:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
446:                 
447:                 } UART_LINE_STATUS;
448:                 
449:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
450:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
451:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
452:                 
453:                 
454:                 
455:                 // *****************************************************************************
456:                 /* UART Data
457:                 
458:                   Summary:
459:                     UART data.
460:                 
461:                   Description:
462:                     This data type defines the supported data sizes for the UART.
463:                 */
464:                 
465:                 typedef union
466:                 {
467:                     // 8-bit data
468:                     struct
469:                     {
470:                         UINT16  data8bit    : 8;
471:                     };
472:                 
473:                     // 9-bit data
474:                     struct
475:                     {
476:                         UINT16  data9bit    : 9;
477:                     };
478:                 
479:                     UINT16 __data;
480:                 } UART_DATA;
481:                 
482:                 
483:                 // *****************************************************************************
484:                 // *****************************************************************************
485:                 // Section: UART Peripheral Library Interface Routines
486:                 // *****************************************************************************
487:                 // *****************************************************************************
488:                 
489:                 
490:                 /*******************************************************************************
491:                   Function:
492:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
493:                 
494:                   Summary:
495:                     Enables or disables the given UART module in the desired mode.
496:                 
497:                   Description:
498:                     This routine enables or disables the given UART module in the desired mode.
499:                 
500:                   Precondition:
501:                     The UART module should be appropriately configured before being enabled.
502:                 
503:                   Parameters:
504:                     id    - Identifies the desired UART module.
505:                 
506:                     mode  - Identifies the desired mode of UART operation.
507:                 
508:                   Returns:
509:                     None
510:                 
511:                   Example:
512:                     <code>
513:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
514:                     </code>
515:                 
516:                   Remarks:
517:                     Enabling UART transmissions will immediately cause a TX interrupt to
518:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
519:                     was pre-loaded with data.
520:                   *****************************************************************************/
521:                 
522:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
523:                 
524:                 
525:                 /*******************************************************************************
526:                   Function:
527:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
528:                 
529:                   Summary:
530:                     UART module configuration routine.
531:                 
532:                   Description:
533:                     This routine allows the caller to configure various features of the UART
534:                     module for desired operation.
535:                 
536:                   Precondition:
537:                     None
538:                 
539:                   Parameters:
540:                     id      - Identifies the desired UART module.
541:                 
542:                     flags   - Bit-wise OR of the desired module configuration settings.
543:                 
544:                   Returns:
545:                     None
546:                 
547:                   Example:
548:                     <code>
549:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
550:                     </code>
551:                 
552:                   Remarks:
553:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
554:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
555:                     of these values will result in a value that is not explicitly defined in
556:                     the enumeration.
557:                   *****************************************************************************/
558:                 
559:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
560:                 
561:                 
562:                 /*******************************************************************************
563:                   Function:
564:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
565:                 
566:                   Summary:
567:                     Controls UART module TX and RX FIFO operation.
568:                 
569:                   Description:
570:                     This routine allows the caller to configure when interrupts occur relative
571:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
572:                     or empty the FIFOs are).
573:                 
574:                   Precondition:
575:                     None
576:                 
577:                   Parameters:
578:                     id      - Identifies the desired UART module.
579:                 
580:                     mode    - Bit-wise OR of the desired FIFO mode values.
581:                 
582:                   Returns:
583:                     None
584:                 
585:                   Example:
586:                     <code>
587:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
588:                     </code>
589:                 
590:                   Remarks:
591:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
592:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
593:                     of these values will result in a value that is not explicitly defined in
594:                     the enumeration.
595:                   *****************************************************************************/
596:                 
597:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
598:                 
599:                 
600:                 /*******************************************************************************
601:                   Function:
602:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
603:                 
604:                   Summary:
605:                     Routine to set the UART module's desired data data rate.
606:                 
607:                   Description:
608:                     This routine allows the caller to set the desired data rate for the UART.
609:                 
610:                   Precondition:
611:                     The source clock's frequency must be operating at the frequency passed in the
612:                     "sourceClock" parameter.
613:                 
614:                   Parameters:
615:                     id          - Identifies the desired UART module.
616:                 
617:                     sourceClock - Frequency (Hz) of the source clock being provided to the
618:                                   UART module.
619:                 
620:                     dataRate     - Desired data rate (bits per second).
621:                 
622:                   Returns:
623:                     Actual bit rate selected
624:                 
625:                   Example:
626:                     <code>
627:                 	#define PERIPHERAL_CLOCK    10000000
628:                 	#define DESIRED_DATA_RATE   19200
629:                 	
630:                 	UINT32    actualDataRate;
631:                 
632:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
633:                     </code>
634:                 
635:                   Remarks:
636:                     Actual data rate selected may be slightly different than the data rate
637:                     requested due to truncation error.
638:                 
639:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
640:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
641:                     the maximum data rate is sourceClock/4.
642:                   *****************************************************************************/
643:                 
644:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
645:                 
646:                 
647:                 /*******************************************************************************
648:                   Function:
649:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
650:                 
651:                   Summary:
652:                     Routine to get the UART module's current data data rate.
653:                 
654:                   Description:
655:                     This routine allows the caller to get the current data rate for the UART module.
656:                 
657:                   Precondition:
658:                     The source clock's frequency must be operating at the frequency passed in the
659:                     "sourceClock" parameter.
660:                 
661:                   Parameters:
662:                     id          - Identifies the desired UART module.
663:                 
664:                     sourceClock - Frequency (Hz) of the source clock being provided to the
665:                                   UART module.
666:                 
667:                   Returns:
668:                     The UART's current data rate (bits per second).
669:                 
670:                   Example:
671:                     <code>
672:                 	#define PERIPHERAL_CLOCK    10000000
673:                 	
674:                 	UINT32    currentDataRate;
675:                 
676:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
677:                     </code>
678:                 
679:                   Remarks:
680:                     The current (actual) data rate returned may be slightly different than bit
681:                     rate requested due to truncation error.
682:                   *****************************************************************************/
683:                 
684:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
685:                 
686:                 
687:                 /*******************************************************************************
688:                   Function:
689:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
690:                 
691:                   Summary:
692:                     Routine to set the UART module's desired line control parameters.
693:                 
694:                   Description:
695:                     This routine allows the caller to select the desired size of the UART data
696:                     frame, the generation of parity and framing parameters (collectively
697:                     referred to as the "line control" mode).
698:                 
699:                   Precondition:
700:                 
701:                   Parameters:
702:                     id      - Identifies the desired UART module.
703:                 
704:                     mode    - This is a bit-wise OR of the desired line control mode flags.
705:                 
706:                   Returns:
707:                     None
708:                 
709:                   Example:
710:                     <code>
711:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
712:                     </code>
713:                 
714:                   Remarks:
715:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
716:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
717:                     of these values will result in a value that is not explicitly defined in
718:                     the enumeration.
719:                   *****************************************************************************/
720:                 
721:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
722:                 
723:                 
724:                 /*******************************************************************************
725:                   Function:
726:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
727:                 
728:                   Summary:
729:                     Provides current UART line status.
730:                 
731:                   Description:
732:                     This routine allows the caller to get the current line status of the UART,
733:                     indicating the current state of the transmitter and receiver buffers, and
734:                     if any errors have occurred.
735:                 
736:                   Precondition:
737:                     None
738:                 
739:                   Parameters:
740:                     id      - Identifies the desired UART module.
741:                 
742:                   Returns:
743:                     A bit-wise OR of the current line status flags.
744:                 
745:                   Example:
746:                     <code>
747:                     UART_LINE_STATUS lineStatus;
748:                 	
749:                 	lineStatus = UARTGetLineStatus(UART1);
750:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
751:                     {
752:                         // Handle receiver error
753:                     }
754:                     </code>
755:                 
756:                   Remarks:
757:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
758:                     status flag.
759:                 
760:                     The receiver line status flags are only valid when data has been received
761:                     and for the data at the top of the RX FIFO.
762:                 
763:                     Note that the bitmask resulting from the bit-wise OR of these values will
764:                     result in a value that is not explicitly defined in the enumeration.
765:                   *****************************************************************************/
766:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
767:                 {
768:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
769:                 }
770:                 
771:                 
772:                 /*******************************************************************************
773:                   Function:
774:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
775:                 
776:                   Summary:
777:                     Routine to detect if the transmitter is ready to accept data to transmit.
778:                 
779:                   Description:
780:                     This routine determines if the transmitter is ready to accept more data to
781:                     be transmitted.
782:                 
783:                   Precondition:
784:                     The UART module should have been appropriately configured and enabled.
785:                 
786:                   Parameters:
787:                     id      - Identifies the desired UART module.
788:                 
789:                   Returns:
790:                     Boolean identifying whether or not the transmitter is ready:
791:                     * TRUE    - If the transmitter is ready to accept more data
792:                     * FALSE   - If the transmitter is not ready to accept more data
793:                 
794:                   Example:
795:                     <code>
796:                     unsigned char data;
797:                 	
798:                 	data = 'a';
799:                 	
800:                 	if (UARTTransmitterIsReady(UART1))
801:                     {
802:                         UARTSendDataByte(UART1, data);
803:                     }
804:                     </code>
805:                 
806:                   Remarks:
807:                   *****************************************************************************/
808:                 
809:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
810:                 {
811:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D01000C  00042080   SLL A0, A0, 2
9D010010  3C029D01   LUI V0, -25343
9D010014  24427E04   ADDIU V0, V0, 32260
9D010018  00822021   ADDU A0, A0, V0
9D01001C  8C830000   LW V1, 0(A0)
9D010020  8C620010   LW V0, 16(V1)
9D010024  30420200   ANDI V0, V0, 512
9D0100F4  3C029D01   LUI V0, -25343
9D0100F8  24427E04   ADDIU V0, V0, 32260
9D0100FC  00621021   ADDU V0, V1, V0
9D010100  8C430000   LW V1, 0(V0)
9D010104  8C620010   LW V0, 16(V1)
9D010108  30420200   ANDI V0, V0, 512
812:                 }
813:                 
814:                 
815:                 /*******************************************************************************
816:                   Function:
817:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
818:                 
819:                   Summary:
820:                     Routine to send a byte of data.
821:                 
822:                   Description:
823:                     This routine allows the caller to send a byte of data.
824:                 
825:                   Precondition:
826:                     The UART should have been appropriately configured.  The configuration must
827:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
828:                     have been ready, although not necessarily enabled yet.
829:                 
830:                   Parameters:
831:                     id      - Identifies the desired UART module.
832:                 
833:                     data    - Data byte to be sent.
834:                 
835:                   Returns:
836:                     None
837:                 
838:                   Example:
839:                     <code>
840:                 	unsigned char data;
841:                 	
842:                 	data = 'a';
843:                 	
844:                     if (UARTTransmitterIsReady(UART1))
845:                     {
846:                         UARTSendDataByte(UART1, data);
847:                     }
848:                     </code>
849:                 
850:                   Remarks:
851:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
852:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
853:                     data.
854:                   *****************************************************************************/
855:                 
856:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
857:                 {
858:                     uartReg[id]->tx.reg = data;
9D010030  30A500FF   ANDI A1, A1, 255
9D010034  AC650020   SW A1, 32(V1)
9D010118  30C600FF   ANDI A2, A2, 255
9D01011C  AC660020   SW A2, 32(V1)
859:                 }
860:                 
861:                 
862:                 /*******************************************************************************
863:                   Function:
864:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
865:                 
866:                   Summary:
867:                     Routine to send data through the UART.
868:                 
869:                   Description:
870:                     This routine allows the caller to send data of any permitted size through
871:                     the UART.
872:                 
873:                   Precondition:
874:                     The UART module should have been appropriately configured.  The configuration must
875:                     have been for desired data size.  The transmitter must have been ready,
876:                     although not necessarily enabled yet.
877:                 
878:                   Parameters:
879:                     id      - Identifies the desired UART module.
880:                 
881:                     data    - Data to be sent.
882:                 
883:                   Returns:
884:                     None
885:                 
886:                   Example:
887:                     <code>
888:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
889:                 	
890:                 	if (UARTTransmitterIsReady(UART1))
891:                     {
892:                         UARTSendData(UART1, data);
893:                     }
894:                     </code>
895:                 
896:                   Remarks:
897:                     Size of the data word size depends on the current configuration (see
898:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
899:                   *****************************************************************************/
900:                 
901:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
902:                 {
903:                     uartReg[id]->tx.reg = data.__data;
904:                 }
905:                 
906:                 /*******************************************************************************
907:                   Function:
908:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
909:                 
910:                   Summary:
911:                     Routine to detect if the UART module has finshed transmitting the most recent
912:                     data.
913:                 
914:                   Description:
915:                     This routine determines if the transmitter has finished sending all
916:                     available data.
917:                 
918:                   Preconditions:
919:                     The UART module should have been appropriately configured and enabled and data
920:                     sent to the UART TX buffer.
921:                 
922:                   Parameters:
923:                     id      - Identifies the desired UART module.
924:                 
925:                   Returns:
926:                     Boolean identifying if the transmission has completed:
927:                     * TRUE    - If the transmitter has completed sending the data
928:                     * FALSE   - If the transmitter is still busy sending the data
929:                 
930:                   Example:
931:                     <code>
932:                 	if (UARTTransmissionHasCompleted(UART1))
933:                     {
934:                         // Perform any tasks necessary when all data has been sent
935:                     }
936:                     </code>
937:                 
938:                   Remarks:
939:                   *****************************************************************************/
940:                 
941:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
942:                 {
943:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
9D01012C  00042080   SLL A0, A0, 2
9D010130  3C029D01   LUI V0, -25343
9D010134  24427E04   ADDIU V0, V0, 32260
9D010138  00822021   ADDU A0, A0, V0
9D01013C  8C830000   LW V1, 0(A0)
9D010140  8C620010   LW V0, 16(V1)
9D010144  30420100   ANDI V0, V0, 256
944:                 }
945:                 
946:                 
947:                 /*******************************************************************************
948:                   Function:
949:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
950:                 
951:                   Summary:
952:                     Routine to detect if the receiver has data available.
953:                 
954:                   Description:
955:                     This routine determines if the receiver has data available to be read.
956:                 
957:                   Precondition:
958:                     The UART module must have been configured appropriately and enabled. A complete
959:                     data frame must have been sent to the UART before it will return a TRUE.
960:                 
961:                   Parameters:
962:                     id      - Identifies the desired UART module.
963:                 
964:                   Returns:
965:                     Boolean identifying whether or not data is available:
966:                     * TRUE    - If the receiver has data available
967:                     * FALSE   - If the receiver does not have data availble
968:                 
969:                   Example:
970:                     <code>
971:                     UART_DATA data;
972:                 	
973:                 	if (UARTReceivedDataIsAvailable(UART1))
974:                     {
975:                         data = UARTGetData(UART1);
976:                     }
977:                     </code>
978:                 
979:                   Remarks:
980:                     This routine provides the same information as the UART_DATA_READY line
981:                     status flag.
982:                   *****************************************************************************/
983:                 
984:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
985:                 {
986:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
9D00FFD4  00042080   SLL A0, A0, 2
9D01005C  00048080   SLL S0, A0, 2
9D010060  3C029D01   LUI V0, -25343
9D010064  24427E04   ADDIU V0, V0, 32260
9D010068  02028021   ADDU S0, S0, V0
9D01006C  8E030000   LW V1, 0(S0)
9D010070  8C620010   LW V0, 16(V1)
9D010074  30420001   ANDI V0, V0, 1
9D010094  3C029D01   LUI V0, -25343
9D010098  24427E04   ADDIU V0, V0, 32260
9D0100A4  8C430010   LW V1, 16(V0)
9D0100A8  30630001   ANDI V1, V1, 1
9D010188  00041080   SLL V0, A0, 2
9D01018C  3C129D01   LUI S2, -25343
9D010190  26527E04   ADDIU S2, S2, 32260
9D010194  00529021   ADDU S2, V0, S2
9D0101A0  8C430010   LW V1, 16(V0)
9D0101A4  30630001   ANDI V1, V1, 1
9D010270  00042080   SLL A0, A0, 2
9D010274  3C029D01   LUI V0, -25343
9D010278  24427E04   ADDIU V0, V0, 32260
9D01027C  00822021   ADDU A0, A0, V0
9D010280  8C830000   LW V1, 0(A0)
9D010284  8C640010   LW A0, 16(V1)
9D010288  30840001   ANDI A0, A0, 1
987:                 }
988:                 
989:                 
990:                 /*******************************************************************************
991:                   Function:
992:                     BYTE UARTGetDataByte ( UART_MODULE id )
993:                 
994:                   Summary:
995:                     Routine to get a byte of data received by the UART.
996:                 
997:                   Description:
998:                     This routine allows the caller to read a byte of data received by the UART.
999:                 
1000:                  Precondition:
1001:                    The UART module must have been appropriately configured, the configuration must
1002:                    have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
1003:                    been enabled.  Also, a complete data frame must have been received by the UART.
1004:                
1005:                  Parameters:
1006:                    id      - Identifies the desired UART module.
1007:                
1008:                  Returns:
1009:                    A byte of data received by the UART.
1010:                
1011:                  Example:
1012:                    <code>
1013:                    unsigned char data;
1014:                	
1015:                	if (UARTReceivedDataIsAvailable(UART1))
1016:                    {
1017:                        data = UARTGetDataByte(UART1);
1018:                    }
1019:                    </code>
1020:                
1021:                  Remarks:
1022:                    This routine is optimized for receiving 8-bit data through the UART.
1023:                  *****************************************************************************/
1024:                
1025:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1026:                {
1027:                    return (BYTE)uartReg[id]->rx.reg;
9D00FFF8  8C620030   LW V0, 48(V1)
9D010080  8C620030   LW V0, 48(V1)
9D0100B4  8C420030   LW V0, 48(V0)
9D0101B0  8C450030   LW A1, 48(V0)
9D010294  8C630030   LW V1, 48(V1)
1028:                }
1029:                
1030:                
1031:                /*******************************************************************************
1032:                  Function:
1033:                    UART_DATA UARTGetData ( UART_MODULE id )
1034:                
1035:                  Summary:
1036:                    Routine to get data received by the UART.
1037:                
1038:                  Description:
1039:                    This routine allows the caller to read a data word received by the UART.
1040:                
1041:                  Precondition:
1042:                    The module must have been appropriately configured, the UART module must have been
1043:                    enabled, and a complete data frame must have been received by the UART.
1044:                
1045:                  Parameters:
1046:                    id      - Identifies the desired UART module.
1047:                
1048:                  Returns:
1049:                    Data received by the UART.
1050:                
1051:                  Example:
1052:                    <code>
1053:                    UART_DATA data;
1054:                	
1055:                	if (UARTReceivedDataIsAvailable(UART1))
1056:                    {
1057:                        data = UARTGetData(UART1);
1058:                    }
1059:                    </code>
1060:                
1061:                  Remarks:
1062:                    Size of the data word depends on the current configuration (see
1063:                    UARTSetLineControl).
1064:                  *****************************************************************************/
1065:                
1066:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1067:                {
1068:                    UART_DATA data;
1069:                
1070:                    data.__data = uartReg[id]->rx.reg;
1071:                
1072:                    return data;
1073:                }
1074:                
1075:                
1076:                /*******************************************************************************
1077:                  Function:
1078:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1079:                
1080:                  Summary:
1081:                    Routine to program the address for which the UART module may watch.
1082:                
1083:                  Description:
1084:                    This routine programs the 8-bit address for which the module may watch.
1085:                
1086:                  Precondition:
1087:                    None
1088:                
1089:                  Parameters:
1090:                    id      - Identifies the desired UART module.
1091:                
1092:                    address - 8-bit address for which the module will watch.
1093:                
1094:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1095:                              * TRUE - Enable address watch mode
1096:                              * FALSE - Disable address watch mode
1097:                
1098:                  Returns:
1099:                    None.
1100:                
1101:                  Example:
1102:                    <code>
1103:                    #define SLAVE_ADDRESS  0x42
1104:                	
1105:                	UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1106:                    </code>
1107:                
1108:                  Remarks:
1109:                    The module can be placed into a mode where it will ignore all data received
1110:                    until it identifies the programmed adress.  After the programmed address
1111:                    has been identified, it will begin receiving data normally.  This mode is
1112:                    particularly useful for supporting the IEEE-485 protocol.
1113:                  *****************************************************************************/
1114:                
1115:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1116:                
1117:                
1118:                /*******************************************************************************
1119:                  Function:
1120:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1121:                
1122:                  Summary:
1123:                    Routine to enable or disable recognition of the programmed address byte.
1124:                
1125:                  Description:
1126:                    This routine can enable or disable the "address watch" mode.  In this mode,
1127:                    the UART module will ignore all data until it recognizes the programmed address.
1128:                
1129:                  Precondition:
1130:                    UART should have already been enabled and set with watch address.
1131:                
1132:                  Parameters:
1133:                    id      - Identifies the desired UART module.
1134:                
1135:                    watch   - Determines if the "address watch" mode will be enabled or
1136:                              disabled.
1137:                              * TRUE - Enable address watch mode
1138:                              * FALSE - Disable address watch mode
1139:                
1140:                  Returns:
1141:                    None.
1142:                
1143:                  Example:
1144:                    <code>
1145:                    #define SLAVE_ADDRESS 0x42
1146:                	
1147:                	// Set the address, but don't enable the watch until later,
1148:                	// UART continues to receive data normally
1149:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1150:                
1151:                    // ...
1152:                
1153:                    // Now begin to ignore all UART traffic until we are addressed
1154:                    UARTWatchForAddress(UART1, TRUE);
1155:                    </code>
1156:                
1157:                  Remarks:
1158:                    The UART module can be placed into a mode where it will ignore all data received
1159:                    until it identifies the programmed address.  After the programmed address
1160:                    has been identified, it will begin receiving data normally.  This mode is
1161:                    particularly useful for supporting the IEEE-485 protocol.
1162:                  *****************************************************************************/
1163:                
1164:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1165:                
1166:                
1167:                /*******************************************************************************
1168:                  Function:
1169:                    void UARTSendBreak ( UART_MODULE id )
1170:                
1171:                  Summary:
1172:                    Routine to send a break signal from the UART.
1173:                
1174:                  Description:
1175:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1176:                
1177:                  Precondition:
1178:                    The UART should have been appropriately configured.  The transmitter should
1179:                    be idle, although not necessarily enabled yet.
1180:                
1181:                  Parameters:
1182:                    id      - Identifies the desired UART module.
1183:                
1184:                  Returns:
1185:                    None
1186:                
1187:                  Example:
1188:                    <code>
1189:                    if (UARTTransmissionHasCompleted(UART1))
1190:                    {
1191:                        UARTSendBreak(UART1);
1192:                    }
1193:                    </code>
1194:                
1195:                  Remarks:
1196:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1197:                    data may be pre-loaded into the FIFO and it will be send immediately
1198:                    following the break signal.
1199:                  *****************************************************************************/
1200:                
1201:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1202:                {
1203:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1204:                }
1205:                
1206:                
1207:                /*******************************************************************************
1208:                  Function:
1209:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1210:                
1211:                  Summary:
1212:                    Routine to automatically determine the data rate (bits-per-second) of an
1213:                    external transmitter to the UART.
1214:                
1215:                  Description:
1216:                    This routine initiates the process of automatically determining the data
1217:                    rate (bits-per-second) of an external transmitter to the UART.
1218:                
1219:                  Precondition:
1220:                    The UART should have been appropriately configured.  The transmitter should
1221:                    be idle, although not necessarily enabled yet.
1222:                
1223:                  Parameters:
1224:                    id      - Identifies the desired UART module.
1225:                
1226:                  Returns:
1227:                    None
1228:                
1229:                  Example:
1230:                    <code>
1231:                	// See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1232:                	// methods to detect a Break.
1233:                	
1234:                    if (breakDetected && useAutoRateDetect) 
1235:                    {
1236:                        UARTStartAutoDataRateDetect (UART1);
1237:                    }
1238:                    </code>
1239:                
1240:                  Remarks:
1241:                    The UART module begins measuring the data rate beginning at the next start
1242:                    bit.  The external transmitter should send an alternating pattern (0x55)
1243:                    for the byte to be measured for an effective rate detection.  To ensure
1244:                    an effective measurement sequence, this can be done immediately following
1245:                    a break reception. It is important that this UART module is not
1246:                	transmitting data while it is trying to detect RX baud rate, see the 
1247:                	"PIC32 Family Reference Manual, Sect. 21 UART".
1248:                  *****************************************************************************/
1249:                
1250:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1251:                {
1252:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1253:                }
1254:                
1255:                
1256:                
1257:                /*******************************************************************************
1258:                  Function:
1259:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1260:                
1261:                  Summary:
1262:                    Routine to identify when automatic data rate detection has completed.
1263:                
1264:                  Description:
1265:                    This routine checks to see if automatic data rate detection has completed.
1266:                
1267:                  Precondition:
1268:                    Automatic rate detection should have been previously started.
1269:                
1270:                  Parameters:
1271:                    id      - Identifies the desired UART module.
1272:                
1273:                  Returns:
1274:                    * TRUE    - Indicates that automatic rate detection has completed.
1275:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1276:                
1277:                  Example:
1278:                    <code>
1279:                    #define PERIPHERAL_CLOCK    10000000
1280:                	
1281:                	UINT32 currentRate;
1282:                	
1283:                	if (UARTDataRateDetected(UART1))
1284:                    {
1285:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1286:                    }
1287:                    </code>
1288:                
1289:                  Remarks:
1290:                    This routine returns FALSE after automatic rate detection
1291:                    has been started but before rate is detectdd, it will return TRUE
1292:                	at any other time.
1293:                  *****************************************************************************/
1294:                
1295:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1296:                {
1297:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1298:                }
1299:                
1300:                #ifdef __cplusplus
1301:                  }
1302:                #endif
1303:                
1304:                #endif // _UART_h_
1305:                
---  /opt/microchip/xc32/v1.33/pic32mx/include/peripheral/system.h  -------------------------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the Company) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Companys customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file, 
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.  
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                  #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:       
92:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                   
94:                   Description:
95:                  	The function sets the PB divider to the optimum value.
96:                   
97:                   PreCondition:    
98:                  	None
99:                   
100:                  Parameters:           
101:                 	sys_clock - system clock in Hz
102:                  
103:                  Returns:          
104:                 	the PB clock frequency in Hz
105:                  
106:                  Side Effects:
107:                 	The PB clock may be changed
108:                 	
109:                  Overview:	    
110:                 	The function sets the PB divider to the optimum value.
111:                  
112:                  Remarks:            
113:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                  
116:                  Example:
117:                 	<code>
118:                 	SYSTEMConfigPB(72000000);
119:                 	</code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
131:                         pb_clock >>= 1;
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:        
146:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                  
148:                   Description:
149:                 	The function sets the Flash Wait states to the optimum value.
150:                  
151:                   PreCondition:    
152:                 	None
153:                  
154:                   Parameters:           
155:                 	sys_clock - system clock in Hz
156:                  
157:                   Returns:          
158:                 	None
159:                  
160:                   Side Effects:    
161:                 	The Wait States may be changed  
162:                  
163:                   Remarks:         
164:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                  
167:                   Example:
168:                 	<code>
169:                 	SYSTEMConfigWaitStates(72000000);
170:                 	</code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:        
197:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                   
199:                   Description:
200:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
201:                  
202:                   PreCondition:    
203:                 	None
204:                  
205:                   Parameters:           
206:                 	sys_clock - system clock in Hz
207:                  
208:                   Returns:          
209:                 	the PB clock frequency in Hz
210:                  
211:                   Side Effects:    
212:                 	The PB clock and wait states may be changed
213:                 
214:                   Remarks:            
215:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                  
218:                   Example:
219:                 	<code>
220:                 	SYSTEMConfigWaitStatesAndPB(72000000);
221:                 	</code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
246:                     mCheConfigure(wait_states);
247:                     INTRestoreInterrupts(int_status);
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:       
255:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                  
257:                   Description:
258:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 	
261:                   PreCondition:    
262:                 	None
263:                  
264:                   Parameters:           
265:                 	sys_clock - system clock in Hz
266:                  
267:                   Output:          
268:                 	the PB clock frequency in Hz
269:                  
270:                   Side Effects:    
271:                 	Sets the PB and Flash Wait states
272:                  	
273:                   Remarks:            
274:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                  
277:                   Example:
278:                 	<code>
279:                 	SYSTEMConfigPerformance(72000000);
280:                 	</code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
294:                 
295:                     mBMXDisableDRMWaitState();
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
299:                     cache_status |= CHE_CONF_PF_ALL;
300:                     mCheConfigure(cache_status);
301:                     CheKseg0CacheOn();
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:       
311:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                  
313:                   Description:
314:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
315:                 	based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 				   
318:                   PreCondition:    
319:                 	None
320:                  
321:                   Parameters:           
322:                 	sys_clock - system clock frequency in Hz
323:                     flags -
324:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                  
329:                   Returns:          
330:                 	the PB clock frequency in Hz
331:                  
332:                   Side Effects:    
333:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                   
336:                  
337:                   Remarks:
338:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                  
341:                   Example:
342:                 	<code>
343:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                 	</code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
9D00F81C  0F405F7F   JAL INTDisableInterrupts
9D00F820  00000000   NOP
355:                 
356:                     mBMXDisableDRMWaitState();
9D00F824  24040040   ADDIU A0, ZERO, 64
9D00F828  3C03BF88   LUI V1, -16504
9D00F82C  AC642004   SW A0, 8196(V1)
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
9D00F830  3C03BF81   LUI V1, -16511
9D00F834  8C63F000   LW V1, -4096(V1)
381:                 
382:                     INTRestoreInterrupts(int_status);
9D00F838  0F405F14   JAL INTRestoreInterrupts
9D00F83C  00402021   ADDU A0, V0, ZERO
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  /home/jacques/MPLABXProjects/vpc-32/vpcBASIC/vpcBASIC.c  -------------------------------------------
1:                   /*
2:                    *    système vpcBASIC exécutant sur la VM.
3:                    */
4:                   #include <math.h>
5:                   #include <stdint.h>
6:                   #include "../hardware/serial_comm/serial_comm.h"
7:                   #include "../hardware/HardwareProfile.h"
8:                   #include "../hardware/spiram/spiram.h"
9:                   #include "../console.h"
10:                  #include "vpcBASIC.h"
11:                  #include "vm.h"
12:                  
13:                  #define NAME_LEN 32  // longueur maximale des mots
14:                  #define COMPILE 1
15:                  #define IMMEDIATE 0
16:                  
17:                  // data types
18:                  typedef unsigned char BYTE ;
19:                  typedef unsigned short WORD;
20:                  
21:                  typedef enum eError {ERR_NONE,ERR_SYNTAX,ERR_DUP_ID} error_t;
22:                  
23:                  typedef enum eToken_id {NONE,NUMBER,SYMBOL,ADDOP, MULOP,POW,LPAREN,RPARENT,
24:                          COMMA,SEMICOLUMN,STRING,APOSTROPH,RELOP} token_t;
25:                  
26:                  typedef enum sSymbol_class {LABEL,VARIABLE,FUNCTION} eSymbol_t;
27:                  
28:                  typedef struct symbol_struct{
29:                      char name[NAME_LEN];
30:                      eSymbol_t class;
31:                      unsigned addr;
32:                  }symb_t;
33:                  
34:                  typedef struct{
35:                      uint16_t const_base; // début bloc de constantes
36:                      uint16_t const_read; // position du pointeur READ
37:                      uint16_t str_base;   // début block chaine de caractères
38:                      uint16_t str_read;   // poisition du pointeur READ
39:                      uint16_t var_base;   // début des variables
40:                      uint16_t var_count;  // nombre de variables
41:                  } prog_header_t;
42:                  
43:                  // blocs SPIRAM utilisés pour le code source et la compilation
44:                  #define SRC_BASE (0x10000)    // texte source
45:                  #define SYMB_BASE (0x1A000)   // table des symboles
46:                  #define CONST_BASE (0x1C00)   // liste des constantes numériques DATA
47:                  #define STR_BASE (0x1E000)    // liste des chaînes DATA
48:                  
49:                  // déclarations vpcBASIC
50:                  #define STATEMENTS_COUNT (18)
51:                  static const char *statements[STATEMENTS_COUNT]={
52:                  "CHANGE",
53:                  "DATA",
54:                  "DEF",
55:                  "DIM",
56:                  "END",
57:                  "FOR",
58:                  "GOSUB",
59:                  "GOTO",
60:                  "IF",
61:                  "INPUT",
62:                  "LET",
63:                  "ON",
64:                  "PRINT",
65:                  "READ",
66:                  "REM",
67:                  "RESTORE",
68:                  "RETURN",
69:                  "STOP",
70:                  };
71:                  
72:                  typedef enum eStatement {CHANGE,DATA,DEF,DIM,END,FOR,GOSUB,GOTO,IF,INPUT,LET,ON,PRINT,
73:                          READ,REM,RESTORE,RETURN,STOP} eStatement_t;
74:                  
75:                  // fonctions vpcBASIC internes
76:                  #define FUNC_COUNT (13)
77:                  static const char *functions[FUNC_COUNT]={
78:                  "ABS",  // absolut
79:                  "ATN",  // arctangente
80:                  "COS",  // cosinus
81:                  "COT",  // cotangente
82:                  "EXP",  // e^X
83:                  "INT",  // partie entière
84:                  "LOG",  // logarigthe naturel
85:                  "NUM",  // nombre d'items lus lors du dernier READ,INPUT
86:                  "RND",  // nombre aléatoire entre [0-1[
87:                  "SGN",  // signe du nombre
88:                  "SIN",  // sinus
89:                  "SQR",  // racine carrée
90:                  "TAN",  // tangente
91:                  };
92:                  
93:                  typedef enum eBasicFunc {ABS,ATN,COS,COT,EXP,INTEG,LOG,NUM,RND,SGN,SIN,SQR,TAN} eBasicFunc_t;
94:                  
95:                  token_t tok_id;
96:                  char tok_value[33];
97:                  prog_header_t prog_header;
98:                  error_t error;
99:                  unsigned state;
100:                 
101:                 unsigned src_end; // fin du code source dans la SPIRAM
102:                 unsigned symb_free; // position libre table des symboles dans la SPIRAM
103:                 unsigned const_free; // position libre table des constantes DATA
104:                 unsigned str_free;   // position libre table des chaînes DATA
105:                 unsigned ram_free; // RAM libre
106:                 unsigned char *ram_code; // espace code
107:                 char *here; // pointeur espace code
108:                 char *vars; // pointeur des variables
109:                 
110:                 
111:                 char src_line[CHAR_PER_LINE+1];
112:                 unsigned inp; //progression de next_token() dans src_line
113:                 
114:                 src_error(error_t e){
9D00534C  27BDFFB0   ADDIU SP, SP, -80
9D005350  AFBF004C   SW RA, 76(SP)
115:                     char msg[56];
116:                 
117:                     error=e;
118:                     switch(e){
9D005354  24020001   ADDIU V0, ZERO, 1
9D005358  10820006   BEQ A0, V0, 0x9D005374
9D00535C  AF8480F0   SW A0, -32528(GP)
9D005360  24020002   ADDIU V0, ZERO, 2
9D005364  1482001D   BNE A0, V0, 0x9D0053DC
9D005368  8FBF004C   LW RA, 76(SP)
119:                     case ERR_SYNTAX:
120:                         sprintf(msg,"syntax error at %d\r",inp-strlen(tok_value));
9D005374  3C04A000   LUI A0, -24576
9D005378  0F40514F   JAL 0x9D01453C
9D00537C  248421C4   ADDIU A0, A0, 8644
9D005380  27A40010   ADDIU A0, SP, 16
9D005384  3C059D01   LUI A1, -25343
9D005388  24A54F14   ADDIU A1, A1, 20244
9D00538C  8F8680D4   LW A2, -32556(GP)
9D005390  0F405BB0   JAL _sprintf_cdnopsuxX
9D005394  00C23023   SUBU A2, A2, V0
121:                         print(comm_channel,msg);
9D005398  8384804C   LB A0, -32692(GP)
9D00539C  0F40229C   JAL print
9D0053A0  27A50010   ADDIU A1, SP, 16
122:                         break;
9D0053A4  0B4014F7   J 0x9D0053DC
9D0053A8  8FBF004C   LW RA, 76(SP)
123:                     case ERR_DUP_ID:
124:                         sprintf(msg,"duplicate identifier at %d\r",inp-strlen(tok_value));
9D00536C  0B4014EB   J 0x9D0053AC
9D005370  3C04A000   LUI A0, -24576
9D0053AC  0F40514F   JAL 0x9D01453C
9D0053B0  248421C4   ADDIU A0, A0, 8644
9D0053B4  27A40010   ADDIU A0, SP, 16
9D0053B8  3C059D01   LUI A1, -25343
9D0053BC  24A54F28   ADDIU A1, A1, 20264
9D0053C0  8F8680D4   LW A2, -32556(GP)
9D0053C4  0F405BB0   JAL _sprintf_cdnopsuxX
9D0053C8  00C23023   SUBU A2, A2, V0
125:                         print(comm_channel,msg);
9D0053CC  8384804C   LB A0, -32692(GP)
9D0053D0  0F40229C   JAL print
9D0053D4  27A50010   ADDIU A1, SP, 16
126:                         break;
127:                     }
128:                 }
9D0053D8  8FBF004C   LW RA, 76(SP)
9D0053DC  03E00008   JR RA
9D0053E0  27BD0050   ADDIU SP, SP, 80
129:                 
130:                 float hex_to_float(char *hex){
9D0053E4  27BDFFE8   ADDIU SP, SP, -24
9D0053E8  AFBF0014   SW RA, 20(SP)
9D0053EC  00801821   ADDU V1, A0, ZERO
131:                     uint32_t h;
132:                     h=0;
133:                     while (*hex){
9D0053F0  80820000   LB V0, 0(A0)
9D0053F4  1040000B   BEQ V0, ZERO, 0x9D005424
9D0053F8  00002021   ADDU A0, ZERO, ZERO
9D005418  80620000   LB V0, 0(V1)
9D00541C  1440FFF7   BNE V0, ZERO, 0x9D0053FC
9D005420  00A02021   ADDU A0, A1, ZERO
134:                         h= h*16 + *hex<='9'?(*hex)-'0':(*hex)-'A'+10;
9D0053FC  00042100   SLL A0, A0, 4
9D005400  00442021   ADDU A0, V0, A0
9D005404  2C84003A   SLTIU A0, A0, 58
9D005408  2445FFD0   ADDIU A1, V0, -48
9D00540C  2442FFC9   ADDIU V0, V0, -55
9D005410  0044280A   MOVZ A1, V0, A0
135:                         hex++;
9D005414  24630001   ADDIU V1, V1, 1
136:                     }
137:                     return (float)((int32_t)h);
9D005424  0F405C4A   JAL sitofp
9D005428  00000000   NOP
138:                 }
9D00542C  8FBF0014   LW RA, 20(SP)
9D005430  03E00008   JR RA
9D005434  27BD0018   ADDIU SP, SP, 24
139:                 
140:                 float bin_to_float(char *bin){
141:                     uint32_t b;
142:                     b=0;
143:                     while (*bin){
9D005438  80820000   LB V0, 0(A0)
9D00543C  10400007   BEQ V0, ZERO, 0x9D00545C
9D005440  00001021   ADDU V0, ZERO, ZERO
9D005448  80820000   LB V0, 0(A0)
9D00544C  1440FFFE   BNE V0, ZERO, 0x9D005448
9D005450  24840001   ADDIU A0, A0, 1
144:                         b = b<<1 + *bin=='1'?1:0;
145:                         bin++;
9D005444  24840001   ADDIU A0, A0, 1
146:                     }
147:                     return (float)((int32_t)b);
148:                 }
9D005454  03E00008   JR RA
9D005458  00001021   ADDU V0, ZERO, ZERO
9D00545C  03E00008   JR RA
9D005460  00000000   NOP
149:                 
150:                 float dec_to_float(char *dec){
9D005464  27BDFFD0   ADDIU SP, SP, -48
9D005468  AFBF002C   SW RA, 44(SP)
9D00546C  AFB60028   SW S6, 40(SP)
9D005470  AFB50024   SW S5, 36(SP)
9D005474  AFB40020   SW S4, 32(SP)
9D005478  AFB3001C   SW S3, 28(SP)
9D00547C  AFB20018   SW S2, 24(SP)
9D005480  AFB10014   SW S1, 20(SP)
9D005484  AFB00010   SW S0, 16(SP)
151:                     uint32_t d,x;
152:                     float f;
153:                     BOOL eneg=FALSE;
9D005560  00003021   ADDU A2, ZERO, ZERO
154:                 
155:                     f=0.0;
9D0055E8  00009021   ADDU S2, ZERO, ZERO
9D005618  00009021   ADDU S2, ZERO, ZERO
156:                     d=1;
157:                     while (*dec && *dec!='.' && *dec!='E'){
9D005488  80900000   LB S0, 0(A0)
9D00548C  12000056   BEQ S0, ZERO, 0x9D0055E8
9D005490  00808821   ADDU S1, A0, ZERO
9D005494  2402002E   ADDIU V0, ZERO, 46
9D005498  1202005F   BEQ S0, V0, 0x9D005618
9D00549C  24020045   ADDIU V0, ZERO, 69
9D0054A0  12020025   BEQ S0, V0, 0x9D005538
9D0054A4  00009021   ADDU S2, ZERO, ZERO
9D0054B8  2415002E   ADDIU S5, ZERO, 46
9D0054BC  24160045   ADDIU S6, ZERO, 69
9D0054F4  82300000   LB S0, 0(S1)
9D0054F8  12000005   BEQ S0, ZERO, 0x9D005510
9D0054FC  00409021   ADDU S2, V0, ZERO
9D005500  52150047   BEQL S0, S5, 0x9D005620
9D005504  26310001   ADDIU S1, S1, 1
9D005508  1616FFEE   BNE S0, S6, 0x9D0054C4
9D00550C  02402021   ADDU A0, S2, ZERO
158:                         f = f*10 + (*dec)-'0';
9D0054A8  3C029D01   LUI V0, -25343
9D0054AC  8C535024   LW S3, 20516(V0)
9D0054B0  3C029D01   LUI V0, -25343
9D0054B4  8C545028   LW S4, 20520(V0)
9D0054C0  02402021   ADDU A0, S2, ZERO
9D0054C4  0F404C28   JAL __mulsf3
9D0054C8  02602821   ADDU A1, S3, ZERO
9D0054CC  00409021   ADDU S2, V0, ZERO
9D0054D0  0F405C4A   JAL sitofp
9D0054D4  02002021   ADDU A0, S0, ZERO
9D0054D8  02402021   ADDU A0, S2, ZERO
9D0054DC  0F404742   JAL fpadd
9D0054E0  00402821   ADDU A1, V0, ZERO
9D0054E4  00402021   ADDU A0, V0, ZERO
9D0054E8  0F404740   JAL __subsf3
9D0054EC  02802821   ADDU A1, S4, ZERO
159:                         dec++;
9D0054F0  26310001   ADDIU S1, S1, 1
160:                     }
161:                     if (*dec=='.'){
162:                         dec++;
9D00561C  26310001   ADDIU S1, S1, 1
163:                         while (*dec && *dec!='E'){
9D005528  14430042   BNE V0, V1, 0x9D005634
9D00552C  26220001   ADDIU V0, S1, 1
9D005620  82220000   LB V0, 0(S1)
9D005624  1440FFC0   BNE V0, ZERO, 0x9D005528
9D005628  24030045   ADDIU V1, ZERO, 69
164:                             d *=10;
165:                             f = f + ((*dec)-'0')/d;
166:                         }
167:                     }
168:                     if (*dec=='E'){
9D005510  82230000   LB V1, 0(S1)
9D005514  24020045   ADDIU V0, ZERO, 69
9D005518  50620008   BEQL V1, V0, 0x9D00553C
9D00551C  26220001   ADDIU V0, S1, 1
169:                         dec++;
9D005538  26220001   ADDIU V0, S1, 1
170:                         if (*dec=='+' || (eneg=(*dec=='-'))){
9D005530  0B401550   J 0x9D005540
9D005534  82230001   LB V1, 1(S1)
9D00553C  82230001   LB V1, 1(S1)
9D005540  2404002B   ADDIU A0, ZERO, 43
9D005544  10640006   BEQ V1, A0, 0x9D005560
9D005548  3863002D   XORI V1, V1, 45
9D00554C  2C660001   SLTIU A2, V1, 1
9D005550  50C00006   BEQL A2, ZERO, 0x9D00556C
9D005554  80430000   LB V1, 0(V0)
171:                             dec++;
9D005558  0B40155A   J 0x9D005568
9D00555C  24420001   ADDIU V0, V0, 1
9D005564  24420001   ADDIU V0, V0, 1
172:                         }
173:                         x=0;
174:                         while (*dec){
9D005568  80430000   LB V1, 0(V0)
9D00556C  10600009   BEQ V1, ZERO, 0x9D005594
9D005570  00002021   ADDU A0, ZERO, ZERO
9D005588  80430000   LB V1, 0(V0)
9D00558C  1460FFF9   BNE V1, ZERO, 0x9D005574
9D005590  2484FFD0   ADDIU A0, A0, -48
175:                             x= x*10 + (*dec)-'0';
9D005574  00042840   SLL A1, A0, 1
9D005578  000420C0   SLL A0, A0, 3
9D00557C  00A42021   ADDU A0, A1, A0
9D005580  00832021   ADDU A0, A0, V1
176:                             dec++;
9D005584  24420001   ADDIU V0, V0, 1
177:                         }
178:                         f *= eneg?pow(10,-x):pow(10,x);
9D005594  10C00009   BEQ A2, ZERO, 0x9D0055BC
9D005598  00000000   NOP
9D00559C  0F405D24   JAL __floatunsisf
9D0055A0  00042023   SUBU A0, ZERO, A0
9D0055A4  3C039D01   LUI V1, -25343
9D0055A8  8C645024   LW A0, 20516(V1)
9D0055AC  0F4051A9   JAL powf
9D0055B0  00402821   ADDU A1, V0, ZERO
9D0055B4  0B401576   J 0x9D0055D8
9D0055B8  00402821   ADDU A1, V0, ZERO
9D0055BC  0F405D24   JAL __floatunsisf
9D0055C0  00000000   NOP
9D0055C4  3C039D01   LUI V1, -25343
9D0055C8  8C645024   LW A0, 20516(V1)
9D0055CC  0F4051A9   JAL powf
9D0055D0  00402821   ADDU A1, V0, ZERO
9D0055D4  00402821   ADDU A1, V0, ZERO
9D0055D8  0F404C28   JAL __mulsf3
9D0055DC  02402021   ADDU A0, S2, ZERO
9D0055E0  0B40157B   J 0x9D0055EC
9D0055E4  00409021   ADDU S2, V0, ZERO
179:                     }
180:                     return f;
181:                 }
9D005520  0B40157C   J 0x9D0055F0
9D005524  02401021   ADDU V0, S2, ZERO
9D0055EC  02401021   ADDU V0, S2, ZERO
9D0055F0  8FBF002C   LW RA, 44(SP)
9D0055F4  8FB60028   LW S6, 40(SP)
9D0055F8  8FB50024   LW S5, 36(SP)
9D0055FC  8FB40020   LW S4, 32(SP)
9D005600  8FB3001C   LW S3, 28(SP)
9D005604  8FB20018   LW S2, 24(SP)
9D005608  8FB10014   LW S1, 20(SP)
9D00560C  8FB00010   LW S0, 16(SP)
9D005610  03E00008   JR RA
9D005614  27BD0030   ADDIU SP, SP, 48
9D00562C  0B40157C   J 0x9D0055F0
9D005630  02401021   ADDU V0, S2, ZERO
9D005634  0B40158D   J 0x9D005634
9D005638  00000000   NOP
182:                 
183:                 float number_to_float(char *number){
9D00563C  27BDFFE8   ADDIU SP, SP, -24
9D005640  AFBF0014   SW RA, 20(SP)
184:                     if (number[0]=='&' && number[1]=='H')
9D005644  80830000   LB V1, 0(A0)
9D005648  24020026   ADDIU V0, ZERO, 38
9D00564C  1462000E   BNE V1, V0, 0x9D005688
9D005650  24030048   ADDIU V1, ZERO, 72
9D005654  80820001   LB V0, 1(A0)
9D005658  14430005   BNE V0, V1, 0x9D005670
9D00565C  24030042   ADDIU V1, ZERO, 66
185:                         return hex_to_float(&number[2]);
9D005660  0F4014F9   JAL hex_to_float
9D005664  24840002   ADDIU A0, A0, 2
9D005668  0B4015A5   J 0x9D005694
9D00566C  8FBF0014   LW RA, 20(SP)
186:                     if (number[0]=='&' && number[1]=='B')
9D005670  14430005   BNE V0, V1, 0x9D005688
9D005674  00000000   NOP
187:                         return bin_to_float(&number[2]);
9D005678  0F40150E   JAL bin_to_float
9D00567C  24840002   ADDIU A0, A0, 2
9D005680  0B4015A5   J 0x9D005694
9D005684  8FBF0014   LW RA, 20(SP)
188:                     return dec_to_float(number);
9D005688  0F401519   JAL dec_to_float
9D00568C  00000000   NOP
189:                 }
9D005690  8FBF0014   LW RA, 20(SP)
9D005694  03E00008   JR RA
9D005698  27BD0018   ADDIU SP, SP, 24
190:                 
191:                 // compile les expressions
192:                 void expression(){
193:                 
194:                 }
9D00569C  03E00008   JR RA
9D0056A0  00000000   NOP
195:                 
196:                 // fonctions compilant
197:                 // les déclarations
198:                 void compile_dim(){
199:                 
200:                 }
9D0056A4  03E00008   JR RA
9D0056A8  00000000   NOP
201:                 
202:                 void compile_let(){
203:                 
204:                 }
9D0056AC  03E00008   JR RA
9D0056B0  00000000   NOP
205:                 
206:                 void compile_if(){
207:                 
208:                 }
9D0056B4  03E00008   JR RA
9D0056B8  00000000   NOP
209:                 
210:                 void compile_goto(){
211:                 
212:                 }
9D0056BC  03E00008   JR RA
9D0056C0  00000000   NOP
213:                 
214:                 void compile_gosub(){
215:                 
216:                 }
9D0056C4  03E00008   JR RA
9D0056C8  00000000   NOP
217:                 
218:                 void compile_for(){
219:                 
220:                 }
9D0056CC  03E00008   JR RA
9D0056D0  00000000   NOP
221:                 
222:                 void compile_read(){
223:                 
224:                 }
9D0056D4  03E00008   JR RA
9D0056D8  00000000   NOP
225:                 
226:                 void compile_input(){
227:                 
228:                 }
9D0056DC  03E00008   JR RA
9D0056E0  00000000   NOP
229:                 
230:                 void compile_print(){
231:                 
232:                 }
9D0056E4  03E00008   JR RA
9D0056E8  00000000   NOP
233:                 
234:                 void compile_data(){
235:                 
236:                 }
9D0056EC  03E00008   JR RA
9D0056F0  00000000   NOP
237:                 
238:                 void compile_restore(){
239:                 
240:                 }
9D0056F4  03E00008   JR RA
9D0056F8  00000000   NOP
241:                 
242:                 void compile_on(){
243:                 
244:                 }
9D0056FC  03E00008   JR RA
9D005700  00000000   NOP
245:                 
246:                 void compile_return(){
247:                 
248:                 }
9D005704  03E00008   JR RA
9D005708  00000000   NOP
249:                 
250:                 void compile_def(){
251:                 
252:                 }
9D00570C  03E00008   JR RA
9D005710  00000000   NOP
253:                 
254:                 void compile_change(){
255:                 
256:                 }
9D005714  03E00008   JR RA
9D005718  00000000   NOP
257:                 
258:                 void compile_stop(){
259:                 
260:                 }
9D00571C  03E00008   JR RA
9D005720  00000000   NOP
261:                 
262:                 void compile_end(){
263:                 
264:                 }
9D005724  03E00008   JR RA
9D005728  00000000   NOP
265:                 
266:                 void compile_function(){
267:                 
268:                 }
9D00572C  03E00008   JR RA
9D005730  00000000   NOP
269:                 
270:                 void compile_comma(){
271:                 
272:                 }
9D005734  03E00008   JR RA
9D005738  00000000   NOP
273:                 
274:                 void semi_column(){
275:                 
276:                 }
9D00573C  03E00008   JR RA
9D005740  00000000   NOP
277:                 
278:                 
279:                 void upper(char *str){
280:                     while (*str) if (*str>='a' && *str<='z') *str -= 32;
9D005744  0B4015D9   J 0x9D005764
9D005748  80830000   LB V1, 0(A0)
9D00574C  2C42001A   SLTIU V0, V0, 26
9D005750  1040FFFF   BEQ V0, ZERO, 0x9D005750
9D005754  00000000   NOP
9D005758  24A5FFE0   ADDIU A1, A1, -32
9D00575C  A0850000   SB A1, 0(A0)
9D005760  80830000   LB V1, 0(A0)
9D005764  306500FF   ANDI A1, V1, 255
9D005768  24A2FF9F   ADDIU V0, A1, -97
9D00576C  1460FFF7   BNE V1, ZERO, 0x9D00574C
9D005770  304200FF   ANDI V0, V0, 255
281:                 }// upper()
9D005774  03E00008   JR RA
9D005778  00000000   NOP
282:                 
283:                 void skip_white(){
9D00577C  8F8280D4   LW V0, -32556(GP)
9D005780  3C05A000   LUI A1, -24576
9D005784  24A521E8   ADDIU A1, A1, 8680
9D005790  00A21821   ADDU V1, A1, V0
284:                     while(src_line[inp]==' ' || src_line[inp]=='\t') inp++;
9D005788  24040020   ADDIU A0, ZERO, 32
9D00578C  24060009   ADDIU A2, ZERO, 9
9D005794  80630000   LB V1, 0(V1)
9D005798  5064FFFD   BEQL V1, A0, 0x9D005790
9D00579C  24420001   ADDIU V0, V0, 1
9D0057A0  5066FFFB   BEQL V1, A2, 0x9D005790
9D0057A4  24420001   ADDIU V0, V0, 1
285:                 }
9D0057A8  03E00008   JR RA
9D0057AC  AF8280D4   SW V0, -32556(GP)
286:                 
287:                 unsigned parse_string(){
9D0057B0  27BDFFD0   ADDIU SP, SP, -48
9D0057B4  AFBF002C   SW RA, 44(SP)
9D0057B8  AFB50028   SW S5, 40(SP)
9D0057BC  AFB40024   SW S4, 36(SP)
9D0057C0  AFB30020   SW S3, 32(SP)
9D0057C4  AFB2001C   SW S2, 28(SP)
9D0057C8  AFB10018   SW S1, 24(SP)
9D0057CC  AFB00014   SW S0, 20(SP)
288:                     BOOL quote=FALSE;
289:                     BOOL escape=FALSE;
9D0057EC  00008821   ADDU S1, ZERO, ZERO
290:                     unsigned i=0;
291:                 
292:                     while (src_line[inp] && !quote){
9D0057D0  3C02A000   LUI V0, -24576
9D0057D4  244221E8   ADDIU V0, V0, 8680
9D0057D8  8F8380D4   LW V1, -32556(GP)
9D0057DC  00621021   ADDU V0, V1, V0
9D0057E0  80420000   LB V0, 0(V0)
9D0057E4  1040004B   BEQ V0, ZERO, 0x9D005914
9D0057E8  00008021   ADDU S0, ZERO, ZERO
9D005800  3C13A000   LUI S3, -24576
9D005804  267321E8   ADDIU S3, S3, 8680
9D0058D8  00531021   ADDU V0, V0, S3
9D0058DC  80420000   LB V0, 0(V0)
9D0058E0  10400005   BEQ V0, ZERO, 0x9D0058F8
9D0058E4  00000000   NOP
9D0058E8  1060FFC7   BEQ V1, ZERO, 0x9D005808
9D0058EC  00000000   NOP
293:                         switch(src_line[inp]){
9D0057F0  2412005C   ADDIU S2, ZERO, 92
9D005808  10520007   BEQ V0, S2, 0x9D005828
9D00580C  2403006E   ADDIU V1, ZERO, 110
9D005810  1043000D   BEQ V0, V1, 0x9D005848
9D005814  24030022   ADDIU V1, ZERO, 34
9D005818  54430021   BNEL V0, V1, 0x9D0058A0
9D00581C  28430020   SLTI V1, V0, 32
294:                         case '\\':
295:                             if (!escape) escape=TRUE;else{tok_value[i++]=src_line[inp];escape=FALSE;}
9D0057F4  3C14A000   LUI S4, -24576
9D0057F8  269421C4   ADDIU S4, S4, 8644
9D0057FC  2415005C   ADDIU S5, ZERO, 92
9D005828  52200027   BEQL S1, ZERO, 0x9D0058C8
9D00582C  24110001   ADDIU S1, ZERO, 1
9D005830  02141021   ADDU V0, S0, S4
9D005834  A0550000   SB S5, 0(V0)
9D005838  26100001   ADDIU S0, S0, 1
9D00583C  00008821   ADDU S1, ZERO, ZERO
9D005840  0B401633   J 0x9D0058CC
9D005844  00001821   ADDU V1, ZERO, ZERO
9D0058C8  00001821   ADDU V1, ZERO, ZERO
296:                             break;
297:                         case 'n':
298:                             if (!escape) tok_value[i++]=src_line[inp];else{tok_value[i++]='\n';escape=FALSE;}
9D005848  16200006   BNE S1, ZERO, 0x9D005864
9D00584C  02141021   ADDU V0, S0, S4
9D005850  2403006E   ADDIU V1, ZERO, 110
9D005854  A0430000   SB V1, 0(V0)
9D005858  26100001   ADDIU S0, S0, 1
9D00585C  0B401633   J 0x9D0058CC
9D005860  00001821   ADDU V1, ZERO, ZERO
9D005864  2403000A   ADDIU V1, ZERO, 10
9D005868  A0430000   SB V1, 0(V0)
9D00586C  26100001   ADDIU S0, S0, 1
9D005870  00008821   ADDU S1, ZERO, ZERO
9D005874  0B401633   J 0x9D0058CC
9D005878  00001821   ADDU V1, ZERO, ZERO
299:                             break;
300:                         case '"':
301:                             if (!escape) quote=TRUE;else{tok_value[i++]=src_line[inp];escape=FALSE;}
9D005820  0B40161F   J 0x9D00587C
9D005824  24030001   ADDIU V1, ZERO, 1
9D00587C  12200014   BEQ S1, ZERO, 0x9D0058D0
9D005880  8F8480D4   LW A0, -32556(GP)
9D005884  02141021   ADDU V0, S0, S4
9D005888  24030022   ADDIU V1, ZERO, 34
9D00588C  A0430000   SB V1, 0(V0)
9D005890  26100001   ADDIU S0, S0, 1
9D005894  00008821   ADDU S1, ZERO, ZERO
9D005898  0B401633   J 0x9D0058CC
9D00589C  00001821   ADDU V1, ZERO, ZERO
302:                             break;
303:                         default:
304:                             if ((src_line[inp]<32)||src_line[inp]>127) src_error(ERR_SYNTAX);else{tok_value[i++]=src_line[inp];}
9D0058A0  50600005   BEQL V1, ZERO, 0x9D0058B8
9D0058A4  02141821   ADDU V1, S0, S4
9D0058A8  0F4014D3   JAL src_error
9D0058AC  24040001   ADDIU A0, ZERO, 1
9D0058B0  0B401633   J 0x9D0058CC
9D0058B4  00001821   ADDU V1, ZERO, ZERO
9D0058B8  A0620000   SB V0, 0(V1)
9D0058BC  26100001   ADDIU S0, S0, 1
9D0058C0  0B401633   J 0x9D0058CC
9D0058C4  00001821   ADDU V1, ZERO, ZERO
305:                             break;
306:                         }//switch
307:                         inp++;
9D0058CC  8F8480D4   LW A0, -32556(GP)
9D0058D0  24820001   ADDIU V0, A0, 1
9D0058D4  AF8280D4   SW V0, -32556(GP)
308:                     }//while
309:                     if (quote){tok_value[i]=0;inp--;} else src_error(ERR_SYNTAX);
9D0058F0  0B401640   J 0x9D005900
9D0058F4  3C02A000   LUI V0, -24576
9D0058F8  10600006   BEQ V1, ZERO, 0x9D005914
9D0058FC  3C02A000   LUI V0, -24576
9D005900  244221C4   ADDIU V0, V0, 8644
9D005904  02021021   ADDU V0, S0, V0
9D005908  A0400000   SB ZERO, 0(V0)
9D00590C  0B401647   J 0x9D00591C
9D005910  AF8480D4   SW A0, -32556(GP)
9D005914  0F4014D3   JAL src_error
9D005918  24040001   ADDIU A0, ZERO, 1
310:                     return i;
311:                 }
9D00591C  02001021   ADDU V0, S0, ZERO
9D005920  8FBF002C   LW RA, 44(SP)
9D005924  8FB50028   LW S5, 40(SP)
9D005928  8FB40024   LW S4, 36(SP)
9D00592C  8FB30020   LW S3, 32(SP)
9D005930  8FB2001C   LW S2, 28(SP)
9D005934  8FB10018   LW S1, 24(SP)
9D005938  8FB00014   LW S0, 20(SP)
9D00593C  03E00008   JR RA
9D005940  27BD0030   ADDIU SP, SP, 48
312:                 
313:                 #define TOK_START (0)
314:                 #define TOK_END (9)
315:                 static int next_token(){
9D005944  27BDFFC8   ADDIU SP, SP, -56
9D005948  AFBF0034   SW RA, 52(SP)
9D00594C  AFBE0030   SW S8, 48(SP)
9D005950  AFB7002C   SW S7, 44(SP)
9D005954  AFB60028   SW S6, 40(SP)
9D005958  AFB50024   SW S5, 36(SP)
9D00595C  AFB40020   SW S4, 32(SP)
9D005960  AFB3001C   SW S3, 28(SP)
9D005964  AFB20018   SW S2, 24(SP)
9D005968  AFB10014   SW S1, 20(SP)
316:                     unsigned pstate=TOK_START;
317:                     unsigned i=0;
318:                 
319:                     
320:                     skip_white();
9D00596C  0F4015DF   JAL skip_white
9D005970  AFB00010   SW S0, 16(SP)
321:                     tok_id=NONE;
9D005974  AF8080CC   SW ZERO, -32564(GP)
322:                     tok_value[0]=0;
9D005978  3C02A000   LUI V0, -24576
9D00597C  A04021C4   SB ZERO, 8644(V0)
323:                     while (!error && (pstate<TOK_END) && src_line[inp]){
9D005980  8F8280F0   LW V0, -32528(GP)
9D005984  14400183   BNE V0, ZERO, 0x9D005F94
9D005988  00009821   ADDU S3, ZERO, ZERO
9D00598C  8F9180D4   LW S1, -32556(GP)
9D005990  3C02A000   LUI V0, -24576
9D005994  244221E8   ADDIU V0, V0, 8680
9D005998  02221021   ADDU V0, S1, V0
9D00599C  80500000   LB S0, 0(V0)
9D0059A0  1200017C   BEQ S0, ZERO, 0x9D005F94
9D0059A4  00009021   ADDU S2, ZERO, ZERO
9D005F74  8F8280F0   LW V0, -32528(GP)
9D005F78  14400006   BNE V0, ZERO, 0x9D005F94
9D005F7C  2E420009   SLTIU V0, S2, 9
9D005F80  10400004   BEQ V0, ZERO, 0x9D005F94
9D005F84  02341021   ADDU V0, S1, S4
9D005F88  80500000   LB S0, 0(V0)
9D005F8C  1600FE8F   BNE S0, ZERO, 0x9D0059CC
9D005F90  2E420009   SLTIU V0, S2, 9
324:                         switch(pstate){
9D0059A8  3C169D00   LUI S6, -25344
9D0059AC  26D659E8   ADDIU S6, S6, 23016
9D0059C8  2E420009   SLTIU V0, S2, 9
9D0059CC  50400167   BEQL V0, ZERO, 0x9D005F6C
9D0059D0  8F9180D4   LW S1, -32556(GP)
9D0059D4  00121080   SLL V0, S2, 2
9D0059D8  02C21021   ADDU V0, S6, V0
9D0059DC  8C420000   LW V0, 0(V0)
9D0059E0  00400008   JR V0
9D0059E4  00000000   NOP
325:                         case 0:
326:                             switch(src_line[inp]){
9D0059B8  3C1E9D00   LUI S8, -25344
9D0059BC  27DE5A38   ADDIU S8, S8, 23096
9D005A0C  2602FFDE   ADDIU V0, S0, -34
9D005A10  304300FF   ANDI V1, V0, 255
9D005A14  2C63003D   SLTIU V1, V1, 61
9D005A18  506000A1   BEQL V1, ZERO, 0x9D005CA0
9D005A1C  02008821   ADDU S1, S0, ZERO
9D005A20  304200FF   ANDI V0, V0, 255
9D005A24  00021080   SLL V0, V0, 2
9D005A28  03C21021   ADDU V0, S8, V0
9D005A2C  8C420000   LW V0, 0(V0)
9D005A30  00400008   JR V0
9D005A34  00000000   NOP
327:                             case '+':
328:                             case '-':
329:                                     tok_id=ADDOP;
9D005B2C  24020003   ADDIU V0, ZERO, 3
9D005B30  AF8280CC   SW V0, -32564(GP)
330:                                     tok_value[i++]=src_line[inp];
9D005B34  02751021   ADDU V0, S3, S5
9D005B38  A0500000   SB S0, 0(V0)
9D005B3C  26730001   ADDIU S3, S3, 1
331:                                     pstate=TOK_END;
332:                                     break;
9D005B40  0B4017DA   J 0x9D005F68
9D005B44  24120009   ADDIU S2, ZERO, 9
333:                             case '*':
334:                             case '/':
335:                                     tok_id=MULOP;
9D005B48  24020004   ADDIU V0, ZERO, 4
9D005B4C  AF8280CC   SW V0, -32564(GP)
336:                                     tok_value[i++]=src_line[inp];
9D005B50  02751021   ADDU V0, S3, S5
9D005B54  A0500000   SB S0, 0(V0)
9D005B58  26730001   ADDIU S3, S3, 1
337:                                     pstate=TOK_END;
338:                                     break;
9D005B5C  0B4017DA   J 0x9D005F68
9D005B60  24120009   ADDIU S2, ZERO, 9
339:                             case '^':
340:                                     tok_id=POW;
9D005B64  24020005   ADDIU V0, ZERO, 5
9D005B68  AF8280CC   SW V0, -32564(GP)
341:                                     tok_value[i++]=src_line[inp];
9D005B6C  02751021   ADDU V0, S3, S5
9D005B70  2403005E   ADDIU V1, ZERO, 94
9D005B74  A0430000   SB V1, 0(V0)
9D005B78  26730001   ADDIU S3, S3, 1
342:                                     pstate=TOK_END;
343:                                     break;
9D005B7C  0B4017DA   J 0x9D005F68
9D005B80  24120009   ADDIU S2, ZERO, 9
344:                             case ',':
345:                                     tok_id=COMMA;
9D005B84  24020008   ADDIU V0, ZERO, 8
9D005B88  AF8280CC   SW V0, -32564(GP)
346:                                     tok_value[i++]=src_line[inp];
9D005B8C  02751021   ADDU V0, S3, S5
9D005B90  2403002C   ADDIU V1, ZERO, 44
9D005B94  A0430000   SB V1, 0(V0)
9D005B98  26730001   ADDIU S3, S3, 1
347:                                     pstate=TOK_END;
348:                                     break;
9D005B9C  0B4017DA   J 0x9D005F68
9D005BA0  24120009   ADDIU S2, ZERO, 9
349:                             case ';':
350:                                     tok_id=SEMICOLUMN;
9D005BA4  24020009   ADDIU V0, ZERO, 9
9D005BA8  AF8280CC   SW V0, -32564(GP)
351:                                     tok_value[i++]=src_line[inp];
9D005BAC  02751021   ADDU V0, S3, S5
9D005BB0  2403003B   ADDIU V1, ZERO, 59
9D005BB4  A0430000   SB V1, 0(V0)
9D005BB8  26730001   ADDIU S3, S3, 1
352:                                     pstate=TOK_END;
353:                                     break;
9D005BBC  0B4017DA   J 0x9D005F68
9D005BC0  24120009   ADDIU S2, ZERO, 9
354:                             case '"':
355:                                     inp++;
9D005BC4  26310001   ADDIU S1, S1, 1
356:                                     i=parse_string();
9D005BC8  0F4015EC   JAL parse_string
9D005BCC  AF9180D4   SW S1, -32556(GP)
9D005BD0  00409821   ADDU S3, V0, ZERO
357:                                     tok_id=STRING;
9D005BD4  2402000A   ADDIU V0, ZERO, 10
9D005BD8  AF8280CC   SW V0, -32564(GP)
358:                                     pstate=TOK_END;
359:                                     break;
9D005BDC  0B4017DA   J 0x9D005F68
9D005BE0  24120009   ADDIU S2, ZERO, 9
360:                             case '=':
361:                                     tok_value[i++]=src_line[inp];
9D005BE4  02751021   ADDU V0, S3, S5
9D005BE8  2403003D   ADDIU V1, ZERO, 61
9D005BEC  A0430000   SB V1, 0(V0)
9D005BF0  26730001   ADDIU S3, S3, 1
362:                                     tok_id=RELOP;
363:                                     pstate=TOK_END;
364:                             case '>':
365:                                     tok_id=RELOP;
9D005BF4  2402000C   ADDIU V0, ZERO, 12
9D005BF8  AF8280CC   SW V0, -32564(GP)
366:                                     tok_value[i++]=src_line[inp];
9D005BFC  02751021   ADDU V0, S3, S5
9D005C00  A0500000   SB S0, 0(V0)
9D005C04  26730001   ADDIU S3, S3, 1
367:                                     if (src_line[inp+1]=='='){
9D005C08  26310001   ADDIU S1, S1, 1
9D005C0C  02341021   ADDU V0, S1, S4
9D005C10  80430000   LB V1, 0(V0)
9D005C14  2402003D   ADDIU V0, ZERO, 61
9D005C18  146200D3   BNE V1, V0, 0x9D005F68
9D005C1C  24120009   ADDIU S2, ZERO, 9
368:                                         tok_value[i++]=src_line[++inp];
9D005C20  AF9180D4   SW S1, -32556(GP)
9D005C24  02751021   ADDU V0, S3, S5
9D005C28  2403003D   ADDIU V1, ZERO, 61
9D005C2C  A0430000   SB V1, 0(V0)
9D005C30  0B4017DA   J 0x9D005F68
9D005C34  26730001   ADDIU S3, S3, 1
369:                                     }
370:                                     pstate=TOK_END;
371:                                     break;
372:                             case '<':
373:                                     tok_id=RELOP;
9D005C38  2402000C   ADDIU V0, ZERO, 12
9D005C3C  AF8280CC   SW V0, -32564(GP)
374:                                     tok_value[i++]=src_line[inp];
9D005C40  02751021   ADDU V0, S3, S5
9D005C44  2403003C   ADDIU V1, ZERO, 60
9D005C48  A0430000   SB V1, 0(V0)
9D005C4C  26730001   ADDIU S3, S3, 1
375:                                     if (src_line[inp+1]=='='||src_line[inp+1]=='>'){
9D0059C0  3C14A000   LUI S4, -24576
9D0059C4  269421E8   ADDIU S4, S4, 8680
9D005C50  26310001   ADDIU S1, S1, 1
9D005C54  02341021   ADDU V0, S1, S4
9D005C58  80420000   LB V0, 0(V0)
9D005C5C  2443FFC3   ADDIU V1, V0, -61
9D005C60  306300FF   ANDI V1, V1, 255
9D005C64  2C630002   SLTIU V1, V1, 2
9D005C68  106000BF   BEQ V1, ZERO, 0x9D005F68
9D005C6C  24120009   ADDIU S2, ZERO, 9
376:                                         tok_value[i++]=src_line[++inp];
9D005C70  AF9180D4   SW S1, -32556(GP)
9D005C74  02751821   ADDU V1, S3, S5
9D005C78  A0620000   SB V0, 0(V1)
9D005C7C  0B4017DA   J 0x9D005F68
9D005C80  26730001   ADDIU S3, S3, 1
377:                                     }
378:                                     pstate=TOK_END;
379:                                     break;
380:                             case '&':
381:                                     tok_value[i++]=src_line[inp];
9D005C84  02751021   ADDU V0, S3, S5
9D005C88  24030026   ADDIU V1, ZERO, 38
9D005C8C  A0430000   SB V1, 0(V0)
9D005C90  26730001   ADDIU S3, S3, 1
382:                                     pstate=1; // nombre hexadécimal
383:                                     break;
9D005C94  0B4017DA   J 0x9D005F68
9D005C98  24120001   ADDIU S2, ZERO, 1
384:                             default:
385:                                     if (isalpha(src_line[inp])||(src_line[inp]=='_')){
9D005C9C  02008821   ADDU S1, S0, ZERO
9D005CA0  0F405F2E   JAL isalpha
9D005CA4  02002021   ADDU A0, S0, ZERO
9D005CA8  14400005   BNE V0, ZERO, 0x9D005CC0
9D005CAC  24020002   ADDIU V0, ZERO, 2
9D005CB0  2402005F   ADDIU V0, ZERO, 95
9D005CB4  1602000A   BNE S0, V0, 0x9D005CE0
9D005CB8  2602FFD0   ADDIU V0, S0, -48
9D005CD8  0B4017DA   J 0x9D005F68
9D005CDC  24120008   ADDIU S2, ZERO, 8
386:                                         tok_id=SYMBOL;
9D005CBC  24020002   ADDIU V0, ZERO, 2
9D005CC0  AF8280CC   SW V0, -32564(GP)
387:                                         tok_value[i++]=toupper(src_line[inp]);
9D005CC4  0F405EF1   JAL toupper
9D005CC8  02202021   ADDU A0, S1, ZERO
9D005CCC  02751821   ADDU V1, S3, S5
9D005CD0  A0620000   SB V0, 0(V1)
9D005CD4  26730001   ADDIU S3, S3, 1
388:                                         pstate=8; // symbole alphanumérique
389:                                     }else if (isdigit(src_line[inp])){
9D005CE0  2C42000A   SLTIU V0, V0, 10
9D005CE4  10400007   BEQ V0, ZERO, 0x9D005D04
9D005CE8  24020001   ADDIU V0, ZERO, 1
390:                                         tok_id=NUMBER;
9D005CEC  AF8280CC   SW V0, -32564(GP)
391:                                         tok_value[i++]=src_line[inp];
9D005CF0  02751021   ADDU V0, S3, S5
9D005CF4  A0500000   SB S0, 0(V0)
9D005CF8  26730001   ADDIU S3, S3, 1
392:                                         pstate=4; // nombre décimal
9D005CFC  0B4017DA   J 0x9D005F68
9D005D00  24120004   ADDIU S2, ZERO, 4
393:                                     }else{
394:                                         src_error(ERR_SYNTAX);
9D005D04  0F4014D3   JAL src_error
9D005D08  24040001   ADDIU A0, ZERO, 1
395:                                     }
396:                             }//switch
397:                             break;
398:                         case 1: // nombre hexadécimal &H ou binaire &B
399:                             if (src_line[inp]=='H'){
9D005D14  24020048   ADDIU V0, ZERO, 72
9D005D18  16020005   BNE S0, V0, 0x9D005D30
9D005D1C  24020042   ADDIU V0, ZERO, 66
400:                                 tok_id=NUMBER;
9D005D20  24020001   ADDIU V0, ZERO, 1
9D005D24  AF8280CC   SW V0, -32564(GP)
401:                                 pstate=2;
9D005D28  0B4017DA   J 0x9D005F68
9D005D2C  24120002   ADDIU S2, ZERO, 2
402:                             }else if (src_line[inp]=='B'){
9D005D30  16020004   BNE S0, V0, 0x9D005D44
9D005D34  24020001   ADDIU V0, ZERO, 1
403:                                 tok_id=NUMBER;
9D005D38  AF8280CC   SW V0, -32564(GP)
404:                                 pstate=3;
9D005D3C  0B4017DA   J 0x9D005F68
9D005D40  24120003   ADDIU S2, ZERO, 3
405:                             }else{
406:                                 src_error(ERR_SYNTAX);
9D005D44  0F4014D3   JAL src_error
9D005D48  24040001   ADDIU A0, ZERO, 1
407:                             }
408:                             break;
409:                         case 2:    // nombre hexadécimal
410:                             if (isxdigit(src_line[inp])){
9D005D54  0F405F64   JAL isxdigit
9D005D58  02002021   ADDU A0, S0, ZERO
9D005D5C  10400007   BEQ V0, ZERO, 0x9D005D7C
9D005D60  24020020   ADDIU V0, ZERO, 32
411:                                  tok_value[i++]=toupper(src_line[inp]);
9D005D64  0F405EF1   JAL toupper
9D005D68  02002021   ADDU A0, S0, ZERO
9D005D6C  02751821   ADDU V1, S3, S5
9D005D70  A0620000   SB V0, 0(V1)
9D005D74  0B4017DA   J 0x9D005F68
9D005D78  26730001   ADDIU S3, S3, 1
412:                             }else if (src_line[inp]==' '){
9D005D7C  1202007A   BEQ S0, V0, 0x9D005F68
9D005D80  2631FFFF   ADDIU S1, S1, -1
413:                                 //ignore espace
414:                             }else{
415:                                 inp--;
9D005D84  AF9180D4   SW S1, -32556(GP)
416:                                 pstate=TOK_END;
9D005D88  0B4017DA   J 0x9D005F68
9D005D8C  24120009   ADDIU S2, ZERO, 9
417:                             }
418:                             break;
419:                         case 3: // nombre binaire
420:                             if ((src_line[inp]=='1') || (src_line[inp]=='0')){
9D005D90  2602FFD0   ADDIU V0, S0, -48
9D005D94  304200FF   ANDI V0, V0, 255
9D005D98  2C420002   SLTIU V0, V0, 2
9D005D9C  10400005   BEQ V0, ZERO, 0x9D005DB4
9D005DA0  24020020   ADDIU V0, ZERO, 32
421:                                 tok_value[i++]=src_line[inp];
9D005DA4  02751021   ADDU V0, S3, S5
9D005DA8  A0500000   SB S0, 0(V0)
9D005DAC  0B4017DA   J 0x9D005F68
9D005DB0  26730001   ADDIU S3, S3, 1
422:                             }else if (src_line[inp]==' '){
9D005DB4  1202006C   BEQ S0, V0, 0x9D005F68
9D005DB8  2631FFFF   ADDIU S1, S1, -1
423:                                 //ignore espace
424:                             }else{
425:                                 inp--;
9D005DBC  AF9180D4   SW S1, -32556(GP)
426:                                 pstate=TOK_END;
9D005DC0  0B4017DA   J 0x9D005F68
9D005DC4  24120009   ADDIU S2, ZERO, 9
427:                             }
428:                             break;
429:                         case 4: // nombre décimal
430:                             if (isdigit(src_line[inp])){
9D005DC8  2602FFD0   ADDIU V0, S0, -48
9D005DCC  2C42000A   SLTIU V0, V0, 10
9D005DD0  10400005   BEQ V0, ZERO, 0x9D005DE8
9D005DD4  2402002E   ADDIU V0, ZERO, 46
431:                                 tok_value[i++]=src_line[inp];
9D005DD8  02751021   ADDU V0, S3, S5
9D005DDC  A0500000   SB S0, 0(V0)
9D005DE0  0B4017DA   J 0x9D005F68
9D005DE4  26730001   ADDIU S3, S3, 1
432:                             }else if (src_line[inp]=='.'){
9D005DE8  16020006   BNE S0, V0, 0x9D005E04
9D005DEC  02751021   ADDU V0, S3, S5
433:                                 tok_value[i++]=src_line[inp];
9D005DF0  2403002E   ADDIU V1, ZERO, 46
9D005DF4  A0430000   SB V1, 0(V0)
9D005DF8  26730001   ADDIU S3, S3, 1
434:                                 pstate=5;
9D005DFC  0B4017DA   J 0x9D005F68
9D005E00  24120005   ADDIU S2, ZERO, 5
435:                             }else if (toupper(src_line[inp])=='E'){
9D005E04  0F405EF1   JAL toupper
9D005E08  02002021   ADDU A0, S0, ZERO
9D005E0C  24030045   ADDIU V1, ZERO, 69
9D005E10  14430006   BNE V0, V1, 0x9D005E2C
9D005E14  24020020   ADDIU V0, ZERO, 32
436:                                 tok_value[i++]='E';
9D005E18  02751021   ADDU V0, S3, S5
9D005E1C  A0430000   SB V1, 0(V0)
9D005E20  26730001   ADDIU S3, S3, 1
437:                                 pstate=6;
9D005E24  0B4017DA   J 0x9D005F68
9D005E28  24120006   ADDIU S2, ZERO, 6
438:                             }else if (src_line[inp]==' '){
9D005E2C  1202004E   BEQ S0, V0, 0x9D005F68
9D005E30  2631FFFF   ADDIU S1, S1, -1
439:                                 //ignore espace
440:                             }else{
441:                                 inp--;
9D005E34  AF9180D4   SW S1, -32556(GP)
442:                                 pstate=TOK_END;
9D005E38  0B4017DA   J 0x9D005F68
9D005E3C  24120009   ADDIU S2, ZERO, 9
443:                             }
444:                             break;
445:                         case 5: //après le '.'
446:                             if (isdigit(src_line[inp])){
9D005E40  2602FFD0   ADDIU V0, S0, -48
9D005E44  2C42000A   SLTIU V0, V0, 10
9D005E48  10400004   BEQ V0, ZERO, 0x9D005E5C
9D005E4C  02751021   ADDU V0, S3, S5
447:                                 tok_value[i++]=src_line[inp];
9D005E50  A0500000   SB S0, 0(V0)
9D005E54  0B4017DA   J 0x9D005F68
9D005E58  26730001   ADDIU S3, S3, 1
448:                             }else if (toupper(src_line[inp])=='E'){
9D005E5C  0F405EF1   JAL toupper
9D005E60  02002021   ADDU A0, S0, ZERO
9D005E64  24030045   ADDIU V1, ZERO, 69
9D005E68  14430006   BNE V0, V1, 0x9D005E84
9D005E6C  24020020   ADDIU V0, ZERO, 32
449:                                 tok_value[i++]='E';
9D005E70  02751021   ADDU V0, S3, S5
9D005E74  A0430000   SB V1, 0(V0)
9D005E78  26730001   ADDIU S3, S3, 1
450:                                 pstate=6;
9D005E7C  0B4017DA   J 0x9D005F68
9D005E80  24120006   ADDIU S2, ZERO, 6
451:                             }else if (src_line[inp]==' '){
9D005E84  12020038   BEQ S0, V0, 0x9D005F68
9D005E88  2631FFFF   ADDIU S1, S1, -1
452:                                 //ignore espace
453:                             }else{
454:                                 inp--;
9D005E8C  AF9180D4   SW S1, -32556(GP)
455:                                 pstate=TOK_END;
9D005E90  0B4017DA   J 0x9D005F68
9D005E94  24120009   ADDIU S2, ZERO, 9
456:                             }
457:                             break;
458:                         case 6: // après le 'E'
459:                             if (isdigit(src_line[inp])||src_line[inp]=='+'||src_line[inp]=='-'){
9D005E98  2602FFD0   ADDIU V0, S0, -48
9D005E9C  2C42000A   SLTIU V0, V0, 10
9D005EA0  14400007   BNE V0, ZERO, 0x9D005EC0
9D005EA4  02751021   ADDU V0, S3, S5
9D005EA8  2402002B   ADDIU V0, ZERO, 43
9D005EAC  12020003   BEQ S0, V0, 0x9D005EBC
9D005EB0  2402002D   ADDIU V0, ZERO, 45
9D005EB4  16020006   BNE S0, V0, 0x9D005ED0
9D005EB8  00000000   NOP
460:                                 tok_value[i++]=src_line[inp];
9D005EBC  02751021   ADDU V0, S3, S5
9D005EC0  A0500000   SB S0, 0(V0)
9D005EC4  26730001   ADDIU S3, S3, 1
461:                                 pstate=7;
9D005EC8  0B4017DA   J 0x9D005F68
9D005ECC  24120007   ADDIU S2, ZERO, 7
462:                             }else{
463:                                 src_error(ERR_SYNTAX);
9D005ED0  0F4014D3   JAL src_error
9D005ED4  24040001   ADDIU A0, ZERO, 1
464:                             }
465:                             break;
466:                         case 7://après signe ou 1ier décimal
467:                             if (isdigit(src_line[inp])){
9D005EE0  2602FFD0   ADDIU V0, S0, -48
9D005EE4  2C42000A   SLTIU V0, V0, 10
9D005EE8  10400004   BEQ V0, ZERO, 0x9D005EFC
9D005EEC  02751021   ADDU V0, S3, S5
468:                                 tok_value[i++]=src_line[inp];
9D005EF0  A0500000   SB S0, 0(V0)
9D005EF4  0B4017DA   J 0x9D005F68
9D005EF8  26730001   ADDIU S3, S3, 1
469:                             }else if (!isdigit(tok_value[i-1])){
9D005EFC  8042FFFF   LB V0, -1(V0)
9D005F00  2442FFD0   ADDIU V0, V0, -48
9D005F04  2C42000A   SLTIU V0, V0, 10
9D005F08  54400005   BNEL V0, ZERO, 0x9D005F20
9D005F0C  2631FFFF   ADDIU S1, S1, -1
470:                                 src_error(ERR_SYNTAX);
9D005F10  0F4014D3   JAL src_error
9D005F14  24040001   ADDIU A0, ZERO, 1
471:                             }else{
472:                                 inp--;
9D005F20  AF9180D4   SW S1, -32556(GP)
473:                                 pstate=TOK_END;
9D005F24  0B4017DA   J 0x9D005F68
9D005F28  24120009   ADDIU S2, ZERO, 9
474:                             }
475:                             break;
476:                         case 8: // symbole alphanumérique
477:                             if (isalnum(src_line[inp]) || src_line[inp]=='_'){
9D005F2C  0200B821   ADDU S7, S0, ZERO
9D005F30  0F405F28   JAL isalnum
9D005F34  02002021   ADDU A0, S0, ZERO
9D005F38  14400003   BNE V0, ZERO, 0x9D005F48
9D005F3C  2402005F   ADDIU V0, ZERO, 95
9D005F40  16020007   BNE S0, V0, 0x9D005F60
9D005F44  2631FFFF   ADDIU S1, S1, -1
478:                                     tok_value[i++]=toupper(src_line[inp]);
9D0059B0  3C15A000   LUI S5, -24576
9D0059B4  26B521C4   ADDIU S5, S5, 8644
9D005F48  0F405EF1   JAL toupper
9D005F4C  02E02021   ADDU A0, S7, ZERO
9D005F50  02751821   ADDU V1, S3, S5
9D005F54  A0620000   SB V0, 0(V1)
9D005F58  0B4017DA   J 0x9D005F68
9D005F5C  26730001   ADDIU S3, S3, 1
479:                             }else{
480:                                 inp--;
9D005F60  AF9180D4   SW S1, -32556(GP)
481:                                 pstate=TOK_END;
9D005F64  24120009   ADDIU S2, ZERO, 9
482:                             }
483:                             break;
484:                         }//switch
485:                         inp++;
9D005D0C  0B4017DB   J 0x9D005F6C
9D005D10  8F9180D4   LW S1, -32556(GP)
9D005D4C  0B4017DB   J 0x9D005F6C
9D005D50  8F9180D4   LW S1, -32556(GP)
9D005ED8  0B4017DB   J 0x9D005F6C
9D005EDC  8F9180D4   LW S1, -32556(GP)
9D005F18  0B4017DB   J 0x9D005F6C
9D005F1C  8F9180D4   LW S1, -32556(GP)
9D005F68  8F9180D4   LW S1, -32556(GP)
9D005F6C  26310001   ADDIU S1, S1, 1
9D005F70  AF9180D4   SW S1, -32556(GP)
486:                     }//while
487:                     tok_value[i]=0;
9D005F94  3C05A000   LUI A1, -24576
9D005F98  24A521C4   ADDIU A1, A1, 8644
9D005F9C  02659821   ADDU S3, S3, A1
9D005FA0  A2600000   SB ZERO, 0(S3)
488:                 #if defined _DEBUG_
489:                     UartPrint(STDOUT,tok_value);
9D005FA4  0F40403A   JAL UartPrint
9D005FA8  24040001   ADDIU A0, ZERO, 1
490:                     UartPutch(STDOUT,'\r');
9D005FAC  24040001   ADDIU A0, ZERO, 1
9D005FB0  0F404002   JAL UartPutch
9D005FB4  2405000D   ADDIU A1, ZERO, 13
491:                 #endif
492:                 }// word()
9D005FB8  8FBF0034   LW RA, 52(SP)
9D005FBC  8FBE0030   LW S8, 48(SP)
9D005FC0  8FB7002C   LW S7, 44(SP)
9D005FC4  8FB60028   LW S6, 40(SP)
9D005FC8  8FB50024   LW S5, 36(SP)
9D005FCC  8FB40020   LW S4, 32(SP)
9D005FD0  8FB3001C   LW S3, 28(SP)
9D005FD4  8FB20018   LW S2, 24(SP)
9D005FD8  8FB10014   LW S1, 20(SP)
9D005FDC  8FB00010   LW S0, 16(SP)
9D005FE0  03E00008   JR RA
9D005FE4  27BD0038   ADDIU SP, SP, 56
493:                 
494:                 // cherche un chaîne dans un liste.
495:                 // paramètres:
496:                 //  s chaine recherchée
497:                 //  list liste de chaines
498:                 //  size  nombre d'items dans la liste
499:                 // renvoie:
500:                 //   -1 si pas trouvé dans la liste
501:                 //   l'index si trouvé.
502:                 int search_list(char *s,const char *list[], int size){
9D006038  01434821   ADDU T1, T2, V1
503:                     int i,j;
504:                     char *target;
505:                     const char *item;
506:                     BOOL match;
507:                      for (i=0;i<size;i++){
9D005FE8  18C00021   BLEZ A2, 0x9D006070
9D005FEC  2402FFFF   ADDIU V0, ZERO, -1
9D005FF4  00001021   ADDU V0, ZERO, ZERO
9D006048  24420001   ADDIU V0, V0, 1
9D00604C  1446FFEA   BNE V0, A2, 0x9D005FF8
9D006050  24A50004   ADDIU A1, A1, 4
508:                          target=s;
9D006014  00803821   ADDU A3, A0, ZERO
509:                          match=FALSE;
510:                          item = list[i];
511:                          j=0;
9D006018  0B40180A   J 0x9D006028
9D00601C  00001821   ADDU V1, ZERO, ZERO
9D00605C  00001821   ADDU V1, ZERO, ZERO
512:                          while (*target && item[j]){
9D005FF0  808B0000   LB T3, 0(A0)
9D005FF8  11600018   BEQ T3, ZERO, 0x9D00605C
9D005FFC  8CAA0000   LW T2, 0(A1)
9D006000  81430000   LB V1, 0(T2)
9D006004  50600011   BEQL V1, ZERO, 0x9D00604C
9D006008  24420001   ADDIU V0, V0, 1
9D00602C  80E80000   LB T0, 0(A3)
9D006030  1100000B   BEQ T0, ZERO, 0x9D006060
9D006034  24630001   ADDIU V1, V1, 1
9D00603C  81290000   LB T1, 0(T1)
9D006040  1520FFF7   BNE T1, ZERO, 0x9D006020
9D006044  00000000   NOP
513:                              if (!(*target==item[j])) break;
9D00600C  5563000F   BNEL T3, V1, 0x9D00604C
9D006010  24420001   ADDIU V0, V0, 1
9D006020  5509000A   BNEL T0, T1, 0x9D00604C
9D006024  24420001   ADDIU V0, V0, 1
514:                              target++;
9D006028  24E70001   ADDIU A3, A3, 1
515:                              j++;
516:                          }
517:                          if (!*target && !item[j]){
9D006060  01431821   ADDU V1, T2, V1
9D006064  80630000   LB V1, 0(V1)
9D006068  5460FFF8   BNEL V1, ZERO, 0x9D00604C
9D00606C  24420001   ADDIU V0, V0, 1
9D006070  03E00008   JR RA
9D006074  00000000   NOP
518:                              match=TRUE;
519:                              break;
520:                          }
521:                      }
522:                     return match?i:-1;
523:                 }//f()
9D006054  03E00008   JR RA
9D006058  2402FFFF   ADDIU V0, ZERO, -1
524:                 
525:                 
526:                 
527:                 
528:                 float parse_number(char *nstr){
529:                 
530:                 }//parse_number()
9D006078  03E00008   JR RA
9D00607C  00000000   NOP
531:                 
532:                 
533:                 unsigned search_symbol(char *name, symb_t *s){
9D006080  27BDFFE0   ADDIU SP, SP, -32
9D006084  AFBF001C   SW RA, 28(SP)
9D006088  AFB20018   SW S2, 24(SP)
9D00608C  AFB10014   SW S1, 20(SP)
9D006090  AFB00010   SW S0, 16(SP)
9D006094  00809021   ADDU S2, A0, ZERO
9D006098  00A08821   ADDU S1, A1, ZERO
534:                     unsigned i=SYMB_BASE;
9D0060B4  3C100001   LUI S0, 1
9D0060B8  3610A000   ORI S0, S0, -24576
535:                 
536:                     while (i<symb_free){
9D00609C  3C020001   LUI V0, 1
9D0060A0  3442A001   ORI V0, V0, -24575
9D0060A4  8F8380E8   LW V1, -32536(GP)
9D0060A8  0062102B   SLTU V0, V1, V0
9D0060AC  14400011   BNE V0, ZERO, 0x9D0060F4
9D0060B0  2410FFFF   ADDIU S0, ZERO, -1
9D0060E4  0202102B   SLTU V0, S0, V0
9D0060E8  1440FFF5   BNE V0, ZERO, 0x9D0060C0
9D0060EC  02002021   ADDU A0, S0, ZERO
537:                         sram_read_block(i,(char*)s,sizeof(symb_t));
9D0060BC  02002021   ADDU A0, S0, ZERO
9D0060C0  02202821   ADDU A1, S1, ZERO
9D0060C4  0F4032C1   JAL sram_read_block
9D0060C8  24060028   ADDIU A2, ZERO, 40
538:                         if (!strcmp(s->name,name)) return i;
9D0060CC  02202021   ADDU A0, S1, ZERO
9D0060D0  0F4052EE   JAL 0x9D014BB8
9D0060D4  02402821   ADDU A1, S2, ZERO
9D0060D8  10400006   BEQ V0, ZERO, 0x9D0060F4
9D0060DC  8F8280E8   LW V0, -32536(GP)
539:                         i += sizeof(symb_t);
9D0060E0  26100028   ADDIU S0, S0, 40
540:                     }
541:                     return -1;
9D0060F0  2410FFFF   ADDIU S0, ZERO, -1
542:                 }
9D0060F4  02001021   ADDU V0, S0, ZERO
9D0060F8  8FBF001C   LW RA, 28(SP)
9D0060FC  8FB20018   LW S2, 24(SP)
9D006100  8FB10014   LW S1, 20(SP)
9D006104  8FB00010   LW S0, 16(SP)
9D006108  03E00008   JR RA
9D00610C  27BD0020   ADDIU SP, SP, 32
543:                 
544:                 BOOL add_symbol(char *name, eSymbol_t class, unsigned addr){
9D006110  27BDFFB8   ADDIU SP, SP, -72
9D006114  AFBF0044   SW RA, 68(SP)
9D006118  AFB20040   SW S2, 64(SP)
9D00611C  AFB1003C   SW S1, 60(SP)
9D006120  AFB00038   SW S0, 56(SP)
9D006124  00809021   ADDU S2, A0, ZERO
9D006128  00A08021   ADDU S0, A1, ZERO
9D00612C  00C08821   ADDU S1, A2, ZERO
545:                     unsigned i;
546:                     symb_t s;
547:                     
548:                     i=search_symbol(name, &s);
9D006130  0F401820   JAL search_symbol
9D006134  27A50010   ADDIU A1, SP, 16
549:                     if (i==-1){
9D006138  2403FFFF   ADDIU V1, ZERO, -1
9D00613C  1443000F   BNE V0, V1, 0x9D00617C
9D006140  8384804C   LB A0, -32692(GP)
550:                         s.class=class;
9D006144  AFB00030   SW S0, 48(SP)
551:                         strcpy(s.name,name);
9D006148  27A40010   ADDIU A0, SP, 16
9D00614C  0F404EAF   JAL 0x9D013ABC
9D006150  02402821   ADDU A1, S2, ZERO
552:                         s.addr=addr;
9D006154  AFB10034   SW S1, 52(SP)
553:                         sram_write_block(symb_free,(char*)&s,sizeof(symb_t));
9D006158  8F8480E8   LW A0, -32536(GP)
9D00615C  27A50010   ADDIU A1, SP, 16
9D006160  0F4032E6   JAL sram_write_block
9D006164  24060028   ADDIU A2, ZERO, 40
554:                         symb_free  +=sizeof(symb_t);
9D006168  8F8280E8   LW V0, -32536(GP)
9D00616C  24420028   ADDIU V0, V0, 40
9D006170  AF8280E8   SW V0, -32536(GP)
555:                         return TRUE;
9D006174  0B401863   J 0x9D00618C
9D006178  24020001   ADDIU V0, ZERO, 1
556:                     }
557:                     print(comm_channel,"Duplicate symbol\r");
9D00617C  3C059D01   LUI A1, -25343
9D006180  0F40229C   JAL print
9D006184  24A54F44   ADDIU A1, A1, 20292
558:                     return FALSE;
9D006188  00001021   ADDU V0, ZERO, ZERO
559:                 }
9D00618C  8FBF0044   LW RA, 68(SP)
9D006190  8FB20040   LW S2, 64(SP)
9D006194  8FB1003C   LW S1, 60(SP)
9D006198  8FB00038   LW S0, 56(SP)
9D00619C  03E00008   JR RA
9D0061A0  27BD0048   ADDIU SP, SP, 72
560:                 
561:                 void statement(){
9D0061A4  27BDFFC8   ADDIU SP, SP, -56
9D0061A8  AFBF0034   SW RA, 52(SP)
9D0061AC  AFB00030   SW S0, 48(SP)
562:                     int i=-1;
563:                     char name[NAME_LEN];
564:                     unsigned addr;
565:                     eSymbol_t class;
566:                 
567:                     name[0]=0;
568:                     next_token();
9D0061B0  0F401651   JAL 0x9D005944
9D0061B4  A3A00010   SB ZERO, 16(SP)
569:                     if (!(tok_id==NUMBER || tok_id==SYMBOL)){
9D0061B8  8F8280CC   LW V0, -32564(GP)
9D0061BC  2443FFFF   ADDIU V1, V0, -1
9D0061C0  2C630002   SLTIU V1, V1, 2
9D0061C4  14600005   BNE V1, ZERO, 0x9D0061DC
9D0061C8  24030002   ADDIU V1, ZERO, 2
570:                         src_error(ERR_SYNTAX);
9D0061CC  0F4014D3   JAL src_error
9D0061D0  24040001   ADDIU A0, ZERO, 1
571:                         return;
9D0061D4  0B4018B1   J 0x9D0062C4
9D0061D8  8FBF0034   LW RA, 52(SP)
572:                     }
573:                     if (tok_id==SYMBOL){
9D0061DC  1443000B   BNE V0, V1, 0x9D00620C
9D0061E0  27A40010   ADDIU A0, SP, 16
574:                         i=search_list(tok_value,statements,STATEMENTS_COUNT);
9D0061E4  3C04A000   LUI A0, -24576
9D0061E8  248421C4   ADDIU A0, A0, 8644
9D0061EC  3C05A000   LUI A1, -24576
9D0061F0  24A52A30   ADDIU A1, A1, 10800
9D0061F4  0F4017FA   JAL search_list
9D0061F8  24060012   ADDIU A2, ZERO, 18
575:                     }
576:                     if (tok_id==NUMBER || i==-1){
9D0061FC  2403FFFF   ADDIU V1, ZERO, -1
9D006200  14430017   BNE V0, V1, 0x9D006260
9D006204  2C420012   SLTIU V0, V0, 18
577:                         strcpy(name,tok_value);
9D006208  27A40010   ADDIU A0, SP, 16
9D00620C  3C05A000   LUI A1, -24576
9D006210  0F404EAF   JAL 0x9D013ABC
9D006214  24A521C4   ADDIU A1, A1, 8644
578:                         addr=(unsigned)here;
579:                         class=LABEL;
580:                         next_token();
9D006218  0F401651   JAL 0x9D005944
9D00621C  8F9080F8   LW S0, -32520(GP)
581:                         if (tok_id!=SYMBOL || (i=search_list(tok_value,statements,STATEMENTS_COUNT))==-1){
9D006220  24020002   ADDIU V0, ZERO, 2
9D006224  8F8380CC   LW V1, -32564(GP)
9D006228  14620009   BNE V1, V0, 0x9D006250
9D00622C  3C05A000   LUI A1, -24576
9D006230  3C04A000   LUI A0, -24576
9D006234  248421C4   ADDIU A0, A0, 8644
9D006238  24A52A30   ADDIU A1, A1, 10800
9D00623C  0F4017FA   JAL search_list
9D006240  24060012   ADDIU A2, ZERO, 18
9D006244  2403FFFF   ADDIU V1, ZERO, -1
9D006248  14430005   BNE V0, V1, 0x9D006260
9D00624C  2C420012   SLTIU V0, V0, 18
582:                             src_error(ERR_SYNTAX);
9D006250  0F4014D3   JAL src_error
9D006254  24040001   ADDIU A0, ZERO, 1
583:                             return;
9D006258  0B4018B1   J 0x9D0062C4
9D00625C  8FBF0034   LW RA, 52(SP)
584:                         }
585:                         //add_symbol(name,LABEL,(unsigned)here);
586:                     }
587:                     switch (i){
9D006260  14400005   BNE V0, ZERO, 0x9D006278
9D006264  8F8280F0   LW V0, -32528(GP)
588:                         case CHANGE:
589:                             compile_change();
590:                             break;
591:                         case DATA:
592:                             compile_data();
593:                             break;
594:                         case DEF:
595:                             compile_def();
596:                             break;
597:                         case DIM:
598:                             compile_dim();
599:                             break;
600:                         case END:
601:                             compile_end();
602:                             break;
603:                         case FOR:
604:                             compile_for();
605:                             break;
606:                         case GOSUB:
607:                             compile_gosub();
608:                             break;
609:                         case GOTO:
610:                             compile_goto();
611:                             break;
612:                         case IF:
613:                             compile_if();
614:                             break;
615:                         case INPUT:
616:                             compile_input();
617:                             break;
618:                         case LET:
619:                             compile_let();
620:                             break;
621:                         case ON:
622:                             compile_on();
623:                             break;
624:                         case PRINT:
625:                             compile_print();
626:                             break;
627:                         case READ:
628:                             compile_read();
629:                             break;
630:                         case REM:
631:                             break;
632:                         case RESTORE:
633:                             compile_restore();
634:                             break;
635:                         case RETURN:
636:                             compile_return();
637:                             break;
638:                         case STOP:
639:                             compile_stop();
640:                             break;
641:                         default:
642:                             src_error(ERR_SYNTAX);
9D006268  0F4014D3   JAL src_error
9D00626C  24040001   ADDIU A0, ZERO, 1
643:                             return;
9D006270  0B4018B1   J 0x9D0062C4
9D006274  8FBF0034   LW RA, 52(SP)
644:                     }
645:                     if (error) return;
9D006278  14400011   BNE V0, ZERO, 0x9D0062C0
9D00627C  83A20010   LB V0, 16(SP)
646:                 success: // si déclaration BASIC est correcte on la sauvegarde dans la SPIRAM
647:                     if (name[0])add_symbol(name,class,addr);
9D006280  50400006   BEQL V0, ZERO, 0x9D00629C
9D006284  8F8480D8   LW A0, -32552(GP)
9D006288  27A40010   ADDIU A0, SP, 16
9D00628C  00002821   ADDU A1, ZERO, ZERO
9D006290  0F401844   JAL add_symbol
9D006294  02003021   ADDU A2, S0, ZERO
648:                     sram_write_string(src_end,src_line);
9D006298  8F8480D8   LW A0, -32552(GP)
9D00629C  3C10A000   LUI S0, -24576
9D0062A0  0F40330B   JAL sram_write_string
9D0062A4  260521E8   ADDIU A1, S0, 8680
649:                     src_end += strlen(src_line)+1;
9D0062A8  0F40514F   JAL 0x9D01453C
9D0062AC  260421E8   ADDIU A0, S0, 8680
9D0062B0  8F8380D8   LW V1, -32552(GP)
9D0062B4  24630001   ADDIU V1, V1, 1
9D0062B8  00621021   ADDU V0, V1, V0
9D0062BC  AF8280D8   SW V0, -32552(GP)
650:                 }
9D0062C0  8FBF0034   LW RA, 52(SP)
9D0062C4  8FB00030   LW S0, 48(SP)
9D0062C8  03E00008   JR RA
9D0062CC  27BD0038   ADDIU SP, SP, 56
651:                 
652:                 
653:                 void run(){
654:                 
655:                 }
9D0062D0  03E00008   JR RA
9D0062D4  00000000   NOP
656:                 
657:                 void compile_run(){ // analyse le contenu de TIB
9D0062D8  27BDFFE8   ADDIU SP, SP, -24
9D0062DC  AFBF0014   SW RA, 20(SP)
658:                     error=ERR_NONE;
9D0062E0  AF8080F0   SW ZERO, -32528(GP)
659:                     if (src_line[0]==' ' || isdigit(src_line[0])) state=COMPILE; else state=IMMEDIATE;
9D0062E4  3C02A000   LUI V0, -24576
9D0062E8  804221E8   LB V0, 8680(V0)
9D0062EC  24030020   ADDIU V1, ZERO, 32
9D0062F0  10430004   BEQ V0, V1, 0x9D006304
9D0062F4  2442FFD0   ADDIU V0, V0, -48
9D0062F8  2C42000A   SLTIU V0, V0, 10
9D0062FC  50400003   BEQL V0, ZERO, 0x9D00630C
9D006300  AF8080DC   SW ZERO, -32548(GP)
9D006304  24020001   ADDIU V0, ZERO, 1
9D006308  AF8280DC   SW V0, -32548(GP)
660:                     if (src_end>=SYMB_BASE){
9D00630C  3C020001   LUI V0, 1
9D006310  3442A000   ORI V0, V0, -24576
9D006314  8F8380D8   LW V1, -32552(GP)
9D006318  0062102B   SLTU V0, V1, V0
9D00631C  14400006   BNE V0, ZERO, 0x9D006338
9D006320  8384804C   LB A0, -32692(GP)
661:                         print(comm_channel,"source memory filled.");
9D006324  3C059D01   LUI A1, -25343
9D006328  0F40229C   JAL print
9D00632C  24A54F58   ADDIU A1, A1, 20312
662:                         return;
9D006330  0B4018D2   J 0x9D006348
9D006334  8FBF0014   LW RA, 20(SP)
663:                     }
664:                     statement();
9D006338  0F401869   JAL statement
9D00633C  00000000   NOP
665:                     if (state=IMMEDIATE) run();
9D006340  AF8080DC   SW ZERO, -32548(GP)
666:                 }// compile_run()
9D006344  8FBF0014   LW RA, 20(SP)
9D006348  03E00008   JR RA
9D00634C  27BD0018   ADDIU SP, SP, 24
667:                 
668:                 
669:                 void list_source(){
9D006350  27BDFFD0   ADDIU SP, SP, -48
9D006354  AFBF002C   SW RA, 44(SP)
9D006358  AFB60028   SW S6, 40(SP)
9D00635C  AFB50024   SW S5, 36(SP)
9D006360  AFB40020   SW S4, 32(SP)
9D006364  AFB3001C   SW S3, 28(SP)
9D006368  AFB20018   SW S2, 24(SP)
9D00636C  AFB10014   SW S1, 20(SP)
9D006370  AFB00010   SW S0, 16(SP)
670:                     char *in,*out;
671:                     unsigned addr=SRC_BASE;
9D0063AC  3C100001   LUI S0, 1
672:                     unsigned line_no=0;
673:                 
674:                     in = malloc(80);
9D006374  0F4047DE   JAL malloc
9D006378  24040050   ADDIU A0, ZERO, 80
9D00637C  0040A821   ADDU S5, V0, ZERO
9D006380  00409821   ADDU S3, V0, ZERO
675:                     out = malloc(80);
9D006384  0F4047DE   JAL malloc
9D006388  24040050   ADDIU A0, ZERO, 80
9D00638C  0040B021   ADDU S6, V0, ZERO
9D006390  00409021   ADDU S2, V0, ZERO
676:                     while (addr<src_end){
9D006394  3C020001   LUI V0, 1
9D006398  24420001   ADDIU V0, V0, 1
9D00639C  8F8380D8   LW V1, -32552(GP)
9D0063A0  0062102B   SLTU V0, V1, V0
9D0063A4  14400017   BNE V0, ZERO, 0x9D006404
9D0063A8  00008821   ADDU S1, ZERO, ZERO
9D0063F4  8F8280D8   LW V0, -32552(GP)
9D0063F8  0202102B   SLTU V0, S0, V0
9D0063FC  1440FFEF   BNE V0, ZERO, 0x9D0063BC
9D006400  02002021   ADDU A0, S0, ZERO
677:                         addr+=sram_read_string(addr,in,CHAR_PER_LINE+1)+1;
9D0063B8  02002021   ADDU A0, S0, ZERO
9D0063BC  02602821   ADDU A1, S3, ZERO
9D0063C0  0F40332D   JAL sram_read_string
9D0063C4  24060036   ADDIU A2, ZERO, 54
9D0063C8  24420001   ADDIU V0, V0, 1
9D0063CC  02028021   ADDU S0, S0, V0
678:                         line_no++;
9D0063D0  26310001   ADDIU S1, S1, 1
679:                         sprintf(out,"%4d %s",line_no,in);
9D0063B0  3C149D01   LUI S4, -25343
9D0063B4  26944F70   ADDIU S4, S4, 20336
9D0063D4  02402021   ADDU A0, S2, ZERO
9D0063D8  02802821   ADDU A1, S4, ZERO
9D0063DC  02203021   ADDU A2, S1, ZERO
9D0063E0  0F405BB0   JAL _sprintf_cdnopsuxX
9D0063E4  02603821   ADDU A3, S3, ZERO
680:                 //        print_int(comm_channel, line_no,0);
681:                         println(comm_channel,out);
9D0063E8  8384804C   LB A0, -32692(GP)
9D0063EC  0F4022B3   JAL println
9D0063F0  02402821   ADDU A1, S2, ZERO
682:                     }
683:                     free(in);
9D006404  0F405E55   JAL free
9D006408  02A02021   ADDU A0, S5, ZERO
684:                     free(out);
9D00640C  0F405E55   JAL free
9D006410  02C02021   ADDU A0, S6, ZERO
685:                 }
9D006414  8FBF002C   LW RA, 44(SP)
9D006418  8FB60028   LW S6, 40(SP)
9D00641C  8FB50024   LW S5, 36(SP)
9D006420  8FB40020   LW S4, 32(SP)
9D006424  8FB3001C   LW S3, 28(SP)
9D006428  8FB20018   LW S2, 24(SP)
9D00642C  8FB10014   LW S1, 20(SP)
9D006430  8FB00010   LW S0, 16(SP)
9D006434  03E00008   JR RA
9D006438  27BD0030   ADDIU SP, SP, 48
686:                 
687:                 
688:                 BOOL bRun;
689:                 
690:                 #define CMD_COUNT (6)
691:                 
692:                 static const char *cmd_list[CMD_COUNT]={
693:                     "RUN",
694:                     "LIST",
695:                     "LOAD",
696:                     "SAVE",
697:                     "BYE",
698:                     "CLEAR"
699:                 };
700:                 
701:                 BOOL command(){
9D00643C  27BDFFE8   ADDIU SP, SP, -24
9D006440  AFBF0014   SW RA, 20(SP)
702:                     int i;
703:                     inp=0;
704:                     next_token();
9D006444  0F401651   JAL 0x9D005944
9D006448  AF8080D4   SW ZERO, -32556(GP)
705:                     if ((i=search_list(tok_value,cmd_list,CMD_COUNT))==-1){
9D00644C  3C04A000   LUI A0, -24576
9D006450  248421C4   ADDIU A0, A0, 8644
9D006454  3C05A000   LUI A1, -24576
9D006458  24A52A18   ADDIU A1, A1, 10776
9D00645C  0F4017FA   JAL search_list
9D006460  24060006   ADDIU A2, ZERO, 6
9D006464  2403FFFF   ADDIU V1, ZERO, -1
9D006468  14430004   BNE V0, V1, 0x9D00647C
9D00646C  24030004   ADDIU V1, ZERO, 4
706:                         inp=0;
9D006470  AF8080D4   SW ZERO, -32556(GP)
707:                         return FALSE;
9D006474  0B40192F   J 0x9D0064BC
9D006478  00001021   ADDU V0, ZERO, ZERO
708:                     }
709:                     switch(i){
9D00647C  10430009   BEQ V0, V1, 0x9D0064A4
9D006480  24030005   ADDIU V1, ZERO, 5
9D006484  1043000A   BEQ V0, V1, 0x9D0064B0
9D006488  24030001   ADDIU V1, ZERO, 1
9D00648C  5443000B   BNEL V0, V1, 0x9D0064BC
9D006490  24020001   ADDIU V0, ZERO, 1
710:                         case 0: //RUN
711:                             break;
712:                         case 1: // LIST
713:                             list_source();
9D006494  0F4018D4   JAL list_source
9D006498  00000000   NOP
714:                             break;
9D00649C  0B40192F   J 0x9D0064BC
9D0064A0  24020001   ADDIU V0, ZERO, 1
715:                         case 2: // LOAD
716:                             break;
717:                         case 3: // SAVE
718:                             break;
719:                         case 4: // BYE
720:                             bRun=FALSE;
9D0064A4  AF8080F4   SW ZERO, -32524(GP)
721:                             break;
9D0064A8  0B40192F   J 0x9D0064BC
9D0064AC  24020001   ADDIU V0, ZERO, 1
722:                         case 5: // CLEAR
723:                             src_end=SRC_BASE;
9D0064B0  3C020001   LUI V0, 1
9D0064B4  AF8280D8   SW V0, -32552(GP)
9D0064B8  24020001   ADDIU V0, ZERO, 1
724:                             break;
725:                     }//switch
726:                     return TRUE;
727:                 }
9D0064BC  8FBF0014   LW RA, 20(SP)
9D0064C0  03E00008   JR RA
9D0064C4  27BD0018   ADDIU SP, SP, 24
728:                 
729:                 
730:                 void vpcBasic(){ 
9D0064C8  27BDFFE0   ADDIU SP, SP, -32
9D0064CC  AFBF001C   SW RA, 28(SP)
9D0064D0  AFB20018   SW S2, 24(SP)
9D0064D4  AFB10014   SW S1, 20(SP)
731:                     ram_free=free_heap()-1024;
9D0064D8  0F403E99   JAL free_heap
9D0064DC  AFB00010   SW S0, 16(SP)
9D0064E0  2442FC00   ADDIU V0, V0, -1024
9D0064E4  AF8280D0   SW V0, -32560(GP)
732:                     print(comm_channel,"code space: ");
9D0064E8  8384804C   LB A0, -32692(GP)
9D0064EC  3C059D01   LUI A1, -25343
9D0064F0  0F40229C   JAL print
9D0064F4  24A54F78   ADDIU A1, A1, 20344
733:                     print_int(comm_channel,ram_free,0);
9D0064F8  8384804C   LB A0, -32692(GP)
9D0064FC  8F8580D0   LW A1, -32560(GP)
9D006500  0F4022E0   JAL print_int
9D006504  00003021   ADDU A2, ZERO, ZERO
734:                     crlf();
9D006508  0F4021F6   JAL crlf
9D00650C  3C119D01   LUI S1, -25343
735:                     ram_code=malloc(ram_free);
9D006510  8F9080D0   LW S0, -32560(GP)
9D006514  0F4047DE   JAL malloc
9D006518  02002021   ADDU A0, S0, ZERO
9D00651C  AF8280FC   SW V0, -32516(GP)
736:                     here=ram_code;
9D006520  AF8280F8   SW V0, -32520(GP)
737:                     vars=ram_code+ram_free;
9D006524  00508021   ADDU S0, V0, S0
9D006528  AF9080EC   SW S0, -32532(GP)
738:                     bRun=TRUE;
9D00652C  24020001   ADDIU V0, ZERO, 1
9D006530  AF8280F4   SW V0, -32524(GP)
739:                     src_end=SRC_BASE;
9D006534  3C020001   LUI V0, 1
9D006538  AF8280D8   SW V0, -32552(GP)
740:                     while (bRun){
9D006544  0B401962   J 0x9D006588
9D006548  261221E8   ADDIU S2, S0, 8680
9D006588  8F8280F4   LW V0, -32524(GP)
9D00658C  1440FFEF   BNE V0, ZERO, 0x9D00654C
9D006590  8384804C   LB A0, -32692(GP)
741:                         print(comm_channel,">");
9D00653C  26314F88   ADDIU S1, S1, 20360
9D00654C  0F40229C   JAL print
9D006550  02202821   ADDU A1, S1, ZERO
742:                         readline(comm_channel,src_line,CHAR_PER_LINE);
9D006540  3C10A000   LUI S0, -24576
9D006554  8384804C   LB A0, -32692(GP)
9D006558  02402821   ADDU A1, S2, ZERO
9D00655C  0F4023F1   JAL readline
9D006560  24060035   ADDIU A2, ZERO, 53
743:                         if (strlen(src_line) && !command()) compile_run();
9D006564  820221E8   LB V0, 8680(S0)
9D006568  10400008   BEQ V0, ZERO, 0x9D00658C
9D00656C  8F8280F4   LW V0, -32524(GP)
9D006570  0F40190F   JAL command
9D006574  00000000   NOP
9D006578  14400004   BNE V0, ZERO, 0x9D00658C
9D00657C  8F8280F4   LW V0, -32524(GP)
9D006580  0F4018B6   JAL compile_run
9D006584  00000000   NOP
744:                     }// while(1)
745:                     free(ram_code);
9D006594  0F405E55   JAL free
9D006598  8F8480FC   LW A0, -32516(GP)
746:                 }//vpcBasic()
9D00659C  8FBF001C   LW RA, 28(SP)
9D0065A0  8FB20018   LW S2, 24(SP)
9D0065A4  8FB10014   LW S1, 20(SP)
9D0065A8  8FB00010   LW S0, 16(SP)
9D0065AC  03E00008   JR RA
9D0065B0  27BD0020   ADDIU SP, SP, 32
---  /home/jacques/MPLABXProjects/vpc-32/vpcBASIC/vm.S  -------------------------------------------------
                                                  1:     /*  Nom: vm.S
                                                  2:      *  Auteur: Jacques Deschênes
                                                  3:      *  Description:
                                                  4:      *      machine viruelle à piles qui exécute du bytecode.
                                                  5:      *      le programme utilisant la VM doit l'appellé en utilisant le prototype de
                                                  6:      *      fonction suivant: void StackVM( char *ip, int* user);
                                                  7:      *         ip pointe vers le bytecode à exécuter
                                                  8:      *         user pointe vers un tableau de variables utilisé par le programme.
                                                  9:      */
                                                  10:    
                                                  11:    #include <p32xxxx.h>
                                                  12:    #include "vm.h"
                                                  13:    
                                                  14:    
                                                  15:    .extern UartPutch
                                                  16:    .extern UartGetch
                                                  17:    .extern UartWaitch
                                                  18:    .extern sys_tick
                                                  19:    .extern print_integer
                                                  20:    .extern print_float
                                                  21:    .extern rnd
                                                  22:    //math fonctions
                                                  23:    .extern sinf
                                                  24:    .extern cosf
                                                  25:    .extern tanf
                                                  26:    .extern acosf
                                                  27:    .extern asinf
                                                  28:    .extern atanf
                                                  29:    .extern sqrtf
                                                  30:    .extern fabsf
                                                  31:    .extern powf
                                                  32:    .extern expf
                                                  33:    .extern logf
                                                  34:    .extern log10f
                                                  35:    .extern rintf
                                                  36:    .extern floorf
                                                  37:    .extern ceilf
                                                  38:    
                                                  39:    
                                                  40:    #define _getch UartGetch
                                                  41:    #define _putch UartPutch
                                                  42:    #define _print UartPrint
                                                  43:    #define _readln UartReadln
                                                  44:    #define _key   UartWaitch
                                                  45:    
                                                  46:    
                                                  47:    /*************** macros *************/
                                                  48:    
                                                  49:    .macro _tpush
                                                  50:    addiu dp,dp, CELL_SIZE
                                                  51:    sw T, 0(dp)
                                                  52:    .endm
                                                  53:    
                                                  54:    .macro _tpop
                                                  55:    lw T, 0(dp)
                                                  56:    addiu dp,dp,-CELL_SIZE
                                                  57:    .endm
                                                  58:    
                                                  59:    .macro _rpush
                                                  60:    addiu rp,rp,CELL_SIZE
                                                  61:    sw R, 0(rp)
                                                  62:    .endm
                                                  63:    
                                                  64:    .macro _rpop
                                                  65:    lw R, 0(rp)
                                                  66:    addiu rp,rp,-CELL_SIZE
                                                  67:    .endm
                                                  68:    
                                                  69:    .macro _next
                                                  70:    addiu ip,ip,1
                                                  71:    .endm
                                                  72:    
                                                  73:    
                                                  74:    /* utilisation des regitres MIPS */
                                                  75:    ip=s0  /* pointeur d'instruction VM */
                                                  76:    dp=s1  /* pointeur pile de données */
                                                  77:    rp=s2  /* pointeur pile de contrôle */
                                                  78:    w=s3  /* pointeur de travail */
                                                  79:    T=s4  /* sommet de la pile des données */
                                                  80:    R=s5  /* sommet de la pile des retours */
                                                  81:    U=s6  /* pointeur variables utilisateur */
                                                  82:    X=s7  /* compteur de boucle */
                                                  83:    
                                                  84:    
                                                  85:    
                                                  86:    STDIO=1
                                                  87:    
                                                  88:    DSTACK_SIZE=80
                                                  89:    RSTACK_SIZE=64
                                                  90:    
                                                  91:    SFR_CLEAR=4
                                                  92:    SFR_SET=8
                                                  93:    SFR_INV=12
                                                  94:    
                                                  95:    
                                                  96:    .bss
                                                  97:    
                                                  98:    # piles
                                                  99:    dstack: .space DSTACK_SIZE
                                                  100:   rstack: .space RSTACK_SIZE
                                                  101:   
                                                  102:   .text
                                                  103:   .align 2, 0xff
                                                  104:   .set noreorder
                                                  105:   .set macro
                                                  106:   
                                                  107:   
                                                  108:   .global StackVM
                                                  109:   
                                                  110:   .ent StackVM
                                                  111:   
                                                  112:   
                                                  113:   StackVM:  # initialisation
9D00A6F8  27BDFFD8   ADDIU SP, SP, -40            114:       addiu sp, sp, -40 // save registers
9D00A6FC  AFBF0024   SW RA, 36(SP)                115:       sw  ra, 36(sp)
9D00A700  AFB00000   SW S0, 0(SP)                 116:       sw  s0, 0(sp)
9D00A704  AFB10004   SW S1, 4(SP)                 117:       sw  s1, 4(sp)
9D00A708  AFB20008   SW S2, 8(SP)                 118:       sw  s2, 8(sp)
9D00A70C  AFB3000C   SW S3, 12(SP)                119:       sw  s3,12(sp)
9D00A710  AFB40010   SW S4, 16(SP)                120:       sw  s4,16(sp)
9D00A714  AFB50014   SW S5, 20(SP)                121:       sw  s5,20(sp)
9D00A718  AFB60018   SW S6, 24(SP)                122:       sw  s6,24(sp)
9D00A71C  AFB7001C   SW S7, 28(SP)                123:       sw  s7,28(sp)
9D00A720  AFBE0020   SW S8, 32(SP)                124:       sw  s8,32(sp)
9D00A724  00808021   ADDU S0, A0, ZERO            125:       move ip, a0   // pointeur bytecode à exécuter
9D00A728  00A0B021   ADDU S6, A1, ZERO            126:       move U, a1    // pointeur tableau de variables
9D00A72C  3C13A000   LUI S3, -24576               127:       lui w, RAM_SEG
9D00A730  367127B4   ORI S1, S3, 10164            128:       ori dp, w, dstack
9D00A734  36722804   ORI S2, S3, 10244            129:       ori rp, w, rstack
                                                  130:   
                                                  131:   next:
9D00A738  82080000   LB T0, 0(S0)                 132:       lb    t0, 0(ip)
                                                  133:   #    addiu t1,t0, IBADOP
                                                  134:   #    bgtz  t1, badop
9D00A73C  00084080   SLL T0, T0, 2                135:       sll   t0, t0, 2   
9D00A740  2508B008   ADDIU T0, T0, -20472         136:       addiu t0,t0,opcodes_table
9D00A744  3C099D00   LUI T1, -25344               137:       lui   t1, CODE_SEG
9D00A748  01284825   OR T1, T1, T0                138:       or    t1,t1,t0
9D00A74C  8D290000   LW T1, 0(T1)                 139:       lw    t1, 0(t1)
9D00A750  01200008   JR T1                        140:       jr    t1
9D00A754  26100001   ADDIU S0, S0, 1              141:       _next
                                                  142:   
                                                  143:   bye:   # 'bye' ( -- ) sortie de la machine virtuelle
9D00A758  10000213   BEQ ZERO, ZERO, 0x9D00AFA8   144:       b exit
9D00A75C  00001026   XOR V0, ZERO, ZERO           145:       xor v0, zero,zero  # return 0
                                                  146:   
                                                  147:   qrx: # '?key' ( -- ch -1 | 0 )
9D00A760  34040001   ORI A0, ZERO, 1              148:       ori a0,zero,STDIO
9D00A764  0F403FF5   JAL 0x9D00FFD4               149:       jal _getch
9D00A768  00000000   NOP                          150:       nop
9D00A76C  26310004   ADDIU S1, S1, 4              151:       _tpush
9D00A774  04400005   BLTZ V0, 0x9D00A78C          152:       bltz v0, qrx_exit
9D00A778  24480001   ADDIU T0, V0, 1              153:       addiu t0,v0,1
9D00A77C  0040A021   ADDU S4, V0, ZERO            154:       move T, v0
9D00A780  2408FFFF   ADDIU T0, ZERO, -1           155:       addiu t0,zero,-1
9D00A784  26310004   ADDIU S1, S1, 4              156:       _tpush
                                                  157:   qrx_exit:
9D00A78C  1000FFEA   BEQ ZERO, ZERO, 0x9D00A738   158:       b next
9D00A790  0100A021   ADDU S4, T0, ZERO            159:       move T, t0
                                                  160:   
                                                  161:   emit:   # 'emit' ( ch -- ) transmet charactère au terminal
9D00A794  34040001   ORI A0, ZERO, 1              162:       ori a0,zero,STDIO
9D00A798  02802821   ADDU A1, S4, ZERO            163:       move  a1, T
9D00A79C  8E340000   LW S4, 0(S1)                 164:       _tpop
9D00A7A4  0F404002   JAL 0x9D010008               165:       jal _putch
9D00A7A8  30A500FF   ANDI A1, A1, 255             166:       andi a1,a1, 255
9D00A7AC  1000FFE2   BEQ ZERO, ZERO, 0x9D00A738   167:       b next
9D00A7B0  00000000   NOP                          168:       nop
                                                  169:   
                                                  170:   lit:    # 'lit' ( -- n) empile un entier
9D00A7B4  0F402BF6   JAL 0x9D00AFD8               171:       jal fetch_int
9D00A7B8  26310004   ADDIU S1, S1, 4              172:       addiu dp,dp,CELL_SIZE
9D00A7BC  AE340000   SW S4, 0(S1)                 173:       sw T, 0(dp)
9D00A7C0  1000FFDD   BEQ ZERO, ZERO, 0x9D00A738   174:       b next
9D00A7C4  0040A021   ADDU S4, V0, ZERO            175:       move T,v0
                                                  176:   
                                                  177:   clit:       # 'clit' ( -- byte ) empile un octet signe étendu sur 32 bits
9D00A7C8  26310004   ADDIU S1, S1, 4              178:       _tpush
9D00A7D0  82140000   LB S4, 0(S0)                 179:       lb T, 0(ip)
9D00A7D4  1000FFD8   BEQ ZERO, ZERO, 0x9D00A738   180:       b next
9D00A7D8  26100001   ADDIU S0, S0, 1              181:       _next
                                                  182:   
                                                  183:   wlit:       # 'wlit' ( -- w16  ) empile un mot de 16 bits
9D00A7DC  26310004   ADDIU S1, S1, 4              184:       _tpush
9D00A7E4  92080000   LBU T0, 0(S0)                185:       lbu t0,0(ip)
9D00A7E8  82090001   LB T1, 1(S0)                 186:       lb t1, 1(ip)
9D00A7EC  26100002   ADDIU S0, S0, 2              187:       addiu ip,ip,2
9D00A7F0  00094A00   SLL T1, T1, 8                188:       sll  t1,t1, 8
9D00A7F4  1000FFD0   BEQ ZERO, ZERO, 0x9D00A738   189:       b next
9D00A7F8  0109A025   OR S4, T0, T1                190:       or  T,t0,t1
                                                  191:   
                                                  192:   call:   # 'call' (R: -- addr_ret ) appelle sous-routine VM
9D00A7FC  0F402BF6   JAL 0x9D00AFD8               193:       jal fetch_int
                                                  194:   //    lui t2, CODE_SEG
                                                  195:   //    lbu t0, 0(ip)
                                                  196:   //fcall_1:
                                                  197:   //    lbu t1, 1(ip)
                                                  198:   //    addiu ip,ip,2
                                                  199:   //    sll t1,t1,8
                                                  200:   //    or t0,t0,t1
                                                  201:   //    or t0,t0,t2
9D00A800  26520004   ADDIU S2, S2, 4              202:       _rpush
9D00A808  0200A821   ADDU S5, S0, ZERO            203:       move R, ip
9D00A80C  1000FFCA   BEQ ZERO, ZERO, 0x9D00A738   204:       b next
9D00A810  00408021   ADDU S0, V0, ZERO            205:       move ip, v0
                                                  206:   
                                                  207:   //rcall:  # 'rcall' (R: -- addr_ret ) appelle sous-routine VM en mémoire RAM
                                                  208:   //    lui t2, RAM_SEG
                                                  209:   //    b fcall_1
                                                  210:   //    lbu t0, 0(ip)
                                                  211:   
                                                  212:   ret:        # ';' (R: addr_ret -- ) sortie de sous-routine
9D00A814  02A08021   ADDU S0, S5, ZERO            213:       move ip, R
9D00A818  8E550000   LW S5, 0(S2)                 214:       lw R, 0(rp)
9D00A81C  1000FFC6   BEQ ZERO, ZERO, 0x9D00A738   215:       b next
9D00A820  2652FFFC   ADDIU S2, S2, -4             216:       addiu rp,rp, -CELL_SIZE
                                                  217:   
                                                  218:   bra:        # 'branch' ( -- ) branchement incondionnnel (adresse relative +127,-128)
9D00A824  82080000   LB T0, 0(S0)                 219:       lb t0, 0(ip)
9D00A828  26100001   ADDIU S0, S0, 1              220:       _next
9D00A82C  1000FFC2   BEQ ZERO, ZERO, 0x9D00A738   221:       b next
9D00A830  02088021   ADDU S0, S0, T0              222:       addu ip, ip, t0   # branchement relatif à ip, intervale -128 à +127
                                                  223:   
                                                  224:   qbra:       # '?bra' ( t|f -- ) branche si sommet pile est vrai (tos!=0)
9D00A834  02804021   ADDU T0, S4, ZERO            225:       move t0, T
9D00A838  8E340000   LW S4, 0(S1)                 226:       _tpop
9D00A840  1100FFBD   BEQ T0, ZERO, 0x9D00A738     227:       beqz t0, next
9D00A844  26100001   ADDIU S0, S0, 1              228:       _next
9D00A848  8208FFFF   LB T0, -1(S0)                229:       lb t0, -1(ip)
9D00A84C  1000FFBA   BEQ ZERO, ZERO, 0x9D00A738   230:       b next
9D00A850  02088021   ADDU S0, S0, T0              231:       addu ip,ip,t0
                                                  232:   
                                                  233:   qbraz:      # '?braz' ( t|f -- ) branche si somme pile est faux (tos==0)
9D00A854  02804021   ADDU T0, S4, ZERO            234:       move t0, T
9D00A858  8E340000   LW S4, 0(S1)                 235:       _tpop
9D00A860  1500FFB5   BNE T0, ZERO, 0x9D00A738     236:       bne t0, zero, next
9D00A864  26100001   ADDIU S0, S0, 1              237:       _next
9D00A868  8208FFFF   LB T0, -1(S0)                238:       lb t0, -1(ip)
9D00A86C  1000FFB2   BEQ ZERO, ZERO, 0x9D00A738   239:       b next
9D00A870  02088021   ADDU S0, S0, T0              240:       addu ip,ip,t0
                                                  241:   
                                                  242:   exec:       # 'exec' ( addr -- ) appelle sous-routine à partir de la pile
9D00A874  26520004   ADDIU S2, S2, 4              243:       _rpush
9D00A87C  0200A821   ADDU S5, S0, ZERO            244:       move R, ip
9D00A880  02808021   ADDU S0, S4, ZERO            245:       move  ip, T
9D00A884  2631FFFC   ADDIU S1, S1, -4             246:       addiu dp,dp, -CELL_SIZE
9D00A888  1000FFAB   BEQ ZERO, ZERO, 0x9D00A738   247:       b next
9D00A88C  8E340000   LW S4, 0(S1)                 248:       lw T, 0(dp)
                                                  249:   
                                                  250:   store:      # '!' ( n addr -- )  variable = n
9D00A890  02804021   ADDU T0, S4, ZERO            251:       move t0, T
9D00A894  8E290000   LW T1, 0(S1)                 252:       lw t1, 0(dp)
9D00A898  A1090000   SB T1, 0(T0)                 253:       sb t1, 0(t0)   # l'adresse n'est pas forcément alignée donc on y va octet par octet
9D00A89C  00094A02   SRL T1, T1, 8                254:       srl t1,t1,8
9D00A8A0  A1090001   SB T1, 1(T0)                 255:       sb t1,1(t0)
9D00A8A4  00094A02   SRL T1, T1, 8                256:       srl t1,t1,8
9D00A8A8  A1090002   SB T1, 2(T0)                 257:       sb t1,2(t0)
9D00A8AC  00094A02   SRL T1, T1, 8                258:       srl t1,t1,8
9D00A8B0  A1090003   SB T1, 3(T0)                 259:       sb t1,3(t0)
9D00A8B4  8E34FFFC   LW S4, -4(S1)                260:       lw T, -CELL_SIZE(dp)
9D00A8B8  1000FF9F   BEQ ZERO, ZERO, 0x9D00A738   261:       b next
9D00A8BC  2631FFF8   ADDIU S1, S1, -8             262:       addiu dp,dp,-2*CELL_SIZE
                                                  263:   
                                                  264:   fetch:      # '@' ( addr -- n ) T= *addr
9D00A8C0  02804021   ADDU T0, S4, ZERO            265:       move t0, T
9D00A8C4  91090000   LBU T1, 0(T0)                266:       lbu t1, 0(t0)   # l'adresse n'est pas forcément alignée donc on y va octet par octet
9D00A8C8  910A0001   LBU T2, 1(T0)                267:       lbu t2, 1(t0)
9D00A8CC  000A5200   SLL T2, T2, 8                268:       sll t2,t2,8
9D00A8D0  012A4825   OR T1, T1, T2                269:       or t1,t1,t2
9D00A8D4  910A0002   LBU T2, 2(T0)                270:       lbu t2, 2(t0)
9D00A8D8  000A5400   SLL T2, T2, 16               271:       sll t2,t2,16
9D00A8DC  012A4825   OR T1, T1, T2                272:       or t1,t1,t2
9D00A8E0  910A0003   LBU T2, 3(T0)                273:       lbu t2, 3(t0)
9D00A8E4  000A5600   SLL T2, T2, 24               274:       sll t2, 24
9D00A8E8  1000FF93   BEQ ZERO, ZERO, 0x9D00A738   275:       b next
9D00A8EC  012AA025   OR S4, T1, T2                276:       or T,t1,t2
                                                  277:   
                                                  278:   cstore:     # 'c!' ( char addr --  ) *addr = char
9D00A8F0  8E280000   LW T0, 0(S1)                 279:       lw t0, 0(dp)
9D00A8F4  A2880000   SB T0, 0(S4)                 280:       sb t0, 0(T)
9D00A8F8  8E34FFFC   LW S4, -4(S1)                281:       lw T, -CELL_SIZE(dp)
9D00A8FC  1000FF8E   BEQ ZERO, ZERO, 0x9D00A738   282:       b next
9D00A900  2631FFF8   ADDIU S1, S1, -8             283:       addiu dp,dp,-2*CELL_SIZE
                                                  284:   
                                                  285:   cfetch:     # 'c@' ( addr -- char )  T = (char)*addr
9D00A904  82880000   LB T0, 0(S4)                 286:       lb t0, 0(T)
9D00A908  1000FF8B   BEQ ZERO, ZERO, 0x9D00A738   287:       b next
9D00A90C  0100A021   ADDU S4, T0, ZERO            288:       move T, t0
                                                  289:   
                                                  290:   rfetch:    # 'r@'  ( -- n R: n -- n )  empile le sommet de la pile des retours
9D00A910  26310004   ADDIU S1, S1, 4              291:       _tpush
9D00A918  1000FF87   BEQ ZERO, ZERO, 0x9D00A738   292:       b next
9D00A91C  02A0A021   ADDU S4, S5, ZERO            293:       move T, R
                                                  294:   
                                                  295:   ufetch:  # 'u@'  ( -- a-addr ) empile U
9D00A920  26310004   ADDIU S1, S1, 4              296:       _tpush
9D00A928  1000FF83   BEQ ZERO, ZERO, 0x9D00A738   297:       b next
9D00A92C  02C0A021   ADDU S4, S6, ZERO            298:       move T, U
                                                  299:   
                                                  300:   ustore:  # 'u!'  ( a-addr -- ) transfert T dans U
9D00A930  0280B021   ADDU S6, S4, ZERO            301:       move U, T
9D00A934  8E340000   LW S4, 0(S1)                 302:       lw T, 0(dp)
9D00A938  1000FF7F   BEQ ZERO, ZERO, 0x9D00A738   303:       b next
9D00A93C  2631FFFC   ADDIU S1, S1, -4             304:       addiu dp,dp,-CELL_SIZE
                                                  305:   
                                                  306:   user: # 'user'  ( n -- a-addr) empile le pointeur de la variable
                                                  307:                                # utilisateur d'indice n.
9D00A940  0014A080   SLL S4, S4, 2                308:         sll  T,T,2
9D00A944  1000FF7C   BEQ ZERO, ZERO, 0x9D00A738   309:         b next
9D00A948  02D4A021   ADDU S4, S6, S4              310:         addu T, U, T
                                                  311:   
                                                  312:   
                                                  313:   tor:        # '>r' ( n -- ) (R: -- n ) envoie T sur pile retour
9D00A94C  26520004   ADDIU S2, S2, 4              314:       _rpush
9D00A954  0280A821   ADDU S5, S4, ZERO            315:       move R, T
9D00A958  8E340000   LW S4, 0(S1)                 316:       lw T, 0(dp)
9D00A95C  1000FF76   BEQ ZERO, ZERO, 0x9D00A738   317:       b next
9D00A960  2631FFFC   ADDIU S1, S1, -4             318:       addiu dp, dp, -CELL_SIZE
                                                  319:   
                                                  320:   rfrom:      # 'r>' ( -- n ) (R: n -- )  envoie R dans T
9D00A964  26310004   ADDIU S1, S1, 4              321:       _tpush
9D00A96C  02A0A021   ADDU S4, S5, ZERO            322:       move T, R
9D00A970  8E550000   LW S5, 0(S2)                 323:       lw  R, 0(rp)
9D00A974  1000FF70   BEQ ZERO, ZERO, 0x9D00A738   324:       b next
9D00A978  2652FFFC   ADDIU S2, S2, -4             325:       addiu rp,rp, -CELL_SIZE
                                                  326:   
                                                  327:   
                                                  328:   dcnt:     # 'dcnt' ( -- n) nombre d'éléments sur la pile de données
9D00A97C  3C08A000   LUI T0, -24576               329:       lui t0, RAM_SEG
9D00A980  350827B4   ORI T0, T0, 10164            330:       ori t0, t0,dstack
9D00A984  02284023   SUBU T0, S1, T0              331:       subu t0,dp,t0
9D00A988  00084083   SRA T0, T0, 2                332:       sra t0,t0,2
9D00A98C  26310004   ADDIU S1, S1, 4              333:       _tpush
9D00A994  1000FF68   BEQ ZERO, ZERO, 0x9D00A738   334:       b next
9D00A998  0100A021   ADDU S4, T0, ZERO            335:       move T, t0
                                                  336:   
                                                  337:   rcnt:     # 'rcnt' ( -- n ) nombre d'éléments sur la pile des retours
9D00A99C  26310004   ADDIU S1, S1, 4              338:       _tpush
9D00A9A4  3C08A000   LUI T0, -24576               339:       lui t0, RAM_SEG
9D00A9A8  35082804   ORI T0, T0, 10244            340:       ori t0,t0,rstack
9D00A9AC  02484023   SUBU T0, S2, T0              341:       subu t0,rp,t0
9D00A9B0  00084083   SRA T0, T0, 2                342:       sra t0,t0,2
9D00A9B4  1000FF60   BEQ ZERO, ZERO, 0x9D00A738   343:       b next
9D00A9B8  0100A021   ADDU S4, T0, ZERO            344:       move T, t0
                                                  345:   
                                                  346:   ipfetch:        # 'ip@' ( -- ip ) empile la valeur courante du pointeur d''instructions
9D00A9BC  26310004   ADDIU S1, S1, 4              347:       _tpush
9D00A9C4  1000FF5C   BEQ ZERO, ZERO, 0x9D00A738   348:       b next
9D00A9C8  0200A021   ADDU S4, S0, ZERO            349:       move T, ip
                                                  350:   
                                                  351:   ipstore:        # 'ip!' ( ip -- ) initialise le pointeur d''insturctions
9D00A9CC  02808021   ADDU S0, S4, ZERO            352:       move ip, T
9D00A9D0  8E340000   LW S4, 0(S1)                 353:       lw T, 0(dp)
9D00A9D4  1000FF58   BEQ ZERO, ZERO, 0x9D00A738   354:       b next
9D00A9D8  2631FFFC   ADDIU S1, S1, -4             355:       addiu dp,dp, -CELL_SIZE
                                                  356:   
                                                  357:   drop:       # 'drop' ( n -- )
9D00A9DC  8E340000   LW S4, 0(S1)                 358:       lw T, 0(dp)
9D00A9E0  1000FF55   BEQ ZERO, ZERO, 0x9D00A738   359:       b next
9D00A9E4  2631FFFC   ADDIU S1, S1, -4             360:       addiu dp,dp,-CELL_SIZE
                                                  361:   
                                                  362:   twodrop:      # '2drop' ( n1 n2 -- )
9D00A9E8  8E34FFFC   LW S4, -4(S1)                363:       lw T, -CELL_SIZE(dp)
9D00A9EC  1000FF52   BEQ ZERO, ZERO, 0x9D00A738   364:       b next
9D00A9F0  2631FFF8   ADDIU S1, S1, -8             365:       addiu dp,dp,-2*CELL_SIZE
                                                  366:   
                                                  367:   dup:        # 'dup' ( n -- n n )
9D00A9F4  26310004   ADDIU S1, S1, 4              368:       addiu dp,dp,CELL_SIZE
9D00A9F8  1000FF4F   BEQ ZERO, ZERO, 0x9D00A738   369:       b next
9D00A9FC  AE340000   SW S4, 0(S1)                 370:       sw T, 0(dp)
                                                  371:   
                                                  372:   twodup:
9D00AA00  8E280000   LW T0, 0(S1)                 373:       lw t0, 0(dp)
9D00AA04  26310008   ADDIU S1, S1, 8              374:       addiu dp,dp,2*CELL_SIZE
9D00AA08  AE34FFFC   SW S4, -4(S1)                375:       sw T, -CELL_SIZE(dp)
9D00AA0C  1000FF4A   BEQ ZERO, ZERO, 0x9D00A738   376:       b next
9D00AA10  AE280000   SW T0, 0(S1)                 377:       sw t0, 0(dp)
                                                  378:   
                                                  379:   qdup:       # ?dup ( n -- n n | n ) duplique n si n!=0
9D00AA14  1280FF48   BEQ S4, ZERO, 0x9D00A738     380:       beq T,zero, next
9D00AA18  00000000   NOP                          381:       nop
9D00AA1C  26310004   ADDIU S1, S1, 4              382:       addiu dp,dp,CELL_SIZE
9D00AA20  1000FF45   BEQ ZERO, ZERO, 0x9D00A738   383:       b next
9D00AA24  AE340000   SW S4, 0(S1)                 384:       sw T, 0(dp)
                                                  385:   
                                                  386:   swap:       # 'swap' (n2 n1 -- n1 n2 )
9D00AA28  02804021   ADDU T0, S4, ZERO            387:       move t0, T
9D00AA2C  8E340000   LW S4, 0(S1)                 388:       lw T, 0(dp)
9D00AA30  1000FF41   BEQ ZERO, ZERO, 0x9D00A738   389:       b next
9D00AA34  AE280000   SW T0, 0(S1)                 390:       sw t0, 0(dp)
                                                  391:   
                                                  392:   over:       # 'over' ( n2 n1 -- n2 n1 n2 )
9D00AA38  26310004   ADDIU S1, S1, 4              393:       _tpush
9D00AA40  1000FF3D   BEQ ZERO, ZERO, 0x9D00A738   394:       b next
9D00AA44  8E34FFFC   LW S4, -4(S1)                395:       lw T, -CELL_SIZE(dp)
                                                  396:   
                                                  397:   rot:
9D00AA48  02804021   ADDU T0, S4, ZERO            398:       move t0, T
9D00AA4C  8E290000   LW T1, 0(S1)                 399:       lw t1, 0(dp)
9D00AA50  8E34FFFC   LW S4, -4(S1)                400:       lw T, -CELL_SIZE(dp)
9D00AA54  AE280000   SW T0, 0(S1)                 401:       sw t0, 0(dp)
9D00AA58  1000FF37   BEQ ZERO, ZERO, 0x9D00A738   402:       b next
9D00AA5C  AE29FFFC   SW T1, -4(S1)                403:       sw t1, -CELL_SIZE(dp)
                                                  404:   
                                                  405:   plus:       # '+'   ( n1 n2 -- n1+n2 )
9D00AA60  02804021   ADDU T0, S4, ZERO            406:       move t0, T
9D00AA64  8E340000   LW S4, 0(S1)                 407:       _tpop
9D00AA6C  1000FF32   BEQ ZERO, ZERO, 0x9D00A738   408:       b next
9D00AA70  0288A021   ADDU S4, S4, T0              409:       addu T,T,t0
                                                  410:   
                                                  411:   oneplus:      # '1+'  (n -- n+1 )
9D00AA74  1000FF30   BEQ ZERO, ZERO, 0x9D00A738   412:       b next
9D00AA78  26940001   ADDIU S4, S4, 1              413:       addiu T, T, 1
                                                  414:   
                                                  415:   plusstore:  # '+!'  ( n addr -- ) *addr  = *addr+n
9D00AA7C  02809821   ADDU S3, S4, ZERO            416:       move w, T
9D00AA80  8E340000   LW S4, 0(S1)                 417:       _tpop
9D00AA88  8E680000   LW T0, 0(S3)                 418:       lw t0, 0(w)
9D00AA8C  0288A021   ADDU S4, S4, T0              419:       addu T, T, t0
9D00AA90  AE740000   SW S4, 0(S3)                 420:       sw T, 0(w)
9D00AA94  8E340000   LW S4, 0(S1)                 421:       lw T, 0(dp)
9D00AA98  1000FF27   BEQ ZERO, ZERO, 0x9D00A738   422:       b next
9D00AA9C  2631FFFC   ADDIU S1, S1, -4             423:       addiu dp,dp,-CELL_SIZE
                                                  424:   
                                                  425:   minus:      # '-' ( n1 n2 -- n1-n2 )
9D00AAA0  02804021   ADDU T0, S4, ZERO            426:       move t0,T
9D00AAA4  8E340000   LW S4, 0(S1)                 427:       _tpop
9D00AAAC  1000FF22   BEQ ZERO, ZERO, 0x9D00A738   428:       b next
9D00AAB0  0288A023   SUBU S4, S4, T0              429:       subu T,T,t0
                                                  430:   
                                                  431:   oneminus:     # '1-' ( n -- n-1 )
9D00AAB4  1000FF20   BEQ ZERO, ZERO, 0x9D00A738   432:       b next
9D00AAB8  2694FFFF   ADDIU S4, S4, -1             433:       addiu T, T, -1
                                                  434:   
                                                  435:   star:      # '*' ( n1 n2 -- n1*n2 ) multiplication signé, résultat simple précision.
9D00AABC  02804021   ADDU T0, S4, ZERO            436:       move t0, T
9D00AAC0  8E340000   LW S4, 0(S1)                 437:       _tpop
9D00AAC8  1000FF1B   BEQ ZERO, ZERO, 0x9D00A738   438:       b next
9D00AACC  7114A002   MUL S4, T0, S4               439:       mul T,t0,T
                                                  440:   
                                                  441:   ustar:    # 'U*' ( u1 u2 -- u3 ) multiplication non signe, résultat simple précision
9D00AAD0  02804021   ADDU T0, S4, ZERO            442:       move t0, T
9D00AAD4  8E340000   LW S4, 0(S1)                 443:       _tpop
9D00AADC  01140019   MULTU 0, T0, S4              444:       multu  t0, T
9D00AAE0  1000FF15   BEQ ZERO, ZERO, 0x9D00A738   445:       b next
9D00AAE4  0000A012   MFLO S4, 0                   446:       mflo T
                                                  447:   
                                                  448:   mstar:  # 'M*' ( n1 n2 -- d) multiplication signée avec résultat double précision.
9D00AAE8  8E280000   LW T0, 0(S1)                 449:       lw t0, 0(dp)
9D00AAEC  01140018   MULT 0, T0, S4               450:       mult t0,T
9D00AAF0  00004012   MFLO T0, 0                   451:       mflo t0
9D00AAF4  0000A010   MFHI S4, 0                   452:       mfhi T
9D00AAF8  1000FF0F   BEQ ZERO, ZERO, 0x9D00A738   453:       b next
9D00AAFC  AE280000   SW T0, 0(S1)                 454:       sw t0, 0(dp)
                                                  455:   
                                                  456:   umstar: # 'UM*' ( u1 u2 -- ud ) multiplication non signé avec résultat double précision.
9D00AB00  8E280000   LW T0, 0(S1)                 457:       lw t0, 0(dp)
9D00AB04  01140019   MULTU 0, T0, S4              458:       multu t0,T
9D00AB08  00004012   MFLO T0, 0                   459:       mflo t0
9D00AB0C  0000A010   MFHI S4, 0                   460:       mfhi T
9D00AB10  1000FF09   BEQ ZERO, ZERO, 0x9D00A738   461:       b next
9D00AB14  AE280000   SW T0, 0(S1)                 462:       sw t0, 0(dp)
                                                  463:   
                                                  464:   slash:      # '/' ( n1 n2 -- n1/n2 )  division signée
9D00AB18  02804021   ADDU T0, S4, ZERO            465:       move t0, T
9D00AB1C  8E340000   LW S4, 0(S1)                 466:       _tpop
9D00AB24  010001F4   TEQ T0, ZERO                 467:       div T,t0
9D00AB40  1000FEFD   BEQ ZERO, ZERO, 0x9D00A738   468:       b next
9D00AB44  0000A012   MFLO S4, 0                   469:       mflo T
                                                  470:   
                                                  471:   uslash:     # 'U/'  (u1 u2 -- u3)  division non signée
9D00AB48  02804021   ADDU T0, S4, ZERO            472:       move t0, T
9D00AB4C  8E340000   LW S4, 0(S1)                 473:       _tpop
9D00AB54  010001F4   TEQ T0, ZERO                 474:       divu T,t0
9D00AB60  1000FEF5   BEQ ZERO, ZERO, 0x9D00A738   475:       b next
9D00AB64  0000A012   MFLO S4, 0                   476:       mflo T
                                                  477:   
                                                  478:   twostar:  # '2*'  ( n  -- 2*n ) multiply by 2 (shift left 1 bit)
9D00AB68  1000FEF3   BEQ ZERO, ZERO, 0x9D00A738   479:       b next
9D00AB6C  0014A040   SLL S4, S4, 1                480:       sll T,T,1
                                                  481:   
                                                  482:   twoslash:  # '2/'  ( n -- n/2 )  divide by 2 ( arithmetic shift right 1 bit)
9D00AB70  1000FEF1   BEQ ZERO, ZERO, 0x9D00A738   483:       b next
9D00AB74  0014A043   SRA S4, S4, 1                484:       sra T,T,1
                                                  485:   
                                                  486:   divmod:     # '/mod'  ( n1 n2 -- n1%n2 n1/n2 )
9D00AB78  8E280000   LW T0, 0(S1)                 487:       lw t0, 0(dp)
9D00AB7C  028001F4   TEQ S4, ZERO                 488:       div t0, T  # n1/n2
9D00AB98  00004010   MFHI T0, 0                   489:       mfhi t0    #  remainder
9D00AB9C  AE280000   SW T0, 0(S1)                 490:       sw t0, 0(dp)
9D00ABA0  1000FEE5   BEQ ZERO, ZERO, 0x9D00A738   491:       b next
9D00ABA4  0000A012   MFLO S4, 0                   492:       mflo T     # quotient
                                                  493:   
                                                  494:   lshift:     # '<<' ( n1 u -- n1<<u )
9D00ABA8  02804021   ADDU T0, S4, ZERO            495:       move t0, T
9D00ABAC  8E340000   LW S4, 0(S1)                 496:       _tpop
9D00ABB4  1000FEE0   BEQ ZERO, ZERO, 0x9D00A738   497:       b next
9D00ABB8  0114A004   SLLV S4, S4, T0              498:       sllv T, T, t0
                                                  499:   
                                                  500:   rshift:     # '>>'  ( n1 u -- n1>>u )
9D00ABBC  02804021   ADDU T0, S4, ZERO            501:       move t0, T
9D00ABC0  8E340000   LW S4, 0(S1)                 502:       _tpop
9D00ABC8  1000FEDB   BEQ ZERO, ZERO, 0x9D00A738   503:       b next
9D00ABCC  0114A006   SRLV S4, S4, T0              504:       srlv T, T, t0
                                                  505:   
                                                  506:   modulo:     # 'mod' ( n1 n2 -- n1%n2 )
9D00ABD0  02804021   ADDU T0, S4, ZERO            507:       move t0, T
9D00ABD4  8E340000   LW S4, 0(S1)                 508:       _tpop
9D00ABDC  010001F4   TEQ T0, ZERO                 509:       div T,t0
9D00ABF8  1000FECF   BEQ ZERO, ZERO, 0x9D00A738   510:       b next
9D00ABFC  0000A010   MFHI S4, 0                   511:       mfhi T
                                                  512:   
                                                  513:   /*
                                                  514:     # division non signée d'un double par un simple, retourne quotient et reste
                                                  515:     # les 32 bits les plus significatifs du double sont ignorés.
                                                  516:     #  Il s'agit dans les fait d'une division simple/simple.
                                                  517:   umsmod:  # 'UM/MOD' ( ud1 u1 -- u2 u3 ) u2=reste, u3= quotient
                                                  518:           lw      t0, -CELL_SIZE(dp)
                                                  519:           divu    t0,T
                                                  520:           mfhi    t0
                                                  521:           mflo    T
                                                  522:           sw      t0, -CELL_SIZE(dp)
                                                  523:           b       next
                                                  524:           addiu   dp, dp, -CELL_SIZE
                                                  525:   */
                                                  526:   
                                                  527:   # division non signée d'un double précision par un simple, retourne quotient et reste
                                                  528:   # si le quotient > 32 bits retourne -1 -1.
                                                  529:   umsmod: # 'UM/MOD (ud1 u1 -- u2 u3|-1 -1) u2=reste, u3=quotient
9D00AC00  8E28FFFC   LW T0, -4(S1)                530:           lw      t0, -CELL_SIZE(dp)  # 32 bits poids faible
9D00AC04  8E290000   LW T1, 0(S1)                 531:           lw      t1, 0(dp)           # 32 bits poids fort
9D00AC08  1D20000D   BGTZ T1, 0x9D00AC40          532:           bgtz    t1, long_div
9D00AC0C  00000000   NOP                          533:           nop
9D00AC10  028001F4   TEQ S4, ZERO                 534:           divu    t0, T
9D00AC1C  00004010   MFHI T0, 0                   535:           mfhi    t0              # reste
9D00AC20  0000A012   MFLO S4, 0                   536:           mflo    T               # quotient
9D00AC24  AE28FFFC   SW T0, -4(S1)                537:           sw      t0, -CELL_SIZE(dp)
9D00AC28  1000FEC3   BEQ ZERO, ZERO, 0x9D00A738   538:           b       next
9D00AC2C  2631FFFC   ADDIU S1, S1, -4             539:           addiu   dp, dp, -CELL_SIZE
9D00AC30  2414FFFF   ADDIU S4, ZERO, -1           540:   1:      li      T, -1             # quotient > 32 bits
9D00AC34  AE34FFFC   SW S4, -4(S1)                541:           sw      T, -CELL_SIZE(dp)
9D00AC38  1000FEBF   BEQ ZERO, ZERO, 0x9D00A738   542:           b       next
9D00AC3C  2631FFFC   ADDIU S1, S1, -4             543:           addiu   dp,dp,-CELL_SIZE
                                                  544:   long_div:
9D00AC40  028001F4   TEQ S4, ZERO                 545:           divu    t1,T
9D00AC4C  00005812   MFLO T3, 0                   546:           mflo    t3      #quotient
9D00AC50  1D60FFF7   BGTZ T3, 0x9D00AC30          547:           bgtz    t3, 1b
9D00AC54  00004810   MFHI T1, 0                   548:           mfhi    t1      #reste
9D00AC58  240A0020   ADDIU T2, ZERO, 32           549:           li      t2, 32  # compteur de boucle
9D00AC5C  0560FFF4   BLTZ T3, 0x9D00AC30          550:   2:      bltz    t3, 1b  # overflow
9D00AC60  000B5840   SLL T3, T3, 1                551:           sll     t3,t3,1
9D00AC64  01346023   SUBU T4, T1, S4              552:           subu    t4,t1,T
9D00AC68  05800003   BLTZ T4, 0x9D00AC78          553:           bltz    t4,3f
9D00AC6C  00000000   NOP                          554:           nop
9D00AC70  01804821   ADDU T1, T4, ZERO            555:           move    t1, t4
9D00AC74  356B0001   ORI T3, T3, 1                556:           ori     t3,t3,1
9D00AC78  254AFFFF   ADDIU T2, T2, -1             557:   3:      addiu   t2,t2,-1  # décrémente le compteur de boucle
9D00AC7C  11400007   BEQ T2, ZERO, 0x9D00AC9C     558:           beqz    t2, 5f    # division terminée si 0
9D00AC80  00000000   NOP                          559:           nop
9D00AC84  00094840   SLL T1, T1, 1                560:           sll     t1,t1,1   # décale à gauche t1:t0
9D00AC88  05010002   BGEZ T0, 0x9D00AC94          561:           bgez    t0, 4f
9D00AC8C  00000000   NOP                          562:           nop
9D00AC90  35290001   ORI T1, T1, 1                563:           ori     t1,t1,1
9D00AC94  1000FFF1   BEQ ZERO, ZERO, 0x9D00AC5C   564:   4:      b 2b
9D00AC98  00084040   SLL T0, T0, 1                565:           sll     t0,t0,1
9D00AC9C  0160A021   ADDU S4, T3, ZERO            566:   5:      move    T, t3                 # quotient
9D00ACA0  AE29FFFC   SW T1, -4(S1)                567:           sw      t1, -CELL_SIZE(dp)    # reste
9D00ACA4  1000FEA4   BEQ ZERO, ZERO, 0x9D00A738   568:           b       next
9D00ACA8  2631FFFC   ADDIU S1, S1, -4             569:           addiu   dp,dp,-CELL_SIZE
                                                  570:   
                                                  571:   
                                                  572:     # division signée d'un double par un simple, retourne quotient et reste
                                                  573:     # les 32 bits les plus significatifs du double sont ignorés.
                                                  574:     #  Il s'agit dans les fait d'une division simple/simple.
                                                  575:   msmod:   # 'M/MOD'  (d1 n1 - n2 n3 )  n2=reste, n3=quotient
9D00ACAC  8E28FFFC   LW T0, -4(S1)                576:           lw      t0, -CELL_SIZE(dp)
9D00ACB0  028001F4   TEQ S4, ZERO                 577:           div     t0, T
9D00ACCC  00004010   MFHI T0, 0                   578:           mfhi    t0
9D00ACD0  0000A012   MFLO S4, 0                   579:           mflo    T
9D00ACD4  AE28FFFC   SW T0, -4(S1)                580:           sw      t0, -CELL_SIZE(dp)
9D00ACD8  1000FE97   BEQ ZERO, ZERO, 0x9D00A738   581:           b       next
9D00ACDC  2631FFFC   ADDIU S1, S1, -4             582:           addiu   dp,dp,-CELL_SIZE
                                                  583:   
                                                  584:   
                                                  585:   min:        # 'min' (n1 n2 -- min )  conserve le plus petit
9D00ACE0  02804021   ADDU T0, S4, ZERO            586:       move t0, T
9D00ACE4  8E340000   LW S4, 0(S1)                 587:       _tpop
9D00ACEC  02884823   SUBU T1, S4, T0              588:       subu t1,T, t0
9D00ACF0  0520FE91   BLTZ T1, 0x9D00A738          589:       bltz t1, next
9D00ACF4  00000000   NOP                          590:       nop
9D00ACF8  1000FE8F   BEQ ZERO, ZERO, 0x9D00A738   591:       b next
9D00ACFC  0100A021   ADDU S4, T0, ZERO            592:       move T, t0
                                                  593:   
                                                  594:   max:        # 'max' (n1 n2 -- max ) conserve le plus grand
9D00AD00  02804021   ADDU T0, S4, ZERO            595:       move t0, T
9D00AD04  8E340000   LW S4, 0(S1)                 596:       _tpop
9D00AD0C  01144823   SUBU T1, T0, S4              597:       subu t1,t0,T
9D00AD10  0520FE89   BLTZ T1, 0x9D00A738          598:       bltz t1, next
9D00AD14  00000000   NOP                          599:       nop
9D00AD18  1000FE87   BEQ ZERO, ZERO, 0x9D00A738   600:       b next
9D00AD1C  0100A021   ADDU S4, T0, ZERO            601:       move T, t0
                                                  602:   
                                                  603:   abs:        # 'abs' ( n -- abs(n) )
9D00AD20  0681FE85   BGEZ S4, 0x9D00A738          604:       bgez T, next
9D00AD24  00000000   NOP                          605:       nop
9D00AD28  1000FE83   BEQ ZERO, ZERO, 0x9D00A738   606:       b next
9D00AD2C  0014A023   SUBU S4, ZERO, S4            607:       negu T
                                                  608:   
                                                  609:   ltz:   # '0<'  ( n -- t|f )
9D00AD30  0680FE81   BLTZ S4, 0x9D00A738          610:       bltz T, next
9D00AD34  2414FFFF   ADDIU S4, ZERO, -1           611:       li T, -1
9D00AD38  1000FE7F   BEQ ZERO, ZERO, 0x9D00A738   612:       b next
9D00AD3C  24140000   ADDIU S4, ZERO, 0            613:       li T,0
                                                  614:   
                                                  615:   zequal: # '0=' ( n -- t|f ) vrai si n == 0 sinon faut
9D00AD40  1280FE7D   BEQ S4, ZERO, 0x9D00A738     616:       beqz T, next
9D00AD44  2414FFFF   ADDIU S4, ZERO, -1           617:       li T, -1
9D00AD48  1000FE7B   BEQ ZERO, ZERO, 0x9D00A738   618:       b next
9D00AD4C  24140000   ADDIU S4, ZERO, 0            619:       li T, 0
                                                  620:   
                                                  621:   bitand:     # 'and' ( n1 n2 -- n1&n2)
9D00AD50  02804021   ADDU T0, S4, ZERO            622:       move t0, T
9D00AD54  8E340000   LW S4, 0(S1)                 623:       _tpop
9D00AD5C  1000FE76   BEQ ZERO, ZERO, 0x9D00A738   624:       b next
9D00AD60  0288A024   AND S4, S4, T0               625:       and T,T,t0
                                                  626:   
                                                  627:   bitor:     # 'or' ( n1 n2 -- n1|n2)
9D00AD64  02804021   ADDU T0, S4, ZERO            628:       move t0, T
9D00AD68  8E340000   LW S4, 0(S1)                 629:       _tpop
9D00AD70  1000FE71   BEQ ZERO, ZERO, 0x9D00A738   630:       b next
9D00AD74  0288A025   OR S4, S4, T0                631:       or T,T,t0
                                                  632:   
                                                  633:   bitxor:     # 'xor' ( n1 n2 -- n1^n2)
9D00AD78  02804021   ADDU T0, S4, ZERO            634:       move t0, T
9D00AD7C  8E340000   LW S4, 0(S1)                 635:       _tpop
9D00AD84  1000FE6C   BEQ ZERO, ZERO, 0x9D00A738   636:       b next
9D00AD88  0288A026   XOR S4, S4, T0               637:       xor T,T,t0
                                                  638:   
                                                  639:   bitnot:     # 'not' ( n1 -- ~n1 )
9D00AD8C  1000FE6A   BEQ ZERO, ZERO, 0x9D00A738   640:       b next
9D00AD90  0280A027   NOR S4, S4, ZERO             641:       not T,T
                                                  642:   
                                                  643:   equal:      # '='  ( n1 n2 -- t|f ) n1==n2?
9D00AD94  02804021   ADDU T0, S4, ZERO            644:       move t0, T
9D00AD98  8E340000   LW S4, 0(S1)                 645:       _tpop
9D00ADA0  1114FE65   BEQ T0, S4, 0x9D00A738       646:       beq t0,T, next
9D00ADA4  2414FFFF   ADDIU S4, ZERO, -1           647:       li T, -1
9D00ADA8  1000FE63   BEQ ZERO, ZERO, 0x9D00A738   648:       b next
9D00ADAC  24140000   ADDIU S4, ZERO, 0            649:       li T, 0
                                                  650:   
                                                  651:   nequal:     # '<>' ( n1 n2 -- t|f ) n1<>n2?
9D00ADB0  02804021   ADDU T0, S4, ZERO            652:       move t0, T
9D00ADB4  8E340000   LW S4, 0(S1)                 653:       _tpop
9D00ADBC  1514FE5E   BNE T0, S4, 0x9D00A738       654:       bne t0,T, next
9D00ADC0  2414FFFF   ADDIU S4, ZERO, -1           655:       li T, -1
9D00ADC4  1000FE5C   BEQ ZERO, ZERO, 0x9D00A738   656:       b next
9D00ADC8  24140000   ADDIU S4, ZERO, 0            657:       li T, 0
                                                  658:   
                                                  659:   less:       # '<'  ( n1 n2 -- t|f ) n1<n2?
9D00ADCC  02804021   ADDU T0, S4, ZERO            660:       move t0, T
9D00ADD0  8E340000   LW S4, 0(S1)                 661:       _tpop
9D00ADD8  02884023   SUBU T0, S4, T0              662:       subu t0,T,t0
9D00ADDC  0500FE56   BLTZ T0, 0x9D00A738          663:       bltz t0, next
9D00ADE0  2414FFFF   ADDIU S4, ZERO, -1           664:       li T, -1
9D00ADE4  1000FE54   BEQ ZERO, ZERO, 0x9D00A738   665:       b next
9D00ADE8  24140000   ADDIU S4, ZERO, 0            666:       li T, 0
                                                  667:   
                                                  668:   greater:    # '>'  ( n1 n2 -- t|f ) n1>n2?
9D00ADEC  02804021   ADDU T0, S4, ZERO            669:       move t0, T
9D00ADF0  8E340000   LW S4, 0(S1)                 670:       _tpop
9D00ADF8  02884023   SUBU T0, S4, T0              671:       subu t0,T,t0
9D00ADFC  1D00FE4E   BGTZ T0, 0x9D00A738          672:       bgtz t0, next
9D00AE00  2414FFFF   ADDIU S4, ZERO, -1           673:       li T, -1
9D00AE04  1000FE4C   BEQ ZERO, ZERO, 0x9D00A738   674:       b next
9D00AE08  24140000   ADDIU S4, ZERO, 0            675:       li T, 0
                                                  676:   
                                                  677:   ltez:        # '<=' ( n1 n2 -- t|f ) n1<=n2?
9D00AE0C  02804021   ADDU T0, S4, ZERO            678:       move t0, T
9D00AE10  8E340000   LW S4, 0(S1)                 679:       _tpop
9D00AE18  02884023   SUBU T0, S4, T0              680:       subu t0,T,t0
9D00AE1C  1900FE46   BLEZ T0, 0x9D00A738          681:       blez t0, next
9D00AE20  2414FFFF   ADDIU S4, ZERO, -1           682:       li T, -1
9D00AE24  1000FE44   BEQ ZERO, ZERO, 0x9D00A738   683:       b next
9D00AE28  24140000   ADDIU S4, ZERO, 0            684:       li T, 0
                                                  685:   
                                                  686:   gtez:        # '>=' ( n1 n2 -- t|f ) n1>=n2?
9D00AE2C  02804021   ADDU T0, S4, ZERO            687:       move t0, T
9D00AE30  8E340000   LW S4, 0(S1)                 688:       _tpop
9D00AE38  02884023   SUBU T0, S4, T0              689:       subu t0,T,t0
9D00AE3C  0501FE3E   BGEZ T0, 0x9D00A738          690:       bgez t0, next
9D00AE40  2414FFFF   ADDIU S4, ZERO, -1           691:       li T, -1
9D00AE44  1000FE3C   BEQ ZERO, ZERO, 0x9D00A738   692:       b next
9D00AE48  24140000   ADDIU S4, ZERO, 0            693:       li T, 0
                                                  694:   
                                                  695:   input:
                                                  696:   
9D00AE4C  1000FE3A   BEQ ZERO, ZERO, 0x9D00A738   697:       b next
9D00AE50  00000000   NOP                          698:       nop
                                                  699:   
                                                  700:   key:        #  ( -- char ) attend réception caractère par terminal
9D00AE54  24040001   ADDIU A0, ZERO, 1            701:       addiu a0, zero, STDIO
9D00AE58  00002826   XOR A1, ZERO, ZERO           702:       xor a1, zero, zero
9D00AE5C  0F404010   JAL 0x9D010040               703:       jal _key
9D00AE60  26310004   ADDIU S1, S1, 4              704:       _tpush
9D00AE68  1000FE33   BEQ ZERO, ZERO, 0x9D00A738   705:       b next
9D00AE6C  0040A021   ADDU S4, V0, ZERO            706:       move T, v0  # T=v0
                                                  707:   
                                                  708:   
                                                  709:   dotq:      # '."' ( -- ) ip pointe vers le texte, le premier octet est le compte.
9D00AE70  26310004   ADDIU S1, S1, 4              710:       _tpush
9D00AE78  82140000   LB S4, 0(S0)                 711:       lb T, 0(ip)
9D00AE7C  26100001   ADDIU S0, S0, 1              712:       _next
                                                  713:   1:
9D00AE80  12800007   BEQ S4, ZERO, 0x9D00AEA0     714:       beqz T, 2f
9D00AE84  2694FFFF   ADDIU S4, S4, -1             715:       addiu T,T,-1
9D00AE88  24040001   ADDIU A0, ZERO, 1            716:       li  a0, STDIO
9D00AE8C  82050000   LB A1, 0(S0)                 717:       lb a1, 0(ip)
9D00AE90  0F404002   JAL 0x9D010008               718:       jal _putch
9D00AE94  26100001   ADDIU S0, S0, 1              719:       _next
9D00AE98  1000FFF9   BEQ ZERO, ZERO, 0x9D00AE80   720:       b 1b
9D00AE9C  00000000   NOP                          721:       nop
9D00AEA0  8E340000   LW S4, 0(S1)                 722:   2:  lw T, 0(dp)
9D00AEA4  1000FE24   BEQ ZERO, ZERO, 0x9D00A738   723:       b next
9D00AEA8  2631FFFC   ADDIU S1, S1, -4             724:       addiu dp, dp, -CELL_SIZE
                                                  725:   
                                                  726:   delay:  # 'delay' ( msec -- ) delais en millisecondes
9D00AEAC  3C13A000   LUI S3, -24576               727:       lui w, RAM_SEG
9D00AEB0  367300E8   ORI S3, S3, 232              728:       ori w, w, sys_tick
9D00AEB4  8E680000   LW T0, 0(S3)                 729:       lw t0, 0(w)
9D00AEB8  02884021   ADDU T0, S4, T0              730:       addu t0, T,t0
9D00AEBC  8E340000   LW S4, 0(S1)                 731:       lw T, 0(dp)
9D00AEC0  8E690000   LW T1, 0(S3)                 732:   1:  lw t1, 0(w)
9D00AEC4  1528FFFE   BNE T1, T0, 0x9D00AEC0       733:       bne t1, t0, 1b
9D00AEC8  00000000   NOP                          734:       nop
9D00AECC  1000FE1A   BEQ ZERO, ZERO, 0x9D00A738   735:       b next
9D00AED0  2631FFFC   ADDIU S1, S1, -4             736:       addiu dp, dp, -CELL_SIZE
                                                  737:   
                                                  738:   ticks:  # 'ticks'  ( -- n ) empile le compteur sys_tick
9D00AED4  26310004   ADDIU S1, S1, 4              739:       _tpush
9D00AEDC  3C13A000   LUI S3, -24576               740:       lui w, RAM_SEG
9D00AEE0  367300E8   ORI S3, S3, 232              741:       ori w, w, sys_tick
9D00AEE4  1000FE14   BEQ ZERO, ZERO, 0x9D00A738   742:       b next
9D00AEE8  8E740000   LW S4, 0(S3)                 743:       lw T, 0(w)
                                                  744:   
                                                  745:   xstore:  # 'x!' ( n --  R: -- X )  X = n  initialise le compteur de boucle
9D00AEEC  26520004   ADDIU S2, S2, 4              746:       _rpush
9D00AEF4  02E0A821   ADDU S5, S7, ZERO            747:       move R, X
9D00AEF8  0280B821   ADDU S7, S4, ZERO            748:       move X, T
9D00AEFC  8E340000   LW S4, 0(S1)                 749:       lw T, 0(dp)
9D00AF00  1000FE0D   BEQ ZERO, ZERO, 0x9D00A738   750:       b next
9D00AF04  2631FFFC   ADDIU S1, S1, -4             751:       addiu dp,dp,-CELL_SIZE
                                                  752:   
                                                  753:   xfetch:  # 'X@' ( -- X ) empile le compteur de boucle X
9D00AF08  26310004   ADDIU S1, S1, 4              754:       _tpush
9D00AF10  1000FE09   BEQ ZERO, ZERO, 0x9D00A738   755:       b next
9D00AF14  02E0A021   ADDU S4, S7, ZERO            756:       move T, X
                                                  757:   
                                                  758:   loop: #  'loop'  décrément X et boucle a l'adresse qui suit
9D00AF18  26F7FFFF   ADDIU S7, S7, -1             759:       addiu X,X,-1   # si X > 0 sinon quitte la boucle en restaurant X à partir de R
9D00AF1C  16E0FE41   BNE S7, ZERO, 0x9D00A824     760:       bne  X, zero, bra
9D00AF20  00000000   NOP                          761:       nop
9D00AF24  26100001   ADDIU S0, S0, 1              762:       addiu ip,ip,1
9D00AF28  02A0B821   ADDU S7, S5, ZERO            763:       move X, R
9D00AF2C  8E550000   LW S5, 0(S2)                 764:       lw R, 0(rp)
9D00AF30  1000FE01   BEQ ZERO, ZERO, 0x9D00A738   765:       b next
9D00AF34  2652FFFC   ADDIU S2, S2, -4             766:       addiu  rp,rp,-CELL_SIZE
                                                  767:   
                                                  768:   ploop: # '+loop' ( n -- ) soustrait n à X, si X>0 boucle sinon quitte la boucle
9D00AF38  02F4B823   SUBU S7, S7, S4              769:       subu X, X,T
9D00AF3C  8E340000   LW S4, 0(S1)                 770:       _tpop
9D00AF44  06E1FE37   BGEZ S7, 0x9D00A824          771:       bgez X, bra
9D00AF48  00000000   NOP                          772:       nop
9D00AF4C  26100001   ADDIU S0, S0, 1              773:       addiu ip,ip,1
9D00AF50  02A0B821   ADDU S7, S5, ZERO            774:       move X, R
9D00AF54  8E550000   LW S5, 0(S2)                 775:       lw R, 0(rp)
9D00AF58  1000FDF7   BEQ ZERO, ZERO, 0x9D00A738   776:       b next
9D00AF5C  2652FFFC   ADDIU S2, S2, -4             777:       addiu  rp,rp,-CELL_SIZE
                                                  778:   
                                                  779:   
                                                  780:   pick: # ( xu...,x1,x0,u -- xu...,x1,x0,xu ) empile une copie du Uième élément de la pile
9D00AF60  02209821   ADDU S3, S1, ZERO            781:       move w, dp
9D00AF64  0014A080   SLL S4, S4, 2                782:       sll  T, T, 2
9D00AF68  02349823   SUBU S3, S1, S4              783:       subu w, dp,T
9D00AF6C  1000FDF2   BEQ ZERO, ZERO, 0x9D00A738   784:       b next
9D00AF70  8E740000   LW S4, 0(S3)                 785:       lw T, 0(w)
                                                  786:   
                                                  787:   sine:
                                                  788:   
9D00AF74  1000FDF0   BEQ ZERO, ZERO, 0x9D00A738   789:       b next
9D00AF78  00000000   NOP                          790:       nop
                                                  791:   
                                                  792:   acos:
                                                  793:   
9D00AF7C  1000FDEE   BEQ ZERO, ZERO, 0x9D00A738   794:       b next
9D00AF80  00000000   NOP                          795:       nop
                                                  796:   
                                                  797:   asin:
                                                  798:   
9D00AF84  1000FDEC   BEQ ZERO, ZERO, 0x9D00A738   799:       b next
9D00AF88  00000000   NOP                          800:       nop
                                                  801:   
                                                  802:   random:
                                                  803:   
9D00AF8C  1000FDEA   BEQ ZERO, ZERO, 0x9D00A738   804:       b next
9D00AF90  00000000   NOP                          805:       nop
                                                  806:   
                                                  807:   trunc:
                                                  808:   
9D00AF94  1000FDE8   BEQ ZERO, ZERO, 0x9D00A738   809:       b next
9D00AF98  00000000   NOP                          810:       nop
                                                  811:   
                                                  812:   num:
                                                  813:   
9D00AF9C  1000FDE6   BEQ ZERO, ZERO, 0x9D00A738   814:       b next
9D00AFA0  00000000   NOP                          815:       nop
                                                  816:   
                                                  817:   badop:
9D00AFA4  01001021   ADDU V0, T0, ZERO            818:       move v0,t0
                                                  819:   exit:
9D00AFA8  8FB00000   LW S0, 0(SP)                 820:       lw  s0,0(sp)
9D00AFAC  8FB10004   LW S1, 4(SP)                 821:       lw  s1,4(sp)
9D00AFB0  8FB20008   LW S2, 8(SP)                 822:       lw  s2,8(sp)
9D00AFB4  8FB3000C   LW S3, 12(SP)                823:       lw  s3,12(sp)
9D00AFB8  8FB40010   LW S4, 16(SP)                824:       lw  s4,16(sp)
9D00AFBC  8FB50014   LW S5, 20(SP)                825:       lw  s5,20(sp)
9D00AFC0  8FB60018   LW S6, 24(SP)                826:       lw  s6,24(sp)
9D00AFC4  8FB7001C   LW S7, 28(SP)                827:       lw  s7, 28(sp)
9D00AFC8  8FBE0020   LW S8, 32(SP)                828:       lw  s8, 32(sp)
9D00AFCC  8FBF0024   LW RA, 36(SP)                829:       lw  ra,36(sp)
9D00AFD0  03E00008   JR RA                        830:       jr  ra
9D00AFD4  27BD0028   ADDIU SP, SP, 40             831:       addiu sp,sp,40
                                                  832:   
                                                  833:   
                                                  834:   .end StackVM
                                                  835:   
                                                  836:   .ent fetch_int
                                                  837:   fetch_int:  # lit un entier little indian dans espace code VM, retourne dans v0
9D00AFD8  92080000   LBU T0, 0(S0)                838:       lbu t0, 0(ip)
9D00AFDC  92090001   LBU T1, 1(S0)                839:       lbu t1, 1(ip)
9D00AFE0  00094A00   SLL T1, T1, 8                840:       sll  t1,t1, 8
9D00AFE4  920A0002   LBU T2, 2(S0)                841:       lbu t2, 2(ip)
9D00AFE8  000A5400   SLL T2, T2, 16               842:       sll t2,t2, 16
9D00AFEC  820B0003   LB T3, 3(S0)                 843:       lb t3, 3(ip)
9D00AFF0  000B5E00   SLL T3, T3, 24               844:       sll t3,t3, 24
9D00AFF4  01094025   OR T0, T0, T1                845:       or  t0,t0,t1
9D00AFF8  010A4025   OR T0, T0, T2                846:       or  t0,t0,t2
9D00AFFC  010B1025   OR V0, T0, T3                847:       or  v0,t0,t3
9D00B000  03E00008   JR RA                        848:       j ra
9D00B004  26100004   ADDIU S0, S0, 4              849:       addiu ip,ip,CELL_SIZE
                                                  850:       
                                                  851:   
                                                  852:   .end fetch_int
                                                  853:   
                                                  854:   
                                                  855:   
                                                  856:   opcodes_table:
                                                  857:   .word bye,input,lit,call,ret,bra,qbra,exec,store,fetch,cstore
                                                  858:   .word cfetch,rfetch,ufetch,ustore,tor,rfrom,drop,dup,swap,over,pick
                                                  859:   .word plus,minus,star,ustar,mstar,umstar,slash,uslash,modulo,umsmod,msmod,ltz
                                                  860:   .word zequal, bitand,bitor
                                                  861:   .word bitxor,bitnot,clit, wlit, ticks, delay
                                                  862:   .word qdup, oneplus, oneminus,plusstore, twostar, twoslash, twodrop, rot, twodup
                                                  863:   .word  min, max, abs, lshift, rshift, divmod, qbraz, dcnt, rcnt
                                                  864:   .word equal,nequal, less, greater,ltez,gtez, xfetch, xstore, loop, ploop,user
                                                  865:   .word sine, cos, tan, atan, acos, asin,random,trunc,num
                                                  866:   
                                                  867:   
---  /home/jacques/MPLABXProjects/vpc-32/vpc-32.c  ------------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /* 
20:                   * File:   vpc-32.c
21:                   * Author: Jacques Deschênes
22:                   *
23:                   * Created on 26 août 2013, 07:38
24:                   */
25:                  
26:                  
27:                  #include <stdio.h>
28:                  #include <stdlib.h>
29:                  #include <plib.h>
30:                  #include "graphics.h"
31:                  
32:                  #include "hardware/HardwareProfile.h"
33:                  #include "hardware/tvout/ntsc.h"
34:                  #include "hardware/serial_comm/serial_comm.h"
35:                  #include "hardware/ps2_kbd/keyboard.h"
36:                  #include "hardware/Pinguino/diskio.h"
37:                  #include "hardware/Pinguino/fileio.h"
38:                  #include "console.h"
39:                  #include "hardware/Pinguino/ff.h"
40:                  #include "vpcBASIC/vm.h"
41:                  #include "vpcBASIC/vpcBASIC.h"
42:                  #include "hardware/sound/sound.h"
43:                  
44:                  // PIC32MX150F128B Configuration Bit Settings
45:                  #include <xc.h>
46:                  
47:                  // DEVCFG3
48:                  // USERID = No Setting
49:                  #pragma config PMDL1WAY = OFF           // permet plusieurs configurations des périphériques.
50:                  #pragma config IOL1WAY = OFF            // permet plusieurs configuration des broches.
51:                  
52:                  // DEVCFG2
53:                  #pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
54:                  #if SYSCLK==40000000L
55:                  #pragma config FPLLMUL = MUL_16         // SYSCLK=40Mhz
56:                  #else
57:                  #pragma config FPLLMUL = MUL_15          // PLL Multiplier (15x Multiplier) SYSCLK=37,5Mhz
58:                  #endif
59:                  #pragma config FPLLODIV = DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)
60:                  
61:                  // DEVCFG1
62:                  #pragma config FNOSC = PRIPLL           // Oscillator Selection Bits (Primary Osc w/PLL (XT+,HS+,EC+PLL))
63:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
64:                  #pragma config IESO = OFF               // Internal/External Switch Over (Disabled)
65:                  #pragma config POSCMOD = HS             // Primary Oscillator Configuration (XT osc mode)
66:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
67:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
68:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
69:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
70:                  
71:                  // DEVCFG0
72:                  #pragma config JTAGEN = OFF             // JTAG Enable (JTAG Disabled)
73:                  #pragma config ICESEL = RESERVED        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
74:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
75:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
76:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
77:                  
78:                  
79:                  
80:                  #if defined _DEBUG_
81:                  const char *msg1=" ntsc video target\r";
82:                  const char *msg2="012345678901234567890123456789012345678901234567890123567"; // 58 caractères par ligne
83:                  
84:                  
85:                  
86:                  void test_pattern(void){
9D010934  27BDFFE8   ADDIU SP, SP, -24
9D010938  AFBF0014   SW RA, 20(SP)
9D01093C  3C06A000   LUI A2, -24576
9D010940  24C60138   ADDIU A2, A2, 312
9D010944  00C03821   ADDU A3, A2, ZERO
9D010948  24C52080   ADDIU A1, A2, 8320
9D01094C  00C01021   ADDU V0, A2, ZERO
9D01096C  24E30028   ADDIU V1, A3, 40
9D010990  24E71868   ADDIU A3, A3, 6248
87:                      int i,j;
88:                      for (i=0;i<VRES;i++){
9D010964  5445FFFD   BNEL V0, A1, 0x9D01095C
9D010968  AC440000   SW A0, 0(V0)
89:                          video_bmp[i][0]=0x80000000;
9D010950  3C048000   LUI A0, -32768
9D010958  AC440000   SW A0, 0(V0)
90:                          video_bmp[i][HRES/32-1]=1;
9D010954  24030001   ADDIU V1, ZERO, 1
9D01095C  AC430024   SW V1, 36(V0)
9D010960  24420028   ADDIU V0, V0, 40
91:                      }
92:                      for (i=0;i<HRES/32;i++){
9D010980  54C3FFFD   BNEL A2, V1, 0x9D010978
9D010984  ACC20000   SW V0, 0(A2)
9D010988  3C02A000   LUI V0, -24576
9D01098C  24420960   ADDIU V0, V0, 2400
93:                          video_bmp[0][i]=0xffffffff;
9D010970  2402FFFF   ADDIU V0, ZERO, -1
9D010974  ACC20000   SW V0, 0(A2)
94:                          video_bmp[VRES-1][i]=0xffffffff;
9D010978  ACC22058   SW V0, 8280(A2)
9D01097C  24C60004   ADDIU A2, A2, 4
95:                      }
96:                      for (i=VRES/4;i<VRES/2+VRES/4;i++){
9D0109C8  5447FFFB   BNEL V0, A3, 0x9D0109B8
9D0109CC  AC460000   SW A2, 0(V0)
97:                          video_bmp[i][2]=0xFF00FF00;
9D010994  3C06FF00   LUI A2, -256
9D010998  34C6FF00   ORI A2, A2, -256
9D0109B4  AC460000   SW A2, 0(V0)
98:                          video_bmp[i][3]=0xF0F0F0F0;
9D01099C  3C05F0F0   LUI A1, -3856
9D0109A0  34A5F0F0   ORI A1, A1, -3856
9D0109B8  AC450004   SW A1, 4(V0)
99:                          video_bmp[i][4]=0xcccccccc;
9D0109A4  3C04CCCC   LUI A0, -13108
9D0109A8  3484CCCC   ORI A0, A0, -13108
9D0109BC  AC440008   SW A0, 8(V0)
100:                         video_bmp[i][5]=0xaaaaaaaa;
9D0109AC  3C03AAAA   LUI V1, -21846
9D0109B0  3463AAAA   ORI V1, V1, -21846
9D0109C0  AC43000C   SW V1, 12(V0)
9D0109C4  24420028   ADDIU V0, V0, 40
101:                     }//i
102:                     print(LOCAL_CON,msg1);
9D0109D0  00002021   ADDU A0, ZERO, ZERO
9D0109D4  0F40229C   JAL print
9D0109D8  8F858024   LW A1, -32732(GP)
103:                     print(LOCAL_CON,msg2);
9D0109DC  00002021   ADDU A0, ZERO, ZERO
9D0109E0  0F40229C   JAL print
9D0109E4  8F858028   LW A1, -32728(GP)
104:                 }//test_pattern()
9D0109E8  8FBF0014   LW RA, 20(SP)
9D0109EC  03E00008   JR RA
9D0109F0  27BD0018   ADDIU SP, SP, 24
105:                 
106:                 const int pts[6]={HRES/2,VRES/2,HRES/2+HRES/3,VRES/2+VRES/3,HRES/2-HRES/3,VRES/2+VRES/3};
107:                 
108:                 void graphics_test(){ // test des fonctions graphiques
9D0109F4  27BDFFE0   ADDIU SP, SP, -32
9D0109F8  AFBF001C   SW RA, 28(SP)
109:                     int i;
110:                 
111:                     rectangle(0,0,HRES-1,VRES-1);
9D0109FC  00002021   ADDU A0, ZERO, ZERO
9D010A00  00002821   ADDU A1, ZERO, ZERO
9D010A04  2406013F   ADDIU A2, ZERO, 319
9D010A08  0F402CE3   JAL rectangle
9D010A0C  240700CF   ADDIU A3, ZERO, 207
112:                     polygon(pts,3);
9D010A10  3C049D01   LUI A0, -25343
9D010A14  248440B0   ADDIU A0, A0, 16560
9D010A18  0F402DB1   JAL polygon
9D010A1C  24050003   ADDIU A1, ZERO, 3
113:                     circle(HRES/2,VRES/2,100);
9D010A20  240400A0   ADDIU A0, ZERO, 160
9D010A24  24050068   ADDIU A1, ZERO, 104
9D010A28  0F402D05   JAL circle
9D010A2C  24060064   ADDIU A2, ZERO, 100
114:                 //    for (i=0;i<100;i++){
115:                 //        ellipse(HRES/3+i,VRES/3+i,50,30);
116:                 //    }
117:                     bezier(20,200,20,40,300,40);
9D010A30  2402012C   ADDIU V0, ZERO, 300
9D010A34  AFA20010   SW V0, 16(SP)
9D010A38  24020028   ADDIU V0, ZERO, 40
9D010A3C  AFA20014   SW V0, 20(SP)
9D010A40  24040014   ADDIU A0, ZERO, 20
9D010A44  240500C8   ADDIU A1, ZERO, 200
9D010A48  24060014   ADDIU A2, ZERO, 20
9D010A4C  0F402DD7   JAL bezier
9D010A50  24070028   ADDIU A3, ZERO, 40
118:                     delay_ms(500);
9D010A54  0F403E92   JAL delay_ms
9D010A58  240401F4   ADDIU A0, ZERO, 500
119:                 }//graphics_test
9D010A5C  8FBF001C   LW RA, 28(SP)
9D010A60  03E00008   JR RA
9D010A64  27BD0020   ADDIU SP, SP, 32
120:                 
121:                 #endif
122:                 
123:                 const unsigned int e3k[]={ // rencontre du 3ième type
124:                 784,500, // sol4
125:                 880,500,// la4
126:                 698,500,// fa4
127:                 349,500,// fa3
128:                 523,500,// do4
129:                 0,0
130:                 };
131:                 
132:                 void main(void) {
9D010A68  27BDFFE0   ADDIU SP, SP, -32
9D010A6C  AFBF001C   SW RA, 28(SP)
9D010A70  AFB10018   SW S1, 24(SP)
133:                     HardwareInit();
9D010A74  0F403E05   JAL HardwareInit
9D010A78  AFB00014   SW S0, 20(SP)
134:                     UartInit(STDIO,115200,DEFAULT_LINE_CTRL);
9D010A7C  24040001   ADDIU A0, ZERO, 1
9D010A80  3C050001   LUI A1, 1
9D010A84  34A5C200   ORI A1, A1, -15872
9D010A88  0F403FD8   JAL UartInit
9D010A8C  00003021   ADDU A2, ZERO, ZERO
135:                     heap_size=free_heap();
9D010A90  0F403E99   JAL free_heap
9D010A94  00000000   NOP
9D010A98  AF8280B8   SW V0, -32584(GP)
136:                 #if defined DEBUG
137:                     test_pattern();
138:                 #endif
139:                     UartPrint(STDOUT,"video initialization\r");
9D010A9C  24040001   ADDIU A0, ZERO, 1
9D010AA0  3C059D01   LUI A1, -25343
9D010AA4  0F40403A   JAL UartPrint
9D010AA8  24A53F84   ADDIU A1, A1, 16260
140:                     VideoInit();
9D010AAC  0F403C06   JAL VideoInit
9D010AB0  00000000   NOP
141:                     delay_ms(500);
9D010AB4  0F403E92   JAL delay_ms
9D010AB8  240401F4   ADDIU A0, ZERO, 500
142:                     UartPrint(STDOUT,"keyboard initialization: ");
9D010ABC  24040001   ADDIU A0, ZERO, 1
9D010AC0  3C059D01   LUI A1, -25343
9D010AC4  0F40403A   JAL UartPrint
9D010AC8  24A53F9C   ADDIU A1, A1, 16284
143:                     if (KeyboardInit()){
9D010ACC  0F402087   JAL KeyboardInit
9D010AD0  00000000   NOP
9D010AD4  10400006   BEQ V0, ZERO, 0x9D010AF0
9D010AD8  24040001   ADDIU A0, ZERO, 1
144:                         UartPrint(STDOUT,"OK\r");
9D010ADC  3C059D01   LUI A1, -25343
9D010AE0  0F40403A   JAL UartPrint
9D010AE4  24A53FB8   ADDIU A1, A1, 16312
145:                         comm_channel=LOCAL_CON;
9D010AE8  0B4042C5   J 0x9D010B14
9D010AEC  A380804C   SB ZERO, -32692(GP)
146:                     }else{
147:                         UartPrint(STDOUT,"keyboard error\r");
9D010AF0  3C059D01   LUI A1, -25343
9D010AF4  0F40403A   JAL UartPrint
9D010AF8  24A53FBC   ADDIU A1, A1, 16316
148:                         UartPrint(STDOUT,"Using uart2 channel.\r");
9D010AFC  24040001   ADDIU A0, ZERO, 1
9D010B00  3C059D01   LUI A1, -25343
9D010B04  0F40403A   JAL UartPrint
9D010B08  24A53FCC   ADDIU A1, A1, 16332
149:                         comm_channel=SERIAL_CON;
9D010B0C  24020001   ADDIU V0, ZERO, 1
9D010B10  A382804C   SB V0, -32692(GP)
150:                     }
151:                     text_coord_t cpos;
152:                     UartPrint(STDOUT,"SD initialization: ");
9D010B14  24040001   ADDIU A0, ZERO, 1
9D010B18  3C059D01   LUI A1, -25343
9D010B1C  0F40403A   JAL UartPrint
9D010B20  24A53FE4   ADDIU A1, A1, 16356
153:                     if (!mount(0)){
9D010B24  0F403A06   JAL mount
9D010B28  00002021   ADDU A0, ZERO, ZERO
9D010B2C  14400006   BNE V0, ZERO, 0x9D010B48
9D010B30  24040001   ADDIU A0, ZERO, 1
154:                         UartPrint(STDOUT,"Failed\r");
9D010B34  3C059D01   LUI A1, -25343
9D010B38  0F40403A   JAL UartPrint
9D010B3C  24A53FF8   ADDIU A1, A1, 16376
155:                         SDCardReady=FALSE;
9D010B40  0B4042D7   J 0x9D010B5C
9D010B44  AF808100   SW ZERO, -32512(GP)
156:                     }else{
157:                         UartPrint(STDOUT,"succeeded\r");
9D010B48  3C059D01   LUI A1, -25343
9D010B4C  0F40403A   JAL UartPrint
9D010B50  24A54000   ADDIU A1, A1, 16384
158:                         SDCardReady=TRUE;
9D010B54  24020001   ADDIU V0, ZERO, 1
9D010B58  AF828100   SW V0, -32512(GP)
159:                     }
160:                     UartPrint(STDOUT,"SRAM initialization\r");
9D010B5C  24040001   ADDIU A0, ZERO, 1
9D010B60  3C059D01   LUI A1, -25343
9D010B64  0F40403A   JAL UartPrint
9D010B68  24A5400C   ADDIU A1, A1, 16396
161:                     sram_init();
9D010B6C  0F40325F   JAL sram_init
9D010B70  3C110001   LUI S1, 1
162:                     UartPrint(STDOUT,"sound initialization.\r");
9D010B74  24040001   ADDIU A0, ZERO, 1
9D010B78  3C059D01   LUI A1, -25343
9D010B7C  0F40403A   JAL UartPrint
9D010B80  24A54024   ADDIU A1, A1, 16420
163:                     tune((unsigned int*)&e3k[0]);
9D010B84  3C049D01   LUI A0, -25343
9D010B88  0F4043FC   JAL tune
9D010B8C  248440C8   ADDIU A0, A0, 16584
164:                     UartPrint(STDOUT,"initialization completed.\r");
9D010B90  24040001   ADDIU A0, ZERO, 1
9D010B94  3C059D01   LUI A1, -25343
9D010B98  0F40403A   JAL UartPrint
9D010B9C  24A5403C   ADDIU A1, A1, 16444
165:                     set_cursor(CR_BLOCK); // sauvegare video_buffer dans SRAM
9D010BA0  0F40239E   JAL set_cursor
9D010BA4  24040001   ADDIU A0, ZERO, 1
166:                     clear_screen();
9D010BA8  0F402290   JAL clear_screen
9D010BAC  3C10A000   LUI S0, -24576
167:                 #if defined _DEBUG_
168:                     graphics_test();
9D010BB0  0F40427D   JAL graphics_test
9D010BB4  00000000   NOP
169:                     set_curpos(0,LINE_PER_SCREEN-1);
9D010BB8  00002021   ADDU A0, ZERO, ZERO
9D010BBC  0F40233E   JAL set_curpos
9D010BC0  24050019   ADDIU A1, ZERO, 25
170:                     print(comm_channel,"test");
9D010BC4  8384804C   LB A0, -32692(GP)
9D010BC8  3C059D01   LUI A1, -25343
9D010BCC  0F40229C   JAL print
9D010BD0  24A54058   ADDIU A1, A1, 16472
171:                     sram_write_block(100000,video_bmp,BMP_SIZE);
9D010BD4  362486A0   ORI A0, S1, -31072
9D010BD8  26050138   ADDIU A1, S0, 312
9D010BDC  0F4032E6   JAL sram_write_block
9D010BE0  24062080   ADDIU A2, ZERO, 8320
172:                     delay_ms(1000);
9D010BE4  0F403E92   JAL delay_ms
9D010BE8  240403E8   ADDIU A0, ZERO, 1000
173:                     clear_screen();
9D010BEC  0F402290   JAL clear_screen
9D010BF0  00000000   NOP
174:                     delay_ms(1000);
9D010BF4  0F403E92   JAL delay_ms
9D010BF8  240403E8   ADDIU A0, ZERO, 1000
175:                     sram_read_block(100000,video_bmp,BMP_SIZE);
9D010BFC  362486A0   ORI A0, S1, -31072
9D010C00  26050138   ADDIU A1, S0, 312
9D010C04  0F4032C1   JAL sram_read_block
9D010C08  24062080   ADDIU A2, ZERO, 8320
176:                     delay_ms(1000);
9D010C0C  0F403E92   JAL delay_ms
9D010C10  240403E8   ADDIU A0, ZERO, 1000
177:                     clear_screen();
9D010C14  0F402290   JAL clear_screen
9D010C18  00000000   NOP
178:                 //    print(comm_channel,"heap_size: ");
179:                 //    print_int(comm_channel,heap_size,0);
180:                 //    crlf();
181:                 #endif
182:                     shell();
9D010C1C  0F401DB4   JAL shell
9D010C20  00000000   NOP
183:                 } // main()
9D010C24  8FBF001C   LW RA, 28(SP)
9D010C28  8FB10018   LW S1, 24(SP)
9D010C2C  8FB00014   LW S0, 20(SP)
9D010C30  03E00008   JR RA
9D010C34  27BD0020   ADDIU SP, SP, 32
184:                 
185:                 
---  /home/jacques/MPLABXProjects/vpc-32/shell.c  -------------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  
20:                  /*
21:                   * File:   shell.h
22:                   * Author: Jacques Deschênes
23:                   *
24:                   * Created on 18 septembre 2013, 07:29
25:                   * Description: un environnement de commande simple pour le VPC-32.
26:                   *   liste des commandes:
27:                   *      ls     liste des fichiers sur la carte SD
28:                   *      rm     efface un fichier.
29:                   *      mv     renomme un fichier.
30:                   *      ed     ouvre l'éditeur
31:                   *      as     assemble un fichier écris en assembleur pour la machine virtuelle.
32:                   *      run    execute un programme compilé pour la machine virtuelle.
33:                   *      cp     copie un fichier
34:                   *      snd    envoie un fichier vers le port sériel
35:                   *      rcv    reçois un fichier par le port sériel
36:                   *      forth  lance l'environnement vpForth
37:                   *      puts mot  imprime à l'écran le mot qui suis
38:                   *      expr {expression}  évalue une expression et retourne le résultat
39:                   */
40:                  
41:                  #include <string.h>
42:                  #include "hardware/HardwareProfile.h"
43:                  #include "hardware/ps2_kbd/keyboard.h"
44:                  #include "console.h"
45:                  #include "hardware/Pinguino/ff.h"
46:                  #include "hardware/Pinguino/fileio.h"
47:                  #include <plib.h>
48:                  #include "shell.h"
49:                  #include "vpcBASIC/vpcBASIC.h"
50:                  
51:                  #define MAX_LINE_LEN 80
52:                  #define MAX_TOKEN 5
53:                  
54:                  /*
55:                  typedef enum {
56:                      ERR_NONE=0,
57:                      ERR_NOT_DONE,
58:                      ERR_ALLOC,
59:                      ERR_USAGE,
60:                      ERR_FIL_OPEN,
61:                      ERR_CPY,
62:                      ERR_MKDIR,
63:                      ERR_NOTEXIST,
64:                      ERR_DENIED,
65:                      ERR_FIO
66:                  } SH_ERROR;
67:                  */
68:                  
69:                  const char *ERR_MSG[]={
70:                      "no error\r",
71:                      "not implemented yet.\r",
72:                      "Memory allocation error.\r",
73:                      "Bad usage.\r",
74:                      "File open error.\r",
75:                      "Copy error.\r",
76:                      "Mkdir error.\r",
77:                      "file does not exist.\r",
78:                      "operation denied.\r",
79:                      "disk operation error, code is %d \r",
80:                      "no SD card detected.\r"
81:                  };
82:                  
83:                  void print_error_msg(SH_ERROR err_code,const char *detail,FRESULT io_code){
9D0065B4  27BDFFE0   ADDIU SP, SP, -32
9D0065B8  AFBF001C   SW RA, 28(SP)
9D0065BC  AFB20018   SW S2, 24(SP)
9D0065C0  AFB10014   SW S1, 20(SP)
9D0065C4  AFB00010   SW S0, 16(SP)
9D0065C8  00A08021   ADDU S0, A1, ZERO
84:                      char *fmt;
85:                      if (err_code==ERR_FIO){
9D0065CC  24020009   ADDIU V0, ZERO, 9
9D0065D0  14820011   BNE A0, V0, 0x9D006618
9D0065D4  00C08821   ADDU S1, A2, ZERO
86:                          fmt=malloc(64);
9D0065D8  0F4047DE   JAL malloc
9D0065DC  24040040   ADDIU A0, ZERO, 64
87:                          if (fmt){
9D0065E0  10400014   BEQ V0, ZERO, 0x9D006634
9D0065E4  00409021   ADDU S2, V0, ZERO
88:                              sprintf(fmt,ERR_MSG[ERR_FIO],io_code);
9D0065E8  00402021   ADDU A0, V0, ZERO
9D0065EC  3C02A000   LUI V0, -24576
9D0065F0  8C4528F4   LW A1, 10484(V0)
9D0065F4  0F405BCA   JAL sprintf
9D0065F8  02203021   ADDU A2, S1, ZERO
89:                              print(comm_channel,fmt);
9D0065FC  8384804C   LB A0, -32692(GP)
9D006600  0F40229C   JAL print
9D006604  02402821   ADDU A1, S2, ZERO
90:                              free(fmt);
9D006608  0F405E55   JAL free
9D00660C  02402021   ADDU A0, S2, ZERO
9D006610  0B40198D   J 0x9D006634
9D006614  00000000   NOP
91:                          }
92:                      }else{
93:                         print(comm_channel,ERR_MSG[err_code]);
9D006618  00042080   SLL A0, A0, 2
9D00661C  3C02A000   LUI V0, -24576
9D006620  244228D0   ADDIU V0, V0, 10448
9D006624  00821021   ADDU V0, A0, V0
9D006628  8384804C   LB A0, -32692(GP)
9D00662C  0F40229C   JAL print
9D006630  8C450000   LW A1, 0(V0)
94:                      }
95:                      if (detail){
9D006634  12000003   BEQ S0, ZERO, 0x9D006644
9D006638  8384804C   LB A0, -32692(GP)
96:                         print(comm_channel,detail);
9D00663C  0F40229C   JAL print
9D006640  02002821   ADDU A1, S0, ZERO
97:                      }
98:                  }//print_error_msg()
9D006644  8FBF001C   LW RA, 28(SP)
9D006648  8FB20018   LW S2, 24(SP)
9D00664C  8FB10014   LW S1, 20(SP)
9D006650  8FB00010   LW S0, 16(SP)
9D006654  03E00008   JR RA
9D006658  27BD0020   ADDIU SP, SP, 32
99:                  
100:                 typedef struct{
101:                     char buff[MAX_LINE_LEN]; // chaîne saisie par l'utilisateur.
102:                     unsigned char len;  // longueur de la chaîne.
103:                     unsigned char first; // position du premier caractère du mot
104:                     unsigned char next; // position du du curseur de l'analyseur.
105:                 } input_buff_t;
106:                 
107:                 static input_buff_t cmd_line;
108:                 static char *cmd_tokens[MAX_TOKEN];
109:                 
110:                 typedef enum CMDS {CMD_CD, CMD_CLEAR,CMD_CPY,CMD_DEL,CMD_DIR,CMD_ED,CMD_EXPR,
111:                                    CMD_FORMAT,CMD_FORTH,CMD_HELP,CMD_MKDIR,CMD_MORE, CMD_PUTS,
112:                                    CMD_REBOOT,CMD_RCV,CMD_REN,CMD_SND,
113:                                    } cmds_t;
114:                 
115:                 #define CMD_LEN 17
116:                 const char *commands[CMD_LEN]={"cd","cls","copy","del","dir","edit","expr","format","forth",
117:                                                "help","mkdir","more","puts","reboot","receive","ren","send"};
118:                 
119:                 int cmd_search(char *target){
9D00665C  27BDFFD8   ADDIU SP, SP, -40
9D006660  AFBF0024   SW RA, 36(SP)
9D006664  AFB30020   SW S3, 32(SP)
9D006668  AFB2001C   SW S2, 28(SP)
9D00666C  AFB10018   SW S1, 24(SP)
9D006670  AFB00014   SW S0, 20(SP)
9D006674  00809021   ADDU S2, A0, ZERO
120:                     int i;
121:                     for (i=CMD_LEN-1;i>=0;i--){
9D006678  3C11A000   LUI S1, -24576
9D00667C  2631293C   ADDIU S1, S1, 10556
9D006680  24100010   ADDIU S0, ZERO, 16
9D006684  2413FFFF   ADDIU S3, ZERO, -1
9D00669C  2610FFFF   ADDIU S0, S0, -1
9D0066A0  1613FFF9   BNE S0, S3, 0x9D006688
9D0066A4  2631FFFC   ADDIU S1, S1, -4
122:                         if (!strcmp(target,commands[i])){
9D006688  02402021   ADDU A0, S2, ZERO
9D00668C  0F4052EE   JAL 0x9D014BB8
9D006690  8E250000   LW A1, 0(S1)
9D006694  10400005   BEQ V0, ZERO, 0x9D0066AC
9D006698  02001021   ADDU V0, S0, ZERO
123:                             break;
124:                         }
125:                     }
126:                     return i;
127:                 }//cmd_search()
9D0066A8  02001021   ADDU V0, S0, ZERO
9D0066AC  8FBF0024   LW RA, 36(SP)
9D0066B0  8FB30020   LW S3, 32(SP)
9D0066B4  8FB2001C   LW S2, 28(SP)
9D0066B8  8FB10018   LW S1, 24(SP)
9D0066BC  8FB00014   LW S0, 20(SP)
9D0066C0  03E00008   JR RA
9D0066C4  27BD0028   ADDIU SP, SP, 40
128:                 
129:                 void display_cmd_list(){
9D0066C8  27BDFFC8   ADDIU SP, SP, -56
9D0066CC  AFBF0034   SW RA, 52(SP)
9D0066D0  AFB50030   SW S5, 48(SP)
9D0066D4  AFB4002C   SW S4, 44(SP)
9D0066D8  AFB30028   SW S3, 40(SP)
9D0066DC  AFB20024   SW S2, 36(SP)
9D0066E0  AFB10020   SW S1, 32(SP)
9D0066E4  AFB0001C   SW S0, 28(SP)
9D00670C  02009021   ADDU S2, S0, ZERO
130:                     int i;
131:                     text_coord_t pos;
132:                     for(i=0;i<CMD_LEN;i++){
9D0066E8  3C10A000   LUI S0, -24576
9D0066EC  261028FC   ADDIU S0, S0, 10492
9D0066F0  00008821   ADDU S1, ZERO, ZERO
9D006700  24140011   ADDIU S4, ZERO, 17
9D006758  26310001   ADDIU S1, S1, 1
9D00675C  1634FFE9   BNE S1, S4, 0x9D006704
9D006760  26100004   ADDIU S0, S0, 4
133:                         pos=get_curpos();
9D006704  0F402333   JAL get_curpos
9D006708  27A40010   ADDIU A0, SP, 16
134:                         if (pos.x>(CHAR_PER_LINE-strlen(commands[i])-2)){
9D0066F4  24130033   ADDIU S3, ZERO, 51
9D006710  0F40514F   JAL 0x9D01453C
9D006714  8E040000   LW A0, 0(S0)
9D006718  97A30010   LHU V1, 16(SP)
9D00671C  02621023   SUBU V0, S3, V0
9D006720  0043182B   SLTU V1, V0, V1
9D006724  10600004   BEQ V1, ZERO, 0x9D006738
9D006728  8384804C   LB A0, -32692(GP)
135:                             put_char(comm_channel,'\r');
9D00672C  0F402205   JAL put_char
9D006730  2405000D   ADDIU A1, ZERO, 13
136:                         }
137:                         print(comm_channel,commands[i]);
9D006734  8384804C   LB A0, -32692(GP)
9D006738  0F40229C   JAL print
9D00673C  8E450000   LW A1, 0(S2)
138:                         if (i<(CMD_LEN-1)){
9D006740  2A220010   SLTI V0, S1, 16
9D006744  50400005   BEQL V0, ZERO, 0x9D00675C
9D006748  26310001   ADDIU S1, S1, 1
139:                             print(comm_channel," ");
9D0066F8  3C159D01   LUI S5, -25343
9D0066FC  26B5F41C   ADDIU S5, S5, -3044
9D00674C  8384804C   LB A0, -32692(GP)
9D006750  0F40229C   JAL print
9D006754  02A02821   ADDU A1, S5, ZERO
140:                         }
141:                     }
142:                     put_char(comm_channel,'\r');
9D006764  8384804C   LB A0, -32692(GP)
9D006768  0F402205   JAL put_char
9D00676C  2405000D   ADDIU A1, ZERO, 13
143:                 }
9D006770  8FBF0034   LW RA, 52(SP)
9D006774  8FB50030   LW S5, 48(SP)
9D006778  8FB4002C   LW S4, 44(SP)
9D00677C  8FB30028   LW S3, 40(SP)
9D006780  8FB20024   LW S2, 36(SP)
9D006784  8FB10020   LW S1, 32(SP)
9D006788  8FB0001C   LW S0, 28(SP)
9D00678C  03E00008   JR RA
9D006790  27BD0038   ADDIU SP, SP, 56
144:                 
145:                 void cmd_format(int i){
9D006794  27BDFFE8   ADDIU SP, SP, -24
146:                     if (i==2){
9D006798  24020002   ADDIU V0, ZERO, 2
9D00679C  14820007   BNE A0, V0, 0x9D0067BC
9D0067A0  AFBF0014   SW RA, 20(SP)
147:                         print_error_msg(ERR_NOT_DONE,NULL,0);
9D0067A4  24040001   ADDIU A0, ZERO, 1
9D0067A8  00002821   ADDU A1, ZERO, ZERO
9D0067AC  0F40196D   JAL print_error_msg
9D0067B0  00003021   ADDU A2, ZERO, ZERO
148:                     }else{
149:                         print(comm_channel,"USAGE: format volume_name\r");
9D0067BC  8384804C   LB A0, -32692(GP)
9D0067C0  3C059D01   LUI A1, -25343
9D0067C4  0F40229C   JAL print
9D0067C8  24A5F420   ADDIU A1, A1, -3040
150:                     }
151:                 }
9D0067B4  0B4019F4   J 0x9D0067D0
9D0067B8  8FBF0014   LW RA, 20(SP)
9D0067CC  8FBF0014   LW RA, 20(SP)
9D0067D0  03E00008   JR RA
9D0067D4  27BD0018   ADDIU SP, SP, 24
152:                 
153:                 static int next_token(void){
154:                     unsigned char loop,quote,escape;
155:                     cmd_line.first=cmd_line.next;
9D0074F4  3C12A000   LUI S2, -24576
9D007554  264329B0   ADDIU V1, S2, 10672
9D007558  90620052   LBU V0, 82(V1)
9D00755C  A0620051   SB V0, 81(V1)
156:                     while (cmd_line.first<cmd_line.len && (cmd_line.buff[cmd_line.first]==' ' ||
9D0074F8  24100020   ADDIU S0, ZERO, 32
9D0074FC  24110009   ADDIU S1, ZERO, 9
9D007560  90650050   LBU A1, 80(V1)
9D007564  0045202B   SLTU A0, V0, A1
9D007568  00401821   ADDU V1, V0, ZERO
9D00756C  14800009   BNE A0, ZERO, 0x9D007594
9D007570  264629B0   ADDIU A2, S2, 10672
9D007580  14450004   BNE V0, A1, 0x9D007594
9D007584  00401821   ADDU V1, V0, ZERO
9D007588  264329B0   ADDIU V1, S2, 10672
9D00758C  0B401D6F   J 0x9D0075BC
9D007590  A0620051   SB V0, 81(V1)
9D007594  00662021   ADDU A0, V1, A2
9D007598  80840000   LB A0, 0(A0)
9D00759C  5090FFF7   BEQL A0, S0, 0x9D00757C
9D0075A0  24620001   ADDIU V0, V1, 1
9D0075A4  5091FFF5   BEQL A0, S1, 0x9D00757C
9D0075A8  24620001   ADDIU V0, V1, 1
9D0075AC  264429B0   ADDIU A0, S2, 10672
9D0075B0  A0820051   SB V0, 81(A0)
9D0075B4  00601021   ADDU V0, V1, ZERO
157:                             cmd_line.buff[cmd_line.first]==9)){
158:                         cmd_line.first++;
9D00757C  304200FF   ANDI V0, V0, 255
159:                     }
160:                     cmd_line.next=cmd_line.first;
9D007574  0B401D6F   J 0x9D0075BC
9D007578  264329B0   ADDIU V1, S2, 10672
9D0075B8  264329B0   ADDIU V1, S2, 10672
9D0075BC  A0620052   SB V0, 82(V1)
161:                     loop=TRUE;
162:                     quote=FALSE;
9D0075D4  00003821   ADDU A3, ZERO, ZERO
9D0075D8  264829B0   ADDIU T0, S2, 10672
163:                     escape=FALSE;
9D0075D0  00002821   ADDU A1, ZERO, ZERO
164:                     while (loop && (cmd_line.next<cmd_line.len)){
9D0075C0  90690050   LBU T1, 80(V1)
9D0075C4  0049182B   SLTU V1, V0, T1
9D0075C8  10600028   BEQ V1, ZERO, 0x9D00766C
9D0075CC  00402021   ADDU A0, V0, ZERO
9D007658  0049182B   SLTU V1, V0, T1
9D00765C  1460FFDF   BNE V1, ZERO, 0x9D0075DC
9D007660  00402021   ADDU A0, V0, ZERO
9D007664  264329B0   ADDIU V1, S2, 10672
9D007668  A0620052   SB V0, 82(V1)
165:                         switch (cmd_line.buff[cmd_line.next]){
9D007500  24130022   ADDIU S3, ZERO, 34
9D007504  0B401D55   J 0x9D007554
9D007508  2415005C   ADDIU S5, ZERO, 92
9D0075DC  00481821   ADDU V1, V0, T0
9D0075E0  80630000   LB V1, 0(V1)
9D0075E4  10730015   BEQ V1, S3, 0x9D00763C
9D0075E8  28660023   SLTI A2, V1, 35
9D0075EC  10C00007   BEQ A2, ZERO, 0x9D00760C
9D0075F0  00000000   NOP
9D0075F4  10710009   BEQ V1, S1, 0x9D00761C
9D0075F8  00000000   NOP
9D0075FC  54700014   BNEL V1, S0, 0x9D007650
9D007600  0007280B   MOVN A1, ZERO, A3
9D007604  0B401D87   J 0x9D00761C
9D007608  00000000   NOP
9D00760C  54750010   BNEL V1, S5, 0x9D007650
9D007610  0007280B   MOVN A1, ZERO, A3
166:                             case ' ':
167:                             case 9: // TAB
168:                                 if (!quote){
9D00761C  54E0000D   BNEL A3, ZERO, 0x9D007654
9D007620  24820001   ADDIU V0, A0, 1
169:                                     cmd_line.next--;
9D007624  264329B0   ADDIU V1, S2, 10672
9D007628  2442FFFF   ADDIU V0, V0, -1
9D00762C  0B401DAF   J 0x9D0076BC
9D007630  A0620052   SB V0, 82(V1)
170:                                     loop=FALSE;
171:                                 }
172:                                 break;
173:                             case '\\':
174:                                 if (quote){
175:                                     if (!escape){
176:                                        escape=TRUE;
9D007614  0B401D8D   J 0x9D007634
9D007618  2CA20001   SLTIU V0, A1, 1
9D007634  0B401D94   J 0x9D007650
9D007638  0047280B   MOVN A1, V0, A3
177:                                     }
178:                                     else{
179:                                         escape=FALSE;
180:                                     }
181:                                 }
182:                                 break;
183:                             case '"':
184:                                 if (!quote){
9D00763C  50E00004   BEQL A3, ZERO, 0x9D007650
9D007640  24070001   ADDIU A3, ZERO, 1
185:                                     quote=1;
186:                                 }
187:                                 else if (!escape){
9D007644  10A0001C   BEQ A1, ZERO, 0x9D0076B8
9D007648  264229B0   ADDIU V0, S2, 10672
9D00764C  00002821   ADDU A1, ZERO, ZERO
188:                                     loop=FALSE;
189:                                 }else{
190:                                     escape=FALSE;
9D0074E4  3C02A000   LUI V0, -24576
9D0074E8  24422A04   ADDIU V0, V0, 10756
9D0074EC  AFA20010   SW V0, 16(SP)
191:                                 }
192:                                 break;
193:                             default:
194:                                 if (quote && escape){
9D007650  24820001   ADDIU V0, A0, 1
9D007654  304200FF   ANDI V0, V0, 255
195:                                     escape=FALSE;
196:                                 }
197:                 
198:                         }//switch
199:                         cmd_line.next++;
9D0076BC  264229B0   ADDIU V0, S2, 10672
9D0076C0  90430052   LBU V1, 82(V0)
9D0076C4  24630001   ADDIU V1, V1, 1
9D0076C8  0B401D9C   J 0x9D007670
9D0076CC  A0430052   SB V1, 82(V0)
200:                     } // while
201:                     if (cmd_line.next>cmd_line.first)
9D00766C  264229B0   ADDIU V0, S2, 10672
9D007670  90570052   LBU S7, 82(V0)
9D007674  90560051   LBU S6, 81(V0)
202:                         return 1;
203:                     else
204:                         return 0;
205:                 }//next_token()
206:                 
207:                 void cd(int i){ // change le répertoire courant.
9D0067D8  27BDFFE8   ADDIU SP, SP, -24
9D0067DC  AFBF0014   SW RA, 20(SP)
9D0067E0  AFB00010   SW S0, 16(SP)
208:                     char *path;
209:                     if (!SDCardReady){
9D0067E4  8F828100   LW V0, -32512(GP)
9D0067E8  1440000C   BNE V0, ZERO, 0x9D00681C
9D0067EC  00808021   ADDU S0, A0, ZERO
210:                         if (!mount(0)){
9D0067F0  0F403A06   JAL mount
9D0067F4  00002021   ADDU A0, ZERO, ZERO
9D0067F8  14400007   BNE V0, ZERO, 0x9D006818
9D0067FC  24020001   ADDIU V0, ZERO, 1
211:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D006800  2404000A   ADDIU A0, ZERO, 10
9D006804  00002821   ADDU A1, ZERO, ZERO
9D006808  0F40196D   JAL print_error_msg
9D00680C  00003021   ADDU A2, ZERO, ZERO
212:                             return;
9D006810  0B401A1F   J 0x9D00687C
9D006814  8FBF0014   LW RA, 20(SP)
213:                         }else{
214:                             SDCardReady=TRUE;
9D006818  AF828100   SW V0, -32512(GP)
215:                         }
216:                     }
217:                     FRESULT error=FR_OK;
218:                    if (i==2){
9D00681C  24020002   ADDIU V0, ZERO, 2
9D006820  16020005   BNE S0, V0, 0x9D006838
9D006824  3C02A000   LUI V0, -24576
219:                        error=f_chdir(cmd_tokens[1]);
9D006828  0F4008DF   JAL f_chdir
9D00682C  8C442A08   LW A0, 10760(V0)
220:                    }
221:                    if (!error){
9D006830  14400012   BNE V0, ZERO, 0x9D00687C
9D006834  8FBF0014   LW RA, 20(SP)
222:                        path=malloc(255);
9D006838  0F4047DE   JAL malloc
9D00683C  240400FF   ADDIU A0, ZERO, 255
223:                        if (path){
9D006840  1040000D   BEQ V0, ZERO, 0x9D006878
9D006844  00408021   ADDU S0, V0, ZERO
224:                           error=f_getcwd(path,255);
9D006848  00402021   ADDU A0, V0, ZERO
9D00684C  0F40090B   JAL f_getcwd
9D006850  240500FF   ADDIU A1, ZERO, 255
225:                           if(!error){
9D006854  14400006   BNE V0, ZERO, 0x9D006870
9D006858  8384804C   LB A0, -32692(GP)
226:                               print(comm_channel,path);
9D00685C  0F40229C   JAL print
9D006860  02002821   ADDU A1, S0, ZERO
227:                               put_char(comm_channel,'\r');
9D006864  8384804C   LB A0, -32692(GP)
9D006868  0F402205   JAL put_char
9D00686C  2405000D   ADDIU A1, ZERO, 13
228:                           }
229:                           free(path);
9D006870  0F405E55   JAL free
9D006874  02002021   ADDU A0, S0, ZERO
230:                        }
231:                    }
232:                 }//cd()
9D006878  8FBF0014   LW RA, 20(SP)
9D00687C  8FB00010   LW S0, 16(SP)
9D006880  03E00008   JR RA
9D006884  27BD0018   ADDIU SP, SP, 24
233:                 
234:                 void del(int i){ // efface un fichier
9D006888  27BDFFE0   ADDIU SP, SP, -32
9D00688C  AFBF001C   SW RA, 28(SP)
9D006890  AFB10018   SW S1, 24(SP)
9D006894  AFB00014   SW S0, 20(SP)
235:                     FILINFO *fi;
236:                     if (!SDCardReady){
9D006898  8F828100   LW V0, -32512(GP)
9D00689C  1440000C   BNE V0, ZERO, 0x9D0068D0
9D0068A0  00808021   ADDU S0, A0, ZERO
237:                         if (!mount(0)){
9D0068A4  0F403A06   JAL mount
9D0068A8  00002021   ADDU A0, ZERO, ZERO
9D0068AC  14400007   BNE V0, ZERO, 0x9D0068CC
9D0068B0  24020001   ADDIU V0, ZERO, 1
238:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D0068B4  2404000A   ADDIU A0, ZERO, 10
9D0068B8  00002821   ADDU A1, ZERO, ZERO
9D0068BC  0F40196D   JAL print_error_msg
9D0068C0  00003021   ADDU A2, ZERO, ZERO
239:                             return;
9D0068C4  0B401A6D   J 0x9D0069B4
9D0068C8  8FBF001C   LW RA, 28(SP)
240:                         }else{
241:                             SDCardReady=TRUE;
9D0068CC  AF828100   SW V0, -32512(GP)
242:                         }
243:                     }
244:                     FRESULT error=FR_OK;
245:                     if (i==2){
9D0068D0  24020002   ADDIU V0, ZERO, 2
9D0068D4  1602002D   BNE S0, V0, 0x9D00698C
9D0068D8  24040003   ADDIU A0, ZERO, 3
246:                         fi=malloc(sizeof(FILINFO));
9D0068DC  0F4047DE   JAL malloc
9D0068E0  24040018   ADDIU A0, ZERO, 24
247:                         if (fi){
9D0068E4  10400022   BEQ V0, ZERO, 0x9D006970
9D0068E8  00408021   ADDU S0, V0, ZERO
248:                             error=f_stat(cmd_tokens[1],fi);
9D0068EC  3C02A000   LUI V0, -24576
9D0068F0  8C442A08   LW A0, 10760(V0)
9D0068F4  0F400B11   JAL f_stat
9D0068F8  02002821   ADDU A1, S0, ZERO
249:                             if (!error){
9D0068FC  14400029   BNE V0, ZERO, 0x9D0069A4
9D006900  00408821   ADDU S1, V0, ZERO
250:                                 if (fi->fattrib & (ATT_DIR|ATT_RO)){
9D006904  92020008   LBU V0, 8(S0)
9D006908  30420011   ANDI V0, V0, 17
9D00690C  1040000A   BEQ V0, ZERO, 0x9D006938
9D006910  3C02A000   LUI V0, -24576
251:                                     print_error_msg(ERR_DENIED,"can't delete directory or read only file.\r",0);
9D006914  24040008   ADDIU A0, ZERO, 8
9D006918  3C059D01   LUI A1, -25343
9D00691C  24A5F43C   ADDIU A1, A1, -3012
9D006920  0F40196D   JAL print_error_msg
9D006924  00003021   ADDU A2, ZERO, ZERO
252:                                 }
253:                                 else{
254:                                     error=f_unlink(cmd_tokens[1]);
9D006938  0F400BF0   JAL f_unlink
9D00693C  8C442A08   LW A0, 10760(V0)
9D006940  00408821   ADDU S1, V0, ZERO
255:                                 }
256:                             }
257:                             free(fi);
9D006928  0F405E55   JAL free
9D00692C  02002021   ADDU A0, S0, ZERO
9D006944  0F405E55   JAL free
9D006948  02002021   ADDU A0, S0, ZERO
9D0069A4  0F405E55   JAL free
9D0069A8  02002021   ADDU A0, S0, ZERO
258:                             if (error){
9D00694C  52200019   BEQL S1, ZERO, 0x9D0069B4
9D006950  8FBF001C   LW RA, 28(SP)
259:                                 print_error_msg(ERR_FIO,"",error);
9D006954  24040009   ADDIU A0, ZERO, 9
9D006958  3C059D01   LUI A1, -25343
9D00695C  24A5F468   ADDIU A1, A1, -2968
9D006960  0F40196D   JAL print_error_msg
9D006964  02203021   ADDU A2, S1, ZERO
9D0069AC  0B401A56   J 0x9D006958
9D0069B0  24040009   ADDIU A0, ZERO, 9
260:                             }
261:                         }else{
262:                                print_error_msg(ERR_ALLOC,"delete failed.\r",0);
9D006970  24040002   ADDIU A0, ZERO, 2
9D006974  3C059D01   LUI A1, -25343
9D006978  24A5F46C   ADDIU A1, A1, -2964
9D00697C  0F40196D   JAL print_error_msg
9D006980  00003021   ADDU A2, ZERO, ZERO
263:                         }
264:                    }else{
265:                        print_error_msg(ERR_USAGE, "delete file USAGE: del file_name\r",0);
9D00698C  3C059D01   LUI A1, -25343
9D006990  24A5F47C   ADDIU A1, A1, -2948
9D006994  0F40196D   JAL print_error_msg
9D006998  00003021   ADDU A2, ZERO, ZERO
266:                    }
267:                 }//del()
9D006930  0B401A6D   J 0x9D0069B4
9D006934  8FBF001C   LW RA, 28(SP)
9D006968  0B401A6D   J 0x9D0069B4
9D00696C  8FBF001C   LW RA, 28(SP)
9D006984  0B401A6D   J 0x9D0069B4
9D006988  8FBF001C   LW RA, 28(SP)
9D00699C  0B401A6D   J 0x9D0069B4
9D0069A0  8FBF001C   LW RA, 28(SP)
9D0069B4  8FB10018   LW S1, 24(SP)
9D0069B8  8FB00014   LW S0, 20(SP)
9D0069BC  03E00008   JR RA
9D0069C0  27BD0020   ADDIU SP, SP, 32
268:                 
269:                 void ren(int i){ // renomme un fichier
9D0069C4  27BDFFE8   ADDIU SP, SP, -24
9D0069C8  AFBF0014   SW RA, 20(SP)
9D0069CC  AFB00010   SW S0, 16(SP)
270:                     if (!SDCardReady){
9D0069D0  8F828100   LW V0, -32512(GP)
9D0069D4  1440000C   BNE V0, ZERO, 0x9D006A08
9D0069D8  00808021   ADDU S0, A0, ZERO
271:                         if (!mount(0)){
9D0069DC  0F403A06   JAL mount
9D0069E0  00002021   ADDU A0, ZERO, ZERO
9D0069E4  14400007   BNE V0, ZERO, 0x9D006A04
9D0069E8  24020001   ADDIU V0, ZERO, 1
272:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D0069EC  2404000A   ADDIU A0, ZERO, 10
9D0069F0  00002821   ADDU A1, ZERO, ZERO
9D0069F4  0F40196D   JAL print_error_msg
9D0069F8  00003021   ADDU A2, ZERO, ZERO
273:                             return;
9D0069FC  0B401A91   J 0x9D006A44
9D006A00  8FBF0014   LW RA, 20(SP)
274:                         }else{
275:                             SDCardReady=TRUE;
9D006A04  AF828100   SW V0, -32512(GP)
276:                         }
277:                     }
278:                     if (i==3){
9D006A08  24020003   ADDIU V0, ZERO, 3
9D006A0C  16020008   BNE S0, V0, 0x9D006A30
9D006A10  24040003   ADDIU A0, ZERO, 3
279:                         f_rename(cmd_tokens[1],cmd_tokens[2]);
9D006A14  3C02A000   LUI V0, -24576
9D006A18  24422A04   ADDIU V0, V0, 10756
9D006A1C  8C440004   LW A0, 4(V0)
9D006A20  0F400D65   JAL f_rename
9D006A24  8C450008   LW A1, 8(V0)
280:                     }else{
281:                         print_error_msg(ERR_USAGE,"rename file, USAGE: ren name new_name\r",0);
9D006A30  3C059D01   LUI A1, -25343
9D006A34  24A5F4A0   ADDIU A1, A1, -2912
9D006A38  0F40196D   JAL print_error_msg
9D006A3C  00003021   ADDU A2, ZERO, ZERO
282:                     }
283:                 }//ren
9D006A28  0B401A91   J 0x9D006A44
9D006A2C  8FBF0014   LW RA, 20(SP)
9D006A40  8FBF0014   LW RA, 20(SP)
9D006A44  8FB00010   LW S0, 16(SP)
9D006A48  03E00008   JR RA
9D006A4C  27BD0018   ADDIU SP, SP, 24
284:                 
285:                 void copy(int i){ // copie un fichier
9D006A50  27BDFFC8   ADDIU SP, SP, -56
9D006A54  AFBF0034   SW RA, 52(SP)
9D006A58  AFB60030   SW S6, 48(SP)
9D006A5C  AFB5002C   SW S5, 44(SP)
9D006A60  AFB40028   SW S4, 40(SP)
9D006A64  AFB30024   SW S3, 36(SP)
9D006A68  AFB20020   SW S2, 32(SP)
9D006A6C  AFB1001C   SW S1, 28(SP)
9D006A70  AFB00018   SW S0, 24(SP)
286:                     FIL *fsrc, *fnew;
287:                     char *buff;
288:                     int n;
289:                     if (!SDCardReady){
9D006A74  8F828100   LW V0, -32512(GP)
9D006A78  1440000C   BNE V0, ZERO, 0x9D006AAC
9D006A7C  00808021   ADDU S0, A0, ZERO
290:                         if (!mount(0)){
9D006A80  0F403A06   JAL mount
9D006A84  00002021   ADDU A0, ZERO, ZERO
9D006A88  14400007   BNE V0, ZERO, 0x9D006AA8
9D006A8C  24020001   ADDIU V0, ZERO, 1
291:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D006A90  2404000A   ADDIU A0, ZERO, 10
9D006A94  00002821   ADDU A1, ZERO, ZERO
9D006A98  0F40196D   JAL print_error_msg
9D006A9C  00003021   ADDU A2, ZERO, ZERO
292:                             return;
9D006AA0  0B401B06   J 0x9D006C18
9D006AA4  8FBF0034   LW RA, 52(SP)
293:                         }else{
294:                             SDCardReady=TRUE;
9D006AA8  AF828100   SW V0, -32512(GP)
295:                         }
296:                     }
297:                     FRESULT error;
298:                     if (i==3){
9D006AAC  24020003   ADDIU V0, ZERO, 3
9D006AB0  16020043   BNE S0, V0, 0x9D006BC0
9D006AB4  24040003   ADDIU A0, ZERO, 3
299:                         fsrc=malloc(sizeof(FIL));
9D006AB8  0F4047DE   JAL malloc
9D006ABC  24040028   ADDIU A0, ZERO, 40
9D006AC0  00408821   ADDU S1, V0, ZERO
9D006AC4  00409821   ADDU S3, V0, ZERO
300:                         fnew=malloc(sizeof(FIL));
9D006AC8  0F4047DE   JAL malloc
9D006ACC  24040028   ADDIU A0, ZERO, 40
9D006AD0  0040A821   ADDU S5, V0, ZERO
301:                         buff=malloc(512);
9D006AD4  0F4047DE   JAL malloc
9D006AD8  24040200   ADDIU A0, ZERO, 512
302:                         error=FR_OK;
303:                         if (fsrc && fnew && buff){
9D006ADC  12200032   BEQ S1, ZERO, 0x9D006BA8
9D006AE0  0040B021   ADDU S6, V0, ZERO
9D006AE4  12A00030   BEQ S5, ZERO, 0x9D006BA8
9D006AE8  02A0A021   ADDU S4, S5, ZERO
9D006AEC  1040002E   BEQ V0, ZERO, 0x9D006BA8
9D006AF0  00409021   ADDU S2, V0, ZERO
304:                             if ((error=f_open(fsrc,cmd_tokens[1],FA_READ)==FR_OK) &&
9D006AF4  02202021   ADDU A0, S1, ZERO
9D006AF8  3C02A000   LUI V0, -24576
9D006AFC  8C452A08   LW A1, 10760(V0)
9D006B00  0F400669   JAL f_open
9D006B04  24060001   ADDIU A2, ZERO, 1
9D006B08  14400043   BNE V0, ZERO, 0x9D006C18
9D006B0C  8FBF0034   LW RA, 52(SP)
9D006B24  1040000C   BEQ V0, ZERO, 0x9D006B58
9D006B28  02602021   ADDU A0, S3, ZERO
305:                                 (error=f_open(fnew,cmd_tokens[2],FA_CREATE_NEW|FA_WRITE)==FR_OK)){
9D006B10  02A02021   ADDU A0, S5, ZERO
9D006B14  3C02A000   LUI V0, -24576
9D006B18  8C452A0C   LW A1, 10764(V0)
9D006B1C  0F400669   JAL f_open
9D006B20  24060006   ADDIU A2, ZERO, 6
306:                                 while ((error=f_read(fsrc,buff,512,&n))==FR_OK){
9D006B54  02602021   ADDU A0, S3, ZERO
9D006B58  02402821   ADDU A1, S2, ZERO
9D006B5C  24060200   ADDIU A2, ZERO, 512
9D006B60  0F400708   JAL f_read
9D006B64  27A70010   ADDIU A3, SP, 16
9D006B68  1040FFF2   BEQ V0, ZERO, 0x9D006B34
9D006B6C  00408021   ADDU S0, V0, ZERO
9D006B70  0B401AF6   J 0x9D006BD8
9D006B74  00000000   NOP
307:                                     if (n){
9D006B34  8FA60010   LW A2, 16(SP)
9D006B38  10C0000F   BEQ A2, ZERO, 0x9D006B78
9D006B3C  02802021   ADDU A0, S4, ZERO
308:                                         if (!((error=f_write(fnew,buff,n,&n))==FR_OK)){
9D006B40  02402821   ADDU A1, S2, ZERO
9D006B44  0F4007B3   JAL f_write
9D006B48  27A70010   ADDIU A3, SP, 16
9D006B4C  14400022   BNE V0, ZERO, 0x9D006BD8
9D006B50  00408021   ADDU S0, V0, ZERO
309:                                             break;
310:                                         }
311:                                     }else{
312:                                          break;
313:                                     }
314:                                 }//while
315:                                 f_close(fsrc);
9D006B78  0F4008CD   JAL f_close
9D006B7C  02202021   ADDU A0, S1, ZERO
9D006BD8  0F4008CD   JAL f_close
9D006BDC  02202021   ADDU A0, S1, ZERO
316:                                 f_close(fnew);
9D006B80  0F4008CD   JAL f_close
9D006B84  02A02021   ADDU A0, S5, ZERO
9D006BE0  0F4008CD   JAL f_close
9D006BE4  02A02021   ADDU A0, S5, ZERO
317:                                 free(buff);
9D006B88  0F405E55   JAL free
9D006B8C  02C02021   ADDU A0, S6, ZERO
9D006BE8  0F405E55   JAL free
9D006BEC  02C02021   ADDU A0, S6, ZERO
318:                                 free(fsrc);
9D006B90  0F405E55   JAL free
9D006B94  02202021   ADDU A0, S1, ZERO
9D006BF0  0F405E55   JAL free
9D006BF4  02202021   ADDU A0, S1, ZERO
319:                                 free(fnew);
9D006B98  0F405E55   JAL free
9D006B9C  02A02021   ADDU A0, S5, ZERO
9D006BF8  0F405E55   JAL free
9D006BFC  02A02021   ADDU A0, S5, ZERO
320:                             }
321:                             if (error){
322:                                 print_error_msg(ERR_FIO,"copy failed.\r",error);
9D006C00  24040009   ADDIU A0, ZERO, 9
9D006C04  3C059D01   LUI A1, -25343
9D006C08  24A5F4F8   ADDIU A1, A1, -2824
9D006C0C  0F40196D   JAL print_error_msg
9D006C10  02003021   ADDU A2, S0, ZERO
323:                             }
324:                         }else{
325:                             print(comm_channel,ERR_MSG[ERR_ALLOC]);
9D006BA8  8384804C   LB A0, -32692(GP)
9D006BAC  3C02A000   LUI V0, -24576
9D006BB0  0F40229C   JAL print
9D006BB4  8C4528D8   LW A1, 10456(V0)
326:                         }
327:                     }else{
328:                         print_error_msg(ERR_USAGE,"copy file USAGE: copy file_name new_file_name\r",0);
9D006BC0  3C059D01   LUI A1, -25343
9D006BC4  24A5F4C8   ADDIU A1, A1, -2872
9D006BC8  0F40196D   JAL print_error_msg
9D006BCC  00003021   ADDU A2, ZERO, ZERO
329:                     }
330:                 }//copy()
9D006B2C  0B401B06   J 0x9D006C18
9D006B30  8FBF0034   LW RA, 52(SP)
9D006BA0  0B401B06   J 0x9D006C18
9D006BA4  8FBF0034   LW RA, 52(SP)
9D006BB8  0B401B06   J 0x9D006C18
9D006BBC  8FBF0034   LW RA, 52(SP)
9D006BD0  0B401B06   J 0x9D006C18
9D006BD4  8FBF0034   LW RA, 52(SP)
9D006C14  8FBF0034   LW RA, 52(SP)
9D006C18  8FB60030   LW S6, 48(SP)
9D006C1C  8FB5002C   LW S5, 44(SP)
9D006C20  8FB40028   LW S4, 40(SP)
9D006C24  8FB30024   LW S3, 36(SP)
9D006C28  8FB20020   LW S2, 32(SP)
9D006C2C  8FB1001C   LW S1, 28(SP)
9D006C30  8FB00018   LW S0, 24(SP)
9D006C34  03E00008   JR RA
9D006C38  27BD0038   ADDIU SP, SP, 56
331:                 
332:                 void send(int i){ // envoie un fichier via uart
9D006C3C  27BDFFE8   ADDIU SP, SP, -24
333:                     // to do
334:                    if (i==2){
9D006C40  24020002   ADDIU V0, ZERO, 2
9D006C44  14820007   BNE A0, V0, 0x9D006C64
9D006C48  AFBF0014   SW RA, 20(SP)
335:                        print_error_msg(ERR_NOT_DONE,NULL,0);
9D006C4C  24040001   ADDIU A0, ZERO, 1
9D006C50  00002821   ADDU A1, ZERO, ZERO
9D006C54  0F40196D   JAL print_error_msg
9D006C58  00003021   ADDU A2, ZERO, ZERO
336:                    }else{
337:                        print(comm_channel, "send file via serial, USAGE: send file_name\r");
9D006C64  8384804C   LB A0, -32692(GP)
9D006C68  3C059D01   LUI A1, -25343
9D006C6C  0F40229C   JAL print
9D006C70  24A5F508   ADDIU A1, A1, -2808
338:                    }
339:                 }//send()
9D006C5C  0B401B1E   J 0x9D006C78
9D006C60  8FBF0014   LW RA, 20(SP)
9D006C74  8FBF0014   LW RA, 20(SP)
9D006C78  03E00008   JR RA
9D006C7C  27BD0018   ADDIU SP, SP, 24
340:                 
341:                 void receive(int i){ // reçois un fichier via uart
9D006C80  27BDFFE8   ADDIU SP, SP, -24
342:                     // to do
343:                    if (i==2){
9D006C84  24020002   ADDIU V0, ZERO, 2
9D006C88  14820007   BNE A0, V0, 0x9D006CA8
9D006C8C  AFBF0014   SW RA, 20(SP)
344:                        print_error_msg(ERR_NOT_DONE,NULL,0);
9D006C90  24040001   ADDIU A0, ZERO, 1
9D006C94  00002821   ADDU A1, ZERO, ZERO
9D006C98  0F40196D   JAL print_error_msg
9D006C9C  00003021   ADDU A2, ZERO, ZERO
345:                    }else{
346:                        print(comm_channel, "receive file from serial, USAGE: receive file_name\r");
9D006CA8  8384804C   LB A0, -32692(GP)
9D006CAC  3C059D01   LUI A1, -25343
9D006CB0  0F40229C   JAL print
9D006CB4  24A5F538   ADDIU A1, A1, -2760
347:                    }
348:                 }//receive()
9D006CA0  0B401B2F   J 0x9D006CBC
9D006CA4  8FBF0014   LW RA, 20(SP)
9D006CB8  8FBF0014   LW RA, 20(SP)
9D006CBC  03E00008   JR RA
9D006CC0  27BD0018   ADDIU SP, SP, 24
349:                 
350:                 
351:                 void more(int i){ // affiche à l'écran le contenu d'un fichier texte
9D006CC4  27BDFFB0   ADDIU SP, SP, -80
9D006CC8  AFBF004C   SW RA, 76(SP)
9D006CCC  AFBE0048   SW S8, 72(SP)
9D006CD0  AFB70044   SW S7, 68(SP)
9D006CD4  AFB60040   SW S6, 64(SP)
9D006CD8  AFB5003C   SW S5, 60(SP)
9D006CDC  AFB40038   SW S4, 56(SP)
9D006CE0  AFB30034   SW S3, 52(SP)
9D006CE4  AFB20030   SW S2, 48(SP)
9D006CE8  AFB1002C   SW S1, 44(SP)
9D006CEC  AFB00028   SW S0, 40(SP)
352:                     FIL *fh;
353:                     char *fmt, *buff, *rbuff, c, prev,key;
354:                     int n,lcnt,colcnt=0;
9D006DB4  00009021   ADDU S2, ZERO, ZERO
355:                     text_coord_t cpos;
356:                     if (!SDCardReady){
9D006CF0  8F828100   LW V0, -32512(GP)
9D006CF4  1440000C   BNE V0, ZERO, 0x9D006D28
9D006CF8  00808021   ADDU S0, A0, ZERO
357:                         if (!mount(0)){
9D006CFC  0F403A06   JAL mount
9D006D00  00002021   ADDU A0, ZERO, ZERO
9D006D04  14400007   BNE V0, ZERO, 0x9D006D24
9D006D08  24020001   ADDIU V0, ZERO, 1
358:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D006D0C  2404000A   ADDIU A0, ZERO, 10
9D006D10  00002821   ADDU A1, ZERO, ZERO
9D006D14  0F40196D   JAL print_error_msg
9D006D18  00003021   ADDU A2, ZERO, ZERO
359:                             return;
9D006D1C  0B401BE9   J 0x9D006FA4
9D006D20  8FBF004C   LW RA, 76(SP)
360:                         }else{
361:                             SDCardReady=TRUE;
9D006D24  AF828100   SW V0, -32512(GP)
362:                         }
363:                     }
364:                     FRESULT error=FR_OK;
9D006F70  00001021   ADDU V0, ZERO, ZERO
365:                     if (i==2){
9D006D28  24020002   ADDIU V0, ZERO, 2
9D006D2C  16020098   BNE S0, V0, 0x9D006F90
9D006D30  24040003   ADDIU A0, ZERO, 3
366:                         fh=malloc(sizeof(FIL));
9D006D34  0F4047DE   JAL malloc
9D006D38  24040028   ADDIU A0, ZERO, 40
9D006D3C  AFA2001C   SW V0, 28(SP)
367:                         if (fh && ((error=f_open(fh,cmd_tokens[1],FA_READ))==FR_OK)){
9D006D40  1040008B   BEQ V0, ZERO, 0x9D006F70
9D006D44  AFA20018   SW V0, 24(SP)
9D006D48  00402021   ADDU A0, V0, ZERO
9D006D4C  3C02A000   LUI V0, -24576
9D006D50  8C452A08   LW A1, 10760(V0)
9D006D54  0F400669   JAL f_open
9D006D58  24060001   ADDIU A2, ZERO, 1
9D006D5C  14400086   BNE V0, ZERO, 0x9D006F78
9D006D60  24040009   ADDIU A0, ZERO, 9
368:                             buff=malloc(512);
9D006D64  0F4047DE   JAL malloc
9D006D68  24040200   ADDIU A0, ZERO, 512
9D006D6C  AFA20024   SW V0, 36(SP)
9D006D80  8FB70024   LW S7, 36(SP)
369:                             fmt=malloc(64);
9D006D70  0F4047DE   JAL malloc
9D006D74  24040040   ADDIU A0, ZERO, 64
370:                             if (fmt && buff){
9D006D78  10400076   BEQ V0, ZERO, 0x9D006F54
9D006D7C  AFA20020   SW V0, 32(SP)
9D006D84  12E00073   BEQ S7, ZERO, 0x9D006F54
9D006D88  00402021   ADDU A0, V0, ZERO
371:                                 sprintf(fmt,"File: %s, size %d bytes\r",cmd_tokens[1],fh->fsize);
9D006D8C  3C059D01   LUI A1, -25343
9D006D90  24A5F56C   ADDIU A1, A1, -2708
9D006D94  3C02A000   LUI V0, -24576
9D006D98  8C462A08   LW A2, 10760(V0)
9D006D9C  8FA2001C   LW V0, 28(SP)
9D006DA0  0F405BCA   JAL sprintf
9D006DA4  8C47000C   LW A3, 12(V0)
372:                                 print(comm_channel,fmt);
9D006DA8  8384804C   LB A0, -32692(GP)
9D006DAC  0F40229C   JAL print
9D006DB0  8FA50020   LW A1, 32(SP)
373:                                 key=0;
9D006DB8  0000B021   ADDU S6, ZERO, ZERO
374:                                 while (key!=ESC && f_read(fh,buff,512,&n)==FR_OK){
9D006F04  2402001B   ADDIU V0, ZERO, 27
9D006F08  12C20008   BEQ S6, V0, 0x9D006F2C
9D006F0C  00000000   NOP
9D006F10  8FA40018   LW A0, 24(SP)
9D006F14  02E02821   ADDU A1, S7, ZERO
9D006F18  24060200   ADDIU A2, ZERO, 512
9D006F1C  0F400708   JAL f_read
9D006F20  27A70010   ADDIU A3, SP, 16
9D006F24  1040FFA9   BEQ V0, ZERO, 0x9D006DCC
9D006F28  8FA20010   LW V0, 16(SP)
375:                                     if (!n) break;
9D006DCC  10400057   BEQ V0, ZERO, 0x9D006F2C
9D006DD0  02E08821   ADDU S1, S7, ZERO
376:                                     rbuff=buff;
377:                                     for(;n;n--){
9D006E8C  0B401BBE   J 0x9D006EF8
9D006E90  8FA20010   LW V0, 16(SP)
9D006E9C  0B401BBE   J 0x9D006EF8
9D006EA0  8FA20010   LW V0, 16(SP)
9D006EF4  8FA20010   LW V0, 16(SP)
9D006EF8  2442FFFF   ADDIU V0, V0, -1
9D006EFC  1440FFB6   BNE V0, ZERO, 0x9D006DD8
9D006F00  AFA20010   SW V0, 16(SP)
378:                                         c=*rbuff++;
9D006DD8  82300000   LB S0, 0(S1)
379:                                         if ((c!=TAB && c!=CR) && (c<32 || c>126)) {c=32;}
9D006DBC  24150009   ADDIU S5, ZERO, 9
9D006DD4  2414000D   ADDIU S4, ZERO, 13
9D006DDC  12150007   BEQ S0, S5, 0x9D006DFC
9D006DE0  26310001   ADDIU S1, S1, 1
9D006DE4  12140005   BEQ S0, S4, 0x9D006DFC
9D006DE8  2603FFE0   ADDIU V1, S0, -32
9D006DEC  306300FF   ANDI V1, V1, 255
9D006DF0  2C63005F   SLTIU V1, V1, 95
9D006DF4  24020020   ADDIU V0, ZERO, 32
9D006DF8  0043800A   MOVZ S0, V0, V1
380:                                         put_char(comm_channel,c);
9D006DFC  8384804C   LB A0, -32692(GP)
9D006E00  0F402205   JAL put_char
9D006E04  02002821   ADDU A1, S0, ZERO
381:                                         if (comm_channel==LOCAL_CON){
9D006E08  9384804C   LBU A0, -32692(GP)
9D006E0C  54800025   BNEL A0, ZERO, 0x9D006EA4
9D006E10  26520001   ADDIU S2, S2, 1
382:                                             cpos=get_curpos();
9D006E14  0F402333   JAL get_curpos
9D006E18  27A40014   ADDIU A0, SP, 20
383:                                             if (cpos.x==0){
9D006E1C  97A20014   LHU V0, 20(SP)
9D006E20  14400034   BNE V0, ZERO, 0x9D006EF4
9D006E24  97A30016   LHU V1, 22(SP)
384:                                                 if (cpos.y>=(LINE_PER_SCREEN-1)){
9D006E28  2C630019   SLTIU V1, V1, 25
9D006E2C  14600032   BNE V1, ZERO, 0x9D006EF8
9D006E30  8FA20010   LW V0, 16(SP)
385:                                                     cpos.y=LINE_PER_SCREEN-1;
386:                                                     invert_video(TRUE);
9D006E34  0F40242F   JAL invert_video
9D006E38  24040001   ADDIU A0, ZERO, 1
387:                                                     print(comm_channel,"-- next --");
9D006DC0  3C1E9D01   LUI S8, -25343
9D006DC4  0B401BC4   J 0x9D006F10
9D006DC8  27DEF588   ADDIU S8, S8, -2680
9D006E3C  8384804C   LB A0, -32692(GP)
9D006E40  0F40229C   JAL print
9D006E44  03C02821   ADDU A1, S8, ZERO
388:                                                     invert_video(FALSE);
9D006E48  0F40242F   JAL invert_video
9D006E4C  00002021   ADDU A0, ZERO, ZERO
389:                                                     key=wait_key(comm_channel);
9D006E50  0F4023C6   JAL wait_key
9D006E54  8384804C   LB A0, -32692(GP)
9D006E58  7C02B420   SEB S6, V0
390:                                                     if (key=='q' || key==ESC){key=ESC; break;}
9D006E5C  24020071   ADDIU V0, ZERO, 113
9D006E60  12C20032   BEQ S6, V0, 0x9D006F2C
9D006E64  2402001B   ADDIU V0, ZERO, 27
9D006E68  12C20030   BEQ S6, V0, 0x9D006F2C
9D006E6C  00000000   NOP
391:                                                     if (key==CR){
9D006E70  16D40008   BNE S6, S4, 0x9D006E94
9D006E74  00000000   NOP
392:                                                         set_curpos(cpos.x,cpos.y);
9D006E78  00002021   ADDU A0, ZERO, ZERO
9D006E7C  0F40233E   JAL set_curpos
9D006E80  24050019   ADDIU A1, ZERO, 25
393:                                                         clear_eol();
9D006E84  0F40231A   JAL clear_eol
9D006E88  00000000   NOP
394:                                                     }else{
395:                                                         clear_screen();
9D006E94  0F402290   JAL clear_screen
9D006E98  00000000   NOP
396:                                                     }
397:                                                 }
398:                                             }
399:                                         }else{
400:                                             colcnt++;
401:                                             if ((colcnt>79)||(c=='\r')){
9D006EA4  2A420050   SLTI V0, S2, 80
9D006EA8  50400004   BEQL V0, ZERO, 0x9D006EBC
9D006EAC  26730001   ADDIU S3, S3, 1
9D006EB0  16140011   BNE S0, S4, 0x9D006EF8
9D006EB4  8FA20010   LW V0, 16(SP)
402:                                                 colcnt=0;
403:                                                 lcnt++;
9D006EB8  26730001   ADDIU S3, S3, 1
404:                                                 if (lcnt==22){
9D006EBC  24020016   ADDIU V0, ZERO, 22
9D006EC0  1662000C   BNE S3, V0, 0x9D006EF4
9D006EC4  00009021   ADDU S2, ZERO, ZERO
405:                                                     lcnt=0;
406:                                                    // print(comm_channel,"\r-- next --\r");
407:                                                     put_char(comm_channel,'\r');
9D006EC8  7C042420   SEB A0, A0
9D006ECC  0F402205   JAL put_char
9D006ED0  02802821   ADDU A1, S4, ZERO
408:                                                     key=wait_key(comm_channel);
9D006ED4  0F4023C6   JAL wait_key
9D006ED8  8384804C   LB A0, -32692(GP)
9D006EDC  7C02B420   SEB S6, V0
409:                                                     if (key=='q' || key==ESC){key=ESC;break;}
9D006EE0  24020071   ADDIU V0, ZERO, 113
9D006EE4  12C20011   BEQ S6, V0, 0x9D006F2C
9D006EE8  2402001B   ADDIU V0, ZERO, 27
9D006EEC  12C2000F   BEQ S6, V0, 0x9D006F2C
9D006EF0  00009821   ADDU S3, ZERO, ZERO
410:                                                 }
411:                                             }
412:                                         }
413:                                     }
414:                                 }
415:                                 f_close(fh);
9D006F2C  0F4008CD   JAL f_close
9D006F30  8FA4001C   LW A0, 28(SP)
416:                                 free(fh);
9D006F34  0F405E55   JAL free
9D006F38  8FA4001C   LW A0, 28(SP)
417:                                 free(buff);
9D006F3C  0F405E55   JAL free
9D006F40  8FA40024   LW A0, 36(SP)
418:                                 free(fmt);
9D006F44  0F405E55   JAL free
9D006F48  8FA40020   LW A0, 32(SP)
9D006F4C  0B401BE9   J 0x9D006FA4
9D006F50  8FBF004C   LW RA, 76(SP)
419:                             }else{
420:                                 print_error_msg(ERR_ALLOC,"Can't display file.\r",0);
9D006F54  24040002   ADDIU A0, ZERO, 2
9D006F58  3C059D01   LUI A1, -25343
9D006F5C  24A5F594   ADDIU A1, A1, -2668
9D006F60  0F40196D   JAL print_error_msg
9D006F64  00003021   ADDU A2, ZERO, ZERO
421:                             }
422:                         }else{
423:                             print_error_msg(ERR_FIO,"File open failed.\r",error);
9D006F74  24040009   ADDIU A0, ZERO, 9
9D006F78  3C059D01   LUI A1, -25343
9D006F7C  24A5F5AC   ADDIU A1, A1, -2644
9D006F80  0F40196D   JAL print_error_msg
9D006F84  00403021   ADDU A2, V0, ZERO
424:                         }
425:                    }else{
426:                        print_error_msg(ERR_USAGE, "USAGE: more file_name\r",0);
9D006F90  3C059D01   LUI A1, -25343
9D006F94  24A5F5C0   ADDIU A1, A1, -2624
9D006F98  0F40196D   JAL print_error_msg
9D006F9C  00003021   ADDU A2, ZERO, ZERO
427:                    }
428:                 }//more
9D006F68  0B401BE9   J 0x9D006FA4
9D006F6C  8FBF004C   LW RA, 76(SP)
9D006F88  0B401BE9   J 0x9D006FA4
9D006F8C  8FBF004C   LW RA, 76(SP)
9D006FA0  8FBF004C   LW RA, 76(SP)
9D006FA4  8FBE0048   LW S8, 72(SP)
9D006FA8  8FB70044   LW S7, 68(SP)
9D006FAC  8FB60040   LW S6, 64(SP)
9D006FB0  8FB5003C   LW S5, 60(SP)
9D006FB4  8FB40038   LW S4, 56(SP)
9D006FB8  8FB30034   LW S3, 52(SP)
9D006FBC  8FB20030   LW S2, 48(SP)
9D006FC0  8FB1002C   LW S1, 44(SP)
9D006FC4  8FB00028   LW S0, 40(SP)
9D006FC8  03E00008   JR RA
9D006FCC  27BD0050   ADDIU SP, SP, 80
429:                 
430:                 void editor(int i){ // lance l'éditeur de texte
9D006FD0  27BDFFE8   ADDIU SP, SP, -24
431:                     if (i>1){
9D006FD4  28840002   SLTI A0, A0, 2
9D006FD8  14800006   BNE A0, ZERO, 0x9D006FF4
9D006FDC  AFBF0014   SW RA, 20(SP)
432:                         ed(cmd_tokens[1]);
9D006FE0  3C02A000   LUI V0, -24576
9D006FE4  0F4038A7   JAL ed
9D006FE8  8C442A08   LW A0, 10760(V0)
433:                     }else{
434:                         ed(NULL);
9D006FF4  0F4038A7   JAL ed
9D006FF8  00002021   ADDU A0, ZERO, ZERO
435:                     }
436:                 }//editor()
9D006FEC  0B401C00   J 0x9D007000
9D006FF0  8FBF0014   LW RA, 20(SP)
9D006FFC  8FBF0014   LW RA, 20(SP)
9D007000  03E00008   JR RA
9D007004  27BD0018   ADDIU SP, SP, 24
437:                 
438:                 void mkdir(int i){
9D007008  27BDFFE8   ADDIU SP, SP, -24
9D00700C  AFBF0014   SW RA, 20(SP)
9D007010  AFB00010   SW S0, 16(SP)
439:                     FRESULT error=FR_OK;
440:                     char *fmt;
441:                     if (!SDCardReady){
9D007014  8F828100   LW V0, -32512(GP)
9D007018  1440000C   BNE V0, ZERO, 0x9D00704C
9D00701C  00808021   ADDU S0, A0, ZERO
442:                         if (!mount(0)){
9D007020  0F403A06   JAL mount
9D007024  00002021   ADDU A0, ZERO, ZERO
9D007028  14400007   BNE V0, ZERO, 0x9D007048
9D00702C  24020001   ADDIU V0, ZERO, 1
443:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D007030  2404000A   ADDIU A0, ZERO, 10
9D007034  00002821   ADDU A1, ZERO, ZERO
9D007038  0F40196D   JAL print_error_msg
9D00703C  00003021   ADDU A2, ZERO, ZERO
444:                             return;
9D007040  0B401C3A   J 0x9D0070E8
9D007044  8FBF0014   LW RA, 20(SP)
445:                         }else{
446:                             SDCardReady=TRUE;
9D007048  AF828100   SW V0, -32512(GP)
447:                         }
448:                     }
449:                     if (i==2){
9D00704C  24020002   ADDIU V0, ZERO, 2
9D007050  1602001B   BNE S0, V0, 0x9D0070C0
9D007054  24040003   ADDIU A0, ZERO, 3
450:                         fmt=malloc(CHAR_PER_LINE+1);
9D007058  0F4047DE   JAL malloc
9D00705C  24040036   ADDIU A0, ZERO, 54
451:                         if (fmt && (error=f_mkdir(cmd_tokens[1])==FR_OK)){
9D007060  10400011   BEQ V0, ZERO, 0x9D0070A8
9D007064  00408021   ADDU S0, V0, ZERO
9D007068  3C02A000   LUI V0, -24576
9D00706C  0F400C4D   JAL f_mkdir
9D007070  8C442A08   LW A0, 10760(V0)
9D007074  14400018   BNE V0, ZERO, 0x9D0070D8
9D007078  8384804C   LB A0, -32692(GP)
452:                             sprintf(fmt,"directory %s created\r",cmd_tokens[1]);
9D00707C  02002021   ADDU A0, S0, ZERO
9D007080  3C059D01   LUI A1, -25343
9D007084  24A5F5D8   ADDIU A1, A1, -2600
9D007088  3C02A000   LUI V0, -24576
9D00708C  0F405BCA   JAL sprintf
9D007090  8C462A08   LW A2, 10760(V0)
453:                             print(comm_channel,fmt);
9D007094  8384804C   LB A0, -32692(GP)
9D007098  0F40229C   JAL print
9D00709C  02002821   ADDU A1, S0, ZERO
9D0070A0  0B401C3A   J 0x9D0070E8
9D0070A4  8FBF0014   LW RA, 20(SP)
454:                         }else{
455:                             if (!fmt){
456:                                 print(comm_channel,ERR_MSG[ERR_ALLOC]);
9D0070A8  8384804C   LB A0, -32692(GP)
9D0070AC  3C02A000   LUI V0, -24576
9D0070B0  0F40229C   JAL print
9D0070B4  8C4528D8   LW A1, 10456(V0)
457:                             }else{
458:                                 print(comm_channel,ERR_MSG[ERR_MKDIR]);
9D0070D8  3C02A000   LUI V0, -24576
9D0070DC  0F40229C   JAL print
9D0070E0  8C4528E8   LW A1, 10472(V0)
459:                             }
460:                         }
461:                     }else{
462:                         print_error_msg(ERR_USAGE,"mkdir create a directory, USAGE: mkdir dir_name\r",0);
9D0070C0  3C059D01   LUI A1, -25343
9D0070C4  24A5F5F0   ADDIU A1, A1, -2576
9D0070C8  0F40196D   JAL print_error_msg
9D0070CC  00003021   ADDU A2, ZERO, ZERO
463:                     }
464:                 }// mkdir()
9D0070B8  0B401C3A   J 0x9D0070E8
9D0070BC  8FBF0014   LW RA, 20(SP)
9D0070D0  0B401C3A   J 0x9D0070E8
9D0070D4  8FBF0014   LW RA, 20(SP)
9D0070E4  8FBF0014   LW RA, 20(SP)
9D0070E8  8FB00010   LW S0, 16(SP)
9D0070EC  03E00008   JR RA
9D0070F0  27BD0018   ADDIU SP, SP, 24
465:                 
466:                 void list_directory(int i){
9D0070F4  27BDFFA8   ADDIU SP, SP, -88
9D0070F8  AFBF0054   SW RA, 84(SP)
9D0070FC  AFB10050   SW S1, 80(SP)
9D007100  AFB0004C   SW S0, 76(SP)
467:                     FRESULT error;
468:                     FIL *fh;
469:                     char fmt[55];
470:                     if (!SDCardReady){
9D007104  8F828100   LW V0, -32512(GP)
9D007108  1440000C   BNE V0, ZERO, 0x9D00713C
9D00710C  00808021   ADDU S0, A0, ZERO
471:                         if (!mount(0)){
9D007110  0F403A06   JAL mount
9D007114  00002021   ADDU A0, ZERO, ZERO
9D007118  14400007   BNE V0, ZERO, 0x9D007138
9D00711C  24020001   ADDIU V0, ZERO, 1
472:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D007120  2404000A   ADDIU A0, ZERO, 10
9D007124  00002821   ADDU A1, ZERO, ZERO
9D007128  0F40196D   JAL print_error_msg
9D00712C  00003021   ADDU A2, ZERO, ZERO
473:                             return;
9D007130  0B401C7F   J 0x9D0071FC
9D007134  8FBF0054   LW RA, 84(SP)
474:                         }else{
475:                             SDCardReady=TRUE;
9D007138  AF828100   SW V0, -32512(GP)
476:                         }
477:                     }
478:                     if (i>1){
9D00713C  2A100002   SLTI S0, S0, 2
9D007140  16000022   BNE S0, ZERO, 0x9D0071CC
9D007144  3C02A000   LUI V0, -24576
479:                         error=listDir(cmd_tokens[1]);
9D007148  0F403A40   JAL listDir
9D00714C  8C442A08   LW A0, 10760(V0)
9D007150  00408021   ADDU S0, V0, ZERO
480:                         if (error==FR_NO_PATH){// not a directory, try file
9D007154  24020005   ADDIU V0, ZERO, 5
9D007158  16020020   BNE S0, V0, 0x9D0071DC
9D00715C  00000000   NOP
481:                             fh=malloc(sizeof(FIL));
9D007160  0F4047DE   JAL malloc
9D007164  24040028   ADDIU A0, ZERO, 40
482:                             if (fh && ((error=f_open(fh,cmd_tokens[1],FA_READ))==FR_OK)){
9D007168  1040001E   BEQ V0, ZERO, 0x9D0071E4
9D00716C  00408821   ADDU S1, V0, ZERO
9D007170  00402021   ADDU A0, V0, ZERO
9D007174  3C02A000   LUI V0, -24576
9D007178  8C452A08   LW A1, 10760(V0)
9D00717C  0F400669   JAL f_open
9D007180  24060001   ADDIU A2, ZERO, 1
9D007184  14400017   BNE V0, ZERO, 0x9D0071E4
9D007188  00408021   ADDU S0, V0, ZERO
483:                                 sprintf(fmt,"File: %s, size %d bytes\r",cmd_tokens[1],fh->fsize);
9D00718C  27A40010   ADDIU A0, SP, 16
9D007190  3C059D01   LUI A1, -25343
9D007194  24A5F56C   ADDIU A1, A1, -2708
9D007198  3C02A000   LUI V0, -24576
9D00719C  8C462A08   LW A2, 10760(V0)
9D0071A0  0F405BCA   JAL sprintf
9D0071A4  8E27000C   LW A3, 12(S1)
484:                                 print(comm_channel,fmt);
9D0071A8  8384804C   LB A0, -32692(GP)
9D0071AC  0F40229C   JAL print
9D0071B0  27A50010   ADDIU A1, SP, 16
485:                                 f_close(fh);
9D0071B4  0F4008CD   JAL f_close
9D0071B8  02202021   ADDU A0, S1, ZERO
486:                                 free(fh);
9D0071BC  0F405E55   JAL free
9D0071C0  02202021   ADDU A0, S1, ZERO
487:                             }
488:                         }
489:                     }else{
490:                         error=listDir(".");
9D0071CC  3C049D01   LUI A0, -25343
9D0071D0  0F403A40   JAL listDir
9D0071D4  2484F624   ADDIU A0, A0, -2524
9D0071D8  00408021   ADDU S0, V0, ZERO
491:                     }
492:                     if (error) print_error_msg(ERR_FIO,"",error);
9D0071DC  12000007   BEQ S0, ZERO, 0x9D0071FC
9D0071E0  8FBF0054   LW RA, 84(SP)
9D0071E4  24040009   ADDIU A0, ZERO, 9
9D0071E8  3C059D01   LUI A1, -25343
9D0071EC  24A5F468   ADDIU A1, A1, -2968
9D0071F0  0F40196D   JAL print_error_msg
9D0071F4  02003021   ADDU A2, S0, ZERO
493:                 }//list_directory()
9D0071C4  0B401C7F   J 0x9D0071FC
9D0071C8  8FBF0054   LW RA, 84(SP)
9D0071F8  8FBF0054   LW RA, 84(SP)
9D0071FC  8FB10050   LW S1, 80(SP)
9D007200  8FB0004C   LW S0, 76(SP)
9D007204  03E00008   JR RA
9D007208  27BD0058   ADDIU SP, SP, 88
494:                 
495:                 void cmd_puts(){
9D00720C  27BDFFE8   ADDIU SP, SP, -24
9D007210  AFBF0014   SW RA, 20(SP)
496:                     print(comm_channel, "commande puts, to be done.\r");
9D007214  8384804C   LB A0, -32692(GP)
9D007218  3C059D01   LUI A1, -25343
9D00721C  0F40229C   JAL print
9D007220  24A5F628   ADDIU A1, A1, -2520
497:                 }//puts()
9D007224  8FBF0014   LW RA, 20(SP)
9D007228  03E00008   JR RA
9D00722C  27BD0018   ADDIU SP, SP, 24
498:                 
499:                 void expr(){
9D007230  27BDFFE8   ADDIU SP, SP, -24
9D007234  AFBF0014   SW RA, 20(SP)
500:                     print(comm_channel, "commande expr, to be done.\r");
9D007238  8384804C   LB A0, -32692(GP)
9D00723C  3C059D01   LUI A1, -25343
9D007240  0F40229C   JAL print
9D007244  24A5F644   ADDIU A1, A1, -2492
501:                 }//expr()
9D007248  8FBF0014   LW RA, 20(SP)
9D00724C  03E00008   JR RA
9D007250  27BD0018   ADDIU SP, SP, 24
502:                 
503:                 //display heap status
504:                 void cmd_free(){
9D007254  27BDFFB0   ADDIU SP, SP, -80
9D007258  AFBF004C   SW RA, 76(SP)
505:                     char fmt[55];
506:                     sprintf(fmt,"free RAM %d/%d BYTES\r",free_heap(),heap_size);
9D00725C  0F403E99   JAL free_heap
9D007260  00000000   NOP
9D007264  27A40010   ADDIU A0, SP, 16
9D007268  3C059D01   LUI A1, -25343
9D00726C  24A5F660   ADDIU A1, A1, -2464
9D007270  00403021   ADDU A2, V0, ZERO
9D007274  0F405BCA   JAL sprintf
9D007278  8F8780B8   LW A3, -32584(GP)
507:                     print(comm_channel,fmt);
9D00727C  8384804C   LB A0, -32692(GP)
9D007280  0F40229C   JAL print
9D007284  27A50010   ADDIU A1, SP, 16
508:                 }
9D007288  8FBF004C   LW RA, 76(SP)
9D00728C  03E00008   JR RA
9D007290  27BD0050   ADDIU SP, SP, 80
509:                 
510:                 void execute_cmd(int i){
9D007294  27BDFFE8   ADDIU SP, SP, -24
9D007298  AFBF0014   SW RA, 20(SP)
9D00729C  AFB00010   SW S0, 16(SP)
9D0072A0  00808021   ADDU S0, A0, ZERO
511:                         switch (cmd_search(cmd_tokens[0])){
9D0072A4  3C02A000   LUI V0, -24576
9D0072A8  0F401997   JAL cmd_search
9D0072AC  8C442A04   LW A0, 10756(V0)
9D0072B0  2C430011   SLTIU V1, V0, 17
9D0072B4  50600063   BEQL V1, ZERO, 0x9D007444
9D0072B8  8384804C   LB A0, -32692(GP)
9D0072BC  00021080   SLL V0, V0, 2
9D0072C0  3C039D00   LUI V1, -25344
9D0072C4  246372D8   ADDIU V1, V1, 29400
9D0072C8  00621021   ADDU V0, V1, V0
9D0072CC  8C420000   LW V0, 0(V0)
9D0072D0  00400008   JR V0
9D0072D4  00000000   NOP
512:                             case CMD_HELP:
513:                                 display_cmd_list();
9D00731C  0F4019B2   JAL display_cmd_list
9D007320  00000000   NOP
514:                                 break;
9D007324  0B401D15   J 0x9D007454
9D007328  8FBF0014   LW RA, 20(SP)
515:                             case CMD_CD:
516:                                 cd(i);
9D00732C  0F4019F6   JAL cd
9D007330  02002021   ADDU A0, S0, ZERO
517:                                 break;
9D007334  0B401D15   J 0x9D007454
9D007338  8FBF0014   LW RA, 20(SP)
518:                             case CMD_DIR: // liste des fichiers sur la carte SD
519:                                 list_directory(i);
9D00733C  0F401C3D   JAL list_directory
9D007340  02002021   ADDU A0, S0, ZERO
520:                                 break;
9D007344  0B401D15   J 0x9D007454
9D007348  8FBF0014   LW RA, 20(SP)
521:                             case CMD_FORMAT:
522:                                 cmd_format(i);
9D00734C  0F4019E5   JAL cmd_format
9D007350  02002021   ADDU A0, S0, ZERO
523:                                 break;
9D007354  0B401D15   J 0x9D007454
9D007358  8FBF0014   LW RA, 20(SP)
524:                 //            case CMD_FREE:
525:                 //                cmd_free();
526:                 //                break;
527:                             case CMD_MKDIR:
528:                                 mkdir(i);
9D00735C  0F401C02   JAL mkdir
9D007360  02002021   ADDU A0, S0, ZERO
529:                                 break;
9D007364  0B401D15   J 0x9D007454
9D007368  8FBF0014   LW RA, 20(SP)
530:                             case CMD_DEL: // efface un fichier
531:                                 del(i);
9D00736C  0F401A22   JAL del
9D007370  02002021   ADDU A0, S0, ZERO
532:                                 break;
9D007374  0B401D15   J 0x9D007454
9D007378  8FBF0014   LW RA, 20(SP)
533:                             case CMD_REN: // renomme ou déplace un fichier
534:                                 ren(i);
9D00737C  0F401A71   JAL ren
9D007380  02002021   ADDU A0, S0, ZERO
535:                                 break;
9D007384  0B401D15   J 0x9D007454
9D007388  8FBF0014   LW RA, 20(SP)
536:                             case CMD_ED: // editeur
537:                                 editor(i);
9D00738C  0F401BF4   JAL editor
9D007390  02002021   ADDU A0, S0, ZERO
538:                                 break;
9D007394  0B401D15   J 0x9D007454
9D007398  8FBF0014   LW RA, 20(SP)
539:                 //            case CMD_BASIC: // lance DIOS forth
540:                 //               vpcBasic();
541:                 //                break;
542:                             case CMD_SND:  // envoie un fichier vers la sortie uart
543:                                 send(i);
9D00739C  0F401B0F   JAL send
9D0073A0  02002021   ADDU A0, S0, ZERO
544:                                 break;
9D0073A4  0B401D15   J 0x9D007454
9D0073A8  8FBF0014   LW RA, 20(SP)
545:                             case CMD_RCV:  // reçoit un fichier du uart
546:                                 receive(i);
9D0073AC  0F401B20   JAL receive
9D0073B0  02002021   ADDU A0, S0, ZERO
547:                                 break;
9D0073B4  0B401D15   J 0x9D007454
9D0073B8  8FBF0014   LW RA, 20(SP)
548:                             case CMD_CPY:   // copie un fichier
549:                                 copy(i);
9D0073BC  0F401A94   JAL copy
9D0073C0  02002021   ADDU A0, S0, ZERO
550:                                 break;
9D0073C4  0B401D15   J 0x9D007454
9D0073C8  8FBF0014   LW RA, 20(SP)
551:                             case CMD_EXPR: // évalue une expression
552:                                 expr();
9D0073CC  0F401C8C   JAL expr
9D0073D0  00000000   NOP
553:                                 break;
9D0073D4  0B401D15   J 0x9D007454
9D0073D8  8FBF0014   LW RA, 20(SP)
554:                             case CMD_CLEAR: // efface l'écran
555:                                 if (comm_channel==LOCAL_CON){
9D0073DC  9384804C   LBU A0, -32692(GP)
9D0073E0  14800005   BNE A0, ZERO, 0x9D0073F8
9D0073E4  7C042420   SEB A0, A0
556:                                     clear_screen();
9D0073E8  0F402290   JAL clear_screen
9D0073EC  00000000   NOP
557:                                 }else{
558:                                     print(comm_channel,"\E[2J\E[H"); // VT100 commands
9D0073F8  3C059D01   LUI A1, -25343
9D0073FC  0F40229C   JAL print
9D007400  24A5F678   ADDIU A1, A1, -2440
559:                                 }
560:                                 break;
561:                             case CMD_MORE:
562:                                 more(i);
9D00740C  0F401B31   JAL more
9D007410  02002021   ADDU A0, S0, ZERO
563:                                 break;
9D007414  0B401D15   J 0x9D007454
9D007418  8FBF0014   LW RA, 20(SP)
564:                             case CMD_PUTS: // affiche un texte à l'écran
565:                                 cmd_puts();
9D00741C  0F401C83   JAL cmd_puts
9D007420  00000000   NOP
566:                                 break;
9D007424  0B401D15   J 0x9D007454
9D007428  8FBF0014   LW RA, 20(SP)
567:                             case CMD_REBOOT: // redémarrage à froid.
568:                                 asm("lui $t0, 0xbfc0"); // _on_reset
9D00742C  3C08BFC0   LUI T0, -16448
569:                                 asm("j  $t0");
9D007430  01000008   JR T0
9D007434  00000000   NOP
570:                                 break;
9D007438  0B401D15   J 0x9D007454
9D00743C  8FBF0014   LW RA, 20(SP)
571:                             default:
572:                                 print(comm_channel,"unknown command!\r");
9D007440  8384804C   LB A0, -32692(GP)
9D007444  3C059D01   LUI A1, -25343
9D007448  0F40229C   JAL print
9D00744C  24A5F680   ADDIU A1, A1, -2432
573:                     }
574:                 }// execute_cmd()
9D0073F0  0B401D15   J 0x9D007454
9D0073F4  8FBF0014   LW RA, 20(SP)
9D007404  0B401D15   J 0x9D007454
9D007408  8FBF0014   LW RA, 20(SP)
9D007450  8FBF0014   LW RA, 20(SP)
9D007454  8FB00010   LW S0, 16(SP)
9D007458  03E00008   JR RA
9D00745C  27BD0018   ADDIU SP, SP, 24
575:                 
576:                 const char *prompt="\r#";
577:                 
578:                 void free_tokens(){
9D007460  27BDFFE0   ADDIU SP, SP, -32
9D007464  AFBF001C   SW RA, 28(SP)
9D007468  AFB10018   SW S1, 24(SP)
9D00746C  AFB00014   SW S0, 20(SP)
9D007470  3C10A000   LUI S0, -24576
9D007474  26102A14   ADDIU S0, S0, 10772
9D007478  3C11A000   LUI S1, -24576
9D00747C  26312A00   ADDIU S1, S1, 10752
579:                     int i;
580:                     for (i=MAX_TOKEN-1;i>=0;i--){
9D00749C  5611FFF9   BNEL S0, S1, 0x9D007484
9D0074A0  8E040000   LW A0, 0(S0)
581:                         if (cmd_tokens[i]){
9D007480  8E040000   LW A0, 0(S0)
9D007484  50800005   BEQL A0, ZERO, 0x9D00749C
9D007488  2610FFFC   ADDIU S0, S0, -4
582:                             free(cmd_tokens[i]);
9D00748C  0F405E55   JAL free
9D007490  00000000   NOP
583:                             cmd_tokens[i]=NULL;
9D007494  AE000000   SW ZERO, 0(S0)
9D007498  2610FFFC   ADDIU S0, S0, -4
584:                         }
585:                     }
586:                 }//free_tokens()
9D0074A4  8FBF001C   LW RA, 28(SP)
9D0074A8  8FB10018   LW S1, 24(SP)
9D0074AC  8FB00014   LW S0, 20(SP)
9D0074B0  03E00008   JR RA
9D0074B4  27BD0020   ADDIU SP, SP, 32
587:                 
588:                 int tokenize(){ // découpe la ligne d'entrée en mots
9D0074B8  27BDFFC0   ADDIU SP, SP, -64
9D0074BC  AFBF003C   SW RA, 60(SP)
9D0074C0  AFBE0038   SW S8, 56(SP)
9D0074C4  AFB70034   SW S7, 52(SP)
9D0074C8  AFB60030   SW S6, 48(SP)
9D0074CC  AFB5002C   SW S5, 44(SP)
9D0074D0  AFB40028   SW S4, 40(SP)
9D0074D4  AFB30024   SW S3, 36(SP)
9D0074D8  AFB20020   SW S2, 32(SP)
9D0074DC  AFB1001C   SW S1, 28(SP)
9D0074E0  AFB00018   SW S0, 24(SP)
589:                     int i;
590:                     char *token;
591:                     i=0;
9D0074F0  0000F021   ADDU S8, ZERO, ZERO
592:                     while ((i<MAX_TOKEN) && next_token()){
9D007548  24020005   ADDIU V0, ZERO, 5
9D00754C  13C2004E   BEQ S8, V0, 0x9D007688
9D007550  03C01021   ADDU V0, S8, ZERO
9D007678  02D7102B   SLTU V0, S6, S7
9D00767C  1440FFA3   BNE V0, ZERO, 0x9D00750C
9D007680  02F6B823   SUBU S7, S7, S6
9D0076B8  A0440052   SB A0, 82(V0)
593:                         token=malloc(sizeof(char)*(cmd_line.next-cmd_line.first+1));
9D00750C  0F4047DE   JAL malloc
9D007510  26E40001   ADDIU A0, S7, 1
9D007514  0040A021   ADDU S4, V0, ZERO
594:                         memcpy(token,&cmd_line.buff[cmd_line.first],cmd_line.next-cmd_line.first);
9D007518  264529B0   ADDIU A1, S2, 10672
9D00751C  00402021   ADDU A0, V0, ZERO
9D007520  00B62821   ADDU A1, A1, S6
9D007524  0F4050F5   JAL 0x9D0143D4
9D007528  02E03021   ADDU A2, S7, ZERO
595:                         *(token+cmd_line.next-cmd_line.first)=(char)0;
9D00752C  0297B821   ADDU S7, S4, S7
9D007530  A2E00000   SB ZERO, 0(S7)
596:                         cmd_tokens[i]=token;
9D007534  8FA20010   LW V0, 16(SP)
9D007538  AC540000   SW S4, 0(V0)
597:                         i++;
9D00753C  27DE0001   ADDIU S8, S8, 1
9D007540  24420004   ADDIU V0, V0, 4
9D007544  AFA20010   SW V0, 16(SP)
598:                     }//while
599:                     return i;
600:                 }//tokenize()
9D007684  03C01021   ADDU V0, S8, ZERO
9D007688  8FBF003C   LW RA, 60(SP)
9D00768C  8FBE0038   LW S8, 56(SP)
9D007690  8FB70034   LW S7, 52(SP)
9D007694  8FB60030   LW S6, 48(SP)
9D007698  8FB5002C   LW S5, 44(SP)
9D00769C  8FB40028   LW S4, 40(SP)
9D0076A0  8FB30024   LW S3, 36(SP)
9D0076A4  8FB20020   LW S2, 32(SP)
9D0076A8  8FB1001C   LW S1, 28(SP)
9D0076AC  8FB00018   LW S0, 24(SP)
9D0076B0  03E00008   JR RA
9D0076B4  27BD0040   ADDIU SP, SP, 64
601:                 
602:                 void shell(void){
9D0076D0  27BDFFE8   ADDIU SP, SP, -24
9D0076D4  AFBF0014   SW RA, 20(SP)
9D0076D8  AFB00010   SW S0, 16(SP)
603:                     int i;
604:                 
605:                     print(comm_channel,"VPC-32 shell\rfree RAM (bytes): ");
9D0076DC  8384804C   LB A0, -32692(GP)
9D0076E0  3C059D01   LUI A1, -25343
9D0076E4  0F40229C   JAL print
9D0076E8  24A5F694   ADDIU A1, A1, -2412
606:                     print_int(comm_channel,free_heap(),0);
9D0076EC  0F403E99   JAL free_heap
9D0076F0  8390804C   LB S0, -32692(GP)
9D0076F4  02002021   ADDU A0, S0, ZERO
9D0076F8  00402821   ADDU A1, V0, ZERO
9D0076FC  0F4022E0   JAL print_int
9D007700  00003021   ADDU A2, ZERO, ZERO
607:                     crlf();
9D007704  0F4021F6   JAL crlf
9D007708  3C10A000   LUI S0, -24576
608:                     free_tokens();
9D00770C  0F401D18   JAL free_tokens
9D007710  261029B0   ADDIU S0, S0, 10672
609:                     while (1){
610:                         print(comm_channel,prompt);
9D007714  8384804C   LB A0, -32692(GP)
9D007718  0F40229C   JAL print
9D00771C  8F858020   LW A1, -32736(GP)
9D007760  0B401DC6   J 0x9D007718
9D007764  8384804C   LB A0, -32692(GP)
611:                         cmd_line.first=0;
9D007720  A2000051   SB ZERO, 81(S0)
612:                         cmd_line.next=0;
9D007724  A2000052   SB ZERO, 82(S0)
613:                         cmd_line.len=readline(comm_channel,cmd_line.buff,CHAR_PER_LINE);
9D007728  8384804C   LB A0, -32692(GP)
9D00772C  02002821   ADDU A1, S0, ZERO
9D007730  0F4023F1   JAL readline
9D007734  24060035   ADDIU A2, ZERO, 53
614:                         if (cmd_line.len){
9D007738  1040FFF6   BEQ V0, ZERO, 0x9D007714
9D00773C  A2020050   SB V0, 80(S0)
615:                             i=tokenize();
9D007740  0F401D2E   JAL tokenize
9D007744  00000000   NOP
616:                             if (i) {
9D007748  5040FFF3   BEQL V0, ZERO, 0x9D007718
9D00774C  8384804C   LB A0, -32692(GP)
617:                                 execute_cmd(i);
9D007750  0F401CA5   JAL execute_cmd
9D007754  00402021   ADDU A0, V0, ZERO
618:                                 free_tokens();
9D007758  0F401D18   JAL free_tokens
9D00775C  00000000   NOP
619:                             } // if
620:                         }// if
621:                     }//while(1)
622:                     asm("lui $t0, 0xbfc0"); // _on_reset
623:                     asm("j  $t0");
624:                 }//shell()
625:                 
---  /home/jacques/MPLABXProjects/vpc-32/hardware/tvout/ntsc.c  -----------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /* 
19:                   * File:   test-ntsc.c
20:                   * Author: Jacques Deschênes
21:                   * Description: test génération signal vidéo NTSC sur PIC32MX150F128B.
22:                   * Created on 20 août 2013, 08:48
23:                   */
24:                  
25:                  #include <stdio.h>
26:                  #include <stdlib.h>
27:                  #include <sys/attribs.h>
28:                  #include <plib.h>
29:                  #include "../HardwareProfile.h"
30:                  #include "ntsc.h"
31:                  
32:                  /*
33:                   *  la fréquence PBCLK influence la largeur des pixels vidéo. Comme PBCLK==SYSCLK
34:                   *  on peut allonger les pixels en diminuant la fréquence légèrement.
35:                   *  pour une résolution horizontale de 320 pixels et une fréquence de 40Mhz le
36:                   *  meilleur diviseur pour le générateur BGR du SPI est de 2 ce qui donne
37:                   *  une fréquence de pixel de  40e6/(2*(2+1)=6,67Mhz et la durée total d'une
38:                   *  ligne vidéo est donc de 320/6,67e6= 48µSec.
39:                   *  En principe pour le standard NTSC on dispose de 52µSec par ligne vidéo.
40:                   *  En pratique on est plutôt à 51µSec. Donc ici on a 3µSec inutilisées.
41:                   *  en résuidant SYSCLK à 37,5Mhz on a 51,2µSec par ligne vidéo. Les pixels
42:                   *  sont donc moins compressé horizontalement. Mais sur certains téléviseurs
43:                   *  on peut perdre quelques pixels en bout de ligne.
44:                   *  la constante SPI_DLY doit-être ajustée en fonction de PBCLK pour que les
45:                   *  320 pixels horizontals soient visibles.
46:                   */
47:                  /* UTILISATION DMA canal 0 et SPI1
48:                   *  les pixels sont sérialisés par SPI1.  Le canal DMA 0 qui prend les pixels
49:                   *  dans le buffer vidéo est les transfert dans le TX buffer du SPI.
50:                   *  le SPI en configuré en mode FRAME. Pour fonctionner il attend donc
51:                   *  que la ligne 
52:                   */
53:                  
54:                  #define PWM_PERIOD (SYSCLK/15748)-1
55:                  #define HALFLINE (PWM_PERIOD-1)
56:                  #define HSYNC  (SYSCLK/212766)  // 4,7µSec
57:                  #define SERATION (HSYNC/2)
58:                  #define FIRST_LINE (34)   //première ligne de scan visible
59:                  #define LAST_LINE (FIRST_LINE+VRES+1)  // dernière ligne de scan visible
60:                  #define BITCLK ((int)(HRES * 1000000L/52)) // 52µSec c'est le temps que dure 1 ligne vidéo.
61:                  #if SYSCLK==40000000L
62:                  #define SPI_DLY HSYNC+90 // délais en début de ligne avant l'envoie du signal vidéo.
63:                  #else
64:                  #define SPI_DLY (HSYNC+38) // délais en début de ligne avant l'envoie du signal vidéo.
65:                  #endif
66:                  #define _enable_video_out()  SPI1CONSET =(1<<15)
67:                  #define _disable_video_out() SPI1CONCLR =(1<<15)
68:                  
69:                  unsigned int video_bmp[VRES][HRES/32]; // video bitmap 7168 octets
70:                  volatile static int *DmaSrc;
71:                  
72:                  
73:                  
74:                  void VideoInit(void){
9D00F018  27BDFFD8   ADDIU SP, SP, -40
9D00F01C  AFBF0024   SW RA, 36(SP)
9D00F020  AFB20020   SW S2, 32(SP)
9D00F024  AFB1001C   SW S1, 28(SP)
9D00F028  AFB00018   SW S0, 24(SP)
75:                      //configuration PWM sur OC2 pour SYNC, utilisation TIMER2
76:                      T2CON = 0;
9D00F02C  3C02BF80   LUI V0, -16512
9D00F030  AC400800   SW ZERO, 2048(V0)
77:                      PR2=PWM_PERIOD;
9D00F034  240309EB   ADDIU V1, ZERO, 2539
9D00F038  3C02BF80   LUI V0, -16512
9D00F03C  AC430820   SW V1, 2080(V0)
78:                      OC2CONbits.OCM = 5; // mode train d'impulsion
9D00F040  3C02BF80   LUI V0, -16512
9D00F044  8C433200   LW V1, 12800(V0)
9D00F048  24120005   ADDIU S2, ZERO, 5
9D00F04C  7E431004   INS V1, S2, 0, 3
9D00F050  AC433200   SW V1, 12800(V0)
79:                      OC2RS = 0; 
9D00F054  3C03BF80   LUI V1, -16512
9D00F058  AC603220   SW ZERO, 12832(V1)
80:                      OC2R = HSYNC;
9D00F05C  240400BB   ADDIU A0, ZERO, 187
9D00F060  3C03BF80   LUI V1, -16512
9D00F064  AC643210   SW A0, 12816(V1)
81:                      IFS0bits.T2IF=0;
9D00F068  3C03BF88   LUI V1, -16504
9D00F06C  8C641030   LW A0, 4144(V1)
9D00F070  7C044A44   INS A0, ZERO, 9, 1
9D00F074  AC641030   SW A0, 4144(V1)
82:                      IEC0bits.T2IE=1;
9D00F078  3C03BF88   LUI V1, -16504
9D00F07C  8C641060   LW A0, 4192(V1)
9D00F080  24110001   ADDIU S1, ZERO, 1
9D00F084  7E244A44   INS A0, S1, 9, 1
9D00F088  AC641060   SW A0, 4192(V1)
83:                      IPC2bits.T2IP=7;
9D00F08C  3C03BF88   LUI V1, -16504
9D00F090  8C6410B0   LW A0, 4272(V1)
9D00F094  24050007   ADDIU A1, ZERO, 7
9D00F098  7CA42084   INS A0, A1, 2, 3
9D00F09C  AC6410B0   SW A0, 4272(V1)
84:                      IPC2bits.T2IS=3;
9D00F0A0  8C6410B0   LW A0, 4272(V1)
9D00F0A4  24050003   ADDIU A1, ZERO, 3
9D00F0A8  7CA40804   INS A0, A1, 0, 2
9D00F0AC  AC6410B0   SW A0, 4272(V1)
85:                      OC2CONbits.ON =1;  // activation
9D00F0B0  8C433200   LW V1, 12800(V0)
9D00F0B4  7E237BC4   INS V1, S1, 15, 1
9D00F0B8  AC433200   SW V1, 12800(V0)
86:                      T2CONbits.ON=1;  // activation
9D00F0BC  3C02BF80   LUI V0, -16512
9D00F0C0  8C430800   LW V1, 2048(V0)
9D00F0C4  7E237BC4   INS V1, S1, 15, 1
9D00F0C8  AC430800   SW V1, 2048(V0)
87:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
88:                      OC1CONbits.OCM = 5; //mode train d'impulsion
9D00F0CC  3C02BF80   LUI V0, -16512
9D00F0D0  8C433000   LW V1, 12288(V0)
9D00F0D4  7E431004   INS V1, S2, 0, 3
9D00F0D8  AC433000   SW V1, 12288(V0)
89:                      OC1RS=0;
9D00F0DC  3C03BF80   LUI V1, -16512
9D00F0E0  AC603020   SW ZERO, 12320(V1)
90:                      OC1R=HSYNC+SPI_DLY;
9D00F0E4  240401D0   ADDIU A0, ZERO, 464
9D00F0E8  3C03BF80   LUI V1, -16512
9D00F0EC  AC643010   SW A0, 12304(V1)
91:                      OC1CONbits.ON=1;
9D00F0F0  8C433000   LW V1, 12288(V0)
9D00F0F4  7E237BC4   INS V1, S1, 15, 1
9D00F0F8  AC433000   SW V1, 12288(V0)
92:                      // configuration SPI pour sortie vidéo
93:                      // configure le DMA
94:                      DmaChnOpen(0,0,DMA_OPEN_DEFAULT);
9D00F0FC  00002021   ADDU A0, ZERO, ZERO
9D00F100  00002821   ADDU A1, ZERO, ZERO
9D00F104  0F4055DA   JAL DmaChnOpen
9D00F108  00003021   ADDU A2, ZERO, ZERO
95:                      DmaChnSetEventControl(0,DMA_EV_START_IRQ_EN|
9D00F10C  00002021   ADDU A0, ZERO, ZERO
9D00F110  0F405E31   JAL DmaChnWriteEventControlFlags
9D00F114  24052610   ADDIU A1, ZERO, 9744
96:                                            DMA_EV_START_IRQ(_SPI1_TX_IRQ));
97:                      DmaChnSetTxfer(0,(void *)DmaSrc,(void *)&SPI1BUF,HRES/8,4,4);
9D00F118  24020004   ADDIU V0, ZERO, 4
9D00F11C  AFA20010   SW V0, 16(SP)
9D00F120  AFA20014   SW V0, 20(SP)
9D00F124  00002021   ADDU A0, ZERO, ZERO
9D00F128  8F858044   LW A1, -32700(GP)
9D00F12C  3C06BF80   LUI A2, -16512
9D00F130  24C65820   ADDIU A2, A2, 22560
9D00F134  0F4059F6   JAL DmaChnSetTxfer
9D00F138  24070028   ADDIU A3, ZERO, 40
98:                      // configuration du SPI canal 1
99:                      SPI1CONbits.DISSDI=1; // SDI n'est pas utilisé.
9D00F13C  3C10BF80   LUI S0, -16512
9D00F140  8E025800   LW V0, 22528(S0)
9D00F144  7E222104   INS V0, S1, 4, 1
9D00F148  AE025800   SW V0, 22528(S0)
100:                     SPI1CONbits.FRMEN=1; // frame mode
9D00F14C  8E025800   LW V0, 22528(S0)
9D00F150  7E22FFC4   INS V0, S1, 31, 1
9D00F154  AE025800   SW V0, 22528(S0)
101:                     SPI1CONbits.FRMCNT=5; // 32 octets par frame.
9D00F158  8E025800   LW V0, 22528(S0)
9D00F15C  7E42D604   INS V0, S2, 24, 3
9D00F160  AE025800   SW V0, 22528(S0)
102:                     SPI1CONbits.FRMPOL=1; // sync sur transition montante
9D00F164  8E025800   LW V0, 22528(S0)
9D00F168  7E22EF44   INS V0, S1, 29, 1
9D00F16C  AE025800   SW V0, 22528(S0)
103:                     SPI1CONbits.FRMSYNC=1; // synchronisation esclave
9D00F170  8E025800   LW V0, 22528(S0)
9D00F174  7E22F784   INS V0, S1, 30, 1
9D00F178  AE025800   SW V0, 22528(S0)
104:                     SPI1CONbits.MSTEN=1; // SPI maître
9D00F17C  8E025800   LW V0, 22528(S0)
9D00F180  7E222944   INS V0, S1, 5, 1
9D00F184  AE025800   SW V0, 22528(S0)
105:                    // SPI1CONbits.SPIFE=1; // synchronisation sur clock premier bit.
106:                     SPI1CONbits.MODE32=1; // mode 32 bits
9D00F188  8E025800   LW V0, 22528(S0)
9D00F18C  7E225AC4   INS V0, S1, 11, 1
9D00F190  AE025800   SW V0, 22528(S0)
107:                     SPI1CONbits.STXISEL=1; // interruption sur TBE
9D00F194  8E025800   LW V0, 22528(S0)
9D00F198  7E221884   INS V0, S1, 2, 2
9D00F19C  AE025800   SW V0, 22528(S0)
108:                     SpiChnSetBitRate(SPI_CHANNEL1, PBCLK, BITCLK);
9D00F1A0  24040001   ADDIU A0, ZERO, 1
9D00F1A4  3C050262   LUI A1, 610
9D00F1A8  24A55A00   ADDIU A1, A1, 23040
9D00F1AC  3C06005D   LUI A2, 93
9D00F1B0  0F405D7C   JAL SpiChnSetBitRate
9D00F1B4  34C6E676   ORI A2, A2, -6538
109:                     SPI1CONbits.ON=1;
9D00F1B8  8E025800   LW V0, 22528(S0)
9D00F1BC  7E227BC4   INS V0, S1, 15, 1
9D00F1C0  AE025800   SW V0, 22528(S0)
110:                 }//init_video()
9D00F1C4  8FBF0024   LW RA, 36(SP)
9D00F1C8  8FB20020   LW S2, 32(SP)
9D00F1CC  8FB1001C   LW S1, 28(SP)
9D00F1D0  8FB00018   LW S0, 24(SP)
9D00F1D4  03E00008   JR RA
9D00F1D8  27BD0028   ADDIU SP, SP, 40
111:                 
112:                 
113:                 
114:                 void __ISR(_TIMER_2_VECTOR,IPL7AUTO) tmr2_isr(void){
9D00F1DC  415DE800   RDPGPR SP, SP
9D00F1E0  401B7000   MFC0 K1, EPC
9D00F1E4  401A6002   MFC0 K0, SRSCtl
9D00F1E8  27BDFFE0   ADDIU SP, SP, -32
9D00F1EC  401B6000   MFC0 K1, Status
9D00F1F0  AFBA001C   SW K0, 28(SP)
9D00F1F4  AFBB0018   SW K1, 24(SP)
9D00F1F8  7C1B7844   INS K1, ZERO, 1, 15
9D00F1FC  377B1C00   ORI K1, K1, 7168
9D00F200  409B6000   MTC0 K1, Status
9D00F204  AFA30008   SW V1, 8(SP)
9D00F208  AFA20004   SW V0, 4(SP)
9D00F20C  AFA4000C   SW A0, 12(SP)
115:                     _disable_video_out();
9D00F210  34038000   ORI V1, ZERO, -32768
9D00F214  3C02BF80   LUI V0, -16512
9D00F218  AC435804   SW V1, 22532(V0)
116:                     static int ln_cnt=-1;
117:                     static char video=0;
118:                     static char even=1;
119:                     
120:                     ln_cnt++;
9D00F21C  8F828018   LW V0, -32744(GP)
9D00F220  24420001   ADDIU V0, V0, 1
121:                     switch (ln_cnt){
9D00F224  24030012   ADDIU V1, ZERO, 18
9D00F228  1043002C   BEQ V0, V1, 0x9D00F2DC
9D00F22C  AF828018   SW V0, -32744(GP)
9D00F230  28430013   SLTI V1, V0, 19
9D00F234  1060000B   BEQ V1, ZERO, 0x9D00F264
9D00F238  240300F3   ADDIU V1, ZERO, 243
9D00F23C  24030006   ADDIU V1, ZERO, 6
9D00F240  1043001E   BEQ V0, V1, 0x9D00F2BC
9D00F244  2403098D   ADDIU V1, ZERO, 2445
9D00F248  2403000C   ADDIU V1, ZERO, 12
9D00F24C  5043001F   BEQL V0, V1, 0x9D00F2CC
9D00F250  2403005D   ADDIU V1, ZERO, 93
9D00F254  10400012   BEQ V0, ZERO, 0x9D00F2A0
9D00F258  240309EA   ADDIU V1, ZERO, 2538
9D00F264  10430035   BEQ V0, V1, 0x9D00F33C
9D00F268  284300F4   SLTI V1, V0, 244
9D00F26C  10600006   BEQ V1, ZERO, 0x9D00F288
9D00F270  2403010F   ADDIU V1, ZERO, 271
9D00F274  24030022   ADDIU V1, ZERO, 34
9D00F278  54430032   BNEL V0, V1, 0x9D00F344
9D00F27C  83828048   LB V0, -32696(GP)
9D00F288  1043001C   BEQ V0, V1, 0x9D00F2FC
9D00F28C  24030110   ADDIU V1, ZERO, 272
9D00F290  5443002C   BNEL V0, V1, 0x9D00F344
9D00F294  83828048   LB V0, -32696(GP)
122:                         case 0:
123:                             PR2=HALFLINE;
9D00F2A0  3C02BF80   LUI V0, -16512
9D00F2A4  AC430820   SW V1, 2080(V0)
124:                             OC2R=SERATION;
9D00F2A8  2403005D   ADDIU V1, ZERO, 93
9D00F2AC  3C02BF80   LUI V0, -16512
9D00F2B0  AC433210   SW V1, 12816(V0)
125:                             break;
9D00F2B4  0B403CF8   J 0x9D00F3E0
9D00F2B8  24030200   ADDIU V1, ZERO, 512
126:                         case 6:
127:                             OC2R=HALFLINE-SERATION;
9D00F2BC  3C02BF80   LUI V0, -16512
9D00F2C0  AC433210   SW V1, 12816(V0)
128:                             break;
9D00F2C4  0B403CF8   J 0x9D00F3E0
9D00F2C8  24030200   ADDIU V1, ZERO, 512
129:                         case 12:
130:                             OC2R=SERATION;
9D00F2CC  3C02BF80   LUI V0, -16512
9D00F2D0  AC433210   SW V1, 12816(V0)
131:                             break;
9D00F2D4  0B403CF8   J 0x9D00F3E0
9D00F2D8  24030200   ADDIU V1, ZERO, 512
132:                         case 18:
133:                             PR2=PWM_PERIOD;
9D00F2DC  240309EB   ADDIU V1, ZERO, 2539
9D00F2E0  3C02BF80   LUI V0, -16512
9D00F2E4  AC430820   SW V1, 2080(V0)
134:                             OC2R=HSYNC;
9D00F2E8  240300BB   ADDIU V1, ZERO, 187
9D00F2EC  3C02BF80   LUI V0, -16512
9D00F2F0  AC433210   SW V1, 12816(V0)
135:                             break;
9D00F2F4  0B403CF8   J 0x9D00F3E0
9D00F2F8  24030200   ADDIU V1, ZERO, 512
136:                         case 271:
137:                             if (even){
9D00F2FC  83828014   LB V0, -32748(GP)
9D00F300  10400037   BEQ V0, ZERO, 0x9D00F3E0
9D00F304  24030200   ADDIU V1, ZERO, 512
138:                                 even=0;
9D00F308  A3808014   SB ZERO, -32748(GP)
139:                                 ln_cnt=-1;
9D00F30C  2402FFFF   ADDIU V0, ZERO, -1
9D00F310  0B403CF8   J 0x9D00F3E0
9D00F314  AF828018   SW V0, -32744(GP)
140:                             }
141:                             break;
142:                         case 272:
143:                             even=1;
9D00F298  0B403CC6   J 0x9D00F318
9D00F29C  24020001   ADDIU V0, ZERO, 1
9D00F318  A3828014   SB V0, -32748(GP)
144:                             ln_cnt=-1;
9D00F31C  2402FFFF   ADDIU V0, ZERO, -1
145:                             break;
9D00F320  0B403CF7   J 0x9D00F3DC
9D00F324  AF828018   SW V0, -32744(GP)
146:                         case FIRST_LINE:
147:                             video=1;
9D00F280  0B403CCA   J 0x9D00F328
9D00F284  24020001   ADDIU V0, ZERO, 1
9D00F328  A3828048   SB V0, -32696(GP)
148:                             DmaSrc=(void*)&video_bmp[0];
9D00F32C  3C02A000   LUI V0, -24576
9D00F330  24420138   ADDIU V0, V0, 312
149:                             break;
9D00F334  0B403CF7   J 0x9D00F3DC
9D00F338  AF828044   SW V0, -32700(GP)
150:                         case LAST_LINE:
151:                             video=0;
152:                             //_disable_video_out();
153:                             break;
9D00F33C  0B403CF7   J 0x9D00F3DC
9D00F340  A3808048   SB ZERO, -32696(GP)
154:                         default:
155:                             if (video){
9D00F25C  0B403CD1   J 0x9D00F344
9D00F260  83828048   LB V0, -32696(GP)
9D00F344  10400026   BEQ V0, ZERO, 0x9D00F3E0
9D00F348  24030200   ADDIU V1, ZERO, 512
156:                                 asm volatile(
9D00F34C  3C02BF80   LUI V0, -16512
9D00F350  24420810   ADDIU V0, V0, 2064
9D00F354  94440000   LHU A0, 0(V0)
9D00F358  30840007   ANDI A0, A0, 7
9D00F35C  00042080   SLL A0, A0, 2
9D00F360  3C029D01   LUI V0, -25343
9D00F364  2442F374   ADDIU V0, V0, -3212
9D00F368  00822021   ADDU A0, A0, V0
9D00F36C  00800008   JR A0
9D00F370  00000000   NOP
9D00F374  00000000   NOP
9D00F378  00000000   NOP
9D00F37C  00000000   NOP
9D00F380  00000000   NOP
9D00F384  00000000   NOP
9D00F388  00000000   NOP
9D00F38C  00000000   NOP
9D00F390  00000000   NOP
157:                                 "la $v0,%0\n"
158:                                 "lhu $a0, 0($v0)\n"
159:                                 "andi $a0,$a0,7\n"
160:                                 "sll $a0,$a0,2\n"
161:                                 "la $v0, jit\n"
162:                                 "addu $a0,$v0\n"
163:                                 "jr $a0\n"
164:                                 "jit:\n"
165:                                 "nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"
166:                                 ::"i"(&TMR2)
167:                                 );
168:                                 _enable_video_out();
9D00F394  34038000   ORI V1, ZERO, -32768
9D00F398  3C02BF80   LUI V0, -16512
9D00F39C  AC435808   SW V1, 22536(V0)
169:                                 IFS1bits.SPI1TXIF=1;
9D00F3A0  3C02BF88   LUI V0, -16504
9D00F3A4  8C431040   LW V1, 4160(V0)
9D00F3A8  24040001   ADDIU A0, ZERO, 1
9D00F3AC  7C833184   INS V1, A0, 6, 1
9D00F3B0  AC431040   SW V1, 4160(V0)
170:                                 DCH0SSA=KVA_TO_PA((void *)DmaSrc);
9D00F3B4  8F828044   LW V0, -32700(GP)
9D00F3B8  7C44E000   EXT A0, V0, 0, 29
9D00F3BC  3C03BF88   LUI V1, -16504
9D00F3C0  AC643090   SW A0, 12432(V1)
171:                                 DmaSrc +=HRES/32;
9D00F3C4  24420028   ADDIU V0, V0, 40
9D00F3C8  AF828044   SW V0, -32700(GP)
172:                                 DCH0CON |=128; // remplace DmaChnEnable(0); réduit le temps de latence
9D00F3CC  3C02BF88   LUI V0, -16504
9D00F3D0  8C433060   LW V1, 12384(V0)
9D00F3D4  34630080   ORI V1, V1, 128
9D00F3D8  AC433060   SW V1, 12384(V0)
173:                             }
174:                     }//switch (ln_cnt)
175:                     mT2ClearIntFlag();
9D00F3DC  24030200   ADDIU V1, ZERO, 512
9D00F3E0  3C02BF88   LUI V0, -16504
9D00F3E4  AC431034   SW V1, 4148(V0)
176:                 }//tmr2_isr()
9D00F3E8  8FA2001C   LW V0, 28(SP)
9D00F3EC  3042000F   ANDI V0, V0, 15
9D00F3F0  14400004   BNE V0, ZERO, 0x9D00F404
9D00F3F4  8FBB0018   LW K1, 24(SP)
9D00F3F8  8FA4000C   LW A0, 12(SP)
9D00F3FC  8FA30008   LW V1, 8(SP)
9D00F400  8FA20004   LW V0, 4(SP)
9D00F404  8FBA001C   LW K0, 28(SP)
9D00F408  27BD0020   ADDIU SP, SP, 32
9D00F40C  409A6002   MTC0 K0, SRSCtl
9D00F410  41DDE800   WRPGPR SP, SP
9D00F414  409B6000   MTC0 K1, Status
9D00F418  42000018   ERET
177:                 
---  /home/jacques/MPLABXProjects/vpc-32/hardware/store/store_spi.c  ------------------------------------
1:                   /*
2:                   * Copyright 2013,2014 Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   store_spi.c
21:                   * Author: jacques Deschênes
22:                   * Description: shared SPI interface used by SDcard and SPIRAM
23:                   *
24:                   * Created on 25 novembre 2014, 15:40
25:                   */
26:                  
27:                  #include <peripheral/ports.h>
28:                  #include "store_spi.h"
29:                  
30:                  unsigned char store_initialized=0;
31:                  
32:                  void store_spi_init(){
33:                      STORE_PORT |= SRAM_SEL|SDC_SEL;  // both devices disabled
9D016BD4  3C02BF88   LUI V0, -16504
9D016BD8  8C436120   LW V1, 24864(V0)
9D016BDC  34630006   ORI V1, V1, 6
9D016BE0  AC436120   SW V1, 24864(V0)
34:                      STORE_PORT &= ~STATUS_LED ; // status LED off
9D016BE4  8C446120   LW A0, 24864(V0)
9D016BE8  2403FFF7   ADDIU V1, ZERO, -9
9D016BEC  00831824   AND V1, A0, V1
9D016BF0  AC436120   SW V1, 24864(V0)
35:                      STORE_TRIS &= ~(SRAM_SEL|SDC_SEL|STATUS_LED); // CS1, CS2 and STATUS_LED as output
9D016BF4  3C02BF88   LUI V0, -16504
9D016BF8  8C446110   LW A0, 24848(V0)
9D016BFC  2403FFF1   ADDIU V1, ZERO, -15
9D016C00  00831824   AND V1, A0, V1
9D016C04  AC436110   SW V1, 24848(V0)
36:                      STORE_SPICON = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
9D016C08  34038120   ORI V1, ZERO, -32480
9D016C0C  3C02BF80   LUI V0, -16512
9D016C10  AC435A00   SW V1, 23040(V0)
37:                      //SPI2 at maximum speed, this 20Mhz for 23LC1024
38:                      if (mGetPeripheralClock()<40000000L){
39:                          STORE_SPIBRG=0;
40:                      }else{
41:                          STORE_SPIBRG = (mGetPeripheralClock() / (2 * 20000000)) - 1; // 20Mbits/sec
9D016C14  3C02BF80   LUI V0, -16512
9D016C18  AC405A30   SW ZERO, 23088(V0)
42:                      }
43:                      store_initialized=1;
9D016C1C  24020001   ADDIU V0, ZERO, 1
44:                  }
9D016C20  03E00008   JR RA
9D016C24  A3828040   SB V0, -32704(GP)
45:                  
46:                  
47:                  // send one byte of data and receive one back at the same time
48:                  unsigned char writeSPI(unsigned char b)
49:                  {
9D016C28  308400FF   ANDI A0, A0, 255
50:                  
51:                  	STORE_SPIBUF = b;
9D016C2C  3C02BF80   LUI V0, -16512
9D016C30  AC445A20   SW A0, 23072(V0)
52:                  	while(!STORE_SPISTATbits.SPIRBF);	// wait transfer complete
9D016C34  3C03BF80   LUI V1, -16512
9D016C38  8C625A10   LW V0, 23056(V1)
9D016C3C  30420001   ANDI V0, V0, 1
9D016C40  1040FFFD   BEQ V0, ZERO, 0x9D016C38
9D016C44  3C02BF80   LUI V0, -16512
53:                  	return STORE_SPIBUF;			// read the received value
9D016C48  8C425A20   LW V0, 23072(V0)
54:                  
55:                  }	// writeSPI
9D016C4C  03E00008   JR RA
9D016C50  304200FF   ANDI V0, V0, 255
56:                  
---  /home/jacques/MPLABXProjects/vpc-32/hardware/spiram/spiram.c  --------------------------------------
1:                   /*
2:                   * Copyright 2013,2014 Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  #include "../HardwareProfile.h"
20:                  #include "spiram.h"
21:                  #include "../Pinguino/sdmmc.h"
22:                  
23:                  
24:                  
25:                  void sram_cmd(unsigned char cmd, unsigned addr){
9D00C868  27BDFFE8   ADDIU SP, SP, -24
9D00C86C  AFBF0014   SW RA, 20(SP)
9D00C870  AFB00010   SW S0, 16(SP)
9D00C874  00A08021   ADDU S0, A1, ZERO
26:                      writeSPI(cmd);
9D00C878  0F405B0A   JAL writeSPI
9D00C87C  308400FF   ANDI A0, A0, 255
27:                      writeSPI(addr>>16);
9D00C880  0F405B0A   JAL writeSPI
9D00C884  7E043C00   EXT A0, S0, 16, 8
28:                      writeSPI(addr>>8);
9D00C888  0F405B0A   JAL writeSPI
9D00C88C  7E043A00   EXT A0, S0, 8, 8
29:                      writeSPI(addr&0xff);
9D00C890  0F405B0A   JAL writeSPI
9D00C894  320400FF   ANDI A0, S0, 255
30:                  }
9D00C898  8FBF0014   LW RA, 20(SP)
9D00C89C  8FB00010   LW S0, 16(SP)
9D00C8A0  03E00008   JR RA
9D00C8A4  27BD0018   ADDIU SP, SP, 24
31:                  
32:                  
33:                  
34:                  void sram_write_mode(unsigned char mode){
9D00C8A8  27BDFFD8   ADDIU SP, SP, -40
9D00C8AC  AFBF0024   SW RA, 36(SP)
9D00C8B0  AFB40020   SW S4, 32(SP)
9D00C8B4  AFB3001C   SW S3, 28(SP)
9D00C8B8  AFB20018   SW S2, 24(SP)
9D00C8BC  AFB10014   SW S1, 20(SP)
9D00C8C0  AFB00010   SW S0, 16(SP)
9D00C8C4  309000FF   ANDI S0, A0, 255
35:                      _sram_enable();
9D00C8C8  3C14BF88   LUI S4, -16504
9D00C8CC  24110002   ADDIU S1, ZERO, 2
9D00C8D0  AE916124   SW S1, 24868(S4)
9D00C8D4  3C12BF88   LUI S2, -16504
9D00C8D8  24130008   ADDIU S3, ZERO, 8
9D00C8DC  AE536128   SW S3, 24872(S2)
36:                      writeSPI(SRAM_WRMR);
9D00C8E0  0F405B0A   JAL writeSPI
9D00C8E4  24040001   ADDIU A0, ZERO, 1
37:                      writeSPI(mode);
9D00C8E8  0F405B0A   JAL writeSPI
9D00C8EC  02002021   ADDU A0, S0, ZERO
38:                      _sram_disable();
9D00C8F0  AE516128   SW S1, 24872(S2)
9D00C8F4  AE936124   SW S3, 24868(S4)
39:                  }
9D00C8F8  8FBF0024   LW RA, 36(SP)
9D00C8FC  8FB40020   LW S4, 32(SP)
9D00C900  8FB3001C   LW S3, 28(SP)
9D00C904  8FB20018   LW S2, 24(SP)
9D00C908  8FB10014   LW S1, 20(SP)
9D00C90C  8FB00010   LW S0, 16(SP)
9D00C910  03E00008   JR RA
9D00C914  27BD0028   ADDIU SP, SP, 40
40:                  
41:                  
42:                  unsigned char sram_read_mode(){
9D00C918  27BDFFD8   ADDIU SP, SP, -40
9D00C91C  AFBF0024   SW RA, 36(SP)
9D00C920  AFB30020   SW S3, 32(SP)
9D00C924  AFB2001C   SW S2, 28(SP)
9D00C928  AFB10018   SW S1, 24(SP)
9D00C92C  AFB00014   SW S0, 20(SP)
43:                      unsigned char mode;
44:                      _sram_enable();
9D00C930  3C13BF88   LUI S3, -16504
9D00C934  24100002   ADDIU S0, ZERO, 2
9D00C938  AE706124   SW S0, 24868(S3)
9D00C93C  3C11BF88   LUI S1, -16504
9D00C940  24120008   ADDIU S2, ZERO, 8
9D00C944  AE326128   SW S2, 24872(S1)
45:                      writeSPI(SRAM_RDMR);
9D00C948  0F405B0A   JAL writeSPI
9D00C94C  24040005   ADDIU A0, ZERO, 5
46:                      mode=writeSPI(0);
9D00C950  0F405B0A   JAL writeSPI
9D00C954  00002021   ADDU A0, ZERO, ZERO
47:                      _sram_disable();
9D00C958  AE306128   SW S0, 24872(S1)
9D00C95C  AE726124   SW S2, 24868(S3)
48:                      return mode;
49:                  }
9D00C960  8FBF0024   LW RA, 36(SP)
9D00C964  8FB30020   LW S3, 32(SP)
9D00C968  8FB2001C   LW S2, 28(SP)
9D00C96C  8FB10018   LW S1, 24(SP)
9D00C970  8FB00014   LW S0, 20(SP)
9D00C974  03E00008   JR RA
9D00C978  27BD0028   ADDIU SP, SP, 40
50:                  
51:                  // use sequencial mode
52:                  void sram_init(){
9D00C97C  27BDFFE8   ADDIU SP, SP, -24
9D00C980  AFBF0014   SW RA, 20(SP)
53:                      if (!store_initialized) store_spi_init();
9D00C984  93828040   LBU V0, -32704(GP)
9D00C988  14400003   BNE V0, ZERO, 0x9D00C998
9D00C98C  00000000   NOP
9D00C990  0F405AF5   JAL store_spi_init
9D00C994  00000000   NOP
54:                      sram_write_mode(SRAM_SQMD);
9D00C998  0F40322A   JAL sram_write_mode
9D00C99C  24040040   ADDIU A0, ZERO, 64
55:                  }
9D00C9A0  8FBF0014   LW RA, 20(SP)
9D00C9A4  03E00008   JR RA
9D00C9A8  27BD0018   ADDIU SP, SP, 24
56:                  
57:                  
58:                  void sram_clear(){
9D00C9AC  27BDFFE0   ADDIU SP, SP, -32
9D00C9B0  AFBF001C   SW RA, 28(SP)
9D00C9B4  AFB10018   SW S1, 24(SP)
9D00C9B8  AFB00014   SW S0, 20(SP)
59:                      unsigned i;
60:                      _sram_enable();
9D00C9BC  24030002   ADDIU V1, ZERO, 2
9D00C9C0  3C02BF88   LUI V0, -16504
9D00C9C4  AC436124   SW V1, 24868(V0)
9D00C9C8  24030008   ADDIU V1, ZERO, 8
9D00C9CC  3C02BF88   LUI V0, -16504
9D00C9D0  AC436128   SW V1, 24872(V0)
61:                      sram_cmd(SRAM_WRITE,0);
9D00C9D4  24040002   ADDIU A0, ZERO, 2
9D00C9D8  0F40321A   JAL sram_cmd
9D00C9DC  00002821   ADDU A1, ZERO, ZERO
62:                      for (i=0;i<SRAM_SIZE;i++) writeSPI(0);
9D00C9E0  00008021   ADDU S0, ZERO, ZERO
9D00C9E4  3C110002   LUI S1, 2
9D00C9E8  0F405B0A   JAL writeSPI
9D00C9EC  00002021   ADDU A0, ZERO, ZERO
9D00C9F0  26100001   ADDIU S0, S0, 1
9D00C9F4  1611FFFC   BNE S0, S1, 0x9D00C9E8
9D00C9F8  24030002   ADDIU V1, ZERO, 2
63:                      _sram_disable();
9D00C9FC  3C02BF88   LUI V0, -16504
9D00CA00  AC436128   SW V1, 24872(V0)
9D00CA04  24030008   ADDIU V1, ZERO, 8
9D00CA08  3C02BF88   LUI V0, -16504
9D00CA0C  AC436124   SW V1, 24868(V0)
64:                  }
9D00CA10  8FBF001C   LW RA, 28(SP)
9D00CA14  8FB10018   LW S1, 24(SP)
9D00CA18  8FB00014   LW S0, 20(SP)
9D00CA1C  03E00008   JR RA
9D00CA20  27BD0020   ADDIU SP, SP, 32
65:                  
66:                  
67:                  unsigned char sram_read_byte(unsigned addr){
9D00CA24  27BDFFD8   ADDIU SP, SP, -40
9D00CA28  AFBF0024   SW RA, 36(SP)
9D00CA2C  AFB30020   SW S3, 32(SP)
9D00CA30  AFB2001C   SW S2, 28(SP)
9D00CA34  AFB10018   SW S1, 24(SP)
9D00CA38  AFB00014   SW S0, 20(SP)
9D00CA3C  00802821   ADDU A1, A0, ZERO
68:                      unsigned char b;
69:                  
70:                      _sram_enable();
9D00CA40  3C13BF88   LUI S3, -16504
9D00CA44  24100002   ADDIU S0, ZERO, 2
9D00CA48  AE706124   SW S0, 24868(S3)
9D00CA4C  3C11BF88   LUI S1, -16504
9D00CA50  24120008   ADDIU S2, ZERO, 8
9D00CA54  AE326128   SW S2, 24872(S1)
71:                      sram_cmd(SRAM_READ,addr);
9D00CA58  0F40321A   JAL sram_cmd
9D00CA5C  24040003   ADDIU A0, ZERO, 3
72:                      b=writeSPI(0);
9D00CA60  0F405B0A   JAL writeSPI
9D00CA64  00002021   ADDU A0, ZERO, ZERO
73:                      _sram_disable();
9D00CA68  AE306128   SW S0, 24872(S1)
9D00CA6C  AE726124   SW S2, 24868(S3)
74:                      return b;
75:                  }
9D00CA70  8FBF0024   LW RA, 36(SP)
9D00CA74  8FB30020   LW S3, 32(SP)
9D00CA78  8FB2001C   LW S2, 28(SP)
9D00CA7C  8FB10018   LW S1, 24(SP)
9D00CA80  8FB00014   LW S0, 20(SP)
9D00CA84  03E00008   JR RA
9D00CA88  27BD0028   ADDIU SP, SP, 40
76:                  
77:                  void sram_write_byte(unsigned addr, unsigned char byte){
9D00CA8C  27BDFFD8   ADDIU SP, SP, -40
9D00CA90  AFBF0024   SW RA, 36(SP)
9D00CA94  AFB40020   SW S4, 32(SP)
9D00CA98  AFB3001C   SW S3, 28(SP)
9D00CA9C  AFB20018   SW S2, 24(SP)
9D00CAA0  AFB10014   SW S1, 20(SP)
9D00CAA4  AFB00010   SW S0, 16(SP)
9D00CAA8  00801021   ADDU V0, A0, ZERO
9D00CAAC  30B000FF   ANDI S0, A1, 255
78:                      _sram_enable();
9D00CAB0  3C14BF88   LUI S4, -16504
9D00CAB4  24110002   ADDIU S1, ZERO, 2
9D00CAB8  AE916124   SW S1, 24868(S4)
9D00CABC  3C12BF88   LUI S2, -16504
9D00CAC0  24130008   ADDIU S3, ZERO, 8
9D00CAC4  AE536128   SW S3, 24872(S2)
79:                      sram_cmd(SRAM_WRITE,addr);
9D00CAC8  24040002   ADDIU A0, ZERO, 2
9D00CACC  0F40321A   JAL sram_cmd
9D00CAD0  00402821   ADDU A1, V0, ZERO
80:                      writeSPI(byte);
9D00CAD4  0F405B0A   JAL writeSPI
9D00CAD8  02002021   ADDU A0, S0, ZERO
81:                      _sram_disable();
9D00CADC  AE516128   SW S1, 24872(S2)
9D00CAE0  AE936124   SW S3, 24868(S4)
82:                  }
9D00CAE4  8FBF0024   LW RA, 36(SP)
9D00CAE8  8FB40020   LW S4, 32(SP)
9D00CAEC  8FB3001C   LW S3, 28(SP)
9D00CAF0  8FB20018   LW S2, 24(SP)
9D00CAF4  8FB10014   LW S1, 20(SP)
9D00CAF8  8FB00010   LW S0, 16(SP)
9D00CAFC  03E00008   JR RA
9D00CB00  27BD0028   ADDIU SP, SP, 40
83:                  
84:                  void sram_read_block(unsigned addr, unsigned char buffer[], unsigned count){
9D00CB04  27BDFFE0   ADDIU SP, SP, -32
9D00CB08  AFBF001C   SW RA, 28(SP)
9D00CB0C  AFB20018   SW S2, 24(SP)
9D00CB10  AFB10014   SW S1, 20(SP)
9D00CB14  AFB00010   SW S0, 16(SP)
9D00CB18  00801021   ADDU V0, A0, ZERO
9D00CB1C  00A09021   ADDU S2, A1, ZERO
9D00CB20  00C08821   ADDU S1, A2, ZERO
9D00CB58  02501821   ADDU V1, S2, S0
85:                      unsigned i;
86:                      _sram_enable();
9D00CB24  24040002   ADDIU A0, ZERO, 2
9D00CB28  3C03BF88   LUI V1, -16504
9D00CB2C  AC646124   SW A0, 24868(V1)
9D00CB30  24040008   ADDIU A0, ZERO, 8
9D00CB34  3C03BF88   LUI V1, -16504
9D00CB38  AC646128   SW A0, 24872(V1)
87:                      sram_cmd(SRAM_READ,addr);
9D00CB3C  24040003   ADDIU A0, ZERO, 3
9D00CB40  0F40321A   JAL sram_cmd
9D00CB44  00402821   ADDU A1, V0, ZERO
88:                      for (i=0;i<count;i++) buffer[i]=writeSPI(0);
9D00CB48  12200007   BEQ S1, ZERO, 0x9D00CB68
9D00CB4C  00008021   ADDU S0, ZERO, ZERO
9D00CB50  0F405B0A   JAL writeSPI
9D00CB54  00002021   ADDU A0, ZERO, ZERO
9D00CB5C  26100001   ADDIU S0, S0, 1
9D00CB60  1611FFFB   BNE S0, S1, 0x9D00CB50
9D00CB64  A0620000   SB V0, 0(V1)
89:                      _sram_disable();
9D00CB68  24030002   ADDIU V1, ZERO, 2
9D00CB6C  3C02BF88   LUI V0, -16504
9D00CB70  AC436128   SW V1, 24872(V0)
9D00CB74  24030008   ADDIU V1, ZERO, 8
9D00CB78  3C02BF88   LUI V0, -16504
9D00CB7C  AC436124   SW V1, 24868(V0)
90:                  }
9D00CB80  8FBF001C   LW RA, 28(SP)
9D00CB84  8FB20018   LW S2, 24(SP)
9D00CB88  8FB10014   LW S1, 20(SP)
9D00CB8C  8FB00010   LW S0, 16(SP)
9D00CB90  03E00008   JR RA
9D00CB94  27BD0020   ADDIU SP, SP, 32
91:                  
92:                  void sram_write_block(unsigned addr, const char buffer[],unsigned count){
9D00CB98  27BDFFE0   ADDIU SP, SP, -32
9D00CB9C  AFBF001C   SW RA, 28(SP)
9D00CBA0  AFB20018   SW S2, 24(SP)
9D00CBA4  AFB10014   SW S1, 20(SP)
9D00CBA8  AFB00010   SW S0, 16(SP)
9D00CBAC  00801021   ADDU V0, A0, ZERO
9D00CBB0  00A09021   ADDU S2, A1, ZERO
9D00CBB4  00C08821   ADDU S1, A2, ZERO
9D00CBE4  02501021   ADDU V0, S2, S0
93:                      unsigned i;
94:                      _sram_enable();
9D00CBB8  24040002   ADDIU A0, ZERO, 2
9D00CBBC  3C03BF88   LUI V1, -16504
9D00CBC0  AC646124   SW A0, 24868(V1)
9D00CBC4  24040008   ADDIU A0, ZERO, 8
9D00CBC8  3C03BF88   LUI V1, -16504
9D00CBCC  AC646128   SW A0, 24872(V1)
95:                      sram_cmd(SRAM_WRITE,addr);
9D00CBD0  24040002   ADDIU A0, ZERO, 2
9D00CBD4  0F40321A   JAL sram_cmd
9D00CBD8  00402821   ADDU A1, V0, ZERO
96:                      for (i=0;i<count;i++) writeSPI(buffer[i]);
9D00CBDC  12200007   BEQ S1, ZERO, 0x9D00CBFC
9D00CBE0  00008021   ADDU S0, ZERO, ZERO
9D00CBE8  0F405B0A   JAL writeSPI
9D00CBEC  90440000   LBU A0, 0(V0)
9D00CBF0  26100001   ADDIU S0, S0, 1
9D00CBF4  1611FFFC   BNE S0, S1, 0x9D00CBE8
9D00CBF8  02501021   ADDU V0, S2, S0
97:                      _sram_disable();
9D00CBFC  24030002   ADDIU V1, ZERO, 2
9D00CC00  3C02BF88   LUI V0, -16504
9D00CC04  AC436128   SW V1, 24872(V0)
9D00CC08  24030008   ADDIU V1, ZERO, 8
9D00CC0C  3C02BF88   LUI V0, -16504
9D00CC10  AC436124   SW V1, 24868(V0)
98:                  }
9D00CC14  8FBF001C   LW RA, 28(SP)
9D00CC18  8FB20018   LW S2, 24(SP)
9D00CC1C  8FB10014   LW S1, 20(SP)
9D00CC20  8FB00010   LW S0, 16(SP)
9D00CC24  03E00008   JR RA
9D00CC28  27BD0020   ADDIU SP, SP, 32
99:                  
100:                 void sram_write_string(unsigned addr, const char *str){
9D00CC2C  27BDFFE8   ADDIU SP, SP, -24
9D00CC30  AFBF0014   SW RA, 20(SP)
9D00CC34  AFB00010   SW S0, 16(SP)
9D00CC38  00801021   ADDU V0, A0, ZERO
9D00CC3C  00A08021   ADDU S0, A1, ZERO
101:                     _sram_enable();
9D00CC40  24040002   ADDIU A0, ZERO, 2
9D00CC44  3C03BF88   LUI V1, -16504
9D00CC48  AC646124   SW A0, 24868(V1)
9D00CC4C  24040008   ADDIU A0, ZERO, 8
9D00CC50  3C03BF88   LUI V1, -16504
9D00CC54  AC646128   SW A0, 24872(V1)
102:                     sram_cmd(SRAM_WRITE,addr);
9D00CC58  24040002   ADDIU A0, ZERO, 2
9D00CC5C  0F40321A   JAL sram_cmd
9D00CC60  00402821   ADDU A1, V0, ZERO
103:                     while (*str) writeSPI(*str++);
9D00CC64  82040000   LB A0, 0(S0)
9D00CC68  10800006   BEQ A0, ZERO, 0x9D00CC84
9D00CC6C  26100001   ADDIU S0, S0, 1
9D00CC70  0F405B0A   JAL writeSPI
9D00CC74  308400FF   ANDI A0, A0, 255
9D00CC78  82040000   LB A0, 0(S0)
9D00CC7C  1480FFFC   BNE A0, ZERO, 0x9D00CC70
9D00CC80  26100001   ADDIU S0, S0, 1
104:                     writeSPI(0);
9D00CC84  0F405B0A   JAL writeSPI
9D00CC88  00002021   ADDU A0, ZERO, ZERO
105:                     _sram_disable();
9D00CC8C  24030002   ADDIU V1, ZERO, 2
9D00CC90  3C02BF88   LUI V0, -16504
9D00CC94  AC436128   SW V1, 24872(V0)
9D00CC98  24030008   ADDIU V1, ZERO, 8
9D00CC9C  3C02BF88   LUI V0, -16504
9D00CCA0  AC436124   SW V1, 24868(V0)
106:                 }
9D00CCA4  8FBF0014   LW RA, 20(SP)
9D00CCA8  8FB00010   LW S0, 16(SP)
9D00CCAC  03E00008   JR RA
9D00CCB0  27BD0018   ADDIU SP, SP, 24
107:                 
108:                 int sram_read_string(unsigned addr, char *buffer,unsigned size){
9D00CCB4  27BDFFD8   ADDIU SP, SP, -40
9D00CCB8  AFBF0024   SW RA, 36(SP)
9D00CCBC  AFB40020   SW S4, 32(SP)
9D00CCC0  AFB3001C   SW S3, 28(SP)
9D00CCC4  AFB20018   SW S2, 24(SP)
9D00CCC8  AFB10014   SW S1, 20(SP)
9D00CCCC  AFB00010   SW S0, 16(SP)
9D00CCD0  00801021   ADDU V0, A0, ZERO
9D00CCD4  00A09021   ADDU S2, A1, ZERO
9D00CCD8  00C0A021   ADDU S4, A2, ZERO
109:                     int i=0;
9D00CD0C  0B403348   J 0x9D00CD20
9D00CD10  00008021   ADDU S0, ZERO, ZERO
9D00CD9C  0B403356   J 0x9D00CD58
9D00CDA0  00008021   ADDU S0, ZERO, ZERO
110:                 
111:                     _sram_enable();
9D00CCDC  24040002   ADDIU A0, ZERO, 2
9D00CCE0  3C03BF88   LUI V1, -16504
9D00CCE4  AC646124   SW A0, 24868(V1)
9D00CCE8  24040008   ADDIU A0, ZERO, 8
9D00CCEC  3C03BF88   LUI V1, -16504
9D00CCF0  AC646128   SW A0, 24872(V1)
112:                     sram_cmd(SRAM_READ,addr);
9D00CCF4  24040003   ADDIU A0, ZERO, 3
9D00CCF8  0F40321A   JAL sram_cmd
9D00CCFC  00402821   ADDU A1, V0, ZERO
113:                     while (i<size && (buffer[i]=writeSPI(0)))i++;
9D00CD00  12800020   BEQ S4, ZERO, 0x9D00CD84
9D00CD04  02809821   ADDU S3, S4, ZERO
9D00CD08  00008821   ADDU S1, ZERO, ZERO
9D00CD14  26100001   ADDIU S0, S0, 1
9D00CD18  12130007   BEQ S0, S3, 0x9D00CD38
9D00CD1C  02008821   ADDU S1, S0, ZERO
9D00CD20  0F405B0A   JAL writeSPI
9D00CD24  00002021   ADDU A0, ZERO, ZERO
9D00CD28  7C021420   SEB V0, V0
9D00CD2C  02511821   ADDU V1, S2, S1
9D00CD30  1440FFF8   BNE V0, ZERO, 0x9D00CD14
9D00CD34  A0620000   SB V0, 0(V1)
114:                     _sram_disable();
9D00CD38  24030002   ADDIU V1, ZERO, 2
9D00CD3C  3C02BF88   LUI V0, -16504
9D00CD40  AC436128   SW V1, 24872(V0)
9D00CD44  24030008   ADDIU V1, ZERO, 8
9D00CD48  3C02BF88   LUI V0, -16504
9D00CD4C  AC436124   SW V1, 24868(V0)
9D00CD84  24030002   ADDIU V1, ZERO, 2
9D00CD88  3C02BF88   LUI V0, -16504
9D00CD8C  AC436128   SW V1, 24872(V0)
9D00CD90  24030008   ADDIU V1, ZERO, 8
9D00CD94  3C02BF88   LUI V0, -16504
9D00CD98  AC436124   SW V1, 24868(V0)
115:                     if (i==size)buffer[i-1]=0;
9D00CD50  16910004   BNE S4, S1, 0x9D00CD64
9D00CD54  02001021   ADDU V0, S0, ZERO
9D00CD58  02549021   ADDU S2, S2, S4
9D00CD5C  A240FFFF   SB ZERO, -1(S2)
116:                     return i;
117:                 }
9D00CD60  02001021   ADDU V0, S0, ZERO
9D00CD64  8FBF0024   LW RA, 36(SP)
9D00CD68  8FB40020   LW S4, 32(SP)
9D00CD6C  8FB3001C   LW S3, 28(SP)
9D00CD70  8FB20018   LW S2, 24(SP)
9D00CD74  8FB10014   LW S1, 20(SP)
9D00CD78  8FB00010   LW S0, 16(SP)
9D00CD7C  03E00008   JR RA
9D00CD80  27BD0028   ADDIU SP, SP, 40
118:                 
119:                 
---  /home/jacques/MPLABXProjects/vpc-32/hardware/sound/sound.c  ----------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   sound.c
20:                   * Author: Jacques Deschênes
21:                   *
22:                   * Created on 13 septembre 2013, 20:42
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "../HardwareProfile.h"
27:                  #include "sound.h"
28:                  
29:                  
30:                  
31:                  volatile unsigned char fSound=0; // indicateurs booléins
32:                  volatile unsigned int duration;
33:                  volatile unsigned int *tones_list;
34:                  
35:                  
36:                  
37:                  void tone(unsigned int freq, // fréquence en hertz
38:                            unsigned int msec){ // durée en  millisecondes
39:                      //configuration PWM sur OC1 puor délais vidéo, utilisation TIMER2
40:                      OC3CONbits.OCM = 5; //mode pwm
9D010F38  3C02BF80   LUI V0, -16512
9D010F3C  8C433400   LW V1, 13312(V0)
9D010F40  24060005   ADDIU A2, ZERO, 5
9D010F44  7CC31004   INS V1, A2, 0, 3
9D010F48  AC433400   SW V1, 13312(V0)
41:                      OC3CONbits.OCTSEL=1; // timer 3
9D010F4C  8C433400   LW V1, 13312(V0)
9D010F50  24060001   ADDIU A2, ZERO, 1
9D010F54  7CC318C4   INS V1, A2, 3, 1
9D010F58  AC433400   SW V1, 13312(V0)
42:                      OC3RS=0;
9D010F5C  3C03BF80   LUI V1, -16512
9D010F60  AC603420   SW ZERO, 13344(V1)
43:                      T3CON=0;
9D010F64  3C03BF80   LUI V1, -16512
9D010F68  AC600A00   SW ZERO, 2560(V1)
44:                      T3CONbits.TCKPS=3;
9D010F6C  3C03BF80   LUI V1, -16512
9D010F70  8C670A00   LW A3, 2560(V1)
9D010F74  24080003   ADDIU T0, ZERO, 3
9D010F78  7D073104   INS A3, T0, 4, 3
9D010F7C  AC670A00   SW A3, 2560(V1)
45:                      PR3=(SYSCLK/8/freq)-1; // rapport cyclique 50%
9D010F80  3C07004C   LUI A3, 76
9D010F84  24E74B40   ADDIU A3, A3, 19264
9D010F88  00E4001B   DIVU A3, A0
9D010F8C  008001F4   TEQ A0, ZERO
9D010F90  00004012   MFLO T0, 0
9D010F94  2507FFFF   ADDIU A3, T0, -1
9D010F98  3C08BF80   LUI T0, -16512
9D010F9C  AD070A20   SW A3, 2592(T0)
46:                      OC3R=SYSCLK/16/freq;
9D010FA0  3C070026   LUI A3, 38
9D010FA4  24E725A0   ADDIU A3, A3, 9632
9D010FA8  00E4001B   DIVU A3, A0
9D010FAC  008001F4   TEQ A0, ZERO
9D010FB0  00003812   MFLO A3, 0
9D010FB4  3C08BF80   LUI T0, -16512
9D010FB8  AD073410   SW A3, 13328(T0)
47:                      duration=msec;
9D010FBC  AF8580C4   SW A1, -32572(GP)
48:                      fSound |=TONE_ON;
9D010FC0  9384803F   LBU A0, -32705(GP)
9D010FC4  308400FF   ANDI A0, A0, 255
9D010FC8  34840001   ORI A0, A0, 1
9D010FCC  A384803F   SB A0, -32705(GP)
49:                      mTone_on();
9D010FD0  8C443400   LW A0, 13312(V0)
9D010FD4  7CC47BC4   INS A0, A2, 15, 1
9D010FD8  AC443400   SW A0, 13312(V0)
50:                      T3CONbits.ON=1;
9D010FDC  8C620A00   LW V0, 2560(V1)
9D010FE0  7CC27BC4   INS V0, A2, 15, 1
9D010FE4  AC620A00   SW V0, 2560(V1)
51:                  } //tone();
9D010FE8  03E00008   JR RA
9D010FEC  00000000   NOP
52:                  
53:                  // joue une mélodie en arrière plan
54:                  void tune(const unsigned int *buffer){
9D010FF0  27BDFFE8   ADDIU SP, SP, -24
9D010FF4  AFBF0014   SW RA, 20(SP)
55:                      tones_list=(unsigned *)buffer;
9D010FF8  AF8480C0   SW A0, -32576(GP)
56:                      if (*tones_list && *(tones_list+1)){
9D010FFC  8C820000   LW V0, 0(A0)
9D011000  10400021   BEQ V0, ZERO, 0x9D011088
9D011004  24830004   ADDIU V1, A0, 4
9D011008  8C820004   LW V0, 4(A0)
9D01100C  1040001F   BEQ V0, ZERO, 0x9D01108C
9D011010  8FBF0014   LW RA, 20(SP)
57:                          fSound |= PLAY_TUNE;
9D011014  9382803F   LBU V0, -32705(GP)
9D011018  304200FF   ANDI V0, V0, 255
9D01101C  34420002   ORI V0, V0, 2
9D011020  A382803F   SB V0, -32705(GP)
58:                          IPC3bits.T3IP=2;
9D011024  3C02BF88   LUI V0, -16504
9D011028  8C4510C0   LW A1, 4288(V0)
9D01102C  24060002   ADDIU A2, ZERO, 2
9D011030  7CC52084   INS A1, A2, 2, 3
9D011034  AC4510C0   SW A1, 4288(V0)
59:                          IPC3bits.T3IS=3;
9D011038  8C4510C0   LW A1, 4288(V0)
9D01103C  24060003   ADDIU A2, ZERO, 3
9D011040  7CC50804   INS A1, A2, 0, 2
9D011044  AC4510C0   SW A1, 4288(V0)
60:                          IFS0bits.T3IF=0;
9D011048  3C02BF88   LUI V0, -16504
9D01104C  8C451030   LW A1, 4144(V0)
9D011050  7C057384   INS A1, ZERO, 14, 1
9D011054  AC451030   SW A1, 4144(V0)
61:                          IEC0bits.T3IE=1;
9D011058  3C02BF88   LUI V0, -16504
9D01105C  8C451060   LW A1, 4192(V0)
9D011060  24060001   ADDIU A2, ZERO, 1
9D011064  7CC57384   INS A1, A2, 14, 1
9D011068  AC451060   SW A1, 4192(V0)
62:                          tone(*tones_list++,*tones_list++);
9D01106C  8C820000   LW V0, 0(A0)
9D011070  AF8380C0   SW V1, -32576(GP)
9D011074  8C850004   LW A1, 4(A0)
9D011078  24830008   ADDIU V1, A0, 8
9D01107C  AF8380C0   SW V1, -32576(GP)
9D011080  0F4043CE   JAL tone
9D011084  00402021   ADDU A0, V0, ZERO
63:                      }
64:                  }//tune()
9D011088  8FBF0014   LW RA, 20(SP)
9D01108C  03E00008   JR RA
9D011090  27BD0018   ADDIU SP, SP, 24
65:                  
66:                  
67:                  
68:                  void __ISR(_TIMER_3_VECTOR, IPL2SOFT)  T3Handler(void){
9D011094  415DE800   RDPGPR SP, SP
9D011098  401A7000   MFC0 K0, EPC
9D01109C  401B6000   MFC0 K1, Status
9D0110A0  27BDFF90   ADDIU SP, SP, -112
9D0110A4  AFBA006C   SW K0, 108(SP)
9D0110A8  401A6002   MFC0 K0, SRSCtl
9D0110AC  AFBB0068   SW K1, 104(SP)
9D0110B0  AFBA0064   SW K0, 100(SP)
9D0110B4  7C1B7844   INS K1, ZERO, 1, 15
9D0110B8  377B0800   ORI K1, K1, 2048
9D0110BC  409B6000   MTC0 K1, Status
9D0110C0  AFBF0054   SW RA, 84(SP)
9D0110C4  AFB90050   SW T9, 80(SP)
9D0110C8  AFB8004C   SW T8, 76(SP)
9D0110CC  AFAF0048   SW T7, 72(SP)
9D0110D0  AFAE0044   SW T6, 68(SP)
9D0110D4  AFAD0040   SW T5, 64(SP)
9D0110D8  AFAC003C   SW T4, 60(SP)
9D0110DC  AFAB0038   SW T3, 56(SP)
9D0110E0  AFAA0034   SW T2, 52(SP)
9D0110E4  AFA90030   SW T1, 48(SP)
9D0110E8  AFA8002C   SW T0, 44(SP)
9D0110EC  AFA70028   SW A3, 40(SP)
9D0110F0  AFA60024   SW A2, 36(SP)
9D0110F4  AFA50020   SW A1, 32(SP)
9D0110F8  AFA4001C   SW A0, 28(SP)
9D0110FC  AFA30018   SW V1, 24(SP)
9D011100  AFA20014   SW V0, 20(SP)
9D011104  AFA10010   SW AT, 16(SP)
9D011108  00001012   MFLO V0, 0
9D01110C  AFA2005C   SW V0, 92(SP)
9D011110  00001810   MFHI V1, 0
9D011114  AFA30058   SW V1, 88(SP)
69:                      unsigned int f,d;
70:                         mT3ClearIntFlag();
9D011118  24034000   ADDIU V1, ZERO, 16384
9D01111C  3C02BF88   LUI V0, -16504
9D011120  AC431034   SW V1, 4148(V0)
71:                         if (fSound==PLAY_TUNE){
9D011124  9383803F   LBU V1, -32705(GP)
9D011128  306300FF   ANDI V1, V1, 255
9D01112C  24020002   ADDIU V0, ZERO, 2
9D011130  1462001F   BNE V1, V0, 0x9D0111B0
9D011134  8F8280C0   LW V0, -32576(GP)
72:                             f=*tones_list++;
9D011138  8C440000   LW A0, 0(V0)
9D01113C  24430004   ADDIU V1, V0, 4
9D011140  AF8380C0   SW V1, -32576(GP)
73:                             d=*tones_list++;
9D011144  8C450004   LW A1, 4(V0)
9D011148  24430008   ADDIU V1, V0, 8
74:                             if (d){
9D01114C  10A0000F   BEQ A1, ZERO, 0x9D01118C
9D011150  AF8380C0   SW V1, -32576(GP)
75:                                  if (f){
9D011154  10800005   BEQ A0, ZERO, 0x9D01116C
9D011158  00000000   NOP
76:                                      tone(f,d);
9D01115C  0F4043CE   JAL tone
9D011160  00000000   NOP
9D011164  0B40446C   J 0x9D0111B0
9D011168  00000000   NOP
77:                                  }else{
78:                                      duration=(*tones_list);
9D01116C  8C420008   LW V0, 8(V0)
9D011170  AF8280C4   SW V0, -32572(GP)
79:                                      fSound |= TONE_ON;
9D011174  9382803F   LBU V0, -32705(GP)
9D011178  304200FF   ANDI V0, V0, 255
9D01117C  34420001   ORI V0, V0, 1
9D011180  A382803F   SB V0, -32705(GP)
9D011184  0B40446C   J 0x9D0111B0
9D011188  00000000   NOP
80:                                  }
81:                             }else{
82:                                 fSound=0;
9D01118C  A380803F   SB ZERO, -32705(GP)
83:                                 IEC0bits.T3IE=0;
9D011190  3C02BF88   LUI V0, -16504
9D011194  8C431060   LW V1, 4192(V0)
9D011198  7C037384   INS V1, ZERO, 14, 1
9D01119C  AC431060   SW V1, 4192(V0)
84:                                 T3CONbits.ON=0;
9D0111A0  3C02BF80   LUI V0, -16512
9D0111A4  8C430A00   LW V1, 2560(V0)
9D0111A8  7C037BC4   INS V1, ZERO, 15, 1
9D0111AC  AC430A00   SW V1, 2560(V0)
85:                             } // if 
86:                         }//if 
87:                  }// T3Handler
9D0111B0  8FA2005C   LW V0, 92(SP)
9D0111B4  00400013   MTLO V0, 0
9D0111B8  8FA30058   LW V1, 88(SP)
9D0111BC  00600011   MTHI V1, 0
9D0111C0  8FBF0054   LW RA, 84(SP)
9D0111C4  8FB90050   LW T9, 80(SP)
9D0111C8  8FB8004C   LW T8, 76(SP)
9D0111CC  8FAF0048   LW T7, 72(SP)
9D0111D0  8FAE0044   LW T6, 68(SP)
9D0111D4  8FAD0040   LW T5, 64(SP)
9D0111D8  8FAC003C   LW T4, 60(SP)
9D0111DC  8FAB0038   LW T3, 56(SP)
9D0111E0  8FAA0034   LW T2, 52(SP)
9D0111E4  8FA90030   LW T1, 48(SP)
9D0111E8  8FA8002C   LW T0, 44(SP)
9D0111EC  8FA70028   LW A3, 40(SP)
9D0111F0  8FA60024   LW A2, 36(SP)
9D0111F4  8FA50020   LW A1, 32(SP)
9D0111F8  8FA4001C   LW A0, 28(SP)
9D0111FC  8FA30018   LW V1, 24(SP)
9D011200  8FA20014   LW V0, 20(SP)
9D011204  8FA10010   LW AT, 16(SP)
9D011208  41606000   DI ZERO
9D01120C  000000C0   EHB
9D011210  8FBA006C   LW K0, 108(SP)
9D011214  8FBB0068   LW K1, 104(SP)
9D011218  409A7000   MTC0 K0, EPC
9D01121C  8FBA0064   LW K0, 100(SP)
9D011220  27BD0070   ADDIU SP, SP, 112
9D011224  409A6002   MTC0 K0, SRSCtl
9D011228  41DDE800   WRPGPR SP, SP
9D01122C  409B6000   MTC0 K1, Status
9D011230  42000018   ERET
---  /home/jacques/MPLABXProjects/vpc-32/hardware/serial_comm/serial_comm.c  ----------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   uart.h
20:                   * Author: Jacques Deschênes
21:                   * Description: fonctions de bas niveau pour communication UART avec le PC
22:                   * Created on 17 avril 2013, 14:48
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "serial_comm.h"
27:                  #include "../HardwareProfile.h"
28:                  
29:                  static char unget;
30:                  
31:                  void UartInit(UART_MODULE channel, int baudrate, UART_LINE_CONTROL_MODE LineCtrl){
9D00FF60  27BDFFE0   ADDIU SP, SP, -32
9D00FF64  AFBF001C   SW RA, 28(SP)
9D00FF68  AFB20018   SW S2, 24(SP)
9D00FF6C  AFB10014   SW S1, 20(SP)
9D00FF70  AFB00010   SW S0, 16(SP)
9D00FF74  00808021   ADDU S0, A0, ZERO
9D00FF78  00A09021   ADDU S2, A1, ZERO
9D00FF7C  00C08821   ADDU S1, A2, ZERO
32:                  /*initialise le périphérique UART*/
33:                     // Configure UART, information dans uart.h
34:                     UARTConfigure(channel, UART_ENABLE_PINS_TX_RX_ONLY); // pas de contrôle de flux matériel.
9D00FF80  0F405D8B   JAL UARTConfigure
9D00FF84  00002821   ADDU A1, ZERO, ZERO
35:                     UARTSetLineControl(channel, LineCtrl);
9D00FF88  02002021   ADDU A0, S0, ZERO
9D00FF8C  0F405EA2   JAL UARTSetLineControl
9D00FF90  02202821   ADDU A1, S1, ZERO
36:                     UARTSetDataRate(channel, mGetPeripheralClock(), baudrate);
9D00FF94  02002021   ADDU A0, S0, ZERO
9D00FF98  3C050262   LUI A1, 610
9D00FF9C  24A55A00   ADDIU A1, A1, 23040
9D00FFA0  0F405A69   JAL UARTSetDataRate
9D00FFA4  02403021   ADDU A2, S2, ZERO
37:                     // activation du périphérique
38:                     UARTEnable(channel, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D00FFA8  02002021   ADDU A0, S0, ZERO
9D00FFAC  0F405B15   JAL UARTEnable
9D00FFB0  24050087   ADDIU A1, ZERO, 135
39:                     unget=-1;
9D00FFB4  2402FFFF   ADDIU V0, ZERO, -1
9D00FFB8  A382803E   SB V0, -32706(GP)
40:                  };
9D00FFBC  8FBF001C   LW RA, 28(SP)
9D00FFC0  8FB20018   LW S2, 24(SP)
9D00FFC4  8FB10014   LW S1, 20(SP)
9D00FFC8  8FB00010   LW S0, 16(SP)
9D00FFCC  03E00008   JR RA
9D00FFD0  27BD0020   ADDIU SP, SP, 32
41:                  
42:                  char UartGetch(UART_MODULE channel){
43:                  /*lecture d'un caractère retourne 0 si aucun disponible*/
44:                      char ch;
45:                      if (!unget==-1) {
46:                          ch=unget;
47:                          unget=-1;
48:                          return ch;
49:                      }else{
50:                          if (UARTReceivedDataIsAvailable (channel)){
9D00FFF0  10800003   BEQ A0, ZERO, 0x9D010000
51:                                 return UARTGetDataByte(channel);
9D00FFFC  7C021420   SEB V0, V0
52:                          }else{
53:                              return 0;
54:                          }
55:                      }
56:                  };
9D010000  03E00008   JR RA
57:                  
58:                  void UartPutch(UART_MODULE channel, char c){
9D010008  7C052C20   SEB A1, A1
59:                  /*Envoie d'un caractère*/
60:                      while(!UARTTransmitterIsReady(channel));
9D010028  1440FFFD   BNE V0, ZERO, 0x9D010020
9D01002C  00000000   NOP
61:                        UARTSendDataByte(channel, c);
62:                  };
9D010038  03E00008   JR RA
9D01003C  00000000   NOP
63:                  
64:                  char UartWaitch(UART_MODULE channel, int delay){
9D010040  27BDFFE0   ADDIU SP, SP, -32
9D010044  AFBF001C   SW RA, 28(SP)
9D010048  AFB10018   SW S1, 24(SP)
9D01004C  AFB00014   SW S0, 20(SP)
9D010050  00808021   ADDU S0, A0, ZERO
65:                  /*attend un caractère pour un temps spécifié par delay
66:                  *retourne 0 si aucun reçu avant expiration du délais
67:                  */
68:                      int t;
69:                      char ch;
70:                      if (!unget==-1){
71:                          ch=unget;
72:                          unget=-1;
73:                          return unget;
74:                      }
75:                      if (!delay) while (1) if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D010054  14A0000D   BNE A1, ZERO, 0x9D01008C
9D010058  00A08821   ADDU S1, A1, ZERO
9D010078  1040FFFD   BEQ V0, ZERO, 0x9D010070
9D01007C  00000000   NOP
9D010084  0B404035   J 0x9D0100D4
9D010088  7C021420   SEB V0, V0
76:                      t=ticks()+delay;
9D01008C  0F403E85   JAL ticks
9D010090  00108080   SLL S0, S0, 2
77:                      while (ticks()<delay){
9D01009C  0B404030   J 0x9D0100C0
9D0100A0  02028021   ADDU S0, S0, V0
9D0100C0  0F403E85   JAL ticks
9D0100C4  00000000   NOP
9D0100C8  0051102B   SLTU V0, V0, S1
9D0100CC  5440FFF5   BNEL V0, ZERO, 0x9D0100A4
9D0100D0  8E020000   LW V0, 0(S0)
78:                         if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D0100AC  10600004   BEQ V1, ZERO, 0x9D0100C0
9D0100B0  00000000   NOP
9D0100B8  0B404035   J 0x9D0100D4
9D0100BC  7C021420   SEB V0, V0
79:                      }
80:                      return 0;
81:                  }
9D0100D4  8FBF001C   LW RA, 28(SP)
9D0100D8  8FB10018   LW S1, 24(SP)
9D0100DC  8FB00014   LW S0, 20(SP)
9D0100E0  03E00008   JR RA
9D0100E4  27BD0020   ADDIU SP, SP, 32
82:                  
83:                  void UartPrint(UART_MODULE channel, const char* str){
84:                  /* envoie la chaine de caractère str via le UART */
85:                     while(*str != (char)0)
9D0100E8  80A60000   LB A2, 0(A1)
9D0100EC  10C0000F   BEQ A2, ZERO, 0x9D01012C
9D0100F0  00041880   SLL V1, A0, 2
9D010120  80A60000   LB A2, 0(A1)
9D010124  14C0FFF7   BNE A2, ZERO, 0x9D010104
9D010128  00000000   NOP
86:                     {
87:                        while(!UARTTransmitterIsReady(channel));
9D01010C  1440FFFD   BNE V0, ZERO, 0x9D010104
9D010110  00000000   NOP
88:                        UARTSendDataByte(channel, *str++);
9D010114  24A50001   ADDIU A1, A1, 1
89:                     }
90:                     while(!UARTTransmissionHasCompleted(channel));
9D010148  1040FFFD   BEQ V0, ZERO, 0x9D010140
9D01014C  00000000   NOP
91:                  };
9D010150  03E00008   JR RA
9D010154  00000000   NOP
92:                  
93:                  int UartReadln(UART_MODULE channel, char *buffer, int buff_len){
9D010158  27BDFFD0   ADDIU SP, SP, -48
9D01015C  AFBF002C   SW RA, 44(SP)
9D010160  AFB50028   SW S5, 40(SP)
9D010164  AFB40024   SW S4, 36(SP)
9D010168  AFB30020   SW S3, 32(SP)
9D01016C  AFB2001C   SW S2, 28(SP)
9D010170  AFB10018   SW S1, 24(SP)
9D010174  AFB00014   SW S0, 20(SP)
9D010178  00809821   ADDU S3, A0, ZERO
9D01017C  00A0A021   ADDU S4, A1, ZERO
9D010180  00C08821   ADDU S1, A2, ZERO
94:                  /* lecture d'une chaine se terminant par '\r'
95:                   *  complète la chaine avec un zéro
96:                   *  retourne le nombre de caractère dans le buffer.
97:                   */
98:                      int count=0;
9D010184  00008021   ADDU S0, ZERO, ZERO
99:                      char c;
100:                     if (!unget==-1){
101:                         c=unget;
102:                         unget=-1;
103:                         *buffer++=c;
104:                         if (c==CR) return;
105:                     }
106:                     while (count < (buff_len-1)){
9D010198  0B404085   J 0x9D010214
9D01019C  3C159D01   LUI S5, -25343
9D0101FC  0B404086   J 0x9D010218
9D010200  2622FFFF   ADDIU V0, S1, -1
9D010214  2622FFFF   ADDIU V0, S1, -1
9D010218  0202102A   SLT V0, S0, V0
9D01021C  5440FFE0   BNEL V0, ZERO, 0x9D0101A0
9D010220  8E420000   LW V0, 0(S2)
107:                         if (UARTReceivedDataIsAvailable(channel)){
9D0101A8  5060001B   BEQL V1, ZERO, 0x9D010218
9D0101AC  2622FFFF   ADDIU V0, S1, -1
108:                             c = UARTGetDataByte(channel);
9D0101B4  7C052C20   SEB A1, A1
109:                             if (c==CR){UartPutch(channel,'\r'); break;}
9D0101B8  2402000D   ADDIU V0, ZERO, 13
9D0101BC  14A20006   BNE A1, V0, 0x9D0101D8
9D0101C0  24020008   ADDIU V0, ZERO, 8
9D0101C4  02602021   ADDU A0, S3, ZERO
9D0101C8  0F404002   JAL UartPutch
9D0101CC  2405000D   ADDIU A1, ZERO, 13
9D0101D0  0B404089   J 0x9D010224
9D0101D4  00000000   NOP
110:                             if (c==BS){
9D0101D8  54A2000A   BNEL A1, V0, 0x9D010204
9D0101DC  A2850000   SB A1, 0(S4)
111:                                 if (count){
9D0101E0  5200000D   BEQL S0, ZERO, 0x9D010218
9D0101E4  2622FFFF   ADDIU V0, S1, -1
112:                                     buffer--;
9D0101E8  2694FFFF   ADDIU S4, S4, -1
113:                                     count--;
9D0101EC  2610FFFF   ADDIU S0, S0, -1
114:                                     UartPrint(channel,"\b \b");
9D0101F0  02602021   ADDU A0, S3, ZERO
9D0101F4  0F40403A   JAL UartPrint
9D0101F8  26A55E74   ADDIU A1, S5, 24180
115:                                 }
116:                             }else{
117:                                 *buffer++=c;
9D010204  26940001   ADDIU S4, S4, 1
118:                                 count++;
9D010208  26100001   ADDIU S0, S0, 1
119:                                 UartPutch(channel,c);
9D01020C  0F404002   JAL UartPutch
9D010210  02602021   ADDU A0, S3, ZERO
120:                             }
121:                             
122:                         }
123:                     }
124:                     if (count) *buffer = (char)0;
9D010224  56000001   BNEL S0, ZERO, 0x9D01022C
9D010228  A2800000   SB ZERO, 0(S4)
125:                     UartPutch(channel,'\r');
9D01022C  02602021   ADDU A0, S3, ZERO
9D010230  0F404002   JAL UartPutch
9D010234  2405000D   ADDIU A1, ZERO, 13
126:                     return count;
127:                 }
9D010238  02001021   ADDU V0, S0, ZERO
9D01023C  8FBF002C   LW RA, 44(SP)
9D010240  8FB50028   LW S5, 40(SP)
9D010244  8FB40024   LW S4, 36(SP)
9D010248  8FB30020   LW S3, 32(SP)
9D01024C  8FB2001C   LW S2, 28(SP)
9D010250  8FB10018   LW S1, 24(SP)
9D010254  8FB00014   LW S0, 20(SP)
9D010258  03E00008   JR RA
9D01025C  27BD0030   ADDIU SP, SP, 48
128:                 
129:                 int UartReceivedBreak(UART_MODULE channel){
130:                    char ch;
131:                    if (unget==-1 && UARTReceivedDataIsAvailable(channel)) {
9D010260  8385803E   LB A1, -32706(GP)
9D010264  2403FFFF   ADDIU V1, ZERO, -1
9D010268  14A30011   BNE A1, V1, 0x9D0102B0
9D01026C  00001021   ADDU V0, ZERO, ZERO
9D01028C  10800008   BEQ A0, ZERO, 0x9D0102B0
9D010290  00001021   ADDU V0, ZERO, ZERO
132:                        ch=UARTGetDataByte(channel);
9D010298  7C031C20   SEB V1, V1
133:                        if (ch==ESC) return 1; else unget=ch;
9D01029C  2404001B   ADDIU A0, ZERO, 27
9D0102A0  10640003   BEQ V1, A0, 0x9D0102B0
9D0102A4  24020001   ADDIU V0, ZERO, 1
9D0102A8  A383803E   SB V1, -32706(GP)
134:                    }
135:                    return 0;
9D0102AC  00001021   ADDU V0, ZERO, ZERO
136:                 }
9D0102B0  03E00008   JR RA
9D0102B4  00000000   NOP
137:                 
---  /home/jacques/MPLABXProjects/vpc-32/hardware/ps2_kbd/keyboard.c  -----------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * Name: keyboard.c
20:                   * Author: Jacques Deschênes
21:                   * Description:  interface avec clavier PS/2
22:                   * Date: 2013-08-26
23:                   */
24:                  
25:                  #include <plib.h>
26:                  #include "../HardwareProfile.h"
27:                  #include "keyboard.h"
28:                  #include "QWERTY.h"
29:                  
30:                  #define KBD_CLK 1  // SET/CLR bit
31:                  #define KBD_DAT 2  // SET/CLR bit
32:                  
33:                  #define _wait_key() while (head==tail)
34:                  
35:                  
36:                  static  unsigned char kbd_queue[32]; // file circulaire pour les codes reçus du clavier.
37:                  volatile  static unsigned char head=0, tail=0; // tête et queue de la file
38:                  volatile  static unsigned char  in_byte=0, bit_cnt=0, parity=0;
39:                  volatile unsigned char rx_flags=0, kbd_leds=0;
40:                  volatile unsigned short key_state; // état des touches d'alteration: shift, ctrl, alt,etc.
41:                  
42:                  #define FN_COUNT 32
43:                  const short fn_keys[FN_COUNT]={CAPS_LOCK,SCROLL_LOCK,NUM_LOCK,LSHIFT,RSHIFT,LCTRL,
44:                  RCTRL,LALT,RALT,F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,PRN,PAUSE,UP_ARROW,DOWN_ARROW,
45:                  LEFT_ARROW,RIGHT_ARROW,INSERT,HOME,PGUP,PGDN,END
46:                  };
47:                  
48:                  static int KbdReset(void);
49:                  
50:                  int KeyboardInit(){ // initialisation E/S et RAZ clavier
9D00821C  27BDFFE0   ADDIU SP, SP, -32
9D008220  AFBF001C   SW RA, 28(SP)
9D008224  AFB20018   SW S2, 24(SP)
9D008228  AFB10014   SW S1, 20(SP)
51:                      unsigned char c;
52:                      unsigned int t0;
53:                      t0=ticks()+750;
9D00822C  0F403E85   JAL ticks
9D008230  AFB00010   SW S0, 16(SP)
9D008234  245002EE   ADDIU S0, V0, 750
54:                      head=0;
9D008238  A380803A   SB ZERO, -32710(GP)
55:                      tail=0;
9D00823C  A3808038   SB ZERO, -32712(GP)
56:                      in_byte=0;
9D008240  A3808039   SB ZERO, -32711(GP)
57:                      bit_cnt=0;
9D008244  A3808036   SB ZERO, -32714(GP)
58:                      parity=0;
9D008248  A3808037   SB ZERO, -32713(GP)
59:                      rx_flags=0;
9D00824C  A3808034   SB ZERO, -32716(GP)
60:                      kbd_leds=0;
9D008250  A3808035   SB ZERO, -32715(GP)
61:                      key_state=0;
9D008254  A78080BC   SH ZERO, -32580(GP)
62:                      TRISASET=KBD_CLK|KBD_DAT;
9D008258  24040003   ADDIU A0, ZERO, 3
9D00825C  3C02BF88   LUI V0, -16504
9D008260  AC446018   SW A0, 24600(V0)
63:                      INTCONbits.INT4EP=0; // interruption sur transition descendante
9D008264  3C02BF88   LUI V0, -16504
9D008268  8C431000   LW V1, 4096(V0)
9D00826C  7C032104   INS V1, ZERO, 4, 1
9D008270  AC431000   SW V1, 4096(V0)
64:                      IPC4bits.INT4IP=6; // priorité 4
9D008274  3C02BF88   LUI V0, -16504
9D008278  8C4310D0   LW V1, 4304(V0)
9D00827C  24050006   ADDIU A1, ZERO, 6
9D008280  7CA3E684   INS V1, A1, 26, 3
9D008284  AC4310D0   SW V1, 4304(V0)
65:                      IPC4bits.INT4IS=3;  // sous-priorité 3.
9D008288  8C4310D0   LW V1, 4304(V0)
9D00828C  7C83CE04   INS V1, A0, 24, 2
9D008290  AC4310D0   SW V1, 4304(V0)
66:                      while (!PORTAbits.RA0);
9D008294  3C03BF88   LUI V1, -16504
9D008298  8C626020   LW V0, 24608(V1)
9D00829C  30420001   ANDI V0, V0, 1
9D0082A0  1040FFFD   BEQ V0, ZERO, 0x9D008298
9D0082A4  3C02BF88   LUI V0, -16504
67:                      IFS0bits.INT4IF=0; // RAZ indicateur interruption
9D0082A8  8C431030   LW V1, 4144(V0)
9D0082AC  7C03BDC4   INS V1, ZERO, 23, 1
9D0082B0  AC431030   SW V1, 4144(V0)
68:                      IEC0SET = _IEC0_INT4IE_MASK; // activation interruption externe 4 (KBD_CLK)
9D0082B4  3C030080   LUI V1, 128
9D0082B8  3C02BF88   LUI V0, -16504
9D0082BC  AC431068   SW V1, 4200(V0)
69:                      while ((ticks()<t0) && ((rx_flags & F_ERROR)==0)){
9D0082C0  0B4020B7   J 0x9D0082DC
9D0082C4  241100AA   ADDIU S1, ZERO, 170
9D0082DC  0F403E85   JAL ticks
9D0082E0  00000000   NOP
9D0082E4  0050102B   SLTU V0, V0, S0
9D0082E8  10400005   BEQ V0, ZERO, 0x9D008300
9D0082EC  00000000   NOP
9D0082F0  93828034   LBU V0, -32716(GP)
9D0082F4  30420001   ANDI V0, V0, 1
9D0082F8  1040FFF3   BEQ V0, ZERO, 0x9D0082C8
9D0082FC  00000000   NOP
70:                          c=KbdScancode();
9D0082C8  0F401F18   JAL KbdScancode
9D0082CC  00000000   NOP
71:                          if (c==BAT_OK){
9D0082D0  304200FF   ANDI V0, V0, 255
9D0082D4  10510028   BEQ V0, S1, 0x9D008378
9D0082D8  24020001   ADDIU V0, ZERO, 1
72:                              return 1;
73:                          }
74:                      }
75:                      if (KbdReset())
76:                          return 1;
77:                      else
78:                          return 0;
79:                  } //KeyboardInit()
9D008378  8FBF001C   LW RA, 28(SP)
9D00837C  8FB20018   LW S2, 24(SP)
9D008380  8FB10014   LW S1, 20(SP)
9D008384  8FB00010   LW S0, 16(SP)
9D008388  03E00008   JR RA
9D00838C  27BD0020   ADDIU SP, SP, 32
80:                  
81:                  static int KbdReset(void){
82:                      unsigned int t0;
83:                      short c;
84:                      rx_flags = 0;
9D008300  A3808034   SB ZERO, -32716(GP)
85:                      KbdSend(KBD_RESET);
9D008304  0F401E5B   JAL KbdSend
9D008308  2404FFFF   ADDIU A0, ZERO, -1
86:                      t0=ticks()+750;
9D00830C  0F403E85   JAL ticks
9D008310  00008021   ADDU S0, ZERO, ZERO
9D008314  245102EE   ADDIU S1, V0, 750
87:                      c=0;
88:                      while ((ticks()<t0) && ((rx_flags & F_ERROR)==0) && !c){
9D008330  0F403E85   JAL ticks
9D008334  00000000   NOP
9D008338  0051102B   SLTU V0, V0, S1
9D00833C  10400007   BEQ V0, ZERO, 0x9D00835C
9D008340  00000000   NOP
9D008344  93828034   LBU V0, -32716(GP)
9D008348  30420001   ANDI V0, V0, 1
9D00834C  14400003   BNE V0, ZERO, 0x9D00835C
9D008350  00000000   NOP
9D008354  1200FFF2   BEQ S0, ZERO, 0x9D008320
9D008358  00000000   NOP
89:                              c=KbdScancode();
9D008320  0F401F18   JAL KbdScancode
9D008324  00000000   NOP
9D008328  00521826   XOR V1, V0, S2
9D00832C  0043800B   MOVN S0, V0, V1
90:                              if (c==KBD_ACK){
9D008318  0B4020CC   J 0x9D008330
9D00831C  241200FA   ADDIU S2, ZERO, 250
91:                                  c=0;
92:                              }
93:                      }
94:                      if ((rx_flags & F_ERROR) || (c!=BAT_OK))
9D00835C  93838034   LBU V1, -32716(GP)
9D008360  30630001   ANDI V1, V1, 1
9D008364  14600003   BNE V1, ZERO, 0x9D008374
9D008368  00001021   ADDU V0, ZERO, ZERO
95:                          return 0;
9D00836C  3A0200AA   XORI V0, S0, 170
9D008370  2C420001   SLTIU V0, V0, 1
9D008374  0002102B   SLTU V0, ZERO, V0
96:                      else
97:                          return 1;
98:                  }//KbdReset()
99:                  
100:                 typedef enum  _STATE {ST0, ST_EXT0, ST_RELEASE, ST_COMPLETED} state_t;
101:                 
102:                 short KbdScancode(){  // obtient le code clavier en tête de la file
9D007C60  27BDFFE8   ADDIU SP, SP, -24
9D007C64  AFBF0014   SW RA, 20(SP)
9D007C68  AFB00010   SW S0, 16(SP)
9D007F48  3C079D01   LUI A3, -25343
9D007F4C  24E775F0   ADDIU A3, A3, 30192
103:                 	unsigned int i, flags;
104:                         state_t state;
105:                 	short code;
106:                         if (head==tail){
9D007C6C  9383803A   LBU V1, -32710(GP)
9D007C70  306300FF   ANDI V1, V1, 255
9D007C74  93828038   LBU V0, -32712(GP)
9D007C78  304200FF   ANDI V0, V0, 255
9D007C7C  14620018   BNE V1, V0, 0x9D007CE0
9D007C80  00002021   ADDU A0, ZERO, ZERO
9D007CE0  00003021   ADDU A2, ZERO, ZERO
107:                             if (rx_flags & F_ERROR){
9D007C84  93838034   LBU V1, -32716(GP)
9D007C88  30630001   ANDI V1, V1, 1
9D007C8C  1060015F   BEQ V1, ZERO, 0x9D00820C
9D007C90  00001021   ADDU V0, ZERO, ZERO
108:                                 _status_on();
9D007C94  24100008   ADDIU S0, ZERO, 8
9D007C98  3C02BF88   LUI V0, -16504
9D007C9C  AC506128   SW S0, 24872(V0)
109:                                 delay_ms(400);
9D007CA0  0F403E92   JAL delay_ms
9D007CA4  24040190   ADDIU A0, ZERO, 400
110:                                 _status_off();
9D007CA8  3C02BF88   LUI V0, -16504
9D007CAC  AC506124   SW S0, 24868(V0)
111:                                 delay_ms(400);
9D007CB0  0F403E92   JAL delay_ms
9D007CB4  24040190   ADDIU A0, ZERO, 400
112:                                 rx_flags &= ~F_ERROR;
9D007CB8  93828034   LBU V0, -32716(GP)
9D007CBC  304200FE   ANDI V0, V0, 254
9D007CC0  A3828034   SB V0, -32716(GP)
113:                                 IEC0bits.INT4IE=1;
9D007CC4  3C02BF88   LUI V0, -16504
9D007CC8  8C431060   LW V1, 4192(V0)
9D007CCC  24040001   ADDIU A0, ZERO, 1
9D007CD0  7C83BDC4   INS V1, A0, 23, 1
9D007CD4  AC431060   SW V1, 4192(V0)
114:                             }
115:                             return 0; // tampon vide
9D007CD8  0B402083   J 0x9D00820C
9D007CDC  00001021   ADDU V0, ZERO, ZERO
116:                         }
117:                 	code = 0;
118:                 	flags=0;
119:                         state=ST0;
120:                 	while (state!=ST_COMPLETED){
9D007CF4  240A0003   ADDIU T2, ZERO, 3
9D007EB8  148AFF91   BNE A0, T2, 0x9D007D00
9D007EBC  00000000   NOP
121:                             _wait_key();
9D007D00  9383803A   LBU V1, -32710(GP)
9D007D04  306300FF   ANDI V1, V1, 255
9D007D08  93828038   LBU V0, -32712(GP)
9D007D0C  304200FF   ANDI V0, V0, 255
9D007D10  1062FFFB   BEQ V1, V0, 0x9D007D00
9D007D14  00000000   NOP
122:                             code=kbd_queue[head];
9D007CE4  3C08A000   LUI T0, -24576
9D007CE8  25082B1C   ADDIU T0, T0, 11036
9D007D18  9382803A   LBU V0, -32710(GP)
9D007D1C  304200FF   ANDI V0, V0, 255
9D007D20  00481021   ADDU V0, V0, T0
9D007D24  90430000   LBU V1, 0(V0)
9D007D28  7C031620   SEH V0, V1
123:                             head++;
9D007D2C  9385803A   LBU A1, -32710(GP)
9D007D30  24A50001   ADDIU A1, A1, 1
9D007D34  30A500FF   ANDI A1, A1, 255
9D007D38  A385803A   SB A1, -32710(GP)
124:                             head &= 31;
9D007D3C  9385803A   LBU A1, -32710(GP)
9D007D40  30A5001F   ANDI A1, A1, 31
9D007D44  A385803A   SB A1, -32710(GP)
125:                             switch (state){
9D007CEC  24070001   ADDIU A3, ZERO, 1
9D007D48  10870026   BEQ A0, A3, 0x9D007DE4
9D007D4C  00000000   NOP
9D007D50  10800006   BEQ A0, ZERO, 0x9D007D6C
9D007D54  00000000   NOP
9D007D58  24030002   ADDIU V1, ZERO, 2
9D007D5C  14830056   BNE A0, V1, 0x9D007EB8
9D007D60  00C02821   ADDU A1, A2, ZERO
126:                                 case ST0:
127:                                     switch (code){
9D007CF8  240B00E1   ADDIU T3, ZERO, 225
9D007CFC  240C00E0   ADDIU T4, ZERO, 224
9D007D6C  106B000B   BEQ V1, T3, 0x9D007D9C
9D007D70  24040007   ADDIU A0, ZERO, 7
9D007D74  50690005   BEQL V1, T1, 0x9D007D8C
9D007D78  34C68000   ORI A2, A2, -32768
9D007D7C  146C004E   BNE V1, T4, 0x9D007EB8
9D007D80  01402021   ADDU A0, T2, ZERO
128:                                         case KEY_REL:
129:                                             flags |= REL_BIT;
130:                                             state = ST_RELEASE;
131:                                             break;
9D007D8C  0B401F40   J 0x9D007D00
9D007D90  24040002   ADDIU A0, ZERO, 2
132:                                         case XTD_KEY:
133:                                             flags |= XT_BIT;
9D007D84  0B401F65   J 0x9D007D94
9D007D88  34C60100   ORI A2, A2, 256
134:                                             state = ST_EXT0;
135:                                             break;
9D007D94  0B401F40   J 0x9D007D00
9D007D98  00E02021   ADDU A0, A3, ZERO
136:                                         case 0xE1:
137:                                             for (i=7;i;i--){     // touche PAUSE élimine les 7 prochains caractères
9D007DD4  1480FFF1   BNE A0, ZERO, 0x9D007D9C
9D007DD8  240201E1   ADDIU V0, ZERO, 481
138:                                                     _wait_key();
9D007D9C  9383803A   LBU V1, -32710(GP)
9D007DA0  306300FF   ANDI V1, V1, 255
9D007DA4  93828038   LBU V0, -32712(GP)
9D007DA8  304200FF   ANDI V0, V0, 255
9D007DAC  1062FFFB   BEQ V1, V0, 0x9D007D9C
9D007DB0  00000000   NOP
139:                                                     head++;
9D007DB4  9382803A   LBU V0, -32710(GP)
9D007DB8  24420001   ADDIU V0, V0, 1
9D007DBC  304200FF   ANDI V0, V0, 255
9D007DC0  A382803A   SB V0, -32710(GP)
140:                                                     head &= 31;
9D007DC4  9382803A   LBU V0, -32710(GP)
9D007DC8  3042001F   ANDI V0, V0, 31
9D007DCC  A382803A   SB V0, -32710(GP)
9D007DD0  2484FFFF   ADDIU A0, A0, -1
141:                                             }
142:                                             code = PAUSE;
143:                                         default:
144:                                             state=ST_COMPLETED;
145:                                     }//switch(code)
146:                                     break;
147:                                 case ST_EXT0:
148:                                     if (code==KEY_REL){
9D007CF0  240900F0   ADDIU T1, ZERO, 240
9D007DE4  14490004   BNE V0, T1, 0x9D007DF8
9D007DE8  30C30100   ANDI V1, A2, 256
149:                                         flags |= REL_BIT;
9D007DEC  34C68000   ORI A2, A2, -32768
150:                                         state = ST_RELEASE;
9D007DF0  0B401F40   J 0x9D007D00
9D007DF4  24040002   ADDIU A0, ZERO, 2
151:                                     }else{
152:                                         if ((flags & XT_BIT) && (code==0x12)){ // touche PrtSc enfoncée.
9D007DF8  10600031   BEQ V1, ZERO, 0x9D007EC0
9D007DFC  00C02821   ADDU A1, A2, ZERO
9D007E00  24030012   ADDIU V1, ZERO, 18
9D007E04  1443002F   BNE V0, V1, 0x9D007EC4
9D007E08  3C03BF88   LUI V1, -16504
9D007E0C  24040002   ADDIU A0, ZERO, 2
153:                                             for (i=2;i;i--){ // élimine les 2 codes suivants
9D007E48  1480FFF1   BNE A0, ZERO, 0x9D007E10
9D007E4C  24020112   ADDIU V0, ZERO, 274
9D007E50  0B401FB0   J 0x9D007EC0
9D007E54  00A03021   ADDU A2, A1, ZERO
154:                                                 _wait_key();
9D007E10  9383803A   LBU V1, -32710(GP)
9D007E14  306300FF   ANDI V1, V1, 255
9D007E18  93828038   LBU V0, -32712(GP)
9D007E1C  304200FF   ANDI V0, V0, 255
9D007E20  1062FFFB   BEQ V1, V0, 0x9D007E10
9D007E24  00000000   NOP
155:                                                 head++;
9D007E28  9382803A   LBU V0, -32710(GP)
9D007E2C  24420001   ADDIU V0, V0, 1
9D007E30  304200FF   ANDI V0, V0, 255
9D007E34  A382803A   SB V0, -32710(GP)
156:                                                 head &=31;
9D007E38  9382803A   LBU V0, -32710(GP)
9D007E3C  3042001F   ANDI V0, V0, 31
9D007E40  A382803A   SB V0, -32710(GP)
9D007E44  2484FFFF   ADDIU A0, A0, -1
157:                                             }
158:                                             code = PRN;
159:                                         }
160:                                         state = ST_COMPLETED;
161:                                     }
162:                                     break;
163:                                 case ST_RELEASE:
164:                                     if ((flags & XT_BIT) && (code==0x7c)){ //touche PrtSc relâchée.
9D007D64  0B401F96   J 0x9D007E58
9D007D68  30C30100   ANDI V1, A2, 256
9D007E58  1060001A   BEQ V1, ZERO, 0x9D007EC4
9D007E5C  3C03BF88   LUI V1, -16504
9D007E60  2403007C   ADDIU V1, ZERO, 124
9D007E64  14430017   BNE V0, V1, 0x9D007EC4
9D007E68  3C03BF88   LUI V1, -16504
9D007E6C  24040003   ADDIU A0, ZERO, 3
165:                                         for (i=3;i;i--){ // élimine les 3 codes suivants.
9D007EA8  1480FFF1   BNE A0, ZERO, 0x9D007E70
9D007EAC  24020112   ADDIU V0, ZERO, 274
9D007EB0  0B401FB0   J 0x9D007EC0
9D007EB4  00A03021   ADDU A2, A1, ZERO
166:                                             _wait_key();
9D007E70  9383803A   LBU V1, -32710(GP)
9D007E74  306300FF   ANDI V1, V1, 255
9D007E78  93828038   LBU V0, -32712(GP)
9D007E7C  304200FF   ANDI V0, V0, 255
9D007E80  1062FFFB   BEQ V1, V0, 0x9D007E70
9D007E84  00000000   NOP
167:                                             head++;
9D007E88  9382803A   LBU V0, -32710(GP)
9D007E8C  24420001   ADDIU V0, V0, 1
9D007E90  304200FF   ANDI V0, V0, 255
9D007E94  A382803A   SB V0, -32710(GP)
168:                                             head &= 31;
9D007E98  9382803A   LBU V0, -32710(GP)
9D007E9C  3042001F   ANDI V0, V0, 31
9D007EA0  A382803A   SB V0, -32710(GP)
9D007EA4  2484FFFF   ADDIU A0, A0, -1
169:                                         }
170:                                         code = PRN;
171:                                     }
172:                                     state=ST_COMPLETED;
173:                                     break;
174:                                 default:;
175:                             }//switch(state)
176:                         }//while(state...)
177:                         IEC0bits.INT4IE=0; // section critique désactive interruption
9D007DDC  0B401FB1   J 0x9D007EC4
9D007DE0  3C03BF88   LUI V1, -16504
9D007EC0  3C03BF88   LUI V1, -16504
9D007EC4  8C641060   LW A0, 4192(V1)
9D007EC8  7C04BDC4   INS A0, ZERO, 23, 1
9D007ECC  AC641060   SW A0, 4192(V1)
178:                 	if (head==tail){
9D007ED0  9384803A   LBU A0, -32710(GP)
9D007ED4  308400FF   ANDI A0, A0, 255
9D007ED8  93838038   LBU V1, -32712(GP)
9D007EDC  306300FF   ANDI V1, V1, 255
9D007EE0  14830005   BNE A0, V1, 0x9D007EF8
9D007EE4  3C03BF88   LUI V1, -16504
179:                 		rx_flags &= ~F_RCVD;
9D007EE8  93838034   LBU V1, -32716(GP)
9D007EEC  306300FD   ANDI V1, V1, 253
9D007EF0  A3838034   SB V1, -32716(GP)
180:                 	}
181:                         IEC0bits.INT4IE=1; // fin section critique réactive interruption
9D007EF4  3C03BF88   LUI V1, -16504
9D007EF8  8C641060   LW A0, 4192(V1)
9D007EFC  24050001   ADDIU A1, ZERO, 1
9D007F00  7CA4BDC4   INS A0, A1, 23, 1
9D007F04  AC641060   SW A0, 4192(V1)
182:                         if ((code==KBD_ACK)||(code==KBD_RSND)||(code==BAT_OK)||(code==BAT_ERROR)){
9D007F08  240300FA   ADDIU V1, ZERO, 250
9D007F0C  104300BF   BEQ V0, V1, 0x9D00820C
9D007F10  240300FE   ADDIU V1, ZERO, 254
9D007F14  104300BD   BEQ V0, V1, 0x9D00820C
9D007F18  240300AA   ADDIU V1, ZERO, 170
9D007F1C  104300BB   BEQ V0, V1, 0x9D00820C
9D007F20  240300FC   ADDIU V1, ZERO, 252
9D007F24  104300B9   BEQ V0, V1, 0x9D00820C
9D007F28  24030058   ADDIU V1, ZERO, 88
183:                             return code;
184:                         }
185:                         code |= flags;
9D007F2C  00462825   OR A1, V0, A2
9D007F30  30A5FFFF   ANDI A1, A1, -1
9D007F34  7C051620   SEH V0, A1
186:                         for (i=0;i<FN_COUNT;i++){
9D0081F8  5467FF56   BNEL V1, A3, 0x9D007F54
9D0081FC  84640000   LH A0, 0(V1)
187:                             if ((code&0x1ff)==fn_keys[i]){
9D007F38  30A501FF   ANDI A1, A1, 511
9D007F3C  10A30007   BEQ A1, V1, 0x9D007F5C
9D007F40  3C039D01   LUI V1, -25343
9D007F44  246375B2   ADDIU V1, V1, 30130
9D007F50  84640000   LH A0, 0(V1)
9D007F54  148500A8   BNE A0, A1, 0x9D0081F8
9D007F58  24630002   ADDIU V1, V1, 2
188:                                 code |= FN_BIT;
9D007F5C  34420200   ORI V0, V0, 512
9D007F60  7C021620   SEH V0, V0
189:                                 switch (code&0x1ff){ // les touches d'alteration sont traitées ici.
9D007F64  304301FF   ANDI V1, V0, 511
9D007F68  24040059   ADDIU A0, ZERO, 89
9D007F6C  10640030   BEQ V1, A0, 0x9D008030
9D007F70  2864005A   SLTI A0, V1, 90
9D007F74  10800011   BEQ A0, ZERO, 0x9D007FBC
9D007F78  2404007E   ADDIU A0, ZERO, 126
9D007F7C  24040012   ADDIU A0, ZERO, 18
9D007F80  1064001D   BEQ V1, A0, 0x9D007FF8
9D007F84  28640013   SLTI A0, V1, 19
9D007F88  10800006   BEQ A0, ZERO, 0x9D007FA4
9D007F8C  24040014   ADDIU A0, ZERO, 20
9D007F90  24040011   ADDIU A0, ZERO, 17
9D007F94  1464009A   BNE V1, A0, 0x9D008200
9D007F98  00000000   NOP
9D007FA4  10640030   BEQ V1, A0, 0x9D008068
9D007FA8  24040058   ADDIU A0, ZERO, 88
9D007FAC  14640094   BNE V1, A0, 0x9D008200
9D007FB0  00000000   NOP
9D007FBC  1064007E   BEQ V1, A0, 0x9D0081B8
9D007FC0  2864007F   SLTI A0, V1, 127
9D007FC4  10800006   BEQ A0, ZERO, 0x9D007FE0
9D007FC8  24040111   ADDIU A0, ZERO, 273
9D007FCC  24040077   ADDIU A0, ZERO, 119
9D007FD0  1464008B   BNE V1, A0, 0x9D008200
9D007FD4  00000000   NOP
9D007FE0  1064003C   BEQ V1, A0, 0x9D0080D4
9D007FE4  24040114   ADDIU A0, ZERO, 276
9D007FE8  14640085   BNE V1, A0, 0x9D008200
9D007FEC  00000000   NOP
190:                                     case LSHIFT:
191:                                         if (flags & REL_BIT){
9D007FF8  30C68000   ANDI A2, A2, -32768
9D007FFC  10C00006   BEQ A2, ZERO, 0x9D008018
9D008000  00000000   NOP
192:                                             key_state &=~F_LSHIFT;
9D008004  978280BC   LHU V0, -32580(GP)
9D008008  3042FFF7   ANDI V0, V0, -9
9D00800C  A78280BC   SH V0, -32580(GP)
9D008010  0B402083   J 0x9D00820C
9D008014  00001021   ADDU V0, ZERO, ZERO
193:                                         }else{
194:                                             key_state |= F_LSHIFT;
9D008018  978280BC   LHU V0, -32580(GP)
9D00801C  3042FFFF   ANDI V0, V0, -1
9D008020  34420008   ORI V0, V0, 8
9D008024  A78280BC   SH V0, -32580(GP)
9D008028  0B402083   J 0x9D00820C
9D00802C  00001021   ADDU V0, ZERO, ZERO
195:                                         }
196:                                         code=0;
197:                                         break;
198:                                     case RSHIFT:
199:                                         if (flags & REL_BIT){
9D008030  30C68000   ANDI A2, A2, -32768
9D008034  10C00006   BEQ A2, ZERO, 0x9D008050
9D008038  00000000   NOP
200:                                             key_state &=~F_RSHIFT;
9D00803C  978280BC   LHU V0, -32580(GP)
9D008040  3042FFEF   ANDI V0, V0, -17
9D008044  A78280BC   SH V0, -32580(GP)
9D008048  0B402083   J 0x9D00820C
9D00804C  00001021   ADDU V0, ZERO, ZERO
201:                                         }else{
202:                                             key_state |= F_RSHIFT;
9D008050  978280BC   LHU V0, -32580(GP)
9D008054  3042FFFF   ANDI V0, V0, -1
9D008058  34420010   ORI V0, V0, 16
9D00805C  A78280BC   SH V0, -32580(GP)
9D008060  0B402083   J 0x9D00820C
9D008064  00001021   ADDU V0, ZERO, ZERO
203:                                         }
204:                                         code=0;
205:                                         break;
206:                                     case LCTRL:
207:                                         if (flags & REL_BIT){
9D008068  30C68000   ANDI A2, A2, -32768
9D00806C  10C00006   BEQ A2, ZERO, 0x9D008088
9D008070  00000000   NOP
208:                                             key_state &=~F_LCTRL;
9D008074  978280BC   LHU V0, -32580(GP)
9D008078  3042FFDF   ANDI V0, V0, -33
9D00807C  A78280BC   SH V0, -32580(GP)
9D008080  0B402083   J 0x9D00820C
9D008084  00001021   ADDU V0, ZERO, ZERO
209:                                         }else{
210:                                             key_state |= F_LCTRL;
9D008088  978280BC   LHU V0, -32580(GP)
9D00808C  3042FFFF   ANDI V0, V0, -1
9D008090  34420020   ORI V0, V0, 32
9D008094  A78280BC   SH V0, -32580(GP)
9D008098  0B402083   J 0x9D00820C
9D00809C  00001021   ADDU V0, ZERO, ZERO
211:                                         }
212:                                         code=0;
213:                                         break;
214:                                     case RCTRL:
215:                                         if (flags & REL_BIT){
9D007FF0  0B402028   J 0x9D0080A0
9D007FF4  30C68000   ANDI A2, A2, -32768
9D0080A0  10C00006   BEQ A2, ZERO, 0x9D0080BC
9D0080A4  00000000   NOP
216:                                             key_state &=~F_RCTRL;
9D0080A8  978280BC   LHU V0, -32580(GP)
9D0080AC  3042FFBF   ANDI V0, V0, -65
9D0080B0  A78280BC   SH V0, -32580(GP)
9D0080B4  0B402083   J 0x9D00820C
9D0080B8  00001021   ADDU V0, ZERO, ZERO
217:                                         }else{
218:                                             key_state |= F_RCTRL;
9D0080BC  978280BC   LHU V0, -32580(GP)
9D0080C0  3042FFFF   ANDI V0, V0, -1
9D0080C4  34420040   ORI V0, V0, 64
9D0080C8  A78280BC   SH V0, -32580(GP)
9D0080CC  0B402083   J 0x9D00820C
9D0080D0  00001021   ADDU V0, ZERO, ZERO
219:                                         }
220:                                         code=0;
221:                                         break;
222:                                     case RALT:
223:                                         if (flags & REL_BIT){
9D0080D4  30C68000   ANDI A2, A2, -32768
9D0080D8  10C00006   BEQ A2, ZERO, 0x9D0080F4
9D0080DC  00000000   NOP
224:                                             key_state &=~F_ALTCHAR;
9D0080E0  978280BC   LHU V0, -32580(GP)
9D0080E4  3042FEFF   ANDI V0, V0, -257
9D0080E8  A78280BC   SH V0, -32580(GP)
9D0080EC  0B402083   J 0x9D00820C
9D0080F0  00001021   ADDU V0, ZERO, ZERO
225:                                         }else{
226:                                             key_state |= F_ALTCHAR;
9D0080F4  978280BC   LHU V0, -32580(GP)
9D0080F8  3042FFFF   ANDI V0, V0, -1
9D0080FC  34420100   ORI V0, V0, 256
9D008100  A78280BC   SH V0, -32580(GP)
9D008104  0B402083   J 0x9D00820C
9D008108  00001021   ADDU V0, ZERO, ZERO
227:                                         }
228:                                         code=0;
229:                                         break;
230:                                     case LALT:
231:                                         if (flags & REL_BIT){
9D007F9C  0B402043   J 0x9D00810C
9D007FA0  30C68000   ANDI A2, A2, -32768
9D00810C  10C00006   BEQ A2, ZERO, 0x9D008128
9D008110  00000000   NOP
232:                                             key_state &=~F_LALT;
9D008114  978280BC   LHU V0, -32580(GP)
9D008118  3042FF7F   ANDI V0, V0, -129
9D00811C  A78280BC   SH V0, -32580(GP)
9D008120  0B402083   J 0x9D00820C
9D008124  00001021   ADDU V0, ZERO, ZERO
233:                                         }else{
234:                                             key_state |= F_LALT;
9D008128  978280BC   LHU V0, -32580(GP)
9D00812C  3042FFFF   ANDI V0, V0, -1
9D008130  34420080   ORI V0, V0, 128
9D008134  A78280BC   SH V0, -32580(GP)
9D008138  0B402083   J 0x9D00820C
9D00813C  00001021   ADDU V0, ZERO, ZERO
235:                                         }
236:                                         code=0;
237:                                         break;
238:                                     case NUM_LOCK:
239:                                         if (flags & REL_BIT){
9D007FD8  0B402050   J 0x9D008140
9D007FDC  30C68000   ANDI A2, A2, -32768
9D008140  10C00032   BEQ A2, ZERO, 0x9D00820C
9D008144  00001021   ADDU V0, ZERO, ZERO
240:                                             kbd_leds ^= F_NUM;
9D008148  93828035   LBU V0, -32715(GP)
9D00814C  304200FF   ANDI V0, V0, 255
9D008150  38420002   XORI V0, V0, 2
9D008154  A3828035   SB V0, -32715(GP)
241:                                             key_state ^= F_NUM;
9D008158  978280BC   LHU V0, -32580(GP)
9D00815C  3042FFFF   ANDI V0, V0, -1
9D008160  38420002   XORI V0, V0, 2
9D008164  A78280BC   SH V0, -32580(GP)
242:                                             SetKbdLeds(kbd_leds);
9D008168  93848035   LBU A0, -32715(GP)
9D00816C  0F401EE3   JAL SetKbdLeds
9D008170  308400FF   ANDI A0, A0, 255
9D008174  0B402083   J 0x9D00820C
9D008178  00001021   ADDU V0, ZERO, ZERO
243:                                         }
244:                                         code=0;
245:                                         break;
246:                                     case CAPS_LOCK:
247:                                         if (flags & REL_BIT){
9D007FB4  0B40205F   J 0x9D00817C
9D007FB8  30C68000   ANDI A2, A2, -32768
9D00817C  10C00023   BEQ A2, ZERO, 0x9D00820C
9D008180  00001021   ADDU V0, ZERO, ZERO
248:                                             kbd_leds ^= F_CAPS;
9D008184  93828035   LBU V0, -32715(GP)
9D008188  304200FF   ANDI V0, V0, 255
9D00818C  38420004   XORI V0, V0, 4
9D008190  A3828035   SB V0, -32715(GP)
249:                                             key_state ^= F_CAPS;
9D008194  978280BC   LHU V0, -32580(GP)
9D008198  3042FFFF   ANDI V0, V0, -1
9D00819C  38420004   XORI V0, V0, 4
9D0081A0  A78280BC   SH V0, -32580(GP)
250:                                             SetKbdLeds(kbd_leds);
9D0081A4  93848035   LBU A0, -32715(GP)
9D0081A8  0F401EE3   JAL SetKbdLeds
9D0081AC  308400FF   ANDI A0, A0, 255
9D0081B0  0B402083   J 0x9D00820C
9D0081B4  00001021   ADDU V0, ZERO, ZERO
251:                                         }
252:                                         code=0;
253:                                         break;
254:                                     case SCROLL_LOCK:
255:                                         if (flags & REL_BIT){
9D0081B8  30C68000   ANDI A2, A2, -32768
9D0081BC  10C00013   BEQ A2, ZERO, 0x9D00820C
9D0081C0  00001021   ADDU V0, ZERO, ZERO
256:                                             kbd_leds ^= F_SCROLL;
9D0081C4  93828035   LBU V0, -32715(GP)
9D0081C8  304200FF   ANDI V0, V0, 255
9D0081CC  38420001   XORI V0, V0, 1
9D0081D0  A3828035   SB V0, -32715(GP)
257:                                             key_state ^= F_SCROLL;
9D0081D4  978280BC   LHU V0, -32580(GP)
9D0081D8  3042FFFF   ANDI V0, V0, -1
9D0081DC  38420001   XORI V0, V0, 1
9D0081E0  A78280BC   SH V0, -32580(GP)
258:                                             SetKbdLeds(kbd_leds);
9D0081E4  93848035   LBU A0, -32715(GP)
9D0081E8  0F401EE3   JAL SetKbdLeds
9D0081EC  308400FF   ANDI A0, A0, 255
9D0081F0  0B402083   J 0x9D00820C
9D0081F4  00001021   ADDU V0, ZERO, ZERO
259:                                         }
260:                                         code=0;
261:                                         break;
262:                                     default:;
263:                                 }//switch(code)
264:                                 break;
265:                             }// if
266:                         }//for
267:                         if ((code < 0) && !(code & FN_BIT)) // ne retourne pas les relâchement de touche pour les touches caractères.
9D008200  04410002   BGEZ V0, 0x9D00820C
9D008204  30430200   ANDI V1, V0, 512
268:                             return 0;
9D008208  0003100A   MOVZ V0, ZERO, V1
269:                         else
270:                             return code;
271:                 }// GetScancode()
9D00820C  8FBF0014   LW RA, 20(SP)
9D008210  8FB00010   LW S0, 16(SP)
9D008214  03E00008   JR RA
9D008218  27BD0018   ADDIU SP, SP, 24
272:                 
273:                 
274:                 short KbdKey(short scancode){  // obtient la transcription du code en ASCII
9D007768  7C042620   SEH A0, A0
275:                 	int a,i;
276:                 	a=0;
9D0077D4  0B401E56   J 0x9D007958
9D0077D8  00001021   ADDU V0, ZERO, ZERO
277:                 	if (scancode & XT_BIT){
9D00776C  3086FFFF   ANDI A2, A0, -1
9D007770  30C20100   ANDI V0, A2, 256
9D007774  10400019   BEQ V0, ZERO, 0x9D0077DC
9D007778  3C029D01   LUI V0, -25343
278:                 		i=0;
279:                 		while (qwerty_xt_char[i].code){
9D00777C  8443425C   LH V1, 16988(V0)
9D007780  10600075   BEQ V1, ZERO, 0x9D007958
9D007784  00001021   ADDU V0, ZERO, ZERO
9D0077C8  84430000   LH V1, 0(V0)
9D0077CC  1460FFF2   BNE V1, ZERO, 0x9D007798
9D0077D0  24A50001   ADDIU A1, A1, 1
280:                 			if (qwerty_xt_char[i].code==scancode){
9D007788  5483000D   BNEL A0, V1, 0x9D0077C0
9D00778C  3C029D01   LUI V0, -25343
9D007790  0B401DEA   J 0x9D0077A8
9D007794  00002821   ADDU A1, ZERO, ZERO
9D007798  1483000B   BNE A0, V1, 0x9D0077C8
9D00779C  24420004   ADDIU V0, V0, 4
9D0077C4  00002821   ADDU A1, ZERO, ZERO
281:                 				a=qwerty_xt_char[i].ascii;
9D0077A0  0B401DEB   J 0x9D0077AC
9D0077A4  00052880   SLL A1, A1, 2
9D0077A8  00052880   SLL A1, A1, 2
9D0077AC  3C029D01   LUI V0, -25343
9D0077B0  2442425C   ADDIU V0, V0, 16988
9D0077B4  00452821   ADDU A1, V0, A1
282:                 				break;
9D0077B8  0B401E56   J 0x9D007958
9D0077BC  84A20002   LH V0, 2(A1)
9D0077C0  24424260   ADDIU V0, V0, 16992
283:                 			}
284:                 			i++;
285:                 		} // while (xt_char[i].code)
286:                 	}else if (key_state & F_SHIFT){
9D0077DC  978280BC   LHU V0, -32580(GP)
9D0077E0  30420018   ANDI V0, V0, 24
9D0077E4  5440000A   BNEL V0, ZERO, 0x9D007810
9D0077E8  3C029D01   LUI V0, -25343
287:                 		i=0;
288:                 		while (qwerty_shifted_key[i].code){
9D007810  84424208   LH V0, 16904(V0)
9D007814  50400019   BEQL V0, ZERO, 0x9D00787C
9D007818  3C029D01   LUI V0, -25343
9D00786C  84430000   LH V1, 0(V0)
9D007870  1460FFEF   BNE V1, ZERO, 0x9D007830
9D007874  24A50001   ADDIU A1, A1, 1
289:                 			if (qwerty_shifted_key[i].code==(scancode&0xff)){
9D00781C  30C700FF   ANDI A3, A2, 255
9D007820  14470010   BNE V0, A3, 0x9D007864
9D007824  3C029D01   LUI V0, -25343
9D007828  0B401E10   J 0x9D007840
9D00782C  00002821   ADDU A1, ZERO, ZERO
9D007830  1467000E   BNE V1, A3, 0x9D00786C
9D007834  24420004   ADDIU V0, V0, 4
9D007868  00002821   ADDU A1, ZERO, ZERO
290:                 				a=qwerty_shifted_key[i].ascii;
9D007838  0B401E11   J 0x9D007844
9D00783C  00052880   SLL A1, A1, 2
9D007840  00052880   SLL A1, A1, 2
9D007844  3C029D01   LUI V0, -25343
9D007848  24424208   ADDIU V0, V0, 16904
9D00784C  00452821   ADDU A1, V0, A1
9D007850  84A20002   LH V0, 2(A1)
291:                 				break;
292:                 			}
293:                 			i++;
294:                 		}// while (shifted_key.code)
295:                 		if (!a){
9D007854  14400041   BNE V0, ZERO, 0x9D00795C
9D007858  2403FF00   ADDIU V1, ZERO, -256
9D007864  2442420C   ADDIU V0, V0, 16908
296:                 			i=0;
297:                 			while (qwerty[i].code){
9D00785C  0B401E1F   J 0x9D00787C
9D007860  3C029D01   LUI V0, -25343
9D007878  3C029D01   LUI V0, -25343
9D00787C  844340F8   LH V1, 16632(V0)
9D007880  10600035   BEQ V1, ZERO, 0x9D007958
9D007884  00001021   ADDU V0, ZERO, ZERO
9D0078DC  84430000   LH V1, 0(V0)
9D0078E0  1460FFEE   BNE V1, ZERO, 0x9D00789C
9D0078E4  24A50001   ADDIU A1, A1, 1
9D0078E8  0B401E56   J 0x9D007958
9D0078EC  00001021   ADDU V0, ZERO, ZERO
298:                 				if (qwerty[i].code==(scancode&0xff)){
9D007888  30C600FF   ANDI A2, A2, 255
9D00788C  54660011   BNEL V1, A2, 0x9D0078D4
9D007890  3C029D01   LUI V0, -25343
9D007894  0B401E2B   J 0x9D0078AC
9D007898  00002821   ADDU A1, ZERO, ZERO
9D00789C  14C3000F   BNE A2, V1, 0x9D0078DC
9D0078A0  24420004   ADDIU V0, V0, 4
9D0078D8  00002821   ADDU A1, ZERO, ZERO
299:                 					a=qwerty[i].ascii;
9D0078A4  0B401E2C   J 0x9D0078B0
9D0078A8  00052880   SLL A1, A1, 2
9D0078AC  00052880   SLL A1, A1, 2
9D0078B0  3C029D01   LUI V0, -25343
9D0078B4  244240F8   ADDIU V0, V0, 16632
9D0078B8  00452821   ADDU A1, V0, A1
9D0078BC  84A20002   LH V0, 2(A1)
300:                 					break;
301:                 				}
302:                 				i++;
303:                 			}// while (translate.code)
304:                 			if (a>='a' && a<='z'){
9D0078C0  2445FF9F   ADDIU A1, V0, -97
9D0078C4  2CA5001A   SLTIU A1, A1, 26
9D0078D4  244240FC   ADDIU V0, V0, 16636
305:                 				a -=32;
9D0078C8  2443FFE0   ADDIU V1, V0, -32
9D0078CC  0B401E56   J 0x9D007958
9D0078D0  0065100B   MOVN V0, V1, A1
306:                 			}
307:                 		} // if (!a)
308:                 	}else{
309:                 		i=0;
310:                 		while (qwerty[i].code){
9D0077EC  3C029D01   LUI V0, -25343
9D0077F0  844340F8   LH V1, 16632(V0)
9D0077F4  10600058   BEQ V1, ZERO, 0x9D007958
9D0077F8  00001021   ADDU V0, ZERO, ZERO
9D007934  84430000   LH V1, 0(V0)
9D007938  1460FFED   BNE V1, ZERO, 0x9D0078F0
9D00793C  24A50001   ADDIU A1, A1, 1
9D007940  0B401E56   J 0x9D007958
9D007944  00001021   ADDU V0, ZERO, ZERO
311:                 			if (qwerty[i].code==(scancode&0xff)){
9D0077FC  30C600FF   ANDI A2, A2, 255
9D007800  1466004A   BNE V1, A2, 0x9D00792C
9D007804  3C029D01   LUI V0, -25343
9D007808  0B401E40   J 0x9D007900
9D00780C  00002821   ADDU A1, ZERO, ZERO
9D0078F0  14660010   BNE V1, A2, 0x9D007934
9D0078F4  24420004   ADDIU V0, V0, 4
9D007930  00002821   ADDU A1, ZERO, ZERO
312:                 				a=qwerty[i].ascii;
9D0078F8  0B401E41   J 0x9D007904
9D0078FC  00052880   SLL A1, A1, 2
9D007900  00052880   SLL A1, A1, 2
9D007904  3C029D01   LUI V0, -25343
9D007908  244240F8   ADDIU V0, V0, 16632
9D00790C  00452821   ADDU A1, V0, A1
9D007910  84A20002   LH V0, 2(A1)
313:                 				break;
314:                 			}
315:                 			i++;
316:                 		}// while (translate.code)
317:                 		if (a>='a' && a<='z' && (key_state & F_CAPS)){
9D007914  2443FF9F   ADDIU V1, V0, -97
9D007918  2C63001A   SLTIU V1, V1, 26
9D00791C  1460000A   BNE V1, ZERO, 0x9D007948
9D007920  2403FF00   ADDIU V1, ZERO, -256
9D00792C  244240FC   ADDIU V0, V0, 16636
9D007948  978580BC   LHU A1, -32580(GP)
9D00794C  30A50004   ANDI A1, A1, 4
318:                 			a -=32;
9D007950  2443FFE0   ADDIU V1, V0, -32
9D007954  0065100B   MOVN V0, V1, A1
319:                 		}
320:                 	}
321:                 	return a|(scancode&0xff00);
9D007924  0B401E58   J 0x9D007960
9D007928  00832024   AND A0, A0, V1
9D007958  2403FF00   ADDIU V1, ZERO, -256
9D00795C  00832024   AND A0, A0, V1
9D007960  00441025   OR V0, V0, A0
322:                 } // GetKey()
9D007964  03E00008   JR RA
9D007968  7C021620   SEH V0, V0
323:                 
324:                 void KbdSend(char cmd){  // envoie une commande au clavier
9D00796C  27BDFFD0   ADDIU SP, SP, -48
9D007970  AFBF002C   SW RA, 44(SP)
9D007974  AFB50028   SW S5, 40(SP)
9D007978  AFB40024   SW S4, 36(SP)
9D00797C  AFB30020   SW S3, 32(SP)
9D007980  AFB2001C   SW S2, 28(SP)
9D007984  AFB10018   SW S1, 24(SP)
9D007988  AFB00014   SW S0, 20(SP)
9D00798C  7C049420   SEB S2, A0
325:                     register unsigned int dly;
326:                     unsigned int t0;
327:                         bit_cnt=0;
9D007990  A3808036   SB ZERO, -32714(GP)
328:                 	parity=0;
9D007994  A3808037   SB ZERO, -32713(GP)
329:                 	IEC0CLR=_IEC0_INT4IE_MASK; // désactive les interruptions sur KBD_CLK
9D007998  3C030080   LUI V1, 128
9D00799C  3C02BF88   LUI V0, -16504
9D0079A0  AC431064   SW V1, 4196(V0)
330:                         TRISACLR = KBD_CLK; // MCU prend le contrôle de la ligne KBD_CLK
9D0079A4  3C11BF88   LUI S1, -16504
9D0079A8  24100001   ADDIU S0, ZERO, 1
9D0079AC  AE306014   SW S0, 24596(S1)
331:                         LATACLR = KBD_CLK; //  mis à 0  KBD_CLK
9D0079B0  3C13BF88   LUI S3, -16504
9D0079B4  AE706034   SW S0, 24628(S3)
332:                         // délais minimum 100µsec
333:                         delay_us(100);
9D0079B8  0F403E88   JAL delay_us
9D0079BC  24040064   ADDIU A0, ZERO, 100
334:                         TRISACLR = KBD_DAT;	// prend le contrôle de la ligne KBD_DAT
9D0079C0  24020002   ADDIU V0, ZERO, 2
9D0079C4  AE226014   SW V0, 24596(S1)
335:                 	LATACLR = KBD_DAT;   	// met KBD_DAT à zéro
9D0079C8  AE626034   SW V0, 24628(S3)
336:                 	TRISASET = KBD_CLK; 	// libère la ligne clock
9D0079CC  3C02BF88   LUI V0, -16504
9D0079D0  AC506018   SW S0, 24600(V0)
337:                         t0=ticks()+100;
9D0079D4  0F403E85   JAL ticks
9D0079D8  00000000   NOP
9D0079DC  24510064   ADDIU S1, V0, 100
338:                         while (!(PORTAbits.RA0)); // attend que la ligne revienne à 1
9D0079E0  3C03BF88   LUI V1, -16504
9D0079E4  8C626020   LW V0, 24608(V1)
9D0079E8  30420001   ANDI V0, V0, 1
9D0079EC  1040FFFD   BEQ V0, ZERO, 0x9D0079E4
9D0079F0  00000000   NOP
339:                         while (bit_cnt<8){      // envoie les 8 bits, le moins significatif en premier.
9D0079F4  93828036   LBU V0, -32714(GP)
9D0079F8  304200FF   ANDI V0, V0, 255
9D0079FC  2C420008   SLTIU V0, V0, 8
9D007A00  10400029   BEQ V0, ZERO, 0x9D007AA8
9D007A04  3C10BF88   LUI S0, -16504
9D007A94  93828036   LBU V0, -32714(GP)
9D007A98  304200FF   ANDI V0, V0, 255
9D007A9C  2C420008   SLTIU V0, V0, 8
9D007AA0  1440FFDC   BNE V0, ZERO, 0x9D007A14
9D007AA4  00129043   SRA S2, S2, 1
340:                 		while ((ticks()<t0) && PORTAbits.RA0);   // attend clock à 0
9D007A14  0F403E85   JAL ticks
9D007A18  00000000   NOP
9D007A1C  0051102B   SLTU V0, V0, S1
9D007A20  10400005   BEQ V0, ZERO, 0x9D007A38
9D007A24  00000000   NOP
9D007A28  8E026020   LW V0, 24608(S0)
9D007A2C  30420001   ANDI V0, V0, 1
9D007A30  1440FFF8   BNE V0, ZERO, 0x9D007A14
9D007A34  00000000   NOP
341:                                 if (ticks()>=t0) return; // pas de réponse du clavier. (pas de clavier!!)
9D007A38  0F403E85   JAL ticks
9D007A3C  00000000   NOP
9D007A40  0051102B   SLTU V0, V0, S1
9D007A44  10400048   BEQ V0, ZERO, 0x9D007B68
9D007A48  32420001   ANDI V0, S2, 1
342:                                 if (cmd&1){
9D007A4C  10400008   BEQ V0, ZERO, 0x9D007A70
9D007A50  00000000   NOP
343:                 			LATASET = KBD_DAT;
9D007A10  3C15BF88   LUI S5, -16504
9D007A54  AEB36038   SW S3, 24632(S5)
344:                 			parity++;
9D007A58  93828037   LBU V0, -32713(GP)
9D007A5C  24420001   ADDIU V0, V0, 1
9D007A60  304200FF   ANDI V0, V0, 255
9D007A64  A3828037   SB V0, -32713(GP)
9D007A68  0B401E9D   J 0x9D007A74
9D007A6C  00000000   NOP
345:                 		}else{
346:                 			LATACLR = KBD_DAT;
9D007A08  3C14BF88   LUI S4, -16504
9D007A0C  24130002   ADDIU S3, ZERO, 2
9D007A70  AE936034   SW S3, 24628(S4)
347:                 		}
348:                 		cmd >>= 1;
349:                 		while (!(PORTAbits.RA0)); // attend clock à 1
9D007A74  8E026020   LW V0, 24608(S0)
9D007A78  30420001   ANDI V0, V0, 1
9D007A7C  1040FFFD   BEQ V0, ZERO, 0x9D007A74
9D007A80  00000000   NOP
350:                 		bit_cnt++;				  // un bit de plus envoyé.
9D007A84  93828036   LBU V0, -32714(GP)
9D007A88  24420001   ADDIU V0, V0, 1
9D007A8C  304200FF   ANDI V0, V0, 255
9D007A90  A3828036   SB V0, -32714(GP)
351:                 	}
352:                         while (PORTAbits.RA0);   // attend clock à 0
9D007AA8  3C03BF88   LUI V1, -16504
9D007AAC  8C626020   LW V0, 24608(V1)
9D007AB0  30420001   ANDI V0, V0, 1
9D007AB4  1440FFFD   BNE V0, ZERO, 0x9D007AAC
9D007AB8  00000000   NOP
353:                 	if (!(parity & 1)){
9D007ABC  93828037   LBU V0, -32713(GP)
9D007AC0  30420001   ANDI V0, V0, 1
9D007AC4  14400005   BNE V0, ZERO, 0x9D007ADC
9D007AC8  24030002   ADDIU V1, ZERO, 2
354:                 		LATASET = KBD_DAT;
9D007ACC  3C02BF88   LUI V0, -16504
9D007AD0  AC436038   SW V1, 24632(V0)
355:                 	}else{
356:                 		LATACLR = KBD_DAT;
9D007ADC  3C02BF88   LUI V0, -16504
9D007AE0  AC436034   SW V1, 24628(V0)
357:                 	}
358:                 	while (!(PORTAbits.RA0)); // attend clock à 1
9D007AD4  0B401EBA   J 0x9D007AE8
9D007AD8  3C03BF88   LUI V1, -16504
9D007AE4  3C03BF88   LUI V1, -16504
9D007AE8  8C626020   LW V0, 24608(V1)
9D007AEC  30420001   ANDI V0, V0, 1
9D007AF0  1040FFFD   BEQ V0, ZERO, 0x9D007AE8
9D007AF4  00000000   NOP
359:                 	while (PORTAbits.RA0);   // attend clock à 0
9D007AF8  3C03BF88   LUI V1, -16504
9D007AFC  8C626020   LW V0, 24608(V1)
9D007B00  30420001   ANDI V0, V0, 1
9D007B04  1440FFFD   BNE V0, ZERO, 0x9D007AFC
9D007B08  3C02BF88   LUI V0, -16504
360:                 	TRISASET = KBD_DAT;  		// libère la ligne data
9D007B0C  24030002   ADDIU V1, ZERO, 2
9D007B10  AC436018   SW V1, 24600(V0)
361:                 	while (!(PORTAbits.RA0)); // attend clock à 1
9D007B14  3C03BF88   LUI V1, -16504
9D007B18  8C626020   LW V0, 24608(V1)
9D007B1C  30420001   ANDI V0, V0, 1
9D007B20  1040FFFD   BEQ V0, ZERO, 0x9D007B18
9D007B24  00000000   NOP
362:                 	while (PORTA & (KBD_DAT+KBD_CLK)); 	// attend que le clavier mette data et clock à 0
9D007B28  3C03BF88   LUI V1, -16504
9D007B2C  8C626020   LW V0, 24608(V1)
9D007B30  30420003   ANDI V0, V0, 3
9D007B34  1440FFFD   BNE V0, ZERO, 0x9D007B2C
9D007B38  3C04BF88   LUI A0, -16504
363:                 	while (!((PORTA & (KBD_DAT+KBD_CLK))==(KBD_DAT+KBD_CLK))); // attend que les 2 lignes reviennent à 1.
9D007B3C  24030003   ADDIU V1, ZERO, 3
9D007B40  8C826020   LW V0, 24608(A0)
9D007B44  30420003   ANDI V0, V0, 3
9D007B48  1443FFFD   BNE V0, V1, 0x9D007B40
9D007B4C  00000000   NOP
364:                 	bit_cnt=0;
9D007B50  A3808036   SB ZERO, -32714(GP)
365:                         IFS0CLR=_IFS0_INT4IF_MASK;
9D007B54  3C020080   LUI V0, 128
9D007B58  3C03BF88   LUI V1, -16504
9D007B5C  AC621034   SW V0, 4148(V1)
366:                 	IEC0SET = _IEC0_INT4IE_MASK; // réactivation interruption
9D007B60  3C03BF88   LUI V1, -16504
9D007B64  AC621068   SW V0, 4200(V1)
367:                 } // KbdSend()
9D007B68  8FBF002C   LW RA, 44(SP)
9D007B6C  8FB50028   LW S5, 40(SP)
9D007B70  8FB40024   LW S4, 36(SP)
9D007B74  8FB30020   LW S3, 32(SP)
9D007B78  8FB2001C   LW S2, 28(SP)
9D007B7C  8FB10018   LW S1, 24(SP)
9D007B80  8FB00014   LW S0, 20(SP)
9D007B84  03E00008   JR RA
9D007B88  27BD0030   ADDIU SP, SP, 48
368:                 
369:                 int SetKbdLeds(unsigned char leds_state){ // contrôle l'état des LEDS du clavier
9D007B8C  27BDFFE0   ADDIU SP, SP, -32
9D007B90  AFBF001C   SW RA, 28(SP)
9D007B94  AFB20018   SW S2, 24(SP)
9D007B98  AFB10014   SW S1, 20(SP)
9D007B9C  AFB00010   SW S0, 16(SP)
370:                     unsigned int t0;
371:                     short c;
372:                     t0=ticks()+100;
9D007BA0  0F403E85   JAL ticks
9D007BA4  309200FF   ANDI S2, A0, 255
9D007BA8  24510064   ADDIU S1, V0, 100
373:                     KbdSend(KBD_LED);
9D007BAC  0F401E5B   JAL KbdSend
9D007BB0  2404FFED   ADDIU A0, ZERO, -19
374:                     c=0;
375:                     while (!(ticks()==t0) && !(rx_flags & F_ERROR) && !c){
9D007BB4  0B401EF2   J 0x9D007BC8
9D007BB8  00008021   ADDU S0, ZERO, ZERO
9D007BC8  0F403E85   JAL ticks
9D007BCC  00000000   NOP
9D007BD0  10510007   BEQ V0, S1, 0x9D007BF0
9D007BD4  240200FA   ADDIU V0, ZERO, 250
9D007BD8  93828034   LBU V0, -32716(GP)
9D007BDC  30420001   ANDI V0, V0, 1
9D007BE0  14400003   BNE V0, ZERO, 0x9D007BF0
9D007BE4  240200FA   ADDIU V0, ZERO, 250
9D007BE8  1200FFF4   BEQ S0, ZERO, 0x9D007BBC
9D007BEC  00000000   NOP
376:                         c=KbdScancode();
9D007BBC  0F401F18   JAL KbdScancode
9D007BC0  00000000   NOP
9D007BC4  00408021   ADDU S0, V0, ZERO
377:                     }
378:                     if (c==KBD_ACK){
9D007BF0  16020015   BNE S0, V0, 0x9D007C48
9D007BF4  24020001   ADDIU V0, ZERO, 1
379:                         t0=ticks()+100;
9D007BF8  0F403E85   JAL ticks
9D007BFC  00008021   ADDU S0, ZERO, ZERO
9D007C00  24510064   ADDIU S1, V0, 100
380:                         KbdSend(leds_state);
9D007C04  0F401E5B   JAL KbdSend
9D007C08  7C122420   SEB A0, S2
381:                         c=0;
382:                         while (!(ticks()==t0) && !(rx_flags & F_ERROR) && !c){
9D007C0C  0B401F08   J 0x9D007C20
9D007C10  00000000   NOP
9D007C20  0F403E85   JAL ticks
9D007C24  00000000   NOP
9D007C28  10510007   BEQ V0, S1, 0x9D007C48
9D007C2C  24020001   ADDIU V0, ZERO, 1
9D007C30  93828034   LBU V0, -32716(GP)
9D007C34  30420001   ANDI V0, V0, 1
9D007C38  14400003   BNE V0, ZERO, 0x9D007C48
9D007C3C  24020001   ADDIU V0, ZERO, 1
9D007C40  1200FFF4   BEQ S0, ZERO, 0x9D007C14
9D007C44  00000000   NOP
383:                             c=KbdScancode();
9D007C14  0F401F18   JAL KbdScancode
9D007C18  00000000   NOP
9D007C1C  00408021   ADDU S0, V0, ZERO
384:                         }
385:                     }
386:                     if (c=KBD_ACK)
387:                         return 1;
388:                     else
389:                         return 0;
390:                 } // SetKbdLeds()
9D007C48  8FBF001C   LW RA, 28(SP)
9D007C4C  8FB20018   LW S2, 24(SP)
9D007C50  8FB10014   LW S1, 20(SP)
9D007C54  8FB00010   LW S0, 16(SP)
9D007C58  03E00008   JR RA
9D007C5C  27BD0020   ADDIU SP, SP, 32
391:                 
392:                 void __ISR(_EXTERNAL_4_VECTOR,IPL6SOFT) kbd_clk_isr(void){
9D008390  415DE800   RDPGPR SP, SP
9D008394  401A7000   MFC0 K0, EPC
9D008398  401B6000   MFC0 K1, Status
9D00839C  27BDFFE0   ADDIU SP, SP, -32
9D0083A0  AFBA001C   SW K0, 28(SP)
9D0083A4  401A6002   MFC0 K0, SRSCtl
9D0083A8  AFBB0018   SW K1, 24(SP)
9D0083AC  AFBA0014   SW K0, 20(SP)
9D0083B0  7C1B7844   INS K1, ZERO, 1, 15
9D0083B4  377B1800   ORI K1, K1, 6144
9D0083B8  409B6000   MTC0 K1, Status
9D0083BC  AFA4000C   SW A0, 12(SP)
9D0083C0  AFA30008   SW V1, 8(SP)
9D0083C4  AFA20004   SW V0, 4(SP)
393:                 	switch (bit_cnt){
9D0083C8  93828036   LBU V0, -32714(GP)
9D0083CC  304200FF   ANDI V0, V0, 255
9D0083D0  24030009   ADDIU V1, ZERO, 9
9D0083D4  10430010   BEQ V0, V1, 0x9D008418
9D0083D8  2403000A   ADDIU V1, ZERO, 10
9D0083DC  10430028   BEQ V0, V1, 0x9D008480
9D0083E0  00000000   NOP
9D0083E4  1440003B   BNE V0, ZERO, 0x9D0084D4
9D0083E8  3C02BF88   LUI V0, -16504
394:                 	case 0:   // start bit
395:                 		if (!(PORTA & KBD_DAT)){
9D0083EC  8C426020   LW V0, 24608(V0)
9D0083F0  30420002   ANDI V0, V0, 2
9D0083F4  5440004C   BNEL V0, ZERO, 0x9D008528
9D0083F8  3C030080   LUI V1, 128
396:                                     parity=0;
9D0083FC  A3808037   SB ZERO, -32713(GP)
397:                                     bit_cnt++;
9D008400  93828036   LBU V0, -32714(GP)
9D008404  24420001   ADDIU V0, V0, 1
9D008408  304200FF   ANDI V0, V0, 255
9D00840C  A3828036   SB V0, -32714(GP)
398:                                 }
399:                 		break;
400:                 	case 9:   // paritée
401:                 		if (PORTA & KBD_DAT)
9D008418  3C02BF88   LUI V0, -16504
9D00841C  8C426020   LW V0, 24608(V0)
9D008420  30420002   ANDI V0, V0, 2
9D008424  10400005   BEQ V0, ZERO, 0x9D00843C
9D008428  00000000   NOP
402:                 			parity++;
9D00842C  93828037   LBU V0, -32713(GP)
9D008430  24420001   ADDIU V0, V0, 1
9D008434  304200FF   ANDI V0, V0, 255
9D008438  A3828037   SB V0, -32713(GP)
403:                 		if (!(parity & 1)){
9D00843C  93828037   LBU V0, -32713(GP)
9D008440  30420001   ANDI V0, V0, 1
9D008444  14400008   BNE V0, ZERO, 0x9D008468
9D008448  00000000   NOP
404:                 			rx_flags |= F_ERROR;
9D00844C  93828034   LBU V0, -32716(GP)
9D008450  304200FF   ANDI V0, V0, 255
9D008454  34420001   ORI V0, V0, 1
9D008458  A3828034   SB V0, -32716(GP)
405:                                         IEC0CLR = _IEC0_INT4IE_MASK; // désactive l'interruption
9D00845C  3C030080   LUI V1, 128
9D008460  3C02BF88   LUI V0, -16504
9D008464  AC431064   SW V1, 4196(V0)
406:                 		}
407:                 		bit_cnt++;
9D008468  93828036   LBU V0, -32714(GP)
9D00846C  24420001   ADDIU V0, V0, 1
9D008470  304200FF   ANDI V0, V0, 255
9D008474  A3828036   SB V0, -32714(GP)
408:                 		break;
9D008478  0B40214A   J 0x9D008528
9D00847C  3C030080   LUI V1, 128
409:                 	case 10:  // stop bit
410:                 		kbd_queue[tail]=in_byte;
9D008480  93848038   LBU A0, -32712(GP)
9D008484  308400FF   ANDI A0, A0, 255
9D008488  93838039   LBU V1, -32711(GP)
9D00848C  3C02A000   LUI V0, -24576
9D008490  24422B1C   ADDIU V0, V0, 11036
9D008494  00821021   ADDU V0, A0, V0
9D008498  A0430000   SB V1, 0(V0)
411:                 		tail++;
9D00849C  93828038   LBU V0, -32712(GP)
9D0084A0  24420001   ADDIU V0, V0, 1
9D0084A4  304200FF   ANDI V0, V0, 255
9D0084A8  A3828038   SB V0, -32712(GP)
412:                 		tail &=31;
9D0084AC  93828038   LBU V0, -32712(GP)
9D0084B0  3042001F   ANDI V0, V0, 31
9D0084B4  A3828038   SB V0, -32712(GP)
413:                 		bit_cnt=0;
9D0084B8  A3808036   SB ZERO, -32714(GP)
414:                 		rx_flags |= F_RCVD;
9D0084BC  93828034   LBU V0, -32716(GP)
9D0084C0  304200FF   ANDI V0, V0, 255
9D0084C4  34420002   ORI V0, V0, 2
9D0084C8  A3828034   SB V0, -32716(GP)
415:                 		break;
9D0084CC  0B40214A   J 0x9D008528
9D0084D0  3C030080   LUI V1, 128
416:                 	default:
417:                 		in_byte >>=1;
9D0084D4  93828039   LBU V0, -32711(GP)
9D0084D8  7C423040   EXT V0, V0, 1, 7
9D0084DC  A3828039   SB V0, -32711(GP)
418:                 		if(PORTA & KBD_DAT){
9D0084E0  3C02BF88   LUI V0, -16504
9D0084E4  8C426020   LW V0, 24608(V0)
9D0084E8  30420002   ANDI V0, V0, 2
9D0084EC  10400009   BEQ V0, ZERO, 0x9D008514
9D0084F0  00000000   NOP
419:                 			in_byte |=128;
9D0084F4  93828039   LBU V0, -32711(GP)
9D0084F8  3042007F   ANDI V0, V0, 127
9D0084FC  34420080   ORI V0, V0, 128
9D008500  A3828039   SB V0, -32711(GP)
420:                 			parity++;
9D008504  93828037   LBU V0, -32713(GP)
9D008508  24420001   ADDIU V0, V0, 1
9D00850C  304200FF   ANDI V0, V0, 255
9D008510  A3828037   SB V0, -32713(GP)
421:                 		}
422:                 		bit_cnt++;
9D008514  93828036   LBU V0, -32714(GP)
9D008518  24420001   ADDIU V0, V0, 1
9D00851C  304200FF   ANDI V0, V0, 255
9D008520  A3828036   SB V0, -32714(GP)
423:                 	}
424:                         mINT4ClearIntFlag();
9D008410  0B40214A   J 0x9D008528
9D008414  3C030080   LUI V1, 128
9D008524  3C030080   LUI V1, 128
9D008528  3C02BF88   LUI V0, -16504
9D00852C  AC431034   SW V1, 4148(V0)
425:                 } // kbd_clk_isr()
9D008530  8FA4000C   LW A0, 12(SP)
9D008534  8FA30008   LW V1, 8(SP)
9D008538  8FA20004   LW V0, 4(SP)
9D00853C  41606000   DI ZERO
9D008540  000000C0   EHB
9D008544  8FBA001C   LW K0, 28(SP)
9D008548  8FBB0018   LW K1, 24(SP)
9D00854C  409A7000   MTC0 K0, EPC
9D008550  8FBA0014   LW K0, 20(SP)
9D008554  27BD0020   ADDIU SP, SP, 32
9D008558  409A6002   MTC0 K0, SRSCtl
9D00855C  41DDE800   WRPGPR SP, SP
9D008560  409B6000   MTC0 K1, Status
9D008564  42000018   ERET
426:                 
427:                 
---  /home/jacques/MPLABXProjects/vpc-32/hardware/Pinguino/sdmmc.c  -------------------------------------
1:                   /*
2:                   ** SDMMC.c SD card interface
3:                   **
4:                   ** 7/20/06 v1.4 LDJ
5:                   ** 7/14/07 v2.0 LDJ
6:                   **
7:                   [30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
8:                   ** 07 May 2012	Changes made to allow SD card library to support
9:                   **					PIC32 Pinguino and PIC32 Pinguino Micro that have neither
10:                  **					SD card presence nor WP switch detection switches.
11:                  **					see functions getCD() and getWP() below.
12:                  */
13:                  /*
14:                   *  adapted to VPC-32 project by Jacques Deschênes 2013,2014
15:                   */
16:                  
17:                  #ifndef __SDMMC_C__
18:                  #define __SDMMC_C__
19:                  
20:                  //#include <system.c>
21:                  //#include <digitalw.c>
22:                  //#include <spi.c>        // in order to use default SPI port
23:                  #include <plib.h>
24:                  #include "sdmmc.h"
25:                  //#include "diskio.h"
26:                  //#include "ff.h"
27:                  
28:                  
29:                  void initSD(void)
30:                  {
9D011234  27BDFFE8   ADDIU SP, SP, -24
9D011238  AFBF0014   SW RA, 20(SP)
31:                      if (!store_initialized) store_spi_init();
9D01123C  93828040   LBU V0, -32704(GP)
9D011240  14400004   BNE V0, ZERO, 0x9D011254
9D011244  8FBF0014   LW RA, 20(SP)
9D011248  0F405AF5   JAL store_spi_init
9D01124C  00000000   NOP
32:                  
33:                  //    PORTB |=SDCSEL; //digitalwrite(SDCSEL, HIGH);	// initially keep the SD card disabled
34:                  //	TRISB &=~SDCSEL; //pinmode(SDCSEL, OUTPUT);		// make Card select an output pin
35:                  //
36:                  //	// init the spi module for a slow (safe) clock speed first
37:                  //
38:                  //	SPI2CON = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
39:                  //	SPI2BRG = (mGetPeripheralClock() / (2 * 10000000)) - 1; // 10Mbits/sec
40:                  
41:                  }   // initSD
9D011250  8FBF0014   LW RA, 20(SP)
9D011254  03E00008   JR RA
9D011258  27BD0018   ADDIU SP, SP, 24
42:                  
43:                  
44:                  #define readSPI()   writeSPI(0xFF)
45:                  #define clockSPI()  writeSPI(0xFF)
46:                  
47:                  void disableSD(void)
48:                  {
9D01125C  27BDFFE8   ADDIU SP, SP, -24
9D011260  AFBF0014   SW RA, 20(SP)
49:                  
50:                     _sdc_disable(); 
9D011264  24030004   ADDIU V1, ZERO, 4
9D011268  3C02BF88   LUI V0, -16504
9D01126C  AC436128   SW V1, 24872(V0)
51:                     clockSPI();
9D011270  0F405B0A   JAL writeSPI
9D011274  240400FF   ADDIU A0, ZERO, 255
52:                     _status_off();
9D011278  24030008   ADDIU V1, ZERO, 8
9D01127C  3C02BF88   LUI V0, -16504
9D011280  AC436124   SW V1, 24868(V0)
53:                  }
9D011284  8FBF0014   LW RA, 20(SP)
9D011288  03E00008   JR RA
9D01128C  27BD0018   ADDIU SP, SP, 24
54:                  
55:                  void enableSD(void)
56:                  {
57:                      _status_on();
9D011290  24030008   ADDIU V1, ZERO, 8
9D011294  3C02BF88   LUI V0, -16504
9D011298  AC436128   SW V1, 24872(V0)
58:                      _sdc_enable();
9D01129C  24030004   ADDIU V1, ZERO, 4
9D0112A0  3C02BF88   LUI V0, -16504
9D0112A4  AC436124   SW V1, 24868(V0)
59:                  
60:                  }
9D0112A8  03E00008   JR RA
9D0112AC  00000000   NOP
61:                  
62:                  // c    command code
63:                  // a    byte address of data block
64:                  int sendSDCmd(unsigned char c, unsigned a)
65:                  {
9D0112B0  27BDFFE0   ADDIU SP, SP, -32
9D0112B4  AFBF001C   SW RA, 28(SP)
9D0112B8  AFB10018   SW S1, 24(SP)
9D0112BC  AFB00014   SW S0, 20(SP)
9D0112C0  00A08821   ADDU S1, A1, ZERO
66:                  	int i, r;
67:                  
68:                  	// enable SD card
69:                  	// CS low
70:                  	enableSD();
9D0112C4  0F4044A4   JAL enableSD
9D0112C8  309000FF   ANDI S0, A0, 255
71:                  
72:                  	// send a comand packet (6 bytes)
73:                  	writeSPI(c | 0x40);    // send command
9D0112CC  0F405B0A   JAL writeSPI
9D0112D0  36040040   ORI A0, S0, 64
74:                  	writeSPI(a>>24);       // msb of the address
9D0112D4  0F405B0A   JAL writeSPI
9D0112D8  00112602   SRL A0, S1, 24
75:                  	writeSPI(a>>16);
9D0112DC  0F405B0A   JAL writeSPI
9D0112E0  7E243C00   EXT A0, S1, 16, 8
76:                  	writeSPI(a>>8);
9D0112E4  0F405B0A   JAL writeSPI
9D0112E8  7E243A00   EXT A0, S1, 8, 8
77:                  	writeSPI(a);           // lsb
9D0112EC  0F405B0A   JAL writeSPI
9D0112F0  322400FF   ANDI A0, S1, 255
78:                  
79:                  	writeSPI(0x95);        // send CMD0 CRC
9D0112F4  0F405B0A   JAL writeSPI
9D0112F8  24040095   ADDIU A0, ZERO, 149
9D0112FC  24100008   ADDIU S0, ZERO, 8
80:                  
81:                  	// now wait for a response, allow for up to 8 bytes delay
82:                  	for(i=0; i<8; i++)
9D011314  1600FFFA   BNE S0, ZERO, 0x9D011300
9D011318  00000000   NOP
83:                  	{
84:                  		r = readSPI();
9D011300  0F405B0A   JAL writeSPI
9D011304  240400FF   ADDIU A0, ZERO, 255
85:                  		if (r != 0xFF)
9D011308  240300FF   ADDIU V1, ZERO, 255
9D01130C  14430003   BNE V0, V1, 0x9D01131C
9D011310  2610FFFF   ADDIU S0, S0, -1
86:                  			break;
87:                  	}
88:                  	return (r);
89:                  
90:                  	/* return response
91:                  	FF - timeout
92:                  	00 - command accepted
93:                  	01 - command received, card in idle state after RESET
94:                  
95:                  	other codes:
96:                  	bit 0 = Idle state
97:                  	bit 1 = Erase Reset
98:                  	bit 2 = Illegal command
99:                  	bit 3 = Communication CRC error
100:                 	bit 4 = Erase sequence error
101:                 	bit 5 = Address error
102:                 	bit 6 = Parameter error
103:                 	bit 7 = Always 0
104:                 	*/
105:                 	// NOTE CSCD is still low!
106:                 } // sendSDCmd
9D01131C  8FBF001C   LW RA, 28(SP)
9D011320  8FB10018   LW S1, 24(SP)
9D011324  8FB00014   LW S0, 20(SP)
9D011328  03E00008   JR RA
9D01132C  27BD0020   ADDIU SP, SP, 32
107:                 
108:                 
109:                 // returns 0 if successful
110:                 //          E_COMMAND_ACK   failed to acknowledge reset command
111:                 //          E_INIT_TIMEOUT  failed to initialize
112:                 int initMedia(void)
113:                 {
9D011330  27BDFFE0   ADDIU SP, SP, -32
9D011334  AFBF001C   SW RA, 28(SP)
9D011338  AFB10018   SW S1, 24(SP)
114:                 	int i, r;
115:                 
116:                 	// 1. with the card NOT selected
117:                 	// Set DI and CS high
118:                 	disableSD();
9D01133C  0F404497   JAL disableSD
9D011340  AFB00014   SW S0, 20(SP)
119:                 
120:                 	// 2. send 74 or more clock cycles to start up
121:                 	// apply 74 or more clock pulses to SCLK.
122:                 	// The card will enter its native operating mode and go ready to accept native commands.
123:                 	for (i=0; i<10; i++)
9D011344  00008021   ADDU S0, ZERO, ZERO
9D011348  2411000A   ADDIU S1, ZERO, 10
9D011354  26100001   ADDIU S0, S0, 1
9D011358  1611FFFC   BNE S0, S1, 0x9D01134C
9D01135C  00000000   NOP
124:                 		clockSPI();
9D01134C  0F405B0A   JAL writeSPI
9D011350  240400FF   ADDIU A0, ZERO, 255
125:                 
126:                 	// 3. now select the card
127:                 	enableSD();
9D011360  0F4044A4   JAL enableSD
9D011364  00000000   NOP
128:                 
129:                 	//card detection is now in disk_initialize()
130:                 
131:                 	return 0;
132:                 } // init media
9D011368  00001021   ADDU V0, ZERO, ZERO
9D01136C  8FBF001C   LW RA, 28(SP)
9D011370  8FB10018   LW S1, 24(SP)
9D011374  8FB00014   LW S0, 20(SP)
9D011378  03E00008   JR RA
9D01137C  27BD0020   ADDIU SP, SP, 32
133:                 
134:                 
135:                 // a        LBA of sector requested
136:                 // p        pointer to sector buffer
137:                 // returns  TRUE if successful
138:                 int readSECTOR(LBA a, char *p)
139:                 {
9D011380  27BDFFD8   ADDIU SP, SP, -40
9D011384  AFBF0024   SW RA, 36(SP)
9D011388  AFB40020   SW S4, 32(SP)
9D01138C  AFB3001C   SW S3, 28(SP)
9D011390  AFB20018   SW S2, 24(SP)
9D011394  AFB10014   SW S1, 20(SP)
9D011398  AFB00010   SW S0, 16(SP)
9D01139C  00A08821   ADDU S1, A1, ZERO
140:                 	int r, i;
141:                 
142:                 	#ifdef READ_LED
143:                         _read_off();
144:                 	//digitalwrite(READ_LED, 0);
145:                 	#endif
146:                 
147:                 	// 1. send READ command
148:                 	r = sendSDCmd(READ_SINGLE, (a << 9));
9D0113A0  00042A40   SLL A1, A0, 9
9D0113A4  0F4044AC   JAL sendSDCmd
9D0113A8  24040011   ADDIU A0, ZERO, 17
149:                 	if (r == 0)    // check if command was accepted
9D0113AC  1440001A   BNE V0, ZERO, 0x9D011418
9D0113B0  00409021   ADDU S2, V0, ZERO
9D0113B4  00008021   ADDU S0, ZERO, ZERO
150:                 	{
151:                 	// 2. wait for a response
152:                 	for(i=0; i<R_TIMEOUT; i++)
9D0113BC  241461A8   ADDIU S4, ZERO, 25000
9D0113D0  26100001   ADDIU S0, S0, 1
9D0113D4  1614FFFA   BNE S0, S4, 0x9D0113C0
9D0113D8  00000000   NOP
9D0113DC  0B404506   J 0x9D011418
9D0113E0  00000000   NOP
153:                 	{
154:                 	r = readSPI();
9D0113C0  0F405B0A   JAL writeSPI
9D0113C4  240400FF   ADDIU A0, ZERO, 255
155:                 	if (r == DATA_START)
9D0113B8  241300FE   ADDIU S3, ZERO, 254
9D0113C8  10530006   BEQ V0, S3, 0x9D0113E4
9D0113CC  00409021   ADDU S2, V0, ZERO
156:                 	break;
157:                 	}
158:                 
159:                 	// 3. if it did not timeout, read 512 byte of data
160:                 	if (i != R_TIMEOUT)
9D0113E4  240261A8   ADDIU V0, ZERO, 25000
9D0113E8  1202000B   BEQ S0, V0, 0x9D011418
9D0113EC  26300200   ADDIU S0, S1, 512
161:                 	{
162:                 		i = 512;
163:                 		do{
164:                 			*p++ = readSPI();
9D0113F0  0F405B0A   JAL writeSPI
9D0113F4  240400FF   ADDIU A0, ZERO, 255
9D0113F8  A2220000   SB V0, 0(S1)
9D0113FC  26310001   ADDIU S1, S1, 1
165:                 		} while (--i>0);
9D011400  1630FFFB   BNE S1, S0, 0x9D0113F0
9D011404  00000000   NOP
166:                 
167:                 		// 4. ignore CRC
168:                 		readSPI();
9D011408  0F405B0A   JAL writeSPI
9D01140C  240400FF   ADDIU A0, ZERO, 255
169:                 		readSPI();
9D011410  0F405B0A   JAL writeSPI
9D011414  240400FF   ADDIU A0, ZERO, 255
170:                 
171:                 	} // data arrived
172:                 
173:                 	} // command accepted
174:                 
175:                 	// 5. remember to disable the card
176:                 	disableSD();
9D011418  0F404497   JAL disableSD
9D01141C  00000000   NOP
177:                 
178:                 	#ifdef READ_LED
179:                         _read_on();
180:                 	//digital(READ_LED, 1);
181:                 	#endif
182:                 
183:                 	return (r == DATA_START);    // return TRUE if successful
9D011420  3A4200FE   XORI V0, S2, 254
184:                 } // readSECTOR
9D011424  2C420001   SLTIU V0, V0, 1
9D011428  8FBF0024   LW RA, 36(SP)
9D01142C  8FB40020   LW S4, 32(SP)
9D011430  8FB3001C   LW S3, 28(SP)
9D011434  8FB20018   LW S2, 24(SP)
9D011438  8FB10014   LW S1, 20(SP)
9D01143C  8FB00010   LW S0, 16(SP)
9D011440  03E00008   JR RA
9D011444  27BD0028   ADDIU SP, SP, 40
185:                 
186:                 
187:                 // a        LBA of sector requested
188:                 // p        pointer to sector buffer
189:                 // returns  TRUE if successful
190:                 int writeSECTOR(LBA a, char *p)
9D01147C  26110200   ADDIU S1, S0, 512
191:                 {
9D011448  27BDFFE0   ADDIU SP, SP, -32
9D01144C  AFBF001C   SW RA, 28(SP)
9D011450  AFB20018   SW S2, 24(SP)
9D011454  AFB10014   SW S1, 20(SP)
9D011458  AFB00010   SW S0, 16(SP)
9D01145C  00A08021   ADDU S0, A1, ZERO
192:                 	unsigned r, i;
193:                 
194:                 	// 0. check Write Protect
195:                 //	if (getWP())
196:                 //		return FAIL;
197:                 
198:                 	// 1. send WRITE command
199:                 	r = sendSDCmd(WRITE_SINGLE, (a << 9));
9D011460  00042A40   SLL A1, A0, 9
9D011464  0F4044AC   JAL sendSDCmd
9D011468  24040018   ADDIU A0, ZERO, 24
200:                 	if (r == 0)    // check if command was accepted
9D01146C  1440001B   BNE V0, ZERO, 0x9D0114DC
9D011470  00409021   ADDU S2, V0, ZERO
201:                 	{
202:                 		// 2. send data
203:                 		writeSPI(DATA_START);
9D011474  0F405B0A   JAL writeSPI
9D011478  240400FE   ADDIU A0, ZERO, 254
204:                 
205:                 		// send 512 bytes of data
206:                 		for(i=0; i<512; i++)
9D01148C  5611FFFD   BNEL S0, S1, 0x9D011484
9D011490  92040000   LBU A0, 0(S0)
207:                 		writeSPI(*p++);
9D011480  92040000   LBU A0, 0(S0)
9D011484  0F405B0A   JAL writeSPI
9D011488  26100001   ADDIU S0, S0, 1
208:                 
209:                 		// 3. send dummy CRC
210:                 		clockSPI();
9D011494  0F405B0A   JAL writeSPI
9D011498  240400FF   ADDIU A0, ZERO, 255
211:                 		clockSPI();
9D01149C  0F405B0A   JAL writeSPI
9D0114A0  240400FF   ADDIU A0, ZERO, 255
212:                 
213:                 		// 4. check if data accepted
214:                 		r = readSPI();
9D0114A4  0F405B0A   JAL writeSPI
9D0114A8  240400FF   ADDIU A0, ZERO, 255
215:                 		if ((r & 0xf) == DATA_ACCEPT)
9D0114AC  3042000F   ANDI V0, V0, 15
9D0114B0  24030005   ADDIU V1, ZERO, 5
9D0114B4  14430009   BNE V0, V1, 0x9D0114DC
9D0114B8  3C100003   LUI S0, 3
9D0114BC  3610D090   ORI S0, S0, -12144
216:                 		{
217:                 			#ifdef WRITE_LED
218:                                         _write_off();
219:                 			//digitalwrite(WRITE_LED, 0);
220:                 			#endif
221:                 
222:                 			// 5. wait for write completion
223:                 			for(i=0; i<W_TIMEOUT; i++)
9D0114D4  1600FFFA   BNE S0, ZERO, 0x9D0114C0
9D0114D8  00000000   NOP
224:                 			{
225:                 				r = readSPI();
9D0114C0  0F405B0A   JAL writeSPI
9D0114C4  240400FF   ADDIU A0, ZERO, 255
226:                 				if (r != 0 )
9D0114C8  14400004   BNE V0, ZERO, 0x9D0114DC
9D0114CC  00409021   ADDU S2, V0, ZERO
9D0114D0  2610FFFF   ADDIU S0, S0, -1
227:                 					break;
228:                 			}
229:                 			#ifdef WRITE_LED
230:                                         _write_on();
231:                 			//digitalwrite(WRITE_LED, 1);
232:                 			#endif
233:                 		} // accepted
234:                 		else
235:                 		{
236:                 			r = FAIL;
237:                 		}
238:                 	} // command accepted
239:                 
240:                 	// 6. disable the card
241:                 	disableSD();
9D0114DC  0F404497   JAL disableSD
9D0114E0  00000000   NOP
242:                 
243:                 	return (r);      // return TRUE if successful
244:                 } // writeSECTOR
9D0114E4  02401021   ADDU V0, S2, ZERO
9D0114E8  8FBF001C   LW RA, 28(SP)
9D0114EC  8FB20018   LW S2, 24(SP)
9D0114F0  8FB10014   LW S1, 20(SP)
9D0114F4  8FB00010   LW S0, 16(SP)
9D0114F8  03E00008   JR RA
9D0114FC  27BD0020   ADDIU SP, SP, 32
245:                 
246:                 
247:                 // SD card connector presence detection switch
248:                 // returns  TRUE card present
249:                 //          FALSE card not present
250:                 int getCD(void)
251:                 {
252:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
253:                 // 2013-09-05 ** added support for VPC_32
254:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined (EMPEROR460) || defined(VPC_32)
255:                 	return TRUE;
256:                 #else
257:                 	return (SDCD);
258:                 #endif
259:                 }
9D011500  03E00008   JR RA
9D011504  24020001   ADDIU V0, ZERO, 1
260:                 
261:                 // card Write Protect tab detection switch
262:                 // returns  TRUE write protect tab on LOCK
263:                 //          FALSE write protection tab OPEN
264:                 int getWP(void)
265:                 {
266:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
267:                 // 2013-09-05 ** added support for VPC_32
268:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined(EMPEROR460) || defined (VPC_32)
269:                 	return FALSE;
270:                 #else
271:                 	return (SDWP);
272:                 #endif
273:                 }
9D011508  03E00008   JR RA
9D01150C  00001021   ADDU V0, ZERO, ZERO
274:                 
275:                 #endif /* __SDMMC_C__ */
---  /home/jacques/MPLABXProjects/vpc-32/hardware/Pinguino/fileio.c  ------------------------------------
1:                   /*	----------------------------------------------------------------------------
2:                   	FILE:			fileio.c
3:                   	PROJECT:		pinguino32
4:                   	PURPOSE:		SD Card file system functions
5:                   	AUTHORS:		Alfred Broda <alfredbroda@gmail.com>
6:                   					Mark Harper <markfh@f2s.com>
7:                   					Regis Blanchot <rblanchot@gmail.com>
8:                   	FIRST RELEASE:	23 dec. 2011
9:                   	LAST RELEASE:	06 jan. 2012
10:                  	----------------------------------------------------------------------------
11:                  	based on original code by Regis Blanchot and FatFS example for PIC24
12:                  	----------------------------------------------------------------------------
13:                   	[30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
14:                  	07 May 2012	As part of providing support for PIC32 Pinguino Micro and
15:                  					potentially other cards removed #if defined (PIC32_Pinguino) etc
16:                  					and #endif in function mount() so that SDCS is set via mount 
17:                  					for all cards.
18:                  */
19:                  
20:                  #ifndef __FILEIO_C__
21:                  #define __FILEIO_C__
22:                  
23:                  // standard C libraries used
24:                  #include <ctype.h>      		// toupper...
25:                  #include <string.h>     		// memcpy...
26:                  //#include <malloc.h>				// malloc, free?
27:                  #include <GenericTypeDefs.h>
28:                  
29:                  #include "fileio.h"
30:                  #include "sdmmc.h"
31:                  #include "ff.h"					// Fat Filesystem
32:                  #include "diskio.h"				// card access functions
33:                  #include "../serial_comm/serial_comm.h"
34:                  #include "../../console.h"
35:                  
36:                  //#define SD_DEBUG
37:                  
38:                  //#ifdef SD_DEBUG
39:                  //    #include <__cdc.c>          // USB CDC functions
40:                  //#endif
41:                  
42:                  /*	----------------------------------------------------------------------------
43:                   mount
44:                   initializes a MEDIA structure for FILEIO access
45:                   will mount only the first partition on the disk/card
46:                   --------------------------------------------------------------------------*/
47:                  
48:                  BOOL SDCardReady;
49:                  
50:                  static FATFS _Fat;
51:                  
52:                  char mount(unsigned char pin) {
9D00E818  27BDFFE0   ADDIU SP, SP, -32
9D00E81C  AFBF001C   SW RA, 28(SP)
53:                  	int flag, i;
54:                  	FRESULT r;
55:                  
56:                  	SDCS = pin;
57:                  
58:                  	// 0. init the I/Os
59:                  	initSD();
9D00E820  0F40448D   JAL initSD
9D00E824  A3848114   SB A0, -32492(GP)
60:                  
61:                  #ifdef SD_DEBUG
62:                  	UartPrint(STDOUT,"Looking for SD slot... ");
63:                  #endif
64:                  	// 1. check if the card is in the slot
65:                  	if (!getCD()) {
9D00E828  0F404540   JAL getCD
9D00E82C  00000000   NOP
9D00E830  14400004   BNE V0, ZERO, 0x9D00E844
9D00E834  24020002   ADDIU V0, ZERO, 2
66:                  		FError = FE_NOT_PRESENT;
9D00E838  A3828108   SB V0, -32504(GP)
67:                  #ifdef SD_DEBUG
68:                  		UartPrint(STDOUT, "Failed!\r");
69:                  #endif
70:                  		return FALSE;
9D00E83C  0B403A2D   J 0x9D00E8B4
9D00E840  00001821   ADDU V1, ZERO, ZERO
71:                  	}
72:                  #ifdef SD_DEBUG
73:                  	UartPrint(STDOUT,"OK\r");
74:                  #endif
75:                  
76:                  	// 2. initialize the card
77:                  #ifdef SD_DEBUG
78:                  	UartPrint(STDOUT,"Initializing SD card... ");
79:                  #endif
80:                  	initMedia();
9D00E844  0F4044CC   JAL initMedia
9D00E848  00000000   NOP
81:                          if (disk_initialize(0)==STA_NOINIT){
9D00E84C  0F40250F   JAL disk_initialize
9D00E850  00002021   ADDU A0, ZERO, ZERO
9D00E854  24040001   ADDIU A0, ZERO, 1
9D00E858  10440016   BEQ V0, A0, 0x9D00E8B4
9D00E85C  00001821   ADDU V1, ZERO, ZERO
82:                  #ifdef SD_DEBUG
83:                              UartPrint(STDOUT,"failed!\r");
84:                  #endif
85:                              return 0;
86:                          };
87:                  #ifdef SD_DEBUG
88:                          UartPrint(STDOUT,"OK\r");
89:                  #endif
90:                  	// We're skipping the old step 3 because there's no need for malloc
91:                  	// This takes 6k off the code size if malloc is not used elsewhere.
92:                  	// Instead, just point it to our _Fat var.
93:                  	// The FATFS struct takes only 560 bytes of mem.
94:                  	Fat = &_Fat;
9D00E860  3C05A000   LUI A1, -24576
9D00E864  24A52238   ADDIU A1, A1, 8760
9D00E868  AF85810C   SW A1, -32500(GP)
95:                  
96:                  	// Mount media
97:                  #ifdef SD_DEBUG
98:                  	UartPrint(STDOUT,"Mounting FAT filesystem... ");
99:                  #endif
100:                 	r = f_mount(0, Fat);
9D00E86C  0F40065D   JAL f_mount
9D00E870  00002021   ADDU A0, ZERO, ZERO
101:                 	if (r != FR_OK) {
9D00E874  10400003   BEQ V0, ZERO, 0x9D00E884
9D00E878  00001821   ADDU V1, ZERO, ZERO
102:                 		FError = r;
103:                 #ifdef SD_DEBUG
104:                 		UartPrint(STDOUT,"Failed!\r");
105:                 #endif
106:                 		//free(Fat);
107:                 		return FALSE;
9D00E87C  0B403A2D   J 0x9D00E8B4
9D00E880  A3828108   SB V0, -32504(GP)
108:                 	}
109:                 #ifdef SD_DEBUG
110:                 	UartPrint(STDOUT, "OK\r");
111:                 #endif
112:                 
113:                 #ifdef SD_DEBUG
114:                 	UartPrint(STDOUT,"Checking FAT filesystem... ");
115:                 #endif
116:                 	const TCHAR * pth = "/";
9D00E884  3C029D01   LUI V0, -25343
9D00E888  24425F48   ADDIU V0, V0, 24392
9D00E88C  AFA20010   SW V0, 16(SP)
117:                 	r = chk_mounted(&pth, &Fat, 0);
9D00E890  27A40010   ADDIU A0, SP, 16
9D00E894  2785810C   ADDIU A1, GP, -32500
9D00E898  0F400529   JAL chk_mounted
9D00E89C  00003021   ADDU A2, ZERO, ZERO
118:                 	if (r != FR_OK) {
9D00E8A0  10400004   BEQ V0, ZERO, 0x9D00E8B4
9D00E8A4  24030001   ADDIU V1, ZERO, 1
119:                 		FError = r;
120:                 #ifdef SD_DEBUG
121:                 		UartPrint(STDOUT, "Failed!\r");
122:                                  //put_rc(r);
123:                 #endif
124:                 		unmount();
9D00E8A8  0F4039FB   JAL unmount
9D00E8AC  A3828108   SB V0, -32504(GP)
125:                 		return FALSE;
9D00E8B0  00001821   ADDU V1, ZERO, ZERO
126:                 	}
127:                 #ifdef SD_DEBUG
128:                 	UartPrint(STDOUT, "OK\r");
129:                 #endif
130:                 
131:                 	return TRUE;
132:                 } // mount
9D00E8B4  00601021   ADDU V0, V1, ZERO
9D00E8B8  8FBF001C   LW RA, 28(SP)
9D00E8BC  03E00008   JR RA
9D00E8C0  27BD0020   ADDIU SP, SP, 32
133:                 
134:                 /*	----------------------------------------------------------------------------
135:                  unmount    initializes a MEDIA structure for FILEIO access
136:                  --------------------------------------------------------------------------*/
137:                 
138:                 void unmount(void) {
9D00E7EC  27BDFFE8   ADDIU SP, SP, -24
9D00E7F0  AFBF0014   SW RA, 20(SP)
139:                 	f_mount(0, NULL);
9D00E7F4  00002021   ADDU A0, ZERO, ZERO
9D00E7F8  0F40065D   JAL f_mount
9D00E7FC  00002821   ADDU A1, ZERO, ZERO
140:                 	//free(Fat);
141:                 	SPI2CONCLR = 0x8000; // SPI2 OFF
9D00E800  34038000   ORI V1, ZERO, -32768
9D00E804  3C02BF80   LUI V0, -16512
9D00E808  AC435A04   SW V1, 23044(V0)
142:                 } // unmount
9D00E80C  8FBF0014   LW RA, 20(SP)
9D00E810  03E00008   JR RA
9D00E814  27BD0018   ADDIU SP, SP, 24
143:                 
144:                 /*	----------------------------------------------------------------------------
145:                  present   test if a SD card is present
146:                  --------------------------------------------------------------------------*/
147:                 
148:                 char SD_present(unsigned char pin) {
9D00E8C4  27BDFFE8   ADDIU SP, SP, -24
9D00E8C8  AFBF0014   SW RA, 20(SP)
149:                 	if (mount(pin)) {
9D00E8CC  0F403A06   JAL mount
9D00E8D0  308400FF   ANDI A0, A0, 255
9D00E8D4  10400004   BEQ V0, ZERO, 0x9D00E8E8
9D00E8D8  00001821   ADDU V1, ZERO, ZERO
150:                 		unmount();
9D00E8DC  0F4039FB   JAL unmount
9D00E8E0  00000000   NOP
151:                 		return TRUE;
9D00E8E4  24030001   ADDIU V1, ZERO, 1
152:                 	} else {
153:                 		return FALSE;
154:                 	}
155:                 }
9D00E8E8  00601021   ADDU V0, V1, ZERO
9D00E8EC  8FBF0014   LW RA, 20(SP)
9D00E8F0  03E00008   JR RA
9D00E8F4  27BD0018   ADDIU SP, SP, 24
156:                 
157:                 /*	----------------------------------------------------------------------------
158:                  Scans the current disk and compiles a list of files with a given extension
159:                  list     array of file names max * 8
160:                  max      number of entries
161:                  ext      file extension we are searching for
162:                  return   number of files found
163:                  --------------------------------------------------------------------------*/
164:                 
165:                 //unsigned listTYPE(char *listname, long *listsize, int max, const char *ext )
166:                 unsigned listTYPE(DIRTABLE *list, int max, const char *ext)
167:                 //unsigned listTYPE(char *list, int max, const char *ext )
168:                 {
169:                 	//TODO: implement
170:                 
171:                 	return 0;
172:                 } // listTYPE
9D00E8F8  03E00008   JR RA
9D00E8FC  00001021   ADDU V0, ZERO, ZERO
173:                 
174:                 /* Prints the directory contents */
175:                 unsigned listDir(const char *path) {
9D00E900  27BDFF90   ADDIU SP, SP, -112
9D00E904  AFBF006C   SW RA, 108(SP)
9D00E908  AFBE0068   SW S8, 104(SP)
9D00E90C  AFB70064   SW S7, 100(SP)
9D00E910  AFB60060   SW S6, 96(SP)
9D00E914  AFB5005C   SW S5, 92(SP)
9D00E918  AFB40058   SW S4, 88(SP)
9D00E91C  AFB30054   SW S3, 84(SP)
9D00E920  AFB20050   SW S2, 80(SP)
9D00E924  AFB1004C   SW S1, 76(SP)
9D00E928  AFB00048   SW S0, 72(SP)
9D00E92C  00808821   ADDU S1, A0, ZERO
176:                 	//TODO: remove all CDC references
177:                 	long p1;
178:                 	PF_BYTE res, b;
179:                 	UINT s1, s2;
180:                 	DIR dir; /* Directory object */
181:                         char * fmt;
182:                         dir.fs=Fat;
9D00E930  8F82810C   LW V0, -32500(GP)
9D00E934  AFA20020   SW V0, 32(SP)
183:                 	res = f_opendir(&dir, path);
9D00E938  27A40020   ADDIU A0, SP, 32
9D00E93C  0F400AB2   JAL f_opendir
9D00E940  02202821   ADDU A1, S1, ZERO
9D00E944  304300FF   ANDI V1, V0, 255
184:                         if (!res) {
9D00E948  14600076   BNE V1, ZERO, 0x9D00EB24
9D00E94C  00601021   ADDU V0, V1, ZERO
185:                             p1 = s1 = s2 = 0;
186:                             fmt=malloc(64);
9D00E950  0F4047DE   JAL malloc
9D00E954  24040040   ADDIU A0, ZERO, 64
9D00E958  AFA20044   SW V0, 68(SP)
187:                             if (!fmt) {
9D00E95C  10400088   BEQ V0, ZERO, 0x9D00EB80
9D00E960  00408021   ADDU S0, V0, ZERO
188:                                 res=-1;
9D00EB90  0B403AC6   J 0x9D00EB18
9D00EB94  241200FF   ADDIU S2, ZERO, 255
189:                             }else{
190:                                 sprintf(fmt,"\rreading dirctory: ('%s')\r", path);
9D00E964  00402021   ADDU A0, V0, ZERO
9D00E968  3C059D01   LUI A1, -25343
9D00E96C  24A55F4C   ADDIU A1, A1, 24396
9D00E970  0F405BB0   JAL _sprintf_cdnopsuxX
9D00E974  02203021   ADDU A2, S1, ZERO
191:                                 print(comm_channel,fmt);
9D00E978  8384804C   LB A0, -32692(GP)
9D00E97C  0F40229C   JAL print
9D00E980  8FA50044   LW A1, 68(SP)
9D00E984  0000B021   ADDU S6, ZERO, ZERO
9D00E988  0000A821   ADDU S5, ZERO, ZERO
9D00E98C  0000A021   ADDU S4, ZERO, ZERO
192:                             }
193:                         }else{
194:                             return res;
195:                         }
196:                         while (!res) {
197:                 		res = f_readdir(&dir, &Finfo);
9D00E990  3C13A000   LUI S3, -24576
9D00E994  26712220   ADDIU S1, S3, 8736
9D00E9B4  27A40020   ADDIU A0, SP, 32
9D00E9B8  0F400AE3   JAL f_readdir
9D00E9BC  02202821   ADDU A1, S1, ZERO
9D00E9C0  305200FF   ANDI S2, V0, 255
9D00EAF4  0B403A6E   J 0x9D00E9B8
9D00EAF8  27A40020   ADDIU A0, SP, 32
198:                 #ifdef SD_DEBUG
199:                 //		put_rc(res);
200:                 #endif
201:                 		if ((res != FR_OK) || !Finfo.fname[0]) {
9D00E9C4  1640004D   BNE S2, ZERO, 0x9D00EAFC
9D00E9C8  8FA40044   LW A0, 68(SP)
9D00E9CC  82220009   LB V0, 9(S1)
9D00E9D0  50400060   BEQL V0, ZERO, 0x9D00EB54
9D00E9D4  AFB40010   SW S4, 16(SP)
202:                 			break;
203:                 		}
204:                 		if (Finfo.fattrib & AM_DIR) {
9D00E9D8  92220008   LBU V0, 8(S1)
9D00E9DC  30430010   ANDI V1, V0, 16
9D00E9E0  50600004   BEQL V1, ZERO, 0x9D00E9F4
9D00E9E4  26B50001   ADDIU S5, S5, 1
205:                 			s2++;
9D00E9E8  26D60001   ADDIU S6, S6, 1
206:                 		} else {
207:                 			s1++;
208:                 			p1 += Finfo.fsize;
9D00E9F4  8E632220   LW V1, 8736(S3)
9D00E9F8  0283A021   ADDU S4, S4, V1
209:                 		}
210:                 // what about other outputs ?
211:                 		sprintf(fmt,"%c%c%c%c%c ",
9D00E998  3C179D01   LUI S7, -25343
9D00E99C  26F75F68   ADDIU S7, S7, 24424
9D00E9EC  0B403A80   J 0x9D00EA00
9D00E9F0  24060044   ADDIU A2, ZERO, 68
9D00E9FC  2406002D   ADDIU A2, ZERO, 45
9D00EA08  24030048   ADDIU V1, ZERO, 72
9D00EA0C  2404002D   ADDIU A0, ZERO, 45
9D00EA10  0065200B   MOVN A0, V1, A1
9D00EA18  24050053   ADDIU A1, ZERO, 83
9D00EA1C  2403002D   ADDIU V1, ZERO, 45
9D00EA20  00A8180B   MOVN V1, A1, T0
9D00EA28  24050041   ADDIU A1, ZERO, 65
9D00EA2C  2408002D   ADDIU T0, ZERO, 45
9D00EA30  0102280A   MOVZ A1, T0, V0
9D00EA34  AFA40010   SW A0, 16(SP)
9D00EA38  AFA30014   SW V1, 20(SP)
9D00EA3C  AFA50018   SW A1, 24(SP)
9D00EA40  02002021   ADDU A0, S0, ZERO
9D00EA44  02E02821   ADDU A1, S7, ZERO
9D00EA48  24020052   ADDIU V0, ZERO, 82
9D00EA4C  2403002D   ADDIU V1, ZERO, 45
9D00EA50  0067100A   MOVZ V0, V1, A3
9D00EA54  0F405BB0   JAL _sprintf_cdnopsuxX
9D00EA58  00403821   ADDU A3, V0, ZERO
212:                                 (Finfo.fattrib & AM_DIR) ? 'D' : '-',
213:                 				(Finfo.fattrib & AM_RDO) ? 'R' : '-',
9D00EA00  30470001   ANDI A3, V0, 1
214:                 				(Finfo.fattrib & AM_HID) ? 'H' : '-',
9D00EA04  30450002   ANDI A1, V0, 2
215:                 				(Finfo.fattrib & AM_SYS) ? 'S' : '-',
9D00EA14  30480004   ANDI T0, V0, 4
216:                 				(Finfo.fattrib & AM_ARC) ? 'A' : '-');
9D00EA24  30420020   ANDI V0, V0, 32
217:                                 print(comm_channel, fmt);
9D00EA5C  8384804C   LB A0, -32692(GP)
9D00EA60  0F40229C   JAL print
9D00EA64  02002821   ADDU A1, S0, ZERO
218:                 		sprintf(fmt,"%u/%02u/%02u %02u:%02u ",
9D00E9A0  3C1E9D01   LUI S8, -25343
9D00E9A4  27DE5F74   ADDIU S8, S8, 24436
9D00EA74  30E3001F   ANDI V1, A3, 31
9D00EA78  AFA30010   SW V1, 16(SP)
9D00EA7C  00021AC2   SRL V1, V0, 11
9D00EA80  AFA30014   SW V1, 20(SP)
9D00EA84  7C422940   EXT V0, V0, 5, 6
9D00EA88  AFA20018   SW V0, 24(SP)
9D00EA8C  02002021   ADDU A0, S0, ZERO
9D00EA90  03C02821   ADDU A1, S8, ZERO
9D00EA94  24C607BC   ADDIU A2, A2, 1980
9D00EA98  0F405BB0   JAL _sprintf_cdnopsuxX
9D00EA9C  7CE71940   EXT A3, A3, 5, 4
219:                                 (Finfo.fdate >> 9) + 1980,
9D00EA68  96270004   LHU A3, 4(S1)
9D00EA70  00073242   SRL A2, A3, 9
220:                 				(Finfo.fdate >> 5) & 15, Finfo.fdate & 31, (Finfo.ftime >> 11),
9D00EA6C  96220006   LHU V0, 6(S1)
221:                 				(Finfo.ftime >> 5) & 63);
222:                                 print(comm_channel, fmt);
9D00EAA0  8384804C   LB A0, -32692(GP)
9D00EAA4  0F40229C   JAL print
9D00EAA8  02002821   ADDU A1, S0, ZERO
223:                                 sprintf(fmt," %9u ", Finfo.fsize);
9D00E9A8  3C029D01   LUI V0, -25343
9D00E9AC  24425F8C   ADDIU V0, V0, 24460
9D00E9B0  AFA20040   SW V0, 64(SP)
9D00EAAC  02002021   ADDU A0, S0, ZERO
9D00EAB0  8FA50040   LW A1, 64(SP)
9D00EAB4  0F405BB0   JAL _sprintf_cdnopsuxX
9D00EAB8  8E662220   LW A2, 8736(S3)
224:                                 print(comm_channel, fmt);
9D00EABC  8384804C   LB A0, -32692(GP)
9D00EAC0  0F40229C   JAL print
9D00EAC4  02002821   ADDU A1, S0, ZERO
225:                 		sprintf(fmt, " %-12s %s\r", Finfo.fname,
9D00EAC8  02002021   ADDU A0, S0, ZERO
9D00EACC  3C029D01   LUI V0, -25343
9D00EAD0  24455F94   ADDIU A1, V0, 24468
9D00EAD4  3C06A000   LUI A2, -24576
9D00EAD8  24C62229   ADDIU A2, A2, 8745
9D00EADC  3C079D01   LUI A3, -25343
9D00EAE0  0F405BB0   JAL _sprintf_cdnopsuxX
9D00EAE4  24E75FA0   ADDIU A3, A3, 24480
226:                 #if _USE_LFN
227:                 				Lfname);
228:                 #else
229:                 				"");
230:                 #endif
231:                                 print(comm_channel,fmt);
9D00EAE8  8384804C   LB A0, -32692(GP)
9D00EAEC  0F40229C   JAL print
9D00EAF0  02002821   ADDU A1, S0, ZERO
232:                 	}
233:                         if (!res){
234:                             sprintf(fmt, "\rfile count %d, directory count %d,  total size %d\r",s1,s2,p1);
9D00EB54  8FA40044   LW A0, 68(SP)
9D00EB58  3C059D01   LUI A1, -25343
9D00EB5C  24A55FC0   ADDIU A1, A1, 24512
9D00EB60  02A03021   ADDU A2, S5, ZERO
9D00EB64  0F405BB0   JAL _sprintf_cdnopsuxX
9D00EB68  02C03821   ADDU A3, S6, ZERO
235:                             print(comm_channel, fmt);
9D00EB6C  8384804C   LB A0, -32692(GP)
9D00EB70  0F40229C   JAL print
9D00EB74  8FA50044   LW A1, 68(SP)
9D00EB78  0B403AC6   J 0x9D00EB18
9D00EB7C  00000000   NOP
236:                         }else{
237:                             if (fmt){
238:                                     sprintf(fmt,"file i/o error code: %d\r", res);
9D00EAFC  3C059D01   LUI A1, -25343
9D00EB00  24A55FA4   ADDIU A1, A1, 24484
9D00EB04  0F405BB0   JAL _sprintf_cdnopsuxX
9D00EB08  02403021   ADDU A2, S2, ZERO
239:                                     print(comm_channel, fmt);
9D00EB0C  8384804C   LB A0, -32692(GP)
9D00EB10  0F40229C   JAL print
9D00EB14  8FA50044   LW A1, 68(SP)
240:                             }else{
241:                                 print(comm_channel,"Memory allocation error.\r");
9D00EB80  8384804C   LB A0, -32692(GP)
9D00EB84  3C059D01   LUI A1, -25343
9D00EB88  0F40229C   JAL print
9D00EB8C  24A55FF4   ADDIU A1, A1, 24564
242:                             }
243:                         }
244:                         free(fmt);
9D00EB18  0F405E55   JAL free
9D00EB1C  8FA40044   LW A0, 68(SP)
245:                 	return res;
9D00EB20  02401021   ADDU V0, S2, ZERO
246:                 } // listDir
9D00EB24  8FBF006C   LW RA, 108(SP)
9D00EB28  8FBE0068   LW S8, 104(SP)
9D00EB2C  8FB70064   LW S7, 100(SP)
9D00EB30  8FB60060   LW S6, 96(SP)
9D00EB34  8FB5005C   LW S5, 92(SP)
9D00EB38  8FB40058   LW S4, 88(SP)
9D00EB3C  8FB30054   LW S3, 84(SP)
9D00EB40  8FB20050   LW S2, 80(SP)
9D00EB44  8FB1004C   LW S1, 76(SP)
9D00EB48  8FB00048   LW S0, 72(SP)
9D00EB4C  03E00008   JR RA
9D00EB50  27BD0070   ADDIU SP, SP, 112
247:                 
248:                 char isDirectory(FILINFO file) {
9D00EB98  AFA40000   SW A0, 0(SP)
9D00EB9C  AFA50004   SW A1, 4(SP)
9D00EBA0  AFA60008   SW A2, 8(SP)
9D00EBA4  AFA7000C   SW A3, 12(SP)
249:                 	if (file.fattrib & AM_DIR) {
250:                 		return TRUE;
251:                 	} else {
252:                 		return FALSE;
253:                 	}
254:                 }
9D00EBA8  03E00008   JR RA
9D00EBAC  7CC20100   EXT V0, A2, 4, 1
255:                 
256:                 char isReadOnly(FILINFO file) {
9D00EBB0  AFA40000   SW A0, 0(SP)
9D00EBB4  AFA50004   SW A1, 4(SP)
9D00EBB8  AFA60008   SW A2, 8(SP)
9D00EBBC  AFA7000C   SW A3, 12(SP)
257:                 	if (file.fattrib & AM_RDO) {
258:                 		return TRUE;
259:                 	} else {
260:                 		return FALSE;
261:                 	}
262:                 }
9D00EBC0  03E00008   JR RA
9D00EBC4  30C20001   ANDI V0, A2, 1
263:                 
264:                 char isHidden(FILINFO file) {
9D00EBC8  AFA40000   SW A0, 0(SP)
9D00EBCC  AFA50004   SW A1, 4(SP)
9D00EBD0  AFA60008   SW A2, 8(SP)
9D00EBD4  AFA7000C   SW A3, 12(SP)
265:                 	if (file.fattrib & AM_HID) {
266:                 		return TRUE;
267:                 	} else {
268:                 		return FALSE;
269:                 	}
270:                 }
9D00EBD8  03E00008   JR RA
9D00EBDC  7CC20040   EXT V0, A2, 1, 1
271:                 
272:                 char isSystem(FILINFO file) {
9D00EBE0  AFA40000   SW A0, 0(SP)
9D00EBE4  AFA50004   SW A1, 4(SP)
9D00EBE8  AFA60008   SW A2, 8(SP)
9D00EBEC  AFA7000C   SW A3, 12(SP)
273:                 	if (file.fattrib & AM_SYS) {
274:                 		return TRUE;
275:                 	} else {
276:                 		return FALSE;
277:                 	}
278:                 }
9D00EBF0  03E00008   JR RA
9D00EBF4  7CC20080   EXT V0, A2, 2, 1
279:                 
280:                 char isArchive(FILINFO file) {
9D00EBF8  AFA40000   SW A0, 0(SP)
9D00EBFC  AFA50004   SW A1, 4(SP)
9D00EC00  AFA60008   SW A2, 8(SP)
9D00EC04  AFA7000C   SW A3, 12(SP)
281:                 	if (file.fattrib & AM_ARC) {
282:                 		return TRUE;
283:                 	} else {
284:                 		return FALSE;
285:                 	}
286:                 }
9D00EC08  03E00008   JR RA
9D00EC0C  7CC20140   EXT V0, A2, 5, 1
287:                 #endif /* __FILEIO_C__ */
288:                 
---  /home/jacques/MPLABXProjects/vpc-32/hardware/Pinguino/ff.c  ----------------------------------------
1:                   /*----------------------------------------------------------------------------/
2:                    /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
3:                    /-----------------------------------------------------------------------------/
4:                    / FatFs module is a generic FAT file system module for small embedded systems.
5:                    / This is a free software that opened for education, research and commercial
6:                    / developments under license policy of following terms.
7:                    /
8:                    /  Copyright (C) 2011, ChaN, all right reserved.
9:                    /
10:                   / * The FatFs module is a free software and there is NO WARRANTY.
11:                   / * No restriction on use. You can use, modify and redistribute it for
12:                   /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
13:                   / * Redistributions of source code must retain the above copyright notice.
14:                   /
15:                   /-----------------------------------------------------------------------------/
16:                   / Feb 26,'06 R0.00  Prototype.
17:                   /
18:                   / Apr 29,'06 R0.01  First stable version.
19:                   /
20:                   / Jun 01,'06 R0.02  Added FAT12 support.
21:                   /                   Removed unbuffered mode.
22:                   /                   Fixed a problem on small (<32M) partition.
23:                   / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
24:                   /
25:                   / Sep 22,'06 R0.03  Added f_rename().
26:                   /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
27:                   / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
28:                   /                   Fixed f_mkdir() creates incorrect directory on FAT32.
29:                   /
30:                   / Feb 04,'07 R0.04  Supported multiple drive system.
31:                   /                   Changed some interfaces for multiple drive system.
32:                   /                   Changed f_mountdrv() to f_mount().
33:                   /                   Added f_mkfs().
34:                   / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
35:                   /                   Added a capability of extending file size to f_lseek().
36:                   /                   Added minimization level 3.
37:                   /                   Fixed an endian sensitive code in f_mkfs().
38:                   / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
39:                   /                   Added FSInfo support.
40:                   /                   Fixed DBCS name can result FR_INVALID_NAME.
41:                   /                   Fixed short seek (<= csize) collapses the file object.
42:                   /
43:                   / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
44:                   /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
45:                   /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
46:                   / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
47:                   /                   Fixed off by one error at FAT sub-type determination.
48:                   /                   Fixed btr in f_read() can be mistruncated.
49:                   /                   Fixed cached sector is not flushed when create and close without write.
50:                   /
51:                   / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
52:                   /                   Improved performance of f_lseek() on moving to the same or following cluster.
53:                   /
54:                   / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
55:                   /                   Added long file name feature.
56:                   /                   Added multiple code page feature.
57:                   /                   Added re-entrancy for multitask operation.
58:                   /                   Added auto cluster size selection to f_mkfs().
59:                   /                   Added rewind option to f_readdir().
60:                   /                   Changed result code of critical errors.
61:                   /                   Renamed string functions to avoid name collision.
62:                   / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
63:                   /                   Added multiple sector size feature.
64:                   / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
65:                   /                   Fixed wrong cache control in f_lseek().
66:                   /                   Added relative path feature.
67:                   /                   Added f_chdir() and f_chdrive().
68:                   /                   Added proper case conversion to extended char.
69:                   / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
70:                   /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
71:                   /                   Fixed name matching error on the 13 char boundary.
72:                   /                   Added a configuration option, _LFN_UNICODE.
73:                   /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
74:                   /
75:                   / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
76:                   /                   Added file lock feature. (_FS_SHARE)
77:                   /                   Added fast seek feature. (_USE_FASTSEEK)
78:                   /                   Changed some types on the API, XCHAR->TCHAR.
79:                   /                   Changed fname member in the FILINFO structure on Unicode cfg.
80:                   /                   String functions support UTF-8 encoding files on Unicode cfg.
81:                   / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
82:                   /                   Added sector erase feature. (_USE_ERASE)
83:                   /                   Moved file lock semaphore table from fs object to the bss.
84:                   /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
85:                   /                   Fixed f_mkfs() creates wrong FAT32 volume.
86:                   / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
87:                   /                   f_lseek() reports required table size on creating CLMP.
88:                   /                   Extended format syntax of f_printf function.
89:                   /                   Ignores duplicated directory separators in given path names.
90:                   /
91:                   / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
92:                   /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
93:                   /---------------------------------------------------------------------------
94:                   / 2011-12 Alfred Broda <alfredbroda@gmail.com> adapted for Pinguno Project
95:                   / BYTE and WORD were changed to PF_BYTE and PF_WORD because of a conflict.
96:                   ---------------------------------------------------------------------------*/
97:                  
98:                  #include "ff.h"			/* FatFs configurations and declarations */
99:                  #include "diskio.h"		/* Declarations of low level disk I/O functions */
100:                 
101:                 #if defined _DEBUG_
102:                 #include "../serial_comm/serial_comm.h"
103:                 #include"../../console.h"
104:                 #endif
105:                 /*--------------------------------------------------------------------------
106:                 
107:                  Module Private Definitions
108:                 
109:                  ---------------------------------------------------------------------------*/
110:                 
111:                 #if _FATFS != 6502	/* Revision ID */
112:                 #error Wrong include file (ff.h).
113:                 #endif
114:                 
115:                 /* Definitions on sector size */
116:                 #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
117:                 #error Wrong sector size.
118:                 #endif
119:                 #if _MAX_SS != 512
120:                 #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
121:                 #else
122:                 #define	SS(fs)	512U			/* Fixed sector size */
123:                 #endif
124:                 
125:                 /* Reentrancy related */
126:                 #if _FS_REENTRANT
127:                 #if _USE_LFN == 1
128:                 #error Static LFN work area must not be used in re-entrant configuration.
129:                 #endif
130:                 #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
131:                 #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
132:                 #else
133:                 #define	ENTER_FF(fs)
134:                 #define LEAVE_FF(fs, res)	return res
135:                 #endif
136:                 
137:                 #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
138:                 
139:                 /* File shareing feature */
140:                 #if _FS_SHARE
141:                 #if _FS_READONLY
142:                 #error _FS_SHARE must be 0 on read-only cfg.
143:                 #endif
144:                 typedef struct {
145:                 	FATFS *fs; /* File ID 1, volume (NULL:blank entry) */
146:                 	DWORD clu; /* File ID 2, directory */
147:                 	PF_WORD idx; /* File ID 3, directory index */
148:                 	PF_WORD ctr; /* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
149:                 }FILESEM;
150:                 #endif
151:                 
152:                 /* Misc definitions */
153:                 #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
154:                 #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
155:                 
156:                 /* DBCS code ranges and SBCS extend char conversion table */
157:                 
158:                 #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
159:                 #define _DF1S	0x81	/* DBC 1st byte range 1 start */
160:                 #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
161:                 #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
162:                 #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
163:                 #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
164:                 #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
165:                 #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
166:                 #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
167:                 
168:                 #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
169:                 #define _DF1S	0x81
170:                 #define _DF1E	0xFE
171:                 #define _DS1S	0x40
172:                 #define _DS1E	0x7E
173:                 #define _DS2S	0x80
174:                 #define _DS2E	0xFE
175:                 
176:                 #elif _CODE_PAGE == 949	/* Korean */
177:                 #define _DF1S	0x81
178:                 #define _DF1E	0xFE
179:                 #define _DS1S	0x41
180:                 #define _DS1E	0x5A
181:                 #define _DS2S	0x61
182:                 #define _DS2E	0x7A
183:                 #define _DS3S	0x81
184:                 #define _DS3E	0xFE
185:                 
186:                 #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
187:                 #define _DF1S	0x81
188:                 #define _DF1E	0xFE
189:                 #define _DS1S	0x40
190:                 #define _DS1E	0x7E
191:                 #define _DS2S	0xA1
192:                 #define _DS2E	0xFE
193:                 
194:                 #elif _CODE_PAGE == 437	/* U.S. (OEM) */
195:                 #define _DF1S	0
196:                 #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
197:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
198:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
199:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
200:                 
201:                 #elif _CODE_PAGE == 720	/* Arabic (OEM) */
202:                 #define _DF1S	0
203:                 #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
204:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
205:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
206:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
207:                 
208:                 #elif _CODE_PAGE == 737	/* Greek (OEM) */
209:                 #define _DF1S	0
210:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
211:                 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
212:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
213:                 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
214:                 
215:                 #elif _CODE_PAGE == 775	/* Baltic (OEM) */
216:                 #define _DF1S	0
217:                 #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
218:                 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
219:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
220:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
221:                 
222:                 #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
223:                 #define _DF1S	0
224:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
225:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
226:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
227:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
228:                 
229:                 #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
230:                 #define _DF1S	0
231:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
232:                 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
233:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
234:                 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
235:                 
236:                 #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
237:                 #define _DF1S	0
238:                 #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
239:                 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
240:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
241:                 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
242:                 
243:                 #elif _CODE_PAGE == 857	/* Turkish (OEM) */
244:                 #define _DF1S	0
245:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
246:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
247:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
248:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
249:                 
250:                 #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
251:                 #define _DF1S	0
252:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
253:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
254:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
255:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
256:                 
257:                 #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
258:                 #define _DF1S	0
259:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
260:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
261:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
262:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
263:                 
264:                 #elif _CODE_PAGE == 866	/* Russian (OEM) */
265:                 #define _DF1S	0
266:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
267:                 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
268:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
269:                 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
270:                 
271:                 #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
272:                 #define _DF1S	0
273:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
274:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
275:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
276:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
277:                 
278:                 #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
279:                 #define _DF1S	0
280:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
281:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
282:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
283:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
284:                 
285:                 #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
286:                 #define _DF1S	0
287:                 #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
288:                 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
289:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
290:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
291:                 
292:                 #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
293:                 #define _DF1S	0
294:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
295:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
296:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
297:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
298:                 
299:                 #elif _CODE_PAGE == 1253 /* Greek (Windows) */
300:                 #define _DF1S	0
301:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
302:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
303:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
304:                 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
305:                 
306:                 #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
307:                 #define _DF1S	0
308:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
309:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
310:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
311:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
312:                 
313:                 #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
314:                 #define _DF1S	0
315:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
316:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
317:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
318:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
319:                 
320:                 #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
321:                 #define _DF1S	0
322:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
323:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
324:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
325:                 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
326:                 
327:                 #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
328:                 #define _DF1S	0
329:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
330:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
331:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
332:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
333:                 
334:                 #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
335:                 #define _DF1S	0
336:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
337:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
338:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
339:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
340:                 
341:                 #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
342:                 #if _USE_LFN
343:                 #error Cannot use LFN feature without valid code page.
344:                 #endif
345:                 #define _DF1S	0
346:                 
347:                 #else
348:                 #error Unknown code page
349:                 
350:                 #endif
351:                 
352:                 /* Character code support macros */
353:                 #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
354:                 #define IsLower(c)	(((c)>='a')&&((c)<='z'))
355:                 #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
356:                 
357:                 #if _DF1S		/* Code page is DBCS */
358:                 
359:                 #ifdef _DF2S	/* Two 1st byte areas */
360:                 #define IsDBCS1(c)	(((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E) || ((PF_BYTE)(c) >= _DF2S && (PF_BYTE)(c) <= _DF2E))
361:                 #else			/* One 1st byte area */
362:                 #define IsDBCS1(c)	((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E)
363:                 #endif
364:                 
365:                 #ifdef _DS3S	/* Three 2nd byte areas */
366:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E) || ((PF_BYTE)(c) >= _DS3S && (PF_BYTE)(c) <= _DS3E))
367:                 #else			/* Two 2nd byte areas */
368:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E))
369:                 #endif
370:                 
371:                 #else			/* Code page is SBCS */
372:                 
373:                 #define IsDBCS1(c)	0
374:                 #define IsDBCS2(c)	0
375:                 
376:                 #endif /* _DF1S */
377:                 
378:                 /* Name status flags */
379:                 #define NS			11		/* Index of name status byte in fn[] */
380:                 #define NS_LOSS		0x01	/* Out of 8.3 format */
381:                 #define NS_LFN		0x02	/* Force to create LFN entry */
382:                 #define NS_LAST		0x04	/* Last segment */
383:                 #define NS_BODY		0x08	/* Lower case flag (body) */
384:                 #define NS_EXT		0x10	/* Lower case flag (ext) */
385:                 #define NS_DOT		0x20	/* Dot entry */
386:                 
387:                 /* FAT sub-type boundaries */
388:                 /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
389:                 #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
390:                 #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
391:                 
392:                 /* FatFs refers the members in the FAT structures as byte array instead of
393:                  / structure member because the structure is not binary compatible between
394:                  / different platforms */
395:                 
396:                 #define BS_jmpBoot			0	/* Jump instruction (3) */
397:                 #define BS_OEMName			3	/* OEM name (8) */
398:                 #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
399:                 #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
400:                 #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
401:                 #define BPB_NumFATs			16	/* Number of FAT copies (1) */
402:                 #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
403:                 #define BPB_TotSec16		19	/* Volume size [sector] (2) */
404:                 #define BPB_Media			21	/* Media descriptor (1) */
405:                 #define BPB_FATSz16			22	/* FAT size [sector] (2) */
406:                 #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
407:                 #define BPB_NumHeads		26	/* Number of heads (2) */
408:                 #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
409:                 #define BPB_TotSec32		32	/* Volume size [sector] (4) */
410:                 #define BS_DrvNum			36	/* Physical drive number (2) */
411:                 #define BS_BootSig			38	/* Extended boot signature (1) */
412:                 #define BS_VolID			39	/* Volume serial number (4) */
413:                 #define BS_VolLab			43	/* Volume label (8) */
414:                 #define BS_FilSysType		54	/* File system type (1) */
415:                 #define BPB_FATSz32			36	/* FAT size [sector] (4) */
416:                 #define BPB_ExtFlags		40	/* Extended flags (2) */
417:                 #define BPB_FSVer			42	/* File system version (2) */
418:                 #define BPB_RootClus		44	/* Root dir first cluster (4) */
419:                 #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
420:                 #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
421:                 #define BS_DrvNum32			64	/* Physical drive number (2) */
422:                 #define BS_BootSig32		66	/* Extended boot signature (1) */
423:                 #define BS_VolID32			67	/* Volume serial number (4) */
424:                 #define BS_VolLab32			71	/* Volume label (8) */
425:                 #define BS_FilSysType32		82	/* File system type (1) */
426:                 #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
427:                 #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
428:                 #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
429:                 #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
430:                 #define MBR_Table			446	/* MBR: Partition table offset (2) */
431:                 #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
432:                 #define BS_55AA				510	/* Boot sector signature (2) */
433:                 
434:                 #define	DIR_Name			0	/* Short file name (11) */
435:                 #define	DIR_Attr			11	/* Attribute (1) */
436:                 #define	DIR_NTres			12	/* NT flag (1) */
437:                 #define	DIR_CrtTime			14	/* Created time (2) */
438:                 #define	DIR_CrtDate			16	/* Created date (2) */
439:                 #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
440:                 #define	DIR_WrtTime			22	/* Modified time (2) */
441:                 #define	DIR_WrtDate			24	/* Modified date (2) */
442:                 #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
443:                 #define	DIR_FileSize		28	/* File size (4) */
444:                 #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
445:                 #define	LDIR_Attr			11	/* LFN attribute (1) */
446:                 #define	LDIR_Type			12	/* LFN type (1) */
447:                 #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
448:                 #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
449:                 #define	SZ_DIR				32		/* Size of a directory entry */
450:                 #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
451:                 #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
452:                 #define	NDDE				0x05	/* Replacement of a character collides with DDE */
453:                 
454:                 /*------------------------------------------------------------*/
455:                 /* Module private work area                                   */
456:                 /*------------------------------------------------------------*/
457:                 /* Note that uninitialized variables with static duration are
458:                  /  zeroed/nulled at start-up. If not, the compiler or start-up
459:                  /  routine is out of ANSI-C standard.
460:                  */
461:                 
462:                 #if _VOLUMES
463:                 static FATFS *FatFs[_VOLUMES]; /* Pointer to the file system objects (logical drives) */
464:                 #else
465:                 #error Number of volumes must not be 0.
466:                 #endif
467:                 
468:                 static PF_WORD Fsid; /* File system mount ID */
469:                 
470:                 #if _FS_RPATH
471:                 static
472:                 PF_BYTE CurrVol; /* Current drive */
473:                 #endif
474:                 
475:                 #if _FS_SHARE
476:                 static
477:                 FILESEM Files[_FS_SHARE]; /* File lock semaphores */
478:                 #endif
479:                 
480:                 #if _USE_LFN == 0			/* No LFN feature */
481:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
482:                 #define INIT_BUF(dobj)		(dobj).fn = sfn
483:                 #define	FREE_BUF()
484:                 
485:                 #elif _USE_LFN == 1			/* LFN feature with static working buffer */
486:                 static WCHAR LfnBuf[_MAX_LFN+1];
487:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
488:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
489:                 #define	FREE_BUF()
490:                 
491:                 #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
492:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
493:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
494:                 #define	FREE_BUF()
495:                 
496:                 #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
497:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR *lfn
498:                 #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
499:                 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
500:                 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
501:                 #define	FREE_BUF()			ff_memfree(lfn)
502:                 
503:                 #else
504:                 #error Wrong LFN configuration.
505:                 #endif
506:                 
507:                 /*--------------------------------------------------------------------------
508:                 
509:                  Module Private Functions
510:                 
511:                  ---------------------------------------------------------------------------*/
512:                 
513:                 /*-----------------------------------------------------------------------*/
514:                 /* String functions                                                      */
515:                 /*-----------------------------------------------------------------------*/
516:                 
517:                 /* Copy memory to memory */
518:                 static
519:                 void mem_cpy(void* dst, const void* src, UINT cnt) {
9D000008  00862021   ADDU A0, A0, A2
520:                 	PF_BYTE *d = (PF_BYTE*) dst;
521:                 	const PF_BYTE *s = (const PF_BYTE*) src;
522:                 
523:                 #if _WORD_ACCESS == 1
524:                 	while (cnt >= sizeof(int)) {
525:                 		*(int*) d = *(int*) s;
526:                 		d += sizeof(int);
527:                 		s += sizeof(int);
528:                 		cnt -= sizeof(int);
529:                 	}
530:                 #endif
531:                 	while (cnt--)
9D000000  10C00007   BEQ A2, ZERO, 0x9D000020
9D000004  00801021   ADDU V0, A0, ZERO
9D000018  1444FFFC   BNE V0, A0, 0x9D00000C
9D00001C  24A50001   ADDIU A1, A1, 1
9D000020  03E00008   JR RA
9D000024  00000000   NOP
532:                 		*d++ = *s++;
9D00000C  90A30000   LBU V1, 0(A1)
9D000010  A0430000   SB V1, 0(V0)
9D000014  24420001   ADDIU V0, V0, 1
533:                 }
534:                 
535:                 /* Fill memory */
536:                 static
537:                 void mem_set(void* dst, int val, UINT cnt) {
9D000030  00862021   ADDU A0, A0, A2
538:                 	PF_BYTE *d = (PF_BYTE*) dst;
539:                 
540:                 	while (cnt--)
9D000028  10C00006   BEQ A2, ZERO, 0x9D000044
9D00002C  00801021   ADDU V0, A0, ZERO
9D00003C  5444FFFE   BNEL V0, A0, 0x9D000038
9D000040  A0450000   SB A1, 0(V0)
9D000044  03E00008   JR RA
9D000048  00000000   NOP
541:                 		*d++ = (PF_BYTE) val;
9D000034  A0450000   SB A1, 0(V0)
9D000038  24420001   ADDIU V0, V0, 1
542:                 }
543:                 
544:                 /* Compare memory to memory */
545:                 static
546:                 int mem_cmp(const void* dst, const void* src, UINT cnt) {
547:                 	const PF_BYTE *d = (const PF_BYTE *) dst, *s = (const PF_BYTE *) src;
9D001100  01402021   ADDU A0, T2, ZERO
548:                 	int r = 0;
549:                 
550:                 	while (cnt-- && (r = *d++ - *s++) == 0)
9D00110C  5068004A   BEQL V1, T0, 0x9D001238
551:                 		;
552:                 	return r;
553:                 }
554:                 
555:                 /* Check if chr is contained in the string */
556:                 static
557:                 int chk_chr(const char* str, int chr) {
558:                 	while (*str && *str != chr)
9D000E7C  3C179D01   LUI S7, -25343
9D000F20  240A0022   ADDIU T2, ZERO, 34
9D000FF8  104A0075   BEQ V0, T2, 0x9D0011D0
9D000FFC  00405821   ADDU T3, V0, ZERO
9D001000  26E57DD0   ADDIU A1, S7, 32208
9D001008  80A70000   LB A3, 0(A1)
9D00100C  50E00005   BEQL A3, ZERO, 0x9D001024
9D001010  2445FFBF   ADDIU A1, V0, -65
9D001014  5567FFFC   BNEL T3, A3, 0x9D001008
9D001018  24A50001   ADDIU A1, A1, 1
9D00101C  0B400477   J 0x9D0011DC
9D001020  24020006   ADDIU V0, ZERO, 6
9D0011D0  0B400477   J 0x9D0011DC
9D0011D4  24020006   ADDIU V0, ZERO, 6
9D0011D8  24020006   ADDIU V0, ZERO, 6
559:                 		str++;
9D001004  24A50001   ADDIU A1, A1, 1
560:                 	return *str;
561:                 }
562:                 
563:                 /*-----------------------------------------------------------------------*/
564:                 /* Request/Release grant to access the volume                            */
565:                 /*-----------------------------------------------------------------------*/
566:                 #if _FS_REENTRANT
567:                 
568:                 static
569:                 int lock_fs (
570:                 		FATFS *fs /* File system object */
571:                 )
572:                 {
573:                 	return ff_req_grant(fs->sobj);
574:                 }
575:                 
576:                 static
577:                 void unlock_fs (
578:                 		FATFS *fs, /* File system object */
579:                 		FRESULT res /* Result code to be returned */
580:                 )
581:                 {
582:                 	if (res != FR_NOT_ENABLED &&
583:                 			res != FR_INVALID_DRIVE &&
584:                 			res != FR_INVALID_OBJECT &&
585:                 			res != FR_TIMEOUT) {
586:                 		ff_rel_grant(fs->sobj);
587:                 	}
588:                 }
589:                 #endif
590:                 
591:                 /*-----------------------------------------------------------------------*/
592:                 /* File shareing control functions                                       */
593:                 /*-----------------------------------------------------------------------*/
594:                 #if _FS_SHARE
595:                 
596:                 static
597:                 FRESULT chk_lock ( /* Check if the file can be accessed */
598:                 		DIR* dj, /* Directory object pointing the file to be checked */
599:                 		int acc /* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
600:                 )
601:                 {
602:                 	UINT i, be;
603:                 
604:                 	/* Search file semaphore table */
605:                 	for (i = be = 0; i < _FS_SHARE; i++) {
606:                 		if (Files[i].fs) { /* Existing entry */
607:                 			if (Files[i].fs == dj->fs && /* Check if the file matched with an open file */
608:                 					Files[i].clu == dj->sclust &&
609:                 					Files[i].idx == dj->index) break;
610:                 		} else { /* Blank entry */
611:                 			be++;
612:                 		}
613:                 	}
614:                 	if (i == _FS_SHARE) /* The file is not opened */
615:                 	return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES; /* Is there a blank entry for new file? */
616:                 
617:                 	/* The file has been opened. Reject any open against writing file and all write mode open */
618:                 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
619:                 }
620:                 
621:                 static
622:                 int enq_lock (void) /* Check if an entry is available for a new file */
623:                 {
624:                 	UINT i;
625:                 
626:                 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
627:                 	return (i == _FS_SHARE) ? 0 : 1;
628:                 }
629:                 
630:                 static
631:                 UINT inc_lock ( /* Increment file open counter and returns its index (0:int error) */
632:                 		DIR* dj, /* Directory object pointing the file to register or increment */
633:                 		int acc /* Desired access mode (0:Read, !0:Write) */
634:                 )
635:                 {
636:                 	UINT i;
637:                 
638:                 	for (i = 0; i < _FS_SHARE; i++) { /* Find the file */
639:                 		if (Files[i].fs == dj->fs &&
640:                 				Files[i].clu == dj->sclust &&
641:                 				Files[i].idx == dj->index) break;
642:                 	}
643:                 
644:                 	if (i == _FS_SHARE) { /* Not opened. Register it as new. */
645:                 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
646:                 		if (i == _FS_SHARE) return 0; /* No space to register (int err) */
647:                 		Files[i].fs = dj->fs;
648:                 		Files[i].clu = dj->sclust;
649:                 		Files[i].idx = dj->index;
650:                 		Files[i].ctr = 0;
651:                 	}
652:                 
653:                 	if (acc && Files[i].ctr) return 0; /* Access violation (int err) */
654:                 
655:                 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1; /* Set semaphore value */
656:                 
657:                 	return i + 1;
658:                 }
659:                 
660:                 static
661:                 FRESULT dec_lock ( /* Decrement file open counter */
662:                 		UINT i /* Semaphore index */
663:                 )
664:                 {
665:                 	PF_WORD n;
666:                 	FRESULT res;
667:                 
668:                 	if (--i < _FS_SHARE) {
669:                 		n = Files[i].ctr;
670:                 		if (n == 0x100) n = 0;
671:                 		if (n) n--;
672:                 		Files[i].ctr = n;
673:                 		if (!n) Files[i].fs = 0;
674:                 		res = FR_OK;
675:                 	} else {
676:                 		res = FR_INT_ERR;
677:                 	}
678:                 	return res;
679:                 }
680:                 
681:                 static
682:                 void clear_lock ( /* Clear lock entries of the volume */
683:                 		FATFS *fs
684:                 )
685:                 {
686:                 	UINT i;
687:                 
688:                 	for (i = 0; i < _FS_SHARE; i++) {
689:                 		if (Files[i].fs == fs) Files[i].fs = 0;
690:                 	}
691:                 }
692:                 #endif
693:                 
694:                 /*-----------------------------------------------------------------------*/
695:                 /* Change window offset                                                  */
696:                 /*-----------------------------------------------------------------------*/
697:                 
698:                 static FRESULT move_window(FATFS *fs, /* File system object */
699:                 DWORD sector /* Sector number to make appearance in the fs->win[] */
700:                 ) /* Move to zero only writes back dirty window */
701:                 {
9D0001E8  27BDFFD8   ADDIU SP, SP, -40
9D0001EC  AFBF0024   SW RA, 36(SP)
9D0001F0  AFB40020   SW S4, 32(SP)
9D0001F4  AFB3001C   SW S3, 28(SP)
9D0001F8  AFB20018   SW S2, 24(SP)
9D0001FC  AFB10014   SW S1, 20(SP)
9D000200  AFB00010   SW S0, 16(SP)
9D000204  00808021   ADDU S0, A0, ZERO
9D000208  00A09021   ADDU S2, A1, ZERO
702:                 	DWORD wsect;
703:                 
704:                 	wsect = fs->winsect;
9D00020C  8C910030   LW S1, 48(A0)
705:                 	if (wsect != sector) { /* Changed current window */
9D000210  1225002D   BEQ S1, A1, 0x9D0002C8
9D000214  00001821   ADDU V1, ZERO, ZERO
706:                 #if !_FS_READONLY
707:                 		if (fs->wflag) { /* Write back dirty window if needed */
9D000218  90820004   LBU V0, 4(A0)
9D00021C  1040001F   BEQ V0, ZERO, 0x9D00029C
9D000220  02203021   ADDU A2, S1, ZERO
708:                 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
9D000224  24940034   ADDIU S4, A0, 52
9D000228  90840001   LBU A0, 1(A0)
9D00022C  02802821   ADDU A1, S4, ZERO
9D000230  0F4025DC   JAL disk_write
9D000234  24070001   ADDIU A3, ZERO, 1
9D000238  14400023   BNE V0, ZERO, 0x9D0002C8
9D00023C  24030001   ADDIU V1, ZERO, 1
709:                 				return FR_DISK_ERR;
710:                 			fs->wflag = 0;
9D000240  A2000004   SB ZERO, 4(S0)
711:                 			if (wsect < (fs->fatbase + fs->fsize)) { /* In FAT area */
9D000244  8E030020   LW V1, 32(S0)
9D000248  8E020024   LW V0, 36(S0)
9D00024C  00621021   ADDU V0, V1, V0
9D000250  0222102B   SLTU V0, S1, V0
9D000254  10400011   BEQ V0, ZERO, 0x9D00029C
9D000258  00000000   NOP
712:                 				PF_BYTE nf;
713:                 				for (nf = fs->n_fats; nf > 1; nf--) { /* Reflect the change to all FAT copies */
9D00025C  92130003   LBU S3, 3(S0)
9D000260  2E620002   SLTIU V0, S3, 2
9D000264  1440000D   BNE V0, ZERO, 0x9D00029C
9D000268  00000000   NOP
9D000288  2673FFFF   ADDIU S3, S3, -1
9D00028C  327300FF   ANDI S3, S3, 255
9D000290  24020001   ADDIU V0, ZERO, 1
9D000294  5662FFF6   BNEL S3, V0, 0x9D000270
9D000298  8E020020   LW V0, 32(S0)
714:                 					wsect += fs->fsize;
9D00026C  8E020020   LW V0, 32(S0)
9D000270  02228821   ADDU S1, S1, V0
715:                 					disk_write(fs->drv, fs->win, wsect, 1);
9D000274  92040001   LBU A0, 1(S0)
9D000278  02802821   ADDU A1, S4, ZERO
9D00027C  02203021   ADDU A2, S1, ZERO
9D000280  0F4025DC   JAL disk_write
9D000284  24070001   ADDIU A3, ZERO, 1
716:                 				}
717:                 			}
718:                 		}
719:                 #endif
720:                 		if (sector) {
9D00029C  1240000A   BEQ S2, ZERO, 0x9D0002C8
9D0002A0  00001821   ADDU V1, ZERO, ZERO
721:                 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
9D0002A4  92040001   LBU A0, 1(S0)
9D0002A8  26050034   ADDIU A1, S0, 52
9D0002AC  02403021   ADDU A2, S2, ZERO
9D0002B0  0F4025A6   JAL disk_read
9D0002B4  24070001   ADDIU A3, ZERO, 1
9D0002B8  14400003   BNE V0, ZERO, 0x9D0002C8
9D0002BC  24030001   ADDIU V1, ZERO, 1
722:                 				return FR_DISK_ERR;
723:                 			fs->winsect = sector;
9D0002C0  AE120030   SW S2, 48(S0)
724:                 		}
725:                 	}
726:                 
727:                 	return FR_OK;
9D0002C4  00001821   ADDU V1, ZERO, ZERO
728:                 }
9D0002C8  00601021   ADDU V0, V1, ZERO
9D0002CC  8FBF0024   LW RA, 36(SP)
9D0002D0  8FB40020   LW S4, 32(SP)
9D0002D4  8FB3001C   LW S3, 28(SP)
9D0002D8  8FB20018   LW S2, 24(SP)
9D0002DC  8FB10014   LW S1, 20(SP)
9D0002E0  8FB00010   LW S0, 16(SP)
9D0002E4  03E00008   JR RA
9D0002E8  27BD0028   ADDIU SP, SP, 40
729:                 
730:                 /*-----------------------------------------------------------------------*/
731:                 /* Clean-up cached data                                                  */
732:                 /*-----------------------------------------------------------------------*/
733:                 #if !_FS_READONLY
734:                 static FRESULT sync( /* FR_OK: successful, FR_DISK_ERR: failed */
735:                 FATFS *fs /* File system object */
736:                 ) {
9D0003C4  27BDFFE0   ADDIU SP, SP, -32
9D0003C8  AFBF001C   SW RA, 28(SP)
9D0003CC  AFB20018   SW S2, 24(SP)
9D0003D0  AFB10014   SW S1, 20(SP)
9D0003D4  AFB00010   SW S0, 16(SP)
9D0003D8  00808821   ADDU S1, A0, ZERO
737:                 	FRESULT res;
738:                 
739:                 	res = move_window(fs, 0);
9D0003DC  0F40007A   JAL move_window
9D0003E0  00002821   ADDU A1, ZERO, ZERO
740:                 	if (res == FR_OK) {
9D0003E4  1440003A   BNE V0, ZERO, 0x9D0004D0
9D0003E8  00408021   ADDU S0, V0, ZERO
741:                 		/* Update FSInfo sector if needed */
742:                 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
9D0003EC  92230000   LBU V1, 0(S1)
9D0003F0  24020003   ADDIU V0, ZERO, 3
9D0003F4  54620031   BNEL V1, V0, 0x9D0004BC
9D0003F8  92240001   LBU A0, 1(S1)
9D0003FC  92220005   LBU V0, 5(S1)
9D000400  5040002E   BEQL V0, ZERO, 0x9D0004BC
9D000404  92240001   LBU A0, 1(S1)
743:                 			fs->winsect = 0;
9D000408  AE200030   SW ZERO, 48(S1)
744:                 			/* Create FSInfo structure */
745:                 			mem_set(fs->win, 0, 512);
9D00040C  26320034   ADDIU S2, S1, 52
9D000410  02402021   ADDU A0, S2, ZERO
9D000414  00002821   ADDU A1, ZERO, ZERO
9D000418  0F40000A   JAL mem_set
9D00041C  24060200   ADDIU A2, ZERO, 512
746:                 			ST_WORD(fs->win+BS_55AA, 0xAA55);
9D000420  24020055   ADDIU V0, ZERO, 85
9D000424  A2220232   SB V0, 562(S1)
9D000428  2402FFAA   ADDIU V0, ZERO, -86
9D00042C  A2220233   SB V0, 563(S1)
747:                 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
9D000430  24020052   ADDIU V0, ZERO, 82
9D000434  A2220034   SB V0, 52(S1)
9D000438  A2220035   SB V0, 53(S1)
9D00043C  24020061   ADDIU V0, ZERO, 97
9D000440  A2220036   SB V0, 54(S1)
9D000444  24030041   ADDIU V1, ZERO, 65
9D000448  A2230037   SB V1, 55(S1)
748:                 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
9D00044C  24040072   ADDIU A0, ZERO, 114
9D000450  A2240218   SB A0, 536(S1)
9D000454  A2240219   SB A0, 537(S1)
9D000458  A223021A   SB V1, 538(S1)
9D00045C  A222021B   SB V0, 539(S1)
749:                 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
9D000460  8E220010   LW V0, 16(S1)
9D000464  A222021C   SB V0, 540(S1)
9D000468  7C433A00   EXT V1, V0, 8, 8
9D00046C  A223021D   SB V1, 541(S1)
9D000470  00021C02   SRL V1, V0, 16
9D000474  A223021E   SB V1, 542(S1)
9D000478  00021602   SRL V0, V0, 24
9D00047C  A222021F   SB V0, 543(S1)
750:                 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
9D000480  8E22000C   LW V0, 12(S1)
9D000484  A2220220   SB V0, 544(S1)
9D000488  7C433A00   EXT V1, V0, 8, 8
9D00048C  A2230221   SB V1, 545(S1)
9D000490  00021C02   SRL V1, V0, 16
9D000494  A2230222   SB V1, 546(S1)
9D000498  00021602   SRL V0, V0, 24
9D00049C  A2220223   SB V0, 547(S1)
751:                 			/* Write it into the FSInfo sector */
752:                 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
9D0004A0  92240001   LBU A0, 1(S1)
9D0004A4  02402821   ADDU A1, S2, ZERO
9D0004A8  8E260014   LW A2, 20(S1)
9D0004AC  0F4025DC   JAL disk_write
9D0004B0  24070001   ADDIU A3, ZERO, 1
753:                 			fs->fsi_flag = 0;
9D0004B4  A2200005   SB ZERO, 5(S1)
754:                 		}
755:                 		/* Make sure that no pending write process in the physical drive */
756:                 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
9D0004B8  92240001   LBU A0, 1(S1)
9D0004BC  00002821   ADDU A1, ZERO, ZERO
9D0004C0  0F402621   JAL disk_ioctl
9D0004C4  00003021   ADDU A2, ZERO, ZERO
757:                 			res = FR_DISK_ERR;
9D0004C8  24030001   ADDIU V1, ZERO, 1
9D0004CC  0062800B   MOVN S0, V1, V0
758:                 	}
759:                 
760:                 	return res;
761:                 }
9D0004D0  02001021   ADDU V0, S0, ZERO
9D0004D4  8FBF001C   LW RA, 28(SP)
9D0004D8  8FB20018   LW S2, 24(SP)
9D0004DC  8FB10014   LW S1, 20(SP)
9D0004E0  8FB00010   LW S0, 16(SP)
9D0004E4  03E00008   JR RA
9D0004E8  27BD0020   ADDIU SP, SP, 32
762:                 #endif
763:                 
764:                 /*-----------------------------------------------------------------------*/
765:                 /* Get sector# from cluster#                                             */
766:                 /*-----------------------------------------------------------------------*/
767:                 
768:                 DWORD clust2sect( /* !=0: Sector number, 0: Failed - invalid cluster# */
769:                 FATFS *fs, /* File system object */
770:                 DWORD clst /* Cluster# to be converted */
771:                 ) {
772:                 	clst -= 2;
9D000538  24A5FFFE   ADDIU A1, A1, -2
773:                 	if (clst >= (fs->n_fatent - 2))
9D00053C  8C83001C   LW V1, 28(A0)
9D000540  2463FFFE   ADDIU V1, V1, -2
9D000544  00A3182B   SLTU V1, A1, V1
9D000548  10600005   BEQ V1, ZERO, 0x9D000560
9D00054C  00001021   ADDU V0, ZERO, ZERO
774:                 		return 0; /* Invalid cluster# */
775:                 	return clst * fs->csize + fs->database;
9D000550  90830002   LBU V1, 2(A0)
9D000554  8C82002C   LW V0, 44(A0)
9D000558  70A32002   MUL A0, A1, V1
9D00055C  00821021   ADDU V0, A0, V0
776:                 }
9D000560  03E00008   JR RA
9D000564  00000000   NOP
777:                 
778:                 /*-----------------------------------------------------------------------*/
779:                 /* FAT access - Read value of a FAT entry                                */
780:                 /*-----------------------------------------------------------------------*/
781:                 
782:                 DWORD get_fat( /* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
783:                 FATFS *fs, /* File system object */
784:                 DWORD clst /* Cluster# to get the link information */
785:                 ) {
9D000568  27BDFFD8   ADDIU SP, SP, -40
9D00056C  AFBF0024   SW RA, 36(SP)
9D000570  AFB30020   SW S3, 32(SP)
9D000574  AFB2001C   SW S2, 28(SP)
9D000578  AFB10018   SW S1, 24(SP)
9D00057C  AFB00014   SW S0, 20(SP)
9D000580  00808021   ADDU S0, A0, ZERO
9D000584  00A08821   ADDU S1, A1, ZERO
786:                 	UINT wc, bc;
787:                 	PF_BYTE *p;
788:                 
789:                 	if (clst < 2 || clst >= fs->n_fatent) /* Chack range */
9D000588  2CA20002   SLTIU V0, A1, 2
9D00058C  1440004F   BNE V0, ZERO, 0x9D0006CC
9D000590  24030001   ADDIU V1, ZERO, 1
9D000594  8C82001C   LW V0, 28(A0)
9D000598  00A2102B   SLTU V0, A1, V0
9D00059C  1040004C   BEQ V0, ZERO, 0x9D0006D0
9D0005A0  00601021   ADDU V0, V1, ZERO
790:                 		return 1;
791:                 
792:                 	switch (fs->fs_type) {
9D0005A4  90820000   LBU V0, 0(A0)
9D0005A8  24030002   ADDIU V1, ZERO, 2
9D0005AC  50430025   BEQL V0, V1, 0x9D000644
9D0005B0  00052A02   SRL A1, A1, 8
9D0005B4  24030003   ADDIU V1, ZERO, 3
9D0005B8  5043002F   BEQL V0, V1, 0x9D000678
9D0005BC  000529C2   SRL A1, A1, 7
9D0005C0  24030001   ADDIU V1, ZERO, 1
9D0005C4  54430041   BNEL V0, V1, 0x9D0006CC
9D0005C8  2403FFFF   ADDIU V1, ZERO, -1
793:                 	case FS_FAT12:
794:                 		bc = (UINT) clst;
795:                 		bc += bc / 2;
9D0005CC  00059042   SRL S2, A1, 1
9D0005D0  02459021   ADDU S2, S2, A1
796:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D0005D4  00122A42   SRL A1, S2, 9
9D0005D8  8C820024   LW V0, 36(A0)
9D0005DC  0F40007A   JAL move_window
9D0005E0  00A22821   ADDU A1, A1, V0
9D0005E4  14400039   BNE V0, ZERO, 0x9D0006CC
9D0005E8  2403FFFF   ADDIU V1, ZERO, -1
797:                 			break;
798:                 		wc = fs->win[bc % SS(fs)];
9D0005EC  324201FF   ANDI V0, S2, 511
9D0005F0  02021021   ADDU V0, S0, V0
9D0005F4  90530034   LBU S3, 52(V0)
799:                 		bc++;
9D0005F8  26520001   ADDIU S2, S2, 1
800:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D0005FC  00122A42   SRL A1, S2, 9
9D000600  8E020024   LW V0, 36(S0)
9D000604  02002021   ADDU A0, S0, ZERO
9D000608  0F40007A   JAL move_window
9D00060C  00A22821   ADDU A1, A1, V0
9D000610  1440002E   BNE V0, ZERO, 0x9D0006CC
9D000614  2403FFFF   ADDIU V1, ZERO, -1
801:                 			break;
802:                 		wc |= fs->win[bc % SS(fs)] << 8;
9D000618  325201FF   ANDI S2, S2, 511
9D00061C  02128021   ADDU S0, S0, S2
9D000620  92030034   LBU V1, 52(S0)
9D000624  00031A00   SLL V1, V1, 8
9D000628  00739825   OR S3, V1, S3
803:                 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
9D00062C  32310001   ANDI S1, S1, 1
9D000630  00131102   SRL V0, S3, 4
9D000634  32730FFF   ANDI S3, S3, 4095
9D000638  00401821   ADDU V1, V0, ZERO
9D00063C  0B4001B3   J 0x9D0006CC
9D000640  0271180A   MOVZ V1, S3, S1
804:                 
805:                 	case FS_FAT16:
806:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))))
9D000644  8C820024   LW V0, 36(A0)
9D000648  0F40007A   JAL move_window
9D00064C  00A22821   ADDU A1, A1, V0
9D000650  1440001E   BNE V0, ZERO, 0x9D0006CC
9D000654  2403FFFF   ADDIU V1, ZERO, -1
807:                 			break;
808:                 		p = &fs->win[clst * 2 % SS(fs)];
9D000658  00118840   SLL S1, S1, 1
9D00065C  323101FF   ANDI S1, S1, 511
809:                 		return LD_WORD(p);
9D000660  02111021   ADDU V0, S0, S1
9D000664  90430035   LBU V1, 53(V0)
9D000668  00031A00   SLL V1, V1, 8
9D00066C  90420034   LBU V0, 52(V0)
9D000670  0B4001B3   J 0x9D0006CC
9D000674  00621825   OR V1, V1, V0
810:                 
811:                 	case FS_FAT32:
812:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))))
9D000678  8C820024   LW V0, 36(A0)
9D00067C  0F40007A   JAL move_window
9D000680  00A22821   ADDU A1, A1, V0
9D000684  14400011   BNE V0, ZERO, 0x9D0006CC
9D000688  2403FFFF   ADDIU V1, ZERO, -1
813:                 			break;
814:                 		p = &fs->win[clst * 4 % SS(fs)];
9D00068C  00118880   SLL S1, S1, 2
9D000690  323101FF   ANDI S1, S1, 511
9D000694  02111021   ADDU V0, S0, S1
9D0006A4  24420034   ADDIU V0, V0, 52
815:                 		return LD_DWORD(p) & 0x0FFFFFFF;
9D000698  90440036   LBU A0, 54(V0)
9D00069C  00042400   SLL A0, A0, 16
9D0006A0  90430037   LBU V1, 55(V0)
9D0006A8  00031E00   SLL V1, V1, 24
9D0006AC  00831825   OR V1, A0, V1
9D0006B0  90420001   LBU V0, 1(V0)
9D0006B4  00021200   SLL V0, V0, 8
9D0006B8  00621825   OR V1, V1, V0
9D0006BC  02118021   ADDU S0, S0, S1
9D0006C0  92020034   LBU V0, 52(S0)
9D0006C4  00621825   OR V1, V1, V0
9D0006C8  7C63D800   EXT V1, V1, 0, 28
816:                 	}
817:                 
818:                 	return 0xFFFFFFFF; /* An error occurred at the disk I/O layer */
819:                 }
9D0006CC  00601021   ADDU V0, V1, ZERO
9D0006D0  8FBF0024   LW RA, 36(SP)
9D0006D4  8FB30020   LW S3, 32(SP)
9D0006D8  8FB2001C   LW S2, 28(SP)
9D0006DC  8FB10018   LW S1, 24(SP)
9D0006E0  8FB00014   LW S0, 20(SP)
9D0006E4  03E00008   JR RA
9D0006E8  27BD0028   ADDIU SP, SP, 40
820:                 
821:                 /*-----------------------------------------------------------------------*/
822:                 /* FAT access - Change value of a FAT entry                              */
823:                 /*-----------------------------------------------------------------------*/
824:                 #if !_FS_READONLY
825:                 
826:                 FRESULT put_fat(FATFS *fs, /* File system object */
827:                 DWORD clst, /* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
828:                 DWORD val /* New value to mark the cluster */
829:                 ) {
9D0008A8  27BDFFD8   ADDIU SP, SP, -40
9D0008AC  AFBF0024   SW RA, 36(SP)
9D0008B0  AFB30020   SW S3, 32(SP)
9D0008B4  AFB2001C   SW S2, 28(SP)
9D0008B8  AFB10018   SW S1, 24(SP)
9D0008BC  AFB00014   SW S0, 20(SP)
9D0008C0  00808021   ADDU S0, A0, ZERO
9D0008C4  00A08821   ADDU S1, A1, ZERO
9D0008C8  00C09021   ADDU S2, A2, ZERO
830:                 	UINT bc;
831:                 	PF_BYTE *p;
832:                 	FRESULT res;
833:                 
834:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D0008CC  2CA30002   SLTIU V1, A1, 2
9D0008D0  1460005D   BNE V1, ZERO, 0x9D000A48
9D0008D4  24020002   ADDIU V0, ZERO, 2
9D0008D8  8C83001C   LW V1, 28(A0)
9D0008DC  00A3182B   SLTU V1, A1, V1
9D0008E0  10600059   BEQ V1, ZERO, 0x9D000A48
9D0008E4  24030002   ADDIU V1, ZERO, 2
835:                 		res = FR_INT_ERR;
836:                 
837:                 	} else {
838:                 		switch (fs->fs_type) {
9D0008E8  90820000   LBU V0, 0(A0)
9D0008EC  10430030   BEQ V0, V1, 0x9D0009B0
9D0008F0  24030003   ADDIU V1, ZERO, 3
9D0008F4  1043003B   BEQ V0, V1, 0x9D0009E4
9D0008F8  24030001   ADDIU V1, ZERO, 1
9D0008FC  14430050   BNE V0, V1, 0x9D000A40
9D000900  24020002   ADDIU V0, ZERO, 2
839:                 		case FS_FAT12:
840:                 			bc = clst;
841:                 			bc += bc / 2;
9D000904  00059842   SRL S3, A1, 1
9D000908  02659821   ADDU S3, S3, A1
842:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D00090C  00132A42   SRL A1, S3, 9
9D000910  8C820024   LW V0, 36(A0)
9D000914  0F40007A   JAL move_window
9D000918  00A22821   ADDU A1, A1, V0
843:                 			if (res != FR_OK)
9D00091C  14400049   BNE V0, ZERO, 0x9D000A44
9D000920  24030001   ADDIU V1, ZERO, 1
844:                 				break;
845:                 			p = &fs->win[bc % SS(fs)];
9D000924  326301FF   ANDI V1, S3, 511
846:                 			*p = (clst & 1) ? ((*p & 0x0F) | ((PF_BYTE) val << 4))
9D000928  32310001   ANDI S1, S1, 1
9D00092C  12200008   BEQ S1, ZERO, 0x9D000950
9D000930  324200FF   ANDI V0, S2, 255
9D000934  02031021   ADDU V0, S0, V1
9D000938  90440034   LBU A0, 52(V0)
9D00093C  3084000F   ANDI A0, A0, 15
9D000940  324200FF   ANDI V0, S2, 255
9D000944  00021100   SLL V0, V0, 4
9D000948  00821025   OR V0, A0, V0
9D00094C  304200FF   ANDI V0, V0, 255
9D000950  02031821   ADDU V1, S0, V1
9D000954  A0620034   SB V0, 52(V1)
847:                 					: (PF_BYTE) val;
848:                 			bc++;
9D000958  26730001   ADDIU S3, S3, 1
849:                 			fs->wflag = 1;
9D00095C  24020001   ADDIU V0, ZERO, 1
9D000960  A2020004   SB V0, 4(S0)
850:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D000964  00132A42   SRL A1, S3, 9
9D000968  8E020024   LW V0, 36(S0)
9D00096C  02002021   ADDU A0, S0, ZERO
9D000970  0F40007A   JAL move_window
9D000974  00A22821   ADDU A1, A1, V0
851:                 			if (res != FR_OK)
9D000978  14400032   BNE V0, ZERO, 0x9D000A44
9D00097C  24030001   ADDIU V1, ZERO, 1
852:                 				break;
853:                 			p = &fs->win[bc % SS(fs)];
854:                 			*p = (clst & 1) ? (PF_BYTE) (val >> 4) : ((*p & 0xF0)
9D000980  12200003   BEQ S1, ZERO, 0x9D000990
9D000984  327301FF   ANDI S3, S3, 511
9D000988  0B400269   J 0x9D0009A4
9D00098C  7E523900   EXT S2, S2, 4, 8
9D000990  02131821   ADDU V1, S0, S3
9D000994  90630034   LBU V1, 52(V1)
9D000998  306300F0   ANDI V1, V1, 240
9D00099C  7E521A00   EXT S2, S2, 8, 4
9D0009A0  00729025   OR S2, V1, S2
9D0009A4  02139821   ADDU S3, S0, S3
855:                 					| ((PF_BYTE) (val >> 8) & 0x0F));
856:                 			break;
9D0009A8  0B400290   J 0x9D000A40
9D0009AC  A2720034   SB S2, 52(S3)
857:                 
858:                 		case FS_FAT16:
859:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
9D0009B0  00052A02   SRL A1, A1, 8
9D0009B4  8C820024   LW V0, 36(A0)
9D0009B8  0F40007A   JAL move_window
9D0009BC  00A22821   ADDU A1, A1, V0
860:                 			if (res != FR_OK)
9D0009C0  14400020   BNE V0, ZERO, 0x9D000A44
9D0009C4  24030001   ADDIU V1, ZERO, 1
861:                 				break;
862:                 			p = &fs->win[clst * 2 % SS(fs)];
9D0009C8  00118840   SLL S1, S1, 1
9D0009CC  323101FF   ANDI S1, S1, 511
863:                 			ST_WORD(p, (PF_WORD)val)
9D0009D0  02111821   ADDU V1, S0, S1
9D0009D4  A0720034   SB S2, 52(V1)
9D0009D8  7E523A00   EXT S2, S2, 8, 8
864:                 			;
865:                 			break;
9D0009DC  0B400290   J 0x9D000A40
9D0009E0  A0720035   SB S2, 53(V1)
866:                 
867:                 		case FS_FAT32:
868:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
9D0009E4  000529C2   SRL A1, A1, 7
9D0009E8  8C820024   LW V0, 36(A0)
9D0009EC  0F40007A   JAL move_window
9D0009F0  00A22821   ADDU A1, A1, V0
869:                 			if (res != FR_OK)
9D0009F4  14400013   BNE V0, ZERO, 0x9D000A44
9D0009F8  24030001   ADDIU V1, ZERO, 1
870:                 				break;
871:                 			p = &fs->win[clst * 4 % SS(fs)];
9D0009FC  00118880   SLL S1, S1, 2
9D000A00  323101FF   ANDI S1, S1, 511
9D000A04  26230030   ADDIU V1, S1, 48
9D000A08  02031821   ADDU V1, S0, V1
872:                 			val |= LD_DWORD(p) & 0xF0000000;
9D000A0C  90640007   LBU A0, 7(V1)
9D000A10  00042600   SLL A0, A0, 24
9D000A14  02118821   ADDU S1, S0, S1
9D000A18  3C05F000   LUI A1, -4096
9D000A1C  00852024   AND A0, A0, A1
9D000A20  00929025   OR S2, A0, S2
873:                 			ST_DWORD(p, val)
9D000A24  A2320034   SB S2, 52(S1)
9D000A28  7E443A00   EXT A0, S2, 8, 8
9D000A2C  A0640005   SB A0, 5(V1)
9D000A30  00122402   SRL A0, S2, 16
9D000A34  A0640006   SB A0, 6(V1)
9D000A38  00129602   SRL S2, S2, 24
9D000A3C  A0720007   SB S2, 7(V1)
874:                 			;
875:                 			break;
876:                 
877:                 		default:
878:                 			res = FR_INT_ERR;
879:                 		}
880:                 		fs->wflag = 1;
9D000A40  24030001   ADDIU V1, ZERO, 1
9D000A44  A2030004   SB V1, 4(S0)
881:                 	}
882:                 
883:                 	return res;
884:                 }
9D000A48  8FBF0024   LW RA, 36(SP)
9D000A4C  8FB30020   LW S3, 32(SP)
9D000A50  8FB2001C   LW S2, 28(SP)
9D000A54  8FB10018   LW S1, 24(SP)
9D000A58  8FB00014   LW S0, 20(SP)
9D000A5C  03E00008   JR RA
9D000A60  27BD0028   ADDIU SP, SP, 40
885:                 #endif /* !_FS_READONLY */
886:                 
887:                 /*-----------------------------------------------------------------------*/
888:                 /* FAT handling - Remove a cluster chain                                 */
889:                 /*-----------------------------------------------------------------------*/
890:                 #if !_FS_READONLY
891:                 static FRESULT remove_chain(FATFS *fs, /* File system object */
892:                 DWORD clst /* Cluster# to remove a chain from */
893:                 ) {
9D0013BC  27BDFFD0   ADDIU SP, SP, -48
9D0013C0  AFBF002C   SW RA, 44(SP)
9D0013C4  AFB50028   SW S5, 40(SP)
9D0013C8  AFB40024   SW S4, 36(SP)
9D0013CC  AFB30020   SW S3, 32(SP)
9D0013D0  AFB2001C   SW S2, 28(SP)
9D0013D4  AFB10018   SW S1, 24(SP)
9D0013D8  AFB00014   SW S0, 20(SP)
9D0013DC  00808821   ADDU S1, A0, ZERO
9D0013E0  00A09021   ADDU S2, A1, ZERO
894:                 	FRESULT res;
895:                 	DWORD nxt;
896:                 #if _USE_ERASE
897:                 	DWORD scl = clst, ecl = clst, resion[2];
898:                 #endif
899:                 
900:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D0013E4  2CA30002   SLTIU V1, A1, 2
9D0013E8  14600025   BNE V1, ZERO, 0x9D001480
9D0013EC  24020002   ADDIU V0, ZERO, 2
9D0013F0  8C83001C   LW V1, 28(A0)
9D0013F4  00A3182B   SLTU V1, A1, V1
9D0013F8  14600003   BNE V1, ZERO, 0x9D001408
9D0013FC  24140001   ADDIU S4, ZERO, 1
901:                 		res = FR_INT_ERR;
902:                 
903:                 	} else {
904:                 		res = FR_OK;
905:                 		while (clst < fs->n_fatent) { /* Not a last link? */
9D00145C  8E23001C   LW V1, 28(S1)
9D001460  0203182B   SLTU V1, S0, V1
9D001464  1460FFEA   BNE V1, ZERO, 0x9D001410
9D001468  02009021   ADDU S2, S0, ZERO
906:                 			nxt = get_fat(fs, clst); /* Get cluster status */
9D001410  02202021   ADDU A0, S1, ZERO
9D001414  0F40015A   JAL get_fat
9D001418  02402821   ADDU A1, S2, ZERO
907:                 			if (nxt == 0)
9D00141C  10400015   BEQ V0, ZERO, 0x9D001474
9D001420  00408021   ADDU S0, V0, ZERO
9D001474  0B400520   J 0x9D001480
9D001478  00001021   ADDU V0, ZERO, ZERO
908:                 				break; /* Empty cluster? */
909:                 			if (nxt == 1) {
9D001424  50540016   BEQL V0, S4, 0x9D001480
9D001428  24020002   ADDIU V0, ZERO, 2
910:                 				res = FR_INT_ERR;
911:                 				break;
912:                 			} /* Internal error? */
913:                 			if (nxt == 0xFFFFFFFF) {
9D001408  2413FFFF   ADDIU S3, ZERO, -1
9D00142C  10530013   BEQ V0, S3, 0x9D00147C
9D001430  02202021   ADDU A0, S1, ZERO
914:                 				res = FR_DISK_ERR;
9D00147C  24020001   ADDIU V0, ZERO, 1
915:                 				break;
916:                 			} /* Disk error? */
917:                 			res = put_fat(fs, clst, 0); /* Mark the cluster "empty" */
9D001434  02402821   ADDU A1, S2, ZERO
9D001438  0F40022A   JAL put_fat
9D00143C  00003021   ADDU A2, ZERO, ZERO
918:                 			if (res != FR_OK)
9D001440  14400010   BNE V0, ZERO, 0x9D001484
9D001444  8FBF002C   LW RA, 44(SP)
919:                 				break;
920:                 			if (fs->free_clust != 0xFFFFFFFF) { /* Update FSInfo */
9D001448  8E230010   LW V1, 16(S1)
9D00144C  10730003   BEQ V1, S3, 0x9D00145C
9D001450  24630001   ADDIU V1, V1, 1
921:                 				fs->free_clust++;
9D001454  AE230010   SW V1, 16(S1)
922:                 				fs->fsi_flag = 1;
9D00140C  24150001   ADDIU S5, ZERO, 1
9D001458  A2350005   SB S5, 5(S1)
923:                 			}
924:                 #if _USE_ERASE
925:                 			if (ecl + 1 == nxt) { /* Next cluster is contiguous */
926:                 				ecl = nxt;
927:                 			} else { /* End of contiguous clusters */
928:                 				resion[0] = clust2sect(fs, scl); /* Start sector */
929:                 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1; /* End sector */
930:                 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion); /* Erase the block */
931:                 				scl = ecl = nxt;
932:                 			}
933:                 #endif
934:                 			clst = nxt; /* Next cluster */
935:                 		}
936:                 	}
937:                 
938:                 	return res;
939:                 }
9D001400  0B400521   J 0x9D001484
9D001404  8FBF002C   LW RA, 44(SP)
9D00146C  0B400521   J 0x9D001484
9D001470  8FBF002C   LW RA, 44(SP)
9D001480  8FBF002C   LW RA, 44(SP)
9D001484  8FB50028   LW S5, 40(SP)
9D001488  8FB40024   LW S4, 36(SP)
9D00148C  8FB30020   LW S3, 32(SP)
9D001490  8FB2001C   LW S2, 28(SP)
9D001494  8FB10018   LW S1, 24(SP)
9D001498  8FB00014   LW S0, 20(SP)
9D00149C  03E00008   JR RA
9D0014A0  27BD0030   ADDIU SP, SP, 48
940:                 #endif
941:                 
942:                 /*-----------------------------------------------------------------------*/
943:                 /* FAT handling - Stretch or Create a cluster chain                      */
944:                 /*-----------------------------------------------------------------------*/
945:                 #if !_FS_READONLY
946:                 static DWORD create_chain( /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
947:                 FATFS *fs, /* File system object */
948:                 DWORD clst /* Cluster# to stretch. 0 means create a new chain. */
949:                 ) {
9D000A64  27BDFFD0   ADDIU SP, SP, -48
9D000A68  AFBF002C   SW RA, 44(SP)
9D000A6C  AFB60028   SW S6, 40(SP)
9D000A70  AFB50024   SW S5, 36(SP)
9D000A74  AFB40020   SW S4, 32(SP)
9D000A78  AFB3001C   SW S3, 28(SP)
9D000A7C  AFB20018   SW S2, 24(SP)
9D000A80  AFB10014   SW S1, 20(SP)
9D000A84  AFB00010   SW S0, 16(SP)
9D000A88  00808821   ADDU S1, A0, ZERO
950:                 	DWORD cs, ncl, scl;
951:                 	FRESULT res;
952:                 
953:                 	if (clst == 0) { /* Create a new chain */
9D000A8C  14A00009   BNE A1, ZERO, 0x9D000AB4
9D000A90  00A0B021   ADDU S6, A1, ZERO
954:                 		scl = fs->last_clust; /* Get suggested start point */
9D000A94  8C92000C   LW S2, 12(A0)
955:                 		if (!scl || scl >= fs->n_fatent)
9D000A98  52400011   BEQL S2, ZERO, 0x9D000AE0
9D000A9C  24120001   ADDIU S2, ZERO, 1
9D000AA0  8C83001C   LW V1, 28(A0)
9D000AA4  0243182B   SLTU V1, S2, V1
956:                 			scl = 1;
9D000AA8  24020001   ADDIU V0, ZERO, 1
9D000AAC  0B4002B8   J 0x9D000AE0
9D000AB0  0043900A   MOVZ S2, V0, V1
957:                 	} else { /* Stretch the current chain */
958:                 		cs = get_fat(fs, clst); /* Check the cluster status */
9D000AB4  0F40015A   JAL get_fat
9D000AB8  00000000   NOP
959:                 		if (cs < 2)
9D000ABC  2C430002   SLTIU V1, V0, 2
9D000AC0  5460003F   BNEL V1, ZERO, 0x9D000BC0
9D000AC4  24020001   ADDIU V0, ZERO, 1
960:                 			return 1; /* It is an invalid cluster */
961:                 		if (cs < fs->n_fatent)
9D000AC8  8E23001C   LW V1, 28(S1)
9D000ACC  0043182B   SLTU V1, V0, V1
9D000AD0  10600003   BEQ V1, ZERO, 0x9D000AE0
9D000AD4  02C09021   ADDU S2, S6, ZERO
962:                 			return cs; /* It is already followed by next cluster */
963:                 		scl = clst;
964:                 	}
965:                 
966:                 	ncl = scl; /* Start cluster */
9D000AE0  02408021   ADDU S0, S2, ZERO
967:                 	for (;;) {
968:                 		ncl++; /* Next cluster */
9D000AF0  26100001   ADDIU S0, S0, 1
969:                 		if (ncl >= fs->n_fatent) { /* Wrap around */
9D000AF4  8E22001C   LW V0, 28(S1)
9D000AF8  0202102B   SLTU V0, S0, V0
9D000AFC  14400004   BNE V0, ZERO, 0x9D000B10
9D000B00  02202021   ADDU A0, S1, ZERO
970:                 			ncl = 2;
971:                 			if (ncl > scl)
9D000AE4  2E550002   SLTIU S5, S2, 2
9D000B04  16A0002D   BNE S5, ZERO, 0x9D000BBC
9D000B08  24100002   ADDIU S0, ZERO, 2
972:                 				return 0; /* No free cluster */
973:                 		}
974:                 		cs = get_fat(fs, ncl); /* Get the cluster status */
9D000B0C  02202021   ADDU A0, S1, ZERO
9D000B10  0F40015A   JAL get_fat
9D000B14  02002821   ADDU A1, S0, ZERO
975:                 		if (cs == 0)
9D000B18  50400009   BEQL V0, ZERO, 0x9D000B40
9D000B1C  02009021   ADDU S2, S0, ZERO
976:                 			break; /* Found a free cluster */
977:                 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
9D000AE8  2413FFFF   ADDIU S3, ZERO, -1
9D000AEC  24140001   ADDIU S4, ZERO, 1
9D000B20  10530028   BEQ V0, S3, 0x9D000BC4
9D000B24  8FBF002C   LW RA, 44(SP)
9D000B28  50540027   BEQL V0, S4, 0x9D000BC8
9D000B2C  8FB60028   LW S6, 40(SP)
978:                 			return cs;
979:                 		if (ncl == scl)
9D000B30  1612FFF0   BNE S0, S2, 0x9D000AF4
9D000B34  26100001   ADDIU S0, S0, 1
980:                 			return 0; /* No free cluster */
9D000B38  0B4002F0   J 0x9D000BC0
9D000B3C  00001021   ADDU V0, ZERO, ZERO
981:                 	}
982:                 
983:                 	res = put_fat(fs, ncl, 0x0FFFFFFF); /* Mark the new cluster "last link" */
9D000B40  02202021   ADDU A0, S1, ZERO
9D000B44  02002821   ADDU A1, S0, ZERO
9D000B48  3C060FFF   LUI A2, 4095
9D000B4C  0F40022A   JAL put_fat
9D000B50  34C6FFFF   ORI A2, A2, -1
984:                 	if (res == FR_OK && clst != 0) {
9D000B54  54400014   BNEL V0, ZERO, 0x9D000BA8
9D000B58  38420001   XORI V0, V0, 1
9D000B5C  52C00008   BEQL S6, ZERO, 0x9D000B80
9D000B60  AE32000C   SW S2, 12(S1)
985:                 		res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
9D000B64  02202021   ADDU A0, S1, ZERO
9D000B68  02C02821   ADDU A1, S6, ZERO
9D000B6C  0F40022A   JAL put_fat
9D000B70  02003021   ADDU A2, S0, ZERO
986:                 	}
987:                 	if (res == FR_OK) {
9D000B74  5440000C   BNEL V0, ZERO, 0x9D000BA8
9D000B78  38420001   XORI V0, V0, 1
988:                 		fs->last_clust = ncl; /* Update FSINFO */
9D000B7C  AE32000C   SW S2, 12(S1)
989:                 		if (fs->free_clust != 0xFFFFFFFF) {
9D000B80  8E230010   LW V1, 16(S1)
9D000B84  2404FFFF   ADDIU A0, ZERO, -1
9D000B88  1064000D   BEQ V1, A0, 0x9D000BC0
9D000B8C  02001021   ADDU V0, S0, ZERO
990:                 			fs->free_clust--;
9D000B90  2463FFFF   ADDIU V1, V1, -1
9D000B94  AE230010   SW V1, 16(S1)
991:                 			fs->fsi_flag = 1;
9D000B98  24020001   ADDIU V0, ZERO, 1
9D000B9C  A2220005   SB V0, 5(S1)
9D000BA0  0B4002F0   J 0x9D000BC0
9D000BA4  02001021   ADDU V0, S0, ZERO
992:                 		}
993:                 	} else {
994:                 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
9D000BA8  2403FFFF   ADDIU V1, ZERO, -1
9D000BAC  24040001   ADDIU A0, ZERO, 1
9D000BB0  0082180B   MOVN V1, A0, V0
9D000BB4  0B4002F0   J 0x9D000BC0
9D000BB8  00601021   ADDU V0, V1, ZERO
9D000BBC  00001021   ADDU V0, ZERO, ZERO
995:                 	}
996:                 
997:                 	return ncl; /* Return new cluster number or error code */
998:                 }
9D000AD8  0B4002F1   J 0x9D000BC4
9D000ADC  8FBF002C   LW RA, 44(SP)
9D000BC0  8FBF002C   LW RA, 44(SP)
9D000BC4  8FB60028   LW S6, 40(SP)
9D000BC8  8FB50024   LW S5, 36(SP)
9D000BCC  8FB40020   LW S4, 32(SP)
9D000BD0  8FB3001C   LW S3, 28(SP)
9D000BD4  8FB20018   LW S2, 24(SP)
9D000BD8  8FB10014   LW S1, 20(SP)
9D000BDC  8FB00010   LW S0, 16(SP)
9D000BE0  03E00008   JR RA
9D000BE4  27BD0030   ADDIU SP, SP, 48
999:                 #endif /* !_FS_READONLY */
1000:                
1001:                /*-----------------------------------------------------------------------*/
1002:                /* FAT handling - Convert offset into cluster with link map table        */
1003:                /*-----------------------------------------------------------------------*/
1004:                
1005:                #if _USE_FASTSEEK
1006:                static DWORD clmt_clust( /* <2:Error, >=2:Cluster number */
1007:                FIL* fp, /* Pointer to the file object */
1008:                DWORD ofs /* File offset to be converted to cluster# */
1009:                ) {
1010:                	DWORD cl, ncl, *tbl;
1011:                
1012:                	tbl = fp->cltbl + 1; /* Top of CLMT */
9D00004C  8C830024   LW V1, 36(A0)
9D000050  24660004   ADDIU A2, V1, 4
1013:                	cl = ofs / SS(fp->fs) / fp->fs->csize; /* Cluster order from top of the file */
9D000054  8C870000   LW A3, 0(A0)
9D000058  90E40002   LBU A0, 2(A3)
9D000068  00051242   SRL V0, A1, 9
9D00006C  0044001B   DIVU V0, A0
9D000070  008001F4   TEQ A0, ZERO
9D000074  00002012   MFLO A0, 0
9D000078  00002812   MFLO A1, 0
1014:                	for (;;) {
1015:                		ncl = *tbl++; /* Number of cluters in the fragment */
9D00005C  8C630004   LW V1, 4(V1)
9D000090  00801821   ADDU V1, A0, ZERO
9D0000A0  8CC40004   LW A0, 4(A2)
1016:                		if (!ncl)
9D000060  10600017   BEQ V1, ZERO, 0x9D0000C0
9D000064  00001021   ADDU V0, ZERO, ZERO
9D0000A4  5480FFFA   BNEL A0, ZERO, 0x9D000090
9D0000A8  00A32823   SUBU A1, A1, V1
1017:                			return 0; /* End of table? (error) */
9D0000AC  03E00008   JR RA
9D0000B0  00001021   ADDU V0, ZERO, ZERO
1018:                		if (cl < ncl)
9D00007C  0083202B   SLTU A0, A0, V1
9D000080  10800007   BEQ A0, ZERO, 0x9D0000A0
9D000084  24C60004   ADDIU A2, A2, 4
9D000094  00A4202B   SLTU A0, A1, A0
9D000098  14800006   BNE A0, ZERO, 0x9D0000B4
9D00009C  24C60008   ADDIU A2, A2, 8
1019:                			break; /* In this fragment? */
1020:                		cl -= ncl;
1021:                		tbl++; /* Next fragment */
1022:                	}
1023:                	return cl + *tbl; /* Return the cluster number */
9D000088  0B40002E   J 0x9D0000B8
9D00008C  8CC20000   LW V0, 0(A2)
9D0000B4  8CC20000   LW V0, 0(A2)
9D0000B8  03E00008   JR RA
9D0000BC  00A21021   ADDU V0, A1, V0
1024:                }
9D0000C0  03E00008   JR RA
9D0000C4  00000000   NOP
1025:                #endif	/* _USE_FASTSEEK */
1026:                
1027:                /*-----------------------------------------------------------------------*/
1028:                /* Directory handling - Set directory index                              */
1029:                /*-----------------------------------------------------------------------*/
1030:                
1031:                static FRESULT dir_sdi(DIR *dj, /* Pointer to directory object */
9D000794  3294FFFF   ANDI S4, S4, -1
9D000798  02328823   SUBU S1, S1, S2
9D00079C  3231FFFF   ANDI S1, S1, -1
9D0007A0  2413FFFF   ADDIU S3, ZERO, -1
1032:                PF_WORD idx /* Directory index number */
1033:                ) {
9D0006EC  27BDFFD8   ADDIU SP, SP, -40
9D0006F0  AFBF0024   SW RA, 36(SP)
9D0006F4  AFB40020   SW S4, 32(SP)
9D0006F8  AFB3001C   SW S3, 28(SP)
9D0006FC  AFB20018   SW S2, 24(SP)
9D000700  AFB10014   SW S1, 20(SP)
9D000704  AFB00010   SW S0, 16(SP)
9D000708  00808021   ADDU S0, A0, ZERO
9D00070C  00A08821   ADDU S1, A1, ZERO
1034:                	DWORD clst;
1035:                	PF_WORD ic;
1036:                
1037:                	dj->index = idx;
9D000710  A4850006   SH A1, 6(A0)
1038:                	clst = dj->sclust;
9D000714  8C850008   LW A1, 8(A0)
1039:                	if (clst == 1 || clst >= dj->fs->n_fatent) /* Check start cluster range */
9D000718  24030001   ADDIU V1, ZERO, 1
9D00071C  10A30044   BEQ A1, V1, 0x9D000830
9D000720  24020002   ADDIU V0, ZERO, 2
9D000724  8C830000   LW V1, 0(A0)
9D000728  8C64001C   LW A0, 28(V1)
9D00072C  00A4202B   SLTU A0, A1, A0
9D000730  50800040   BEQL A0, ZERO, 0x9D000834
9D000734  8FBF0024   LW RA, 36(SP)
1040:                		return FR_INT_ERR;
1041:                	if (!clst && dj->fs->fs_type == FS_FAT32) /* Replace cluster# 0 with root cluster# if in FAT32 */
9D000738  54A00012   BNEL A1, ZERO, 0x9D000784
9D00073C  90720002   LBU S2, 2(V1)
9D000740  90640000   LBU A0, 0(V1)
9D000744  24020003   ADDIU V0, ZERO, 3
9D000748  54820005   BNEL A0, V0, 0x9D000760
9D00074C  AE00000C   SW ZERO, 12(S0)
1042:                		clst = dj->fs->dirbase;
9D000750  8C650028   LW A1, 40(V1)
1043:                
1044:                	if (clst == 0) { /* Static table (root-dir in FAT12/16) */
9D000754  54A0000B   BNEL A1, ZERO, 0x9D000784
9D000758  90720002   LBU S2, 2(V1)
1045:                		dj->clust = clst;
9D00075C  AE00000C   SW ZERO, 12(S0)
1046:                		if (idx >= dj->fs->n_rootdir) /* Index is out of range */
9D000760  94640008   LHU A0, 8(V1)
9D000764  0224202B   SLTU A0, S1, A0
9D000768  10800031   BEQ A0, ZERO, 0x9D000830
9D00076C  24020002   ADDIU V0, ZERO, 2
1047:                			return FR_INT_ERR;
1048:                		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D000770  7E247900   EXT A0, S1, 4, 16
9D000774  8C620028   LW V0, 40(V1)
9D000778  00821021   ADDU V0, A0, V0
9D00077C  0B400201   J 0x9D000804
9D000780  AE020010   SW V0, 16(S0)
1049:                	} else { /* Dynamic table (sub-dirs or root-dir in FAT32) */
1050:                		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize; /* Entries per cluster */
9D000784  00129100   SLL S2, S2, 4
1051:                		while (idx >= ic) { /* Follow cluster chain */
9D000788  0232102B   SLTU V0, S1, S2
9D00078C  14400017   BNE V0, ZERO, 0x9D0007EC
9D000790  0012A023   SUBU S4, ZERO, S2
9D0007D8  00521821   ADDU V1, V0, S2
9D0007DC  3063FFFF   ANDI V1, V1, -1
9D0007E0  0072182B   SLTU V1, V1, S2
9D0007E4  5060FFEF   BEQL V1, ZERO, 0x9D0007A4
9D0007E8  00408821   ADDU S1, V0, ZERO
1052:                			clst = get_fat(dj->fs, clst); /* Get next cluster */
9D0007A4  0F40015A   JAL get_fat
9D0007A8  8E040000   LW A0, 0(S0)
1053:                			if (clst == 0xFFFFFFFF)
9D0007AC  1053001D   BEQ V0, S3, 0x9D000824
9D0007B0  00402821   ADDU A1, V0, ZERO
1054:                				return FR_DISK_ERR; /* Disk error */
9D000824  0B40020C   J 0x9D000830
9D000828  24020001   ADDIU V0, ZERO, 1
1055:                			if (clst < 2 || clst >= dj->fs->n_fatent) /* Reached to end of table or int error */
9D0007B4  2C420002   SLTIU V0, V0, 2
9D0007B8  1440001D   BNE V0, ZERO, 0x9D000830
9D0007BC  24020002   ADDIU V0, ZERO, 2
9D0007C0  8E020000   LW V0, 0(S0)
9D0007C4  8C42001C   LW V0, 28(V0)
9D0007C8  00A2102B   SLTU V0, A1, V0
9D0007CC  10400017   BEQ V0, ZERO, 0x9D00082C
9D0007D0  02341021   ADDU V0, S1, S4
9D0007D4  3042FFFF   ANDI V0, V0, -1
1056:                				return FR_INT_ERR;
9D00082C  24020002   ADDIU V0, ZERO, 2
1057:                			idx -= ic;
1058:                		}
1059:                		dj->clust = clst;
9D0007EC  AE05000C   SW A1, 12(S0)
1060:                		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D0007F0  0F40014E   JAL clust2sect
9D0007F4  8E040000   LW A0, 0(S0)
9D0007F8  7E237900   EXT V1, S1, 4, 16
9D0007FC  00621021   ADDU V0, V1, V0
9D000800  AE020010   SW V0, 16(S0)
1061:                	}
1062:                
1063:                	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR; /* Ptr to the entry in the sector */
9D000804  8E020000   LW V0, 0(S0)
9D000808  24420034   ADDIU V0, V0, 52
9D00080C  3231000F   ANDI S1, S1, 15
9D000810  00118940   SLL S1, S1, 5
9D000814  00518821   ADDU S1, V0, S1
9D000818  AE110014   SW S1, 20(S0)
1064:                
1065:                	return FR_OK; /* Seek succeeded */
9D00081C  0B40020C   J 0x9D000830
9D000820  00001021   ADDU V0, ZERO, ZERO
1066:                }
9D000830  8FBF0024   LW RA, 36(SP)
9D000834  8FB40020   LW S4, 32(SP)
9D000838  8FB3001C   LW S3, 28(SP)
9D00083C  8FB20018   LW S2, 24(SP)
9D000840  8FB10014   LW S1, 20(SP)
9D000844  8FB00010   LW S0, 16(SP)
9D000848  03E00008   JR RA
9D00084C  27BD0028   ADDIU SP, SP, 40
1067:                
1068:                /*-----------------------------------------------------------------------*/
1069:                /* Directory handling - Move directory index next                        */
1070:                /*-----------------------------------------------------------------------*/
1071:                
1072:                static FRESULT dir_next( /* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
1073:                DIR *dj, /* Pointer to directory object */
1074:                int stretch /* 0: Do not stretch table, 1: Stretch table if needed */
1075:                ) {
9D000BE8  27BDFFD8   ADDIU SP, SP, -40
9D000BEC  AFBF0024   SW RA, 36(SP)
9D000BF0  AFB40020   SW S4, 32(SP)
9D000BF4  AFB3001C   SW S3, 28(SP)
9D000BF8  AFB20018   SW S2, 24(SP)
9D000BFC  AFB10014   SW S1, 20(SP)
9D000C00  AFB00010   SW S0, 16(SP)
9D000C04  00808821   ADDU S1, A0, ZERO
9D000C08  00A08021   ADDU S0, A1, ZERO
1076:                	DWORD clst;
1077:                	PF_WORD i;
1078:                
1079:                	stretch = stretch; /* To suppress warning on read-only cfg. */
1080:                	i = dj->index + 1;
9D000C0C  94920006   LHU S2, 6(A0)
9D000C10  26520001   ADDIU S2, S2, 1
9D000C14  3252FFFF   ANDI S2, S2, -1
1081:                	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
9D000C18  1240006C   BEQ S2, ZERO, 0x9D000DCC
9D000C1C  24030004   ADDIU V1, ZERO, 4
9D000C20  8C820010   LW V0, 16(A0)
9D000C24  5040006A   BEQL V0, ZERO, 0x9D000DD0
9D000C28  00601021   ADDU V0, V1, ZERO
1082:                		return FR_NO_FILE;
1083:                
1084:                	if (!(i % (SS(dj->fs) / SZ_DIR))) { /* Sector changed? */
9D000C2C  3243000F   ANDI V1, S2, 15
9D000C30  5460005D   BNEL V1, ZERO, 0x9D000DA8
9D000C34  A6320006   SH S2, 6(S1)
1085:                		dj->sect++; /* Next sector */
9D000C38  24420001   ADDIU V0, V0, 1
9D000C3C  AC820010   SW V0, 16(A0)
1086:                
1087:                		if (dj->clust == 0) { /* Static table */
9D000C40  8C85000C   LW A1, 12(A0)
9D000C44  54A00008   BNEL A1, ZERO, 0x9D000C68
9D000C48  8C840000   LW A0, 0(A0)
1088:                			if (i >= dj->fs->n_rootdir) /* Report EOT when end of table */
9D000C4C  8C820000   LW V0, 0(A0)
9D000C50  94420008   LHU V0, 8(V0)
9D000C54  0242102B   SLTU V0, S2, V0
9D000C58  14400052   BNE V0, ZERO, 0x9D000DA4
9D000C5C  24030004   ADDIU V1, ZERO, 4
1089:                				return FR_NO_FILE;
1090:                		} else { /* Dynamic table */
1091:                			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) { /* Cluster changed? */
9D000C68  90820002   LBU V0, 2(A0)
9D000C6C  2442FFFF   ADDIU V0, V0, -1
9D000C70  00121902   SRL V1, S2, 4
9D000C74  00431024   AND V0, V0, V1
9D000C78  5440004B   BNEL V0, ZERO, 0x9D000DA8
9D000C7C  A6320006   SH S2, 6(S1)
1092:                				clst = get_fat(dj->fs, dj->clust); /* Get next cluster */
9D000C80  0F40015A   JAL get_fat
9D000C84  00000000   NOP
9D000C88  00409821   ADDU S3, V0, ZERO
1093:                				if (clst <= 1)
9D000C8C  2C420002   SLTIU V0, V0, 2
9D000C90  1440004E   BNE V0, ZERO, 0x9D000DCC
9D000C94  24030002   ADDIU V1, ZERO, 2
1094:                					return FR_INT_ERR;
1095:                				if (clst == 0xFFFFFFFF)
9D000C98  2402FFFF   ADDIU V0, ZERO, -1
9D000C9C  1262004B   BEQ S3, V0, 0x9D000DCC
9D000CA0  24030001   ADDIU V1, ZERO, 1
1096:                					return FR_DISK_ERR;
1097:                				if (clst >= dj->fs->n_fatent) { /* When it reached end of dynamic table */
9D000CA4  8E240000   LW A0, 0(S1)
9D000CA8  8C82001C   LW V0, 28(A0)
9D000CAC  0262102B   SLTU V0, S3, V0
9D000CB0  54400038   BNEL V0, ZERO, 0x9D000D94
9D000CB4  AE33000C   SW S3, 12(S1)
1098:                #if !_FS_READONLY
1099:                					PF_BYTE c;
1100:                					if (!stretch)
9D000CB8  12000044   BEQ S0, ZERO, 0x9D000DCC
9D000CBC  24030004   ADDIU V1, ZERO, 4
1101:                						return FR_NO_FILE; /* When do not stretch, report EOT */
1102:                					clst = create_chain(dj->fs, dj->clust); /* Stretch cluster chain */
9D000CC0  0F400299   JAL create_chain
9D000CC4  8E25000C   LW A1, 12(S1)
9D000CC8  00409821   ADDU S3, V0, ZERO
1103:                					if (clst == 0)
9D000CCC  1040003F   BEQ V0, ZERO, 0x9D000DCC
9D000CD0  24030007   ADDIU V1, ZERO, 7
1104:                						return FR_DENIED; /* No free cluster */
1105:                					if (clst == 1)
9D000CD4  24020001   ADDIU V0, ZERO, 1
9D000CD8  1262003C   BEQ S3, V0, 0x9D000DCC
9D000CDC  24030002   ADDIU V1, ZERO, 2
1106:                						return FR_INT_ERR;
1107:                					if (clst == 0xFFFFFFFF)
9D000CE0  2402FFFF   ADDIU V0, ZERO, -1
9D000CE4  12620039   BEQ S3, V0, 0x9D000DCC
9D000CE8  24030001   ADDIU V1, ZERO, 1
1108:                						return FR_DISK_ERR;
1109:                					/* Clean-up stretched table */
1110:                					if (move_window(dj->fs, 0))
9D000CEC  8E240000   LW A0, 0(S1)
9D000CF0  0F40007A   JAL move_window
9D000CF4  00002821   ADDU A1, ZERO, ZERO
9D000CF8  14400034   BNE V0, ZERO, 0x9D000DCC
9D000CFC  24030001   ADDIU V1, ZERO, 1
1111:                						return FR_DISK_ERR; /* Flush active window */
1112:                					mem_set(dj->fs->win, 0, SS(dj->fs)); /* Clear window buffer */
9D000D00  8E240000   LW A0, 0(S1)
9D000D04  24840034   ADDIU A0, A0, 52
9D000D08  00002821   ADDU A1, ZERO, ZERO
9D000D0C  0F40000A   JAL mem_set
9D000D10  24060200   ADDIU A2, ZERO, 512
1113:                					dj->fs->winsect = clust2sect(dj->fs, clst); /* Cluster start sector */
9D000D14  8E300000   LW S0, 0(S1)
9D000D18  02002021   ADDU A0, S0, ZERO
9D000D1C  0F40014E   JAL clust2sect
9D000D20  02602821   ADDU A1, S3, ZERO
9D000D24  AE020030   SW V0, 48(S0)
1114:                					for (c = 0; c < dj->fs->csize; c++) { /* Fill the new cluster with 0 */
9D000D28  8E220000   LW V0, 0(S1)
9D000D2C  90430002   LBU V1, 2(V0)
9D000D30  10600014   BEQ V1, ZERO, 0x9D000D84
9D000D34  00008021   ADDU S0, ZERO, ZERO
9D000D64  321000FF   ANDI S0, S0, 255
9D000D68  8E220000   LW V0, 0(S1)
9D000D6C  90430002   LBU V1, 2(V0)
9D000D70  0203182B   SLTU V1, S0, V1
9D000D74  5460FFF2   BNEL V1, ZERO, 0x9D000D40
9D000D78  A0540004   SB S4, 4(V0)
1115:                						dj->fs->wflag = 1;
9D000D38  24140001   ADDIU S4, ZERO, 1
9D000D3C  A0540004   SB S4, 4(V0)
1116:                						if (move_window(dj->fs, 0))
9D000D40  8E240000   LW A0, 0(S1)
9D000D44  0F40007A   JAL move_window
9D000D48  00002821   ADDU A1, ZERO, ZERO
9D000D4C  1440001E   BNE V0, ZERO, 0x9D000DC8
9D000D50  26100001   ADDIU S0, S0, 1
1117:                							return FR_DISK_ERR;
9D000DC8  24030001   ADDIU V1, ZERO, 1
1118:                						dj->fs->winsect++;
9D000D54  8E220000   LW V0, 0(S1)
9D000D58  8C430030   LW V1, 48(V0)
9D000D5C  24630001   ADDIU V1, V1, 1
9D000D60  AC430030   SW V1, 48(V0)
1119:                					}
1120:                					dj->fs->winsect -= c; /* Rewind window address */
9D000D7C  0B400362   J 0x9D000D88
9D000D80  8C430030   LW V1, 48(V0)
9D000D84  8C430030   LW V1, 48(V0)
9D000D88  00708023   SUBU S0, V1, S0
9D000D8C  AC500030   SW S0, 48(V0)
1121:                #else
1122:                					return FR_NO_FILE; /* Report EOT */
1123:                #endif
1124:                				}
1125:                				dj->clust = clst; /* Initialize data for new cluster */
9D000D90  AE33000C   SW S3, 12(S1)
1126:                				dj->sect = clust2sect(dj->fs, clst);
9D000D94  8E240000   LW A0, 0(S1)
9D000D98  0F40014E   JAL clust2sect
9D000D9C  02602821   ADDU A1, S3, ZERO
9D000DA0  AE220010   SW V0, 16(S1)
1127:                			}
1128:                		}
1129:                	}
1130:                
1131:                	dj->index = i;
9D000DA4  A6320006   SH S2, 6(S1)
1132:                	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
9D000DA8  8E220000   LW V0, 0(S1)
9D000DAC  24420034   ADDIU V0, V0, 52
9D000DB0  3252000F   ANDI S2, S2, 15
9D000DB4  00129140   SLL S2, S2, 5
9D000DB8  00529021   ADDU S2, V0, S2
9D000DBC  AE320014   SW S2, 20(S1)
1133:                
1134:                	return FR_OK;
9D000DC0  0B400373   J 0x9D000DCC
9D000DC4  00001821   ADDU V1, ZERO, ZERO
1135:                }
9D000C60  0B400374   J 0x9D000DD0
9D000C64  00601021   ADDU V0, V1, ZERO
9D000DCC  00601021   ADDU V0, V1, ZERO
9D000DD0  8FBF0024   LW RA, 36(SP)
9D000DD4  8FB40020   LW S4, 32(SP)
9D000DD8  8FB3001C   LW S3, 28(SP)
9D000DDC  8FB20018   LW S2, 24(SP)
9D000DE0  8FB10014   LW S1, 20(SP)
9D000DE4  8FB00010   LW S0, 16(SP)
9D000DE8  03E00008   JR RA
9D000DEC  27BD0028   ADDIU SP, SP, 40
1136:                
1137:                /*-----------------------------------------------------------------------*/
1138:                /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
1139:                /*-----------------------------------------------------------------------*/
1140:                #if _USE_LFN
1141:                static
1142:                const PF_BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30}; /* Offset of LFN chars in the directory entry */
1143:                
1144:                static
1145:                int cmp_lfn ( /* 1:Matched, 0:Not matched */
1146:                		WCHAR *lfnbuf, /* Pointer to the LFN to be compared */
1147:                		PF_BYTE *dir /* Pointer to the directory entry containing a part of LFN */
1148:                )
1149:                {
1150:                	UINT i, s;
1151:                	WCHAR wc, uc;
1152:                
1153:                	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13; /* Get offset in the LFN buffer */
1154:                	s = 0; wc = 1;
1155:                	do {
1156:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1157:                		if (wc) { /* Last char has not been processed */
1158:                			wc = ff_wtoupper(uc); /* Convert it to upper case */
1159:                			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++])) /* Compare it */
1160:                			return 0; /* Not matched */
1161:                		} else {
1162:                			if (uc != 0xFFFF) return 0; /* Check filler */
1163:                		}
1164:                	}while (++s < 13); /* Repeat until all chars in the entry are checked */
1165:                
1166:                	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i]) /* Last segment matched but different length */
1167:                	return 0;
1168:                
1169:                	return 1; /* The part of LFN matched */
1170:                }
1171:                
1172:                static
1173:                int pick_lfn ( /* 1:Succeeded, 0:Buffer overflow */
1174:                		WCHAR *lfnbuf, /* Pointer to the Unicode-LFN buffer */
1175:                		PF_BYTE *dir /* Pointer to the directory entry */
1176:                )
1177:                {
1178:                	UINT i, s;
1179:                	WCHAR wc, uc;
1180:                
1181:                	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13; /* Offset in the LFN buffer */
1182:                
1183:                	s = 0; wc = 1;
1184:                	do {
1185:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1186:                		if (wc) { /* Last char has not been processed */
1187:                			if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1188:                			lfnbuf[i++] = wc = uc; /* Store it */
1189:                		} else {
1190:                			if (uc != 0xFFFF) return 0; /* Check filler */
1191:                		}
1192:                	}while (++s < 13); /* Read all character in the entry */
1193:                
1194:                	if (dir[LDIR_Ord] & LLE) { /* Put terminator if it is the last LFN part */
1195:                		if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1196:                		lfnbuf[i] = 0;
1197:                	}
1198:                
1199:                	return 1;
1200:                }
1201:                
1202:                #if !_FS_READONLY
1203:                static
1204:                void fit_lfn (
1205:                		const WCHAR *lfnbuf, /* Pointer to the LFN buffer */
1206:                		PF_BYTE *dir, /* Pointer to the directory entry */
1207:                		PF_BYTE ord, /* LFN order (1-20) */
1208:                		PF_BYTE sum /* SFN sum */
1209:                )
1210:                {
1211:                	UINT i, s;
1212:                	WCHAR wc;
1213:                
1214:                	dir[LDIR_Chksum] = sum; /* Set check sum */
1215:                	dir[LDIR_Attr] = AM_LFN; /* Set attribute. LFN entry */
1216:                	dir[LDIR_Type] = 0;
1217:                	ST_WORD(dir+LDIR_FstClusLO, 0);
1218:                
1219:                	i = (ord - 1) * 13; /* Get offset in the LFN buffer */
1220:                	s = wc = 0;
1221:                	do {
1222:                		if (wc != 0xFFFF) wc = lfnbuf[i++]; /* Get an effective char */
1223:                		ST_WORD(dir+LfnOfs[s], wc); /* Put it */
1224:                		if (!wc) wc = 0xFFFF; /* Padding chars following last char */
1225:                	}while (++s < 13);
1226:                	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE; /* Bottom LFN part is the start of LFN sequence */
1227:                	dir[LDIR_Ord] = ord; /* Set the LFN order */
1228:                }
1229:                
1230:                #endif
1231:                #endif
1232:                
1233:                /*-----------------------------------------------------------------------*/
1234:                /* Create numbered name                                                  */
1235:                /*-----------------------------------------------------------------------*/
1236:                #if _USE_LFN
1237:                void gen_numname (
1238:                		PF_BYTE *dst, /* Pointer to generated SFN */
1239:                		const PF_BYTE *src, /* Pointer to source SFN to be modified */
1240:                		const WCHAR *lfn, /* Pointer to LFN */
1241:                		PF_WORD seq /* Sequence number */
1242:                )
1243:                {
1244:                	PF_BYTE ns[8], c;
1245:                	UINT i, j;
1246:                
1247:                	mem_cpy(dst, src, 11);
1248:                
1249:                	if (seq > 5) { /* On many collisions, generate a hash number instead of sequential number */
1250:                		do seq = (seq >> 1) + (seq << 15) + (PF_WORD)*lfn++; while (*lfn);
1251:                	}
1252:                
1253:                	/* itoa (hexdecimal) */
1254:                	i = 7;
1255:                	do {
1256:                		c = (seq % 16) + '0';
1257:                		if (c > '9') c += 7;
1258:                		ns[i--] = c;
1259:                		seq /= 16;
1260:                	}while (seq);
1261:                	ns[i] = '~';
1262:                
1263:                	/* Append the number */
1264:                	for (j = 0; j < i && dst[j] != ' '; j++) {
1265:                		if (IsDBCS1(dst[j])) {
1266:                			if (j == i - 1) break;
1267:                			j++;
1268:                		}
1269:                	}
1270:                	do {
1271:                		dst[j++] = (i < 8) ? ns[i++] : ' ';
1272:                	}while (j < 8);
1273:                }
1274:                #endif
1275:                
1276:                /*-----------------------------------------------------------------------*/
1277:                /* Calculate sum of an SFN                                               */
1278:                /*-----------------------------------------------------------------------*/
1279:                #if _USE_LFN
1280:                static
1281:                PF_BYTE sum_sfn (
1282:                		const PF_BYTE *dir /* Ptr to directory entry */
1283:                )
1284:                {
1285:                	PF_BYTE sum = 0;
1286:                	UINT n = 11;
1287:                
1288:                	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
1289:                	return sum;
1290:                }
1291:                #endif
1292:                
1293:                /*-----------------------------------------------------------------------*/
1294:                /* Directory handling - Find an object in the directory                  */
1295:                /*-----------------------------------------------------------------------*/
1296:                
1297:                static FRESULT dir_find(DIR *dj /* Pointer to the directory object linked to the file name */
1298:                ) {
1299:                	FRESULT res;
1300:                	PF_BYTE c, *dir;
1301:                #if _USE_LFN
1302:                	PF_BYTE a, ord, sum;
1303:                #endif
1304:                
1305:                	res = dir_sdi(dj, 0); /* Rewind directory object */
9D00121C  02202021   ADDU A0, S1, ZERO
9D001220  0F4001BB   JAL dir_sdi
9D001224  00002821   ADDU A1, ZERO, ZERO
1306:                	if (res != FR_OK)
9D001228  5040FFA8   BEQL V0, ZERO, 0x9D0010CC
9D00122C  8E240000   LW A0, 0(S1)
1307:                		return res;
1308:                
1309:                #if _USE_LFN
1310:                	ord = sum = 0xFF;
1311:                #endif
1312:                	do {
1313:                		res = move_window(dj->fs, dj->sect);
9D0010CC  0F40007A   JAL move_window
9D0010D0  8E250010   LW A1, 16(S1)
1314:                		if (res != FR_OK)
9D0010D4  5440001A   BNEL V0, ZERO, 0x9D001140
9D0010D8  8E230018   LW V1, 24(S1)
1315:                			break;
1316:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D0010DC  8E270014   LW A3, 20(S1)
1317:                		c = dir[DIR_Name];
1318:                		if (c == 0) {
9D0010E0  90E30000   LBU V1, 0(A3)
9D0010E4  50600059   BEQL V1, ZERO, 0x9D00124C
9D0010E8  8E220018   LW V0, 24(S1)
1319:                			res = FR_NO_FILE;
1320:                			break;
1321:                		} /* Reached to end of table */
1322:                #if _USE_LFN	/* LFN configuration */
1323:                		a = dir[DIR_Attr] & AM_MASK;
1324:                		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1325:                			ord = 0xFF;
1326:                		} else {
1327:                			if (a == AM_LFN) { /* An LFN entry is found */
1328:                				if (dj->lfn) {
1329:                					if (c & LLE) { /* Is it start of LFN sequence? */
1330:                						sum = dir[LDIR_Chksum];
1331:                						c &= ~LLE; ord = c; /* LFN start order */
1332:                						dj->lfn_idx = dj->index;
1333:                					}
1334:                					/* Check validity of the LFN entry and compare it with given name */
1335:                					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1336:                				}
1337:                			} else { /* An SFN entry is found */
1338:                				if (!ord && sum == sum_sfn(dir)) break; /* LFN matched? */
1339:                				ord = 0xFF; dj->lfn_idx = 0xFFFF; /* Reset LFN sequence */
1340:                				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break; /* SFN matched? */
1341:                			}
1342:                		}
1343:                #else		/* Non LFN configuration */
1344:                		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
9D0010EC  90E9000B   LBU T1, 11(A3)
9D0010F0  31230008   ANDI V1, T1, 8
9D0010F4  1460000C   BNE V1, ZERO, 0x9D001128
9D0010F8  00E01821   ADDU V1, A3, ZERO
9D0010FC  8E2A0018   LW T2, 24(S1)
1345:                			break;
1346:                #endif
1347:                		res = dir_next(dj, 0); /* Next entry */
9D001128  02202021   ADDU A0, S1, ZERO
9D00112C  0F4002FA   JAL dir_next
9D001130  00002821   ADDU A1, ZERO, ZERO
1348:                	} while (res == FR_OK);
9D001134  5040FFE5   BEQL V0, ZERO, 0x9D0010CC
9D001138  8E240000   LW A0, 0(S1)
1349:                
1350:                	return res;
1351:                }
1352:                
1353:                /*-----------------------------------------------------------------------*/
1354:                /* Read an object from the directory                                     */
1355:                /*-----------------------------------------------------------------------*/
1356:                #if _FS_MINIMIZE <= 1
1357:                static FRESULT dir_read(DIR *dj /* Pointer to the directory object that pointing the entry to be read */
1358:                ) {
9D001328  27BDFFE0   ADDIU SP, SP, -32
9D00132C  AFBF001C   SW RA, 28(SP)
9D001330  AFB10018   SW S1, 24(SP)
9D001334  AFB00014   SW S0, 20(SP)
9D001338  00808021   ADDU S0, A0, ZERO
1359:                	FRESULT res;
1360:                	PF_BYTE c, *dir;
1361:                #if _USE_LFN
1362:                	PF_BYTE a, ord = 0xFF, sum = 0xFF;
1363:                #endif
1364:                
1365:                	res = FR_NO_FILE;
9D00133C  24020004   ADDIU V0, ZERO, 4
1366:                	while (dj->sect) {
9D001340  0B4004E4   J 0x9D001390
9D001344  241100E5   ADDIU S1, ZERO, 229
9D001390  8E050010   LW A1, 16(S0)
9D001394  14A0FFEC   BNE A1, ZERO, 0x9D001348
9D001398  00000000   NOP
1367:                		res = move_window(dj->fs, dj->sect);
9D001348  0F40007A   JAL move_window
9D00134C  8E040000   LW A0, 0(S0)
1368:                		if (res != FR_OK)
9D001350  54400015   BNEL V0, ZERO, 0x9D0013A8
9D001354  AE000010   SW ZERO, 16(S0)
1369:                			break;
1370:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D001358  8E040014   LW A0, 20(S0)
1371:                		c = dir[DIR_Name];
9D00135C  90830000   LBU V1, 0(A0)
1372:                		if (c == 0) {
9D001360  50600010   BEQL V1, ZERO, 0x9D0013A4
9D001364  24020004   ADDIU V0, ZERO, 4
1373:                			res = FR_NO_FILE;
1374:                			break;
1375:                		} /* Reached to end of table */
1376:                #if _USE_LFN	/* LFN configuration */
1377:                		a = dir[DIR_Attr] & AM_MASK;
1378:                		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1379:                			ord = 0xFF;
1380:                		} else {
1381:                			if (a == AM_LFN) { /* An LFN entry is found */
1382:                				if (c & LLE) { /* Is it start of LFN sequence? */
1383:                					sum = dir[LDIR_Chksum];
1384:                					c &= ~LLE; ord = c;
1385:                					dj->lfn_idx = dj->index;
1386:                				}
1387:                				/* Check LFN validity and capture it */
1388:                				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1389:                			} else { /* An SFN entry is found */
1390:                				if (ord || sum != sum_sfn(dir)) /* Is there a valid LFN? */
1391:                				dj->lfn_idx = 0xFFFF; /* It has no LFN. */
1392:                				break;
1393:                			}
1394:                		}
1395:                #else		/* Non LFN configuration */
1396:                		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL)) /* Is it a valid entry? */
9D001368  50710005   BEQL V1, S1, 0x9D001380
9D00136C  02002021   ADDU A0, S0, ZERO
9D001370  9083000B   LBU V1, 11(A0)
9D001374  30630008   ANDI V1, V1, 8
9D001378  1060000B   BEQ V1, ZERO, 0x9D0013A8
9D00137C  02002021   ADDU A0, S0, ZERO
1397:                			break;
1398:                #endif
1399:                		res = dir_next(dj, 0); /* Next entry */
9D001380  0F4002FA   JAL dir_next
9D001384  00002821   ADDU A1, ZERO, ZERO
1400:                		if (res != FR_OK)
9D001388  54400007   BNEL V0, ZERO, 0x9D0013A8
9D00138C  AE000010   SW ZERO, 16(S0)
1401:                			break;
1402:                	}
1403:                
1404:                	if (res != FR_OK)
9D00139C  10400003   BEQ V0, ZERO, 0x9D0013AC
9D0013A0  8FBF001C   LW RA, 28(SP)
1405:                		dj->sect = 0;
9D0013A4  AE000010   SW ZERO, 16(S0)
1406:                
1407:                	return res;
1408:                }
9D0013A8  8FBF001C   LW RA, 28(SP)
9D0013AC  8FB10018   LW S1, 24(SP)
9D0013B0  8FB00014   LW S0, 20(SP)
9D0013B4  03E00008   JR RA
9D0013B8  27BD0020   ADDIU SP, SP, 32
1409:                #endif
1410:                
1411:                /*-----------------------------------------------------------------------*/
1412:                /* Register an object to the directory                                   */
1413:                /*-----------------------------------------------------------------------*/
1414:                #if !_FS_READONLY
1415:                static FRESULT dir_register( /* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
1416:                DIR *dj /* Target directory with object name to be created */
1417:                ) {
9D001254  27BDFFE0   ADDIU SP, SP, -32
9D001258  AFBF001C   SW RA, 28(SP)
9D00125C  AFB20018   SW S2, 24(SP)
9D001260  AFB10014   SW S1, 20(SP)
9D001264  AFB00010   SW S0, 16(SP)
9D001268  00808821   ADDU S1, A0, ZERO
1418:                	FRESULT res;
1419:                	PF_BYTE c, *dir;
1420:                #if _USE_LFN	/* LFN configuration */
1421:                	PF_WORD n, ne, is;
1422:                	PF_BYTE sn[12], *fn, sum;
1423:                	WCHAR *lfn;
1424:                
1425:                	fn = dj->fn; lfn = dj->lfn;
1426:                	mem_cpy(sn, fn, 12);
1427:                
1428:                	if (_FS_RPATH && (sn[NS] & NS_DOT)) /* Cannot create dot entry */
1429:                	return FR_INVALID_NAME;
1430:                
1431:                	if (sn[NS] & NS_LOSS) { /* When LFN is out of 8.3 format, generate a numbered name */
1432:                		fn[NS] = 0; dj->lfn = 0; /* Find only SFN */
1433:                		for (n = 1; n < 100; n++) {
1434:                			gen_numname(fn, sn, lfn, n); /* Generate a numbered name */
1435:                			res = dir_find(dj); /* Check if the name collides with existing SFN */
1436:                			if (res != FR_OK) break;
1437:                		}
1438:                		if (n == 100) return FR_DENIED; /* Abort if too many collisions */
1439:                		if (res != FR_NO_FILE) return res; /* Abort if the result is other than 'not collided' */
1440:                		fn[NS] = sn[NS]; dj->lfn = lfn;
1441:                	}
1442:                
1443:                	if (sn[NS] & NS_LFN) { /* When LFN is to be created, reserve an SFN + LFN entries. */
1444:                		for (ne = 0; lfn[ne]; ne++);
1445:                		ne = (ne + 25) / 13;
1446:                	} else { /* Otherwise reserve only an SFN entry. */
1447:                		ne = 1;
1448:                	}
1449:                
1450:                	/* Reserve contiguous entries */
1451:                	res = dir_sdi(dj, 0);
1452:                	if (res != FR_OK) return res;
1453:                	n = is = 0;
1454:                	do {
1455:                		res = move_window(dj->fs, dj->sect);
1456:                		if (res != FR_OK) break;
1457:                		c = *dj->dir; /* Check the entry status */
1458:                		if (c == DDE || c == 0) { /* Is it a blank entry? */
1459:                			if (n == 0) is = dj->index; /* First index of the contiguous entry */
1460:                			if (++n == ne) break; /* A contiguous entry that required count is found */
1461:                		} else {
1462:                			n = 0; /* Not a blank entry. Restart to search */
1463:                		}
1464:                		res = dir_next(dj, 1); /* Next entry with table stretch */
1465:                	}while (res == FR_OK);
1466:                
1467:                	if (res == FR_OK && ne > 1) { /* Initialize LFN entry if needed */
1468:                		res = dir_sdi(dj, is);
1469:                		if (res == FR_OK) {
1470:                			sum = sum_sfn(dj->fn); /* Sum of the SFN tied to the LFN */
1471:                			ne--;
1472:                			do { /* Store LFN entries in bottom first */
1473:                				res = move_window(dj->fs, dj->sect);
1474:                				if (res != FR_OK) break;
1475:                				fit_lfn(dj->lfn, dj->dir, (PF_BYTE)ne, sum);
1476:                				dj->fs->wflag = 1;
1477:                				res = dir_next(dj, 0); /* Next entry */
1478:                			}while (res == FR_OK && --ne);
1479:                		}
1480:                	}
1481:                
1482:                #else	/* Non LFN configuration */
1483:                	res = dir_sdi(dj, 0);
9D00126C  0F4001BB   JAL dir_sdi
9D001270  00002821   ADDU A1, ZERO, ZERO
1484:                	if (res == FR_OK) {
9D001274  1440001E   BNE V0, ZERO, 0x9D0012F0
9D001278  00408021   ADDU S0, V0, ZERO
1485:                		do { /* Find a blank entry for the SFN */
1486:                			res = move_window(dj->fs, dj->sect);
9D001280  8E240000   LW A0, 0(S1)
9D001284  0F40007A   JAL move_window
9D001288  8E250010   LW A1, 16(S1)
1487:                			if (res != FR_OK)
9D00128C  14400018   BNE V0, ZERO, 0x9D0012F0
9D001290  00408021   ADDU S0, V0, ZERO
1488:                				break;
1489:                			c = *dj->dir;
9D001294  8E220014   LW V0, 20(S1)
9D001298  90420000   LBU V0, 0(V0)
1490:                			if (c == DDE || c == 0)
9D00127C  241200E5   ADDIU S2, ZERO, 229
9D00129C  5052001C   BEQL V0, S2, 0x9D001310
9D0012A0  8E240000   LW A0, 0(S1)
9D0012A4  10400019   BEQ V0, ZERO, 0x9D00130C
9D0012A8  02202021   ADDU A0, S1, ZERO
1491:                				break; /* Is it a blank entry? */
1492:                			res = dir_next(dj, 1); /* Next entry with table stretch */
9D0012AC  0F4002FA   JAL dir_next
9D0012B0  24050001   ADDIU A1, ZERO, 1
1493:                		} while (res == FR_OK);
9D0012B4  1040FFF2   BEQ V0, ZERO, 0x9D001280
9D0012B8  00408021   ADDU S0, V0, ZERO
1494:                	}
1495:                #endif
1496:                
1497:                	if (res == FR_OK) { /* Initialize the SFN entry */
1498:                		res = move_window(dj->fs, dj->sect);
9D00130C  8E240000   LW A0, 0(S1)
9D001310  0F40007A   JAL move_window
9D001314  8E250010   LW A1, 16(S1)
1499:                		if (res == FR_OK) {
9D001318  1440FFF5   BNE V0, ZERO, 0x9D0012F0
9D00131C  00408021   ADDU S0, V0, ZERO
1500:                			dir = dj->dir;
9D001320  0B4004B1   J 0x9D0012C4
9D001324  8E320014   LW S2, 20(S1)
1501:                			mem_set(dir, 0, SZ_DIR); /* Clean the entry */
9D0012C4  02402021   ADDU A0, S2, ZERO
9D0012C8  00002821   ADDU A1, ZERO, ZERO
9D0012CC  0F40000A   JAL mem_set
9D0012D0  24060020   ADDIU A2, ZERO, 32
1502:                			mem_cpy(dir, dj->fn, 11); /* Put SFN */
9D0012D4  02402021   ADDU A0, S2, ZERO
9D0012D8  8E250018   LW A1, 24(S1)
9D0012DC  0F400000   JAL mem_cpy
9D0012E0  2406000B   ADDIU A2, ZERO, 11
1503:                #if _USE_LFN
1504:                			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT); /* Put NT flag */
1505:                #endif
1506:                			dj->fs->wflag = 1;
9D0012E4  8E220000   LW V0, 0(S1)
9D0012E8  24030001   ADDIU V1, ZERO, 1
9D0012EC  A0430004   SB V1, 4(V0)
1507:                		}
1508:                	}
1509:                
1510:                	return res;
1511:                }
9D0012BC  0B4004BD   J 0x9D0012F4
9D0012C0  02001021   ADDU V0, S0, ZERO
9D0012F0  02001021   ADDU V0, S0, ZERO
9D0012F4  8FBF001C   LW RA, 28(SP)
9D0012F8  8FB20018   LW S2, 24(SP)
9D0012FC  8FB10014   LW S1, 20(SP)
9D001300  8FB00010   LW S0, 16(SP)
9D001304  03E00008   JR RA
9D001308  27BD0020   ADDIU SP, SP, 32
1512:                #endif /* !_FS_READONLY */
1513:                
1514:                /*-----------------------------------------------------------------------*/
1515:                /* Remove an object from the directory                                   */
1516:                /*-----------------------------------------------------------------------*/
1517:                #if !_FS_READONLY && !_FS_MINIMIZE
1518:                static FRESULT dir_remove( /* FR_OK: Successful, FR_DISK_ERR: A disk error */
1519:                DIR *dj /* Directory object pointing the entry to be removed */
1520:                ) {
9D000850  27BDFFE8   ADDIU SP, SP, -24
9D000854  AFBF0014   SW RA, 20(SP)
9D000858  AFB00010   SW S0, 16(SP)
9D00085C  00808021   ADDU S0, A0, ZERO
1521:                	FRESULT res;
1522:                #if _USE_LFN	/* LFN configuration */
1523:                	PF_WORD i;
1524:                
1525:                	i = dj->index; /* SFN index */
1526:                	res = dir_sdi(dj, (PF_WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx)); /* Goto the SFN or top of the LFN entries */
1527:                	if (res == FR_OK) {
1528:                		do {
1529:                			res = move_window(dj->fs, dj->sect);
1530:                			if (res != FR_OK) break;
1531:                			*dj->dir = DDE; /* Mark the entry "deleted" */
1532:                			dj->fs->wflag = 1;
1533:                			if (dj->index >= i) break; /* When reached SFN, all entries of the object has been deleted. */
1534:                			res = dir_next(dj, 0); /* Next entry */
1535:                		}while (res == FR_OK);
1536:                		if (res == FR_NO_FILE) res = FR_INT_ERR;
1537:                	}
1538:                
1539:                #else			/* Non LFN configuration */
1540:                	res = dir_sdi(dj, dj->index);
9D000860  0F4001BB   JAL dir_sdi
9D000864  94850006   LHU A1, 6(A0)
1541:                	if (res == FR_OK) {
9D000868  1440000C   BNE V0, ZERO, 0x9D00089C
9D00086C  8FBF0014   LW RA, 20(SP)
1542:                		res = move_window(dj->fs, dj->sect);
9D000870  8E040000   LW A0, 0(S0)
9D000874  0F40007A   JAL move_window
9D000878  8E050010   LW A1, 16(S0)
1543:                		if (res == FR_OK) {
9D00087C  14400006   BNE V0, ZERO, 0x9D000898
9D000880  2404FFE5   ADDIU A0, ZERO, -27
1544:                			*dj->dir = DDE; /* Mark the entry "deleted" */
9D000884  8E030014   LW V1, 20(S0)
9D000888  A0640000   SB A0, 0(V1)
1545:                			dj->fs->wflag = 1;
9D00088C  8E030000   LW V1, 0(S0)
9D000890  24040001   ADDIU A0, ZERO, 1
9D000894  A0640004   SB A0, 4(V1)
1546:                		}
1547:                	}
1548:                #endif
1549:                
1550:                	return res;
1551:                }
9D000898  8FBF0014   LW RA, 20(SP)
9D00089C  8FB00010   LW S0, 16(SP)
9D0008A0  03E00008   JR RA
9D0008A4  27BD0018   ADDIU SP, SP, 24
1552:                #endif /* !_FS_READONLY */
1553:                
1554:                /*-----------------------------------------------------------------------*/
1555:                /* Pick a segment and create the object name in directory form           */
1556:                /*-----------------------------------------------------------------------*/
1557:                
1558:                static FRESULT create_name(DIR *dj, /* Pointer to the directory object */
1559:                const TCHAR **path /* Pointer to pointer to the segment in the path string */
1560:                ) {
1561:                #ifdef _EXCVT
1562:                	static const PF_BYTE excvt[] = _EXCVT; /* Upper conversion table for extended chars */
1563:                #endif
1564:                
1565:                #if _USE_LFN	/* LFN configuration */
1566:                	PF_BYTE b, cf;
1567:                	WCHAR w, *lfn;
1568:                	UINT i, ni, si, di;
1569:                	const TCHAR *p;
1570:                
1571:                	/* Create LFN in Unicode */
1572:                	for (p = *path; *p == '/' || *p == '\\'; p++); /* Strip duplicated separator */
1573:                	lfn = dj->lfn;
1574:                	si = di = 0;
1575:                	for (;;) {
1576:                		w = p[si++]; /* Get a character */
1577:                		if (w < ' ' || w == '/' || w == '\\') break; /* Break on end of segment */
1578:                		if (di >= _MAX_LFN) /* Reject too long name */
1579:                		return FR_INVALID_NAME;
1580:                #if !_LFN_UNICODE
1581:                		w &= 0xFF;
1582:                		if (IsDBCS1(w)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1583:                			b = (PF_BYTE)p[si++]; /* Get 2nd byte */
1584:                			if (!IsDBCS2(b))
1585:                			return FR_INVALID_NAME; /* Reject invalid sequence */
1586:                			w = (w << 8) + b; /* Create a DBC */
1587:                		}
1588:                		w = ff_convert(w, 1); /* Convert ANSI/OEM to Unicode */
1589:                		if (!w) return FR_INVALID_NAME; /* Reject invalid code */
1590:                #endif
1591:                		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
1592:                		return FR_INVALID_NAME;
1593:                		lfn[di++] = w; /* Store the Unicode char */
1594:                	}
1595:                	*path = &p[si]; /* Return pointer to the next segment */
1596:                	cf = (w < ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
1597:                #if _FS_RPATH
1598:                	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
1599:                			(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
1600:                		lfn[di] = 0;
1601:                		for (i = 0; i < 11; i++)
1602:                		dj->fn[i] = (i < di) ? '.' : ' ';
1603:                		dj->fn[i] = cf | NS_DOT; /* This is a dot entry */
1604:                		return FR_OK;
1605:                	}
1606:                #endif
1607:                	while (di) { /* Strip trailing spaces and dots */
1608:                		w = lfn[di-1];
1609:                		if (w != ' ' && w != '.') break;
1610:                		di--;
1611:                	}
1612:                	if (!di) return FR_INVALID_NAME; /* Reject nul string */
1613:                
1614:                	lfn[di] = 0; /* LFN is created */
1615:                
1616:                	/* Create SFN in directory form */
1617:                	mem_set(dj->fn, ' ', 11);
1618:                	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++); /* Strip leading spaces and dots */
1619:                	if (si) cf |= NS_LOSS | NS_LFN;
1620:                	while (di && lfn[di - 1] != '.') di--; /* Find extension (di<=si: no extension) */
1621:                
1622:                	b = i = 0; ni = 8;
1623:                	for (;;) {
1624:                		w = lfn[si++]; /* Get an LFN char */
1625:                		if (!w) break; /* Break on end of the LFN */
1626:                		if (w == ' ' || (w == '.' && si != di)) { /* Remove spaces and dots */
1627:                			cf |= NS_LOSS | NS_LFN; continue;
1628:                		}
1629:                
1630:                		if (i >= ni || si == di) { /* Extension or end of SFN */
1631:                			if (ni == 11) { /* Long extension */
1632:                				cf |= NS_LOSS | NS_LFN; break;
1633:                			}
1634:                			if (si != di) cf |= NS_LOSS | NS_LFN; /* Out of 8.3 format */
1635:                			if (si > di) break; /* No extension */
1636:                			si = di; i = 8; ni = 11; /* Enter extension section */
1637:                			b <<= 2; continue;
1638:                		}
1639:                
1640:                		if (w >= 0x80) { /* Non ASCII char */
1641:                #ifdef _EXCVT
1642:                			w = ff_convert(w, 0); /* Unicode -> OEM code */
1643:                			if (w) w = excvt[w - 0x80]; /* Convert extended char to upper (SBCS) */
1644:                #else
1645:                			w = ff_convert(ff_wtoupper(w), 0); /* Upper converted Unicode -> OEM code */
1646:                #endif
1647:                			cf |= NS_LFN; /* Force create LFN entry */
1648:                		}
1649:                
1650:                		if (_DF1S && w >= 0x100) { /* Double byte char (always false on SBCS cfg) */
1651:                			if (i >= ni - 1) {
1652:                				cf |= NS_LOSS | NS_LFN; i = ni; continue;
1653:                			}
1654:                			dj->fn[i++] = (PF_BYTE)(w >> 8);
1655:                		} else { /* Single byte char */
1656:                			if (!w || chk_chr("+,;=[]", w)) { /* Replace illegal chars for SFN */
1657:                				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
1658:                			} else {
1659:                				if (IsUpper(w)) { /* ASCII large capital */
1660:                					b |= 2;
1661:                				} else {
1662:                					if (IsLower(w)) { /* ASCII small capital */
1663:                						b |= 1; w -= 0x20;
1664:                					}
1665:                				}
1666:                			}
1667:                		}
1668:                		dj->fn[i++] = (PF_BYTE)w;
1669:                	}
1670:                
1671:                	if (dj->fn[0] == DDE) dj->fn[0] = NDDE; /* If the first char collides with deleted mark, replace it with 0x05 */
1672:                
1673:                	if (ni == 8) b <<= 2;
1674:                	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) /* Create LFN entry when there are composite capitals */
1675:                	cf |= NS_LFN;
1676:                	if (!(cf & NS_LFN)) { /* When LFN is in 8.3 format without extended char, NT flags are created */
1677:                		if ((b & 0x03) == 0x01) cf |= NS_EXT; /* NT flag (Extension has only small capital) */
1678:                		if ((b & 0x0C) == 0x04) cf |= NS_BODY; /* NT flag (Filename has only small capital) */
1679:                	}
1680:                
1681:                	dj->fn[NS] = cf; /* SFN is created */
1682:                
1683:                	return FR_OK;
1684:                
1685:                #else	/* Non-LFN configuration */
1686:                	PF_BYTE b, c, d, *sfn;
1687:                	UINT ni, si, i;
1688:                	const char *p;
1689:                
1690:                	/* Create file name in directory form */
1691:                	for (p = *path; *p == '/' || *p == '\\'; p++)
9D000E70  2413005C   ADDIU S3, ZERO, 92
9D000E80  82020000   LB V0, 0(S0)
9D000E84  5052FFFE   BEQL V0, S2, 0x9D000E80
9D000E88  26100001   ADDIU S0, S0, 1
9D000E8C  5053FFFC   BEQL V0, S3, 0x9D000E80
9D000E90  26100001   ADDIU S0, S0, 1
1692:                		; /* Strip duplicated separator */
1693:                	sfn = dj->fn;
9D000E94  8E350018   LW S5, 24(S1)
1694:                	mem_set(sfn, ' ', 11);
9D000E98  02A02021   ADDU A0, S5, ZERO
9D000E9C  24050020   ADDIU A1, ZERO, 32
9D000EA0  0F40000A   JAL mem_set
9D000EA4  2406000B   ADDIU A2, ZERO, 11
1695:                	si = i = b = 0;
1696:                	ni = 8;
1697:                #if _FS_RPATH
1698:                	if (p[si] == '.') { /* Is this a dot entry? */
9D000E74  2414002E   ADDIU S4, ZERO, 46
9D000EA8  82020000   LB V0, 0(S0)
9D000EAC  54540018   BNEL V0, S4, 0x9D000F10
9D000EB0  00003021   ADDU A2, ZERO, ZERO
9D000F10  00001821   ADDU V1, ZERO, ZERO
9D000F14  24040008   ADDIU A0, ZERO, 8
9D000F18  00004021   ADDU T0, ZERO, ZERO
1699:                		for (;;) {
1700:                			c = (PF_BYTE)p[si++];
9D000EBC  92020001   LBU V0, 1(S0)
9D000ED0  92020002   LBU V0, 2(S0)
1701:                			if (c != '.' || si >= 3) break;
9D000EC0  14540006   BNE V0, S4, 0x9D000EDC
9D000EC4  24030002   ADDIU V1, ZERO, 2
9D000ED4  10540005   BEQ V0, S4, 0x9D000EEC
9D000ED8  24030003   ADDIU V1, ZERO, 3
1702:                			sfn[i++] = c;
9D000EB4  2402002E   ADDIU V0, ZERO, 46
9D000EB8  A2A20000   SB V0, 0(S5)
9D000EC8  2402002E   ADDIU V0, ZERO, 46
9D000ECC  A2A20001   SB V0, 1(S5)
1703:                		}
1704:                		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
9D000EDC  50520008   BEQL V0, S2, 0x9D000F00
9D000EE0  02038021   ADDU S0, S0, V1
9D000EE4  50530006   BEQL V0, S3, 0x9D000F00
9D000EE8  02038021   ADDU S0, S0, V1
9D000EEC  2C420021   SLTIU V0, V0, 33
9D000EF0  144000C5   BNE V0, ZERO, 0x9D001208
9D000EF4  02038021   ADDU S0, S0, V1
9D000EF8  0B40046E   J 0x9D0011B8
9D000EFC  24020006   ADDIU V0, ZERO, 6
1705:                		*path = &p[si]; /* Return pointer to the next segment */
1706:                		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT; /* Set last segment flag if end of path */
9D000F00  26B5000B   ADDIU S5, S5, 11
9D000F04  24020020   ADDIU V0, ZERO, 32
9D000F08  0B400487   J 0x9D00121C
9D000F0C  A2A20000   SB V0, 0(S5)
9D001208  26B5000B   ADDIU S5, S5, 11
9D00120C  0B4003C2   J 0x9D000F08
9D001210  24020024   ADDIU V0, ZERO, 36
1707:                		return FR_OK;
1708:                	}
1709:                #endif
1710:                	for (;;) {
1711:                		c = (PF_BYTE) p[si++];
9D000F24  02031021   ADDU V0, S0, V1
9D000F28  80450000   LB A1, 0(V0)
9D000F2C  30A200FF   ANDI V0, A1, 255
1712:                		if (c <= ' ' || c == '/' || c == '\\')
9D000F30  2C470021   SLTIU A3, V0, 33
9D000F34  14E0004C   BNE A3, ZERO, 0x9D001068
9D000F38  24630001   ADDIU V1, V1, 1
9D000F3C  505200B5   BEQL V0, S2, 0x9D001214
9D000F40  02038021   ADDU S0, S0, V1
9D000F44  505300B3   BEQL V0, S3, 0x9D001214
9D000F48  02038021   ADDU S0, S0, V1
1713:                			break; /* Break on end of segment */
1714:                		if (c == '.' || i >= ni) {
9D000F4C  10540003   BEQ V0, S4, 0x9D000F5C
9D000F50  00C4382B   SLTU A3, A2, A0
9D000F54  14E0000A   BNE A3, ZERO, 0x9D000F80
9D000F58  35070003   ORI A3, T0, 3
1715:                			if (ni != 8 || c != '.')
9D000F1C  24090008   ADDIU T1, ZERO, 8
9D000F5C  5489009F   BNEL A0, T1, 0x9D0011DC
9D000F60  24020006   ADDIU V0, ZERO, 6
9D000F64  1454009D   BNE V0, S4, 0x9D0011DC
9D000F68  24020006   ADDIU V0, ZERO, 6
1716:                				return FR_INVALID_NAME;
1717:                			i = 8;
9D000F74  01203021   ADDU A2, T1, ZERO
1718:                			ni = 11;
9D000F78  0B4003C9   J 0x9D000F24
9D000F7C  2404000B   ADDIU A0, ZERO, 11
1719:                			b <<= 2;
9D000F6C  00084080   SLL T0, T0, 2
9D000F70  310800FF   ANDI T0, T0, 255
1720:                			continue;
1721:                		}
1722:                		if (c >= 0x80) { /* Extended char? */
1723:                			b |= 3; /* Eliminate NT flag */
9D000F80  28A50000   SLTI A1, A1, 0
9D000F84  00E5400B   MOVN T0, A3, A1
1724:                #ifdef _EXCVT
1725:                			c = excvt[c-0x80]; /* Upper conversion (SBCS) */
1726:                #else
1727:                #if !_DF1S	/* ASCII only cfg */
1728:                			return FR_INVALID_NAME;
1729:                #endif
1730:                #endif
1731:                		}
1732:                		if (IsDBCS1(c)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
9D000F88  2445007F   ADDIU A1, V0, 127
9D000F8C  30A500FF   ANDI A1, A1, 255
9D000F90  2CA5001F   SLTIU A1, A1, 31
9D000F94  14A00006   BNE A1, ZERO, 0x9D000FB0
9D000F98  02032821   ADDU A1, S0, V1
9D000F9C  24450020   ADDIU A1, V0, 32
9D000FA0  30A500FF   ANDI A1, A1, 255
9D000FA4  2CA5001D   SLTIU A1, A1, 29
9D000FA8  10A00013   BEQ A1, ZERO, 0x9D000FF8
9D000FAC  02032821   ADDU A1, S0, V1
1733:                			d = (PF_BYTE) p[si++]; /* Get 2nd byte */
9D000FB0  90A50000   LBU A1, 0(A1)
1734:                			if (!IsDBCS2(d) || i >= ni - 1) /* Reject invalid DBC */
9D000FB4  24A7FFC0   ADDIU A3, A1, -64
9D000FB8  30E700FF   ANDI A3, A3, 255
9D000FBC  2CE7003F   SLTIU A3, A3, 63
9D000FC0  14E00005   BNE A3, ZERO, 0x9D000FD8
9D000FC4  2487FFFF   ADDIU A3, A0, -1
9D000FC8  38A70080   XORI A3, A1, 128
9D000FCC  2CE7007D   SLTIU A3, A3, 125
9D000FD0  10E0007B   BEQ A3, ZERO, 0x9D0011C0
9D000FD4  2487FFFF   ADDIU A3, A0, -1
9D000FD8  00C7382B   SLTU A3, A2, A3
9D000FDC  10E0007A   BEQ A3, ZERO, 0x9D0011C8
9D000FE0  24630001   ADDIU V1, V1, 1
9D0011C0  0B400477   J 0x9D0011DC
9D0011C4  24020006   ADDIU V0, ZERO, 6
9D0011C8  0B400477   J 0x9D0011DC
9D0011CC  24020006   ADDIU V0, ZERO, 6
1735:                				return FR_INVALID_NAME;
1736:                			sfn[i++] = c;
9D000FE4  02A63821   ADDU A3, S5, A2
9D000FE8  A0E20000   SB V0, 0(A3)
1737:                			sfn[i++] = d;
9D000FEC  A0E50001   SB A1, 1(A3)
9D000FF0  0B4003C9   J 0x9D000F24
9D000FF4  24C60002   ADDIU A2, A2, 2
1738:                		} else { /* Single byte code */
1739:                			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) /* Reject illegal chrs for SFN */
1740:                				return FR_INVALID_NAME;
1741:                			if (IsUpper(c)) { /* ASCII large capital? */
9D001024  30A500FF   ANDI A1, A1, 255
9D001028  2CA5001A   SLTIU A1, A1, 26
9D00102C  10A00003   BEQ A1, ZERO, 0x9D00103C
9D001030  2445FF9F   ADDIU A1, V0, -97
1742:                				b |= 2;
9D001034  0B400416   J 0x9D001058
9D001038  35080002   ORI T0, T0, 2
1743:                			} else {
1744:                				if (IsLower(c)) { /* ASCII small capital? */
9D00103C  30A500FF   ANDI A1, A1, 255
9D001040  2CA5001A   SLTIU A1, A1, 26
9D001044  10A00005   BEQ A1, ZERO, 0x9D00105C
9D001048  02A62821   ADDU A1, S5, A2
1745:                					b |= 1;
9D00104C  35080001   ORI T0, T0, 1
1746:                					c -= 0x20;
9D001050  2442FFE0   ADDIU V0, V0, -32
9D001054  304200FF   ANDI V0, V0, 255
1747:                				}
1748:                			}
1749:                			sfn[i++] = c;
9D001058  02A62821   ADDU A1, S5, A2
9D00105C  A0A20000   SB V0, 0(A1)
9D001060  0B4003C9   J 0x9D000F24
9D001064  24C60001   ADDIU A2, A2, 1
1750:                		}
1751:                	}
1752:                	*path = &p[si]; /* Return pointer to the next segment */
9D001068  02038021   ADDU S0, S0, V1
1753:                	c = (c <= ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
9D00106C  02C01021   ADDU V0, S6, ZERO
9D001214  0B40041C   J 0x9D001070
9D001218  00001021   ADDU V0, ZERO, ZERO
1754:                
1755:                	if (!i)
9D001070  10C00059   BEQ A2, ZERO, 0x9D0011D8
9D001074  240300E5   ADDIU V1, ZERO, 229
1756:                		return FR_INVALID_NAME; /* Reject nul string */
1757:                	if (sfn[0] == DDE)
9D001078  92A50000   LBU A1, 0(S5)
9D00107C  14A30004   BNE A1, V1, 0x9D001090
9D001080  24030008   ADDIU V1, ZERO, 8
1758:                		sfn[0] = NDDE; /* When first char collides with DDE, replace it with 0x05 */
9D001084  24030005   ADDIU V1, ZERO, 5
9D001088  A2A30000   SB V1, 0(S5)
1759:                
1760:                	if (ni == 8)
9D00108C  24030008   ADDIU V1, ZERO, 8
9D001090  14830004   BNE A0, V1, 0x9D0010A4
9D001094  01002021   ADDU A0, T0, ZERO
1761:                		b <<= 2;
9D001098  00084080   SLL T0, T0, 2
9D00109C  310800FF   ANDI T0, T0, 255
1762:                	if ((b & 0x03) == 0x01)
9D0010A0  01002021   ADDU A0, T0, ZERO
9D0010A4  31080003   ANDI T0, T0, 3
1763:                		c |= NS_EXT; /* NT flag (Name extension has only small capital) */
9D0010A8  34430010   ORI V1, V0, 16
9D0010AC  39080001   XORI T0, T0, 1
9D0010B0  0068100A   MOVZ V0, V1, T0
1764:                	if ((b & 0x0C) == 0x04)
9D0010B4  3084000C   ANDI A0, A0, 12
1765:                		c |= NS_BODY; /* NT flag (Name body has only small capital) */
9D0010B8  34430008   ORI V1, V0, 8
9D0010BC  00962026   XOR A0, A0, S6
9D0010C0  0064100A   MOVZ V0, V1, A0
1766:                
1767:                	sfn[NS] = c; /* Store NT flag, File name is created */
9D0010C4  0B400487   J 0x9D00121C
9D0010C8  A2A2000B   SB V0, 11(S5)
1768:                
1769:                	return FR_OK;
1770:                #endif
1771:                }
1772:                
1773:                /*-----------------------------------------------------------------------*/
1774:                /* Get file information from directory entry                             */
1775:                /*-----------------------------------------------------------------------*/
1776:                #if _FS_MINIMIZE <= 1
1777:                static
1778:                void get_fileinfo( /* No return code */
9D0000FC  00C41021   ADDU V0, A2, A0
1779:                DIR *dj, /* Pointer to the directory object */
1780:                FILINFO *fno /* Pointer to the file information to be filled */
1781:                ) {
1782:                	UINT i;
1783:                	PF_BYTE nt, *dir;
1784:                	TCHAR *p, c;
1785:                
1786:                	p = fno->fname;
1787:                	if (dj->sect) {
9D0000C8  8C820010   LW V0, 16(A0)
9D0000CC  10400039   BEQ V0, ZERO, 0x9D0001B4
9D0000D0  24A30009   ADDIU V1, A1, 9
1788:                		dir = dj->dir;
9D0000D4  8C860014   LW A2, 20(A0)
1789:                		nt = dir[DIR_NTres]; /* NT flag */
1790:                		for (i = 0; i < 8; i++) { /* Copy name body */
9D0000F0  24080008   ADDIU T0, ZERO, 8
9D000118  24840001   ADDIU A0, A0, 1
9D00011C  1488FFF7   BNE A0, T0, 0x9D0000FC
9D000120  24630001   ADDIU V1, V1, 1
1791:                			c = dir[i];
9D0000D8  80C20000   LB V0, 0(A2)
9D000100  80420000   LB V0, 0(V0)
1792:                			if (c == ' ')
9D0000DC  24040020   ADDIU A0, ZERO, 32
9D0000E0  10440010   BEQ V0, A0, 0x9D000124
9D0000E4  00002021   ADDU A0, ZERO, ZERO
9D0000F4  0B400043   J 0x9D00010C
9D0000F8  240B0020   ADDIU T3, ZERO, 32
9D000104  504B0008   BEQL V0, T3, 0x9D000128
9D000108  90C40008   LBU A0, 8(A2)
1793:                				break;
1794:                			if (c == NDDE)
9D0000E8  240A0005   ADDIU T2, ZERO, 5
1795:                				c = (TCHAR) DDE;
9D0000EC  2409FFE5   ADDIU T1, ZERO, -27
9D00010C  004A3826   XOR A3, V0, T2
9D000110  0127100A   MOVZ V0, T1, A3
1796:                			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c))
1797:                				c += 0x20;
1798:                #if _LFN_UNICODE
1799:                			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
1800:                			c = (c << 8) | dir[++i];
1801:                			c = ff_convert(c, 1);
1802:                			if (!c) c = '?';
1803:                #endif
1804:                			*p++ = c;
9D000114  A0620000   SB V0, 0(V1)
1805:                		}
1806:                		if (dir[8] != ' ') { /* Copy name extension */
9D000124  90C40008   LBU A0, 8(A2)
9D000128  24020020   ADDIU V0, ZERO, 32
9D00012C  1082000A   BEQ A0, V0, 0x9D000158
9D000130  2402002E   ADDIU V0, ZERO, 46
1807:                			*p++ = '.';
9D000134  A0620000   SB V0, 0(V1)
1808:                			for (i = 8; i < 11; i++) {
1809:                				c = dir[i];
9D000138  80C20008   LB V0, 8(A2)
9D0001C0  80C20009   LB V0, 9(A2)
9D0001D4  80C2000A   LB V0, 10(A2)
1810:                				if (c == ' ')
9D00013C  24040020   ADDIU A0, ZERO, 32
9D000140  1444001E   BNE V0, A0, 0x9D0001BC
9D000144  24630001   ADDIU V1, V1, 1
9D0001C4  24040020   ADDIU A0, ZERO, 32
9D0001C8  1044FFE3   BEQ V0, A0, 0x9D000158
9D0001CC  24630001   ADDIU V1, V1, 1
9D0001D8  1444FFDD   BNE V0, A0, 0x9D000150
9D0001DC  24630001   ADDIU V1, V1, 1
1811:                					break;
1812:                				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c))
1813:                					c += 0x20;
1814:                #if _LFN_UNICODE
1815:                				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
1816:                				c = (c << 8) | dir[++i];
1817:                				c = ff_convert(c, 1);
1818:                				if (!c) c = '?';
1819:                #endif
1820:                				*p++ = c;
9D000150  A0620000   SB V0, 0(V1)
9D000154  24630001   ADDIU V1, V1, 1
9D0001BC  A0620000   SB V0, 0(V1)
9D0001D0  A0620000   SB V0, 0(V1)
1821:                			}
1822:                		}
1823:                		fno->fattrib = dir[DIR_Attr]; /* Attribute */
9D000148  0B400057   J 0x9D00015C
9D00014C  90C2000B   LBU V0, 11(A2)
9D000158  90C2000B   LBU V0, 11(A2)
9D00015C  A0A20008   SB V0, 8(A1)
9D0001E0  0B400057   J 0x9D00015C
9D0001E4  90C2000B   LBU V0, 11(A2)
1824:                		fno->fsize = LD_DWORD(dir+DIR_FileSize); /* Size */
9D000160  90C4001F   LBU A0, 31(A2)
9D000164  00042600   SLL A0, A0, 24
9D000168  90C2001E   LBU V0, 30(A2)
9D00016C  00021400   SLL V0, V0, 16
9D000170  00821025   OR V0, A0, V0
9D000174  90C4001C   LBU A0, 28(A2)
9D000178  00441025   OR V0, V0, A0
9D00017C  90C4001D   LBU A0, 29(A2)
9D000180  00042200   SLL A0, A0, 8
9D000184  00441025   OR V0, V0, A0
9D000188  ACA20000   SW V0, 0(A1)
1825:                		fno->fdate = LD_WORD(dir+DIR_WrtDate); /* Date */
9D00018C  90C20019   LBU V0, 25(A2)
9D000190  00021200   SLL V0, V0, 8
9D000194  90C40018   LBU A0, 24(A2)
9D000198  00441025   OR V0, V0, A0
9D00019C  A4A20004   SH V0, 4(A1)
1826:                		fno->ftime = LD_WORD(dir+DIR_WrtTime); /* Time */
9D0001A0  90C20017   LBU V0, 23(A2)
9D0001A4  00021200   SLL V0, V0, 8
9D0001A8  90C40016   LBU A0, 22(A2)
9D0001AC  00441025   OR V0, V0, A0
9D0001B0  A4A20006   SH V0, 6(A1)
1827:                	}
1828:                	*p = 0; /* Terminate SFN str by a \0 */
1829:                
1830:                #if _USE_LFN
1831:                	if (fno->lfname && fno->lfsize) {
1832:                		TCHAR *tp = fno->lfname;
1833:                		WCHAR w, *lfn;
1834:                
1835:                		i = 0;
1836:                		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
1837:                			lfn = dj->lfn;
1838:                			while ((w = *lfn++) != 0) { /* Get an LFN char */
1839:                #if !_LFN_UNICODE
1840:                				w = ff_convert(w, 0); /* Unicode -> OEM conversion */
1841:                				if (!w) {i = 0; break;} /* Could not convert, no LFN */
1842:                				if (_DF1S && w >= 0x100) /* Put 1st byte if it is a DBC (always false on SBCS cfg) */
1843:                				tp[i++] = (TCHAR)(w >> 8);
1844:                #endif
1845:                				if (i >= fno->lfsize - 1) {i = 0; break;} /* Buffer overflow, no LFN */
1846:                				tp[i++] = (TCHAR)w;
1847:                			}
1848:                		}
1849:                		tp[i] = 0; /* Terminate the LFN str by a \0 */
1850:                	}
1851:                #endif
1852:                }
9D0001B4  03E00008   JR RA
9D0001B8  A0600000   SB ZERO, 0(V1)
1853:                #endif /* _FS_MINIMIZE <= 1 */
1854:                
1855:                /*-----------------------------------------------------------------------*/
1856:                /* Follow a file path                                                    */
1857:                /*-----------------------------------------------------------------------*/
1858:                
1859:                static FRESULT follow_path( /* FR_OK(0): successful, !=0: error code */
9D001104  0B400445   J 0x9D001114
1860:                DIR *dj, /* Directory object to return last directory and found object */
1861:                const TCHAR *path /* Full-path string to find a file or directory */
1862:                ) {
9D000DF0  27BDFFC8   ADDIU SP, SP, -56
9D000DF4  AFBF0034   SW RA, 52(SP)
9D000DF8  AFB70030   SW S7, 48(SP)
9D000DFC  AFB6002C   SW S6, 44(SP)
9D000E00  AFB50028   SW S5, 40(SP)
9D000E04  AFB40024   SW S4, 36(SP)
9D000E08  AFB30020   SW S3, 32(SP)
9D000E0C  AFB2001C   SW S2, 28(SP)
9D000E10  AFB10018   SW S1, 24(SP)
9D000E14  AFB00014   SW S0, 20(SP)
9D000E18  00808821   ADDU S1, A0, ZERO
1863:                	FRESULT res;
1864:                	PF_BYTE *dir, ns;
1865:                
1866:                #if _FS_RPATH
1867:                	if (*path == '/' || *path == '\\') { /* There is a heading separator */
9D000E1C  80A20000   LB V0, 0(A1)
9D000E20  2403002F   ADDIU V1, ZERO, 47
9D000E24  10430004   BEQ V0, V1, 0x9D000E38
9D000E28  00A08021   ADDU S0, A1, ZERO
9D000E2C  2403005C   ADDIU V1, ZERO, 92
9D000E30  54430004   BNEL V0, V1, 0x9D000E44
9D000E34  8C820000   LW V0, 0(A0)
1868:                		path++; dj->sclust = 0; /* Strip it and start from the root dir */
9D000E38  26100001   ADDIU S0, S0, 1
9D000E3C  0B400393   J 0x9D000E4C
9D000E40  AE200008   SW ZERO, 8(S1)
1869:                	} else { /* No heading separator */
1870:                		dj->sclust = dj->fs->cdir; /* Start from the current dir */
9D000E44  8C420018   LW V0, 24(V0)
9D000E48  AC820008   SW V0, 8(A0)
1871:                	}
1872:                #else
1873:                	if (*path == '/' || *path == '\\') /* Strip heading separator if exist */
1874:                		path++;
1875:                	dj->sclust = 0; /* Start from the root dir */
1876:                #endif
1877:                
1878:                	if ((UINT) *path < ' ') { /* Nul path means the start directory itself */
9D000E4C  92020000   LBU V0, 0(S0)
9D000E50  2C420020   SLTIU V0, V0, 32
9D000E54  10400006   BEQ V0, ZERO, 0x9D000E70
9D000E58  2412002F   ADDIU S2, ZERO, 47
1879:                		res = dir_sdi(dj, 0);
9D000E5C  02202021   ADDU A0, S1, ZERO
9D000E60  0F4001BB   JAL dir_sdi
9D000E64  00002821   ADDU A1, ZERO, ZERO
1880:                		dj->dir = 0;
9D000E68  0B400477   J 0x9D0011DC
9D000E6C  AE200014   SW ZERO, 20(S1)
1881:                
1882:                	} else { /* Follow path */
1883:                		for (;;) {
1884:                			res = create_name(dj, &path); /* Get a segment */
1885:                			if (res != FR_OK)
1886:                				break;
1887:                			res = dir_find(dj); /* Find it */
9D00116C  24030004   ADDIU V1, ZERO, 4
9D001170  24040005   ADDIU A0, ZERO, 5
9D001174  0082180A   MOVZ V1, A0, V0
9D001178  0B400477   J 0x9D0011DC
9D00117C  00601021   ADDU V0, V1, ZERO
1888:                			ns = *(dj->fn + NS);
9D00113C  8E230018   LW V1, 24(S1)
9D001230  0B400450   J 0x9D001140
9D001234  8E230018   LW V1, 24(S1)
9D00124C  0B400452   J 0x9D001148
9D001250  9043000B   LBU V1, 11(V0)
1889:                			if (res != FR_OK) { /* Failed to find the object */
1890:                				if (res != FR_NO_FILE)
9D000E78  24160004   ADDIU S6, ZERO, 4
9D001140  14560026   BNE V0, S6, 0x9D0011DC
9D001144  9063000B   LBU V1, 11(V1)
1891:                					break; /* Abort if any hard error occured */
1892:                				/* Object not found */
1893:                				if (_FS_RPATH && (ns & NS_DOT)) { /* If dot entry is not exit */
9D001148  30640020   ANDI A0, V1, 32
9D00114C  10800007   BEQ A0, ZERO, 0x9D00116C
9D001150  30620004   ANDI V0, V1, 4
1894:                					dj->sclust = 0;
9D001154  AE200008   SW ZERO, 8(S1)
1895:                					dj->dir = 0; /* It is the root dir */
1896:                					res = FR_OK;
9D001164  0B400477   J 0x9D0011DC
9D001168  00001021   ADDU V0, ZERO, ZERO
1897:                					if (!(ns & NS_LAST))
9D001158  30630004   ANDI V1, V1, 4
9D00115C  1060FF48   BEQ V1, ZERO, 0x9D000E80
9D001160  AE200014   SW ZERO, 20(S1)
1898:                						continue;
1899:                				} else { /* Could not find the object */
1900:                					if (!(ns & NS_LAST))
1901:                						res = FR_NO_PATH;
1902:                				}
1903:                				break;
1904:                			}
1905:                			if (ns & NS_LAST)
9D001238  30630004   ANDI V1, V1, 4
9D00123C  5060FFD0   BEQL V1, ZERO, 0x9D001180
9D001240  31290010   ANDI T1, T1, 16
1906:                				break; /* Last segment match. Function completed. */
1907:                			dir = dj->dir; /* There is next segment. Follow the sub directory */
1908:                			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
9D001180  11200016   BEQ T1, ZERO, 0x9D0011DC
9D001184  24020005   ADDIU V0, ZERO, 5
1909:                				res = FR_NO_PATH;
1910:                				break;
1911:                			}
1912:                			dj->sclust = LD_CLUST(dir);
9D001188  90E30015   LBU V1, 21(A3)
9D00118C  00031A00   SLL V1, V1, 8
9D001190  90E20014   LBU V0, 20(A3)
9D001194  00621825   OR V1, V1, V0
9D001198  00031C00   SLL V1, V1, 16
9D00119C  90E2001B   LBU V0, 27(A3)
9D0011A0  00021200   SLL V0, V0, 8
9D0011A4  90E4001A   LBU A0, 26(A3)
9D0011A8  00441025   OR V0, V0, A0
9D0011AC  00621025   OR V0, V1, V0
9D0011B0  0B4003A0   J 0x9D000E80
9D0011B4  AE220008   SW V0, 8(S1)
1913:                		}
1914:                	}
1915:                
1916:                	return res;
1917:                }
9D0011B8  0B400478   J 0x9D0011E0
9D0011BC  8FBF0034   LW RA, 52(SP)
9D0011DC  8FBF0034   LW RA, 52(SP)
9D0011E0  8FB70030   LW S7, 48(SP)
9D0011E4  8FB6002C   LW S6, 44(SP)
9D0011E8  8FB50028   LW S5, 40(SP)
9D0011EC  8FB40024   LW S4, 36(SP)
9D0011F0  8FB30020   LW S3, 32(SP)
9D0011F4  8FB2001C   LW S2, 28(SP)
9D0011F8  8FB10018   LW S1, 24(SP)
9D0011FC  8FB00014   LW S0, 20(SP)
9D001200  03E00008   JR RA
9D001204  27BD0038   ADDIU SP, SP, 56
9D001244  0B400478   J 0x9D0011E0
9D001248  8FBF0034   LW RA, 52(SP)
1918:                
1919:                /*-----------------------------------------------------------------------*/
1920:                /* Load a sector and check if it is an FAT Volume Boot Record            */
1921:                /*-----------------------------------------------------------------------*/
1922:                
1923:                static PF_BYTE check_fs( /* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
1924:                FATFS *fs, /* File system object */
1925:                DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
1926:                ) {
9D0002EC  27BDFFE8   ADDIU SP, SP, -24
9D0002F0  AFBF0014   SW RA, 20(SP)
9D0002F4  AFB00010   SW S0, 16(SP)
9D0002F8  00808021   ADDU S0, A0, ZERO
9D0002FC  00A03021   ADDU A2, A1, ZERO
1927:                	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK) /* Load boot record */
9D000300  90840001   LBU A0, 1(A0)
9D000304  26050034   ADDIU A1, S0, 52
9D000308  0F4025A6   JAL disk_read
9D00030C  24070001   ADDIU A3, ZERO, 1
9D000310  14400027   BNE V0, ZERO, 0x9D0003B0
9D000314  24030003   ADDIU V1, ZERO, 3
1928:                		return 3;
9D0003A0  3C02FFAB   LUI V0, -85
9D0003A4  3442BEBA   ORI V0, V0, -16710
9D0003A8  00621821   ADDU V1, V1, V0
9D0003AC  0003182B   SLTU V1, ZERO, V1
1929:                	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55) /* Check record signature (always placed at offset 510 even if the sector size is >512) */
9D000318  92040233   LBU A0, 563(S0)
9D00031C  00042200   SLL A0, A0, 8
9D000320  92020232   LBU V0, 562(S0)
9D000324  00822025   OR A0, A0, V0
9D000328  7C042620   SEH A0, A0
9D00032C  2402AA55   ADDIU V0, ZERO, -21931
9D000330  1482001F   BNE A0, V0, 0x9D0003B0
9D000334  24030002   ADDIU V1, ZERO, 2
1930:                		return 2;
1931:                
1932:                	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) /* Check "FAT" string */
9D000338  9204006D   LBU A0, 109(S0)
9D00033C  00042600   SLL A0, A0, 24
9D000340  9202006C   LBU V0, 108(S0)
9D000344  00021400   SLL V0, V0, 16
9D000348  00822025   OR A0, A0, V0
9D00034C  9202006A   LBU V0, 106(S0)
9D000350  00822025   OR A0, A0, V0
9D000354  9202006B   LBU V0, 107(S0)
9D000358  00021200   SLL V0, V0, 8
9D00035C  00822025   OR A0, A0, V0
9D000360  7C84B800   EXT A0, A0, 0, 24
9D000364  3C020054   LUI V0, 84
9D000368  24424146   ADDIU V0, V0, 16710
9D00036C  10820010   BEQ A0, V0, 0x9D0003B0
9D000370  00001821   ADDU V1, ZERO, ZERO
1933:                		return 0;
1934:                	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
9D000374  92030089   LBU V1, 137(S0)
9D000378  00031E00   SLL V1, V1, 24
9D00037C  92020088   LBU V0, 136(S0)
9D000380  00021400   SLL V0, V0, 16
9D000384  00621825   OR V1, V1, V0
9D000388  92020086   LBU V0, 134(S0)
9D00038C  00621825   OR V1, V1, V0
9D000390  92020087   LBU V0, 135(S0)
9D000394  00021200   SLL V0, V0, 8
9D000398  00621825   OR V1, V1, V0
9D00039C  7C63B800   EXT V1, V1, 0, 24
1935:                		return 0;
1936:                
1937:                	return 1;
1938:                }
9D0003B0  00601021   ADDU V0, V1, ZERO
9D0003B4  8FBF0014   LW RA, 20(SP)
9D0003B8  8FB00010   LW S0, 16(SP)
9D0003BC  03E00008   JR RA
9D0003C0  27BD0018   ADDIU SP, SP, 24
1939:                
1940:                /*-----------------------------------------------------------------------*/
1941:                /* Check if the file system object is valid or not                       */
1942:                /*-----------------------------------------------------------------------*/
1943:                
1944:                FRESULT chk_mounted( /* FR_OK(0): successful, !=0: any error occurred */
1945:                                            const TCHAR **path, /* Pointer to pointer to the path name (drive number) */
1946:                                            FATFS **rfs, /* Pointer to pointer to the found file system object */
1947:                                            PF_BYTE chk_wp /* !=0: Check media write protection for write access */
1948:                                            ) {
9D0014A4  27BDFFE0   ADDIU SP, SP, -32
9D0014A8  AFBF001C   SW RA, 28(SP)
9D0014AC  AFB20018   SW S2, 24(SP)
9D0014B0  AFB10014   SW S1, 20(SP)
9D0014B4  AFB00010   SW S0, 16(SP)
9D0014B8  30D100FF   ANDI S1, A2, 255
1949:                	PF_BYTE fmt, b, pi, *tbl;
1950:                	UINT vol;
1951:                	DSTATUS stat;
1952:                	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
1953:                	PF_WORD nrsv;
1954:                	const TCHAR *p = *path;
9D0014BC  8C820000   LW V0, 0(A0)
1955:                	FATFS *fs;
1956:                
1957:                	/* Get logical drive number from the path name */
1958:                	vol = p[0] - '0'; /* Is there a drive number? */
9D0014C0  80430000   LB V1, 0(V0)
9D0014C4  2463FFD0   ADDIU V1, V1, -48
1959:                	if (vol <= 9 && p[1] == ':') { /* Found a drive number, get and strip it */
9D0014C8  2C66000A   SLTIU A2, V1, 10
9D0014CC  50C00007   BEQL A2, ZERO, 0x9D0014EC
9D0014D0  93838058   LBU V1, -32680(GP)
9D0014D4  80470001   LB A3, 1(V0)
9D0014D8  2406003A   ADDIU A2, ZERO, 58
9D0014DC  54E60003   BNEL A3, A2, 0x9D0014EC
9D0014E0  93838058   LBU V1, -32680(GP)
1960:                		p += 2;
9D0014E4  24420002   ADDIU V0, V0, 2
9D0014E8  AC820000   SW V0, 0(A0)
1961:                		*path = p; /* Return pointer to the path name */
1962:                	} else { /* No drive number is given */
1963:                #if _FS_RPATH
1964:                		vol = CurrVol; /* Use current drive */
1965:                #else
1966:                		vol = 0; /* Use drive 0 */
1967:                #endif
1968:                	}
1969:                
1970:                	/* Check if the file system object is valid or not */
1971:                	if (vol >= _VOLUMES) /* Is the drive number valid? */
9D0014EC  14600114   BNE V1, ZERO, 0x9D001940
9D0014F0  2402000B   ADDIU V0, ZERO, 11
1972:                		return FR_INVALID_DRIVE;
1973:                	*rfs = fs = FatFs[vol]; /* Return pointer to the corresponding file system object */
9D0014F4  8F90805C   LW S0, -32676(GP)
9D0014F8  ACB00000   SW S0, 0(A1)
1974:                	if (!fs)
9D0014FC  12000110   BEQ S0, ZERO, 0x9D001940
9D001500  2402000C   ADDIU V0, ZERO, 12
1975:                		return FR_NOT_ENABLED; /* Is the file system object available? */
1976:                
1977:                	ENTER_FF(fs); /* Lock file system */
1978:                
1979:                	if (fs->fs_type) { /* If the logical drive has been mounted */
9D001504  92020000   LBU V0, 0(S0)
9D001508  5040000D   BEQL V0, ZERO, 0x9D001540
9D00150C  A2000000   SB ZERO, 0(S0)
1980:                		stat = disk_status(fs->drv);
9D001510  0F40259F   JAL disk_status
9D001514  92040001   LBU A0, 1(S0)
9D001518  00401821   ADDU V1, V0, ZERO
1981:                		if (!(stat & STA_NOINIT)) { /* and the physical drive is kept initialized (has not been changed), */
9D00151C  30420001   ANDI V0, V0, 1
9D001520  54400007   BNEL V0, ZERO, 0x9D001540
9D001524  A2000000   SB ZERO, 0(S0)
1982:                			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check write protection if needed */
9D001528  12200105   BEQ S1, ZERO, 0x9D001940
9D00152C  2404000A   ADDIU A0, ZERO, 10
9D001530  30620004   ANDI V0, V1, 4
1983:                				return FR_WRITE_PROTECTED;
1984:                			return FR_OK; /* The file system object is valid */
9D001534  0002200A   MOVZ A0, ZERO, V0
9D001538  0B400650   J 0x9D001940
9D00153C  00801021   ADDU V0, A0, ZERO
1985:                		}
1986:                	}
1987:                
1988:                	/* The file system object is not valid. */
1989:                	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
1990:                
1991:                	fs->fs_type = 0; /* Clear the file system object */
1992:                	fs->drv = LD2PD(vol); /* Bind the logical drive and a physical drive */
9D001540  A2000001   SB ZERO, 1(S0)
1993:                	stat = disk_initialize(fs->drv); /* Initialize low level disk I/O layer */
9D001544  0F40250F   JAL disk_initialize
9D001548  00002021   ADDU A0, ZERO, ZERO
9D00154C  00401821   ADDU V1, V0, ZERO
1994:                	if (stat & STA_NOINIT) /* Check if the initialization succeeded */
9D001550  30440001   ANDI A0, V0, 1
9D001554  148000FA   BNE A0, ZERO, 0x9D001940
9D001558  24020003   ADDIU V0, ZERO, 3
1995:                		return FR_NOT_READY; /* Failed to initialize due to no media or hard error */
1996:                	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check disk write protection if needed */
9D00155C  12200003   BEQ S1, ZERO, 0x9D00156C
9D001560  30630004   ANDI V1, V1, 4
9D001564  146000F6   BNE V1, ZERO, 0x9D001940
9D001568  2402000A   ADDIU V0, ZERO, 10
1997:                		return FR_WRITE_PROTECTED;
1998:                #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
1999:                	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
2000:                	return FR_DISK_ERR;
2001:                #endif
2002:                	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
2003:                	fmt = check_fs(fs, bsect = 0); /* Load sector 0 and check if it is an FAT-VBR (in SFD) */
9D00156C  02002021   ADDU A0, S0, ZERO
9D001570  0F4000BB   JAL check_fs
9D001574  00002821   ADDU A1, ZERO, ZERO
9D001578  00401821   ADDU V1, V0, ZERO
2004:                	if (LD2PT(vol) && !fmt)
2005:                		fmt = 1; /* Force non-SFD if the volume is forced partition */
2006:                	if (fmt == 1) { /* Not an FAT-VBR, the physical drive can be partitioned */
9D00157C  24020001   ADDIU V0, ZERO, 1
9D001580  14620012   BNE V1, V0, 0x9D0015CC
9D001584  00008821   ADDU S1, ZERO, ZERO
2007:                		/* Check the partition listed in the partition table */
2008:                		pi = LD2PT(vol);
2009:                		if (pi)
2010:                			pi--;
2011:                		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
2012:                		if (tbl[4]) { /* Is the partition existing? */
9D001588  920301F6   LBU V1, 502(S0)
9D00158C  106000EC   BEQ V1, ZERO, 0x9D001940
9D001590  2402000D   ADDIU V0, ZERO, 13
2013:                			bsect = LD_DWORD(&tbl[8]); /* Partition offset in LBA */
9D001594  921101FD   LBU S1, 509(S0)
9D001598  00118E00   SLL S1, S1, 24
9D00159C  920201FC   LBU V0, 508(S0)
9D0015A0  00021400   SLL V0, V0, 16
9D0015A4  02228825   OR S1, S1, V0
9D0015A8  920201FA   LBU V0, 506(S0)
9D0015AC  02228825   OR S1, S1, V0
9D0015B0  920201FB   LBU V0, 507(S0)
9D0015B4  00021200   SLL V0, V0, 8
9D0015B8  02228825   OR S1, S1, V0
2014:                			fmt = check_fs(fs, bsect); /* Check the partition */
9D0015BC  02002021   ADDU A0, S0, ZERO
9D0015C0  0F4000BB   JAL check_fs
9D0015C4  02202821   ADDU A1, S1, ZERO
9D0015C8  00401821   ADDU V1, V0, ZERO
2015:                		}
2016:                	}
2017:                	if (fmt == 3)
9D0015CC  24040003   ADDIU A0, ZERO, 3
9D0015D0  106400DB   BEQ V1, A0, 0x9D001940
9D0015D4  24020001   ADDIU V0, ZERO, 1
2018:                		return FR_DISK_ERR;
2019:                	if (fmt)
9D0015D8  146000D9   BNE V1, ZERO, 0x9D001940
9D0015DC  2402000D   ADDIU V0, ZERO, 13
2020:                		return FR_NO_FILESYSTEM; /* No FAT volume is found */
2021:                
2022:                	/* An FAT volume is found. Following code initializes the file system object */
2023:                
2024:                	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs)) /* (BPB_BytsPerSec must be equal to the physical sector size) */
9D0015E0  92040040   LBU A0, 64(S0)
9D0015E4  00042200   SLL A0, A0, 8
9D0015E8  9202003F   LBU V0, 63(S0)
9D0015EC  00822025   OR A0, A0, V0
9D0015F0  7C042620   SEH A0, A0
9D0015F4  24030200   ADDIU V1, ZERO, 512
9D0015F8  148300D1   BNE A0, V1, 0x9D001940
9D0015FC  2402000D   ADDIU V0, ZERO, 13
2025:                		return FR_NO_FILESYSTEM;
2026:                
2027:                	fasize = LD_WORD(fs->win+BPB_FATSz16); /* Number of sectors per FAT */
9D001600  9203004B   LBU V1, 75(S0)
9D001604  00031A00   SLL V1, V1, 8
9D001608  9202004A   LBU V0, 74(S0)
9D00160C  00621825   OR V1, V1, V0
2028:                	if (!fasize)
9D001610  5460000C   BNEL V1, ZERO, 0x9D001644
9D001614  AE030020   SW V1, 32(S0)
2029:                		fasize = LD_DWORD(fs->win+BPB_FATSz32);
9D001618  9203005B   LBU V1, 91(S0)
9D00161C  00031E00   SLL V1, V1, 24
9D001620  9202005A   LBU V0, 90(S0)
9D001624  00021400   SLL V0, V0, 16
9D001628  00621825   OR V1, V1, V0
9D00162C  92020058   LBU V0, 88(S0)
9D001630  00621825   OR V1, V1, V0
9D001634  92020059   LBU V0, 89(S0)
9D001638  00021200   SLL V0, V0, 8
9D00163C  00621825   OR V1, V1, V0
2030:                	fs->fsize = fasize;
9D001640  AE030020   SW V1, 32(S0)
2031:                
2032:                	fs->n_fats = b = fs->win[BPB_NumFATs]; /* Number of FAT copies */
9D001644  92070044   LBU A3, 68(S0)
9D001648  A2070003   SB A3, 3(S0)
2033:                	if (b != 1 && b != 2)
9D00164C  24E4FFFF   ADDIU A0, A3, -1
9D001650  308400FF   ANDI A0, A0, 255
9D001654  2C840002   SLTIU A0, A0, 2
9D001658  108000B9   BEQ A0, ZERO, 0x9D001940
9D00165C  2402000D   ADDIU V0, ZERO, 13
2034:                		return FR_NO_FILESYSTEM; /* (Must be 1 or 2) */
2035:                	fasize *= b; /* Number of sectors for FAT area */
9D0016F0  70673802   MUL A3, V1, A3
2036:                
2037:                	fs->csize = b = fs->win[BPB_SecPerClus]; /* Number of sectors per cluster */
9D001660  92080041   LBU T0, 65(S0)
2038:                	if (!b || (b & (b - 1)))
9D001664  110000B6   BEQ T0, ZERO, 0x9D001940
9D001668  A2080002   SB T0, 2(S0)
9D00166C  2504FFFF   ADDIU A0, T0, -1
9D001670  00882024   AND A0, A0, T0
9D001674  148000B3   BNE A0, ZERO, 0x9D001944
9D001678  8FBF001C   LW RA, 28(SP)
2039:                		return FR_NO_FILESYSTEM; /* (Must be power of 2) */
2040:                
2041:                	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt); /* Number of root directory entries */
9D00167C  92040046   LBU A0, 70(S0)
9D001680  00042200   SLL A0, A0, 8
9D001684  92020045   LBU V0, 69(S0)
9D001688  00822025   OR A0, A0, V0
9D00168C  A6040008   SH A0, 8(S0)
2042:                	if (fs->n_rootdir % (SS(fs) / SZ_DIR))
9D001690  3085000F   ANDI A1, A0, 15
9D001694  14A000AA   BNE A1, ZERO, 0x9D001940
9D001698  2402000D   ADDIU V0, ZERO, 13
2043:                		return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be sector aligned) */
2044:                
2045:                	tsect = LD_WORD(fs->win+BPB_TotSec16); /* Number of sectors on the volume */
9D00169C  92090048   LBU T1, 72(S0)
9D0016A0  00094A00   SLL T1, T1, 8
9D0016A4  92020047   LBU V0, 71(S0)
9D0016A8  01224825   OR T1, T1, V0
2046:                	if (!tsect)
9D0016AC  1520000B   BNE T1, ZERO, 0x9D0016DC
9D0016B0  92050043   LBU A1, 67(S0)
2047:                		tsect = LD_DWORD(fs->win+BPB_TotSec32);
9D0016B4  92090057   LBU T1, 87(S0)
9D0016B8  00094E00   SLL T1, T1, 24
9D0016BC  92020056   LBU V0, 86(S0)
9D0016C0  00021400   SLL V0, V0, 16
9D0016C4  01224825   OR T1, T1, V0
9D0016C8  92020054   LBU V0, 84(S0)
9D0016CC  01224825   OR T1, T1, V0
9D0016D0  92020055   LBU V0, 85(S0)
9D0016D4  00021200   SLL V0, V0, 8
9D0016D8  01224825   OR T1, T1, V0
2048:                
2049:                	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt); /* Number of reserved sectors */
9D0016DC  00052A00   SLL A1, A1, 8
9D0016E0  92020042   LBU V0, 66(S0)
9D0016E4  00A22825   OR A1, A1, V0
2050:                	if (!nrsv)
9D0016E8  10A00095   BEQ A1, ZERO, 0x9D001940
9D0016EC  2402000D   ADDIU V0, ZERO, 13
2051:                		return FR_NO_FILESYSTEM; /* (BPB_RsvdSecCnt must not be 0) */
2052:                
2053:                	/* Determine the FAT sub type */
2054:                	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR); /* RSV+FAT+DIR */
9D0016F4  00043102   SRL A2, A0, 4
9D0016F8  00C53021   ADDU A2, A2, A1
9D0016FC  00C73021   ADDU A2, A2, A3
2055:                	if (tsect < sysect)
9D001700  0126502B   SLTU T2, T1, A2
9D001704  1540008F   BNE T2, ZERO, 0x9D001944
9D001708  8FBF001C   LW RA, 28(SP)
2056:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2057:                	nclst = (tsect - sysect) / fs->csize; /* Number of clusters */
9D00170C  01261023   SUBU V0, T1, A2
9D001710  0048001B   DIVU V0, T0
9D001714  010001F4   TEQ T0, ZERO
9D001718  00004012   MFLO T0, 0
2058:                	if (!nclst)
9D00171C  11000088   BEQ T0, ZERO, 0x9D001940
9D001720  2402000D   ADDIU V0, ZERO, 13
2059:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2060:                	fmt = FS_FAT12;
9D001728  24020001   ADDIU V0, ZERO, 1
9D00172C  24090002   ADDIU T1, ZERO, 2
9D001730  0132100A   MOVZ V0, T1, S2
9D001734  00409021   ADDU S2, V0, ZERO
2061:                	if (nclst >= MIN_FAT16)
9D001724  2D120FF6   SLTIU S2, T0, 4086
2062:                		fmt = FS_FAT16;
2063:                	if (nclst >= MIN_FAT32)
9D001738  3402FFF6   ORI V0, ZERO, -10
9D00173C  0102102B   SLTU V0, T0, V0
9D001740  10400085   BEQ V0, ZERO, 0x9D001958
9D001744  25080002   ADDIU T0, T0, 2
2064:                		fmt = FS_FAT32;
9D00196C  0B4005D9   J 0x9D001764
9D001970  24120003   ADDIU S2, ZERO, 3
2065:                
2066:                	/* Boundaries and Limits */
2067:                	fs->n_fatent = nclst + 2; /* Number of FAT entries */
9D001748  AE08001C   SW T0, 28(S0)
9D001958  AE08001C   SW T0, 28(S0)
2068:                	fs->database = bsect + sysect; /* Data start sector */
9D00174C  02263021   ADDU A2, S1, A2
9D001750  AE06002C   SW A2, 44(S0)
9D00195C  02263021   ADDU A2, S1, A2
9D001960  AE06002C   SW A2, 44(S0)
2069:                	fs->fatbase = bsect + nrsv; /* FAT start sector */
9D001754  02252821   ADDU A1, S1, A1
9D001964  02252821   ADDU A1, S1, A1
9D001968  AE050024   SW A1, 36(S0)
2070:                	if (fmt == FS_FAT32) {
9D001758  24020003   ADDIU V0, ZERO, 3
9D00175C  16420010   BNE S2, V0, 0x9D0017A0
9D001760  AE050024   SW A1, 36(S0)
2071:                		if (fs->n_rootdir)
9D001764  14800076   BNE A0, ZERO, 0x9D001940
9D001768  2402000D   ADDIU V0, ZERO, 13
2072:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be 0) */
2073:                		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
9D00176C  92040063   LBU A0, 99(S0)
9D001770  00042600   SLL A0, A0, 24
9D001774  92020062   LBU V0, 98(S0)
9D001778  00021400   SLL V0, V0, 16
9D00177C  00822025   OR A0, A0, V0
9D001780  92020060   LBU V0, 96(S0)
9D001784  00822025   OR A0, A0, V0
9D001788  92020061   LBU V0, 97(S0)
9D00178C  00021200   SLL V0, V0, 8
9D001790  00821025   OR V0, A0, V0
9D001794  AE020028   SW V0, 40(S0)
2074:                		szbfat = fs->n_fatent * 4; /* (Required FAT size) */
9D001798  0B4005F5   J 0x9D0017D4
9D00179C  00084080   SLL T0, T0, 2
2075:                	} else {
2076:                		if (!fs->n_rootdir)
9D0017A0  10800067   BEQ A0, ZERO, 0x9D001940
9D0017A4  2402000D   ADDIU V0, ZERO, 13
2077:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must not be 0) */
2078:                		fs->dirbase = fs->fatbase + fasize; /* Root directory start sector */
9D0017A8  00E52821   ADDU A1, A3, A1
2079:                		szbfat = (fmt == FS_FAT16) ? /* (Required FAT size) */
2080:                		fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
9D0017AC  24020002   ADDIU V0, ZERO, 2
9D0017B0  16420003   BNE S2, V0, 0x9D0017C0
9D0017B4  AE050028   SW A1, 40(S0)
9D0017B8  0B4005F5   J 0x9D0017D4
9D0017BC  00084040   SLL T0, T0, 1
9D0017C0  24020003   ADDIU V0, ZERO, 3
9D0017C4  71021002   MUL V0, T0, V0
9D0017C8  00021042   SRL V0, V0, 1
9D0017CC  31080001   ANDI T0, T0, 1
9D0017D0  00484021   ADDU T0, V0, T0
2081:                	}
2082:                	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) /* (BPB_FATSz must not be less than required) */
9D0017D4  250801FF   ADDIU T0, T0, 511
9D0017D8  00084242   SRL T0, T0, 9
9D0017DC  0068182B   SLTU V1, V1, T0
9D0017E0  14600057   BNE V1, ZERO, 0x9D001940
9D0017E4  2402000D   ADDIU V0, ZERO, 13
2083:                		return FR_NO_FILESYSTEM;
2084:                
2085:                #if !_FS_READONLY
2086:                	/* Initialize cluster allocation information */
2087:                	fs->free_clust = 0xFFFFFFFF;
9D0017E8  2402FFFF   ADDIU V0, ZERO, -1
9D0017EC  AE020010   SW V0, 16(S0)
2088:                	fs->last_clust = 0;
2089:                
2090:                	/* Get fsinfo if available */
2091:                	if (fmt == FS_FAT32) {
9D0017F0  24020003   ADDIU V0, ZERO, 3
9D0017F4  16420048   BNE S2, V0, 0x9D001918
9D0017F8  AE00000C   SW ZERO, 12(S0)
2092:                		fs->fsi_flag = 0;
9D0017FC  A2000005   SB ZERO, 5(S0)
2093:                		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
9D001800  92060065   LBU A2, 101(S0)
9D001804  00063200   SLL A2, A2, 8
9D001808  92020064   LBU V0, 100(S0)
9D00180C  00C23025   OR A2, A2, V0
9D001810  02263021   ADDU A2, S1, A2
9D001814  AE060014   SW A2, 20(S0)
2094:                		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK
9D001818  92040001   LBU A0, 1(S0)
9D00181C  26050034   ADDIU A1, S0, 52
9D001820  0F4025A6   JAL disk_read
9D001824  24070001   ADDIU A3, ZERO, 1
9D001828  5440003C   BNEL V0, ZERO, 0x9D00191C
9D00182C  A2120000   SB S2, 0(S0)
2095:                				&& LD_WORD(fs->win+BS_55AA) == 0xAA55
9D001830  92030233   LBU V1, 563(S0)
9D001834  00031A00   SLL V1, V1, 8
9D001838  92020232   LBU V0, 562(S0)
9D00183C  00621825   OR V1, V1, V0
9D001840  7C031E20   SEH V1, V1
9D001844  2402AA55   ADDIU V0, ZERO, -21931
9D001848  54620034   BNEL V1, V0, 0x9D00191C
9D00184C  A2120000   SB S2, 0(S0)
2096:                				&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
9D001850  92030037   LBU V1, 55(S0)
9D001854  00031E00   SLL V1, V1, 24
9D001858  92020036   LBU V0, 54(S0)
9D00185C  00021400   SLL V0, V0, 16
9D001860  00621825   OR V1, V1, V0
9D001864  92020034   LBU V0, 52(S0)
9D001868  00621825   OR V1, V1, V0
9D00186C  92020035   LBU V0, 53(S0)
9D001870  00021200   SLL V0, V0, 8
9D001874  00621825   OR V1, V1, V0
9D001878  3C024161   LUI V0, 16737
9D00187C  24425252   ADDIU V0, V0, 21074
9D001880  54620026   BNEL V1, V0, 0x9D00191C
9D001884  A2120000   SB S2, 0(S0)
2097:                				&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
9D001888  9203021B   LBU V1, 539(S0)
9D00188C  00031E00   SLL V1, V1, 24
9D001890  9202021A   LBU V0, 538(S0)
9D001894  00021400   SLL V0, V0, 16
9D001898  00621825   OR V1, V1, V0
9D00189C  92020218   LBU V0, 536(S0)
9D0018A0  00621825   OR V1, V1, V0
9D0018A4  92020219   LBU V0, 537(S0)
9D0018A8  00021200   SLL V0, V0, 8
9D0018AC  00621825   OR V1, V1, V0
9D0018B0  3C026141   LUI V0, 24897
9D0018B4  24427272   ADDIU V0, V0, 29298
9D0018B8  54620018   BNEL V1, V0, 0x9D00191C
9D0018BC  A2120000   SB S2, 0(S0)
2098:                			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
9D0018C0  92030223   LBU V1, 547(S0)
9D0018C4  00031E00   SLL V1, V1, 24
9D0018C8  92020222   LBU V0, 546(S0)
9D0018CC  00021400   SLL V0, V0, 16
9D0018D0  00621825   OR V1, V1, V0
9D0018D4  92020220   LBU V0, 544(S0)
9D0018D8  00621825   OR V1, V1, V0
9D0018DC  92020221   LBU V0, 545(S0)
9D0018E0  00021200   SLL V0, V0, 8
9D0018E4  00621025   OR V0, V1, V0
9D0018E8  AE02000C   SW V0, 12(S0)
2099:                			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
9D0018EC  9203021F   LBU V1, 543(S0)
9D0018F0  00031E00   SLL V1, V1, 24
9D0018F4  9202021E   LBU V0, 542(S0)
9D0018F8  00021400   SLL V0, V0, 16
9D0018FC  00621825   OR V1, V1, V0
9D001900  9202021C   LBU V0, 540(S0)
9D001904  00621825   OR V1, V1, V0
9D001908  9202021D   LBU V0, 541(S0)
9D00190C  00021200   SLL V0, V0, 8
9D001910  00621025   OR V0, V1, V0
9D001914  AE020010   SW V0, 16(S0)
2100:                		}
2101:                	}
2102:                #endif
2103:                	fs->fs_type = fmt; /* FAT sub-type */
9D001918  A2120000   SB S2, 0(S0)
2104:                	fs->id = ++Fsid; /* File system mount ID */
9D00191C  97828060   LHU V0, -32672(GP)
9D001920  24420001   ADDIU V0, V0, 1
9D001924  3042FFFF   ANDI V0, V0, -1
9D001928  A7828060   SH V0, -32672(GP)
9D00192C  A6020006   SH V0, 6(S0)
2105:                	fs->winsect = 0; /* Invalidate sector cache */
9D001930  AE000030   SW ZERO, 48(S0)
2106:                	fs->wflag = 0;
9D001934  A2000004   SB ZERO, 4(S0)
2107:                #if _FS_RPATH
2108:                	fs->cdir = 0; /* Current directory (root dir) */
9D001938  AE000018   SW ZERO, 24(S0)
2109:                #endif
2110:                #if _FS_SHARE				/* Clear file lock semaphores */
2111:                	clear_lock(fs);
2112:                #endif
2113:                
2114:                	return FR_OK;
9D00193C  00001021   ADDU V0, ZERO, ZERO
2115:                }
9D001940  8FBF001C   LW RA, 28(SP)
9D001944  8FB20018   LW S2, 24(SP)
9D001948  8FB10014   LW S1, 20(SP)
9D00194C  8FB00010   LW S0, 16(SP)
9D001950  03E00008   JR RA
9D001954  27BD0020   ADDIU SP, SP, 32
2116:                
2117:                /*-----------------------------------------------------------------------*/
2118:                /* Check if the file/dir object is valid or not                          */
2119:                /*-----------------------------------------------------------------------*/
2120:                
2121:                static FRESULT validate( /* FR_OK(0): The object is valid, !=0: Invalid */
2122:                FATFS *fs, /* Pointer to the file system object */
2123:                PF_WORD id /* Member id of the target object to be checked */
2124:                ) {
9D0004EC  27BDFFE8   ADDIU SP, SP, -24
9D0004F0  AFBF0014   SW RA, 20(SP)
2125:                	if (!fs || !fs->fs_type || fs->id != id)
9D0004F4  1080000D   BEQ A0, ZERO, 0x9D00052C
9D0004F8  24020009   ADDIU V0, ZERO, 9
9D0004FC  90830000   LBU V1, 0(A0)
9D000500  1060000B   BEQ V1, ZERO, 0x9D000530
9D000504  8FBF0014   LW RA, 20(SP)
9D000508  94830006   LHU V1, 6(A0)
9D00050C  14650008   BNE V1, A1, 0x9D000530
9D000510  00000000   NOP
2126:                		return FR_INVALID_OBJECT;
2127:                
2128:                	ENTER_FF(fs); /* Lock file system */
2129:                
2130:                	if (disk_status(fs->drv) & STA_NOINIT)
9D000514  0F40259F   JAL disk_status
9D000518  90840001   LBU A0, 1(A0)
9D00051C  30420001   ANDI V0, V0, 1
2131:                		return FR_NOT_READY;
9D000520  24030003   ADDIU V1, ZERO, 3
9D000524  0002180A   MOVZ V1, ZERO, V0
9D000528  00601021   ADDU V0, V1, ZERO
2132:                
2133:                	return FR_OK;
2134:                }
9D00052C  8FBF0014   LW RA, 20(SP)
9D000530  03E00008   JR RA
9D000534  27BD0018   ADDIU SP, SP, 24
2135:                
2136:                /*--------------------------------------------------------------------------
2137:                
2138:                 Public Functions
2139:                
2140:                 --------------------------------------------------------------------------*/
2141:                
2142:                /*-----------------------------------------------------------------------*/
2143:                /* Mount/Unmount a Logical Drive                                         */
2144:                /*-----------------------------------------------------------------------*/
2145:                
2146:                FRESULT f_mount(PF_BYTE vol, /* Logical drive number to be mounted/unmounted */
2147:                                FATFS *fs /* Pointer to new file system object (NULL for unmount)*/
2148:                                ) {
9D001974  308400FF   ANDI A0, A0, 255
2149:                	FATFS *rfs;
2150:                
2151:                	if (vol >= _VOLUMES) {/* Check if the drive number is valid */
9D001978  14800008   BNE A0, ZERO, 0x9D00199C
9D00197C  2402000B   ADDIU V0, ZERO, 11
2152:                		return FR_INVALID_DRIVE;
2153:                	}
2154:                	rfs = FatFs[vol]; /* Get current fs object */
9D001980  8F82805C   LW V0, -32676(GP)
2155:                
2156:                	if (rfs) {
9D001984  54400001   BNEL V0, ZERO, 0x9D00198C
9D001988  A0400000   SB ZERO, 0(V0)
2157:                #if _FS_SHARE
2158:                		clear_lock(rfs);
2159:                #endif
2160:                #if _FS_REENTRANT				/* Discard sync object of the current volume */
2161:                		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2162:                #endif
2163:                		rfs->fs_type = 0; /* Clear old fs object */
2164:                	}
2165:                
2166:                	if (fs) {
9D00198C  54A00001   BNEL A1, ZERO, 0x9D001994
9D001990  A0A00000   SB ZERO, 0(A1)
2167:                		fs->fs_type = 0; /* Clear new fs object */
2168:                #if _FS_REENTRANT				/* Create sync object for the new volume */
2169:                		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2170:                #endif
2171:                	}
2172:                	FatFs[vol] = fs; /* Register new fs object */
9D001994  AF85805C   SW A1, -32676(GP)
2173:                
2174:                	return FR_OK;
9D001998  00001021   ADDU V0, ZERO, ZERO
2175:                }
9D00199C  03E00008   JR RA
9D0019A0  00000000   NOP
2176:                
2177:                /*-----------------------------------------------------------------------*/
2178:                /* Open or Create a File                                                 */
2179:                /*-----------------------------------------------------------------------*/
2180:                
2181:                FRESULT f_open(FIL *fp, /* Pointer to the blank file object */
2182:                                const TCHAR *path, /* Pointer to the file name */
2183:                                PF_BYTE mode /* Access mode and file open mode flags */
2184:                                ) {
9D0019A4  27BDFFB0   ADDIU SP, SP, -80
9D0019A8  AFBF004C   SW RA, 76(SP)
9D0019AC  AFB40048   SW S4, 72(SP)
9D0019B0  AFB30044   SW S3, 68(SP)
9D0019B4  AFB20040   SW S2, 64(SP)
9D0019B8  AFB1003C   SW S1, 60(SP)
9D0019BC  AFB00038   SW S0, 56(SP)
9D0019C0  00808821   ADDU S1, A0, ZERO
9D0019C4  AFA50054   SW A1, 84(SP)
2185:                	FRESULT res;
2186:                	DIR dj;
2187:                	PF_BYTE *dir;
2188:                	DEF_NAMEBUF;
2189:                
2190:                	fp->fs = 0; /* Clear file object */
9D0019C8  AC800000   SW ZERO, 0(A0)
2191:                
2192:                #if !_FS_READONLY
2193:                	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS
9D0019CC  30D2001F   ANDI S2, A2, 31
2194:                			| FA_CREATE_NEW;
2195:                	res = chk_mounted(&path, &dj.fs, (PF_BYTE) (mode & ~FA_READ));
9D0019D0  02409821   ADDU S3, S2, ZERO
9D0019D4  27A40054   ADDIU A0, SP, 84
9D0019D8  27A50010   ADDIU A1, SP, 16
9D0019DC  0F400529   JAL chk_mounted
9D0019E0  3246001E   ANDI A2, S2, 30
2196:                #else
2197:                	mode &= FA_READ;
2198:                	res = chk_mounted(&path, &dj.fs, 0);
2199:                #endif
2200:                	INIT_BUF(dj);
9D0019E4  27A3002C   ADDIU V1, SP, 44
2201:                	if (res == FR_OK)
9D0019E8  14400086   BNE V0, ZERO, 0x9D001C04
9D0019EC  AFA30028   SW V1, 40(SP)
2202:                		res = follow_path(&dj, path); /* Follow the file path */
9D0019F0  27A40010   ADDIU A0, SP, 16
9D0019F4  0F40037C   JAL follow_path
9D0019F8  8FA50054   LW A1, 84(SP)
2203:                	dir = dj.dir;
9D001C04  0B400683   J 0x9D001A0C
9D001C08  8FB00024   LW S0, 36(SP)
2204:                
2205:                #if !_FS_READONLY	/* R/W configuration */
2206:                	if (res == FR_OK) {
9D0019FC  14400003   BNE V0, ZERO, 0x9D001A0C
9D001A00  8FB00024   LW S0, 36(SP)
2207:                		if (!dir) /* Current dir itself */
2208:                			res = FR_INVALID_NAME;
9D001A04  24030006   ADDIU V1, ZERO, 6
9D001A08  0070100A   MOVZ V0, V1, S0
2209:                #if _FS_SHARE
2210:                		else
2211:                		res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2212:                #endif
2213:                	}
2214:                	/* Create or Open a file */
2215:                	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
9D001A0C  3263001C   ANDI V1, S3, 28
9D001A10  10600044   BEQ V1, ZERO, 0x9D001B24
9D001A14  00000000   NOP
2216:                		DWORD dw, cl;
2217:                
2218:                		if (res != FR_OK) { /* No file, create new */
9D001A18  5040000B   BEQL V0, ZERO, 0x9D001A48
9D001A1C  9203000B   LBU V1, 11(S0)
2219:                			if (res == FR_NO_FILE) /* There is no file to open, create a new entry */
9D001A20  24030004   ADDIU V1, ZERO, 4
9D001A24  14430070   BNE V0, V1, 0x9D001BE8
9D001A28  8FBF004C   LW RA, 76(SP)
2220:                #if _FS_SHARE
2221:                				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
2222:                #else
2223:                				res = dir_register(&dj);
9D001A2C  0F400495   JAL dir_register
9D001A30  27A40010   ADDIU A0, SP, 16
2224:                #endif
2225:                			mode |= FA_CREATE_ALWAYS; /* File is created */
2226:                			dir = dj.dir; /* New entry */
9D001A34  8FB00024   LW S0, 36(SP)
2227:                		} else { /* Any object is already existing */
2228:                			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) { /* Cannot overwrite it (R/O or DIR) */
9D001A48  30630011   ANDI V1, V1, 17
9D001A4C  14600065   BNE V1, ZERO, 0x9D001BE4
9D001A50  24020007   ADDIU V0, ZERO, 7
2229:                				res = FR_DENIED;
2230:                			} else {
2231:                				if (mode & FA_CREATE_NEW) /* Cannot create as new file */
9D001A54  32730004   ANDI S3, S3, 4
9D001A58  16600062   BNE S3, ZERO, 0x9D001BE4
9D001A5C  24020008   ADDIU V0, ZERO, 8
2232:                					res = FR_EXIST;
2233:                			}
2234:                		}
2235:                		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) { /* Truncate it if overwrite mode */
9D001A38  10400009   BEQ V0, ZERO, 0x9D001A60
9D001A3C  36520008   ORI S2, S2, 8
9D001A60  32420008   ANDI V0, S2, 8
9D001A64  1040003F   BEQ V0, ZERO, 0x9D001B64
9D001A68  8FA30010   LW V1, 16(SP)
2236:                			dw = get_fattime(); /* Created time */
9D001A6C  0F402701   JAL get_fattime
9D001A70  00000000   NOP
2237:                			ST_DWORD(dir+DIR_CrtTime, dw);
9D001A74  A202000E   SB V0, 14(S0)
9D001A78  7C433A00   EXT V1, V0, 8, 8
9D001A7C  A203000F   SB V1, 15(S0)
9D001A80  00021C02   SRL V1, V0, 16
9D001A84  A2030010   SB V1, 16(S0)
9D001A88  00021602   SRL V0, V0, 24
9D001A8C  A2020011   SB V0, 17(S0)
2238:                			dir[DIR_Attr] = 0; /* Reset attribute */
9D001A90  A200000B   SB ZERO, 11(S0)
2239:                			ST_DWORD(dir+DIR_FileSize, 0); /* size = 0 */
9D001A94  A200001C   SB ZERO, 28(S0)
9D001A98  A200001D   SB ZERO, 29(S0)
9D001A9C  A200001E   SB ZERO, 30(S0)
9D001AA0  A200001F   SB ZERO, 31(S0)
2240:                			cl = LD_CLUST(dir); /* Get start cluster */
9D001AA4  92020015   LBU V0, 21(S0)
9D001AA8  00021200   SLL V0, V0, 8
9D001AAC  92030014   LBU V1, 20(S0)
9D001AB0  00431025   OR V0, V0, V1
9D001AB4  00021400   SLL V0, V0, 16
9D001AB8  9213001B   LBU S3, 27(S0)
9D001ABC  00139A00   SLL S3, S3, 8
9D001AC0  9203001A   LBU V1, 26(S0)
9D001AC4  02639825   OR S3, S3, V1
9D001AC8  00539825   OR S3, V0, S3
2241:                			ST_CLUST(dir, 0); /* cluster = 0 */
9D001ACC  A200001A   SB ZERO, 26(S0)
9D001AD0  A200001B   SB ZERO, 27(S0)
9D001AD4  A2000014   SB ZERO, 20(S0)
9D001AD8  A2000015   SB ZERO, 21(S0)
2242:                			dj.fs->wflag = 1;
9D001ADC  8FA40010   LW A0, 16(SP)
9D001AE0  24020001   ADDIU V0, ZERO, 1
2243:                			if (cl) { /* Remove the cluster chain if exist */
9D001AE4  12600049   BEQ S3, ZERO, 0x9D001C0C
9D001AE8  A0820004   SB V0, 4(A0)
2244:                				dw = dj.fs->winsect;
9D001AEC  8C940030   LW S4, 48(A0)
2245:                				res = remove_chain(dj.fs, cl);
9D001AF0  0F4004EF   JAL remove_chain
9D001AF4  02602821   ADDU A1, S3, ZERO
2246:                				if (res == FR_OK) {
9D001AF8  1440003B   BNE V0, ZERO, 0x9D001BE8
9D001AFC  8FBF004C   LW RA, 76(SP)
2247:                					dj.fs->last_clust = cl - 1; /* Reuse the cluster hole */
9D001B00  8FA40010   LW A0, 16(SP)
9D001B04  2673FFFF   ADDIU S3, S3, -1
9D001B08  AC93000C   SW S3, 12(A0)
2248:                					res = move_window(dj.fs, dw);
9D001B0C  0F40007A   JAL move_window
9D001B10  02802821   ADDU A1, S4, ZERO
2249:                				}
2250:                			}
2251:                		}
2252:                	} else { /* Open an existing file */
2253:                		if (res == FR_OK) { /* Follow succeeded */
9D001B24  14400030   BNE V0, ZERO, 0x9D001BE8
9D001B28  8FBF004C   LW RA, 76(SP)
2254:                			if (dir[DIR_Attr] & AM_DIR) { /* It is a directory */
9D001B2C  9203000B   LBU V1, 11(S0)
9D001B30  30640010   ANDI A0, V1, 16
9D001B34  1480002B   BNE A0, ZERO, 0x9D001BE4
9D001B38  24020004   ADDIU V0, ZERO, 4
2255:                				res = FR_NO_FILE;
2256:                			} else {
2257:                				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
9D001B3C  32730002   ANDI S3, S3, 2
9D001B40  12600033   BEQ S3, ZERO, 0x9D001C10
9D001B44  32420008   ANDI V0, S2, 8
9D001B48  30630001   ANDI V1, V1, 1
9D001B4C  14600025   BNE V1, ZERO, 0x9D001BE4
9D001B50  24020007   ADDIU V0, ZERO, 7
2258:                					res = FR_DENIED;
2259:                			}
2260:                		}
2261:                	}
2262:                	if (res == FR_OK) {
9D001B14  10400012   BEQ V0, ZERO, 0x9D001B60
9D001B18  36520020   ORI S2, S2, 32
2263:                		if (mode & FA_CREATE_ALWAYS) /* Set file change flag if created or overwritten */
9D001B54  0B400704   J 0x9D001C10
9D001B58  32420008   ANDI V0, S2, 8
9D001C0C  32420008   ANDI V0, S2, 8
9D001C10  1040FFD4   BEQ V0, ZERO, 0x9D001B64
9D001C14  8FA30010   LW V1, 16(SP)
9D001C18  0B4006D7   J 0x9D001B5C
9D001C1C  00001021   ADDU V0, ZERO, ZERO
2264:                			mode |= FA__WRITTEN;
9D001B5C  36520020   ORI S2, S2, 32
2265:                		fp->dir_sect = dj.fs->winsect; /* Pointer to the directory entry */
9D001B60  8FA30010   LW V1, 16(SP)
9D001B64  8C640030   LW A0, 48(V1)
9D001B68  AE24001C   SW A0, 28(S1)
2266:                		fp->dir_ptr = dir;
9D001B6C  AE300020   SW S0, 32(S1)
2267:                #if _FS_SHARE
2268:                		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2269:                		if (!fp->lockid) res = FR_INT_ERR;
2270:                #endif
2271:                	}
2272:                
2273:                #else				/* R/O configuration */
2274:                	if (res == FR_OK) { /* Follow succeeded */
2275:                		if (!dir) { /* Current dir itself */
2276:                			res = FR_INVALID_NAME;
2277:                		} else {
2278:                			if (dir[DIR_Attr] & AM_DIR) /* It is a directory */
2279:                			res = FR_NO_FILE;
2280:                		}
2281:                	}
2282:                #endif
2283:                	FREE_BUF();
2284:                
2285:                	if (res == FR_OK) {
2286:                		fp->flag = mode; /* File access mode */
9D001B70  A2320006   SB S2, 6(S1)
2287:                		fp->sclust = LD_CLUST(dir); /* File start cluster */
9D001B74  92050015   LBU A1, 21(S0)
9D001B78  00052A00   SLL A1, A1, 8
9D001B7C  92060014   LBU A2, 20(S0)
9D001B80  00A62825   OR A1, A1, A2
9D001B84  00052C00   SLL A1, A1, 16
9D001B88  9204001B   LBU A0, 27(S0)
9D001B8C  00042200   SLL A0, A0, 8
9D001B90  9206001A   LBU A2, 26(S0)
9D001B94  00862025   OR A0, A0, A2
9D001B98  00A42025   OR A0, A1, A0
9D001B9C  AE240010   SW A0, 16(S1)
2288:                		fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
9D001BA0  9205001F   LBU A1, 31(S0)
9D001BA4  00052E00   SLL A1, A1, 24
9D001BA8  9204001E   LBU A0, 30(S0)
9D001BAC  00042400   SLL A0, A0, 16
9D001BB0  00A42025   OR A0, A1, A0
9D001BB4  9205001C   LBU A1, 28(S0)
9D001BB8  00852025   OR A0, A0, A1
9D001BBC  9205001D   LBU A1, 29(S0)
9D001BC0  00052A00   SLL A1, A1, 8
9D001BC4  00852025   OR A0, A0, A1
9D001BC8  AE24000C   SW A0, 12(S1)
2289:                		fp->fptr = 0; /* File pointer */
9D001BCC  AE200008   SW ZERO, 8(S1)
2290:                		fp->dsect = 0;
9D001BD0  AE200018   SW ZERO, 24(S1)
2291:                #if _USE_FASTSEEK
2292:                		fp->cltbl = 0; /* Normal seek mode */
9D001BD4  AE200024   SW ZERO, 36(S1)
2293:                #endif
2294:                		fp->fs = dj.fs;
9D001BD8  AE230000   SW V1, 0(S1)
2295:                		fp->id = dj.fs->id; /* Validate file object */
9D001BDC  94630006   LHU V1, 6(V1)
9D001BE0  A6230004   SH V1, 4(S1)
2296:                	}
2297:                
2298:                	LEAVE_FF(dj.fs, res);
2299:                }
9D001A40  0B4006FA   J 0x9D001BE8
9D001A44  8FBF004C   LW RA, 76(SP)
9D001B1C  0B4006FA   J 0x9D001BE8
9D001B20  8FBF004C   LW RA, 76(SP)
9D001BE4  8FBF004C   LW RA, 76(SP)
9D001BE8  8FB40048   LW S4, 72(SP)
9D001BEC  8FB30044   LW S3, 68(SP)
9D001BF0  8FB20040   LW S2, 64(SP)
9D001BF4  8FB1003C   LW S1, 60(SP)
9D001BF8  8FB00038   LW S0, 56(SP)
9D001BFC  03E00008   JR RA
9D001C00  27BD0050   ADDIU SP, SP, 80
2300:                
2301:                /*-----------------------------------------------------------------------*/
2302:                /* Read File                                                             */
2303:                /*-----------------------------------------------------------------------*/
2304:                
2305:                FRESULT f_read(FIL *fp, /* Pointer to the file object */
2306:                                void *buff, /* Pointer to data buffer */
2307:                                UINT btr, /* Number of bytes to read */
2308:                                UINT *br /* Pointer to number of bytes read */
2309:                                ) {
9D001C20  27BDFFC8   ADDIU SP, SP, -56
9D001C24  AFBF0034   SW RA, 52(SP)
9D001C28  AFBE0030   SW S8, 48(SP)
9D001C2C  AFB7002C   SW S7, 44(SP)
9D001C30  AFB60028   SW S6, 40(SP)
9D001C34  AFB50024   SW S5, 36(SP)
9D001C38  AFB40020   SW S4, 32(SP)
9D001C3C  AFB3001C   SW S3, 28(SP)
9D001C40  AFB20018   SW S2, 24(SP)
9D001C44  AFB10014   SW S1, 20(SP)
9D001C48  AFB00010   SW S0, 16(SP)
9D001C4C  00808021   ADDU S0, A0, ZERO
9D001C50  00A0A021   ADDU S4, A1, ZERO
9D001C54  00C08821   ADDU S1, A2, ZERO
9D001C58  00E09821   ADDU S3, A3, ZERO
2310:                	FRESULT res;
2311:                	DWORD clst, sect, remain;
2312:                	UINT rcnt, cc;
2313:                	PF_BYTE csect, *rbuff = buff;
2314:                
2315:                	*br = 0; /* Initialize byte counter */
9D001C5C  ACE00000   SW ZERO, 0(A3)
2316:                
2317:                	res = validate(fp->fs, fp->id); /* Check validity */
9D001C60  8C840000   LW A0, 0(A0)
9D001C64  0F40013B   JAL validate
9D001C68  96050004   LHU A1, 4(S0)
2318:                	if (res != FR_OK)
9D001C6C  1440008A   BNE V0, ZERO, 0x9D001E98
9D001C70  0040B821   ADDU S7, V0, ZERO
2319:                		LEAVE_FF(fp->fs, res);
2320:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D001C74  92020006   LBU V0, 6(S0)
9D001C78  7C021C20   SEB V1, V0
9D001C7C  04600085   BLTZ V1, 0x9D001E94
9D001C80  30420001   ANDI V0, V0, 1
2321:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2322:                	if (!(fp->flag & FA_READ)) /* Check access mode */
9D001C84  50400084   BEQL V0, ZERO, 0x9D001E98
9D001C88  24170007   ADDIU S7, ZERO, 7
9D001C98  0251102B   SLTU V0, S2, S1
9D001C9C  0222900A   MOVZ S2, S1, V0
2323:                		LEAVE_FF(fp->fs, FR_DENIED);
2324:                	remain = fp->fsize - fp->fptr;
9D001C8C  8E12000C   LW S2, 12(S0)
9D001C90  8E020008   LW V0, 8(S0)
9D001C94  02429023   SUBU S2, S2, V0
2325:                	if (btr > remain)
2326:                		btr = (UINT) remain; /* Truncate btr by remaining bytes */
2327:                
2328:                	for (;btr; /* Repeat until all data read */
9D001CA0  1240007E   BEQ S2, ZERO, 0x9D001E9C
9D001CA4  02E01021   ADDU V0, S7, ZERO
9D001E84  12400004   BEQ S2, ZERO, 0x9D001E98
9D001E88  AE620000   SW V0, 0(S3)
2329:                	rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
9D001E6C  8E020008   LW V0, 8(S0)
9D001E70  00511021   ADDU V0, V0, S1
9D001E74  AE020008   SW V0, 8(S0)
9D001E78  8E620000   LW V0, 0(S3)
9D001E7C  00511021   ADDU V0, V0, S1
9D001E80  02519023   SUBU S2, S2, S1
9D001E8C  0B40072A   J 0x9D001CA8
9D001E90  0291A021   ADDU S4, S4, S1
9D001E94  24170002   ADDIU S7, ZERO, 2
2330:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D001CA8  8E050008   LW A1, 8(S0)
9D001CAC  30A201FF   ANDI V0, A1, 511
9D001CB0  54400057   BNEL V0, ZERO, 0x9D001E10
9D001CB4  8E110008   LW S1, 8(S0)
2331:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D001CB8  8E040000   LW A0, 0(S0)
9D001CBC  00051242   SRL V0, A1, 9
9D001CC0  90950002   LBU S5, 2(A0)
9D001CC4  26B5FFFF   ADDIU S5, S5, -1
9D001CC8  0055A824   AND S5, V0, S5
9D001CCC  32B500FF   ANDI S5, S5, 255
2332:                			if (!csect) { /* On the cluster boundary? */
9D001CD0  56A0001F   BNEL S5, ZERO, 0x9D001D50
9D001CD4  8E160000   LW S6, 0(S0)
2333:                				if (fp->fptr == 0) { /* On the top of the file? */
9D001CD8  54A00003   BNEL A1, ZERO, 0x9D001CE8
9D001CDC  8E020024   LW V0, 36(S0)
2334:                					clst = fp->sclust; /* Follow from the origin */
9D001CE0  0B400742   J 0x9D001D08
9D001CE4  8E020010   LW V0, 16(S0)
2335:                				} else { /* Middle or end of the file */
2336:                #if _USE_FASTSEEK
2337:                					if (fp->cltbl)
9D001CE8  10400005   BEQ V0, ZERO, 0x9D001D00
9D001CEC  00000000   NOP
2338:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D001CF0  0F400013   JAL clmt_clust
9D001CF4  02002021   ADDU A0, S0, ZERO
2339:                					else
2340:                #endif
2341:                						clst = get_fat(fp->fs, fp->clust); /* Follow cluster chain on the FAT */
9D001D00  0F40015A   JAL get_fat
9D001D04  8E050014   LW A1, 20(S0)
2342:                				}
2343:                				if (clst < 2)
9D001CF8  0B400743   J 0x9D001D0C
9D001CFC  2C430002   SLTIU V1, V0, 2
9D001D08  2C430002   SLTIU V1, V0, 2
9D001D0C  10600007   BEQ V1, ZERO, 0x9D001D2C
9D001D10  2403FFFF   ADDIU V1, ZERO, -1
2344:                					ABORT(fp->fs, FR_INT_ERR);
9D001D14  92030006   LBU V1, 6(S0)
9D001D18  2402FF80   ADDIU V0, ZERO, -128
9D001D1C  00621025   OR V0, V1, V0
9D001D20  A2020006   SB V0, 6(S0)
9D001D24  0B4007A6   J 0x9D001E98
9D001D28  24170002   ADDIU S7, ZERO, 2
2345:                				if (clst == 0xFFFFFFFF)
9D001D2C  54430007   BNEL V0, V1, 0x9D001D4C
9D001D30  AE020014   SW V0, 20(S0)
2346:                					ABORT(fp->fs, FR_DISK_ERR);
9D001D34  92030006   LBU V1, 6(S0)
9D001D38  2402FF80   ADDIU V0, ZERO, -128
9D001D3C  00621025   OR V0, V1, V0
9D001D40  A2020006   SB V0, 6(S0)
9D001D44  0B4007A6   J 0x9D001E98
9D001D48  24170001   ADDIU S7, ZERO, 1
2347:                				fp->clust = clst; /* Update current cluster */
2348:                			}
2349:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D001D4C  8E160000   LW S6, 0(S0)
9D001D50  02C02021   ADDU A0, S6, ZERO
9D001D54  0F40014E   JAL clust2sect
9D001D58  8E050014   LW A1, 20(S0)
2350:                			if (!sect)
9D001D5C  14400007   BNE V0, ZERO, 0x9D001D7C
9D001D60  00128A42   SRL S1, S2, 9
2351:                				ABORT(fp->fs, FR_INT_ERR);
9D001D64  92030006   LBU V1, 6(S0)
9D001D68  2402FF80   ADDIU V0, ZERO, -128
9D001D6C  00621025   OR V0, V1, V0
9D001D70  A2020006   SB V0, 6(S0)
9D001D74  0B4007A6   J 0x9D001E98
9D001D78  24170002   ADDIU S7, ZERO, 2
2352:                			sect += csect;
2353:                			cc = btr / SS(fp->fs); /* When remaining bytes >= sector size, */
2354:                			if (cc) { /* Read maximum contiguous sectors directly */
9D001D7C  12200022   BEQ S1, ZERO, 0x9D001E08
9D001D80  0055F021   ADDU S8, V0, S5
2355:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D001D84  92C20002   LBU V0, 2(S6)
9D001D88  02351821   ADDU V1, S1, S5
9D001D8C  0043182B   SLTU V1, V0, V1
2356:                					cc = fp->fs->csize - csect;
9D001D90  0055A823   SUBU S5, V0, S5
9D001D94  02A3880B   MOVN S1, S5, V1
2357:                				if (disk_read(fp->fs->drv, rbuff, sect, (PF_BYTE) cc) != RES_OK)
9D001D98  92C40001   LBU A0, 1(S6)
9D001D9C  02802821   ADDU A1, S4, ZERO
9D001DA0  03C03021   ADDU A2, S8, ZERO
9D001DA4  0F4025A6   JAL disk_read
9D001DA8  322700FF   ANDI A3, S1, 255
9D001DAC  50400007   BEQL V0, ZERO, 0x9D001DCC
9D001DB0  8E050000   LW A1, 0(S0)
2358:                					ABORT(fp->fs, FR_DISK_ERR);
9D001DB4  92030006   LBU V1, 6(S0)
9D001DB8  2402FF80   ADDIU V0, ZERO, -128
9D001DBC  00621025   OR V0, V1, V0
9D001DC0  A2020006   SB V0, 6(S0)
9D001DC4  0B4007A6   J 0x9D001E98
9D001DC8  24170001   ADDIU S7, ZERO, 1
2359:                #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
2360:                #if _FS_TINY
2361:                				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
9D001DCC  90A20004   LBU V0, 4(A1)
9D001DD0  50400026   BEQL V0, ZERO, 0x9D001E6C
9D001DD4  00118A40   SLL S1, S1, 9
9D001DD8  8CA20030   LW V0, 48(A1)
9D001DDC  005EF023   SUBU S8, V0, S8
9D001DE0  03D1102B   SLTU V0, S8, S1
9D001DE4  50400021   BEQL V0, ZERO, 0x9D001E6C
9D001DE8  00118A40   SLL S1, S1, 9
2362:                				mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
9D001DEC  001EF240   SLL S8, S8, 9
9D001DF0  029E2021   ADDU A0, S4, S8
9D001DF4  24A50034   ADDIU A1, A1, 52
9D001DF8  0F400000   JAL mem_cpy
9D001DFC  24060200   ADDIU A2, ZERO, 512
2363:                #else
2364:                				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
2365:                					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf,
2366:                							SS(fp->fs));
2367:                #endif
2368:                #endif
2369:                				rcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2370:                				continue;
9D001E00  0B40079B   J 0x9D001E6C
9D001E04  00118A40   SLL S1, S1, 9
2371:                			}
2372:                #if !_FS_TINY
2373:                			if (fp->dsect != sect) { /* Load data sector if not in cache */
2374:                #if !_FS_READONLY
2375:                				if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2376:                					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2377:                							!= RES_OK)
2378:                						ABORT(fp->fs, FR_DISK_ERR);
2379:                					fp->flag &= ~FA__DIRTY;
2380:                				}
2381:                #endif
2382:                				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK) /* Fill sector cache */
2383:                					ABORT(fp->fs, FR_DISK_ERR);
2384:                			}
2385:                #endif
2386:                			fp->dsect = sect;
9D001E08  AE1E0018   SW S8, 24(S0)
2387:                		}
2388:                		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs)); /* Get partial sector data from sector buffer */
9D001E0C  8E110008   LW S1, 8(S0)
9D001E3C  24020200   ADDIU V0, ZERO, 512
9D001E40  00518823   SUBU S1, V0, S1
9D001E44  0232102B   SLTU V0, S1, S2
9D001E48  0242880A   MOVZ S1, S2, V0
2389:                		if (rcnt > btr)
2390:                			rcnt = btr;
2391:                #if _FS_TINY
2392:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D001E10  8E040000   LW A0, 0(S0)
9D001E14  0F40007A   JAL move_window
9D001E18  8E050018   LW A1, 24(S0)
9D001E1C  10400007   BEQ V0, ZERO, 0x9D001E3C
9D001E20  323101FF   ANDI S1, S1, 511
2393:                		ABORT(fp->fs, FR_DISK_ERR);
9D001E24  92030006   LBU V1, 6(S0)
9D001E28  2402FF80   ADDIU V0, ZERO, -128
9D001E2C  00621025   OR V0, V1, V0
9D001E30  A2020006   SB V0, 6(S0)
9D001E34  0B4007A6   J 0x9D001E98
9D001E38  24170001   ADDIU S7, ZERO, 1
2394:                		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
9D001E4C  8E050000   LW A1, 0(S0)
9D001E50  24A50034   ADDIU A1, A1, 52
9D001E54  8E020008   LW V0, 8(S0)
9D001E58  304201FF   ANDI V0, V0, 511
9D001E5C  02802021   ADDU A0, S4, ZERO
9D001E60  00A22821   ADDU A1, A1, V0
9D001E64  0F400000   JAL mem_cpy
9D001E68  02203021   ADDU A2, S1, ZERO
2395:                #else
2396:                		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
2397:                #endif
2398:                	}
2399:                
2400:                	LEAVE_FF(fp->fs, FR_OK);
2401:                }
9D001E98  02E01021   ADDU V0, S7, ZERO
9D001E9C  8FBF0034   LW RA, 52(SP)
9D001EA0  8FBE0030   LW S8, 48(SP)
9D001EA4  8FB7002C   LW S7, 44(SP)
9D001EA8  8FB60028   LW S6, 40(SP)
9D001EAC  8FB50024   LW S5, 36(SP)
9D001EB0  8FB40020   LW S4, 32(SP)
9D001EB4  8FB3001C   LW S3, 28(SP)
9D001EB8  8FB20018   LW S2, 24(SP)
9D001EBC  8FB10014   LW S1, 20(SP)
9D001EC0  8FB00010   LW S0, 16(SP)
9D001EC4  03E00008   JR RA
9D001EC8  27BD0038   ADDIU SP, SP, 56
2402:                
2403:                #if !_FS_READONLY
2404:                /*-----------------------------------------------------------------------*/
2405:                /* Write File                                                            */
2406:                /*-----------------------------------------------------------------------*/
2407:                
2408:                FRESULT f_write(FIL *fp, /* Pointer to the file object */
2409:                                const void *buff, /* Pointer to the data to be written */
2410:                                UINT btw, /* Number of bytes to write */
2411:                                UINT *bw /* Pointer to number of bytes written */
2412:                                ) {
9D001ECC  27BDFFC8   ADDIU SP, SP, -56
9D001ED0  AFBF0034   SW RA, 52(SP)
9D001ED4  AFBE0030   SW S8, 48(SP)
9D001ED8  AFB7002C   SW S7, 44(SP)
9D001EDC  AFB60028   SW S6, 40(SP)
9D001EE0  AFB50024   SW S5, 36(SP)
9D001EE4  AFB40020   SW S4, 32(SP)
9D001EE8  AFB3001C   SW S3, 28(SP)
9D001EEC  AFB20018   SW S2, 24(SP)
9D001EF0  AFB10014   SW S1, 20(SP)
9D001EF4  AFB00010   SW S0, 16(SP)
9D001EF8  00808021   ADDU S0, A0, ZERO
9D001EFC  00A0A021   ADDU S4, A1, ZERO
9D001F00  00C08821   ADDU S1, A2, ZERO
9D001F04  00E09821   ADDU S3, A3, ZERO
2413:                	FRESULT res;
2414:                	DWORD clst, sect;
2415:                	UINT wcnt, cc;
2416:                	const PF_BYTE *wbuff = buff;
2417:                	PF_BYTE csect;
2418:                
2419:                	*bw = 0; /* Initialize byte counter */
9D001F08  ACE00000   SW ZERO, 0(A3)
2420:                
2421:                	res = validate(fp->fs, fp->id); /* Check validity */
9D001F0C  8C840000   LW A0, 0(A0)
9D001F10  0F40013B   JAL validate
9D001F14  96050004   LHU A1, 4(S0)
2422:                	if (res != FR_OK)
9D001F18  144000BA   BNE V0, ZERO, 0x9D002204
9D001F1C  0040B821   ADDU S7, V0, ZERO
2423:                		LEAVE_FF(fp->fs, res);
2424:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D001F20  92020006   LBU V0, 6(S0)
9D001F24  7C021C20   SEB V1, V0
9D001F28  046000B5   BLTZ V1, 0x9D002200
9D001F2C  30420002   ANDI V0, V0, 2
2425:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2426:                	if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D001F30  504000B4   BEQL V0, ZERO, 0x9D002204
9D001F34  24170007   ADDIU S7, ZERO, 7
2427:                		LEAVE_FF(fp->fs, FR_DENIED);
2428:                	if ((DWORD) (fp->fsize + btw) < fp->fsize)
9D001F38  8E02000C   LW V0, 12(S0)
9D001F3C  02221821   ADDU V1, S1, V0
9D001F40  0062102B   SLTU V0, V1, V0
9D001F44  544000A6   BNEL V0, ZERO, 0x9D0021E0
9D001F48  8E020008   LW V0, 8(S0)
2429:                		btw = 0; /* File size cannot reach 4GB */
2430:                
2431:                	for (; btw; /* Repeat until all data written */
9D001F4C  522000A4   BEQL S1, ZERO, 0x9D0021E0
9D001F50  8E020008   LW V0, 8(S0)
9D0021CC  12200003   BEQ S1, ZERO, 0x9D0021DC
9D0021D0  AE620000   SW V0, 0(S3)
2432:                	wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
9D0021B4  8E020008   LW V0, 8(S0)
9D0021B8  00521021   ADDU V0, V0, S2
9D0021BC  AE020008   SW V0, 8(S0)
9D0021C0  8E620000   LW V0, 0(S3)
9D0021C4  00521021   ADDU V0, V0, S2
9D0021C8  02328823   SUBU S1, S1, S2
9D0021D4  0B4007D5   J 0x9D001F54
9D0021D8  0292A021   ADDU S4, S4, S2
2433:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D001F54  8E050008   LW A1, 8(S0)
9D001F58  30A201FF   ANDI V0, A1, 511
9D001F5C  5440007B   BNEL V0, ZERO, 0x9D00214C
9D001F60  8E120008   LW S2, 8(S0)
2434:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D001F64  8E040000   LW A0, 0(S0)
9D001F68  00051242   SRL V0, A1, 9
9D001F6C  90950002   LBU S5, 2(A0)
9D001F70  26B5FFFF   ADDIU S5, S5, -1
9D001F74  0055A824   AND S5, V0, S5
9D001F78  32B500FF   ANDI S5, S5, 255
2435:                			if (!csect) { /* On the cluster boundary? */
9D001F7C  56A00026   BNEL S5, ZERO, 0x9D002018
9D001F80  8C830030   LW V1, 48(A0)
2436:                				if (fp->fptr == 0) { /* On the top of the file? */
9D001F84  54A00008   BNEL A1, ZERO, 0x9D001FA8
9D001F88  8E020024   LW V0, 36(S0)
2437:                					clst = fp->sclust; /* Follow from the origin */
9D001F8C  8E020010   LW V0, 16(S0)
2438:                					if (clst == 0) /* When no cluster is allocated, */
9D001F90  1440000F   BNE V0, ZERO, 0x9D001FD0
9D001F94  24030001   ADDIU V1, ZERO, 1
2439:                						fp->sclust = clst = create_chain(fp->fs, 0); /* Create a new cluster chain */
9D001F98  0F400299   JAL create_chain
9D001F9C  00000000   NOP
9D001FA0  0B4007F2   J 0x9D001FC8
9D001FA4  AE020010   SW V0, 16(S0)
2440:                				} else { /* Middle or end of the file */
2441:                #if _USE_FASTSEEK
2442:                					if (fp->cltbl)
9D001FA8  10400005   BEQ V0, ZERO, 0x9D001FC0
9D001FAC  00000000   NOP
2443:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D001FB0  0F400013   JAL clmt_clust
9D001FB4  02002021   ADDU A0, S0, ZERO
9D001FB8  0B4007F2   J 0x9D001FC8
9D001FBC  00000000   NOP
2444:                					else
2445:                #endif
2446:                						clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
9D001FC0  0F400299   JAL create_chain
9D001FC4  8E050014   LW A1, 20(S0)
2447:                				}
2448:                				if (clst == 0)
9D001FC8  10400084   BEQ V0, ZERO, 0x9D0021DC
9D001FCC  24030001   ADDIU V1, ZERO, 1
2449:                					break; /* Could not allocate a new cluster (disk full) */
2450:                				if (clst == 1)
9D001FD0  14430007   BNE V0, V1, 0x9D001FF0
9D001FD4  2403FFFF   ADDIU V1, ZERO, -1
2451:                					ABORT(fp->fs, FR_INT_ERR);
9D001FD8  92030006   LBU V1, 6(S0)
9D001FDC  2402FF80   ADDIU V0, ZERO, -128
9D001FE0  00621025   OR V0, V1, V0
9D001FE4  A2020006   SB V0, 6(S0)
9D001FE8  0B400881   J 0x9D002204
9D001FEC  24170002   ADDIU S7, ZERO, 2
2452:                				if (clst == 0xFFFFFFFF)
9D001FF0  54430007   BNEL V0, V1, 0x9D002010
9D001FF4  AE020014   SW V0, 20(S0)
2453:                					ABORT(fp->fs, FR_DISK_ERR);
9D001FF8  92030006   LBU V1, 6(S0)
9D001FFC  2402FF80   ADDIU V0, ZERO, -128
9D002000  00621025   OR V0, V1, V0
9D002004  A2020006   SB V0, 6(S0)
9D002008  0B400881   J 0x9D002204
9D00200C  24170001   ADDIU S7, ZERO, 1
2454:                				fp->clust = clst; /* Update current cluster */
2455:                			}
2456:                #if _FS_TINY
2457:                			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0)) /* Write-back sector cache */
9D002010  8E040000   LW A0, 0(S0)
9D002014  8C830030   LW V1, 48(A0)
9D002018  8E020018   LW V0, 24(S0)
9D00201C  5462000B   BNEL V1, V0, 0x9D00204C
9D002020  8E160000   LW S6, 0(S0)
9D002024  0F40007A   JAL move_window
9D002028  00002821   ADDU A1, ZERO, ZERO
9D00202C  50400007   BEQL V0, ZERO, 0x9D00204C
9D002030  8E160000   LW S6, 0(S0)
2458:                			ABORT(fp->fs, FR_DISK_ERR);
9D002034  92030006   LBU V1, 6(S0)
9D002038  2402FF80   ADDIU V0, ZERO, -128
9D00203C  00621025   OR V0, V1, V0
9D002040  A2020006   SB V0, 6(S0)
9D002044  0B400881   J 0x9D002204
9D002048  24170001   ADDIU S7, ZERO, 1
2459:                #else
2460:                			if (fp->flag & FA__DIRTY) { /* Write-back sector cache */
2461:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2462:                					ABORT(fp->fs, FR_DISK_ERR);
2463:                				fp->flag &= ~FA__DIRTY;
2464:                			}
2465:                #endif
2466:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D00204C  02C02021   ADDU A0, S6, ZERO
9D002050  0F40014E   JAL clust2sect
9D002054  8E050014   LW A1, 20(S0)
2467:                			if (!sect)
9D002058  14400007   BNE V0, ZERO, 0x9D002078
9D00205C  00119242   SRL S2, S1, 9
2468:                				ABORT(fp->fs, FR_INT_ERR);
9D002060  92030006   LBU V1, 6(S0)
9D002064  2402FF80   ADDIU V0, ZERO, -128
9D002068  00621025   OR V0, V1, V0
9D00206C  A2020006   SB V0, 6(S0)
9D002070  0B400881   J 0x9D002204
9D002074  24170002   ADDIU S7, ZERO, 2
2469:                			sect += csect;
2470:                			cc = btw / SS(fp->fs); /* When remaining bytes >= sector size, */
2471:                			if (cc) { /* Write maximum contiguous sectors directly */
9D002078  12400021   BEQ S2, ZERO, 0x9D002100
9D00207C  0055F021   ADDU S8, V0, S5
2472:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D002080  92C20002   LBU V0, 2(S6)
9D002084  02551821   ADDU V1, S2, S5
9D002088  0043182B   SLTU V1, V0, V1
2473:                					cc = fp->fs->csize - csect;
9D00208C  0055A823   SUBU S5, V0, S5
9D002090  02A3900B   MOVN S2, S5, V1
2474:                				if (disk_write(fp->fs->drv, wbuff, sect, (PF_BYTE) cc)
9D002094  92C40001   LBU A0, 1(S6)
9D002098  02802821   ADDU A1, S4, ZERO
9D00209C  03C03021   ADDU A2, S8, ZERO
9D0020A0  0F4025DC   JAL disk_write
9D0020A4  324700FF   ANDI A3, S2, 255
9D0020A8  50400007   BEQL V0, ZERO, 0x9D0020C8
9D0020AC  8E040000   LW A0, 0(S0)
2475:                						!= RES_OK)
2476:                					ABORT(fp->fs, FR_DISK_ERR);
9D0020B0  92030006   LBU V1, 6(S0)
9D0020B4  2402FF80   ADDIU V0, ZERO, -128
9D0020B8  00621025   OR V0, V1, V0
9D0020BC  A2020006   SB V0, 6(S0)
9D0020C0  0B400881   J 0x9D002204
9D0020C4  24170001   ADDIU S7, ZERO, 1
2477:                #if _FS_TINY
2478:                				if (fp->fs->winsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
9D0020C8  8C820030   LW V0, 48(A0)
9D0020CC  005EF023   SUBU S8, V0, S8
9D0020D0  03D2102B   SLTU V0, S8, S2
9D0020D4  50400037   BEQL V0, ZERO, 0x9D0021B4
9D0020D8  00129240   SLL S2, S2, 9
2479:                					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
9D0020DC  001EF240   SLL S8, S8, 9
9D0020E0  24840034   ADDIU A0, A0, 52
9D0020E4  029E2821   ADDU A1, S4, S8
9D0020E8  0F400000   JAL mem_cpy
9D0020EC  24060200   ADDIU A2, ZERO, 512
2480:                					fp->fs->wflag = 0;
9D0020F0  8E020000   LW V0, 0(S0)
9D0020F4  A0400004   SB ZERO, 4(V0)
2481:                				}
2482:                #else
2483:                				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
2484:                					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)),
2485:                							SS(fp->fs));
2486:                					fp->flag &= ~FA__DIRTY;
2487:                				}
2488:                #endif
2489:                				wcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2490:                				continue;
9D0020F8  0B40086D   J 0x9D0021B4
9D0020FC  00129240   SLL S2, S2, 9
2491:                			}
2492:                #if _FS_TINY
2493:                			if (fp->fptr >= fp->fsize) { /* Avoid silly cache filling at growing edge */
9D002100  8E030008   LW V1, 8(S0)
9D002104  8E02000C   LW V0, 12(S0)
9D002108  0062102B   SLTU V0, V1, V0
9D00210C  5440000E   BNEL V0, ZERO, 0x9D002148
9D002110  AE1E0018   SW S8, 24(S0)
2494:                				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
9D002114  02C02021   ADDU A0, S6, ZERO
9D002118  0F40007A   JAL move_window
9D00211C  00002821   ADDU A1, ZERO, ZERO
9D002120  50400007   BEQL V0, ZERO, 0x9D002140
9D002124  8E020000   LW V0, 0(S0)
9D002128  92030006   LBU V1, 6(S0)
9D00212C  2402FF80   ADDIU V0, ZERO, -128
9D002130  00621025   OR V0, V1, V0
9D002134  A2020006   SB V0, 6(S0)
9D002138  0B400881   J 0x9D002204
9D00213C  24170001   ADDIU S7, ZERO, 1
2495:                				fp->fs->winsect = sect;
9D002140  AC5E0030   SW S8, 48(V0)
2496:                			}
2497:                #else
2498:                			if (fp->dsect != sect) { /* Fill sector cache with file data */
2499:                				if (fp->fptr < fp->fsize && disk_read(fp->fs->drv, fp->buf,
2500:                						sect, 1) != RES_OK)
2501:                					ABORT(fp->fs, FR_DISK_ERR);
2502:                			}
2503:                #endif
2504:                			fp->dsect = sect;
9D002144  AE1E0018   SW S8, 24(S0)
2505:                		}
2506:                		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
9D002148  8E120008   LW S2, 8(S0)
9D002178  24020200   ADDIU V0, ZERO, 512
9D00217C  00529023   SUBU S2, V0, S2
9D002180  0251102B   SLTU V0, S2, S1
9D002184  0222900A   MOVZ S2, S1, V0
2507:                		if (wcnt > btw)
2508:                			wcnt = btw;
2509:                #if _FS_TINY
2510:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D00214C  8E040000   LW A0, 0(S0)
9D002150  0F40007A   JAL move_window
9D002154  8E050018   LW A1, 24(S0)
9D002158  10400007   BEQ V0, ZERO, 0x9D002178
9D00215C  325201FF   ANDI S2, S2, 511
2511:                		ABORT(fp->fs, FR_DISK_ERR);
9D002160  92030006   LBU V1, 6(S0)
9D002164  2402FF80   ADDIU V0, ZERO, -128
9D002168  00621025   OR V0, V1, V0
9D00216C  A2020006   SB V0, 6(S0)
9D002170  0B400881   J 0x9D002204
9D002174  24170001   ADDIU S7, ZERO, 1
2512:                		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
9D002188  8E040000   LW A0, 0(S0)
9D00218C  24840034   ADDIU A0, A0, 52
9D002190  8E020008   LW V0, 8(S0)
9D002194  304201FF   ANDI V0, V0, 511
9D002198  00822021   ADDU A0, A0, V0
9D00219C  02802821   ADDU A1, S4, ZERO
9D0021A0  0F400000   JAL mem_cpy
9D0021A4  02403021   ADDU A2, S2, ZERO
2513:                		fp->fs->wflag = 1;
9D0021A8  8E020000   LW V0, 0(S0)
9D0021AC  24030001   ADDIU V1, ZERO, 1
9D0021B0  A0430004   SB V1, 4(V0)
2514:                #else
2515:                		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
2516:                		fp->flag |= FA__DIRTY;
2517:                #endif
2518:                	}
2519:                
2520:                	if (fp->fptr > fp->fsize)
9D0021DC  8E020008   LW V0, 8(S0)
9D0021E0  8E03000C   LW V1, 12(S0)
9D0021E4  0062182B   SLTU V1, V1, V0
9D0021E8  54600001   BNEL V1, ZERO, 0x9D0021F0
9D0021EC  AE02000C   SW V0, 12(S0)
2521:                		fp->fsize = fp->fptr; /* Update file size if needed */
2522:                	fp->flag |= FA__WRITTEN; /* Set file change flag */
9D0021F0  92020006   LBU V0, 6(S0)
9D0021F4  34420020   ORI V0, V0, 32
2523:                
2524:                	LEAVE_FF(fp->fs, FR_OK);
9D0021F8  0B400881   J 0x9D002204
9D0021FC  A2020006   SB V0, 6(S0)
9D002200  24170002   ADDIU S7, ZERO, 2
2525:                }
9D002204  02E01021   ADDU V0, S7, ZERO
9D002208  8FBF0034   LW RA, 52(SP)
9D00220C  8FBE0030   LW S8, 48(SP)
9D002210  8FB7002C   LW S7, 44(SP)
9D002214  8FB60028   LW S6, 40(SP)
9D002218  8FB50024   LW S5, 36(SP)
9D00221C  8FB40020   LW S4, 32(SP)
9D002220  8FB3001C   LW S3, 28(SP)
9D002224  8FB20018   LW S2, 24(SP)
9D002228  8FB10014   LW S1, 20(SP)
9D00222C  8FB00010   LW S0, 16(SP)
9D002230  03E00008   JR RA
9D002234  27BD0038   ADDIU SP, SP, 56
2526:                
2527:                /*-----------------------------------------------------------------------*/
2528:                /* Synchronize the File Object                                           */
2529:                /*-----------------------------------------------------------------------*/
2530:                
2531:                FRESULT f_sync(FIL *fp /* Pointer to the file object */
2532:                ) {
9D002238  27BDFFE0   ADDIU SP, SP, -32
9D00223C  AFBF001C   SW RA, 28(SP)
9D002240  AFB10018   SW S1, 24(SP)
9D002244  AFB00014   SW S0, 20(SP)
9D002248  00808021   ADDU S0, A0, ZERO
2533:                	FRESULT res;
2534:                	DWORD tim;
2535:                	PF_BYTE *dir;
2536:                
2537:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D00224C  8C840000   LW A0, 0(A0)
9D002250  0F40013B   JAL validate
9D002254  96050004   LHU A1, 4(S0)
2538:                	if (res == FR_OK) {
9D002258  14400032   BNE V0, ZERO, 0x9D002324
9D00225C  8FBF001C   LW RA, 28(SP)
2539:                		if (fp->flag & FA__WRITTEN) { /* Has the file been written? */
9D002260  92030006   LBU V1, 6(S0)
9D002264  30630020   ANDI V1, V1, 32
9D002268  1060002F   BEQ V1, ZERO, 0x9D002328
9D00226C  8FB10018   LW S1, 24(SP)
2540:                #if !_FS_TINY	/* Write-back dirty buffer */
2541:                			if (fp->flag & FA__DIRTY) {
2542:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2543:                					LEAVE_FF(fp->fs, FR_DISK_ERR);
2544:                				fp->flag &= ~FA__DIRTY;
2545:                			}
2546:                #endif
2547:                			/* Update the directory entry */
2548:                			res = move_window(fp->fs, fp->dir_sect);
9D002270  8E040000   LW A0, 0(S0)
9D002274  0F40007A   JAL move_window
9D002278  8E05001C   LW A1, 28(S0)
2549:                			if (res == FR_OK) {
9D00227C  14400029   BNE V0, ZERO, 0x9D002324
9D002280  8FBF001C   LW RA, 28(SP)
2550:                				dir = fp->dir_ptr;
9D002284  8E110020   LW S1, 32(S0)
2551:                				dir[DIR_Attr] |= AM_ARC; /* Set archive bit */
9D002288  9222000B   LBU V0, 11(S1)
9D00228C  34420020   ORI V0, V0, 32
9D002290  A222000B   SB V0, 11(S1)
2552:                				ST_DWORD(dir+DIR_FileSize, fp->fsize); /* Update file size */
9D002294  8E02000C   LW V0, 12(S0)
9D002298  A222001C   SB V0, 28(S1)
9D00229C  9602000C   LHU V0, 12(S0)
9D0022A0  00021202   SRL V0, V0, 8
9D0022A4  A222001D   SB V0, 29(S1)
9D0022A8  9602000E   LHU V0, 14(S0)
9D0022AC  A222001E   SB V0, 30(S1)
9D0022B0  9202000F   LBU V0, 15(S0)
9D0022B4  A222001F   SB V0, 31(S1)
2553:                				ST_CLUST(dir, fp->sclust); /* Update start cluster */
9D0022B8  8E020010   LW V0, 16(S0)
9D0022BC  A222001A   SB V0, 26(S1)
9D0022C0  96020010   LHU V0, 16(S0)
9D0022C4  00021202   SRL V0, V0, 8
9D0022C8  A222001B   SB V0, 27(S1)
9D0022CC  96020012   LHU V0, 18(S0)
9D0022D0  A2220014   SB V0, 20(S1)
9D0022D4  96020012   LHU V0, 18(S0)
9D0022D8  00021202   SRL V0, V0, 8
2554:                				tim = get_fattime(); /* Update updated time */
9D0022DC  0F402701   JAL get_fattime
9D0022E0  A2220015   SB V0, 21(S1)
2555:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D0022E4  A2220016   SB V0, 22(S1)
9D0022E8  7C433A00   EXT V1, V0, 8, 8
9D0022EC  A2230017   SB V1, 23(S1)
9D0022F0  00021C02   SRL V1, V0, 16
9D0022F4  A2230018   SB V1, 24(S1)
9D0022F8  00021602   SRL V0, V0, 24
9D0022FC  A2220019   SB V0, 25(S1)
2556:                				fp->flag &= ~FA__WRITTEN;
9D002300  92020006   LBU V0, 6(S0)
9D002304  304200DF   ANDI V0, V0, 223
9D002308  A2020006   SB V0, 6(S0)
2557:                				fp->fs->wflag = 1;
9D00230C  8E020000   LW V0, 0(S0)
9D002310  24030001   ADDIU V1, ZERO, 1
9D002314  A0430004   SB V1, 4(V0)
2558:                				res = sync(fp->fs);
9D002318  0F4000F1   JAL sync
9D00231C  8E040000   LW A0, 0(S0)
2559:                			}
2560:                		}
2561:                	}
2562:                
2563:                	LEAVE_FF(fp->fs, res);
2564:                }
9D002320  8FBF001C   LW RA, 28(SP)
9D002324  8FB10018   LW S1, 24(SP)
9D002328  8FB00014   LW S0, 20(SP)
9D00232C  03E00008   JR RA
9D002330  27BD0020   ADDIU SP, SP, 32
2565:                
2566:                #endif /* !_FS_READONLY */
2567:                
2568:                /*-----------------------------------------------------------------------*/
2569:                /* Close File                                                            */
2570:                /*-----------------------------------------------------------------------*/
2571:                
2572:                FRESULT f_close(FIL *fp /* Pointer to the file object to be closed */
2573:                ) {
9D002334  27BDFFE8   ADDIU SP, SP, -24
9D002338  AFBF0014   SW RA, 20(SP)
9D00233C  AFB00010   SW S0, 16(SP)
2574:                	FRESULT res;
2575:                
2576:                #if _FS_READONLY
2577:                	FATFS *fs = fp->fs;
2578:                	res = validate(fs, fp->id);
2579:                	if (res == FR_OK) fp->fs = 0; /* Discard file object */
2580:                	LEAVE_FF(fs, res);
2581:                
2582:                #else
2583:                	res = f_sync(fp); /* Flush cached data */
9D002340  0F40088E   JAL f_sync
9D002344  00808021   ADDU S0, A0, ZERO
2584:                #if _FS_SHARE
2585:                	if (res == FR_OK) { /* Decrement open counter */
2586:                #if _FS_REENTRANT
2587:                		res = validate(fp->fs, fp->id);
2588:                		if (res == FR_OK) {
2589:                			res = dec_lock(fp->lockid);
2590:                			unlock_fs(fp->fs, FR_OK);
2591:                		}
2592:                #else
2593:                		res = dec_lock(fp->lockid);
2594:                #endif
2595:                	}
2596:                #endif
2597:                	if (res == FR_OK)
9D002348  50400001   BEQL V0, ZERO, 0x9D002350
9D00234C  AE000000   SW ZERO, 0(S0)
2598:                		fp->fs = 0; /* Discard file object */
2599:                	return res;
2600:                #endif
2601:                }
9D002350  8FBF0014   LW RA, 20(SP)
9D002354  8FB00010   LW S0, 16(SP)
9D002358  03E00008   JR RA
9D00235C  27BD0018   ADDIU SP, SP, 24
2602:                
2603:                /*-----------------------------------------------------------------------*/
2604:                /* Current Drive/Directory Handlings                                     */
2605:                /*-----------------------------------------------------------------------*/
2606:                
2607:                #if _FS_RPATH >= 1
2608:                
2609:                FRESULT f_chdrive (
2610:                		PF_BYTE drv /* Drive number */
2611:                )
2612:                {
9D002360  308400FF   ANDI A0, A0, 255
2613:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
9D002364  14800003   BNE A0, ZERO, 0x9D002374
9D002368  2402000B   ADDIU V0, ZERO, 11
2614:                
2615:                	CurrVol = drv;
9D00236C  A3808058   SB ZERO, -32680(GP)
2616:                
2617:                	return FR_OK;
9D002370  00001021   ADDU V0, ZERO, ZERO
2618:                }
9D002374  03E00008   JR RA
9D002378  00000000   NOP
2619:                
2620:                FRESULT f_chdir (
2621:                		const TCHAR *path /* Pointer to the directory path */
2622:                )
2623:                {
9D00237C  27BDFFC0   ADDIU SP, SP, -64
9D002380  AFBF003C   SW RA, 60(SP)
9D002384  AFA40040   SW A0, 64(SP)
2624:                	FRESULT res;
2625:                	DIR dj;
2626:                	DEF_NAMEBUF;
2627:                
2628:                	res = chk_mounted(&path, &dj.fs, 0);
9D002388  27A40040   ADDIU A0, SP, 64
9D00238C  27A50010   ADDIU A1, SP, 16
9D002390  0F400529   JAL chk_mounted
9D002394  00003021   ADDU A2, ZERO, ZERO
2629:                	if (res == FR_OK) {
9D002398  14400022   BNE V0, ZERO, 0x9D002424
9D00239C  8FBF003C   LW RA, 60(SP)
2630:                		INIT_BUF(dj);
9D0023A0  27A2002C   ADDIU V0, SP, 44
9D0023A4  AFA20028   SW V0, 40(SP)
2631:                		res = follow_path(&dj, path); /* Follow the path */
9D0023A8  27A40010   ADDIU A0, SP, 16
9D0023AC  0F40037C   JAL follow_path
9D0023B0  8FA50040   LW A1, 64(SP)
2632:                		FREE_BUF();
2633:                		if (res == FR_OK) { /* Follow completed */
9D0023B4  14400018   BNE V0, ZERO, 0x9D002418
9D0023B8  38440004   XORI A0, V0, 4
2634:                			if (!dj.dir) {
9D0023BC  8FA30024   LW V1, 36(SP)
9D0023C0  54600005   BNEL V1, ZERO, 0x9D0023D8
9D0023C4  9064000B   LBU A0, 11(V1)
2635:                				dj.fs->cdir = dj.sclust; /* Start directory itself */
9D0023C8  8FA40018   LW A0, 24(SP)
9D0023CC  8FA30010   LW V1, 16(SP)
9D0023D0  0B400908   J 0x9D002420
9D0023D4  AC640018   SW A0, 24(V1)
2636:                			} else {
2637:                				if (dj.dir[DIR_Attr] & AM_DIR) /* Reached to the directory */
9D0023D8  30840010   ANDI A0, A0, 16
9D0023DC  50800010   BEQL A0, ZERO, 0x9D002420
9D0023E0  24020005   ADDIU V0, ZERO, 5
2638:                				dj.fs->cdir = LD_CLUST(dj.dir);
9D0023E4  90650015   LBU A1, 21(V1)
9D0023E8  00052A00   SLL A1, A1, 8
9D0023EC  90640014   LBU A0, 20(V1)
9D0023F0  00A42825   OR A1, A1, A0
9D0023F4  00052C00   SLL A1, A1, 16
9D0023F8  9064001B   LBU A0, 27(V1)
9D0023FC  00042200   SLL A0, A0, 8
9D002400  9063001A   LBU V1, 26(V1)
9D002404  00832025   OR A0, A0, V1
9D002408  00A42025   OR A0, A1, A0
9D00240C  8FA30010   LW V1, 16(SP)
9D002410  0B400908   J 0x9D002420
9D002414  AC640018   SW A0, 24(V1)
2639:                				else
2640:                				res = FR_NO_PATH; /* Reached but a file */
2641:                			}
2642:                		}
2643:                		if (res == FR_NO_FILE) res = FR_NO_PATH;
9D002418  24030005   ADDIU V1, ZERO, 5
9D00241C  0064100A   MOVZ V0, V1, A0
2644:                	}
2645:                
2646:                	LEAVE_FF(dj.fs, res);
2647:                }
9D002420  8FBF003C   LW RA, 60(SP)
9D002424  03E00008   JR RA
9D002428  27BD0040   ADDIU SP, SP, 64
2648:                
2649:                #if _FS_RPATH >= 2
2650:                FRESULT f_getcwd (
9D002498  27B00034   ADDIU S0, SP, 52
9D002584  27A3002C   ADDIU V1, SP, 44
9D002588  00641021   ADDU V0, V1, A0
9D0025B0  00641021   ADDU V0, V1, A0
9D0025B4  24420008   ADDIU V0, V0, 8
9D0025B8  02201821   ADDU V1, S1, ZERO
2651:                		TCHAR *path, /* Pointer to the directory path */
2652:                		UINT sz_path /* Size of path */
2653:                )
2654:                {
9D00242C  27BDFF88   ADDIU SP, SP, -120
9D002430  AFBF0074   SW RA, 116(SP)
9D002434  AFB70070   SW S7, 112(SP)
9D002438  AFB6006C   SW S6, 108(SP)
9D00243C  AFB50068   SW S5, 104(SP)
9D002440  AFB40064   SW S4, 100(SP)
9D002444  AFB30060   SW S3, 96(SP)
9D002448  AFB2005C   SW S2, 92(SP)
9D00244C  AFB10058   SW S1, 88(SP)
9D002450  AFB00054   SW S0, 84(SP)
9D002454  AFA40078   SW A0, 120(SP)
9D002458  00A0B821   ADDU S7, A1, ZERO
2655:                	FRESULT res;
2656:                	DIR dj;
2657:                	UINT i, n;
2658:                	DWORD ccl;
2659:                	TCHAR *tp;
2660:                	FILINFO fno;
2661:                	DEF_NAMEBUF;
2662:                
2663:                	*path = 0;
9D00245C  A0800000   SB ZERO, 0(A0)
2664:                	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0); /* Get current volume */
9D002460  27A40078   ADDIU A0, SP, 120
9D002464  27A50010   ADDIU A1, SP, 16
9D002468  0F400529   JAL chk_mounted
9D00246C  00003021   ADDU A2, ZERO, ZERO
2665:                	if (res == FR_OK) {
9D002470  14400075   BNE V0, ZERO, 0x9D002648
9D002474  0040B021   ADDU S6, V0, ZERO
2666:                		INIT_BUF(dj);
9D002478  27A20044   ADDIU V0, SP, 68
9D00247C  AFA20028   SW V0, 40(SP)
2667:                		i = sz_path; /* Bottom of buffer (dir stack base) */
9D002490  02E08821   ADDU S1, S7, ZERO
2668:                		dj.sclust = dj.fs->cdir; /* Start to follow upper dir from current dir */
9D002480  8FA20010   LW V0, 16(SP)
9D002484  8C520018   LW S2, 24(V0)
2669:                		while ((ccl = dj.sclust) != 0) { /* Repeat while current dir is a sub-dir */
9D002488  12400084   BEQ S2, ZERO, 0x9D00269C
9D00248C  AFB20018   SW S2, 24(SP)
9D0025EC  8FB20018   LW S2, 24(SP)
9D0025F0  1640FFAC   BNE S2, ZERO, 0x9D0024A4
9D0025F4  27A40010   ADDIU A0, SP, 16
2670:                			res = dir_sdi(&dj, 1); /* Get parent dir */
9D0024A0  27A40010   ADDIU A0, SP, 16
9D0024A4  0F4001BB   JAL dir_sdi
9D0024A8  24050001   ADDIU A1, ZERO, 1
2671:                			if (res != FR_OK) break;
9D0024AC  14400055   BNE V0, ZERO, 0x9D002604
9D0024B0  00409821   ADDU S3, V0, ZERO
2672:                			res = dir_read(&dj);
9D0024B4  0F4004CA   JAL dir_read
9D0024B8  27A40010   ADDIU A0, SP, 16
2673:                			if (res != FR_OK) break;
9D0024BC  14400051   BNE V0, ZERO, 0x9D002604
9D0024C0  00409821   ADDU S3, V0, ZERO
2674:                			dj.sclust = LD_CLUST(dj.dir); /* Goto parent dir */
9D0024C4  8FA20024   LW V0, 36(SP)
9D0024C8  90430015   LBU V1, 21(V0)
9D0024CC  00031A00   SLL V1, V1, 8
9D0024D0  90440014   LBU A0, 20(V0)
9D0024D4  00641825   OR V1, V1, A0
9D0024D8  00031C00   SLL V1, V1, 16
9D0024DC  9045001B   LBU A1, 27(V0)
9D0024E0  00052A00   SLL A1, A1, 8
9D0024E4  9044001A   LBU A0, 26(V0)
9D0024E8  00A41025   OR V0, A1, A0
9D0024EC  00621025   OR V0, V1, V0
9D0024F0  AFA20018   SW V0, 24(SP)
2675:                			res = dir_sdi(&dj, 0);
9D0024F4  27A40010   ADDIU A0, SP, 16
9D0024F8  0F4001BB   JAL dir_sdi
9D0024FC  00002821   ADDU A1, ZERO, ZERO
2676:                			if (res != FR_OK) break;
9D002500  14400040   BNE V0, ZERO, 0x9D002604
9D002504  00409821   ADDU S3, V0, ZERO
2677:                			do { /* Find the entry links to the child dir */
2678:                				res = dir_read(&dj);
9D002508  0F4004CA   JAL dir_read
9D00250C  27A40010   ADDIU A0, SP, 16
2679:                				if (res != FR_OK) break;
9D002510  14400012   BNE V0, ZERO, 0x9D00255C
9D002514  00000000   NOP
2680:                				if (ccl == LD_CLUST(dj.dir)) break; /* Found the entry */
9D002518  8FA20024   LW V0, 36(SP)
9D00251C  90430015   LBU V1, 21(V0)
9D002520  00031A00   SLL V1, V1, 8
9D002524  90440014   LBU A0, 20(V0)
9D002528  00641825   OR V1, V1, A0
9D00252C  00031C00   SLL V1, V1, 16
9D002530  9045001B   LBU A1, 27(V0)
9D002534  00052A00   SLL A1, A1, 8
9D002538  9044001A   LBU A0, 26(V0)
9D00253C  00A41025   OR V0, A1, A0
9D002540  00621025   OR V0, V1, V0
9D002544  10520009   BEQ V0, S2, 0x9D00256C
9D002548  27A40010   ADDIU A0, SP, 16
2681:                				res = dir_next(&dj, 0);
9D00254C  0F4002FA   JAL dir_next
9D002550  00002821   ADDU A1, ZERO, ZERO
2682:                			}while (res == FR_OK);
9D002554  1040FFEC   BEQ V0, ZERO, 0x9D002508
9D002558  00000000   NOP
2683:                			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
9D002494  24150004   ADDIU S5, ZERO, 4
9D00255C  50550029   BEQL V0, S5, 0x9D002604
9D002560  24130002   ADDIU S3, ZERO, 2
2684:                			if (res != FR_OK) break;
9D002564  14400026   BNE V0, ZERO, 0x9D002600
9D002568  27A40010   ADDIU A0, SP, 16
2685:                #if _USE_LFN
2686:                			fno.lfname = path;
2687:                			fno.lfsize = i;
2688:                #endif
2689:                			get_fileinfo(&dj, &fno); /* Get the dir name and push it to the buffer */
9D00256C  0F400032   JAL get_fileinfo
9D002570  27A5002C   ADDIU A1, SP, 44
2690:                			tp = fno.fname;
2691:                			if (_USE_LFN && *path) tp = path;
2692:                			for (n = 0; tp[n]; n++);
9D002574  83A20035   LB V0, 53(SP)
9D002578  10400007   BEQ V0, ZERO, 0x9D002598
9D00257C  00002021   ADDU A0, ZERO, ZERO
9D002580  24840001   ADDIU A0, A0, 1
9D00258C  80420009   LB V0, 9(V0)
9D002590  5440FFFD   BNEL V0, ZERO, 0x9D002588
9D002594  24840001   ADDIU A0, A0, 1
2693:                			if (i < n + 3) {
9D002598  24820003   ADDIU V0, A0, 3
9D00259C  0222102B   SLTU V0, S1, V0
9D0025A0  54400018   BNEL V0, ZERO, 0x9D002604
9D0025A4  24130011   ADDIU S3, ZERO, 17
2694:                				res = FR_NOT_ENOUGH_CORE; break;
2695:                			}
2696:                			while (n) path[--i] = tp[--n];
9D0025A8  1080000C   BEQ A0, ZERO, 0x9D0025DC
9D0025AC  27A3002C   ADDIU V1, SP, 44
9D0025BC  2463FFFF   ADDIU V1, V1, -1
9D0025C0  8FA50078   LW A1, 120(SP)
9D0025C4  00A32821   ADDU A1, A1, V1
9D0025C8  90460000   LBU A2, 0(V0)
9D0025CC  2442FFFF   ADDIU V0, V0, -1
9D0025D0  1450FFFA   BNE V0, S0, 0x9D0025BC
9D0025D4  A0A60000   SB A2, 0(A1)
9D0025D8  02248823   SUBU S1, S1, A0
2697:                			path[--i] = '/';
9D00249C  2414002F   ADDIU S4, ZERO, 47
9D0025DC  2631FFFF   ADDIU S1, S1, -1
9D0025E0  8FA20078   LW V0, 120(SP)
9D0025E4  00511021   ADDU V0, V0, S1
9D0025E8  A0540000   SB S4, 0(V0)
2698:                		}
2699:                		tp = path;
9D0025F8  0B40099E   J 0x9D002678
9D0025FC  8FA20078   LW V0, 120(SP)
9D002600  00409821   ADDU S3, V0, ZERO
9D002604  8FA20078   LW V0, 120(SP)
9D002608  0B400991   J 0x9D002644
9D00260C  0260B021   ADDU S6, S3, ZERO
9D00269C  8FA20078   LW V0, 120(SP)
2700:                		if (res == FR_OK) {
2701:                			*tp++ = '0' + CurrVol; /* Put drive number */
9D002678  93838058   LBU V1, -32680(GP)
9D00267C  24630030   ADDIU V1, V1, 48
9D002680  A0430000   SB V1, 0(V0)
9D0026A0  93838058   LBU V1, -32680(GP)
9D0026A4  24630030   ADDIU V1, V1, 48
9D0026A8  A0430000   SB V1, 0(V0)
2702:                			*tp++ = ':';
9D002684  2403003A   ADDIU V1, ZERO, 58
9D002688  A0430001   SB V1, 1(V0)
9D0026AC  2403003A   ADDIU V1, ZERO, 58
9D0026B0  A0430001   SB V1, 1(V0)
9D0026B4  0B400984   J 0x9D002610
9D0026B8  24420002   ADDIU V0, V0, 2
2703:                			if (i == sz_path) { /* Root-dir */
9D00268C  1637FFE4   BNE S1, S7, 0x9D002620
9D002690  24420002   ADDIU V0, V0, 2
2704:                				*tp++ = '/';
9D002610  2403002F   ADDIU V1, ZERO, 47
9D002614  A0430000   SB V1, 0(V0)
9D002618  0B400991   J 0x9D002644
9D00261C  24420001   ADDIU V0, V0, 1
9D002694  0B400985   J 0x9D002614
9D002698  2403002F   ADDIU V1, ZERO, 47
2705:                			} else { /* Sub-dir */
2706:                				do /* Add stacked path str */
2707:                				*tp++ = path[i++];
9D002620  8FA30078   LW V1, 120(SP)
9D002624  00711821   ADDU V1, V1, S1
9D002628  90630000   LBU V1, 0(V1)
9D00262C  A0430000   SB V1, 0(V0)
9D002630  26310001   ADDIU S1, S1, 1
2708:                				while (i < sz_path);
9D002634  0237182B   SLTU V1, S1, S7
9D002638  1460FFF9   BNE V1, ZERO, 0x9D002620
9D00263C  24420001   ADDIU V0, V0, 1
9D002640  0260B021   ADDU S6, S3, ZERO
2709:                			}
2710:                		}
2711:                		*tp = 0;
9D002644  A0400000   SB ZERO, 0(V0)
2712:                		FREE_BUF();
2713:                	}
2714:                
2715:                	LEAVE_FF(dj.fs, res);
2716:                }
9D002648  02C01021   ADDU V0, S6, ZERO
9D00264C  8FBF0074   LW RA, 116(SP)
9D002650  8FB70070   LW S7, 112(SP)
9D002654  8FB6006C   LW S6, 108(SP)
9D002658  8FB50068   LW S5, 104(SP)
9D00265C  8FB40064   LW S4, 100(SP)
9D002660  8FB30060   LW S3, 96(SP)
9D002664  8FB2005C   LW S2, 92(SP)
9D002668  8FB10058   LW S1, 88(SP)
9D00266C  8FB00054   LW S0, 84(SP)
9D002670  03E00008   JR RA
9D002674  27BD0078   ADDIU SP, SP, 120
2717:                #endif /* _FS_RPATH >= 2 */
2718:                #endif /* _FS_RPATH >= 1 */
2719:                
2720:                #if _FS_MINIMIZE <= 2
2721:                /*-----------------------------------------------------------------------*/
2722:                /* Seek File R/W Pointer                                                 */
2723:                /*-----------------------------------------------------------------------*/
2724:                
2725:                FRESULT f_lseek(FIL *fp, /* Pointer to the file object */
9D002958  02539023   SUBU S2, S2, S3
9D00295C  2414FFFF   ADDIU S4, ZERO, -1
2726:                                DWORD ofs /* File pointer from top of file */
2727:                                ) {
9D0026BC  27BDFFC8   ADDIU SP, SP, -56
9D0026C0  AFBF0034   SW RA, 52(SP)
9D0026C4  AFBE0030   SW S8, 48(SP)
9D0026C8  AFB7002C   SW S7, 44(SP)
9D0026CC  AFB60028   SW S6, 40(SP)
9D0026D0  AFB50024   SW S5, 36(SP)
9D0026D4  AFB40020   SW S4, 32(SP)
9D0026D8  AFB3001C   SW S3, 28(SP)
9D0026DC  AFB20018   SW S2, 24(SP)
9D0026E0  AFB10014   SW S1, 20(SP)
9D0026E4  AFB00010   SW S0, 16(SP)
9D0026E8  00808021   ADDU S0, A0, ZERO
9D0026EC  00A09021   ADDU S2, A1, ZERO
2728:                	FRESULT res;
2729:                
2730:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D0026F0  8C840000   LW A0, 0(A0)
9D0026F4  0F40013B   JAL validate
9D0026F8  96050004   LHU A1, 4(S0)
2731:                	if (res != FR_OK)
9D0026FC  144000E5   BNE V0, ZERO, 0x9D002A94
9D002700  00408821   ADDU S1, V0, ZERO
2732:                		LEAVE_FF(fp->fs, res);
2733:                	if (fp->flag & FA__ERROR) /* Check abort flag */
9D002704  92130006   LBU S3, 6(S0)
9D002708  7C131420   SEB V0, S3
9D00270C  044200E1   BLTZL V0, 0x9D002A94
9D002710  24110002   ADDIU S1, ZERO, 2
2734:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2735:                
2736:                #if _USE_FASTSEEK
2737:                	if (fp->cltbl) { /* Fast seek */
9D002714  8E170024   LW S7, 36(S0)
9D002718  12E00055   BEQ S7, ZERO, 0x9D002870
9D00271C  2402FFFF   ADDIU V0, ZERO, -1
2738:                		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
2739:                
2740:                		if (ofs == CREATE_LINKMAP) { /* Create CLMT */
9D002720  56420034   BNEL S2, V0, 0x9D0027F4
9D002724  8E02000C   LW V0, 12(S0)
2741:                			tbl = fp->cltbl;
2742:                			tlen = *tbl++;
9D002728  8EFE0000   LW S8, 0(S7)
9D00272C  26F70004   ADDIU S7, S7, 4
2743:                			ulen = 2; /* Given table size and required table size */
9D002734  24150002   ADDIU S5, ZERO, 2
2744:                			cl = fp->sclust; /* Top of the chain */
9D002730  8E160010   LW S6, 16(S0)
2745:                			if (cl) {
9D002738  16C00003   BNE S6, ZERO, 0x9D002748
9D00273C  2414FFFF   ADDIU S4, ZERO, -1
2746:                				do {
2747:                					/* Get a fragment */
2748:                					tcl = cl;
2749:                					ncl = 0;
9D00274C  00009821   ADDU S3, ZERO, ZERO
2750:                					ulen += 2; /* Top, length and used items */
9D0027A8  26B50002   ADDIU S5, S5, 2
2751:                					do {
2752:                						pcl = cl;
2753:                						ncl++;
2754:                						cl = get_fat(fp->fs, cl);
9D002748  02C09021   ADDU S2, S6, ZERO
9D002750  8E040000   LW A0, 0(S0)
9D002754  0F40015A   JAL get_fat
9D002758  02402821   ADDU A1, S2, ZERO
2755:                						if (cl <= 1)
9D00275C  2C430002   SLTIU V1, V0, 2
9D002760  10600007   BEQ V1, ZERO, 0x9D002780
9D002764  00000000   NOP
2756:                							ABORT(fp->fs, FR_INT_ERR);
9D002768  92030006   LBU V1, 6(S0)
9D00276C  2402FF80   ADDIU V0, ZERO, -128
9D002770  00621025   OR V0, V1, V0
9D002774  A2020006   SB V0, 6(S0)
9D002778  0B400AA5   J 0x9D002A94
9D00277C  24110002   ADDIU S1, ZERO, 2
2757:                						if (cl == 0xFFFFFFFF)
9D002780  14540007   BNE V0, S4, 0x9D0027A0
9D002784  26520001   ADDIU S2, S2, 1
2758:                							ABORT(fp->fs, FR_DISK_ERR);
9D002788  92030006   LBU V1, 6(S0)
9D00278C  2402FF80   ADDIU V0, ZERO, -128
9D002790  00621025   OR V0, V1, V0
9D002794  A2020006   SB V0, 6(S0)
9D002798  0B400AA5   J 0x9D002A94
9D00279C  24110001   ADDIU S1, ZERO, 1
2759:                					} while (cl == pcl + 1);
9D0027A0  1242FFEB   BEQ S2, V0, 0x9D002750
9D0027A4  26730001   ADDIU S3, S3, 1
2760:                					if (ulen <= tlen) { /* Store the length and top of the fragment */
9D0027AC  03D5182B   SLTU V1, S8, S5
9D0027B0  54600005   BNEL V1, ZERO, 0x9D0027C8
9D0027B4  8E030000   LW V1, 0(S0)
2761:                						*tbl++ = ncl;
9D0027B8  AEF30000   SW S3, 0(S7)
2762:                						*tbl++ = tcl;
9D0027BC  AEF60004   SW S6, 4(S7)
9D0027C0  26F70008   ADDIU S7, S7, 8
2763:                					}
2764:                				} while (cl < fp->fs->n_fatent); /* Repeat until end of chain */
9D0027C4  8E030000   LW V1, 0(S0)
9D0027C8  8C63001C   LW V1, 28(V1)
9D0027CC  0043182B   SLTU V1, V0, V1
9D0027D0  1460FFDD   BNE V1, ZERO, 0x9D002748
9D0027D4  0040B021   ADDU S6, V0, ZERO
2765:                			}
2766:                			*fp->cltbl = ulen; /* Number of items used */
9D002740  0B4009F7   J 0x9D0027DC
9D002744  8E020024   LW V0, 36(S0)
9D0027D8  8E020024   LW V0, 36(S0)
9D0027DC  AC550000   SW S5, 0(V0)
2767:                			if (ulen <= tlen)
9D0027E0  03D5A82B   SLTU S5, S8, S5
9D0027E4  56A000AB   BNEL S5, ZERO, 0x9D002A94
9D0027E8  24110011   ADDIU S1, ZERO, 17
2768:                				*tbl = 0; /* Terminate table */
9D0027EC  0B400AA5   J 0x9D002A94
9D0027F0  AEE00000   SW ZERO, 0(S7)
9D0027F4  0052182B   SLTU V1, V0, S2
9D0027F8  0043900B   MOVN S2, V0, V1
2769:                			else
2770:                				res = FR_NOT_ENOUGH_CORE; /* Given table size is smaller than required */
2771:                
2772:                		} else { /* Fast seek */
2773:                			if (ofs > fp->fsize) /* Clip offset at the file size */
2774:                				ofs = fp->fsize;
2775:                			fp->fptr = ofs; /* Set file pointer */
2776:                			if (ofs) {
9D0027FC  124000A5   BEQ S2, ZERO, 0x9D002A94
9D002800  AE120008   SW S2, 8(S0)
2777:                				fp->clust = clmt_clust(fp, ofs - 1);
9D002804  2655FFFF   ADDIU S5, S2, -1
9D002808  02002021   ADDU A0, S0, ZERO
9D00280C  0F400013   JAL clmt_clust
9D002810  02A02821   ADDU A1, S5, ZERO
9D002814  AE020014   SW V0, 20(S0)
2778:                				dsc = clust2sect(fp->fs, fp->clust);
9D002818  8E140000   LW S4, 0(S0)
9D00281C  02802021   ADDU A0, S4, ZERO
9D002820  0F40014E   JAL clust2sect
9D002824  00402821   ADDU A1, V0, ZERO
2779:                				if (!dsc)
9D002828  14400006   BNE V0, ZERO, 0x9D002844
9D00282C  325201FF   ANDI S2, S2, 511
2780:                					ABORT(fp->fs, FR_INT_ERR);
9D002830  2402FF80   ADDIU V0, ZERO, -128
9D002834  02629825   OR S3, S3, V0
9D002838  A2130006   SB S3, 6(S0)
9D00283C  0B400AA5   J 0x9D002A94
9D002840  24110002   ADDIU S1, ZERO, 2
2781:                				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
9D00284C  0015AA42   SRL S5, S5, 9
9D002850  2463FFFF   ADDIU V1, V1, -1
9D002854  02A31824   AND V1, S5, V1
9D002858  00431021   ADDU V0, V0, V1
2782:                				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) { /* Refill sector cache if needed */
9D002844  12400093   BEQ S2, ZERO, 0x9D002A94
9D002848  92830002   LBU V1, 2(S4)
9D00285C  8E030018   LW V1, 24(S0)
9D002860  5462008C   BNEL V1, V0, 0x9D002A94
9D002864  AE020018   SW V0, 24(S0)
2783:                #if !_FS_TINY
2784:                #if !_FS_READONLY
2785:                					if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2786:                						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2787:                								!= RES_OK)
2788:                							ABORT(fp->fs, FR_DISK_ERR);
2789:                						fp->flag &= ~FA__DIRTY;
2790:                					}
2791:                #endif
2792:                					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK) /* Load current sector */
2793:                						ABORT(fp->fs, FR_DISK_ERR);
2794:                #endif
2795:                					fp->dsect = dsc;
2796:                				}
2797:                			}
2798:                		}
2799:                	} else
2800:                #endif
2801:                
2802:                	/* Normal Seek */
2803:                	{
2804:                		DWORD clst, bcs, nsect, ifptr;
2805:                
2806:                		if (ofs > fp->fsize /* In read-only mode, clip offset with the file size */
9D002870  8E02000C   LW V0, 12(S0)
9D002874  0052182B   SLTU V1, V0, S2
9D002878  50600004   BEQL V1, ZERO, 0x9D00288C
9D00287C  8E020008   LW V0, 8(S0)
2807:                #if !_FS_READONLY
2808:                				&& !(fp->flag & FA_WRITE)
9D002880  32730002   ANDI S3, S3, 2
2809:                #endif
2810:                		)
2811:                			ofs = fp->fsize;
9D002884  0053900A   MOVZ S2, V0, S3
2812:                
2813:                		ifptr = fp->fptr;
9D002888  8E020008   LW V0, 8(S0)
2814:                		fp->fptr = nsect = 0;
2815:                		if (ofs) {
9D00288C  12400081   BEQ S2, ZERO, 0x9D002A94
9D002890  AE000008   SW ZERO, 8(S0)
2816:                			bcs = (DWORD) fp->fs->csize * SS(fp->fs); /* Cluster size (byte) */
9D002894  8E040000   LW A0, 0(S0)
9D002898  90930002   LBU S3, 2(A0)
2817:                			if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
9D00289C  10400012   BEQ V0, ZERO, 0x9D0028E8
9D0028A0  00139A40   SLL S3, S3, 9
9D0028A4  2442FFFF   ADDIU V0, V0, -1
9D0028A8  2643FFFF   ADDIU V1, S2, -1
9D0028AC  0073001B   DIVU V1, S3
9D0028B0  026001F4   TEQ S3, ZERO
9D0028B4  00001812   MFLO V1, 0
9D0028B8  0053001B   DIVU V0, S3
9D0028BC  026001F4   TEQ S3, ZERO
9D0028C0  00002812   MFLO A1, 0
9D0028C4  0065182B   SLTU V1, V1, A1
9D0028C8  54600008   BNEL V1, ZERO, 0x9D0028EC
9D0028CC  8E020010   LW V0, 16(S0)
2818:                				fp->fptr = (ifptr - 1) & ~(bcs - 1); /* start from the current cluster */
9D0028D0  00131823   SUBU V1, ZERO, S3
9D0028D4  00621024   AND V0, V1, V0
9D0028D8  AE020008   SW V0, 8(S0)
2819:                				ofs -= fp->fptr;
9D0028DC  02429023   SUBU S2, S2, V0
2820:                				clst = fp->clust;
9D0028E0  0B400A51   J 0x9D002944
9D0028E4  8E020014   LW V0, 20(S0)
2821:                			} else { /* When seek to back cluster, */
2822:                				clst = fp->sclust; /* start from the first cluster */
9D0028E8  8E020010   LW V0, 16(S0)
2823:                #if !_FS_READONLY
2824:                				if (clst == 0) { /* If no cluster chain, create a new chain */
9D0028EC  54400015   BNEL V0, ZERO, 0x9D002944
9D0028F0  AE020014   SW V0, 20(S0)
2825:                					clst = create_chain(fp->fs, 0);
9D0028F4  0F400299   JAL create_chain
9D0028F8  00002821   ADDU A1, ZERO, ZERO
2826:                					if (clst == 1)
9D0028FC  24030001   ADDIU V1, ZERO, 1
9D002900  14430007   BNE V0, V1, 0x9D002920
9D002904  2403FFFF   ADDIU V1, ZERO, -1
2827:                						ABORT(fp->fs, FR_INT_ERR);
9D002908  92030006   LBU V1, 6(S0)
9D00290C  2402FF80   ADDIU V0, ZERO, -128
9D002910  00621025   OR V0, V1, V0
9D002914  A2020006   SB V0, 6(S0)
9D002918  0B400AA5   J 0x9D002A94
9D00291C  24110002   ADDIU S1, ZERO, 2
2828:                					if (clst == 0xFFFFFFFF)
9D002920  54430007   BNEL V0, V1, 0x9D002940
9D002924  AE020010   SW V0, 16(S0)
2829:                						ABORT(fp->fs, FR_DISK_ERR);
9D002928  92030006   LBU V1, 6(S0)
9D00292C  2402FF80   ADDIU V0, ZERO, -128
9D002930  00621025   OR V0, V1, V0
9D002934  A2020006   SB V0, 6(S0)
9D002938  0B400AA5   J 0x9D002A94
9D00293C  24110001   ADDIU S1, ZERO, 1
2830:                					fp->sclust = clst;
2831:                				}
2832:                #endif
2833:                				fp->clust = clst;
9D002940  AE020014   SW V0, 20(S0)
2834:                			}
2835:                			if (clst != 0) {
9D002944  10400043   BEQ V0, ZERO, 0x9D002A54
9D002948  00001821   ADDU V1, ZERO, ZERO
2836:                				while (ofs > bcs) { /* Cluster following loop */
9D00294C  0272182B   SLTU V1, S3, S2
9D002950  1060002E   BEQ V1, ZERO, 0x9D002A0C
9D002954  0013A823   SUBU S5, ZERO, S3
9D0029F4  00732021   ADDU A0, V1, S3
9D0029F8  0264202B   SLTU A0, S3, A0
9D0029FC  5480FFD8   BNEL A0, ZERO, 0x9D002960
9D002A00  00609021   ADDU S2, V1, ZERO
2837:                #if !_FS_READONLY
2838:                					if (fp->flag & FA_WRITE) { /* Check if in write mode or not */
9D002960  92030006   LBU V1, 6(S0)
9D002964  30630002   ANDI V1, V1, 2
9D002968  10600007   BEQ V1, ZERO, 0x9D002988
9D00296C  8E040000   LW A0, 0(S0)
2839:                						clst = create_chain(fp->fs, clst); /* Force stretch if in write mode */
9D002970  0F400299   JAL create_chain
9D002974  00402821   ADDU A1, V0, ZERO
2840:                						if (clst == 0) { /* When disk gets full, clip file size */
9D002978  14400005   BNE V0, ZERO, 0x9D002990
9D00297C  00000000   NOP
2841:                							ofs = bcs;
9D002980  0B400A83   J 0x9D002A0C
9D002984  02609021   ADDU S2, S3, ZERO
2842:                							break;
2843:                						}
2844:                					} else
2845:                #endif
2846:                						clst = get_fat(fp->fs, clst); /* Follow cluster chain if not in write mode */
9D002988  0F40015A   JAL get_fat
9D00298C  00402821   ADDU A1, V0, ZERO
2847:                					if (clst == 0xFFFFFFFF)
9D002990  14540007   BNE V0, S4, 0x9D0029B0
9D002994  2C430002   SLTIU V1, V0, 2
2848:                						ABORT(fp->fs, FR_DISK_ERR);
9D002998  92030006   LBU V1, 6(S0)
9D00299C  2402FF80   ADDIU V0, ZERO, -128
9D0029A0  00621025   OR V0, V1, V0
9D0029A4  A2020006   SB V0, 6(S0)
9D0029A8  0B400AA5   J 0x9D002A94
9D0029AC  24110001   ADDIU S1, ZERO, 1
2849:                					if (clst <= 1 || clst >= fp->fs->n_fatent)
9D0029B0  54600007   BNEL V1, ZERO, 0x9D0029D0
9D0029B4  92030006   LBU V1, 6(S0)
9D0029B8  8E030000   LW V1, 0(S0)
9D0029BC  8C63001C   LW V1, 28(V1)
9D0029C0  0043182B   SLTU V1, V0, V1
9D0029C4  54600007   BNEL V1, ZERO, 0x9D0029E4
9D0029C8  AE020014   SW V0, 20(S0)
2850:                						ABORT(fp->fs, FR_INT_ERR);
9D0029CC  92030006   LBU V1, 6(S0)
9D0029D0  2402FF80   ADDIU V0, ZERO, -128
9D0029D4  00621025   OR V0, V1, V0
9D0029D8  A2020006   SB V0, 6(S0)
9D0029DC  0B400AA5   J 0x9D002A94
9D0029E0  24110002   ADDIU S1, ZERO, 2
2851:                					fp->clust = clst;
2852:                					fp->fptr += bcs;
9D0029E4  8E030008   LW V1, 8(S0)
9D0029E8  00731821   ADDU V1, V1, S3
9D0029EC  AE030008   SW V1, 8(S0)
9D0029F0  02551821   ADDU V1, S2, S5
2853:                					ofs -= bcs;
2854:                				}
2855:                				fp->fptr += ofs;
9D002A04  0B400A84   J 0x9D002A10
9D002A08  8E030008   LW V1, 8(S0)
9D002A0C  8E030008   LW V1, 8(S0)
9D002A10  00721821   ADDU V1, V1, S2
9D002A14  AE030008   SW V1, 8(S0)
2856:                				if (ofs % SS(fp->fs)) {
9D002A18  324401FF   ANDI A0, S2, 511
9D002A1C  1080000D   BEQ A0, ZERO, 0x9D002A54
9D002A20  00001821   ADDU V1, ZERO, ZERO
2857:                					nsect = clust2sect(fp->fs, clst); /* Current sector */
9D002A24  8E040000   LW A0, 0(S0)
9D002A28  0F40014E   JAL clust2sect
9D002A2C  00402821   ADDU A1, V0, ZERO
2858:                					if (!nsect)
9D002A30  14400007   BNE V0, ZERO, 0x9D002A50
9D002A34  00121A42   SRL V1, S2, 9
2859:                						ABORT(fp->fs, FR_INT_ERR);
9D002A38  92030006   LBU V1, 6(S0)
9D002A3C  2402FF80   ADDIU V0, ZERO, -128
9D002A40  00621025   OR V0, V1, V0
9D002A44  A2020006   SB V0, 6(S0)
9D002A48  0B400AA5   J 0x9D002A94
9D002A4C  24110002   ADDIU S1, ZERO, 2
2860:                					nsect += ofs / SS(fp->fs);
9D002A50  00431821   ADDU V1, V0, V1
2861:                				}
2862:                			}
2863:                		}
2864:                		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) { /* Fill sector cache if needed */
9D002A54  8E020008   LW V0, 8(S0)
9D002A58  304201FF   ANDI V0, V0, 511
9D002A5C  50400005   BEQL V0, ZERO, 0x9D002A74
9D002A60  8E020008   LW V0, 8(S0)
9D002A64  8E020018   LW V0, 24(S0)
9D002A68  54430001   BNEL V0, V1, 0x9D002A70
9D002A6C  AE030018   SW V1, 24(S0)
2865:                #if !_FS_TINY
2866:                #if !_FS_READONLY
2867:                			if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2868:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2869:                					ABORT(fp->fs, FR_DISK_ERR);
2870:                				fp->flag &= ~FA__DIRTY;
2871:                			}
2872:                #endif
2873:                			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK) /* Fill sector cache */
2874:                				ABORT(fp->fs, FR_DISK_ERR);
2875:                #endif
2876:                			fp->dsect = nsect;
2877:                		}
2878:                #if !_FS_READONLY
2879:                		if (fp->fptr > fp->fsize) { /* Set file change flag if the file size is extended */
9D002A70  8E020008   LW V0, 8(S0)
9D002A74  8E03000C   LW V1, 12(S0)
9D002A78  0062182B   SLTU V1, V1, V0
9D002A7C  50600006   BEQL V1, ZERO, 0x9D002A98
9D002A80  02201021   ADDU V0, S1, ZERO
2880:                			fp->fsize = fp->fptr;
9D002A84  AE02000C   SW V0, 12(S0)
2881:                			fp->flag |= FA__WRITTEN;
9D002A88  92020006   LBU V0, 6(S0)
9D002A8C  34420020   ORI V0, V0, 32
9D002A90  A2020006   SB V0, 6(S0)
2882:                		}
2883:                #endif
2884:                	}
2885:                
2886:                	LEAVE_FF(fp->fs, res);
2887:                }
9D002868  0B400AA6   J 0x9D002A98
9D00286C  02201021   ADDU V0, S1, ZERO
9D002A94  02201021   ADDU V0, S1, ZERO
9D002A98  8FBF0034   LW RA, 52(SP)
9D002A9C  8FBE0030   LW S8, 48(SP)
9D002AA0  8FB7002C   LW S7, 44(SP)
9D002AA4  8FB60028   LW S6, 40(SP)
9D002AA8  8FB50024   LW S5, 36(SP)
9D002AAC  8FB40020   LW S4, 32(SP)
9D002AB0  8FB3001C   LW S3, 28(SP)
9D002AB4  8FB20018   LW S2, 24(SP)
9D002AB8  8FB10014   LW S1, 20(SP)
9D002ABC  8FB00010   LW S0, 16(SP)
9D002AC0  03E00008   JR RA
9D002AC4  27BD0038   ADDIU SP, SP, 56
2888:                
2889:                #if _FS_MINIMIZE <= 1
2890:                /*-----------------------------------------------------------------------*/
2891:                /* Create a Directroy Object                                             */
2892:                /*-----------------------------------------------------------------------*/
2893:                
2894:                FRESULT f_opendir(DIR *dj, /* Pointer to directory object to create */
2895:                const TCHAR *path /* Pointer to the directory path */
2896:                ) {
9D002AC8  27BDFFD8   ADDIU SP, SP, -40
9D002ACC  AFBF0024   SW RA, 36(SP)
9D002AD0  AFB00020   SW S0, 32(SP)
9D002AD4  00808021   ADDU S0, A0, ZERO
9D002AD8  AFA5002C   SW A1, 44(SP)
2897:                	FRESULT res;
2898:                	DEF_NAMEBUF;
2899:                
2900:                	res = chk_mounted(&path, &dj->fs, 0);
9D002ADC  27A4002C   ADDIU A0, SP, 44
9D002AE0  02002821   ADDU A1, S0, ZERO
9D002AE4  0F400529   JAL chk_mounted
9D002AE8  00003021   ADDU A2, ZERO, ZERO
2901:                	if (res == FR_OK) {
9D002AEC  14400024   BNE V0, ZERO, 0x9D002B80
9D002AF0  8FBF0024   LW RA, 36(SP)
2902:                		INIT_BUF(*dj);
9D002AF4  27A20010   ADDIU V0, SP, 16
9D002AF8  AE020018   SW V0, 24(S0)
2903:                		res = follow_path(dj, path); /* Follow the path to the directory */
9D002AFC  02002021   ADDU A0, S0, ZERO
9D002B00  0F40037C   JAL follow_path
9D002B04  8FA5002C   LW A1, 44(SP)
2904:                		FREE_BUF();
2905:                		if (res == FR_OK) { /* Follow completed */
9D002B08  1440001A   BNE V0, ZERO, 0x9D002B74
9D002B0C  38440004   XORI A0, V0, 4
2906:                			if (dj->dir) { /* It is not the root dir */
9D002B10  8E030014   LW V1, 20(S0)
9D002B14  50600011   BEQL V1, ZERO, 0x9D002B5C
9D002B18  8E020000   LW V0, 0(S0)
2907:                				if (dj->dir[DIR_Attr] & AM_DIR) { /* The object is a directory */
9D002B1C  9064000B   LBU A0, 11(V1)
9D002B20  30840010   ANDI A0, A0, 16
9D002B24  10800015   BEQ A0, ZERO, 0x9D002B7C
9D002B28  24020005   ADDIU V0, ZERO, 5
2908:                					dj->sclust = LD_CLUST(dj->dir);
9D002B2C  90640015   LBU A0, 21(V1)
9D002B30  00042200   SLL A0, A0, 8
9D002B34  90620014   LBU V0, 20(V1)
9D002B38  00822025   OR A0, A0, V0
9D002B3C  00042400   SLL A0, A0, 16
9D002B40  9062001B   LBU V0, 27(V1)
9D002B44  00021200   SLL V0, V0, 8
9D002B48  9063001A   LBU V1, 26(V1)
9D002B4C  00431025   OR V0, V0, V1
9D002B50  00821025   OR V0, A0, V0
9D002B54  AE020008   SW V0, 8(S0)
2909:                				} else { /* The object is not a directory */
2910:                					res = FR_NO_PATH;
2911:                				}
2912:                			}
2913:                			if (res == FR_OK) {
2914:                				dj->id = dj->fs->id;
9D002B58  8E020000   LW V0, 0(S0)
9D002B5C  94420006   LHU V0, 6(V0)
9D002B60  A6020004   SH V0, 4(S0)
2915:                				res = dir_sdi(dj, 0); /* Rewind dir */
9D002B64  02002021   ADDU A0, S0, ZERO
9D002B68  0F4001BB   JAL dir_sdi
9D002B6C  00002821   ADDU A1, ZERO, ZERO
2916:                			}
2917:                		}
2918:                		if (res == FR_NO_FILE){
2919:                			res = FR_NO_PATH;
9D002B70  38440004   XORI A0, V0, 4
9D002B74  24030005   ADDIU V1, ZERO, 5
9D002B78  0064100A   MOVZ V0, V1, A0
2920:                                }
2921:                	}
2922:                	LEAVE_FF(dj->fs, res);
2923:                }
9D002B7C  8FBF0024   LW RA, 36(SP)
9D002B80  8FB00020   LW S0, 32(SP)
9D002B84  03E00008   JR RA
9D002B88  27BD0028   ADDIU SP, SP, 40
2924:                
2925:                /*-----------------------------------------------------------------------*/
2926:                /* Read Directory Entry in Sequense                                      */
2927:                /*-----------------------------------------------------------------------*/
2928:                
2929:                FRESULT f_readdir(DIR *dj, /* Pointer to the open directory object */
2930:                FILINFO *fno /* Pointer to file information to return */
2931:                ) {
9D002B8C  27BDFFD0   ADDIU SP, SP, -48
9D002B90  AFBF002C   SW RA, 44(SP)
9D002B94  AFB20028   SW S2, 40(SP)
9D002B98  AFB10024   SW S1, 36(SP)
9D002B9C  AFB00020   SW S0, 32(SP)
9D002BA0  00808821   ADDU S1, A0, ZERO
9D002BA4  00A09021   ADDU S2, A1, ZERO
2932:                	FRESULT res;
2933:                	DEF_NAMEBUF;
2934:                
2935:                	res = validate(dj->fs, dj->id); /* Check validity of the object */
9D002BA8  8C840000   LW A0, 0(A0)
9D002BAC  0F40013B   JAL validate
9D002BB0  96250004   LHU A1, 4(S1)
2936:                	if (res == FR_OK) {
9D002BB4  1440001C   BNE V0, ZERO, 0x9D002C28
9D002BB8  00408021   ADDU S0, V0, ZERO
2937:                		if (!fno) {
9D002BBC  16400006   BNE S2, ZERO, 0x9D002BD8
9D002BC0  27A20010   ADDIU V0, SP, 16
2938:                			res = dir_sdi(dj, 0); /* Rewind the directory object */
9D002BC4  02202021   ADDU A0, S1, ZERO
9D002BC8  0F4001BB   JAL dir_sdi
9D002BCC  00002821   ADDU A1, ZERO, ZERO
9D002BD0  0B400B0A   J 0x9D002C28
9D002BD4  00408021   ADDU S0, V0, ZERO
2939:                		} else {
2940:                			INIT_BUF(*dj);
9D002BD8  AE220018   SW V0, 24(S1)
2941:                			res = dir_read(dj); /* Read an directory item */
9D002BDC  0F4004CA   JAL dir_read
9D002BE0  02202021   ADDU A0, S1, ZERO
2942:                			if (res == FR_NO_FILE) { /* Reached end of dir */
9D002BE4  24030004   ADDIU V1, ZERO, 4
9D002BE8  14430003   BNE V0, V1, 0x9D002BF8
9D002BEC  00000000   NOP
2943:                				dj->sect = 0;
9D002BF0  0B400B00   J 0x9D002C00
9D002BF4  AE200010   SW ZERO, 16(S1)
2944:                				res = FR_OK;
2945:                			}
2946:                			if (res == FR_OK) { /* A valid entry is found */
9D002BF8  5440000B   BNEL V0, ZERO, 0x9D002C28
9D002BFC  00408021   ADDU S0, V0, ZERO
2947:                				get_fileinfo(dj, fno); /* Get the object information */
9D002C00  02202021   ADDU A0, S1, ZERO
9D002C04  0F400032   JAL get_fileinfo
9D002C08  02402821   ADDU A1, S2, ZERO
2948:                				res = dir_next(dj, 0); /* Increment index for next */
9D002C0C  02202021   ADDU A0, S1, ZERO
9D002C10  0F4002FA   JAL dir_next
9D002C14  00002821   ADDU A1, ZERO, ZERO
2949:                				if (res == FR_NO_FILE) {
9D002C18  24030004   ADDIU V1, ZERO, 4
9D002C1C  54430002   BNEL V0, V1, 0x9D002C28
9D002C20  00408021   ADDU S0, V0, ZERO
9D002C24  AE200010   SW ZERO, 16(S1)
2950:                					dj->sect = 0;
2951:                					res = FR_OK;
2952:                				}
2953:                			} FREE_BUF();
2954:                		}
2955:                	}
2956:                
2957:                	LEAVE_FF(dj->fs, res);
2958:                }
9D002C28  02001021   ADDU V0, S0, ZERO
9D002C2C  8FBF002C   LW RA, 44(SP)
9D002C30  8FB20028   LW S2, 40(SP)
9D002C34  8FB10024   LW S1, 36(SP)
9D002C38  8FB00020   LW S0, 32(SP)
9D002C3C  03E00008   JR RA
9D002C40  27BD0030   ADDIU SP, SP, 48
2959:                
2960:                #if _FS_MINIMIZE == 0
2961:                /*-----------------------------------------------------------------------*/
2962:                /* Get File Status                                                       */
2963:                /*-----------------------------------------------------------------------*/
2964:                
2965:                FRESULT f_stat(const TCHAR *path, /* Pointer to the file path */
2966:                                FILINFO *fno /* Pointer to file information to return */
2967:                                ) {
9D002C44  27BDFFB8   ADDIU SP, SP, -72
9D002C48  AFBF0044   SW RA, 68(SP)
9D002C4C  AFB10040   SW S1, 64(SP)
9D002C50  AFB0003C   SW S0, 60(SP)
9D002C54  AFA40048   SW A0, 72(SP)
9D002C58  00A08821   ADDU S1, A1, ZERO
2968:                	FRESULT res;
2969:                	DIR dj;
2970:                	DEF_NAMEBUF;
2971:                
2972:                	res = chk_mounted(&path, &dj.fs, 0);
9D002C5C  27A40048   ADDIU A0, SP, 72
9D002C60  27A50010   ADDIU A1, SP, 16
9D002C64  0F400529   JAL chk_mounted
9D002C68  00003021   ADDU A2, ZERO, ZERO
2973:                	if (res == FR_OK) {
9D002C6C  14400010   BNE V0, ZERO, 0x9D002CB0
9D002C70  00408021   ADDU S0, V0, ZERO
2974:                		INIT_BUF(dj);
9D002C74  27A2002C   ADDIU V0, SP, 44
9D002C78  AFA20028   SW V0, 40(SP)
2975:                		res = follow_path(&dj, path); /* Follow the file path */
9D002C7C  27A40010   ADDIU A0, SP, 16
9D002C80  0F40037C   JAL follow_path
9D002C84  8FA50048   LW A1, 72(SP)
2976:                		if (res == FR_OK) { /* Follow completed */
9D002C88  14400009   BNE V0, ZERO, 0x9D002CB0
9D002C8C  00408021   ADDU S0, V0, ZERO
2977:                			if (dj.dir) /* Found an object */
9D002C90  8FA20024   LW V0, 36(SP)
9D002C94  10400005   BEQ V0, ZERO, 0x9D002CAC
9D002C98  27A40010   ADDIU A0, SP, 16
2978:                				get_fileinfo(&dj, fno);
9D002C9C  0F400032   JAL get_fileinfo
9D002CA0  02202821   ADDU A1, S1, ZERO
2979:                			else
2980:                				/* It is root dir */
2981:                				res = FR_INVALID_NAME;
9D002CAC  24100006   ADDIU S0, ZERO, 6
2982:                		}FREE_BUF();
2983:                	}
2984:                
2985:                	LEAVE_FF(dj.fs, res);
2986:                }
9D002CA4  0B400B2D   J 0x9D002CB4
9D002CA8  02001021   ADDU V0, S0, ZERO
9D002CB0  02001021   ADDU V0, S0, ZERO
9D002CB4  8FBF0044   LW RA, 68(SP)
9D002CB8  8FB10040   LW S1, 64(SP)
9D002CBC  8FB0003C   LW S0, 60(SP)
9D002CC0  03E00008   JR RA
9D002CC4  27BD0048   ADDIU SP, SP, 72
2987:                
2988:                #if !_FS_READONLY
2989:                /*-----------------------------------------------------------------------*/
2990:                /* Get Number of Free Clusters                                           */
2991:                /*-----------------------------------------------------------------------*/
2992:                
2993:                FRESULT f_getfree(const TCHAR *path, /* Pointer to the logical drive number (root dir) */
2994:                DWORD *nclst, /* Pointer to the variable to return number of free clusters */
2995:                FATFS **fatfs /* Pointer to pointer to corresponding file system object to return */
2996:                ) {
9D002CC8  27BDFFC8   ADDIU SP, SP, -56
9D002CCC  AFBF0034   SW RA, 52(SP)
9D002CD0  AFB70030   SW S7, 48(SP)
9D002CD4  AFB6002C   SW S6, 44(SP)
9D002CD8  AFB50028   SW S5, 40(SP)
9D002CDC  AFB40024   SW S4, 36(SP)
9D002CE0  AFB30020   SW S3, 32(SP)
9D002CE4  AFB2001C   SW S2, 28(SP)
9D002CE8  AFB10018   SW S1, 24(SP)
9D002CEC  AFB00014   SW S0, 20(SP)
9D002CF0  AFA40038   SW A0, 56(SP)
9D002CF4  00A0B821   ADDU S7, A1, ZERO
9D002CF8  00C09021   ADDU S2, A2, ZERO
2997:                	FRESULT res;
2998:                	DWORD n, clst, sect, stat;
2999:                	UINT i;
3000:                	PF_BYTE fat, *p;
3001:                
3002:                	/* Get drive number */
3003:                	res = chk_mounted(&path, fatfs, 0);
9D002CFC  27A40038   ADDIU A0, SP, 56
9D002D00  00C02821   ADDU A1, A2, ZERO
9D002D04  0F400529   JAL chk_mounted
9D002D08  00003021   ADDU A2, ZERO, ZERO
3004:                	if (res == FR_OK) {
9D002D0C  1440005A   BNE V0, ZERO, 0x9D002E78
9D002D10  00408021   ADDU S0, V0, ZERO
3005:                		/* If free_clust is valid, return it without full cluster scan */
3006:                		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
9D002D14  8E420000   LW V0, 0(S2)
9D002D18  8C430010   LW V1, 16(V0)
9D002D1C  8C51001C   LW S1, 28(V0)
9D002D20  2624FFFE   ADDIU A0, S1, -2
9D002D24  0083202B   SLTU A0, A0, V1
9D002D28  54800003   BNEL A0, ZERO, 0x9D002D38
9D002D2C  90540000   LBU S4, 0(V0)
3007:                			*nclst = (*fatfs)->free_clust;
9D002D30  0B400B9E   J 0x9D002E78
9D002D34  AEE30000   SW V1, 0(S7)
3008:                		} else {
3009:                			/* Get number of free clusters */
3010:                			fat = (*fatfs)->fs_type;
3011:                			n = 0;
9D002D9C  00009821   ADDU S3, ZERO, ZERO
3012:                			if (fat == FS_FAT12) {
9D002D38  24030001   ADDIU V1, ZERO, 1
9D002D3C  56830015   BNEL S4, V1, 0x9D002D94
9D002D40  8C560024   LW S6, 36(V0)
9D002D44  24110002   ADDIU S1, ZERO, 2
9D002D48  00009821   ADDU S3, ZERO, ZERO
3013:                				clst = 2;
3014:                				do {
3015:                					stat = get_fat(*fatfs, clst);
9D002D54  8E440000   LW A0, 0(S2)
9D002D58  0F40015A   JAL get_fat
9D002D5C  02202821   ADDU A1, S1, ZERO
3016:                					if (stat == 0xFFFFFFFF) {
9D002D4C  2415FFFF   ADDIU S5, ZERO, -1
9D002D60  5055003C   BEQL V0, S5, 0x9D002E54
9D002D64  24100001   ADDIU S0, ZERO, 1
3017:                						res = FR_DISK_ERR;
3018:                						break;
3019:                					}
3020:                					if (stat == 1) {
9D002D50  24160001   ADDIU S6, ZERO, 1
9D002D68  10560037   BEQ V0, S6, 0x9D002E48
9D002D6C  2C420001   SLTIU V0, V0, 1
3021:                						res = FR_INT_ERR;
9D002E48  0B400B95   J 0x9D002E54
9D002E4C  24100002   ADDIU S0, ZERO, 2
3022:                						break;
3023:                					}
3024:                					if (stat == 0)
3025:                						n++;
9D002D70  02629821   ADDU S3, S3, V0
3026:                				} while (++clst < (*fatfs)->n_fatent);
9D002D74  26310001   ADDIU S1, S1, 1
9D002D78  8E420000   LW V0, 0(S2)
9D002D7C  8C43001C   LW V1, 28(V0)
9D002D80  0223182B   SLTU V1, S1, V1
9D002D84  5460FFF4   BNEL V1, ZERO, 0x9D002D58
9D002D88  8E440000   LW A0, 0(S2)
3027:                			} else {
3028:                				clst = (*fatfs)->n_fatent;
3029:                				sect = (*fatfs)->fatbase;
3030:                				i = 0;
9D002D98  00001821   ADDU V1, ZERO, ZERO
3031:                				p = 0;
9D002D94  00001021   ADDU V0, ZERO, ZERO
3032:                				do {
3033:                					if (!i) {
9D002DA4  14600009   BNE V1, ZERO, 0x9D002DCC
9D002DA8  00000000   NOP
3034:                						res = move_window(*fatfs, sect++);
9D002DAC  8E440000   LW A0, 0(S2)
9D002DB0  0F40007A   JAL move_window
9D002DB4  02C02821   ADDU A1, S6, ZERO
9D002E50  00408021   ADDU S0, V0, ZERO
3035:                						if (res != FR_OK)
9D002DB8  14400025   BNE V0, ZERO, 0x9D002E50
9D002DBC  26D60001   ADDIU S6, S6, 1
3036:                							break;
3037:                						p = (*fatfs)->win;
9D002DC0  8E420000   LW V0, 0(S2)
9D002DC4  24420034   ADDIU V0, V0, 52
3038:                						i = SS(*fatfs);
9D002DC8  24030200   ADDIU V1, ZERO, 512
3039:                					}
3040:                					if (fat == FS_FAT16) {
9D002DA0  24150002   ADDIU S5, ZERO, 2
9D002DCC  5695000B   BNEL S4, S5, 0x9D002DFC
9D002DD0  90450003   LBU A1, 3(V0)
3041:                						if (LD_WORD(p) == 0)
9D002DD4  90440001   LBU A0, 1(V0)
9D002DD8  00042200   SLL A0, A0, 8
9D002DDC  90450000   LBU A1, 0(V0)
9D002DE0  00852025   OR A0, A0, A1
9D002DE4  7C042620   SEH A0, A0
3042:                							n++;
9D002DE8  2C840001   SLTIU A0, A0, 1
9D002DEC  02649821   ADDU S3, S3, A0
3043:                						p += 2;
9D002DF0  24420002   ADDIU V0, V0, 2
3044:                						i -= 2;
9D002DF4  0B400B8D   J 0x9D002E34
9D002DF8  2463FFFE   ADDIU V1, V1, -2
3045:                					} else {
3046:                						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0)
9D002DFC  00052E00   SLL A1, A1, 24
9D002E00  90440002   LBU A0, 2(V0)
9D002E04  00042400   SLL A0, A0, 16
9D002E08  00A42025   OR A0, A1, A0
9D002E0C  90450000   LBU A1, 0(V0)
9D002E10  00852025   OR A0, A0, A1
9D002E14  90450001   LBU A1, 1(V0)
9D002E18  00052A00   SLL A1, A1, 8
9D002E1C  00852025   OR A0, A0, A1
9D002E20  7C84D800   EXT A0, A0, 0, 28
3047:                							n++;
9D002E24  2C840001   SLTIU A0, A0, 1
9D002E28  02649821   ADDU S3, S3, A0
3048:                						p += 4;
9D002E2C  24420004   ADDIU V0, V0, 4
3049:                						i -= 4;
9D002E30  2463FFFC   ADDIU V1, V1, -4
3050:                					}
3051:                				} while (--clst);
9D002E34  2631FFFF   ADDIU S1, S1, -1
9D002E38  1620FFDA   BNE S1, ZERO, 0x9D002DA4
9D002E3C  00000000   NOP
3052:                			}
3053:                			(*fatfs)->free_clust = n;
9D002D8C  0B400B9D   J 0x9D002E74
9D002D90  AC530010   SW S3, 16(V0)
9D002E40  0B400B96   J 0x9D002E58
9D002E44  8E420000   LW V0, 0(S2)
9D002E54  8E420000   LW V0, 0(S2)
9D002E58  AC530010   SW S3, 16(V0)
3054:                			if (fat == FS_FAT32)
9D002E5C  24020003   ADDIU V0, ZERO, 3
9D002E60  56820005   BNEL S4, V0, 0x9D002E78
9D002E64  AEF30000   SW S3, 0(S7)
3055:                				(*fatfs)->fsi_flag = 1;
9D002E68  8E420000   LW V0, 0(S2)
9D002E6C  24030001   ADDIU V1, ZERO, 1
9D002E70  A0430005   SB V1, 5(V0)
3056:                			*nclst = n;
9D002E74  AEF30000   SW S3, 0(S7)
3057:                		}
3058:                	}
3059:                	LEAVE_FF(*fatfs, res);
3060:                }
9D002E78  02001021   ADDU V0, S0, ZERO
9D002E7C  8FBF0034   LW RA, 52(SP)
9D002E80  8FB70030   LW S7, 48(SP)
9D002E84  8FB6002C   LW S6, 44(SP)
9D002E88  8FB50028   LW S5, 40(SP)
9D002E8C  8FB40024   LW S4, 36(SP)
9D002E90  8FB30020   LW S3, 32(SP)
9D002E94  8FB2001C   LW S2, 28(SP)
9D002E98  8FB10018   LW S1, 24(SP)
9D002E9C  8FB00014   LW S0, 20(SP)
9D002EA0  03E00008   JR RA
9D002EA4  27BD0038   ADDIU SP, SP, 56
3061:                
3062:                /*-----------------------------------------------------------------------*/
3063:                /* Truncate File                                                         */
3064:                /*-----------------------------------------------------------------------*/
3065:                
3066:                FRESULT f_truncate(FIL *fp /* Pointer to the file object */
3067:                ) {
9D002EA8  27BDFFE0   ADDIU SP, SP, -32
9D002EAC  AFBF001C   SW RA, 28(SP)
9D002EB0  AFB10018   SW S1, 24(SP)
9D002EB4  AFB00014   SW S0, 20(SP)
9D002EB8  00808021   ADDU S0, A0, ZERO
3068:                	FRESULT res;
3069:                	DWORD ncl;
3070:                
3071:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D002EBC  8C840000   LW A0, 0(A0)
9D002EC0  0F40013B   JAL validate
9D002EC4  96050004   LHU A1, 4(S0)
3072:                	if (res == FR_OK) {
9D002EC8  14400033   BNE V0, ZERO, 0x9D002F98
9D002ECC  8FBF001C   LW RA, 28(SP)
3073:                		if (fp->flag & FA__ERROR) { /* Check abort flag */
9D002ED0  92030006   LBU V1, 6(S0)
9D002ED4  7C032420   SEB A0, V1
9D002ED8  04800005   BLTZ A0, 0x9D002EF0
9D002EDC  30640002   ANDI A0, V1, 2
3074:                			res = FR_INT_ERR;
9D002EF0  0B400BE5   J 0x9D002F94
9D002EF4  24020002   ADDIU V0, ZERO, 2
3075:                		} else {
3076:                			if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D002EE0  54800031   BNEL A0, ZERO, 0x9D002FA8
9D002EE4  8E040008   LW A0, 8(S0)
3077:                				res = FR_DENIED;
9D002EE8  0B400BE5   J 0x9D002F94
9D002EEC  24020007   ADDIU V0, ZERO, 7
3078:                		}
3079:                	}
3080:                	if (res == FR_OK) {
3081:                		if (fp->fsize > fp->fptr) {
9D002FA8  8E05000C   LW A1, 12(S0)
9D002FAC  0085282B   SLTU A1, A0, A1
9D002FB0  54A0FFD1   BNEL A1, ZERO, 0x9D002EF8
9D002FB4  AE04000C   SW A0, 12(S0)
3082:                			fp->fsize = fp->fptr; /* Set file size to current R/W point */
3083:                			fp->flag |= FA__WRITTEN;
9D002EF8  34630020   ORI V1, V1, 32
3084:                			if (fp->fptr == 0) { /* When set file size to zero, remove entire cluster chain */
9D002EFC  14800006   BNE A0, ZERO, 0x9D002F18
9D002F00  A2030006   SB V1, 6(S0)
3085:                				res = remove_chain(fp->fs, fp->sclust);
9D002F04  8E040000   LW A0, 0(S0)
9D002F08  0F4004EF   JAL remove_chain
9D002F0C  8E050010   LW A1, 16(S0)
3086:                				fp->sclust = 0;
9D002F10  0B400BDF   J 0x9D002F7C
9D002F14  AE000010   SW ZERO, 16(S0)
3087:                			} else { /* When truncate a part of the file, remove remaining clusters */
3088:                				ncl = get_fat(fp->fs, fp->clust);
9D002F18  8E040000   LW A0, 0(S0)
9D002F1C  0F40015A   JAL get_fat
9D002F20  8E050014   LW A1, 20(S0)
9D002F24  00408821   ADDU S1, V0, ZERO
3089:                				res = FR_OK;
9D002F34  26220001   ADDIU V0, S1, 1
9D002F38  2C420001   SLTIU V0, V0, 1
3090:                				if (ncl == 0xFFFFFFFF)
3091:                					res = FR_DISK_ERR;
3092:                				if (ncl == 1)
9D002F28  24020001   ADDIU V0, ZERO, 1
9D002F2C  12220015   BEQ S1, V0, 0x9D002F84
9D002F30  24020002   ADDIU V0, ZERO, 2
3093:                					res = FR_INT_ERR;
3094:                				if (res == FR_OK && ncl < fp->fs->n_fatent) {
9D002F3C  54400012   BNEL V0, ZERO, 0x9D002F88
9D002F40  92040006   LBU A0, 6(S0)
9D002F44  8E040000   LW A0, 0(S0)
9D002F48  8C83001C   LW V1, 28(A0)
9D002F4C  0223182B   SLTU V1, S1, V1
9D002F50  10600011   BEQ V1, ZERO, 0x9D002F98
9D002F54  8FBF001C   LW RA, 28(SP)
3095:                					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
9D002F58  8E050014   LW A1, 20(S0)
9D002F5C  3C060FFF   LUI A2, 4095
9D002F60  0F40022A   JAL put_fat
9D002F64  34C6FFFF   ORI A2, A2, -1
3096:                					if (res == FR_OK)
9D002F68  54400007   BNEL V0, ZERO, 0x9D002F88
9D002F6C  92040006   LBU A0, 6(S0)
3097:                						res = remove_chain(fp->fs, ncl);
9D002F70  8E040000   LW A0, 0(S0)
9D002F74  0F4004EF   JAL remove_chain
9D002F78  02202821   ADDU A1, S1, ZERO
3098:                				}
3099:                			}
3100:                		}
3101:                		if (res != FR_OK)
9D002F7C  10400006   BEQ V0, ZERO, 0x9D002F98
9D002F80  8FBF001C   LW RA, 28(SP)
3102:                			fp->flag |= FA__ERROR;
9D002F84  92040006   LBU A0, 6(S0)
9D002F88  2403FF80   ADDIU V1, ZERO, -128
9D002F8C  00831825   OR V1, A0, V1
9D002F90  A2030006   SB V1, 6(S0)
3103:                	}
3104:                
3105:                	LEAVE_FF(fp->fs, res);
3106:                }
9D002F94  8FBF001C   LW RA, 28(SP)
9D002F98  8FB10018   LW S1, 24(SP)
9D002F9C  8FB00014   LW S0, 20(SP)
9D002FA0  03E00008   JR RA
9D002FA4  27BD0020   ADDIU SP, SP, 32
9D002FB8  0B400BE6   J 0x9D002F98
9D002FBC  8FBF001C   LW RA, 28(SP)
3107:                
3108:                /*-----------------------------------------------------------------------*/
3109:                /* Delete a File or Directory                                            */
3110:                /*-----------------------------------------------------------------------*/
3111:                
3112:                FRESULT f_unlink(const TCHAR *path /* Pointer to the file or directory path */
3113:                ) {
9D002FC0  27BDFFA0   ADDIU SP, SP, -96
9D002FC4  AFBF005C   SW RA, 92(SP)
9D002FC8  AFB00058   SW S0, 88(SP)
9D002FCC  AFA40060   SW A0, 96(SP)
3114:                	FRESULT res;
3115:                	DIR dj, sdj;
3116:                	PF_BYTE *dir;
3117:                	DWORD dclst;
3118:                	DEF_NAMEBUF;
3119:                
3120:                	res = chk_mounted(&path, &dj.fs, 1);
9D002FD0  27A40060   ADDIU A0, SP, 96
9D002FD4  27A50010   ADDIU A1, SP, 16
9D002FD8  0F400529   JAL chk_mounted
9D002FDC  24060001   ADDIU A2, ZERO, 1
3121:                	if (res == FR_OK) {
9D002FE0  14400038   BNE V0, ZERO, 0x9D0030C4
9D002FE4  8FBF005C   LW RA, 92(SP)
3122:                		INIT_BUF(dj);
9D002FE8  27A20048   ADDIU V0, SP, 72
9D002FEC  AFA20028   SW V0, 40(SP)
3123:                		res = follow_path(&dj, path); /* Follow the file path */
9D002FF0  27A40010   ADDIU A0, SP, 16
9D002FF4  0F40037C   JAL follow_path
9D002FF8  8FA50060   LW A1, 96(SP)
3124:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D002FFC  14400031   BNE V0, ZERO, 0x9D0030C4
9D003000  8FBF005C   LW RA, 92(SP)
9D003004  8FA20028   LW V0, 40(SP)
9D003008  9042000B   LBU V0, 11(V0)
9D00300C  30420020   ANDI V0, V0, 32
9D003010  1040002F   BEQ V0, ZERO, 0x9D0030D0
9D003014  8FA30024   LW V1, 36(SP)
3125:                			res = FR_INVALID_NAME; /* Cannot remove dot entry */
9D003018  0B400C30   J 0x9D0030C0
9D00301C  24020006   ADDIU V0, ZERO, 6
3126:                #if _FS_SHARE
3127:                		if (res == FR_OK) res = chk_lock(&dj, 2); /* Cannot remove open file */
3128:                #endif
3129:                		if (res == FR_OK) { /* The object is accessible */
3130:                			dir = dj.dir;
3131:                			if (!dir) {
9D0030D0  1460FFD3   BNE V1, ZERO, 0x9D003020
9D0030D4  24020006   ADDIU V0, ZERO, 6
3132:                				res = FR_INVALID_NAME; /* Cannot remove the start directory */
3133:                			} else {
3134:                				if (dir[DIR_Attr] & AM_RDO)
9D003020  9062000B   LBU V0, 11(V1)
9D003024  30420001   ANDI V0, V0, 1
9D003028  50400033   BEQL V0, ZERO, 0x9D0030F8
9D00302C  90620015   LBU V0, 21(V1)
3135:                					res = FR_DENIED; /* Cannot remove R/O object */
9D003030  0B400C30   J 0x9D0030C0
9D003034  24020007   ADDIU V0, ZERO, 7
3136:                			}
3137:                			dclst = LD_CLUST(dir);
9D0030F8  00021200   SLL V0, V0, 8
9D0030FC  90640014   LBU A0, 20(V1)
9D003100  00441025   OR V0, V0, A0
9D003104  00021400   SLL V0, V0, 16
9D003108  9070001B   LBU S0, 27(V1)
9D00310C  00108200   SLL S0, S0, 8
9D003110  9064001A   LBU A0, 26(V1)
9D003114  02048025   OR S0, S0, A0
9D003118  00508025   OR S0, V0, S0
3138:                			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) { /* Is it a sub-dir? */
9D00311C  9062000B   LBU V0, 11(V1)
9D003120  30420010   ANDI V0, V0, 16
9D003124  1440FFC4   BNE V0, ZERO, 0x9D003038
9D003128  2E030002   SLTIU V1, S0, 2
9D00312C  0B400C38   J 0x9D0030E0
9D003130  00000000   NOP
3139:                				if (dclst < 2) {
9D003038  14600021   BNE V1, ZERO, 0x9D0030C0
9D00303C  24020002   ADDIU V0, ZERO, 2
3140:                					res = FR_INT_ERR;
3141:                				} else {
3142:                					mem_cpy(&sdj, &dj, sizeof(DIR)); /* Check if the sub-dir is empty or not */
9D003040  27A4002C   ADDIU A0, SP, 44
9D003044  27A50010   ADDIU A1, SP, 16
9D003048  0F400000   JAL mem_cpy
9D00304C  2406001C   ADDIU A2, ZERO, 28
3143:                					sdj.sclust = dclst;
9D003050  AFB00034   SW S0, 52(SP)
3144:                					res = dir_sdi(&sdj, 2); /* Exclude dot entries */
9D003054  27A4002C   ADDIU A0, SP, 44
9D003058  0F4001BB   JAL dir_sdi
9D00305C  24050002   ADDIU A1, ZERO, 2
3145:                					if (res == FR_OK) {
9D003060  14400018   BNE V0, ZERO, 0x9D0030C4
9D003064  8FBF005C   LW RA, 92(SP)
3146:                						res = dir_read(&sdj);
9D003068  0F4004CA   JAL dir_read
9D00306C  27A4002C   ADDIU A0, SP, 44
3147:                						if (res == FR_OK /* Not empty dir */
9D003070  50400013   BEQL V0, ZERO, 0x9D0030C0
9D003074  24020007   ADDIU V0, ZERO, 7
3148:                #if _FS_RPATH
3149:                							|| dclst == sdj.fs->cdir /* Current dir */
9D003078  8FA3002C   LW V1, 44(SP)
9D00307C  8C630018   LW V1, 24(V1)
9D003080  10700005   BEQ V1, S0, 0x9D003098
9D003084  24030004   ADDIU V1, ZERO, 4
9D003098  0B400C30   J 0x9D0030C0
9D00309C  24020007   ADDIU V0, ZERO, 7
3150:                #endif
3151:                							) res = FR_DENIED;
3152:                						if (res == FR_NO_FILE)
9D003088  10430015   BEQ V0, V1, 0x9D0030E0
9D00308C  8FBF005C   LW RA, 92(SP)
3153:                							res = FR_OK; /* Empty */
3154:                					}
3155:                				}
3156:                			}
3157:                			if (res == FR_OK) {
3158:                				res = dir_remove(&dj); /* Remove the directory entry */
9D0030E0  0F400214   JAL dir_remove
9D0030E4  27A40010   ADDIU A0, SP, 16
3159:                				if (res == FR_OK) {
9D0030E8  1040FFED   BEQ V0, ZERO, 0x9D0030A0
9D0030EC  8FBF005C   LW RA, 92(SP)
3160:                					if (dclst) /* Remove the cluster chain if exist */
9D0030A0  12000005   BEQ S0, ZERO, 0x9D0030B8
9D0030A4  8FA40010   LW A0, 16(SP)
3161:                						res = remove_chain(dj.fs, dclst);
9D0030A8  0F4004EF   JAL remove_chain
9D0030AC  02002821   ADDU A1, S0, ZERO
3162:                					if (res == FR_OK)
9D0030B0  14400004   BNE V0, ZERO, 0x9D0030C4
9D0030B4  8FBF005C   LW RA, 92(SP)
3163:                						res = sync(dj.fs);
9D0030B8  0F4000F1   JAL sync
9D0030BC  8FA40010   LW A0, 16(SP)
3164:                				}
3165:                			}
3166:                		}FREE_BUF();
3167:                	}
3168:                	LEAVE_FF(dj.fs, res);
3169:                }
9D003090  0B400C32   J 0x9D0030C8
9D003094  8FB00058   LW S0, 88(SP)
9D0030C0  8FBF005C   LW RA, 92(SP)
9D0030C4  8FB00058   LW S0, 88(SP)
9D0030C8  03E00008   JR RA
9D0030CC  27BD0060   ADDIU SP, SP, 96
9D0030D8  0B400C31   J 0x9D0030C4
9D0030DC  8FBF005C   LW RA, 92(SP)
9D0030F0  0B400C32   J 0x9D0030C8
9D0030F4  8FB00058   LW S0, 88(SP)
3170:                
3171:                /*-----------------------------------------------------------------------*/
3172:                /* Create a Directory                                                    */
3173:                /*-----------------------------------------------------------------------*/
3174:                
3175:                FRESULT f_mkdir(const TCHAR *path /* Pointer to the directory path */
9D003300  32B500FF   ANDI S5, S5, 255
9D003304  26B50001   ADDIU S5, S5, 1
9D003308  02B2A821   ADDU S5, S5, S2
3176:                ) {
9D003134  27BDFF88   ADDIU SP, SP, -120
9D003138  AFBF0074   SW RA, 116(SP)
9D00313C  AFBE0070   SW S8, 112(SP)
9D003140  AFB7006C   SW S7, 108(SP)
9D003144  AFB60068   SW S6, 104(SP)
9D003148  AFB50064   SW S5, 100(SP)
9D00314C  AFB40060   SW S4, 96(SP)
9D003150  AFB3005C   SW S3, 92(SP)
9D003154  AFB20058   SW S2, 88(SP)
9D003158  AFB10054   SW S1, 84(SP)
9D00315C  AFB00050   SW S0, 80(SP)
3177:                	FRESULT res;
3178:                	DIR dj;
3179:                	PF_BYTE *dir, n;
3180:                	DWORD dsc, dcl, pcl, tim = get_fattime();
9D003160  0F402701   JAL get_fattime
9D003164  AFA40078   SW A0, 120(SP)
9D003168  00408821   ADDU S1, V0, ZERO
3181:                	DEF_NAMEBUF;
3182:                
3183:                	res = chk_mounted(&path, &dj.fs, 1);
9D00316C  27A40078   ADDIU A0, SP, 120
9D003170  27A50010   ADDIU A1, SP, 16
9D003174  0F400529   JAL chk_mounted
9D003178  24060001   ADDIU A2, ZERO, 1
3184:                	if (res == FR_OK) {
9D00317C  1440008E   BNE V0, ZERO, 0x9D0033B8
9D003180  00408021   ADDU S0, V0, ZERO
3185:                		INIT_BUF(dj);
9D003184  27A2002C   ADDIU V0, SP, 44
9D003188  AFA20028   SW V0, 40(SP)
3186:                		res = follow_path(&dj, path); /* Follow the file path */
9D00318C  27A40010   ADDIU A0, SP, 16
9D003190  0F40037C   JAL follow_path
9D003194  8FA50078   LW A1, 120(SP)
3187:                		if (res == FR_OK)
9D003198  5040000A   BEQL V0, ZERO, 0x9D0031C4
9D00319C  24020008   ADDIU V0, ZERO, 8
3188:                			res = FR_EXIST; /* Any object with same name is already existing */
3189:                		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
9D0031A0  24030004   ADDIU V1, ZERO, 4
9D0031A4  54430084   BNEL V0, V1, 0x9D0033B8
9D0031A8  00408021   ADDU S0, V0, ZERO
9D0031AC  8FA20028   LW V0, 40(SP)
9D0031B0  9042000B   LBU V0, 11(V0)
9D0031B4  30420020   ANDI V0, V0, 32
9D0031B8  1040008C   BEQ V0, ZERO, 0x9D0033EC
9D0031BC  8FA40010   LW A0, 16(SP)
9D0031C0  24020006   ADDIU V0, ZERO, 6
3190:                			res = FR_INVALID_NAME;
3191:                		if (res == FR_NO_FILE) { /* Can create a new directory */
3192:                			dcl = create_chain(dj.fs, 0); /* Allocate a cluster for the new directory table */
9D0033EC  0F400299   JAL create_chain
9D0033F0  00002821   ADDU A1, ZERO, ZERO
3193:                			res = FR_OK;
3194:                			if (dcl == 0)
9D0033F4  1040FF7C   BEQ V0, ZERO, 0x9D0031E8
9D0033F8  0040A021   ADDU S4, V0, ZERO
3195:                				res = FR_DENIED; /* No space to allocate a new cluster */
9D0031E8  24100007   ADDIU S0, ZERO, 7
3196:                			if (dcl == 1)
9D0031CC  52820060   BEQL S4, V0, 0x9D003350
9D0031D0  24100002   ADDIU S0, ZERO, 2
9D0033FC  0B400C73   J 0x9D0031CC
9D003400  24020001   ADDIU V0, ZERO, 1
3197:                				res = FR_INT_ERR;
3198:                			if (dcl == 0xFFFFFFFF)
9D0031D4  2402FFFF   ADDIU V0, ZERO, -1
9D0031D8  5282005D   BEQL S4, V0, 0x9D003350
9D0031DC  24100001   ADDIU S0, ZERO, 1
9D0031E0  0B400C7B   J 0x9D0031EC
9D0031E4  00000000   NOP
3199:                				res = FR_DISK_ERR;
3200:                			if (res == FR_OK) /* Flush FAT */
9D0031EC  16000058   BNE S0, ZERO, 0x9D003350
9D0031F0  8FA40010   LW A0, 16(SP)
3201:                				res = move_window(dj.fs, 0);
9D0031F4  0F40007A   JAL move_window
9D0031F8  00002821   ADDU A1, ZERO, ZERO
3202:                			if (res == FR_OK) { /* Initialize the new directory table */
9D0031FC  14400054   BNE V0, ZERO, 0x9D003350
9D003200  00408021   ADDU S0, V0, ZERO
3203:                				dsc = clust2sect(dj.fs, dcl);
9D003204  8FB00010   LW S0, 16(SP)
9D003208  02002021   ADDU A0, S0, ZERO
9D00320C  0F40014E   JAL clust2sect
9D003210  02802821   ADDU A1, S4, ZERO
9D003214  00409021   ADDU S2, V0, ZERO
3204:                				dir = dj.fs->win;
9D003218  26130034   ADDIU S3, S0, 52
3205:                				mem_set(dir, 0, SS(dj.fs));
9D00321C  02602021   ADDU A0, S3, ZERO
9D003220  00002821   ADDU A1, ZERO, ZERO
9D003224  0F40000A   JAL mem_set
9D003228  24060200   ADDIU A2, ZERO, 512
3206:                				mem_set(dir + DIR_Name, ' ', 8 + 3); /* Create "." entry */
9D00322C  02602021   ADDU A0, S3, ZERO
9D003230  24050020   ADDIU A1, ZERO, 32
9D003234  0F40000A   JAL mem_set
9D003238  2406000B   ADDIU A2, ZERO, 11
3207:                				dir[DIR_Name] = '.';
9D00323C  2415002E   ADDIU S5, ZERO, 46
9D003240  A2150034   SB S5, 52(S0)
3208:                				dir[DIR_Attr] = AM_DIR;
9D003244  24020010   ADDIU V0, ZERO, 16
9D003248  A202003F   SB V0, 63(S0)
3209:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D00324C  322200FF   ANDI V0, S1, 255
9D003250  AFA20038   SW V0, 56(SP)
9D003254  A202004A   SB V0, 74(S0)
9D003258  00111A02   SRL V1, S1, 8
9D00325C  A3A30048   SB V1, 72(SP)
9D003260  A203004B   SB V1, 75(S0)
9D003264  7E223C00   EXT V0, S1, 16, 8
9D003268  AFA2003C   SW V0, 60(SP)
9D00326C  A202004C   SB V0, 76(S0)
9D003270  00118E02   SRL S1, S1, 24
9D003274  AFB10040   SW S1, 64(SP)
9D003278  A211004D   SB S1, 77(S0)
3210:                				ST_CLUST(dir, dcl);
9D00327C  328300FF   ANDI V1, S4, 255
9D003280  AFA30044   SW V1, 68(SP)
9D003284  A203004E   SB V1, 78(S0)
9D003288  0014BA02   SRL S7, S4, 8
9D00328C  A217004F   SB S7, 79(S0)
9D003290  0014B402   SRL S6, S4, 16
9D003294  32DE00FF   ANDI S8, S6, 255
9D003298  A21E0048   SB S8, 72(S0)
9D00329C  0016B202   SRL S6, S6, 8
9D0032A0  A2160049   SB S6, 73(S0)
3211:                				mem_cpy(dir + SZ_DIR, dir, SZ_DIR); /* Create ".." entry */
9D0032A4  26040054   ADDIU A0, S0, 84
9D0032A8  02602821   ADDU A1, S3, ZERO
9D0032AC  0F400000   JAL mem_cpy
9D0032B0  24060020   ADDIU A2, ZERO, 32
3212:                				dir[33] = '.';
9D0032B4  A2150055   SB S5, 85(S0)
3213:                				pcl = dj.sclust;
3214:                				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
9D0032B8  8FA30010   LW V1, 16(SP)
9D0032BC  90650000   LBU A1, 0(V1)
9D0032C0  24040003   ADDIU A0, ZERO, 3
9D0032C4  14A40004   BNE A1, A0, 0x9D0032D8
9D0032C8  8FA20018   LW V0, 24(SP)
9D0032CC  8C640028   LW A0, 40(V1)
3215:                					pcl = 0;
9D0031C4  0B400CEE   J 0x9D0033B8
9D0031C8  00408021   ADDU S0, V0, ZERO
9D0032D0  00822026   XOR A0, A0, V0
9D0032D4  0004100A   MOVZ V0, ZERO, A0
3216:                				ST_CLUST(dir+SZ_DIR, pcl);
9D0032D8  A202006E   SB V0, 110(S0)
9D0032DC  7C443A00   EXT A0, V0, 8, 8
9D0032E0  A204006F   SB A0, 111(S0)
9D0032E4  00021402   SRL V0, V0, 16
9D0032E8  A2020068   SB V0, 104(S0)
9D0032EC  00021202   SRL V0, V0, 8
9D0032F0  A2020069   SB V0, 105(S0)
3217:                				for (n = dj.fs->csize; n; n--) { /* Write dot entries and clear following sectors */
9D0032F4  90620002   LBU V0, 2(V1)
9D0032F8  10400042   BEQ V0, ZERO, 0x9D003404
9D0032FC  2455FFFF   ADDIU S5, V0, -1
9D003340  1655FFF4   BNE S2, S5, 0x9D003314
9D003344  8FA40010   LW A0, 16(SP)
9D003348  0B400D01   J 0x9D003404
9D00334C  00000000   NOP
3218:                					dj.fs->winsect = dsc++;
9D003310  8FA40010   LW A0, 16(SP)
9D003314  AC920030   SW S2, 48(A0)
9D003318  26520001   ADDIU S2, S2, 1
3219:                					dj.fs->wflag = 1;
9D00330C  24110001   ADDIU S1, ZERO, 1
9D00331C  A0910004   SB S1, 4(A0)
3220:                					res = move_window(dj.fs, 0);
9D003320  0F40007A   JAL move_window
9D003324  00002821   ADDU A1, ZERO, ZERO
3221:                					if (res != FR_OK)
9D003328  14400009   BNE V0, ZERO, 0x9D003350
9D00332C  00408021   ADDU S0, V0, ZERO
3222:                						break;
3223:                					mem_set(dir, 0, SS(dj.fs));
9D003330  02602021   ADDU A0, S3, ZERO
9D003334  00002821   ADDU A1, ZERO, ZERO
9D003338  0F40000A   JAL mem_set
9D00333C  24060200   ADDIU A2, ZERO, 512
3224:                				}
3225:                			}
3226:                			if (res == FR_OK)
3227:                				res = dir_register(&dj); /* Register the object to the directoy */
9D003404  0F400495   JAL dir_register
9D003408  27A40010   ADDIU A0, SP, 16
3228:                			if (res != FR_OK) {
9D00340C  1040FFD5   BEQ V0, ZERO, 0x9D003364
9D003410  00408021   ADDU S0, V0, ZERO
3229:                				remove_chain(dj.fs, dcl); /* Could not register, remove cluster chain */
9D003350  8FA40010   LW A0, 16(SP)
9D003354  0F4004EF   JAL remove_chain
9D003358  02802821   ADDU A1, S4, ZERO
9D003414  0B400CD5   J 0x9D003354
9D003418  8FA40010   LW A0, 16(SP)
3230:                			} else {
3231:                				dir = dj.dir;
9D003364  8FA20024   LW V0, 36(SP)
3232:                				dir[DIR_Attr] = AM_DIR; /* Attribute */
9D003368  24030010   ADDIU V1, ZERO, 16
9D00336C  A043000B   SB V1, 11(V0)
3233:                				ST_DWORD(dir+DIR_WrtTime, tim); /* Created time */
9D003370  8FA30038   LW V1, 56(SP)
9D003374  A0430016   SB V1, 22(V0)
9D003378  93A30048   LBU V1, 72(SP)
9D00337C  A0430017   SB V1, 23(V0)
9D003380  8FA3003C   LW V1, 60(SP)
9D003384  A0430018   SB V1, 24(V0)
9D003388  8FA30040   LW V1, 64(SP)
9D00338C  A0430019   SB V1, 25(V0)
3234:                				ST_CLUST(dir, dcl); /* Table start cluster */
9D003390  8FA30044   LW V1, 68(SP)
9D003394  A043001A   SB V1, 26(V0)
9D003398  A057001B   SB S7, 27(V0)
9D00339C  A05E0014   SB S8, 20(V0)
9D0033A0  A0560015   SB S6, 21(V0)
3235:                				dj.fs->wflag = 1;
9D0033A4  8FA40010   LW A0, 16(SP)
9D0033A8  24020001   ADDIU V0, ZERO, 1
3236:                				res = sync(dj.fs);
9D0033AC  0F4000F1   JAL sync
9D0033B0  A0820004   SB V0, 4(A0)
9D0033B4  00408021   ADDU S0, V0, ZERO
3237:                			}
3238:                		}FREE_BUF();
3239:                	}
3240:                
3241:                	LEAVE_FF(dj.fs, res);
3242:                }
9D00335C  0B400CEF   J 0x9D0033BC
9D003360  02001021   ADDU V0, S0, ZERO
9D0033B8  02001021   ADDU V0, S0, ZERO
9D0033BC  8FBF0074   LW RA, 116(SP)
9D0033C0  8FBE0070   LW S8, 112(SP)
9D0033C4  8FB7006C   LW S7, 108(SP)
9D0033C8  8FB60068   LW S6, 104(SP)
9D0033CC  8FB50064   LW S5, 100(SP)
9D0033D0  8FB40060   LW S4, 96(SP)
9D0033D4  8FB3005C   LW S3, 92(SP)
9D0033D8  8FB20058   LW S2, 88(SP)
9D0033DC  8FB10054   LW S1, 84(SP)
9D0033E0  8FB00050   LW S0, 80(SP)
9D0033E4  03E00008   JR RA
9D0033E8  27BD0078   ADDIU SP, SP, 120
3243:                
3244:                /*-----------------------------------------------------------------------*/
3245:                /* Change Attribute                                                      */
3246:                /*-----------------------------------------------------------------------*/
3247:                
3248:                FRESULT f_chmod(const TCHAR *path, /* Pointer to the file path */
3249:                PF_BYTE value, /* Attribute bits */
3250:                PF_BYTE mask /* Attribute mask to change */
3251:                ) {
9D00341C  27BDFFB8   ADDIU SP, SP, -72
9D003420  AFBF0044   SW RA, 68(SP)
9D003424  AFB10040   SW S1, 64(SP)
9D003428  AFB0003C   SW S0, 60(SP)
9D00342C  AFA40048   SW A0, 72(SP)
9D003430  30B100FF   ANDI S1, A1, 255
9D003434  30D000FF   ANDI S0, A2, 255
3252:                	FRESULT res;
3253:                	DIR dj;
3254:                	PF_BYTE *dir;
3255:                	DEF_NAMEBUF;
3256:                
3257:                	res = chk_mounted(&path, &dj.fs, 1);
9D003438  27A40048   ADDIU A0, SP, 72
9D00343C  27A50010   ADDIU A1, SP, 16
9D003440  0F400529   JAL chk_mounted
9D003444  24060001   ADDIU A2, ZERO, 1
3258:                	if (res == FR_OK) {
9D003448  1440001B   BNE V0, ZERO, 0x9D0034B8
9D00344C  8FBF0044   LW RA, 68(SP)
3259:                		INIT_BUF(dj);
9D003450  27A2002C   ADDIU V0, SP, 44
9D003454  AFA20028   SW V0, 40(SP)
3260:                		res = follow_path(&dj, path); /* Follow the file path */
9D003458  27A40010   ADDIU A0, SP, 16
9D00345C  0F40037C   JAL follow_path
9D003460  8FA50048   LW A1, 72(SP)
3261:                		FREE_BUF();
3262:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D003464  14400014   BNE V0, ZERO, 0x9D0034B8
9D003468  8FBF0044   LW RA, 68(SP)
9D00346C  8FA20028   LW V0, 40(SP)
9D003470  9042000B   LBU V0, 11(V0)
9D003474  30420020   ANDI V0, V0, 32
9D003478  10400013   BEQ V0, ZERO, 0x9D0034C8
9D00347C  8FA30024   LW V1, 36(SP)
3263:                			res = FR_INVALID_NAME;
9D003480  0B400D2D   J 0x9D0034B4
9D003484  24020006   ADDIU V0, ZERO, 6
3264:                		if (res == FR_OK) {
3265:                			dir = dj.dir;
3266:                			if (!dir) { /* Is it a root directory? */
9D0034C8  1460FFEF   BNE V1, ZERO, 0x9D003488
9D0034CC  24020006   ADDIU V0, ZERO, 6
3267:                				res = FR_INVALID_NAME;
3268:                			} else { /* File or sub directory */
3269:                				mask &= AM_RDO | AM_HID | AM_SYS | AM_ARC; /* Valid attribute mask */
9D003488  32100027   ANDI S0, S0, 39
3270:                				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr]
9D003490  9062000B   LBU V0, 11(V1)
9D003494  00821024   AND V0, A0, V0
9D003498  02118024   AND S0, S0, S1
9D00349C  00508025   OR S0, V0, S0
9D0034A0  A070000B   SB S0, 11(V1)
3271:                						& (PF_BYTE) ~mask); /* Apply attribute change */
9D00348C  00102027   NOR A0, ZERO, S0
3272:                				dj.fs->wflag = 1;
9D0034A4  8FA40010   LW A0, 16(SP)
9D0034A8  24020001   ADDIU V0, ZERO, 1
3273:                				res = sync(dj.fs);
9D0034AC  0F4000F1   JAL sync
9D0034B0  A0820004   SB V0, 4(A0)
3274:                			}
3275:                		}
3276:                	}
3277:                
3278:                	LEAVE_FF(dj.fs, res);
3279:                }
9D0034B4  8FBF0044   LW RA, 68(SP)
9D0034B8  8FB10040   LW S1, 64(SP)
9D0034BC  8FB0003C   LW S0, 60(SP)
9D0034C0  03E00008   JR RA
9D0034C4  27BD0048   ADDIU SP, SP, 72
9D0034D0  0B400D2E   J 0x9D0034B8
9D0034D4  8FBF0044   LW RA, 68(SP)
3280:                
3281:                /*-----------------------------------------------------------------------*/
3282:                /* Change Timestamp                                                      */
3283:                /*-----------------------------------------------------------------------*/
3284:                
3285:                FRESULT f_utime(const TCHAR *path, /* Pointer to the file/directory name */
3286:                const FILINFO *fno /* Pointer to the time stamp to be set */
3287:                ) {
9D0034D8  27BDFFC0   ADDIU SP, SP, -64
9D0034DC  AFBF003C   SW RA, 60(SP)
9D0034E0  AFB00038   SW S0, 56(SP)
9D0034E4  AFA40040   SW A0, 64(SP)
9D0034E8  00A08021   ADDU S0, A1, ZERO
3288:                	FRESULT res;
3289:                	DIR dj;
3290:                	PF_BYTE *dir;
3291:                	DEF_NAMEBUF;
3292:                
3293:                	res = chk_mounted(&path, &dj.fs, 1);
9D0034EC  27A40040   ADDIU A0, SP, 64
9D0034F0  27A50010   ADDIU A1, SP, 16
9D0034F4  0F400529   JAL chk_mounted
9D0034F8  24060001   ADDIU A2, ZERO, 1
3294:                	if (res == FR_OK) {
9D0034FC  1440001E   BNE V0, ZERO, 0x9D003578
9D003500  8FBF003C   LW RA, 60(SP)
3295:                		INIT_BUF(dj);
9D003504  27A2002C   ADDIU V0, SP, 44
9D003508  AFA20028   SW V0, 40(SP)
3296:                		res = follow_path(&dj, path); /* Follow the file path */
9D00350C  27A40010   ADDIU A0, SP, 16
9D003510  0F40037C   JAL follow_path
9D003514  8FA50040   LW A1, 64(SP)
3297:                		FREE_BUF();
3298:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D003518  14400017   BNE V0, ZERO, 0x9D003578
9D00351C  8FBF003C   LW RA, 60(SP)
9D003520  8FA20028   LW V0, 40(SP)
9D003524  9042000B   LBU V0, 11(V0)
9D003528  30420020   ANDI V0, V0, 32
9D00352C  10400015   BEQ V0, ZERO, 0x9D003584
9D003530  8FA30024   LW V1, 36(SP)
3299:                			res = FR_INVALID_NAME;
9D003534  0B400D5D   J 0x9D003574
9D003538  24020006   ADDIU V0, ZERO, 6
3300:                		if (res == FR_OK) {
3301:                			dir = dj.dir;
3302:                			if (!dir) { /* Root directory */
9D003584  1460FFED   BNE V1, ZERO, 0x9D00353C
9D003588  24020006   ADDIU V0, ZERO, 6
3303:                				res = FR_INVALID_NAME;
3304:                			} else { /* File or sub-directory */
3305:                				ST_WORD(dir+DIR_WrtTime, fno->ftime);
9D00353C  96020006   LHU V0, 6(S0)
9D003540  A0620016   SB V0, 22(V1)
9D003544  96020006   LHU V0, 6(S0)
9D003548  00021202   SRL V0, V0, 8
9D00354C  A0620017   SB V0, 23(V1)
3306:                				ST_WORD(dir+DIR_WrtDate, fno->fdate);
9D003550  96020004   LHU V0, 4(S0)
9D003554  A0620018   SB V0, 24(V1)
9D003558  96020004   LHU V0, 4(S0)
9D00355C  00021202   SRL V0, V0, 8
9D003560  A0620019   SB V0, 25(V1)
3307:                				dj.fs->wflag = 1;
9D003564  8FA40010   LW A0, 16(SP)
9D003568  24020001   ADDIU V0, ZERO, 1
3308:                				res = sync(dj.fs);
9D00356C  0F4000F1   JAL sync
9D003570  A0820004   SB V0, 4(A0)
3309:                			}
3310:                		}
3311:                	}
3312:                
3313:                	LEAVE_FF(dj.fs, res);
3314:                }
9D003574  8FBF003C   LW RA, 60(SP)
9D003578  8FB00038   LW S0, 56(SP)
9D00357C  03E00008   JR RA
9D003580  27BD0040   ADDIU SP, SP, 64
9D00358C  0B400D5E   J 0x9D003578
9D003590  8FBF003C   LW RA, 60(SP)
3315:                
3316:                /*-----------------------------------------------------------------------*/
3317:                /* Rename File/Directory                                                 */
3318:                /*-----------------------------------------------------------------------*/
3319:                
3320:                FRESULT f_rename(const TCHAR *path_old, /* Pointer to the old name */
3321:                const TCHAR *path_new /* Pointer to the new name */
3322:                ) {
9D003594  27BDFF80   ADDIU SP, SP, -128
9D003598  AFBF007C   SW RA, 124(SP)
9D00359C  AFB10078   SW S1, 120(SP)
9D0035A0  AFB00074   SW S0, 116(SP)
9D0035A4  AFA40080   SW A0, 128(SP)
9D0035A8  00A08021   ADDU S0, A1, ZERO
3323:                	FRESULT res;
3324:                	DIR djo, djn;
3325:                	PF_BYTE buf[21], *dir;
3326:                	DWORD dw;
3327:                	DEF_NAMEBUF;
3328:                
3329:                	res = chk_mounted(&path_old, &djo.fs, 1);
9D0035AC  27A40080   ADDIU A0, SP, 128
9D0035B0  27A50010   ADDIU A1, SP, 16
9D0035B4  0F400529   JAL chk_mounted
9D0035B8  24060001   ADDIU A2, ZERO, 1
3330:                	if (res == FR_OK) {
9D0035BC  14400069   BNE V0, ZERO, 0x9D003764
9D0035C0  8FBF007C   LW RA, 124(SP)
3331:                		djn.fs = djo.fs;
9D0035C4  8FA20010   LW V0, 16(SP)
9D0035C8  AFA2002C   SW V0, 44(SP)
3332:                		INIT_BUF(djo);
9D0035CC  27A20060   ADDIU V0, SP, 96
9D0035D0  AFA20028   SW V0, 40(SP)
3333:                		res = follow_path(&djo, path_old); /* Check old object */
9D0035D4  27A40010   ADDIU A0, SP, 16
9D0035D8  0F40037C   JAL follow_path
9D0035DC  8FA50080   LW A1, 128(SP)
3334:                		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
9D0035E0  14400060   BNE V0, ZERO, 0x9D003764
9D0035E4  8FBF007C   LW RA, 124(SP)
9D0035E8  8FA20028   LW V0, 40(SP)
9D0035EC  9042000B   LBU V0, 11(V0)
9D0035F0  30420020   ANDI V0, V0, 32
9D0035F4  5040005F   BEQL V0, ZERO, 0x9D003774
9D0035F8  8FA50024   LW A1, 36(SP)
3335:                			res = FR_INVALID_NAME;
9D0035FC  0B400DD8   J 0x9D003760
9D003600  24020006   ADDIU V0, ZERO, 6
3336:                #if _FS_SHARE
3337:                		if (res == FR_OK) res = chk_lock(&djo, 2);
3338:                #endif
3339:                		if (res == FR_OK) { /* Old object is found */
3340:                			if (!djo.dir) { /* Is root dir? */
9D003774  14A0FFA3   BNE A1, ZERO, 0x9D003604
9D003778  24020004   ADDIU V0, ZERO, 4
3341:                				res = FR_NO_FILE;
3342:                			} else {
3343:                				mem_cpy(buf, djo.dir + DIR_Attr, 21); /* Save the object information except for name */
9D003604  27A40048   ADDIU A0, SP, 72
9D003608  24A5000B   ADDIU A1, A1, 11
9D00360C  0F400000   JAL mem_cpy
9D003610  24060015   ADDIU A2, ZERO, 21
3344:                				mem_cpy(&djn, &djo, sizeof(DIR)); /* Check new object */
9D003614  27A4002C   ADDIU A0, SP, 44
9D003618  27A50010   ADDIU A1, SP, 16
9D00361C  0F400000   JAL mem_cpy
9D003620  2406001C   ADDIU A2, ZERO, 28
3345:                				res = follow_path(&djn, path_new);
9D003624  27A4002C   ADDIU A0, SP, 44
9D003628  0F40037C   JAL follow_path
9D00362C  02002821   ADDU A1, S0, ZERO
3346:                				if (res == FR_OK)
9D003630  5040004B   BEQL V0, ZERO, 0x9D003760
9D003634  24020008   ADDIU V0, ZERO, 8
3347:                					res = FR_EXIST; /* The new object name is already existing */
3348:                				if (res == FR_NO_FILE) { /* Is it a valid path and no name collision? */
9D003638  24030004   ADDIU V1, ZERO, 4
9D00363C  14430049   BNE V0, V1, 0x9D003764
9D003640  8FBF007C   LW RA, 124(SP)
3349:                					/* Start critical section that any interruption or error can cause cross-link */
3350:                					res = dir_register(&djn); /* Register the new entry */
9D003644  0F400495   JAL dir_register
9D003648  27A4002C   ADDIU A0, SP, 44
3351:                					if (res == FR_OK) {
9D00364C  14400045   BNE V0, ZERO, 0x9D003764
9D003650  8FBF007C   LW RA, 124(SP)
3352:                						dir = djn.dir; /* Copy object information except for name */
9D003654  8FB00040   LW S0, 64(SP)
3353:                						mem_cpy(dir + 13, buf + 2, 19);
9D003658  2604000D   ADDIU A0, S0, 13
9D00365C  27A5004A   ADDIU A1, SP, 74
9D003660  0F400000   JAL mem_cpy
9D003664  24060013   ADDIU A2, ZERO, 19
3354:                						dir[DIR_Attr] = buf[0] | AM_ARC;
9D003668  93A20048   LBU V0, 72(SP)
9D00366C  34420020   ORI V0, V0, 32
9D003670  A202000B   SB V0, 11(S0)
3355:                						djo.fs->wflag = 1;
9D003674  24030001   ADDIU V1, ZERO, 1
9D003678  8FA20010   LW V0, 16(SP)
9D00367C  A0430004   SB V1, 4(V0)
3356:                						if (djo.sclust != djn.sclust
9D003680  8FA20034   LW V0, 52(SP)
9D003684  8FA30018   LW V1, 24(SP)
9D003688  1062002D   BEQ V1, V0, 0x9D003740
9D00368C  00000000   NOP
3357:                								&& (dir[DIR_Attr] & AM_DIR)) { /* Update .. entry in the directory if needed */
9D003690  9202000B   LBU V0, 11(S0)
9D003694  30420010   ANDI V0, V0, 16
9D003698  10400029   BEQ V0, ZERO, 0x9D003740
9D00369C  8FB1002C   LW S1, 44(SP)
3358:                							dw = clust2sect(djn.fs, LD_CLUST(dir));
9D0036A0  92050015   LBU A1, 21(S0)
9D0036A4  00052A00   SLL A1, A1, 8
9D0036A8  92020014   LBU V0, 20(S0)
9D0036AC  00A22825   OR A1, A1, V0
9D0036B0  00052C00   SLL A1, A1, 16
9D0036B4  9203001B   LBU V1, 27(S0)
9D0036B8  00031A00   SLL V1, V1, 8
9D0036BC  9202001A   LBU V0, 26(S0)
9D0036C0  00621025   OR V0, V1, V0
9D0036C4  02202021   ADDU A0, S1, ZERO
9D0036C8  0F40014E   JAL clust2sect
9D0036CC  00A22825   OR A1, A1, V0
9D0036D0  00402821   ADDU A1, V0, ZERO
3359:                							if (!dw) {
9D0036D4  10A00022   BEQ A1, ZERO, 0x9D003760
9D0036D8  24020002   ADDIU V0, ZERO, 2
3360:                								res = FR_INT_ERR;
3361:                							} else {
3362:                								res = move_window(djn.fs, dw);
9D0036DC  0F40007A   JAL move_window
9D0036E0  02202021   ADDU A0, S1, ZERO
3363:                								dir = djn.fs->win + SZ_DIR; /* .. entry */
3364:                								if (res == FR_OK && dir[1] == '.') {
9D0036E4  1440001E   BNE V0, ZERO, 0x9D003760
9D0036E8  8FA3002C   LW V1, 44(SP)
9D0036EC  90640055   LBU A0, 85(V1)
9D0036F0  2402002E   ADDIU V0, ZERO, 46
9D0036F4  14820012   BNE A0, V0, 0x9D003740
9D0036F8  24020003   ADDIU V0, ZERO, 3
3365:                									dw
3366:                											= (djn.fs->fs_type == FS_FAT32
3367:                													&& djn.sclust
3368:                															== djn.fs->dirbase) ? 0
3369:                													: djn.sclust;
9D0036FC  90640000   LBU A0, 0(V1)
9D003700  14820006   BNE A0, V0, 0x9D00371C
9D003704  8FA20034   LW V0, 52(SP)
9D003708  8C640028   LW A0, 40(V1)
9D00370C  8FA50034   LW A1, 52(SP)
9D003710  10A40002   BEQ A1, A0, 0x9D00371C
9D003714  00001021   ADDU V0, ZERO, ZERO
9D003718  8FA20034   LW V0, 52(SP)
3370:                									ST_CLUST(dir, dw);
9D00371C  A062006E   SB V0, 110(V1)
9D003720  7C443A00   EXT A0, V0, 8, 8
9D003724  A064006F   SB A0, 111(V1)
9D003728  00021402   SRL V0, V0, 16
9D00372C  A0620068   SB V0, 104(V1)
9D003730  00021202   SRL V0, V0, 8
9D003734  A0620069   SB V0, 105(V1)
3371:                									djn.fs->wflag = 1;
9D003738  24020001   ADDIU V0, ZERO, 1
9D00373C  A0620004   SB V0, 4(V1)
3372:                								}
3373:                							}
3374:                						}
3375:                						if (res == FR_OK) {
3376:                							res = dir_remove(&djo); /* Remove old entry */
9D003740  0F400214   JAL dir_remove
9D003744  27A40010   ADDIU A0, SP, 16
3377:                							if (res == FR_OK)
9D003748  54400006   BNEL V0, ZERO, 0x9D003764
9D00374C  8FBF007C   LW RA, 124(SP)
3378:                								res = sync(djo.fs);
9D003750  0F4000F1   JAL sync
9D003754  8FA40010   LW A0, 16(SP)
3379:                						}
3380:                					}
3381:                					/* End critical section */
3382:                				}
3383:                			}
3384:                		}FREE_BUF();
3385:                	}
3386:                	LEAVE_FF(djo.fs, res);
3387:                }
9D003758  0B400DD9   J 0x9D003764
9D00375C  8FBF007C   LW RA, 124(SP)
9D003760  8FBF007C   LW RA, 124(SP)
9D003764  8FB10078   LW S1, 120(SP)
9D003768  8FB00074   LW S0, 116(SP)
9D00376C  03E00008   JR RA
9D003770  27BD0080   ADDIU SP, SP, 128
9D00377C  0B400DD9   J 0x9D003764
9D003780  8FBF007C   LW RA, 124(SP)
3388:                
3389:                #endif /* !_FS_READONLY */
3390:                #endif /* _FS_MINIMIZE == 0 */
3391:                #endif /* _FS_MINIMIZE <= 1 */
3392:                #endif /* _FS_MINIMIZE <= 2 */
3393:                
3394:                /*-----------------------------------------------------------------------*/
3395:                /* Forward data to the stream directly (available on only tiny cfg)      */
3396:                /*-----------------------------------------------------------------------*/
3397:                #if _USE_FORWARD && _FS_TINY
3398:                
3399:                FRESULT f_forward (
3400:                		FIL *fp, /* Pointer to the file object */
3401:                		UINT (*func)(const PF_BYTE*,UINT), /* Pointer to the streaming function */
3402:                		UINT btr, /* Number of bytes to forward */
3403:                		UINT *bf /* Pointer to number of bytes forwarded */
3404:                )
3405:                {
3406:                	FRESULT res;
3407:                	DWORD remain, clst, sect;
3408:                	UINT rcnt;
3409:                	PF_BYTE csect;
3410:                
3411:                	*bf = 0; /* Initialize byte counter */
3412:                
3413:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
3414:                	if (res != FR_OK) LEAVE_FF(fp->fs, res);
3415:                	if (fp->flag & FA__ERROR) /* Check error flag */
3416:                	LEAVE_FF(fp->fs, FR_INT_ERR);
3417:                	if (!(fp->flag & FA_READ)) /* Check access mode */
3418:                	LEAVE_FF(fp->fs, FR_DENIED);
3419:                
3420:                	remain = fp->fsize - fp->fptr;
3421:                	if (btr > remain) btr = (UINT)remain; /* Truncate btr by remaining bytes */
3422:                
3423:                	for (; btr && (*func)(0, 0); /* Repeat until all data transferred or stream becomes busy */
3424:                			fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
3425:                		csect = (PF_BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
3426:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
3427:                			if (!csect) { /* On the cluster boundary? */
3428:                				clst = (fp->fptr == 0) ? /* On the top of the file? */
3429:                				fp->sclust : get_fat(fp->fs, fp->clust);
3430:                				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
3431:                				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
3432:                				fp->clust = clst; /* Update current cluster */
3433:                			}
3434:                		}
3435:                		sect = clust2sect(fp->fs, fp->clust); /* Get current data sector */
3436:                		if (!sect) ABORT(fp->fs, FR_INT_ERR);
3437:                		sect += csect;
3438:                		if (move_window(fp->fs, sect)) /* Move sector window */
3439:                		ABORT(fp->fs, FR_DISK_ERR);
3440:                		fp->dsect = sect;
3441:                		rcnt = SS(fp->fs) - (PF_WORD)(fp->fptr % SS(fp->fs)); /* Forward data from sector window */
3442:                		if (rcnt > btr) rcnt = btr;
3443:                		rcnt = (*func)(&fp->fs->win[(PF_WORD)fp->fptr % SS(fp->fs)], rcnt);
3444:                		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
3445:                	}
3446:                
3447:                	LEAVE_FF(fp->fs, FR_OK);
3448:                }
3449:                #endif /* _USE_FORWARD */
3450:                
3451:                #if _USE_MKFS && !_FS_READONLY
3452:                /*-----------------------------------------------------------------------*/
3453:                /* Create File System on the Drive                                       */
3454:                /*-----------------------------------------------------------------------*/
3455:                #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
3456:                #define N_FATS		1		/* Number of FAT copies (1 or 2) */
3457:                
3458:                FRESULT f_mkfs (
3459:                		PF_BYTE drv, /* Logical drive number */
3460:                		PF_BYTE sfd, /* Partitioning rule 0:FDISK, 1:SFD */
3461:                		UINT au /* Allocation unit size [bytes] */
3462:                )
3463:                {
3464:                	static const PF_WORD vst[] = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0};
3465:                	static const PF_WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
3466:                	PF_BYTE fmt, md, sys, *tbl, pdrv, part;
3467:                	DWORD n_clst, vs, n, wsect;
3468:                	UINT i;
3469:                	DWORD b_vol, b_fat, b_dir, b_data; /* LBA */
3470:                	DWORD n_vol, n_rsv, n_fat, n_dir; /* Size */
3471:                	FATFS *fs;
3472:                	DSTATUS stat;
3473:                
3474:                	/* Check mounted drive and clear work area */
3475:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
3476:                	if (sfd > 1) return FR_INVALID_PARAMETER;
3477:                	if (au & (au - 1)) return FR_INVALID_PARAMETER;
3478:                	fs = FatFs[drv];
3479:                	if (!fs) return FR_NOT_ENABLED;
3480:                	fs->fs_type = 0;
3481:                	pdrv = LD2PD(drv); /* Physical drive */
3482:                	part = LD2PT(drv); /* Partition (0:auto detect, 1-4:get from partition table)*/
3483:                
3484:                	/* Get disk statics */
3485:                	stat = disk_initialize(pdrv);
3486:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3487:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3488:                #if _MAX_SS != 512					/* Get disk sector size */
3489:                	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
3490:                	return FR_DISK_ERR;
3491:                #endif
3492:                	if (_MULTI_PARTITION && part) {
3493:                		/* Get partition information from partition table in the MBR */
3494:                		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3495:                		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
3496:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3497:                		if (!tbl[4]) return FR_MKFS_ABORTED; /* No partition? */
3498:                		b_vol = LD_DWORD(tbl+8); /* Volume start sector */
3499:                		n_vol = LD_DWORD(tbl+12); /* Volume size */
3500:                	} else {
3501:                		/* Create a partition in this function */
3502:                		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
3503:                		return FR_DISK_ERR;
3504:                		b_vol = (sfd) ? 0 : 63; /* Volume start sector */
3505:                		n_vol -= b_vol; /* Volume size */
3506:                	}
3507:                
3508:                	if (!au) { /* AU auto selection */
3509:                		vs = n_vol / (2000 / (SS(fs) / 512));
3510:                		for (i = 0; vs < vst[i]; i++);
3511:                		au = cst[i];
3512:                	}
3513:                	au /= SS(fs); /* Number of sectors per cluster */
3514:                	if (au == 0) au = 1;
3515:                	if (au > 128) au = 128;
3516:                
3517:                	/* Pre-compute number of clusters and FAT syb-type */
3518:                	n_clst = n_vol / au;
3519:                	fmt = FS_FAT12;
3520:                	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
3521:                	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
3522:                
3523:                	/* Determine offset and size of FAT structure */
3524:                	if (fmt == FS_FAT32) {
3525:                		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
3526:                		n_rsv = 32;
3527:                		n_dir = 0;
3528:                	} else {
3529:                		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
3530:                		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
3531:                		n_rsv = 1;
3532:                		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
3533:                	}
3534:                	b_fat = b_vol + n_rsv; /* FAT area start sector */
3535:                	b_dir = b_fat + n_fat * N_FATS; /* Directory area start sector */
3536:                	b_data = b_dir + n_dir; /* Data area start sector */
3537:                	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED; /* Too small volume */
3538:                
3539:                	/* Align data start sector to erase block boundary (for flash memory media) */
3540:                	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
3541:                	n = (b_data + n - 1) & ~(n - 1); /* Next nearest erase block from current data start */
3542:                	n = (n - b_data) / N_FATS;
3543:                	if (fmt == FS_FAT32) { /* FAT32: Move FAT offset */
3544:                		n_rsv += n;
3545:                		b_fat += n;
3546:                	} else { /* FAT12/16: Expand FAT size */
3547:                		n_fat += n;
3548:                	}
3549:                
3550:                	/* Determine number of clusters and final check of validity of the FAT sub-type */
3551:                	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
3552:                	if ( (fmt == FS_FAT16 && n_clst < MIN_FAT16)
3553:                			|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
3554:                	return FR_MKFS_ABORTED;
3555:                
3556:                	switch (fmt) { /* Determine system ID for partition table */
3557:                		case FS_FAT12: sys = 0x01; break;
3558:                		case FS_FAT16: sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
3559:                		default: sys = 0x0C;
3560:                	}
3561:                
3562:                	if (_MULTI_PARTITION && part) {
3563:                		/* Update system ID in the partition table */
3564:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3565:                		tbl[4] = sys;
3566:                		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3567:                		md = 0xF8;
3568:                	} else {
3569:                		if (sfd) { /* No patition table (SFD) */
3570:                			md = 0xF0;
3571:                		} else { /* Create partition table (FDISK) */
3572:                			mem_set(fs->win, 0, SS(fs));
3573:                			tbl = fs->win+MBR_Table; /* Create partiton table for single partition in the drive */
3574:                			tbl[1] = 1; /* Partition start head */
3575:                			tbl[2] = 1; /* Partition start sector */
3576:                			tbl[3] = 0; /* Partition start cylinder */
3577:                			tbl[4] = sys; /* System type */
3578:                			tbl[5] = 254; /* Partition end head */
3579:                			n = (b_vol + n_vol) / 63 / 255;
3580:                			tbl[6] = (PF_BYTE)((n >> 2) | 63); /* Partiiton end sector */
3581:                			tbl[7] = (PF_BYTE)n; /* End cylinder */
3582:                			ST_DWORD(tbl+8, 63); /* Partition start in LBA */
3583:                			ST_DWORD(tbl+12, n_vol); /* Partition size in LBA */
3584:                			ST_WORD(fs->win+BS_55AA, 0xAA55); /* MBR signature */
3585:                			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) /* Write it to the MBR sector */
3586:                			return FR_DISK_ERR;
3587:                			md = 0xF8;
3588:                		}
3589:                	}
3590:                
3591:                	/* Create BPB in the VBR */
3592:                	tbl = fs->win; /* Clear sector */
3593:                	mem_set(tbl, 0, SS(fs));
3594:                	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
3595:                	i = SS(fs); /* Sector size */
3596:                	ST_WORD(tbl+BPB_BytsPerSec, i);
3597:                	tbl[BPB_SecPerClus] = (PF_BYTE)au; /* Sectors per cluster */
3598:                	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv); /* Reserved sectors */
3599:                	tbl[BPB_NumFATs] = N_FATS; /* Number of FATs */
3600:                	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR; /* Number of rootdir entries */
3601:                	ST_WORD(tbl+BPB_RootEntCnt, i);
3602:                	if (n_vol < 0x10000) { /* Number of total sectors */
3603:                		ST_WORD(tbl+BPB_TotSec16, n_vol);
3604:                	} else {
3605:                		ST_DWORD(tbl+BPB_TotSec32, n_vol);
3606:                	}
3607:                	tbl[BPB_Media] = md; /* Media descriptor */
3608:                	ST_WORD(tbl+BPB_SecPerTrk, 63); /* Number of sectors per track */
3609:                	ST_WORD(tbl+BPB_NumHeads, 255); /* Number of heads */
3610:                	ST_DWORD(tbl+BPB_HiddSec, b_vol); /* Hidden sectors */
3611:                	n = get_fattime(); /* Use current time as VSN */
3612:                	if (fmt == FS_FAT32) {
3613:                		ST_DWORD(tbl+BS_VolID32, n); /* VSN */
3614:                		ST_DWORD(tbl+BPB_FATSz32, n_fat); /* Number of sectors per FAT */
3615:                		ST_DWORD(tbl+BPB_RootClus, 2); /* Root directory start cluster (2) */
3616:                		ST_WORD(tbl+BPB_FSInfo, 1); /* FSInfo record offset (VBR+1) */
3617:                		ST_WORD(tbl+BPB_BkBootSec, 6); /* Backup boot record offset (VBR+6) */
3618:                		tbl[BS_DrvNum32] = 0x80; /* Drive number */
3619:                		tbl[BS_BootSig32] = 0x29; /* Extended boot signature */
3620:                		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19); /* Volume label, FAT signature */
3621:                	} else {
3622:                		ST_DWORD(tbl+BS_VolID, n); /* VSN */
3623:                		ST_WORD(tbl+BPB_FATSz16, n_fat); /* Number of sectors per FAT */
3624:                		tbl[BS_DrvNum] = 0x80; /* Drive number */
3625:                		tbl[BS_BootSig] = 0x29; /* Extended boot signature */
3626:                		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19); /* Volume label, FAT signature */
3627:                	}
3628:                	ST_WORD(tbl+BS_55AA, 0xAA55); /* Signature (Offset is fixed here regardless of sector size) */
3629:                	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK) /* Write it to the VBR sector */
3630:                	return FR_DISK_ERR;
3631:                	if (fmt == FS_FAT32) /* Write backup VBR if needed (VBR+6) */
3632:                	disk_write(pdrv, tbl, b_vol + 6, 1);
3633:                
3634:                	/* Initialize FAT area */
3635:                	wsect = b_fat;
3636:                	for (i = 0; i < N_FATS; i++) { /* Initialize each FAT copy */
3637:                		mem_set(tbl, 0, SS(fs)); /* 1st sector of the FAT  */
3638:                		n = md; /* Media descriptor byte */
3639:                		if (fmt != FS_FAT32) {
3640:                			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
3641:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT12/16) */
3642:                		} else {
3643:                			n |= 0xFFFFFF00;
3644:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT32) */
3645:                			ST_DWORD(tbl+4, 0xFFFFFFFF);
3646:                			ST_DWORD(tbl+8, 0x0FFFFFFF); /* Reserve cluster #2 for root dir */
3647:                		}
3648:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3649:                		return FR_DISK_ERR;
3650:                		mem_set(tbl, 0, SS(fs)); /* Fill following FAT entries with zero */
3651:                		for (n = 1; n < n_fat; n++) { /* This loop may take a time on FAT32 volume due to many single sector writes */
3652:                			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3653:                			return FR_DISK_ERR;
3654:                		}
3655:                	}
3656:                
3657:                	/* Initialize root directory */
3658:                	i = (fmt == FS_FAT32) ? au : n_dir;
3659:                	do {
3660:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3661:                		return FR_DISK_ERR;
3662:                	}while (--i);
3663:                
3664:                #if _USE_ERASE	/* Erase data area if needed */
3665:                	{
3666:                		DWORD eb[2];
3667:                
3668:                		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
3669:                		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
3670:                	}
3671:                #endif
3672:                
3673:                	/* Create FSInfo if needed */
3674:                	if (fmt == FS_FAT32) {
3675:                		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
3676:                		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
3677:                		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1); /* Number of free clusters */
3678:                		ST_DWORD(tbl+FSI_Nxt_Free, 2); /* Last allocated cluster# */
3679:                		ST_WORD(tbl+BS_55AA, 0xAA55);
3680:                		disk_write(pdrv, tbl, b_vol + 1, 1); /* Write original (VBR+1) */
3681:                		disk_write(pdrv, tbl, b_vol + 7, 1); /* Write backup (VBR+7) */
3682:                	}
3683:                
3684:                	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
3685:                }
3686:                
3687:                #if _MULTI_PARTITION == 2
3688:                /*-----------------------------------------------------------------------*/
3689:                /* Divide Physical Drive                                                 */
3690:                /*-----------------------------------------------------------------------*/
3691:                
3692:                FRESULT f_fdisk (
3693:                		PF_BYTE pdrv, /* Physical drive number */
3694:                		const DWORD szt[], /* Pointer to the size table for each partitions */
3695:                		void* work /* Pointer to the working buffer */
3696:                )
3697:                {
3698:                	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
3699:                	PF_BYTE s_hd, e_hd, *p, *buf = (PF_BYTE*)work;
3700:                	DSTATUS stat;
3701:                	DWORD sz_disk, sz_part, s_part;
3702:                
3703:                	stat = disk_initialize(pdrv);
3704:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3705:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3706:                	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
3707:                
3708:                	/* Determine CHS in the table regardless of the drive geometry */
3709:                	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2);
3710:                	if (n == 256) n--;
3711:                	e_hd = n - 1;
3712:                	sz_cyl = 63 * n;
3713:                	tot_cyl = sz_disk / sz_cyl;
3714:                
3715:                	/* Create partition table */
3716:                	mem_set(buf, 0, _MAX_SS);
3717:                	p = buf + MBR_Table; b_cyl = 0;
3718:                	for (i = 0; i < 4; i++, p += SZ_PTE) {
3719:                		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
3720:                		if (!p_cyl) continue;
3721:                		s_part = (DWORD)sz_cyl * b_cyl;
3722:                		sz_part = (DWORD)sz_cyl * p_cyl;
3723:                		if (i == 0) { /* Exclude first track of cylinder 0 */
3724:                			s_hd = 1;
3725:                			s_part += 63; sz_part -= 63;
3726:                		} else {
3727:                			s_hd = 0;
3728:                		}
3729:                		e_cyl = b_cyl + p_cyl - 1;
3730:                		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
3731:                
3732:                		/* Set partition table */
3733:                		p[1] = s_hd; /* Start head */
3734:                		p[2] = (PF_BYTE)((b_cyl >> 2) + 1); /* Start sector */
3735:                		p[3] = (PF_BYTE)b_cyl; /* Start cylinder */
3736:                		p[4] = 0x06; /* System type (temporary setting) */
3737:                		p[5] = e_hd; /* End head */
3738:                		p[6] = (PF_BYTE)((e_cyl >> 2) + 63); /* End sector */
3739:                		p[7] = (PF_BYTE)e_cyl; /* End cylinder */
3740:                		ST_DWORD(p + 8, s_part); /* Start sector in LBA */
3741:                		ST_DWORD(p + 12, sz_part); /* Partition size */
3742:                
3743:                		/* Next partition */
3744:                		b_cyl += p_cyl;
3745:                	}
3746:                	ST_WORD(p, 0xAA55);
3747:                
3748:                	/* Write it to the MBR */
3749:                	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
3750:                }
3751:                
3752:                #endif /* _MULTI_PARTITION == 2 */
3753:                #endif /* _USE_MKFS && !_FS_READONLY */
3754:                
3755:                #if _USE_STRFUNC
3756:                /*-----------------------------------------------------------------------*/
3757:                /* Get a string from the file                                            */
3758:                /*-----------------------------------------------------------------------*/
3759:                TCHAR* f_gets (
3760:                		TCHAR* buff, /* Pointer to the string buffer to read */
3761:                		int len, /* Size of string buffer (characters) */
3762:                		FIL* fil /* Pointer to the file object */
3763:                )
3764:                {
3765:                	int n = 0;
3766:                	TCHAR c, *p = buff;
3767:                	PF_BYTE s[2];
3768:                	UINT rc;
3769:                
3770:                	while (n < len - 1) { /* Read bytes until buffer gets filled */
3771:                		f_read(fil, s, 1, &rc);
3772:                		if (rc != 1) break; /* Break on EOF or error */
3773:                		c = s[0];
3774:                #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
3775:                		if (c >= 0x80) {
3776:                			if (c < 0xC0) continue; /* Skip stray trailer */
3777:                			if (c < 0xE0) { /* Two-byte sequense */
3778:                				f_read(fil, s, 1, &rc);
3779:                				if (rc != 1) break;
3780:                				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
3781:                				if (c < 0x80) c = '?';
3782:                			} else {
3783:                				if (c < 0xF0) { /* Three-byte sequense */
3784:                					f_read(fil, s, 2, &rc);
3785:                					if (rc != 2) break;
3786:                					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
3787:                					if (c < 0x800) c = '?';
3788:                				} else { /* Reject four-byte sequense */
3789:                					c = '?';
3790:                				}
3791:                			}
3792:                		}
3793:                #endif
3794:                #if _USE_STRFUNC >= 2
3795:                		if (c == '\r') continue; /* Strip '\r' */
3796:                #endif
3797:                		*p++ = c;
3798:                		n++;
3799:                		if (c == '\n') break; /* Break on EOL */
3800:                	}
3801:                	*p = 0;
3802:                	return n ? buff : 0; /* When no data read (eof or error), return with error. */
3803:                }
3804:                
3805:                #if !_FS_READONLY
3806:                #include <stdarg.h>
3807:                /*-----------------------------------------------------------------------*/
3808:                /* Put a character to the file                                           */
3809:                /*-----------------------------------------------------------------------*/
3810:                int f_putc (
3811:                		TCHAR c, /* A character to be output */
3812:                		FIL* fil /* Pointer to the file object */
3813:                )
3814:                {
3815:                	UINT bw, btw;
3816:                	PF_BYTE s[3];
3817:                
3818:                #if _USE_STRFUNC >= 2
3819:                	if (c == '\n') f_putc ('\r', fil); /* LF -> CRLF conversion */
3820:                #endif
3821:                
3822:                #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
3823:                	if (c < 0x80) { /* 7-bit */
3824:                		s[0] = (PF_BYTE)c;
3825:                		btw = 1;
3826:                	} else {
3827:                		if (c < 0x800) { /* 11-bit */
3828:                			s[0] = (PF_BYTE)(0xC0 | (c >> 6));
3829:                			s[1] = (PF_BYTE)(0x80 | (c & 0x3F));
3830:                			btw = 2;
3831:                		} else { /* 16-bit */
3832:                			s[0] = (PF_BYTE)(0xE0 | (c >> 12));
3833:                			s[1] = (PF_BYTE)(0x80 | ((c >> 6) & 0x3F));
3834:                			s[2] = (PF_BYTE)(0x80 | (c & 0x3F));
3835:                			btw = 3;
3836:                		}
3837:                	}
3838:                #else				/* Write the character without conversion */
3839:                	s[0] = (PF_BYTE)c;
3840:                	btw = 1;
3841:                #endif
3842:                	f_write(fil, s, btw, &bw); /* Write the char to the file */
3843:                	return (bw == btw) ? 1 : EOF; /* Return the result */
3844:                }
3845:                
3846:                /*-----------------------------------------------------------------------*/
3847:                /* Put a string to the file                                              */
3848:                /*-----------------------------------------------------------------------*/
3849:                int f_puts (
3850:                		const TCHAR* str, /* Pointer to the string to be output */
3851:                		FIL* fil /* Pointer to the file object */
3852:                )
3853:                {
3854:                	int n;
3855:                
3856:                	for (n = 0; *str; str++, n++) {
3857:                		if (f_putc(*str, fil) == EOF) return EOF;
3858:                	}
3859:                	return n;
3860:                }
3861:                
3862:                /*-----------------------------------------------------------------------*/
3863:                /* Put a formatted string to the file                                    */
3864:                /*-----------------------------------------------------------------------*/
3865:                int f_printf (
3866:                		FIL* fil, /* Pointer to the file object */
3867:                		const TCHAR* str, /* Pointer to the format string */
3868:                		... /* Optional arguments... */
3869:                )
3870:                {
3871:                	va_list arp;
3872:                	PF_BYTE f, r;
3873:                	UINT i, j, w;
3874:                	ULONG v;
3875:                	TCHAR c, d, s[16], *p;
3876:                	int res, chc, cc;
3877:                
3878:                	va_start(arp, str);
3879:                
3880:                	for (cc = res = 0; cc != EOF; res += cc) {
3881:                		c = *str++;
3882:                		if (c == 0) break; /* End of string */
3883:                		if (c != '%') { /* Non escape character */
3884:                			cc = f_putc(c, fil);
3885:                			if (cc != EOF) cc = 1;
3886:                			continue;
3887:                		}
3888:                		w = f = 0;
3889:                		c = *str++;
3890:                		if (c == '0') { /* Flag: '0' padding */
3891:                			f = 1; c = *str++;
3892:                		} else {
3893:                			if (c == '-') { /* Flag: left justified */
3894:                				f = 2; c = *str++;
3895:                			}
3896:                		}
3897:                		while (IsDigit(c)) { /* Precision */
3898:                			w = w * 10 + c - '0';
3899:                			c = *str++;
3900:                		}
3901:                		if (c == 'l' || c == 'L') { /* Prefix: Size is long int */
3902:                			f |= 4; c = *str++;
3903:                		}
3904:                		if (!c) break;
3905:                		d = c;
3906:                		if (IsLower(d)) d -= 0x20;
3907:                		switch (d) { /* Type is... */
3908:                			case 'S' : /* String */
3909:                			p = va_arg(arp, TCHAR*);
3910:                			for (j = 0; p[j]; j++);
3911:                			chc = 0;
3912:                			if (!(f & 2)) {
3913:                				while (j++ < w) chc += (cc = f_putc(' ', fil));
3914:                			}
3915:                			chc += (cc = f_puts(p, fil));
3916:                			while (j++ < w) chc += (cc = f_putc(' ', fil));
3917:                			if (cc != EOF) cc = chc;
3918:                			continue;
3919:                			case 'C' : /* Character */
3920:                			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
3921:                			case 'B' : /* Binary */
3922:                			r = 2; break;
3923:                			case 'O' : /* Octal */
3924:                			r = 8; break;
3925:                			case 'D' : /* Signed decimal */
3926:                			case 'U' : /* Unsigned decimal */
3927:                			r = 10; break;
3928:                			case 'X' : /* Hexdecimal */
3929:                			r = 16; break;
3930:                			default: /* Unknown type (passthrough) */
3931:                			cc = f_putc(c, fil); continue;
3932:                		}
3933:                
3934:                		/* Get an argument and put it in numeral */
3935:                		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
3936:                		if (d == 'D' && (v & 0x80000000)) {
3937:                			v = 0 - v;
3938:                			f |= 8;
3939:                		}
3940:                		i = 0;
3941:                		do {
3942:                			d = (TCHAR)(v % r); v /= r;
3943:                			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
3944:                			s[i++] = d + '0';
3945:                		}while (v && i < sizeof(s) / sizeof(s[0]));
3946:                		if (f & 8) s[i++] = '-';
3947:                		j = i; d = (f & 1) ? '0' : ' ';
3948:                		res = 0;
3949:                		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
3950:                		do res += (cc = f_putc(s[--i], fil)); while(i);
3951:                		while (j++ < w) res += (cc = f_putc(' ', fil));
3952:                		if (cc != EOF) cc = res;
3953:                	}
3954:                
3955:                	va_end(arp);
3956:                	return (cc == EOF) ? cc : res;
3957:                }
3958:                
3959:                #endif /* !_FS_READONLY */
3960:                #endif /* _USE_STRFUNC */
---  /home/jacques/MPLABXProjects/vpc-32/hardware/Pinguino/diskio.c  ------------------------------------
1:                   /*------------------------------------------------------------------------/
2:                    /  MMCv3/SDv1/SDv2 (in SPI mode) control module
3:                    /-------------------------------------------------------------------------/
4:                    /
5:                    /  Copyright (C) 2010, ChaN, all right reserved.
6:                    /
7:                    / * This software is a free software and there is NO WARRANTY.
8:                    / * No restriction on use. You can use, modify and redistribute it for
9:                    /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
10:                   / * Redistributions of source code must retain the above copyright notice.
11:                   /
12:                   /-------------------------------------------------------------------------*/
13:                  
14:                  // 07 May 2012 Changes made to allow SD card library to support
15:                  //					PIC32 Pinguino Micro and potentially other cards that
16:                  //					do not support the use of the RTCC library.
17:                  // 25 May 2012 Added includes for delay.c and digitalw.c
18:                  
19:                  #include <stdlib.h>
20:                  
21:                  //#include "ff.h"
22:                  #include "diskio.h"
23:                  //#include <delay.c>
24:                  //#include <digitalw.c>
25:                  #include "../HardwareProfile.h"
26:                  #include "sdmmc.h"
27:                  #include "../store/store_spi.h"
28:                  #include "../../shell.h"
29:                  
30:                  // For boards known to support the RTCC library ***Added 07 May 2012
31:                  // to allow SD Library to support PIC32 Pinguino Micro, which
32:                  // which does not have a RTCC crystal and associated components,
33:                  // and would not operate if #include <rtcc.c> is included.
34:                  // See also changes to get_fattime() below.
35:                  
36:                  #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
37:                  	#include <rtcc.c>
38:                  #endif
39:                  
40:                  /* Definitions for MMC/SDC command */
41:                  #define CMD0   (0)			/* GO_IDLE_STATE */
42:                  #define CMD1   (1)			/* SEND_OP_COND */
43:                  #define ACMD41 (41|0x80)	/* SEND_OP_COND (SDC) */
44:                  #define CMD8   (8)			/* SEND_IF_COND */
45:                  #define CMD9   (9)			/* SEND_CSD */
46:                  #define CMD10  (10)			/* SEND_CID */
47:                  #define CMD12  (12)			/* STOP_TRANSMISSION */
48:                  #define ACMD13 (13|0x80)	/* SD_STATUS (SDC) */
49:                  #define CMD16  (16)			/* SET_BLOCKLEN */
50:                  #define CMD17  (17)			/* READ_SINGLE_BLOCK */
51:                  #define CMD18  (18)			/* READ_MULTIPLE_BLOCK */
52:                  #define CMD23  (23)			/* SET_BLOCK_COUNT */
53:                  #define ACMD23 (23|0x80)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
54:                  #define CMD24  (24)			/* WRITE_BLOCK */
55:                  #define CMD25  (25)			/* WRITE_MULTIPLE_BLOCK */
56:                  #define CMD41  (41)			/* SEND_OP_COND (ACMD) */
57:                  #define CMD55  (55)			/* APP_CMD */
58:                  #define CMD58  (58)			/* READ_OCR */
59:                  
60:                  /* Port Controls  (Platform dependent) */
61:                  //#define SOCKPORT	PORTB		/* Socket contact port */
62:                  //#define SOCKWP	(1<<10)		/* Write protect switch (RB10) */
63:                  //#define SOCKINS	(1<<11)		/* Card detect switch (RB11) */
64:                  
65:                  //#define	FCLK_SLOW()			/* Set slow clock (100k-400k) */
66:                  //#define	FCLK_FAST()			/* Set fast clock (depends on the CSD) */
67:                  
68:                  
69:                  /*--------------------------------------------------------------------------
70:                  
71:                   Module Private Functions
72:                  
73:                   ---------------------------------------------------------------------------*/
74:                  
75:                  static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
76:                  
77:                  static volatile UINT16 Timer1, Timer2; /* 1000Hz decrement timer */
78:                  
79:                  static UINT16 CardType;
80:                  
81:                  /*-----------------------------------------------------------------------*/
82:                  /* Exchange a byte between PIC and MMC via SPI  (Platform dependent)     */
83:                  /*-----------------------------------------------------------------------*/
84:                  
85:                  #define xmit_spi(dat) 	writeSPI(dat)
86:                  #define rcvr_spi()	writeSPI(0xFF)
87:                  #define rcvr_spi_m(p)	SDC_SPIBUF = 0xFF; while (!SDC_SPISTATbits.SPIRBF); *(p) = (PF_BYTE)SDC_SPIBUF;
88:                  #define xchg_spi (dat)  writeSPI(dat)
89:                  #define DLY_US(i)	delay_us(i)
90:                  #define CS_H()		_sdc_disable()//digitalwrite(SDCS, HIGH)
91:                  #define CS_L()		_sdc_enable()//digitalwrite(SDCS, LOW)
92:                  
93:                  /*-----------------------------------------------------------------------*/
94:                  /* Wait for card ready                                                   */
95:                  /*-----------------------------------------------------------------------*/
96:                  
97:                  static
98:                  int wait_ready(void) {
9D0090E0  27BDFFE0   ADDIU SP, SP, -32
9D0090E4  AFBF001C   SW RA, 28(SP)
9D0090E8  AFB10018   SW S1, 24(SP)
9D0090EC  AFB00014   SW S0, 20(SP)
9D0090F0  24111388   ADDIU S1, ZERO, 5000
99:                  	PF_BYTE d;
100:                 	UINT16 tmr;
101:                 
102:                 	for (tmr = 5000; tmr; tmr--) { /* Wait for ready in timeout of 500ms */
9D00911C  1620FFF5   BNE S1, ZERO, 0x9D0090F4
9D009120  3A0200FF   XORI V0, S0, 255
103:                 		d = rcvr_spi();
9D0090F4  0F405B0A   JAL writeSPI
9D0090F8  240400FF   ADDIU A0, ZERO, 255
9D0090FC  00408021   ADDU S0, V0, ZERO
104:                 		if (d == 0xFF)
9D009100  240200FF   ADDIU V0, ZERO, 255
9D009104  12020007   BEQ S0, V0, 0x9D009124
9D009108  3A0200FF   XORI V0, S0, 255
105:                 			break;
106:                 		DLY_US(100);
9D00910C  0F403E88   JAL delay_us
9D009110  24040064   ADDIU A0, ZERO, 100
9D009114  2631FFFF   ADDIU S1, S1, -1
9D009118  3231FFFF   ANDI S1, S1, -1
107:                 	}
108:                 
109:                 	return (d == 0xFF) ? 1 : 0;
110:                 }
9D009124  2C420001   SLTIU V0, V0, 1
9D009128  8FBF001C   LW RA, 28(SP)
9D00912C  8FB10018   LW S1, 24(SP)
9D009130  8FB00014   LW S0, 20(SP)
9D009134  03E00008   JR RA
9D009138  27BD0020   ADDIU SP, SP, 32
111:                 
112:                 /*-----------------------------------------------------------------------*/
113:                 /* Deselect the card and release SPI bus                                 */
114:                 /*-----------------------------------------------------------------------*/
115:                 
116:                 #define deselect() disableSD();
117:                 
118:                 /*-----------------------------------------------------------------------*/
119:                 /* Select the card and wait ready                                        */
120:                 /*-----------------------------------------------------------------------*/
121:                 
122:                 static int select(void) /* 1:Successful, 0:Timeout */
123:                 {
9D00913C  27BDFFE8   ADDIU SP, SP, -24
9D009140  AFBF0014   SW RA, 20(SP)
124:                 	enableSD();
9D009144  0F4044A4   JAL enableSD
9D009148  00000000   NOP
125:                 	rcvr_spi(); /* Dummy clock (force DO enabled) */
9D00914C  0F405B0A   JAL writeSPI
9D009150  240400FF   ADDIU A0, ZERO, 255
126:                 
127:                 	if (wait_ready())
9D009154  0F402438   JAL 0x9D0090E0
9D009158  00000000   NOP
9D00915C  14400004   BNE V0, ZERO, 0x9D009170
9D009160  24030001   ADDIU V1, ZERO, 1
128:                 		return 1; /* OK */
129:                 	deselect();
9D009164  0F404497   JAL disableSD
9D009168  00000000   NOP
130:                 	return 0; /* Timeout */
9D00916C  00001821   ADDU V1, ZERO, ZERO
131:                 }
9D009170  00601021   ADDU V0, V1, ZERO
9D009174  8FBF0014   LW RA, 20(SP)
9D009178  03E00008   JR RA
9D00917C  27BD0018   ADDIU SP, SP, 24
132:                 
133:                 /*-----------------------------------------------------------------------*/
134:                 /* Receive a data packet from MMC                                        */
135:                 /*-----------------------------------------------------------------------*/
136:                 
137:                 static int rcvr_datablock( /* 1:OK, 0:Failed */
9D009404  0B4024E2   J 0x9D009388
9D009408  26310004   ADDIU S1, S1, 4
138:                                           PF_BYTE *buff, /* Data buffer to store received data */
139:                                           UINT16 btr /* Byte count (must be multiple of 4) */
140:                                           ) {
9D009320  27BDFFE0   ADDIU SP, SP, -32
9D009324  AFBF001C   SW RA, 28(SP)
9D009328  AFB20018   SW S2, 24(SP)
9D00932C  AFB10014   SW S1, 20(SP)
9D009330  AFB00010   SW S0, 16(SP)
9D009334  00808821   ADDU S1, A0, ZERO
9D009338  00A09021   ADDU S2, A1, ZERO
9D00933C  241003E8   ADDIU S0, ZERO, 1000
141:                 	PF_BYTE d;
142:                 	UINT16 tmr;
143:                 
144:                 	for (tmr = 1000; tmr; tmr--) { /* Wait for data packet in timeout of 100ms */
9D009364  1600FFF6   BNE S0, ZERO, 0x9D009340
9D009368  00001821   ADDU V1, ZERO, ZERO
145:                 		d = rcvr_spi();
9D009340  0F405B0A   JAL writeSPI
9D009344  240400FF   ADDIU A0, ZERO, 255
146:                 		if (d != 0xFF)
9D009348  240300FF   ADDIU V1, ZERO, 255
9D00934C  14430009   BNE V0, V1, 0x9D009374
9D009350  240400FE   ADDIU A0, ZERO, 254
147:                 			break;
148:                 		DLY_US(100);
9D009354  0F403E88   JAL delay_us
9D009358  24040064   ADDIU A0, ZERO, 100
9D00935C  2610FFFF   ADDIU S0, S0, -1
9D009360  3210FFFF   ANDI S0, S0, -1
149:                 	}
150:                 	if (d != 0xFE)
9D009374  1444002A   BNE V0, A0, 0x9D009420
9D009378  00001821   ADDU V1, ZERO, ZERO
151:                 		return 0; /* If not valid data token, return with error */
152:                 
153:                 	do { /* Receive the data block into buffer */
154:                 		rcvr_spi_m(buff++);
9D00937C  3C04BF80   LUI A0, -16512
9D009380  240500FF   ADDIU A1, ZERO, 255
9D009384  3C02BF80   LUI V0, -16512
9D009388  AC855A20   SW A1, 23072(A0)
9D00938C  8C435A10   LW V1, 23056(V0)
9D009390  30630001   ANDI V1, V1, 1
9D009394  1060FFFD   BEQ V1, ZERO, 0x9D00938C
9D009398  00000000   NOP
9D00939C  8C835A20   LW V1, 23072(A0)
9D0093A0  A2230000   SB V1, 0(S1)
155:                 		rcvr_spi_m(buff++);
9D0093A4  AC855A20   SW A1, 23072(A0)
9D0093A8  8C435A10   LW V1, 23056(V0)
9D0093AC  30630001   ANDI V1, V1, 1
9D0093B0  1060FFFD   BEQ V1, ZERO, 0x9D0093A8
9D0093B4  00000000   NOP
9D0093B8  8C835A20   LW V1, 23072(A0)
9D0093BC  A2230001   SB V1, 1(S1)
156:                 		rcvr_spi_m(buff++);
9D0093C0  AC855A20   SW A1, 23072(A0)
9D0093C4  8C435A10   LW V1, 23056(V0)
9D0093C8  30630001   ANDI V1, V1, 1
9D0093CC  1060FFFD   BEQ V1, ZERO, 0x9D0093C4
9D0093D0  00000000   NOP
9D0093D4  8C835A20   LW V1, 23072(A0)
9D0093D8  A2230002   SB V1, 2(S1)
157:                 		rcvr_spi_m(buff++);
9D0093DC  AC855A20   SW A1, 23072(A0)
9D0093E0  8C435A10   LW V1, 23056(V0)
9D0093E4  30630001   ANDI V1, V1, 1
9D0093E8  1060FFFD   BEQ V1, ZERO, 0x9D0093E0
9D0093EC  00000000   NOP
9D0093F0  8C835A20   LW V1, 23072(A0)
158:                 	} while (btr -= 4);
9D0093F4  2652FFFC   ADDIU S2, S2, -4
9D0093F8  3252FFFF   ANDI S2, S2, -1
9D0093FC  12400003   BEQ S2, ZERO, 0x9D00940C
9D009400  A2230003   SB V1, 3(S1)
159:                 	rcvr_spi(); /* Discard CRC */
9D00940C  0F405B0A   JAL writeSPI
9D009410  240400FF   ADDIU A0, ZERO, 255
160:                 	rcvr_spi();
9D009414  0F405B0A   JAL writeSPI
9D009418  240400FF   ADDIU A0, ZERO, 255
161:                 
162:                 	return 1; /* Return with success */
9D00941C  24030001   ADDIU V1, ZERO, 1
163:                 }
9D00936C  0B402509   J 0x9D009424
9D009370  00601021   ADDU V0, V1, ZERO
9D009420  00601021   ADDU V0, V1, ZERO
9D009424  8FBF001C   LW RA, 28(SP)
9D009428  8FB20018   LW S2, 24(SP)
9D00942C  8FB10014   LW S1, 20(SP)
9D009430  8FB00010   LW S0, 16(SP)
9D009434  03E00008   JR RA
9D009438  27BD0020   ADDIU SP, SP, 32
164:                 
165:                 /*-----------------------------------------------------------------------*/
166:                 /* Send a data packet to MMC                                             */
167:                 /*-----------------------------------------------------------------------*/
168:                 
169:                 #if _READONLY == 0
170:                 static int xmit_datablock( /* 1:OK, 0:Failed */
9D0092C4  26110200   ADDIU S1, S0, 512
9D009300  38630005   XORI V1, V1, 5
9D009304  2C630001   SLTIU V1, V1, 1
171:                                           const PF_BYTE *buff, /* 512 byte data block to be transmitted */
172:                                           PF_BYTE token /* Data token */
173:                                           ) {
9D00928C  27BDFFE0   ADDIU SP, SP, -32
9D009290  AFBF001C   SW RA, 28(SP)
9D009294  AFB10018   SW S1, 24(SP)
9D009298  AFB00014   SW S0, 20(SP)
9D00929C  00808021   ADDU S0, A0, ZERO
174:                 	PF_BYTE resp;
175:                 	UINT16 bc = BLK_SIZE;
176:                 
177:                 	if (!wait_ready())
9D0092A0  0F402438   JAL 0x9D0090E0
9D0092A4  00A08821   ADDU S1, A1, ZERO
9D0092A8  10400017   BEQ V0, ZERO, 0x9D009308
9D0092AC  00001821   ADDU V1, ZERO, ZERO
178:                 		return 0;
179:                 
180:                 	xmit_spi(token); /* Xmit a token */
9D0092B0  0F405B0A   JAL writeSPI
9D0092B4  02202021   ADDU A0, S1, ZERO
181:                 	if (token != 0xFD) { /* Not StopTran token */
9D0092B8  240200FD   ADDIU V0, ZERO, 253
9D0092BC  12220012   BEQ S1, V0, 0x9D009308
9D0092C0  24030001   ADDIU V1, ZERO, 1
182:                 		do { /* Xmit the 512 byte data block to the MMC */
183:                 			xmit_spi(*buff++);
9D0092C8  0F405B0A   JAL writeSPI
9D0092CC  92040000   LBU A0, 0(S0)
184:                 			xmit_spi(*buff++);
9D0092D0  92040001   LBU A0, 1(S0)
9D0092D4  0F405B0A   JAL writeSPI
9D0092D8  26100002   ADDIU S0, S0, 2
185:                 		} while (bc -= 2);
9D0092DC  1630FFFA   BNE S1, S0, 0x9D0092C8
9D0092E0  00000000   NOP
186:                 		xmit_spi(0xFF); /* CRC (Dummy) */
9D0092E4  0F405B0A   JAL writeSPI
9D0092E8  240400FF   ADDIU A0, ZERO, 255
187:                 		xmit_spi(0xFF);
9D0092EC  0F405B0A   JAL writeSPI
9D0092F0  240400FF   ADDIU A0, ZERO, 255
188:                 		resp = rcvr_spi(); /* Receive a data response */
9D0092F4  0F405B0A   JAL writeSPI
9D0092F8  240400FF   ADDIU A0, ZERO, 255
189:                 		if ((resp & 0x1F) != 0x05) /* If not accepted, return with error */
9D0092FC  3043001F   ANDI V1, V0, 31
190:                 			return 0;
191:                 	}
192:                 
193:                 	return 1;
194:                 }
9D009308  00601021   ADDU V0, V1, ZERO
9D00930C  8FBF001C   LW RA, 28(SP)
9D009310  8FB10018   LW S1, 24(SP)
9D009314  8FB00014   LW S0, 20(SP)
9D009318  03E00008   JR RA
9D00931C  27BD0020   ADDIU SP, SP, 32
195:                 #endif	/* _READONLY */
196:                 
197:                 /*-----------------------------------------------------------------------*/
198:                 /* Send a command packet to MMC                                          */
199:                 /*-----------------------------------------------------------------------*/
200:                 
201:                 static PF_BYTE send_cmd(PF_BYTE cmd, /* Command byte */
202:                                         DWORD arg /* Argument */
203:                                         ) {
9D009180  27BDFFE0   ADDIU SP, SP, -32
9D009184  AFBF001C   SW RA, 28(SP)
9D009188  AFB10018   SW S1, 24(SP)
9D00918C  AFB00014   SW S0, 20(SP)
9D009190  00A08821   ADDU S1, A1, ZERO
9D00922C  2410000A   ADDIU S0, ZERO, 10
9D009274  0B40248C   J 0x9D009230
9D009278  2410000A   ADDIU S0, ZERO, 10
9D009284  0B40248C   J 0x9D009230
9D009288  2410000A   ADDIU S0, ZERO, 10
204:                 	PF_BYTE n, res;
205:                 
206:                 	if (cmd & 0x80) { /* ACMD<n> is the command sequense of CMD55-CMD<n> */
9D009194  7C041420   SEB V0, A0
9D009198  04410009   BGEZ V0, 0x9D0091C0
9D00919C  00808021   ADDU S0, A0, ZERO
207:                 		cmd &= 0x7F;
9D0091BC  3210007F   ANDI S0, S0, 127
208:                 		res = send_cmd(CMD55, 0);
9D0091A0  24040037   ADDIU A0, ZERO, 55
9D0091A4  0F402460   JAL 0x9D009180
9D0091A8  00002821   ADDU A1, ZERO, ZERO
9D0091AC  00401821   ADDU V1, V0, ZERO
209:                 		if (res > 1)
9D0091B0  2C420002   SLTIU V0, V0, 2
9D0091B4  10400028   BEQ V0, ZERO, 0x9D009258
9D0091B8  00601021   ADDU V0, V1, ZERO
210:                 			return res;
211:                 	}
212:                 
213:                 	/* Select the card and wait for ready */
214:                 	deselect();
9D0091C0  0F404497   JAL disableSD
9D0091C4  00000000   NOP
215:                 	if (!select())
9D0091C8  0F40244F   JAL 0x9D00913C
9D0091CC  00000000   NOP
9D0091D0  10400020   BEQ V0, ZERO, 0x9D009254
9D0091D4  240300FF   ADDIU V1, ZERO, 255
216:                 		return 0xFF;
217:                 
218:                 	/* Send command packet */
219:                 	xmit_spi(0x40 | cmd); /* Start + Command index */
9D0091D8  0F405B0A   JAL writeSPI
9D0091DC  36040040   ORI A0, S0, 64
220:                 	xmit_spi((PF_BYTE)(arg >> 24)); /* Argument[31..24] */
9D0091E0  0F405B0A   JAL writeSPI
9D0091E4  00112602   SRL A0, S1, 24
221:                 	xmit_spi((PF_BYTE)(arg >> 16)); /* Argument[23..16] */
9D0091E8  0F405B0A   JAL writeSPI
9D0091EC  7E243C00   EXT A0, S1, 16, 8
222:                 	xmit_spi((PF_BYTE)(arg >> 8)); /* Argument[15..8] */
9D0091F0  0F405B0A   JAL writeSPI
9D0091F4  7E243A00   EXT A0, S1, 8, 8
223:                 	xmit_spi((PF_BYTE)arg); /* Argument[7..0] */
9D0091F8  0F405B0A   JAL writeSPI
9D0091FC  322400FF   ANDI A0, S1, 255
224:                 	n = 0x01; /* Dummy CRC + Stop */
225:                 	if (cmd == CMD0)
9D009200  1200001E   BEQ S0, ZERO, 0x9D00927C
9D009204  24020008   ADDIU V0, ZERO, 8
226:                 		n = 0x95; /* Valid CRC for CMD0(0) */
227:                 	if (cmd == CMD8)
9D009208  12020018   BEQ S0, V0, 0x9D00926C
9D00920C  00000000   NOP
228:                 		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
229:                 	xmit_spi(n);
9D009210  0F405B0A   JAL writeSPI
9D009214  24040001   ADDIU A0, ZERO, 1
9D00926C  0F405B0A   JAL writeSPI
9D009270  24040087   ADDIU A0, ZERO, 135
9D00927C  0F405B0A   JAL writeSPI
9D009280  24040095   ADDIU A0, ZERO, 149
230:                 
231:                 	/* Receive command response */
232:                 	if (cmd == CMD12)
9D009218  2402000C   ADDIU V0, ZERO, 12
9D00921C  16020004   BNE S0, V0, 0x9D009230
9D009220  2410000A   ADDIU S0, ZERO, 10
233:                 		rcvr_spi(); /* Skip a stuff byte when stop reading */
9D009224  0F405B0A   JAL writeSPI
9D009228  240400FF   ADDIU A0, ZERO, 255
234:                 	n = 10; /* Wait for a valid response in timeout of 10 attempts */
235:                 	do
236:                 		res = rcvr_spi();
9D009230  0F405B0A   JAL writeSPI
9D009234  240400FF   ADDIU A0, ZERO, 255
9D009238  00401821   ADDU V1, V0, ZERO
237:                 	while ((res & 0x80) && --n);
9D00923C  7C021420   SEB V0, V0
9D009240  04410004   BGEZ V0, 0x9D009254
9D009244  2610FFFF   ADDIU S0, S0, -1
9D009248  321000FF   ANDI S0, S0, 255
9D00924C  1600FFF8   BNE S0, ZERO, 0x9D009230
9D009250  00000000   NOP
238:                 
239:                 	return res; /* Return with the response value */
240:                 }
9D009254  00601021   ADDU V0, V1, ZERO
9D009258  8FBF001C   LW RA, 28(SP)
9D00925C  8FB10018   LW S1, 24(SP)
9D009260  8FB00014   LW S0, 20(SP)
9D009264  03E00008   JR RA
9D009268  27BD0020   ADDIU SP, SP, 32
241:                 
242:                 /*--------------------------------------------------------------------------
243:                 
244:                  Public Functions
245:                 
246:                  ---------------------------------------------------------------------------*/
247:                 
248:                 /*-----------------------------------------------------------------------*/
249:                 /* Initialize Disk Drive                                                 */
250:                 /*-----------------------------------------------------------------------*/
251:                 
252:                 DSTATUS disk_initialize(PF_BYTE drv /* Physical drive number (0) */
9D0094E8  27B10014   ADDIU S1, SP, 20
9D009584  27A40010   ADDIU A0, SP, 16
9D009588  00901821   ADDU V1, A0, S0
253:                                         ) {
9D00943C  27BDFFD8   ADDIU SP, SP, -40
9D009440  AFBF0024   SW RA, 36(SP)
9D009444  AFB10020   SW S1, 32(SP)
9D009448  AFB0001C   SW S0, 28(SP)
9D00944C  308400FF   ANDI A0, A0, 255
254:                 	PF_BYTE n, ty, cmd, buf[4];
255:                 	UINT16 tmr;
256:                 	DSTATUS s = 0;
257:                 	if (drv)
9D009450  14800083   BNE A0, ZERO, 0x9D009660
9D009454  24020001   ADDIU V0, ZERO, 1
258:                 		return STA_NOINIT; /* Supports only single drive */
259:                 	if (Stat & STA_NODISK)
9D009458  93828010   LBU V0, -32752(GP)
9D00945C  30420002   ANDI V0, V0, 2
9D009460  10400004   BEQ V0, ZERO, 0x9D009474
9D009464  00000000   NOP
260:                 		return Stat; /* No card in the socket */
9D009468  93828010   LBU V0, -32752(GP)
9D00946C  0B402598   J 0x9D009660
9D009470  304200FF   ANDI V0, V0, 255
261:                 
262:                 	deselect(); /* Force socket power on */
9D009474  0F404497   JAL disableSD
9D009478  2410000A   ADDIU S0, ZERO, 10
263:                 	//FCLK_SLOW();
264:                 	for (n = 10; n; n--)
9D00948C  1600FFFB   BNE S0, ZERO, 0x9D00947C
9D009490  24030004   ADDIU V1, ZERO, 4
265:                 		rcvr_spi(); /* 80 dummy clocks */
9D00947C  0F405B0A   JAL writeSPI
9D009480  240400FF   ADDIU A0, ZERO, 255
9D009484  2610FFFF   ADDIU S0, S0, -1
9D009488  321000FF   ANDI S0, S0, 255
266:                 	CS_H();
9D009494  3C02BF88   LUI V0, -16504
9D009498  AC436128   SW V1, 24872(V0)
9D00949C  2410000A   ADDIU S0, ZERO, 10
267:                 	for (n = 10; n; n--)
9D0094B0  1600FFFB   BNE S0, ZERO, 0x9D0094A0
9D0094B4  00002021   ADDU A0, ZERO, ZERO
268:                 		rcvr_spi(); /* 80 dummy clocks */
9D0094A0  0F405B0A   JAL writeSPI
9D0094A4  240400FF   ADDIU A0, ZERO, 255
9D0094A8  2610FFFF   ADDIU S0, S0, -1
9D0094AC  321000FF   ANDI S0, S0, 255
269:                 
270:                 	ty = 0;
271:                 	if (send_cmd(CMD0, 0) == 1) { /* Enter Idle state */
9D0094B8  0F402460   JAL 0x9D009180
9D0094BC  00002821   ADDU A1, ZERO, ZERO
9D0094C0  24030001   ADDIU V1, ZERO, 1
9D0094C4  5443006B   BNEL V0, V1, 0x9D009674
9D0094C8  A780803C   SH ZERO, -32708(GP)
272:                 		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2? */
9D0094CC  24040008   ADDIU A0, ZERO, 8
9D0094D0  0F402460   JAL 0x9D009180
9D0094D4  240501AA   ADDIU A1, ZERO, 426
9D0094D8  24030001   ADDIU V1, ZERO, 1
9D0094DC  14430035   BNE V0, V1, 0x9D0095B4
9D0094E0  240400A9   ADDIU A0, ZERO, 169
9D0094E4  27B00010   ADDIU S0, SP, 16
273:                 			for (n = 0; n < 4; n++)
9D0094FC  1611FFFB   BNE S0, S1, 0x9D0094EC
9D009500  93A30012   LBU V1, 18(SP)
274:                 				buf[n] = rcvr_spi(); /* Get trailing return value of R7 resp */
9D0094EC  0F405B0A   JAL writeSPI
9D0094F0  240400FF   ADDIU A0, ZERO, 255
9D0094F4  A2020000   SB V0, 0(S0)
9D0094F8  26100001   ADDIU S0, S0, 1
275:                 			if (buf[2] == 0x01 && buf[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
9D009504  24020001   ADDIU V0, ZERO, 1
9D009508  54620050   BNEL V1, V0, 0x9D00964C
9D00950C  A780803C   SH ZERO, -32708(GP)
9D009510  93A30013   LBU V1, 19(SP)
9D009514  240200AA   ADDIU V0, ZERO, 170
9D009518  54620056   BNEL V1, V0, 0x9D009674
9D00951C  A780803C   SH ZERO, -32708(GP)
9D009520  241003E8   ADDIU S0, ZERO, 1000
276:                 				for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state (ACMD41 with HCS bit) */
9D009540  2610FFFF   ADDIU S0, S0, -1
9D009544  3210FFFF   ANDI S0, S0, -1
9D009548  1600FFF7   BNE S0, ZERO, 0x9D009528
9D00954C  240400A9   ADDIU A0, ZERO, 169
277:                 					if (send_cmd(ACMD41, 1UL << 30) == 0)
9D009524  240400A9   ADDIU A0, ZERO, 169
9D009528  0F402460   JAL 0x9D009180
9D00952C  3C054000   LUI A1, 16384
9D009530  10400009   BEQ V0, ZERO, 0x9D009558
9D009534  00000000   NOP
278:                 						break;
279:                 					DLY_US(1000);
9D009538  0F403E88   JAL delay_us
9D00953C  240403E8   ADDIU A0, ZERO, 1000
280:                 				}
281:                 				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
9D009558  52000046   BEQL S0, ZERO, 0x9D009674
9D00955C  A780803C   SH ZERO, -32708(GP)
9D009560  2404003A   ADDIU A0, ZERO, 58
9D009564  0F402460   JAL 0x9D009180
9D009568  00002821   ADDU A1, ZERO, ZERO
9D00956C  54400041   BNEL V0, ZERO, 0x9D009674
9D009570  A780803C   SH ZERO, -32708(GP)
9D009574  00008021   ADDU S0, ZERO, ZERO
282:                 					for (n = 0; n < 4; n++)
9D009578  24110004   ADDIU S1, ZERO, 4
9D009590  1611FFFA   BNE S0, S1, 0x9D00957C
9D009594  A0620000   SB V0, 0(V1)
283:                 						buf[n] = rcvr_spi();
9D00957C  0F405B0A   JAL writeSPI
9D009580  240400FF   ADDIU A0, ZERO, 255
9D00958C  26100001   ADDIU S0, S0, 1
284:                 					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 */
9D009598  93A40010   LBU A0, 16(SP)
9D00959C  30840040   ANDI A0, A0, 64
9D0095A0  24030004   ADDIU V1, ZERO, 4
9D0095A4  2402000C   ADDIU V0, ZERO, 12
9D0095A8  0064100A   MOVZ V0, V1, A0
285:                 				}
286:                 			}
287:                 		} else { /* SDv1 or MMCv3 */
288:                 			if (send_cmd(ACMD41, 0) <= 1) {
9D0095B4  0F402460   JAL 0x9D009180
9D0095B8  00002821   ADDU A1, ZERO, ZERO
9D0095BC  2C420002   SLTIU V0, V0, 2
289:                 				ty = CT_SD1;
9D0095C0  24030002   ADDIU V1, ZERO, 2
9D0095C4  24040001   ADDIU A0, ZERO, 1
9D0095C8  00608821   ADDU S1, V1, ZERO
9D0095CC  0082880A   MOVZ S1, A0, V0
290:                 				cmd = ACMD41; /* SDv1 */
291:                 			} else {
292:                 				ty = CT_MMC;
293:                 				cmd = CMD1; /* MMCv3 */
294:                 			}
295:                 			for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state */
9D0095D0  241003E8   ADDIU S0, ZERO, 1000
9D0095F0  2610FFFF   ADDIU S0, S0, -1
9D0095F4  3210FFFF   ANDI S0, S0, -1
9D0095F8  1600FFF7   BNE S0, ZERO, 0x9D0095D8
9D0095FC  240400A9   ADDIU A0, ZERO, 169
296:                 				if (send_cmd(ACMD41, 0) == 0)
9D0095D4  240400A9   ADDIU A0, ZERO, 169
9D0095D8  0F402460   JAL 0x9D009180
9D0095DC  00002821   ADDU A1, ZERO, ZERO
9D0095E0  10400009   BEQ V0, ZERO, 0x9D009608
9D0095E4  00000000   NOP
297:                 					break;
298:                 				DLY_US(1000);
9D0095E8  0F403E88   JAL delay_us
9D0095EC  240403E8   ADDIU A0, ZERO, 1000
299:                 			}
300:                 			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
9D009608  5200001A   BEQL S0, ZERO, 0x9D009674
9D00960C  A780803C   SH ZERO, -32708(GP)
9D009610  24040010   ADDIU A0, ZERO, 16
9D009614  0F402460   JAL 0x9D009180
9D009618  24050200   ADDIU A1, ZERO, 512
9D00961C  54400015   BNEL V0, ZERO, 0x9D009674
9D009620  A780803C   SH ZERO, -32708(GP)
301:                 				ty = 0;
302:                 		}
303:                 	}
304:                 	CardType = ty;
9D009550  0B40259D   J 0x9D009674
9D009554  A780803C   SH ZERO, -32708(GP)
9D0095AC  0B40258C   J 0x9D009630
9D0095B0  A782803C   SH V0, -32708(GP)
9D009600  0B40259D   J 0x9D009674
9D009604  A780803C   SH ZERO, -32708(GP)
9D009624  A791803C   SH S1, -32708(GP)
305:                 	if (ty) {/* Initialization succeded */
9D009628  12200008   BEQ S1, ZERO, 0x9D00964C
9D00962C  24020001   ADDIU V0, ZERO, 1
306:                 		s &= ~STA_NOINIT;
9D009648  00001021   ADDU V0, ZERO, ZERO
307:                 		// 6. increase speed
308:                 		SPI2CON = 0; // disable the SPI2 module
9D009630  3C02BF80   LUI V0, -16512
9D009634  AC405A00   SW ZERO, 23040(V0)
309:                 		SPI2BRG = 0; // maximum possible baud rate = Fpb/2
9D009638  3C03BF80   LUI V1, -16512
9D00963C  AC605A30   SW ZERO, 23088(V1)
310:                 		SPI2CON = 0x8120; // re-enable the SPI2 module
9D009640  34038120   ORI V1, ZERO, -32480
9D009644  AC435A00   SW V1, 23040(V0)
311:                 	} else {
312:                 		/* Initialization failed */
313:                 		s |= STA_NOINIT;
9D009674  0B402593   J 0x9D00964C
9D009678  24020001   ADDIU V0, ZERO, 1
314:                 	}
315:                 	Stat = s;
9D00964C  A3828010   SB V0, -32752(GP)
316:                 
317:                 	deselect();
9D009650  0F404497   JAL disableSD
9D009654  00000000   NOP
318:                 
319:                 	return Stat;
9D009658  93828010   LBU V0, -32752(GP)
9D00965C  304200FF   ANDI V0, V0, 255
320:                 }
9D009660  8FBF0024   LW RA, 36(SP)
9D009664  8FB10020   LW S1, 32(SP)
9D009668  8FB0001C   LW S0, 28(SP)
9D00966C  03E00008   JR RA
9D009670  27BD0028   ADDIU SP, SP, 40
321:                 
322:                 /*-----------------------------------------------------------------------*/
323:                 /* Get Disk Status                                                       */
324:                 /*-----------------------------------------------------------------------*/
325:                 
326:                 DSTATUS disk_status(PF_BYTE drv /* Physical drive number (0) */
327:                 ) {
9D00967C  308400FF   ANDI A0, A0, 255
328:                 	if (drv)
9D009680  14800003   BNE A0, ZERO, 0x9D009690
9D009684  24020001   ADDIU V0, ZERO, 1
329:                 		return STA_NOINIT; /* Supports only single drive */
330:                 	return Stat;
9D009688  93828010   LBU V0, -32752(GP)
9D00968C  304200FF   ANDI V0, V0, 255
331:                 }
9D009690  03E00008   JR RA
9D009694  00000000   NOP
332:                 
333:                 /*-----------------------------------------------------------------------*/
334:                 /* Read Sector(s)                                                        */
335:                 /*-----------------------------------------------------------------------*/
336:                 
337:                 DRESULT disk_read(PF_BYTE drv, /* Physical drive nmuber (0) */
338:                                   PF_BYTE *buff, /* Pointer to the data buffer to store read data */
339:                                   DWORD sector, /* Start sector number (LBA) */
340:                                   PF_BYTE count /* Sector count (1..255) */
341:                                   ) {
9D009698  27BDFFE0   ADDIU SP, SP, -32
9D00969C  AFBF001C   SW RA, 28(SP)
9D0096A0  AFB10018   SW S1, 24(SP)
9D0096A4  AFB00014   SW S0, 20(SP)
9D0096A8  00A08821   ADDU S1, A1, ZERO
9D0096AC  308400FF   ANDI A0, A0, 255
9D0096B0  30F000FF   ANDI S0, A3, 255
342:                 	if (drv || !count)
9D0096B4  14800029   BNE A0, ZERO, 0x9D00975C
9D0096B8  24020004   ADDIU V0, ZERO, 4
9D0096BC  52000028   BEQL S0, ZERO, 0x9D009760
9D0096C0  8FBF001C   LW RA, 28(SP)
343:                 		return RES_PARERR;
344:                 	if (Stat & STA_NOINIT)
9D0096C4  93838010   LBU V1, -32752(GP)
9D0096C8  30630001   ANDI V1, V1, 1
9D0096CC  14600023   BNE V1, ZERO, 0x9D00975C
9D0096D0  24020003   ADDIU V0, ZERO, 3
345:                 		return RES_NOTRDY;
346:                 
347:                 	if (!(CardType & CT_BLOCK))
9D0096D4  9783803C   LHU V1, -32708(GP)
9D0096D8  30630008   ANDI V1, V1, 8
348:                 		sector *= BLK_SIZE; /* Convert to byte address if needed */
9D0096DC  00061240   SLL V0, A2, 9
9D0096E0  0043300A   MOVZ A2, V0, V1
349:                 
350:                 	if (count == 1) { /* Single block read */
9D0096E4  24020001   ADDIU V0, ZERO, 1
9D0096E8  1602000A   BNE S0, V0, 0x9D009714
9D0096EC  24040012   ADDIU A0, ZERO, 18
351:                 		if ((send_cmd(CMD17, sector) == 0) /* READ_SINGLE_BLOCK */
9D0096F0  24040011   ADDIU A0, ZERO, 17
9D0096F4  0F402460   JAL 0x9D009180
9D0096F8  00C02821   ADDU A1, A2, ZERO
9D0096FC  14400014   BNE V0, ZERO, 0x9D009750
9D009700  02202021   ADDU A0, S1, ZERO
352:                 		&& rcvr_datablock(buff, BLK_SIZE))
9D009704  0F4024C8   JAL 0x9D009320
9D009708  24050200   ADDIU A1, ZERO, 512
353:                 			count = 0;
9D00970C  0B4025D4   J 0x9D009750
9D009710  0002800B   MOVN S0, ZERO, V0
354:                 	} else { /* Multiple block read */
355:                 		if (send_cmd(CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
9D009714  0F402460   JAL 0x9D009180
9D009718  00C02821   ADDU A1, A2, ZERO
9D00971C  1440000C   BNE V0, ZERO, 0x9D009750
9D009720  00000000   NOP
356:                 			do {
357:                 				if (!rcvr_datablock(buff, BLK_SIZE))
9D009724  02202021   ADDU A0, S1, ZERO
9D009728  0F4024C8   JAL 0x9D009320
9D00972C  24050200   ADDIU A1, ZERO, 512
9D009730  10400005   BEQ V0, ZERO, 0x9D009748
9D009734  2404000C   ADDIU A0, ZERO, 12
358:                 					break;
359:                 				buff += BLK_SIZE;
360:                 			} while (--count);
9D009738  2610FFFF   ADDIU S0, S0, -1
9D00973C  321000FF   ANDI S0, S0, 255
9D009740  1600FFF8   BNE S0, ZERO, 0x9D009724
9D009744  26310200   ADDIU S1, S1, 512
361:                 			send_cmd(CMD12, 0); /* STOP_TRANSMISSION */
9D009748  0F402460   JAL 0x9D009180
9D00974C  00002821   ADDU A1, ZERO, ZERO
362:                 		}
363:                 	}
364:                 	deselect();
9D009750  0F404497   JAL disableSD
9D009754  00000000   NOP
365:                 
366:                 	return count ? RES_ERROR : RES_OK;
9D009758  0010102B   SLTU V0, ZERO, S0
367:                 }
9D00975C  8FBF001C   LW RA, 28(SP)
9D009760  8FB10018   LW S1, 24(SP)
9D009764  8FB00014   LW S0, 20(SP)
9D009768  03E00008   JR RA
9D00976C  27BD0020   ADDIU SP, SP, 32
368:                 
369:                 /*-----------------------------------------------------------------------*/
370:                 /* Write Sector(s)                                                       */
371:                 /*-----------------------------------------------------------------------*/
372:                 
373:                 #if _READONLY == 0
374:                 DRESULT disk_write(PF_BYTE drv, /* Physical drive number (0) */
375:                                    const PF_BYTE *buff, /* Pointer to the data to be written */
376:                                    DWORD sector, /* Start sector number (LBA) */
377:                                    PF_BYTE count /* Sector count (1..255) */
378:                                    ) {
9D009770  27BDFFE0   ADDIU SP, SP, -32
9D009774  AFBF001C   SW RA, 28(SP)
9D009778  AFB20018   SW S2, 24(SP)
9D00977C  AFB10014   SW S1, 20(SP)
9D009780  AFB00010   SW S0, 16(SP)
9D009784  00A08821   ADDU S1, A1, ZERO
9D009788  00C08021   ADDU S0, A2, ZERO
9D00978C  308400FF   ANDI A0, A0, 255
9D009790  30F200FF   ANDI S2, A3, 255
379:                 	if (drv || !count)
9D009794  14800035   BNE A0, ZERO, 0x9D00986C
9D009798  24020004   ADDIU V0, ZERO, 4
9D00979C  52400034   BEQL S2, ZERO, 0x9D009870
9D0097A0  8FBF001C   LW RA, 28(SP)
380:                 		return RES_PARERR;
381:                 	if (Stat & STA_NOINIT)
9D0097A4  93838010   LBU V1, -32752(GP)
9D0097A8  30630001   ANDI V1, V1, 1
9D0097AC  1460002F   BNE V1, ZERO, 0x9D00986C
9D0097B0  24020003   ADDIU V0, ZERO, 3
382:                 		return RES_NOTRDY;
383:                 	if (Stat & STA_PROTECT)
9D0097B4  93838010   LBU V1, -32752(GP)
9D0097B8  30630004   ANDI V1, V1, 4
9D0097BC  1460002B   BNE V1, ZERO, 0x9D00986C
9D0097C0  24020002   ADDIU V0, ZERO, 2
384:                 		return RES_WRPRT;
385:                 
386:                 	if (!(CardType & CT_BLOCK))
9D0097C4  9782803C   LHU V0, -32708(GP)
9D0097C8  30440008   ANDI A0, V0, 8
387:                 		sector *= 512; /* Convert to byte address if needed */
9D0097CC  00061A40   SLL V1, A2, 9
9D0097D0  0064800A   MOVZ S0, V1, A0
388:                 
389:                 	if (count == 1) { /* Single block write */
9D0097D4  24030001   ADDIU V1, ZERO, 1
9D0097D8  1643000A   BNE S2, V1, 0x9D009804
9D0097DC  30420006   ANDI V0, V0, 6
390:                 		if ((send_cmd(CMD24, sector) == 0) /* WRITE_BLOCK */
9D0097E0  24040018   ADDIU A0, ZERO, 24
9D0097E4  0F402460   JAL 0x9D009180
9D0097E8  02002821   ADDU A1, S0, ZERO
9D0097EC  1440001C   BNE V0, ZERO, 0x9D009860
9D0097F0  02202021   ADDU A0, S1, ZERO
391:                 		&& xmit_datablock(buff, 0xFE))
9D0097F4  0F4024A3   JAL 0x9D00928C
9D0097F8  240500FE   ADDIU A1, ZERO, 254
392:                 			count = 0;
9D0097FC  0B402618   J 0x9D009860
9D009800  0002900B   MOVN S2, ZERO, V0
393:                 	} else { /* Multiple block write */
394:                 		if (CardType & CT_SDC)
9D009804  10400005   BEQ V0, ZERO, 0x9D00981C
9D009808  24040019   ADDIU A0, ZERO, 25
395:                 			send_cmd(ACMD23, count);
9D00980C  24040097   ADDIU A0, ZERO, 151
9D009810  0F402460   JAL 0x9D009180
9D009814  02402821   ADDU A1, S2, ZERO
396:                 		if (send_cmd(CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
9D009818  24040019   ADDIU A0, ZERO, 25
9D00981C  0F402460   JAL 0x9D009180
9D009820  02002821   ADDU A1, S0, ZERO
9D009824  1440000E   BNE V0, ZERO, 0x9D009860
9D009828  00000000   NOP
397:                 			do {
398:                 				if (!xmit_datablock(buff, 0xFC))
9D00982C  02202021   ADDU A0, S1, ZERO
9D009830  0F4024A3   JAL 0x9D00928C
9D009834  240500FC   ADDIU A1, ZERO, 252
9D009838  10400005   BEQ V0, ZERO, 0x9D009850
9D00983C  00002021   ADDU A0, ZERO, ZERO
399:                 					break;
400:                 				buff += 512;
401:                 			} while (--count);
9D009840  2652FFFF   ADDIU S2, S2, -1
9D009844  325200FF   ANDI S2, S2, 255
9D009848  1640FFF8   BNE S2, ZERO, 0x9D00982C
9D00984C  26310200   ADDIU S1, S1, 512
402:                 			if (!xmit_datablock(0, 0xFD)) /* STOP_TRAN token */
9D009850  0F4024A3   JAL 0x9D00928C
9D009854  240500FD   ADDIU A1, ZERO, 253
403:                 				count = 1;
9D009858  24030001   ADDIU V1, ZERO, 1
9D00985C  0062900A   MOVZ S2, V1, V0
404:                 		}
405:                 	}
406:                 	deselect();
9D009860  0F404497   JAL disableSD
9D009864  00000000   NOP
407:                 
408:                 	return count ? RES_ERROR : RES_OK;
9D009868  0012102B   SLTU V0, ZERO, S2
409:                 }
9D00986C  8FBF001C   LW RA, 28(SP)
9D009870  8FB20018   LW S2, 24(SP)
9D009874  8FB10014   LW S1, 20(SP)
9D009878  8FB00010   LW S0, 16(SP)
9D00987C  03E00008   JR RA
9D009880  27BD0020   ADDIU SP, SP, 32
410:                 #endif /* _READONLY */
411:                 
412:                 /*-----------------------------------------------------------------------*/
413:                 /* Miscellaneous Functions                                               */
414:                 /*-----------------------------------------------------------------------*/
415:                 
416:                 DRESULT disk_ioctl(PF_BYTE drv, /* Physical drive number (0) */
9D009B88  26300004   ADDIU S0, S1, 4
417:                                    PF_BYTE ctrl, /* Control code */
418:                                    void *buff /* Buffer to send/receive data block */
419:                                    ) {
9D009884  27BDFFD0   ADDIU SP, SP, -48
9D009888  AFBF002C   SW RA, 44(SP)
9D00988C  AFB20028   SW S2, 40(SP)
9D009890  AFB10024   SW S1, 36(SP)
9D009894  AFB00020   SW S0, 32(SP)
9D009898  00C08821   ADDU S1, A2, ZERO
9D00989C  308400FF   ANDI A0, A0, 255
9D0098A0  30A500FF   ANDI A1, A1, 255
420:                 	DRESULT res;
421:                 	PF_BYTE n, csd[16], *ptr = buff;
422:                 	DWORD csize;
423:                 
424:                 	if (drv)
9D0098A4  148000D0   BNE A0, ZERO, 0x9D009BE8
9D0098A8  24100004   ADDIU S0, ZERO, 4
425:                 		return RES_PARERR;
426:                 	if (Stat & STA_NOINIT)
9D0098AC  93828010   LBU V0, -32752(GP)
9D0098B0  30420001   ANDI V0, V0, 1
9D0098B4  144000CC   BNE V0, ZERO, 0x9D009BE8
9D0098B8  24100003   ADDIU S0, ZERO, 3
427:                 		return RES_NOTRDY;
428:                 
429:                 	res = RES_ERROR;
9D009B40  0B4026F8   J 0x9D009BE0
9D009B44  2C500001   SLTIU S0, V0, 1
9D009B68  0B4026F8   J 0x9D009BE0
9D009B6C  2C500001   SLTIU S0, V0, 1
9D009BD4  0B4026F8   J 0x9D009BE0
9D009BD8  2C500001   SLTIU S0, V0, 1
430:                 	switch (ctrl) {
9D0098BC  2CA2000F   SLTIU V0, A1, 15
9D0098C0  504000C7   BEQL V0, ZERO, 0x9D009BE0
9D0098C4  24100004   ADDIU S0, ZERO, 4
9D0098C8  00052880   SLL A1, A1, 2
9D0098CC  3C029D01   LUI V0, -25343
9D0098D0  244298E4   ADDIU V0, V0, -26396
9D0098D4  00452821   ADDU A1, V0, A1
9D0098D8  8CA20000   LW V0, 0(A1)
9D0098DC  00400008   JR V0
9D0098E0  00000000   NOP
431:                 	case CTRL_SYNC: /* Flush dirty buffer if present */
432:                 		if (select()) {
9D009920  0F40244F   JAL 0x9D00913C
9D009924  24100001   ADDIU S0, ZERO, 1
9D009928  104000AD   BEQ V0, ZERO, 0x9D009BE0
9D00992C  00000000   NOP
433:                 			deselect();
9D009930  0F404497   JAL disableSD
9D009934  00008021   ADDU S0, ZERO, ZERO
9D009938  0B4026F8   J 0x9D009BE0
9D00993C  00000000   NOP
434:                 			res = RES_OK;
435:                 		}
436:                 		break;
437:                 
438:                 	case GET_SECTOR_COUNT: /* Get number of sectors on the disk (WORD) */
439:                 		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
9D009940  24040009   ADDIU A0, ZERO, 9
9D009944  0F402460   JAL 0x9D009180
9D009948  00002821   ADDU A1, ZERO, ZERO
9D00994C  144000A4   BNE V0, ZERO, 0x9D009BE0
9D009950  24100001   ADDIU S0, ZERO, 1
9D009954  27A40010   ADDIU A0, SP, 16
9D009958  0F4024C8   JAL 0x9D009320
9D00995C  24050010   ADDIU A1, ZERO, 16
9D009960  1040009F   BEQ V0, ZERO, 0x9D009BE0
9D009964  93A30010   LBU V1, 16(SP)
440:                 			if ((csd[0] >> 6) == 1) { /* SDv2? */
9D009968  00031982   SRL V1, V1, 6
9D00996C  24020001   ADDIU V0, ZERO, 1
9D009970  1462000A   BNE V1, V0, 0x9D00999C
9D009974  93A30018   LBU V1, 24(SP)
441:                 				csize = csd[9] + ((WORD) csd[8] << 8) + 1;
9D009978  93A30019   LBU V1, 25(SP)
9D00997C  24630001   ADDIU V1, V1, 1
9D009980  93A20018   LBU V0, 24(SP)
9D009984  00021200   SLL V0, V0, 8
9D009988  00621021   ADDU V0, V1, V0
442:                 				*(DWORD*) buff = (DWORD) csize << 10;
9D00998C  00021280   SLL V0, V0, 10
9D009990  AE220000   SW V0, 0(S1)
443:                 			} else { /* SDv1 or MMCv2 */
444:                 				n = (csd[5] & 15) + ((csd[10] & 128) >> 7)
9D0099C0  93A40015   LBU A0, 21(SP)
9D0099C4  3084000F   ANDI A0, A0, 15
9D0099C8  93A2001A   LBU V0, 26(SP)
9D0099CC  000211C2   SRL V0, V0, 7
9D0099D0  00822021   ADDU A0, A0, V0
9D0099D4  93A20019   LBU V0, 25(SP)
9D0099D8  30420003   ANDI V0, V0, 3
9D0099DC  00021040   SLL V0, V0, 1
445:                 						+ ((csd[9] & 3) << 1) + 2;
446:                 				csize = (csd[8] >> 6) + ((WORD) csd[7] << 2) + ((WORD) (csd[6]
9D00999C  00031982   SRL V1, V1, 6
9D0099A0  93A20017   LBU V0, 23(SP)
9D0099A4  00021080   SLL V0, V0, 2
9D0099A8  00621821   ADDU V1, V1, V0
9D0099AC  24630001   ADDIU V1, V1, 1
447:                 						& 3) << 10) + 1;
9D0099B0  93A20016   LBU V0, 22(SP)
9D0099B4  30420003   ANDI V0, V0, 3
9D0099B8  00021280   SLL V0, V0, 10
9D0099BC  00621821   ADDU V1, V1, V0
448:                 				*(DWORD*) buff = (DWORD) csize << (n - 9);
9D0099E0  00821021   ADDU V0, A0, V0
9D0099E4  2442FFF9   ADDIU V0, V0, -7
9D0099E8  00431004   SLLV V0, V1, V0
9D0099EC  AE220000   SW V0, 0(S1)
449:                 			}
450:                 			res = RES_OK;
9D009994  0B4026F8   J 0x9D009BE0
9D009998  00008021   ADDU S0, ZERO, ZERO
9D0099F0  0B4026F8   J 0x9D009BE0
9D0099F4  00008021   ADDU S0, ZERO, ZERO
451:                 		}
452:                 		break;
453:                 
454:                 	case GET_SECTOR_SIZE: /* Get sectors on the disk (WORD) */
455:                 		*(WORD*) buff = 512;
9D0099F8  24020200   ADDIU V0, ZERO, 512
9D0099FC  A4C20000   SH V0, 0(A2)
456:                 		res = RES_OK;
457:                 		break;
9D009A00  0B4026F8   J 0x9D009BE0
9D009A04  00008021   ADDU S0, ZERO, ZERO
458:                 
459:                 	case GET_BLOCK_SIZE: /* Get erase block size in unit of sectors (DWORD) */
460:                 		if (CardType & CT_SD2) { /* SDv2? */
9D009A08  9782803C   LHU V0, -32708(GP)
9D009A0C  30420004   ANDI V0, V0, 4
9D009A10  10400019   BEQ V0, ZERO, 0x9D009A78
9D009A14  24040009   ADDIU A0, ZERO, 9
461:                 			if (send_cmd(ACMD13, 0) == 0) { /* Read SD status */
9D009A18  2404008D   ADDIU A0, ZERO, 141
9D009A1C  0F402460   JAL 0x9D009180
9D009A20  00002821   ADDU A1, ZERO, ZERO
9D009A24  1440006E   BNE V0, ZERO, 0x9D009BE0
9D009A28  24100001   ADDIU S0, ZERO, 1
462:                 				rcvr_spi();
9D009A2C  0F405B0A   JAL writeSPI
9D009A30  240400FF   ADDIU A0, ZERO, 255
463:                 				if (rcvr_datablock(csd, 16)) { /* Read partial block */
9D009A34  27A40010   ADDIU A0, SP, 16
9D009A38  0F4024C8   JAL 0x9D009320
9D009A3C  24050010   ADDIU A1, ZERO, 16
9D009A40  10400067   BEQ V0, ZERO, 0x9D009BE0
9D009A44  00000000   NOP
9D009A48  24100030   ADDIU S0, ZERO, 48
464:                 					for (n = 64 - 16; n; n--)
9D009A54  2610FFFF   ADDIU S0, S0, -1
9D009A58  321000FF   ANDI S0, S0, 255
9D009A5C  1600FFFB   BNE S0, ZERO, 0x9D009A4C
9D009A60  93A2001A   LBU V0, 26(SP)
465:                 						rcvr_spi(); /* Purge trailing data */
9D009A4C  0F405B0A   JAL writeSPI
9D009A50  240400FF   ADDIU A0, ZERO, 255
466:                 					*(DWORD*) buff = 16UL << (csd[10] >> 4);
9D009A64  00021102   SRL V0, V0, 4
9D009A68  24030010   ADDIU V1, ZERO, 16
9D009A6C  00431004   SLLV V0, V1, V0
9D009A70  0B4026F8   J 0x9D009BE0
9D009A74  AE220000   SW V0, 0(S1)
467:                 					res = RES_OK;
468:                 				}
469:                 			}
470:                 		} else { /* SDv1 or MMCv3 */
471:                 			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) { /* Read CSD */
9D009A78  0F402460   JAL 0x9D009180
9D009A7C  00002821   ADDU A1, ZERO, ZERO
9D009A80  14400057   BNE V0, ZERO, 0x9D009BE0
9D009A84  24100001   ADDIU S0, ZERO, 1
9D009A88  27A40010   ADDIU A0, SP, 16
9D009A8C  0F4024C8   JAL 0x9D009320
9D009A90  24050010   ADDIU A1, ZERO, 16
9D009A94  10400052   BEQ V0, ZERO, 0x9D009BE0
9D009A98  9782803C   LHU V0, -32708(GP)
472:                 				if (CardType & CT_SD1) { /* SDv1 */
9D009A9C  30420002   ANDI V0, V0, 2
9D009AA0  1040000F   BEQ V0, ZERO, 0x9D009AE0
9D009AA4  93A2001B   LBU V0, 27(SP)
473:                 					*(DWORD*) buff = (((csd[10] & 63) << 1) + ((WORD) (csd[11]
9D009AB0  24630001   ADDIU V1, V1, 1
9D009AB4  93A2001A   LBU V0, 26(SP)
9D009AB8  3042003F   ANDI V0, V0, 63
9D009ABC  00021040   SLL V0, V0, 1
9D009AD4  AE220000   SW V0, 0(S1)
474:                 							& 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
9D009AA8  93A3001B   LBU V1, 27(SP)
9D009AAC  000319C2   SRL V1, V1, 7
9D009AC0  00621821   ADDU V1, V1, V0
9D009AC4  93A2001D   LBU V0, 29(SP)
9D009AC8  00021182   SRL V0, V0, 6
9D009ACC  2442FFFF   ADDIU V0, V0, -1
9D009AD0  00431004   SLLV V0, V1, V0
475:                 				} else { /* MMCv3 */
476:                 					*(DWORD*) buff = ((WORD) ((csd[10] & 124) >> 2) + 1)
9D009AE0  93A3001A   LBU V1, 26(SP)
9D009AE4  7C632080   EXT V1, V1, 2, 5
9D009AE8  24630001   ADDIU V1, V1, 1
9D009B04  AE220000   SW V0, 0(S1)
477:                 							* (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5)
9D009AEC  00022142   SRL A0, V0, 5
9D009AF0  24840001   ADDIU A0, A0, 1
9D009AF4  30420003   ANDI V0, V0, 3
9D009AF8  000210C0   SLL V0, V0, 3
9D009B00  70621002   MUL V0, V1, V0
478:                 									+ 1);
9D009AFC  00821021   ADDU V0, A0, V0
479:                 				}
480:                 				res = RES_OK;
9D009AD8  0B4026F8   J 0x9D009BE0
9D009ADC  00008021   ADDU S0, ZERO, ZERO
9D009B08  0B4026F8   J 0x9D009BE0
9D009B0C  00008021   ADDU S0, ZERO, ZERO
481:                 			}
482:                 		}
483:                 		break;
484:                 
485:                 	case MMC_GET_TYPE: /* Get card type flags (1 byte) */
486:                 		*ptr = CardType;
9D009B10  9782803C   LHU V0, -32708(GP)
9D009B14  A0C20000   SB V0, 0(A2)
487:                 		res = RES_OK;
488:                 		break;
9D009B18  0B4026F8   J 0x9D009BE0
9D009B1C  00008021   ADDU S0, ZERO, ZERO
489:                 
490:                 	case MMC_GET_CSD: /* Receive CSD as a data block (16 bytes) */
491:                 		if ((send_cmd(CMD9, 0) == 0) /* READ_CSD */
9D009B20  24040009   ADDIU A0, ZERO, 9
9D009B24  0F402460   JAL 0x9D009180
9D009B28  00002821   ADDU A1, ZERO, ZERO
9D009B2C  1440002C   BNE V0, ZERO, 0x9D009BE0
9D009B30  24100001   ADDIU S0, ZERO, 1
492:                 		&& rcvr_datablock(buff, 16))
9D009B34  02202021   ADDU A0, S1, ZERO
9D009B38  0F4024C8   JAL 0x9D009320
9D009B3C  24050010   ADDIU A1, ZERO, 16
493:                 			res = RES_OK;
494:                 		break;
495:                 
496:                 	case MMC_GET_CID: /* Receive CID as a data block (16 bytes) */
497:                 		if ((send_cmd(CMD10, 0) == 0) /* READ_CID */
9D009B48  2404000A   ADDIU A0, ZERO, 10
9D009B4C  0F402460   JAL 0x9D009180
9D009B50  00002821   ADDU A1, ZERO, ZERO
9D009B54  14400022   BNE V0, ZERO, 0x9D009BE0
9D009B58  24100001   ADDIU S0, ZERO, 1
498:                 		&& rcvr_datablock(buff, 16))
9D009B5C  02202021   ADDU A0, S1, ZERO
9D009B60  0F4024C8   JAL 0x9D009320
9D009B64  24050010   ADDIU A1, ZERO, 16
499:                 			res = RES_OK;
500:                 		break;
501:                 
502:                 	case MMC_GET_OCR: /* Receive OCR as an R3 resp (4 bytes) */
503:                 		if (send_cmd(CMD58, 0) == 0) { /* READ_OCR */
9D009B70  2404003A   ADDIU A0, ZERO, 58
9D009B74  0F402460   JAL 0x9D009180
9D009B78  00002821   ADDU A1, ZERO, ZERO
9D009B7C  14400018   BNE V0, ZERO, 0x9D009BE0
9D009B80  24100001   ADDIU S0, ZERO, 1
9D009B84  02209021   ADDU S2, S1, ZERO
504:                 			for (n = 0; n < 4; n++)
9D009B9C  1650FFFB   BNE S2, S0, 0x9D009B8C
9D009BA0  00000000   NOP
505:                 				*((PF_BYTE*) buff + n) = rcvr_spi();
9D009B8C  0F405B0A   JAL writeSPI
9D009B90  240400FF   ADDIU A0, ZERO, 255
9D009B94  A2420000   SB V0, 0(S2)
9D009B98  26520001   ADDIU S2, S2, 1
506:                 			res = RES_OK;
9D009BA4  0B4026F8   J 0x9D009BE0
9D009BA8  00008021   ADDU S0, ZERO, ZERO
507:                 		}
508:                 		break;
509:                 
510:                 	case MMC_GET_SDSTAT: /* Receive SD status as a data block (64 bytes) */
511:                 		if (send_cmd(ACMD13, 0) == 0) { /* SD_STATUS */
9D009BAC  2404008D   ADDIU A0, ZERO, 141
9D009BB0  0F402460   JAL 0x9D009180
9D009BB4  00002821   ADDU A1, ZERO, ZERO
9D009BB8  14400009   BNE V0, ZERO, 0x9D009BE0
9D009BBC  24100001   ADDIU S0, ZERO, 1
512:                 			rcvr_spi();
9D009BC0  0F405B0A   JAL writeSPI
9D009BC4  240400FF   ADDIU A0, ZERO, 255
513:                 			if (rcvr_datablock(buff, 64))
9D009BC8  02202021   ADDU A0, S1, ZERO
9D009BCC  0F4024C8   JAL 0x9D009320
9D009BD0  24050040   ADDIU A1, ZERO, 64
514:                 				res = RES_OK;
515:                 		}
516:                 		break;
517:                 
518:                 	default:
519:                 		res = RES_PARERR;
9D009BDC  24100004   ADDIU S0, ZERO, 4
520:                 	}
521:                 
522:                 	deselect();
9D009BE0  0F404497   JAL disableSD
9D009BE4  00000000   NOP
523:                 
524:                 	return res;
525:                 }//disk_ioctl()
9D009BE8  02001021   ADDU V0, S0, ZERO
9D009BEC  8FBF002C   LW RA, 44(SP)
9D009BF0  8FB20028   LW S2, 40(SP)
9D009BF4  8FB10024   LW S1, 36(SP)
9D009BF8  8FB00020   LW S0, 32(SP)
9D009BFC  03E00008   JR RA
9D009C00  27BD0030   ADDIU SP, SP, 48
526:                 
527:                 /*-----------------------------------------------------------------------*/
528:                 /* Device Timer Interrupt Procedure  (Platform dependent)                */
529:                 /*-----------------------------------------------------------------------*/
530:                 /* This function must be called in period of 1ms                         */
531:                 /*
532:                 void disk_timerproc(void) {
533:                 	static WORD pv;
534:                 	WORD p;
535:                 	PF_BYTE s;
536:                 	UINT16 n;
537:                 
538:                 	n = Timer1; // 1000Hz decrement timer
539:                 	if (n)
540:                 		Timer1 = --n;
541:                 	n = Timer2;
542:                 	if (n)
543:                 		Timer2 = --n;
544:                 
545:                 	p = pv;
546:                 	pv = getCD() & getWP(); // Sample socket switch
547:                 
548:                 	if (p == pv) { // Have contacts stabled?
549:                 		s = Stat;
550:                 
551:                 		if (p & getWP()) // WP is H (write protected)
552:                 			s |= STA_PROTECT;
553:                 		else
554:                 			//* WP is L (write enabled)
555:                 			s &= ~STA_PROTECT;
556:                 
557:                 		if (p & getCD()) // INS = H (Socket empty)
558:                 			s |= (STA_NODISK | STA_NOINIT);
559:                 		else
560:                 			// INS = L (Card inserted)
561:                 			s &= ~STA_NODISK;
562:                 
563:                 		Stat = s;
564:                 	}
565:                 }
566:                 */
567:                 
568:                 /*---------------------------------------------------------*/
569:                 /* User Provided RTC Function for FatFs module             */
570:                 /*---------------------------------------------------------*/
571:                 /* This is a real time clock service to be called from     */
572:                 /* FatFs module. Any valid time must be returned even if   */
573:                 /* the system does not support an RTC.                     */
574:                 /* This function is not required in read-only cfg.         */
575:                 
576:                 /*	The current time is returned packed into a DWORD
577:                 	(32 bit) value. The bit fields are as follows:
578:                 		bits 31:25	Year from 1980 (0..127)
579:                 		bits 24:21	Month (1..12)
580:                 		bits 20:16	Day in month (1..31)
581:                 		bits 15:11	Hour (0..23)
582:                 		bits 10:05	Minute (0..59)
583:                 		bits 04:00	Second / 2 (0..29)						*/
584:                 
585:                 DWORD get_fattime(void) {
586:                 	DWORD tmr = 0;
587:                 
588:                 // Pre-processor commands added so only use RTCC if the board is known
589:                 // to support the RTCC ** Added 07 May 2012
590:                 
591:                 // For boards known to support the RTCC library
592:                 
593:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
594:                 	rtccTime pTm, cTm;
595:                 	rtccDate pDt, cDt;
596:                 
597:                 	RTCC_GetTimeDate(&pTm, &pDt);	// get time and date from RTC
598:                 											// assumes RTC has been set and is running
599:                 											// OK - could be expanded to check that RTC
600:                 											// is running and that a valid value is
601:                 											// being returned by the RTC
602:                 	cTm = RTCC_ConvertTime(&pTm);	// convert time from bcd to decimal format
603:                 	cDt = RTCC_ConvertDate(&pDt);	// convert date from bcd to decimal format
604:                 
605:                 	/* Pack date and time into a DWORD variable */
606:                 //	tmr = (((DWORD) pDt.year - 80)) | ((DWORD) pDt.mon) | ((DWORD) pDt.mday)
607:                 //			| (WORD) (pTm.hour) | (WORD) (pTm.min) | (WORD) (pTm.sec);
608:                 	tmr = cDt.year + 20;
609:                    
610:                   // Correction according to a newer rtcc library, with diff struct members.
611:                   
612:                 	 tmr = (tmr << 4) | cDt.month;		// shifts left 4 bits and adds monthth
613:                 	tmr = (tmr << 5) | cDt.dayofmonth;		// shifts left 5 bits and adds m.day
614:                 	tmr = (tmr << 5) | cTm.hours;		// shifts left 5 bits and adds hour
615:                 	tmr = (tmr << 6) | cTm.minutes;		// shift left 6 bits and adds minutes
616:                 	tmr = (tmr << 5) | (cTm.seconds/2);	// shifts left 5 bits and adds seconds/2
617:                 
618:                 //	For other boards use a fixed date and time of 01 Jan 2012 12:00:00
619:                 #else
620:                      tmr = 12 + 20;
621:                      tmr = (tmr << 4) | 1;       // shifts left 4 bits and adds month
622:                      tmr = (tmr << 5) | 1;    	// shifts left 5 bits and adds m.day
623:                      tmr = (tmr << 5) | 12;    	// shifts left 5 bits and adds hour
624:                      tmr = (tmr << 6) | 0;       // shift left 6 bits and adds minutes
625:                      tmr = (tmr << 5) | (0/2);   // shifts left 5 bits and adds seconds/2
626:                 #endif
627:                 
628:                 	return tmr;
629:                 } // get_fattime()
9D009C04  3C024021   LUI V0, 16417
9D009C08  03E00008   JR RA
9D009C0C  24426000   ADDIU V0, V0, 24576
630:                 
631:                 void put_rc(FRESULT rc) {
632:                     char *fmt;
633:                 
634:                 	const char *str =
635:                                         "OK\0" "DISK_ERR\0" "INT_ERR\0" "NOT_READY\0" "NO_FILE\0" "NO_PATH\0"
636:                                                 "INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
637:                                                 "INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
638:                                                 "LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0";
639:                 	FRESULT i;
640:                             for (i = 0; i != rc && *str; i++) {
641:                                     while (*str++)
642:                                             ;
643:                             }
644:                             print_error_msg(ERR_FIO,str,rc);
645:                 }//put_rc()
646:                 
---  /home/jacques/MPLABXProjects/vpc-32/hardware/HardwareProfile.c  ------------------------------------
1:                   /*
2:                   * Copyright 2013,2014 Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   HardwareProfile.h
21:                   * Author: Jacques Deschênes
22:                   * Description: configuration hardware spécifique, assignation des périphériques
23:                   *     UART2 assigné à PB10,PB11
24:                   * Created on 17 avril 2013, 14:41
25:                   *
26:                   */
27:                  
28:                  #include "HardwareProfile.h"
29:                  #include <plib.h>
30:                  #include "sound/sound.h"
31:                  
32:                  volatile unsigned int  sys_tick; // compteur pour les milli-secondes
33:                  
34:                  
35:                  void HardwareInit(){
9D00F814  27BDFFE8   ADDIU SP, SP, -24
9D00F818  AFBF0014   SW RA, 20(SP)
36:                     SYSTEMConfig(mGetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
37:                     INTEnableSystemMultiVectoredInt();
9D00F840  0F405DE3   JAL INTEnableSystemMultiVectoredInt
9D00F844  00000000   NOP
38:                      // configure coretimer pour le sys_tick
39:                  #ifdef USE_CORE_TIMER
40:                     OpenCoreTimer(CORE_TICK_RATE);
9D00F848  0F405F7C   JAL OpenCoreTimer
9D00F84C  24044E20   ADDIU A0, ZERO, 20000
41:                     mConfigIntCoreTimer((CT_INT_ON | CT_INT_PRIOR_1 | CT_INT_SUB_PRIOR_0));
9D00F850  24020001   ADDIU V0, ZERO, 1
9D00F854  3C03BF88   LUI V1, -16504
9D00F858  AC621034   SW V0, 4148(V1)
9D00F85C  3C04BF88   LUI A0, -16504
9D00F860  2403001C   ADDIU V1, ZERO, 28
9D00F864  AC831094   SW V1, 4244(A0)
9D00F868  3C03BF88   LUI V1, -16504
9D00F86C  24050004   ADDIU A1, ZERO, 4
9D00F870  AC651098   SW A1, 4248(V1)
9D00F874  24070003   ADDIU A3, ZERO, 3
9D00F878  AC871094   SW A3, 4244(A0)
9D00F87C  AC601098   SW ZERO, 4248(V1)
9D00F880  3C03BF88   LUI V1, -16504
9D00F884  AC621064   SW V0, 4196(V1)
9D00F888  3C03BF88   LUI V1, -16504
9D00F88C  AC621068   SW V0, 4200(V1)
42:                  #endif
43:                     // désactivation de toutes les entrée analogiques.
44:                     ANSELBCLR=0xFFFFFFFF;
9D00F890  3C03BF88   LUI V1, -16504
9D00F894  2404FFFF   ADDIU A0, ZERO, -1
9D00F898  AC646104   SW A0, 24836(V1)
45:                     ANSELACLR=0xFFFFFFFF;
9D00F89C  3C06BF88   LUI A2, -16504
9D00F8A0  ACC46004   SW A0, 24580(A2)
46:                      // configuration PB10 sortie et PB11 entrée
47:                     mPORTBSetBits(TX); // mettre à Vdd pour ne pas généré un faux start bit.
9D00F8A4  24060400   ADDIU A2, ZERO, 1024
9D00F8A8  3C04BF88   LUI A0, -16504
9D00F8AC  AC866138   SW A2, 24888(A0)
48:                     mPORTBSetPinsDigitalOut(TX);      // sortie PB10(Tx), transmission UART2
9D00F8B0  3C04BF88   LUI A0, -16504
9D00F8B4  AC866114   SW A2, 24852(A0)
9D00F8B8  AC666104   SW A2, 24836(V1)
49:                     mPORTBSetPinsDigitalIn (RX);      // entrée PB11(Rx), réception UART2
9D00F8BC  24060800   ADDIU A2, ZERO, 2048
9D00F8C0  3C08BF88   LUI T0, -16504
9D00F8C4  AD066118   SW A2, 24856(T0)
9D00F8C8  AC666104   SW A2, 24836(V1)
50:                     // assignation des périphériques aux broches
51:                     // l'information se trouve dans pps.h
52:                     PPSUnLock;                     // déverrouillage configuration assignation périphérique
9D00F8CC  3C03BF81   LUI V1, -16511
9D00F8D0  8C66F200   LW A2, -3584(V1)
9D00F8D4  7C066B44   INS A2, ZERO, 13, 1
9D00F8D8  AC66F200   SW A2, -3584(V1)
53:                     //clavier
54:                     I2C1CONbits.DISSLW=1; // voir pic32mx1xxx/2xxx-errata.pdf rev. E, point 9
9D00F8DC  3C06BF80   LUI A2, -16512
9D00F8E0  8CC85000   LW T0, 20480(A2)
9D00F8E4  7C484A44   INS T0, V0, 9, 1
9D00F8E8  ACC85000   SW T0, 20480(A2)
55:                     RPA0R=0;  // pas de périphérique sur RA0 (keyboard clock)
9D00F8EC  3C06BF81   LUI A2, -16511
9D00F8F0  ACC0FB00   SW ZERO, -1280(A2)
56:                     RPA1R=0;  // pas de périphérique sur RA1 (keyboard data)
9D00F8F4  3C06BF81   LUI A2, -16511
9D00F8F8  ACC0FB04   SW ZERO, -1276(A2)
57:                     RPB1R=0;  // pas de périphérique sur RPB1 ~CS1 SRAM
9D00F8FC  3C06BF81   LUI A2, -16511
9D00F900  ACC0FB30   SW ZERO, -1232(A2)
58:                     RPB2R=0;  // pas de périphérique sur RPB2 ~CS2 SDCARD
9D00F904  3C06BF81   LUI A2, -16511
9D00F908  ACC0FB34   SW ZERO, -1228(A2)
59:                     RPB3R=0; //  pas de périphérique sur RB3 (status LED)
9D00F90C  3C06BF81   LUI A2, -16511
9D00F910  ACC0FB38   SW ZERO, -1224(A2)
60:                     RPB15R=0; // pad de périphérique sur RB15
9D00F914  3C06BF81   LUI A2, -16511
9D00F918  ACC0FB68   SW ZERO, -1176(A2)
61:                     TRISBCLR=STATUS_LED; // broche status LED en sortie
9D00F91C  24060008   ADDIU A2, ZERO, 8
9D00F920  AC866114   SW A2, 24852(A0)
62:                     _status_off();
9D00F924  3C08BF88   LUI T0, -16504
9D00F928  AD066124   SW A2, 24868(T0)
63:                     PPSOutput(4, RPB10, U2TX);  // assignation U2TX sur PB10, (groupe, pin, fonction)
9D00F92C  3C06BF81   LUI A2, -16511
9D00F930  8CC9FB54   LW T1, -1196(A2)
9D00F934  24080002   ADDIU T0, ZERO, 2
9D00F938  7D091804   INS T1, T0, 0, 4
9D00F93C  ACC9FB54   SW T1, -1196(A2)
64:                     PPSInput (2, U2RX, RPB11);  // assignation U2RX sur PB11, (groupe, fonction, pin)
9D00F940  3C06BF81   LUI A2, -16511
9D00F944  8CC9FA58   LW T1, -1448(A2)
9D00F948  7CE91804   INS T1, A3, 0, 4
9D00F94C  ACC9FA58   SW T1, -1448(A2)
65:                     PPSOutput(2,RPB5,OC2); // 5=OC2  sur PB5 sortie synchronistaiton ntsc
9D00F950  3C09BF81   LUI T1, -16511
9D00F954  8D2AFB40   LW T2, -1216(T1)
9D00F958  24060005   ADDIU A2, ZERO, 5
9D00F95C  7CCA1804   INS T2, A2, 0, 4
9D00F960  AD2AFB40   SW T2, -1216(T1)
66:                     PPSOutput(1,RPB4,OC1);  // 5=OC1 impulsion déclenchant SPI , Fsync vidéo
9D00F964  3C09BF81   LUI T1, -16511
9D00F968  8D2AFB3C   LW T2, -1220(T1)
9D00F96C  7CCA1804   INS T2, A2, 0, 4
9D00F970  AD2AFB3C   SW T2, -1220(T1)
67:                     PPSOutput(3,RPB6,SDO1); // 3=SDO1 sortie SPI1 (vidéo)
9D00F974  3C09BF81   LUI T1, -16511
9D00F978  8D2AFB44   LW T2, -1212(T1)
9D00F97C  7CEA1804   INS T2, A3, 0, 4
9D00F980  AD2AFB44   SW T2, -1212(T1)
68:                     PPSOutput(4,RPB9,OC3); // OC3 sortie audio.
9D00F984  3C07BF81   LUI A3, -16511
9D00F988  8CE9FB50   LW T1, -1200(A3)
9D00F98C  7CC91804   INS T1, A2, 0, 4
9D00F990  ACE9FB50   SW T1, -1200(A3)
69:                     PPSInput(1,SS1,RPB7); // entrée Fsync sur RPB7
9D00F994  3C06BF81   LUI A2, -16511
9D00F998  8CC7FA88   LW A3, -1400(A2)
9D00F99C  7CA71804   INS A3, A1, 0, 4
9D00F9A0  ACC7FA88   SW A3, -1400(A2)
70:                     PPSInput(3,SDI2,RPA4); // entrée SDI pour carte SD
9D00F9A4  3C06BF81   LUI A2, -16511
9D00F9A8  8CC7FA90   LW A3, -1392(A2)
9D00F9AC  7D071804   INS A3, T0, 0, 4
9D00F9B0  ACC7FA90   SW A3, -1392(A2)
71:                     PPSOutput(2,RPB8,SDO2); // sortie commande carte SD
9D00F9B4  3C06BF81   LUI A2, -16511
9D00F9B8  8CC7FB4C   LW A3, -1204(A2)
9D00F9BC  7CA71804   INS A3, A1, 0, 4
9D00F9C0  ACC7FB4C   SW A3, -1204(A2)
72:                     PPSOutput(2,RPB1,NULL); // sortie GPIO RB1, ~CS1  (SPIRAM)
9D00F9C4  3C05BF81   LUI A1, -16511
9D00F9C8  8CA6FB30   LW A2, -1232(A1)
9D00F9CC  7C061804   INS A2, ZERO, 0, 4
9D00F9D0  ACA6FB30   SW A2, -1232(A1)
73:                     TRISBCLR=1|(1<<14); // RB0 et RB14 sortie GPIO
9D00F9D4  24054001   ADDIU A1, ZERO, 16385
9D00F9D8  AC856114   SW A1, 24852(A0)
74:                     PPSOutput(4,RPB0,NULL); // sortie GPIO RB0, snes_clock
9D00F9DC  3C04BF81   LUI A0, -16511
9D00F9E0  8C85FB2C   LW A1, -1236(A0)
9D00F9E4  7C051804   INS A1, ZERO, 0, 4
9D00F9E8  AC85FB2C   SW A1, -1236(A0)
75:                     PPSOutput(4,RPB14,NULL); // sortie GPIO RB14, snes_latch
9D00F9EC  3C04BF81   LUI A0, -16511
9D00F9F0  8C85FB64   LW A1, -1180(A0)
9D00F9F4  7C051804   INS A1, ZERO, 0, 4
9D00F9F8  AC85FB64   SW A1, -1180(A0)
76:                     PPSLock;                // reverrouille pour éviter assignation accidentelle.
9D00F9FC  8C64F200   LW A0, -3584(V1)
9D00FA00  7C446B44   INS A0, V0, 13, 1
9D00FA04  AC64F200   SW A0, -3584(V1)
77:                  }
9D00FA08  8FBF0014   LW RA, 20(SP)
9D00FA0C  03E00008   JR RA
9D00FA10  27BD0018   ADDIU SP, SP, 24
78:                  
79:                  inline unsigned int ticks(void){
80:                      return sys_tick;
9D00FA14  8F8280C8   LW V0, -32568(GP)
81:                  } //ticks()
9D00FA18  03E00008   JR RA
9D00FA1C  00000000   NOP
82:                  
83:                  inline void delay_us(unsigned int usec){
84:                      for (usec=usec*(CLK_PER_USEC/3);usec;usec--);
9D00FA20  00041080   SLL V0, A0, 2
9D00FA24  00041900   SLL V1, A0, 4
9D00FA28  00621023   SUBU V0, V1, V0
9D00FA2C  00442021   ADDU A0, V0, A0
9D00FA30  10800003   BEQ A0, ZERO, 0x9D00FA40
9D00FA34  2484FFFF   ADDIU A0, A0, -1
9D00FA38  1480FFFF   BNE A0, ZERO, 0x9D00FA38
9D00FA3C  2484FFFF   ADDIU A0, A0, -1
9D00FA40  03E00008   JR RA
9D00FA44  00000000   NOP
85:                  }//delay_us()
86:                  
87:                  void delay_ms(unsigned int msec){
88:                  #ifdef USE_CORE_TIMER
89:                      unsigned int t0;
90:                      t0=sys_tick+msec;
9D00FA48  8F8280C8   LW V0, -32568(GP)
9D00FA4C  00821021   ADDU V0, A0, V0
91:                      while (sys_tick!=t0);
9D00FA50  8F8380C8   LW V1, -32568(GP)
9D00FA54  1462FFFE   BNE V1, V0, 0x9D00FA50
9D00FA58  00000000   NOP
92:                  #else
93:                      while (msec--)
94:                          delay_us(1000);
95:                  #endif
96:                  } // delay_ms()
9D00FA5C  03E00008   JR RA
9D00FA60  00000000   NOP
97:                  
98:                  // détermine la mémoire disponible
99:                  // sur le heap
100:                 // essais successifs par division binaire
101:                 unsigned free_heap(){
9D00FA64  27BDFFD8   ADDIU SP, SP, -40
9D00FA68  AFBF0024   SW RA, 36(SP)
9D00FA6C  AFB30020   SW S3, 32(SP)
9D00FA70  AFB2001C   SW S2, 28(SP)
9D00FA74  AFB10018   SW S1, 24(SP)
9D00FA78  AFB00014   SW S0, 20(SP)
102:                     unsigned top=RAM_SIZE,size,bottom=0;
9D00FA7C  00009021   ADDU S2, ZERO, ZERO
9D00FA84  3C130001   LUI S3, 1
103:                     void *ptr=NULL;
104:                 
105:                     size=RAM_SIZE/2;
9D00FA80  34108000   ORI S0, ZERO, -32768
106:                     while ((top-bottom)>16){
9D00FAC4  02721023   SUBU V0, S3, S2
9D00FAC8  2C420011   SLTIU V0, V0, 17
9D00FACC  1040FFEE   BEQ V0, ZERO, 0x9D00FA88
9D00FAD0  00000000   NOP
107:                         ptr=malloc(size);
9D00FA88  0F4047DE   JAL malloc
9D00FA8C  02002021   ADDU A0, S0, ZERO
108:                         if (!ptr){
9D00FA90  14400006   BNE V0, ZERO, 0x9D00FAAC
9D00FA94  00408821   ADDU S1, V0, ZERO
109:                             top=size;
110:                             size-=(top-bottom)>>1;
9D00FA98  02121023   SUBU V0, S0, S2
9D00FA9C  00021042   SRL V0, V0, 1
9D00FAA0  02009821   ADDU S3, S0, ZERO
9D00FAA4  0B403EB1   J 0x9D00FAC4
9D00FAA8  02028023   SUBU S0, S0, V0
111:                         }else{
112:                             free(ptr);
9D00FAAC  0F405E55   JAL free
9D00FAB0  00402021   ADDU A0, V0, ZERO
113:                             bottom=size;
114:                             size+=(top-bottom)>>1;
9D00FAB4  02701023   SUBU V0, S3, S0
9D00FAB8  00021042   SRL V0, V0, 1
9D00FABC  02009021   ADDU S2, S0, ZERO
9D00FAC0  00508021   ADDU S0, V0, S0
115:                         }
116:                     }
117:                     if (ptr) free(ptr);
9D00FAD4  12200004   BEQ S1, ZERO, 0x9D00FAE8
9D00FAD8  02001021   ADDU V0, S0, ZERO
9D00FADC  0F405E55   JAL free
9D00FAE0  02202021   ADDU A0, S1, ZERO
118:                     return size;
119:                 }
9D00FAE4  02001021   ADDU V0, S0, ZERO
9D00FAE8  8FBF0024   LW RA, 36(SP)
9D00FAEC  8FB30020   LW S3, 32(SP)
9D00FAF0  8FB2001C   LW S2, 28(SP)
9D00FAF4  8FB10018   LW S1, 24(SP)
9D00FAF8  8FB00014   LW S0, 20(SP)
9D00FAFC  03E00008   JR RA
9D00FB00  27BD0028   ADDIU SP, SP, 40
120:                 
121:                 #ifdef USE_CORE_TIMER
122:                   //déclaration du gestionnaire d'interruption
123:                    void __ISR(_CORE_TIMER_VECTOR, IPL1SOFT)  CoreTimerHandler(void){
9D00FB04  415DE800   RDPGPR SP, SP
9D00FB08  401A7000   MFC0 K0, EPC
9D00FB0C  401B6000   MFC0 K1, Status
9D00FB10  27BDFFE8   ADDIU SP, SP, -24
9D00FB14  AFBA0014   SW K0, 20(SP)
9D00FB18  401A6002   MFC0 K0, SRSCtl
9D00FB1C  AFBB0010   SW K1, 16(SP)
9D00FB20  AFBA000C   SW K0, 12(SP)
9D00FB24  7C1B7844   INS K1, ZERO, 1, 15
9D00FB28  377B0400   ORI K1, K1, 1024
9D00FB2C  409B6000   MTC0 K1, Status
9D00FB30  AFA30004   SW V1, 4(SP)
9D00FB34  AFA20000   SW V0, 0(SP)
124:                        sys_tick++;
9D00FB38  8F8280C8   LW V0, -32568(GP)
9D00FB3C  24420001   ADDIU V0, V0, 1
9D00FB40  AF8280C8   SW V0, -32568(GP)
125:                        __asm__("mfc0 $v0, $11");
9D00FB44  40025800   MFC0 V0, Compare
126:                        __asm__("addiu $v0,$v0,%0"::"I"(CORE_TICK_RATE));
9D00FB48  24424E20   ADDIU V0, V0, 20000
127:                        __asm__("mtc0 $v0, $11");
9D00FB4C  40825800   MTC0 V0, Compare
128:                        mCTClearIntFlag();
9D00FB50  24030001   ADDIU V1, ZERO, 1
9D00FB54  3C02BF88   LUI V0, -16504
9D00FB58  AC431034   SW V1, 4148(V0)
129:                        if ((fSound & TONE_ON) && !(--duration)){
9D00FB5C  9382803F   LBU V0, -32705(GP)
9D00FB60  30420001   ANDI V0, V0, 1
9D00FB64  1040000E   BEQ V0, ZERO, 0x9D00FBA0
9D00FB68  00000000   NOP
9D00FB6C  8F8280C4   LW V0, -32572(GP)
9D00FB70  2442FFFF   ADDIU V0, V0, -1
9D00FB74  AF8280C4   SW V0, -32572(GP)
9D00FB78  8F8280C4   LW V0, -32572(GP)
9D00FB7C  14400008   BNE V0, ZERO, 0x9D00FBA0
9D00FB80  00000000   NOP
130:                            fSound &= ~TONE_ON;
9D00FB84  9382803F   LBU V0, -32705(GP)
9D00FB88  304200FE   ANDI V0, V0, 254
9D00FB8C  A382803F   SB V0, -32705(GP)
131:                            mTone_off();
9D00FB90  3C02BF80   LUI V0, -16512
9D00FB94  8C433400   LW V1, 13312(V0)
9D00FB98  7C037BC4   INS V1, ZERO, 15, 1
9D00FB9C  AC433400   SW V1, 13312(V0)
132:                        }
133:                    };
9D00FBA0  8FA30004   LW V1, 4(SP)
9D00FBA4  8FA20000   LW V0, 0(SP)
9D00FBA8  41606000   DI ZERO
9D00FBAC  000000C0   EHB
9D00FBB0  8FBA0014   LW K0, 20(SP)
9D00FBB4  8FBB0010   LW K1, 16(SP)
9D00FBB8  409A7000   MTC0 K0, EPC
9D00FBBC  8FBA000C   LW K0, 12(SP)
9D00FBC0  27BD0018   ADDIU SP, SP, 24
9D00FBC4  409A6002   MTC0 K0, SRSCtl
9D00FBC8  41DDE800   WRPGPR SP, SP
9D00FBCC  409B6000   MTC0 K1, Status
9D00FBD0  42000018   ERET
134:                 #endif
135:                 
---  /home/jacques/MPLABXProjects/vpc-32/graphics.c  ----------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   *  File: graphics.c
20:                   *  Author: Jacques Deschênes
21:                   *  Created on 2 novembre 2013
22:                   *  Description: fonctions graphiques.
23:                   *  REF: http://en.wikipedia.org/wiki/Midpoint_circle_algorithm
24:                   *  REF: http://members.chello.at/~easyfilter/bresenham.html
25:                   */
26:                  #include "hardware/tvout/ntsc.h"
27:                  #include <math.h>
28:                  
29:                  int getPixel(int x, int y){
30:                      int h,ofs;
31:                      h=x/32;
9D00B16C  2486001F   ADDIU A2, A0, 31
9D00B170  28870000   SLTI A3, A0, 0
9D00B174  00C7200B   MOVN A0, A2, A3
9D00B178  00043143   SRA A2, A0, 5
32:                      ofs=31-x%32;
9D00B14C  000417C3   SRA V0, A0, 31
9D00B150  000216C2   SRL V0, V0, 27
9D00B154  00821821   ADDU V1, A0, V0
9D00B158  3063001F   ANDI V1, V1, 31
9D00B15C  00431823   SUBU V1, V0, V1
9D00B160  2463001F   ADDIU V1, V1, 31
33:                      return (video_bmp[y][h]&(1<<ofs))>>ofs;
9D00B164  24020001   ADDIU V0, ZERO, 1
9D00B168  00621004   SLLV V0, V0, V1
9D00B17C  00052040   SLL A0, A1, 1
9D00B180  000528C0   SLL A1, A1, 3
9D00B184  00852021   ADDU A0, A0, A1
9D00B188  00862021   ADDU A0, A0, A2
9D00B18C  00042080   SLL A0, A0, 2
9D00B190  3C06A000   LUI A2, -24576
9D00B194  24C60138   ADDIU A2, A2, 312
9D00B198  00862021   ADDU A0, A0, A2
9D00B19C  8C840000   LW A0, 0(A0)
9D00B1A0  00441024   AND V0, V0, A0
34:                  }//getPixel()
9D00B1A4  03E00008   JR RA
9D00B1A8  00621006   SRLV V0, V0, V1
35:                  
36:                  void setPixel(int x, int y){
37:                      int h,ofs;
38:                      if (y>(VRES-1)) return; // hors limites
9D00B1AC  28A200D0   SLTI V0, A1, 208
9D00B1B0  10400019   BEQ V0, ZERO, 0x9D00B218
9D00B1B4  2482001F   ADDIU V0, A0, 31
39:                      h= x/32;
9D00B1B8  28830000   SLTI V1, A0, 0
9D00B1BC  0083100A   MOVZ V0, A0, V1
9D00B1C0  00021143   SRA V0, V0, 5
40:                      if (h>HRES/32) return; // hors limites
9D00B1C4  2843000B   SLTI V1, V0, 11
9D00B1C8  10600013   BEQ V1, ZERO, 0x9D00B218
9D00B1CC  00051840   SLL V1, A1, 1
41:                      ofs = 31 - x%32;
9D00B1EC  00041FC3   SRA V1, A0, 31
9D00B1F0  00031EC2   SRL V1, V1, 27
9D00B1F4  00832021   ADDU A0, A0, V1
9D00B1F8  3084001F   ANDI A0, A0, 31
9D00B1FC  00641823   SUBU V1, V1, A0
9D00B200  2463001F   ADDIU V1, V1, 31
42:                      video_bmp[y][h]|= (1<<ofs);
9D00B1D0  000528C0   SLL A1, A1, 3
9D00B1D4  00652821   ADDU A1, V1, A1
9D00B1D8  00A21021   ADDU V0, A1, V0
9D00B1DC  00021080   SLL V0, V0, 2
9D00B1E0  3C03A000   LUI V1, -24576
9D00B1E4  24630138   ADDIU V1, V1, 312
9D00B1E8  00431021   ADDU V0, V0, V1
9D00B204  24040001   ADDIU A0, ZERO, 1
9D00B208  00641804   SLLV V1, A0, V1
9D00B20C  8C450000   LW A1, 0(V0)
9D00B210  00651825   OR V1, V1, A1
9D00B214  AC430000   SW V1, 0(V0)
9D00B218  03E00008   JR RA
9D00B21C  00000000   NOP
43:                  } // setPixel()
44:                  
45:                  void clearPixel(int x, int y){
46:                      int h,ofs;
47:                      if (y>(VRES-1)) return; // hors limites
9D00B220  28A200D0   SLTI V0, A1, 208
9D00B224  1040001A   BEQ V0, ZERO, 0x9D00B290
9D00B228  2482001F   ADDIU V0, A0, 31
48:                      h= x/32;
9D00B22C  28830000   SLTI V1, A0, 0
9D00B230  0083100A   MOVZ V0, A0, V1
9D00B234  00021143   SRA V0, V0, 5
49:                      if (h>HRES/32) return; // hors limites
9D00B238  2843000B   SLTI V1, V0, 11
9D00B23C  10600014   BEQ V1, ZERO, 0x9D00B290
9D00B240  00051840   SLL V1, A1, 1
50:                      ofs = 31 - x%32;
9D00B260  00041FC3   SRA V1, A0, 31
9D00B264  00031EC2   SRL V1, V1, 27
9D00B268  00832021   ADDU A0, A0, V1
9D00B26C  3084001F   ANDI A0, A0, 31
9D00B270  00641823   SUBU V1, V1, A0
9D00B274  2463001F   ADDIU V1, V1, 31
51:                      video_bmp[y][h]&= ~(1<<ofs);
9D00B244  000528C0   SLL A1, A1, 3
9D00B248  00652821   ADDU A1, V1, A1
9D00B24C  00A21021   ADDU V0, A1, V0
9D00B250  00021080   SLL V0, V0, 2
9D00B254  3C03A000   LUI V1, -24576
9D00B258  24630138   ADDIU V1, V1, 312
9D00B25C  00431021   ADDU V0, V0, V1
9D00B278  24040001   ADDIU A0, ZERO, 1
9D00B27C  00641804   SLLV V1, A0, V1
9D00B280  00031827   NOR V1, ZERO, V1
9D00B284  8C440000   LW A0, 0(V0)
9D00B288  00641824   AND V1, V1, A0
9D00B28C  AC430000   SW V1, 0(V0)
9D00B290  03E00008   JR RA
9D00B294  00000000   NOP
52:                  }//clearPixel()
53:                  
54:                  //  REF: http://members.chello.at/~easyfilter/bresenham.html
55:                  void line(int x0, int y0, int x1, int y1)
56:                  {
9D00B298  27BDFFC8   ADDIU SP, SP, -56
9D00B29C  AFBF0034   SW RA, 52(SP)
9D00B2A0  AFBE0030   SW S8, 48(SP)
9D00B2A4  AFB7002C   SW S7, 44(SP)
9D00B2A8  AFB60028   SW S6, 40(SP)
9D00B2AC  AFB50024   SW S5, 36(SP)
9D00B2B0  AFB40020   SW S4, 32(SP)
9D00B2B4  AFB3001C   SW S3, 28(SP)
9D00B2B8  AFB20018   SW S2, 24(SP)
9D00B2BC  AFB10014   SW S1, 20(SP)
9D00B2C0  AFB00010   SW S0, 16(SP)
9D00B2C4  00808021   ADDU S0, A0, ZERO
9D00B2C8  00A09021   ADDU S2, A1, ZERO
9D00B2CC  00C0A821   ADDU S5, A2, ZERO
9D00B2D0  00E0F021   ADDU S8, A3, ZERO
57:                     int dx =  abs(x1-x0), sx = x0<x1 ? 1 : -1;
9D00B2D4  00C49823   SUBU S3, A2, A0
9D00B2D8  001317C3   SRA V0, S3, 31
9D00B2DC  00539826   XOR S3, V0, S3
9D00B2E0  02629823   SUBU S3, S3, V0
9D00B2E4  0086B02A   SLT S6, A0, A2
9D00B2E8  24020001   ADDIU V0, ZERO, 1
9D00B2EC  2403FFFF   ADDIU V1, ZERO, -1
9D00B2F0  0076100A   MOVZ V0, V1, S6
9D00B2F4  0040B021   ADDU S6, V0, ZERO
58:                     int dy = -abs(y1-y0), sy = y0<y1 ? 1 : -1;
9D00B2F8  00E5A023   SUBU S4, A3, A1
9D00B2FC  001417C3   SRA V0, S4, 31
9D00B300  0054A026   XOR S4, V0, S4
9D00B304  0054A023   SUBU S4, V0, S4
9D00B308  00A7B82A   SLT S7, A1, A3
9D00B30C  24020001   ADDIU V0, ZERO, 1
9D00B310  0077100A   MOVZ V0, V1, S7
9D00B314  0040B821   ADDU S7, V0, ZERO
59:                     int err = dx+dy, e2; /* error value e_xy */
9D00B318  02938821   ADDU S1, S4, S3
60:                  
61:                     for(;;){  /* loop */
62:                        setPixel(x0,y0);
9D00B31C  02002021   ADDU A0, S0, ZERO
9D00B320  0F402C6B   JAL setPixel
9D00B324  02402821   ADDU A1, S2, ZERO
63:                        if (x0==x1 && y0==y1) break;
9D00B328  16150003   BNE S0, S5, 0x9D00B338
9D00B32C  00111040   SLL V0, S1, 1
9D00B330  125E000B   BEQ S2, S8, 0x9D00B360
9D00B334  8FBF0034   LW RA, 52(SP)
64:                        e2 = 2*err;
65:                        if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
9D00B338  0054182A   SLT V1, V0, S4
9D00B33C  14600003   BNE V1, ZERO, 0x9D00B34C
9D00B340  0262102A   SLT V0, S3, V0
9D00B344  02348821   ADDU S1, S1, S4
9D00B348  02168021   ADDU S0, S0, S6
66:                        if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
9D00B34C  1440FFF4   BNE V0, ZERO, 0x9D00B320
9D00B350  02002021   ADDU A0, S0, ZERO
9D00B354  02338821   ADDU S1, S1, S3
9D00B358  0B402CC8   J 0x9D00B320
9D00B35C  02579021   ADDU S2, S2, S7
67:                     }
68:                  }//line()
9D00B360  8FBE0030   LW S8, 48(SP)
9D00B364  8FB7002C   LW S7, 44(SP)
9D00B368  8FB60028   LW S6, 40(SP)
9D00B36C  8FB50024   LW S5, 36(SP)
9D00B370  8FB40020   LW S4, 32(SP)
9D00B374  8FB3001C   LW S3, 28(SP)
9D00B378  8FB20018   LW S2, 24(SP)
9D00B37C  8FB10014   LW S1, 20(SP)
9D00B380  8FB00010   LW S0, 16(SP)
9D00B384  03E00008   JR RA
9D00B388  27BD0038   ADDIU SP, SP, 56
69:                  
70:                  void rectangle(int x1, int y1, int x2, int y2){
9D00B38C  27BDFFD8   ADDIU SP, SP, -40
9D00B390  AFBF0024   SW RA, 36(SP)
9D00B394  AFB30020   SW S3, 32(SP)
9D00B398  AFB2001C   SW S2, 28(SP)
9D00B39C  AFB10018   SW S1, 24(SP)
9D00B3A0  AFB00014   SW S0, 20(SP)
9D00B3A4  00808821   ADDU S1, A0, ZERO
9D00B3A8  00A09821   ADDU S3, A1, ZERO
9D00B3AC  00C08021   ADDU S0, A2, ZERO
9D00B3B0  00E09021   ADDU S2, A3, ZERO
71:                      line(x1,y1,x1,y2);
9D00B3B4  0F402CA6   JAL line
9D00B3B8  00803021   ADDU A2, A0, ZERO
72:                      line(x2,y1,x2,y2);
9D00B3BC  02002021   ADDU A0, S0, ZERO
9D00B3C0  02602821   ADDU A1, S3, ZERO
9D00B3C4  02003021   ADDU A2, S0, ZERO
9D00B3C8  0F402CA6   JAL line
9D00B3CC  02403821   ADDU A3, S2, ZERO
73:                      line(x1,y1,x2,y1);
9D00B3D0  02202021   ADDU A0, S1, ZERO
9D00B3D4  02602821   ADDU A1, S3, ZERO
9D00B3D8  02003021   ADDU A2, S0, ZERO
9D00B3DC  0F402CA6   JAL line
9D00B3E0  02603821   ADDU A3, S3, ZERO
74:                      line(x1,y2,x2,y2);
9D00B3E4  02202021   ADDU A0, S1, ZERO
9D00B3E8  02402821   ADDU A1, S2, ZERO
9D00B3EC  02003021   ADDU A2, S0, ZERO
9D00B3F0  0F402CA6   JAL line
9D00B3F4  02403821   ADDU A3, S2, ZERO
75:                  }//rectangle()
9D00B3F8  8FBF0024   LW RA, 36(SP)
9D00B3FC  8FB30020   LW S3, 32(SP)
9D00B400  8FB2001C   LW S2, 28(SP)
9D00B404  8FB10018   LW S1, 24(SP)
9D00B408  8FB00014   LW S0, 20(SP)
9D00B40C  03E00008   JR RA
9D00B410  27BD0028   ADDIU SP, SP, 40
76:                  
77:                  //  REF: http://members.chello.at/~easyfilter/bresenham.html
78:                  void circle(int xc, int yc, int r)
79:                  {
9D00B414  27BDFFD8   ADDIU SP, SP, -40
9D00B418  AFBF0024   SW RA, 36(SP)
9D00B41C  AFB40020   SW S4, 32(SP)
9D00B420  AFB3001C   SW S3, 28(SP)
9D00B424  AFB20018   SW S2, 24(SP)
9D00B428  AFB10014   SW S1, 20(SP)
9D00B42C  AFB00010   SW S0, 16(SP)
9D00B430  00809821   ADDU S3, A0, ZERO
9D00B434  00A0A021   ADDU S4, A1, ZERO
80:                     int x = -r, y = 0, err = 2-2*r; /* II. Quadrant */
9D00B438  00068023   SUBU S0, ZERO, A2
9D00B43C  00109040   SLL S2, S0, 1
9D00B440  26520002   ADDIU S2, S2, 2
9D00B444  00008821   ADDU S1, ZERO, ZERO
81:                     do {
82:                        setPixel(xc-x, yc+y); /*   I. Quadrant */
9D00B448  02702023   SUBU A0, S3, S0
9D00B44C  0F402C6B   JAL setPixel
9D00B450  02342821   ADDU A1, S1, S4
83:                        setPixel(xc-y, yc-x); /*  II. Quadrant */
9D00B454  02712023   SUBU A0, S3, S1
9D00B458  0F402C6B   JAL setPixel
9D00B45C  02902823   SUBU A1, S4, S0
84:                        setPixel(xc+x, yc-y); /* III. Quadrant */
9D00B460  02132021   ADDU A0, S0, S3
9D00B464  0F402C6B   JAL setPixel
9D00B468  02912823   SUBU A1, S4, S1
85:                        setPixel(xc+y, yc+x); /*  IV. Quadrant */
9D00B46C  02332021   ADDU A0, S1, S3
9D00B470  0F402C6B   JAL setPixel
9D00B474  02142821   ADDU A1, S0, S4
86:                        r = err;
87:                        if (r <= y) err += ++y*2+1;           /* e_xy+e_y < 0 */
9D00B478  0232182A   SLT V1, S1, S2
9D00B47C  14600005   BNE V1, ZERO, 0x9D00B494
9D00B480  02401021   ADDU V0, S2, ZERO
9D00B484  26310001   ADDIU S1, S1, 1
9D00B488  26430001   ADDIU V1, S2, 1
9D00B48C  00111040   SLL V0, S1, 1
9D00B490  00621021   ADDU V0, V1, V0
88:                        if (r > x || err > y) err += ++x*2+1; /* e_xy+e_x > 0 or no 2nd y-step */
9D00B494  0212902A   SLT S2, S0, S2
9D00B498  56400005   BNEL S2, ZERO, 0x9D00B4B0
9D00B49C  26100001   ADDIU S0, S0, 1
9D00B4A0  0222182A   SLT V1, S1, V0
9D00B4A4  10600005   BEQ V1, ZERO, 0x9D00B4BC
9D00B4A8  00409021   ADDU S2, V0, ZERO
9D00B4AC  26100001   ADDIU S0, S0, 1
9D00B4B0  00109040   SLL S2, S0, 1
9D00B4B4  26520001   ADDIU S2, S2, 1
9D00B4B8  02429021   ADDU S2, S2, V0
89:                     } while (x < 0);
9D00B4BC  0600FFE3   BLTZ S0, 0x9D00B44C
9D00B4C0  02702023   SUBU A0, S3, S0
90:                  }//circle()
9D00B4C4  8FBF0024   LW RA, 36(SP)
9D00B4C8  8FB40020   LW S4, 32(SP)
9D00B4CC  8FB3001C   LW S3, 28(SP)
9D00B4D0  8FB20018   LW S2, 24(SP)
9D00B4D4  8FB10014   LW S1, 20(SP)
9D00B4D8  8FB00010   LW S0, 16(SP)
9D00B4DC  03E00008   JR RA
9D00B4E0  27BD0028   ADDIU SP, SP, 40
91:                  
92:                  /* REF: http://members.chello.at/~easyfilter/bresenham.html
93:                   * dessine une ellipse circoncrite par un rectangle
94:                   */
95:                  void ellipse (int x0, int y0, int x1, int y1){
9D00B4E4  27BDFFC0   ADDIU SP, SP, -64
9D00B4E8  AFBF003C   SW RA, 60(SP)
9D00B4EC  AFBE0038   SW S8, 56(SP)
9D00B4F0  AFB70034   SW S7, 52(SP)
9D00B4F4  AFB60030   SW S6, 48(SP)
9D00B4F8  AFB5002C   SW S5, 44(SP)
9D00B4FC  AFB40028   SW S4, 40(SP)
9D00B500  AFB30024   SW S3, 36(SP)
9D00B504  AFB20020   SW S2, 32(SP)
9D00B508  AFB1001C   SW S1, 28(SP)
9D00B50C  AFB00018   SW S0, 24(SP)
9D00B510  00809821   ADDU S3, A0, ZERO
9D00B514  00C09021   ADDU S2, A2, ZERO
96:                     int a = abs(x1-x0), b = abs(y1-y0), b1 = b&1; /* values of diameter */
9D00B518  00C41023   SUBU V0, A2, A0
9D00B51C  00021FC3   SRA V1, V0, 31
9D00B520  00621026   XOR V0, V1, V0
9D00B524  00431023   SUBU V0, V0, V1
9D00B528  00E5B823   SUBU S7, A3, A1
9D00B52C  00171FC3   SRA V1, S7, 31
9D00B530  0077B826   XOR S7, V1, S7
9D00B534  02E3B823   SUBU S7, S7, V1
9D00B538  32F10001   ANDI S1, S7, 1
97:                     long dx = 4*(1-a)*b*b, dy = 4*(b1+1)*a*a; /* error increment */
9D00B53C  72F7F002   MUL S8, S7, S7
9D00B540  0002A823   SUBU S5, ZERO, V0
9D00B544  0015A880   SLL S5, S5, 2
9D00B548  26B50004   ADDIU S5, S5, 4
9D00B54C  73D5A802   MUL S5, S8, S5
9D00B550  70421802   MUL V1, V0, V0
9D00B554  0003B080   SLL S6, V1, 2
9D00B558  26240001   ADDIU A0, S1, 1
9D00B55C  72C4B002   MUL S6, S6, A0
98:                     long err = dx+dy+b1*a*a, e2; /* error of 1.step */
9D00B560  72232002   MUL A0, S1, V1
9D00B564  0095A021   ADDU S4, A0, S5
99:                  
100:                    if (x0 > x1) { x0 = x1; x1 += a; } /* if called with swapped points */
9D00B568  00D3202A   SLT A0, A2, S3
9D00B56C  10800003   BEQ A0, ZERO, 0x9D00B57C
9D00B570  0296A021   ADDU S4, S4, S6
9D00B574  00C09821   ADDU S3, A2, ZERO
9D00B578  00469021   ADDU S2, V0, A2
9D00B57C  00A7802A   SLT S0, A1, A3
9D00B580  00F0280A   MOVZ A1, A3, S0
101:                    if (y0 > y1) y0 = y1; /* .. exchange them */
102:                    y0 += (b+1)/2; y1 = y0-b1;   /* starting pixel */
9D00B584  26E20001   ADDIU V0, S7, 1
9D00B588  000287C2   SRL S0, V0, 31
9D00B58C  02028021   ADDU S0, S0, V0
9D00B590  00108043   SRA S0, S0, 1
9D00B594  02058021   ADDU S0, S0, A1
9D00B598  02118823   SUBU S1, S0, S1
103:                    a *= 8*a; b1 = 8*b*b;
9D00B59C  000318C0   SLL V1, V1, 3
9D00B5A0  AFA30010   SW V1, 16(SP)
9D00B5A4  001EF0C0   SLL S8, S8, 3
104:                 
105:                    do {
106:                        setPixel(x1, y0); /*   I. Quadrant */
9D00B5A8  02402021   ADDU A0, S2, ZERO
9D00B5AC  0F402C6B   JAL setPixel
9D00B5B0  02002821   ADDU A1, S0, ZERO
107:                        setPixel(x0, y0); /*  II. Quadrant */
9D00B5B4  02602021   ADDU A0, S3, ZERO
9D00B5B8  0F402C6B   JAL setPixel
9D00B5BC  02002821   ADDU A1, S0, ZERO
108:                        setPixel(x0, y1); /* III. Quadrant */
9D00B5C0  02602021   ADDU A0, S3, ZERO
9D00B5C4  0F402C6B   JAL setPixel
9D00B5C8  02202821   ADDU A1, S1, ZERO
109:                        setPixel(x1, y1); /*  IV. Quadrant */
9D00B5CC  02402021   ADDU A0, S2, ZERO
9D00B5D0  0F402C6B   JAL setPixel
9D00B5D4  02202821   ADDU A1, S1, ZERO
110:                        e2 = 2*err;
9D00B5D8  00141040   SLL V0, S4, 1
111:                        if (e2 <= dy) { y0++; y1--; err += dy += a; }  /* y step */
9D00B5DC  02C2182A   SLT V1, S6, V0
9D00B5E0  14600006   BNE V1, ZERO, 0x9D00B5FC
9D00B5E4  0055102A   SLT V0, V0, S5
9D00B5E8  26100001   ADDIU S0, S0, 1
9D00B5EC  2631FFFF   ADDIU S1, S1, -1
9D00B5F0  8FA30010   LW V1, 16(SP)
9D00B5F4  02C3B021   ADDU S6, S6, V1
9D00B5F8  0296A021   ADDU S4, S4, S6
112:                        if (e2 >= dx || 2*err > dy) { x0++; x1--; err += dx += b1; } /* x step */
9D00B5FC  50400006   BEQL V0, ZERO, 0x9D00B618
9D00B600  26730001   ADDIU S3, S3, 1
9D00B604  00141040   SLL V0, S4, 1
9D00B608  02C2102A   SLT V0, S6, V0
9D00B60C  10400006   BEQ V0, ZERO, 0x9D00B628
9D00B610  0253102A   SLT V0, S2, S3
9D00B614  26730001   ADDIU S3, S3, 1
9D00B618  2652FFFF   ADDIU S2, S2, -1
9D00B61C  02BEA821   ADDU S5, S5, S8
9D00B620  0295A021   ADDU S4, S4, S5
113:                    } while (x0 <= x1);
9D00B624  0253102A   SLT V0, S2, S3
9D00B628  1040FFE0   BEQ V0, ZERO, 0x9D00B5AC
9D00B62C  02402021   ADDU A0, S2, ZERO
114:                 
115:                    while (y0-y1 < b) {  /* too early stop of flat ellipses a=1 */
9D00B630  0211A023   SUBU S4, S0, S1
9D00B634  0297102A   SLT V0, S4, S7
9D00B638  10400016   BEQ V0, ZERO, 0x9D00B694
9D00B63C  2673FFFF   ADDIU S3, S3, -1
9D00B688  0297102A   SLT V0, S4, S7
9D00B68C  1440FFEE   BNE V0, ZERO, 0x9D00B648
9D00B690  02008821   ADDU S1, S0, ZERO
116:                        setPixel(x0-1, y0); /* -> finish tip of ellipse */
9D00B64C  02602021   ADDU A0, S3, ZERO
9D00B650  0F402C6B   JAL setPixel
9D00B654  02002821   ADDU A1, S0, ZERO
117:                        setPixel(x1+1, y0++);
9D00B640  0B402D93   J 0x9D00B64C
9D00B644  26520001   ADDIU S2, S2, 1
9D00B648  02A08021   ADDU S0, S5, ZERO
9D00B658  26150001   ADDIU S5, S0, 1
9D00B65C  02402021   ADDU A0, S2, ZERO
9D00B660  0F402C6B   JAL setPixel
9D00B664  02002821   ADDU A1, S0, ZERO
118:                        setPixel(x0-1, y1);
9D00B668  02602021   ADDU A0, S3, ZERO
9D00B66C  0F402C6B   JAL setPixel
9D00B670  02202821   ADDU A1, S1, ZERO
119:                        setPixel(x1+1, y1--);
9D00B674  2630FFFF   ADDIU S0, S1, -1
9D00B678  02402021   ADDU A0, S2, ZERO
9D00B67C  0F402C6B   JAL setPixel
9D00B680  02202821   ADDU A1, S1, ZERO
9D00B684  26940002   ADDIU S4, S4, 2
120:                    }
121:                 }//ellipse()
9D00B694  8FBF003C   LW RA, 60(SP)
9D00B698  8FBE0038   LW S8, 56(SP)
9D00B69C  8FB70034   LW S7, 52(SP)
9D00B6A0  8FB60030   LW S6, 48(SP)
9D00B6A4  8FB5002C   LW S5, 44(SP)
9D00B6A8  8FB40028   LW S4, 40(SP)
9D00B6AC  8FB30024   LW S3, 36(SP)
9D00B6B0  8FB20020   LW S2, 32(SP)
9D00B6B4  8FB1001C   LW S1, 28(SP)
9D00B6B8  8FB00018   LW S0, 24(SP)
9D00B6BC  03E00008   JR RA
9D00B6C0  27BD0040   ADDIU SP, SP, 64
122:                 
123:                 /*
124:                  * points[]={x1,y1,x2,y2,x3,y3,...}
125:                  * vertices est le nombre de points
126:                  */
127:                 void polygon(const int points[], int vertices){
9D00B6C4  27BDFFD8   ADDIU SP, SP, -40
9D00B6C8  AFBF0024   SW RA, 36(SP)
9D00B6CC  AFB30020   SW S3, 32(SP)
9D00B6D0  AFB2001C   SW S2, 28(SP)
9D00B6D4  AFB10018   SW S1, 24(SP)
9D00B6D8  AFB00014   SW S0, 20(SP)
9D00B6DC  00809821   ADDU S3, A0, ZERO
128:                     int i;
129:                     for(i=0;i<(2*vertices-2);i+=2){
9D00B6E0  24A5FFFF   ADDIU A1, A1, -1
9D00B6E4  00059040   SLL S2, A1, 1
9D00B6E8  1A40000B   BLEZ S2, 0x9D00B718
9D00B6EC  00008821   ADDU S1, ZERO, ZERO
9D00B6F0  00808021   ADDU S0, A0, ZERO
9D00B708  26310002   ADDIU S1, S1, 2
9D00B70C  0232102A   SLT V0, S1, S2
9D00B710  1440FFF8   BNE V0, ZERO, 0x9D00B6F4
9D00B714  26100008   ADDIU S0, S0, 8
130:                         line(points[i],points[i+1],points[i+2],points[i+3]);
9D00B6F4  8E040000   LW A0, 0(S0)
9D00B6F8  8E050004   LW A1, 4(S0)
9D00B6FC  8E060008   LW A2, 8(S0)
9D00B700  0F402CA6   JAL line
9D00B704  8E07000C   LW A3, 12(S0)
131:                     }
132:                     line(points[0],points[1],points[i],points[i+1]);
9D00B718  00111080   SLL V0, S1, 2
9D00B71C  02621021   ADDU V0, S3, V0
9D00B720  26310001   ADDIU S1, S1, 1
9D00B724  00118880   SLL S1, S1, 2
9D00B728  02718821   ADDU S1, S3, S1
9D00B72C  8E640000   LW A0, 0(S3)
9D00B730  8E650004   LW A1, 4(S3)
9D00B734  8C460000   LW A2, 0(V0)
9D00B738  0F402CA6   JAL line
9D00B73C  8E270000   LW A3, 0(S1)
133:                 }//polygon()
9D00B740  8FBF0024   LW RA, 36(SP)
9D00B744  8FB30020   LW S3, 32(SP)
9D00B748  8FB2001C   LW S2, 28(SP)
9D00B74C  8FB10018   LW S1, 24(SP)
9D00B750  8FB00014   LW S0, 20(SP)
9D00B754  03E00008   JR RA
9D00B758  27BD0028   ADDIU SP, SP, 40
134:                 
135:                 //  REF: http://members.chello.at/~easyfilter/bresenham.html
136:                 void bezier(int x0, int y0, int x1, int y1, int x2, int y2){
9D00B75C  27BDFFB0   ADDIU SP, SP, -80
9D00B760  AFBF004C   SW RA, 76(SP)
9D00B764  AFBE0048   SW S8, 72(SP)
9D00B768  AFB70044   SW S7, 68(SP)
9D00B76C  AFB60040   SW S6, 64(SP)
9D00B770  AFB5003C   SW S5, 60(SP)
9D00B774  AFB40038   SW S4, 56(SP)
9D00B778  AFB30034   SW S3, 52(SP)
9D00B77C  AFB20030   SW S2, 48(SP)
9D00B780  AFB1002C   SW S1, 44(SP)
9D00B784  AFB00028   SW S0, 40(SP)
9D00B788  00809021   ADDU S2, A0, ZERO
9D00B78C  00A0A021   ADDU S4, A1, ZERO
9D00B790  AFA60058   SW A2, 88(SP)
9D00B794  AFA7005C   SW A3, 92(SP)
9D00B798  8FB70060   LW S7, 96(SP)
137:                   int sx = x2-x1, sy = y2-y1;
9D00B79C  02E68023   SUBU S0, S7, A2
9D00B7A0  8FA20064   LW V0, 100(SP)
9D00B7A4  00479823   SUBU S3, V0, A3
138:                   long xx = x0-x1, yy = y0-y1, xy;         /* relative values for checks */
9D00B7A8  0086A823   SUBU S5, A0, A2
9D00B7AC  00A7B023   SUBU S6, A1, A3
139:                   double dx, dy, err, cur = xx*sy-yy*sx;                    /* curvature */
9D00B7B0  72752002   MUL A0, S3, S5
9D00B7B4  72161002   MUL V0, S0, S6
9D00B7B8  0F405C4A   JAL sitofp
9D00B7BC  00822023   SUBU A0, A0, V0
9D00B7C0  00408821   ADDU S1, V0, ZERO
140:                 
141:                   //if(xx*sx <= 0 && yy*sy <= 0) return;  /* sign of gradient must not change */
142:                 
143:                   if (sx*(long)sx+sy*(long)sy > xx*xx+yy*yy) { /* begin with longer part */
9D00B7C4  02100018   MULT 0, S0, S0
9D00B7C8  72730000   MADD 0, S3, S3
9D00B7CC  00001812   MFLO V1, 0
9D00B7D0  02B50018   MULT 0, S5, S5
9D00B7D4  72D60000   MADD 0, S6, S6
9D00B7D8  00001012   MFLO V0, 0
9D00B7DC  0043102A   SLT V0, V0, V1
9D00B7E0  1040000A   BEQ V0, ZERO, 0x9D00B80C
9D00B7E4  02202021   ADDU A0, S1, ZERO
144:                     x2 = x0; x0 = sx+x1; y2 = y0; y0 = sy+y1; cur = -cur;  /* swap P0 P2 */
9D00B7E8  3C028000   LUI V0, -32768
9D00B7EC  00518826   XOR S1, V0, S1
9D00B7F0  AFB40064   SW S4, 100(SP)
9D00B7F4  0240B821   ADDU S7, S2, ZERO
9D00B7F8  8FA2005C   LW V0, 92(SP)
9D00B7FC  0262A021   ADDU S4, S3, V0
9D00B800  8FA30058   LW V1, 88(SP)
9D00B804  02039021   ADDU S2, S0, V1
145:                   }
146:                   if (cur != 0) {                                    /* no straight line */
9D00B808  02202021   ADDU A0, S1, ZERO
9D00B80C  0F405A1D   JAL __lesf2
9D00B810  00002821   ADDU A1, ZERO, ZERO
9D00B814  1040009F   BEQ V0, ZERO, 0x9D00BA94
9D00B818  0215A821   ADDU S5, S0, S5
147:                     xx += sx; xx *= sx = x0 < x2 ? 1 : -1;           /* x step direction */
9D00B81C  0257202A   SLT A0, S2, S7
9D00B820  24020001   ADDIU V0, ZERO, 1
9D00B824  2403FFFF   ADDIU V1, ZERO, -1
9D00B828  0064100A   MOVZ V0, V1, A0
9D00B82C  AFA20018   SW V0, 24(SP)
9D00B830  7055A802   MUL S5, V0, S5
148:                     yy += sy; yy *= sy = y0 < y2 ? 1 : -1;           /* y step direction */
9D00B834  02769821   ADDU S3, S3, S6
9D00B838  8FA20064   LW V0, 100(SP)
9D00B83C  0282202A   SLT A0, S4, V0
9D00B840  24020001   ADDIU V0, ZERO, 1
9D00B844  0064100A   MOVZ V0, V1, A0
9D00B848  AFA2001C   SW V0, 28(SP)
9D00B84C  70539802   MUL S3, V0, S3
149:                     xy = 2*xx*yy; xx *= xx; yy *= yy;          /* differences 2nd degree */
9D00B850  0015F040   SLL S8, S5, 1
9D00B854  73D3F002   MUL S8, S8, S3
9D00B858  72B5A802   MUL S5, S5, S5
9D00B85C  72739802   MUL S3, S3, S3
150:                     if (cur*sx*sy < 0) {                           /* negated curvature? */
9D00B860  0F405C4A   JAL sitofp
9D00B864  8FA40018   LW A0, 24(SP)
9D00B868  AFA20020   SW V0, 32(SP)
9D00B86C  0F405C4A   JAL sitofp
9D00B870  8FA4001C   LW A0, 28(SP)
9D00B874  00408021   ADDU S0, V0, ZERO
9D00B878  8FA40020   LW A0, 32(SP)
9D00B87C  0F404C28   JAL __mulsf3
9D00B880  02202821   ADDU A1, S1, ZERO
9D00B884  00402021   ADDU A0, V0, ZERO
9D00B888  0F404C28   JAL __mulsf3
9D00B88C  02002821   ADDU A1, S0, ZERO
9D00B890  00402021   ADDU A0, V0, ZERO
9D00B894  0F405A1D   JAL __lesf2
9D00B898  00002821   ADDU A1, ZERO, ZERO
9D00B89C  04410005   BGEZ V0, 0x9D00B8B4
9D00B8A0  3C028000   LUI V0, -32768
151:                       xx = -xx; yy = -yy; xy = -xy; cur = -cur;
9D00B8A4  0015A823   SUBU S5, ZERO, S5
9D00B8A8  00139823   SUBU S3, ZERO, S3
9D00B8AC  001EF023   SUBU S8, ZERO, S8
9D00B8B0  00518826   XOR S1, V0, S1
152:                     }
153:                     dx = 4.0*sy*cur*(x1-x0)+xx-xy;             /* differences 1st degree */
9D00B8B4  0F405C4A   JAL sitofp
9D00B8B8  03C02021   ADDU A0, S8, ZERO
9D00B8BC  0040F021   ADDU S8, V0, ZERO
9D00B8C0  3C169D01   LUI S6, -25343
9D00B8C4  02002021   ADDU A0, S0, ZERO
9D00B8C8  0F404C28   JAL __mulsf3
9D00B8CC  8EC57E60   LW A1, 32352(S6)
9D00B8D0  00402021   ADDU A0, V0, ZERO
9D00B8D4  0F404C28   JAL __mulsf3
9D00B8D8  02202821   ADDU A1, S1, ZERO
9D00B8DC  00408021   ADDU S0, V0, ZERO
9D00B8E0  8FA20058   LW V0, 88(SP)
9D00B8E4  0F405C4A   JAL sitofp
9D00B8E8  00522023   SUBU A0, V0, S2
9D00B8EC  02002021   ADDU A0, S0, ZERO
9D00B8F0  0F404C28   JAL __mulsf3
9D00B8F4  00402821   ADDU A1, V0, ZERO
9D00B8F8  00408021   ADDU S0, V0, ZERO
9D00B8FC  0F405C4A   JAL sitofp
9D00B900  02A02021   ADDU A0, S5, ZERO
9D00B904  02002021   ADDU A0, S0, ZERO
9D00B908  0F404742   JAL fpadd
9D00B90C  00402821   ADDU A1, V0, ZERO
9D00B910  00402021   ADDU A0, V0, ZERO
9D00B914  0F404740   JAL __subsf3
9D00B918  03C02821   ADDU A1, S8, ZERO
9D00B91C  00408021   ADDU S0, V0, ZERO
154:                     dy = 4.0*sx*cur*(y0-y1)+yy-xy;
9D00B920  8FA40020   LW A0, 32(SP)
9D00B924  0F404C28   JAL __mulsf3
9D00B928  8EC57E60   LW A1, 32352(S6)
9D00B92C  00402021   ADDU A0, V0, ZERO
9D00B930  0F404C28   JAL __mulsf3
9D00B934  02202821   ADDU A1, S1, ZERO
9D00B938  00408821   ADDU S1, V0, ZERO
9D00B93C  8FA3005C   LW V1, 92(SP)
9D00B940  0F405C4A   JAL sitofp
9D00B944  02832023   SUBU A0, S4, V1
9D00B948  02202021   ADDU A0, S1, ZERO
9D00B94C  0F404C28   JAL __mulsf3
9D00B950  00402821   ADDU A1, V0, ZERO
9D00B954  00408821   ADDU S1, V0, ZERO
9D00B958  0F405C4A   JAL sitofp
9D00B95C  02602021   ADDU A0, S3, ZERO
9D00B960  02202021   ADDU A0, S1, ZERO
9D00B964  0F404742   JAL fpadd
9D00B968  00402821   ADDU A1, V0, ZERO
9D00B96C  00402021   ADDU A0, V0, ZERO
9D00B970  0F404740   JAL __subsf3
9D00B974  03C02821   ADDU A1, S8, ZERO
9D00B978  00408821   ADDU S1, V0, ZERO
155:                     xx += xx; yy += yy; err = dx+dy+xy;                /* error 1st step */
9D00B97C  0015A840   SLL S5, S5, 1
9D00B980  AFB50010   SW S5, 16(SP)
9D00B984  00139840   SLL S3, S3, 1
9D00B988  AFB30014   SW S3, 20(SP)
9D00B98C  02002021   ADDU A0, S0, ZERO
9D00B990  0F404742   JAL fpadd
9D00B994  00402821   ADDU A1, V0, ZERO
9D00B998  03C02021   ADDU A0, S8, ZERO
9D00B99C  0F404742   JAL fpadd
9D00B9A0  00402821   ADDU A1, V0, ZERO
9D00B9A4  00409821   ADDU S3, V0, ZERO
156:                     do {
157:                       setPixel(x0,y0);                                     /* setPixel curve */
9D00B9A8  02402021   ADDU A0, S2, ZERO
9D00B9AC  0F402C6B   JAL setPixel
9D00B9B0  02802821   ADDU A1, S4, ZERO
158:                       if (x0 == x2 && y0 == y2) return;  /* last pixel -> curve finished */
9D00B9B4  16570004   BNE S2, S7, 0x9D00B9C8
9D00B9B8  02602021   ADDU A0, S3, ZERO
9D00B9BC  8FA40064   LW A0, 100(SP)
9D00B9C0  12840039   BEQ S4, A0, 0x9D00BAA8
9D00B9C4  02602021   ADDU A0, S3, ZERO
159:                       y1 = 2*err < dx;                  /* save value for test of y step */
9D00B9C8  0F404742   JAL fpadd
9D00B9CC  02602821   ADDU A1, S3, ZERO
9D00B9D0  0040A821   ADDU S5, V0, ZERO
9D00B9D4  00402021   ADDU A0, V0, ZERO
9D00B9D8  0F405A1D   JAL __lesf2
9D00B9DC  02002821   ADDU A1, S0, ZERO
9D00B9E0  28420000   SLTI V0, V0, 0
9D00B9E4  24160001   ADDIU S6, ZERO, 1
9D00B9E8  0002B00A   MOVZ S6, ZERO, V0
160:                       if (2*err > dy) { x0 += sx; dx -= xy; err += dy += yy; } /* x step */
9D00B9EC  02202021   ADDU A0, S1, ZERO
9D00B9F0  0F405A1D   JAL __lesf2
9D00B9F4  02A02821   ADDU A1, S5, ZERO
9D00B9F8  04410010   BGEZ V0, 0x9D00BA3C
9D00B9FC  8FA20018   LW V0, 24(SP)
9D00BA00  02429021   ADDU S2, S2, V0
9D00BA04  02002021   ADDU A0, S0, ZERO
9D00BA08  0F404740   JAL __subsf3
9D00BA0C  03C02821   ADDU A1, S8, ZERO
9D00BA10  00408021   ADDU S0, V0, ZERO
9D00BA14  0F405C4A   JAL sitofp
9D00BA18  8FA40014   LW A0, 20(SP)
9D00BA1C  02202021   ADDU A0, S1, ZERO
9D00BA20  0F404742   JAL fpadd
9D00BA24  00402821   ADDU A1, V0, ZERO
9D00BA28  00408821   ADDU S1, V0, ZERO
9D00BA2C  02602021   ADDU A0, S3, ZERO
9D00BA30  0F404742   JAL fpadd
9D00BA34  00402821   ADDU A1, V0, ZERO
9D00BA38  00409821   ADDU S3, V0, ZERO
161:                       if (    y1    ) { y0 += sy; dy -= xy; err += dx += xx; } /* y step */
9D00BA3C  12C00011   BEQ S6, ZERO, 0x9D00BA84
9D00BA40  02202021   ADDU A0, S1, ZERO
9D00BA44  8FA3001C   LW V1, 28(SP)
9D00BA48  0283A021   ADDU S4, S4, V1
9D00BA4C  0F404740   JAL __subsf3
9D00BA50  03C02821   ADDU A1, S8, ZERO
9D00BA54  00408821   ADDU S1, V0, ZERO
9D00BA58  0F405C4A   JAL sitofp
9D00BA5C  8FA40010   LW A0, 16(SP)
9D00BA60  02002021   ADDU A0, S0, ZERO
9D00BA64  0F404742   JAL fpadd
9D00BA68  00402821   ADDU A1, V0, ZERO
9D00BA6C  00408021   ADDU S0, V0, ZERO
9D00BA70  02602021   ADDU A0, S3, ZERO
9D00BA74  0F404742   JAL fpadd
9D00BA78  00402821   ADDU A1, V0, ZERO
9D00BA7C  00409821   ADDU S3, V0, ZERO
162:                     } while (dy < dx );           /* gradient negates -> algorithm fails */
9D00BA80  02202021   ADDU A0, S1, ZERO
9D00BA84  0F405A1D   JAL __lesf2
9D00BA88  02002821   ADDU A1, S0, ZERO
9D00BA8C  0440FFC7   BLTZ V0, 0x9D00B9AC
9D00BA90  02402021   ADDU A0, S2, ZERO
163:                   }
164:                   line(x0,y0, x2,y2);                  /* setPixel remaining part to end */
9D00BA94  02402021   ADDU A0, S2, ZERO
9D00BA98  02802821   ADDU A1, S4, ZERO
9D00BA9C  02E03021   ADDU A2, S7, ZERO
9D00BAA0  0F402CA6   JAL line
9D00BAA4  8FA70064   LW A3, 100(SP)
165:                 }//besiez()
9D00BAA8  8FBF004C   LW RA, 76(SP)
9D00BAAC  8FBE0048   LW S8, 72(SP)
9D00BAB0  8FB70044   LW S7, 68(SP)
9D00BAB4  8FB60040   LW S6, 64(SP)
9D00BAB8  8FB5003C   LW S5, 60(SP)
9D00BABC  8FB40038   LW S4, 56(SP)
9D00BAC0  8FB30034   LW S3, 52(SP)
9D00BAC4  8FB20030   LW S2, 48(SP)
9D00BAC8  8FB1002C   LW S1, 44(SP)
9D00BACC  8FB00028   LW S0, 40(SP)
9D00BAD0  03E00008   JR RA
9D00BAD4  27BD0050   ADDIU SP, SP, 80
166:                 
167:                 
168:                 void fill(int x, int y){
169:                 }//fill()
9D00BAD8  03E00008   JR RA
9D00BADC  00000000   NOP
---  /home/jacques/MPLABXProjects/vpc-32/editor.c  ------------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   editor.h
20:                   * Author: Jacques Deschênes
21:                   *
22:                   * Created on 18 septembre 2013, 07:18
23:                   * Description: un éditeur simple pour le VPC-32
24:                   *
25:                   */
26:                  
27:                  #include <stdlib.h>
28:                  
29:                  #include "hardware/HardwareProfile.h"
30:                  #include "hardware/ps2_kbd/keyboard.h"
31:                  #include "console.h"
32:                  #include "shell.h"
33:                  #include "hardware/Pinguino/ff.h"
34:                  
35:                  #define BUFF_SIZE 8192 // dimension tampon editeur.
36:                  #define LOWER 0   // quel buffer utilisé
37:                  #define UPPER 1
38:                  
39:                  static const char *ED_TEMP="ed.tmp";
40:                  
41:                  
42:                  #define  MODIFIED 1
43:                  #define  NEW 2
44:                  #define  F_INSERT 4  // 1=insert, 0=overwrite
45:                  
46:                  
47:                  static unsigned char edFlags=0;  // indicateurs booléens.
48:                  static unsigned int fsize=0;    // grosseur du fichier.
49:                  static unsigned short sline=0; // position du curseur
50:                  static unsigned short scol=0;  // à l'écran.
51:                  static unsigned int bline=0;    // position du curseur
52:                  static unsigned int bcol=0;     // dans le texte.
53:                  static char *ipos=0;  // pointeur du point d'insertion dans le tampon.
54:                  static char *tpos=0;  // position de la fin du texte après la fente.
55:                  static char *ed_buff=NULL;  // pointeur début du tampon texte.
56:                  static char *ftemp=NULL;   // nom du fichier temporaire
57:                  static char *fname=NULL;   // nom du fichier
58:                  static FILINFO *fi=NULL;   // information fichier (File Control Block).
59:                  static FIL     *fn=NULL;  // handle fichier édité.
60:                  static FIL     *ft=NULL;  // handle fichier temporaire.
61:                  
62:                  
63:                  /*
64:                   * copie le fichier source dans le fichier temporaire.
65:                   * les fins de ligne CRLF sont converties en LF.
66:                   * les TAB sont convertis en espaces.
67:                   */
68:                  void read_file(unsigned int i){
9D00DF78  27BDFFC8   ADDIU SP, SP, -56
9D00DF7C  AFBF0034   SW RA, 52(SP)
9D00DF80  AFB50030   SW S5, 48(SP)
9D00DF84  AFB4002C   SW S4, 44(SP)
9D00DF88  AFB30028   SW S3, 40(SP)
9D00DF8C  AFB20024   SW S2, 36(SP)
9D00DF90  AFB10020   SW S1, 32(SP)
9D00DF94  AFB0001C   SW S0, 28(SP)
9D00DFF4  24A50001   ADDIU A1, A1, 1
9D00E060  24420001   ADDIU V0, V0, 1
69:                      FRESULT error=FR_OK;
70:                      unsigned int j,cnt, size=0,line,col;
9D00DFA0  0000A821   ADDU S5, ZERO, ZERO
9D00E168  0B40384A   J 0x9D00E128
9D00E16C  0000A821   ADDU S5, ZERO, ZERO
71:                      unsigned char prev, c;
72:                      for(;i && !error;i--){
9D00DF98  1080006D   BEQ A0, ZERO, 0x9D00E150
9D00DF9C  0080A021   ADDU S4, A0, ZERO
9D00E0D0  2694FFFF   ADDIU S4, S4, -1
9D00E0D4  12800003   BEQ S4, ZERO, 0x9D00E0E4
9D00E0D8  02A3A821   ADDU S5, S5, V1
9D00E0DC  1040FFB6   BEQ V0, ZERO, 0x9D00DFB8
9D00E0E0  8F848068   LW A0, -32664(GP)
73:                          error=f_read(fn,ed_buff,512,&cnt);
9D00DFB4  8F848068   LW A0, -32664(GP)
9D00DFB8  8F858070   LW A1, -32656(GP)
9D00DFBC  24060200   ADDIU A2, ZERO, 512
9D00DFC0  0F400708   JAL f_read
9D00DFC4  27A70010   ADDIU A3, SP, 16
74:                          j=0;
9D00DFE0  00003021   ADDU A2, ZERO, ZERO
75:                          c=0;
9D00DFD8  00005021   ADDU T2, ZERO, ZERO
76:                          line=0;
77:                          col=0;
9D00DFDC  00001821   ADDU V1, ZERO, ZERO
78:                          tpos=ed_buff+516;
9D00DFC8  8F858070   LW A1, -32656(GP)
9D00DFCC  24A20204   ADDIU V0, A1, 516
9D00DFD0  AF82808C   SW V0, -32628(GP)
9D00DFD4  8F828090   LW V0, -32624(GP)
79:                          while (cnt){
9D00DFE8  0B40382A   J 0x9D00E0A8
9D00DFEC  24080020   ADDIU T0, ZERO, 32
9D00E0A8  8FA40010   LW A0, 16(SP)
9D00E0AC  5480FFD0   BNEL A0, ZERO, 0x9D00DFF0
9D00E0B0  80A90000   LB T1, 0(A1)
9D00E0B4  AF858070   SW A1, -32656(GP)
9D00E0B8  AF828090   SW V0, -32624(GP)
80:                              prev=c;
81:                              c= *ed_buff++;
9D00DFF0  312700FF   ANDI A3, T1, 255
82:                              cnt--;
9D00DFF8  2484FFFF   ADDIU A0, A0, -1
83:                              switch (c){
9D00DFA4  2410000A   ADDIU S0, ZERO, 10
9D00DFB0  24120009   ADDIU S2, ZERO, 9
9D00DFFC  10F0000B   BEQ A3, S0, 0x9D00E02C
9D00E000  AFA40010   SW A0, 16(SP)
9D00E004  50F10005   BEQL A3, S1, 0x9D00E01C
9D00E008  A0530000   SB S3, 0(V0)
9D00E00C  14F2001B   BNE A3, S2, 0x9D00E07C
9D00E010  24E4FFE0   ADDIU A0, A3, -32
84:                                  case CR:
85:                                      *ipos++=LF;
9D00E01C  24420001   ADDIU V0, V0, 1
86:                                      col=0;
87:                                      line++;
88:                                      j++;
9D00E020  24C60001   ADDIU A2, A2, 1
89:                                      break;
9D00E024  0B403829   J 0x9D00E0A4
9D00E028  00001821   ADDU V1, ZERO, ZERO
90:                                  case LF:
91:                                      if (prev!=CR){
9D00DFA8  2411000D   ADDIU S1, ZERO, 13
9D00E02C  1151001E   BEQ T2, S1, 0x9D00E0A8
9D00E030  00E05021   ADDU T2, A3, ZERO
92:                                          *ipos++=LF;
9D00DFAC  2413000A   ADDIU S3, ZERO, 10
9D00E034  A0530000   SB S3, 0(V0)
9D00E038  24420001   ADDIU V0, V0, 1
93:                                          col=0;
9D00E040  0B40382A   J 0x9D00E0A8
9D00E044  00001821   ADDU V1, ZERO, ZERO
9D00E074  0B40382A   J 0x9D00E0A8
9D00E078  00E05021   ADDU T2, A3, ZERO
9D00E0A4  00E05021   ADDU T2, A3, ZERO
94:                                          line++;
95:                                          j++;
9D00E03C  24C60001   ADDIU A2, A2, 1
96:                                      }
97:                                      break;
98:                                  case TAB:
99:                                      *ipos++=SPACE;
9D00E014  0B403812   J 0x9D00E048
9D00E018  A0480000   SB T0, 0(V0)
9D00E048  24420001   ADDIU V0, V0, 1
100:                                     col++;
9D00E04C  24630001   ADDIU V1, V1, 1
101:                                     j++;
102:                                     while(col % TAB_WIDTH){
9D00E050  30640003   ANDI A0, V1, 3
9D00E054  10800013   BEQ A0, ZERO, 0x9D00E0A4
9D00E058  24C60001   ADDIU A2, A2, 1
9D00E068  30640003   ANDI A0, V1, 3
9D00E06C  1480FFFB   BNE A0, ZERO, 0x9D00E05C
9D00E070  24C60001   ADDIU A2, A2, 1
103:                                         *ipos++=SPACE;
9D00E05C  A0480000   SB T0, 0(V0)
104:                                         col++;
9D00E064  24630001   ADDIU V1, V1, 1
105:                                         j++;
106:                                     }
107:                                     break;
108:                                 default:
109:                                     if (c<32 || c>127){
9D00E07C  308400FF   ANDI A0, A0, 255
9D00E080  2C840060   SLTIU A0, A0, 96
9D00E084  54800004   BNEL A0, ZERO, 0x9D00E098
9D00E088  A0490000   SB T1, 0(V0)
110:                                         *ipos++=127;
9D00DFE4  240B007F   ADDIU T3, ZERO, 127
9D00E08C  A04B0000   SB T3, 0(V0)
9D00E090  0B403827   J 0x9D00E09C
9D00E094  24420001   ADDIU V0, V0, 1
111:                                     }else{
112:                                         *ipos++=c;
9D00E098  24420001   ADDIU V0, V0, 1
113:                                     }
114:                                     col++;
9D00E09C  24630001   ADDIU V1, V1, 1
115:                                     j++;
9D00E0A0  24C60001   ADDIU A2, A2, 1
116:                             }
117:                         }//while(j)
118:                         error=f_write(ft,ed_buff+516,j,&cnt);
9D00E0BC  8F84806C   LW A0, -32660(GP)
9D00E0C0  24A50204   ADDIU A1, A1, 516
9D00E0C4  0F4007B3   JAL f_write
9D00E0C8  27A70010   ADDIU A3, SP, 16
119:                         size+=cnt;
9D00E0CC  8FA30010   LW V1, 16(SP)
120:                     }
121:                     error=f_close(fn);
9D00E0E4  0F4008CD   JAL f_close
9D00E0E8  8F848068   LW A0, -32664(GP)
9D00E150  0F4008CD   JAL f_close
9D00E154  8F848068   LW A0, -32664(GP)
122:                     fsize=size;
9D00E0EC  AF958094   SW S5, -32620(GP)
9D00E158  AF808094   SW ZERO, -32620(GP)
123:                     error=f_lseek(ft,0);
9D00E0F0  8F84806C   LW A0, -32660(GP)
9D00E0F4  0F4009AF   JAL f_lseek
9D00E0F8  00002821   ADDU A1, ZERO, ZERO
9D00E15C  8F84806C   LW A0, -32660(GP)
9D00E160  0F4009AF   JAL f_lseek
9D00E164  00002821   ADDU A1, ZERO, ZERO
124:                     if (size>BUFF_SIZE/3){
9D00E0FC  2EA20AAB   SLTIU V0, S5, 2731
9D00E100  1440000A   BNE V0, ZERO, 0x9D00E12C
9D00E104  24022000   ADDIU V0, ZERO, 8192
125:                         error=f_read(ft,ed_buff+BUFF_SIZE*2/3,BUFF_SIZE/3,&cnt);
9D00E108  8F84806C   LW A0, -32660(GP)
9D00E10C  8F858070   LW A1, -32656(GP)
9D00E110  24A51555   ADDIU A1, A1, 5461
9D00E114  24060AAA   ADDIU A2, ZERO, 2730
9D00E118  0F400708   JAL f_read
9D00E11C  27A70010   ADDIU A3, SP, 16
126:                     }else{
127:                         error=f_read(ft,ed_buff+BUFF_SIZE-size,size,&cnt);
9D00E128  24022000   ADDIU V0, ZERO, 8192
9D00E12C  00551023   SUBU V0, V0, S5
9D00E130  8F84806C   LW A0, -32660(GP)
9D00E134  8F858070   LW A1, -32656(GP)
9D00E138  00A22821   ADDU A1, A1, V0
9D00E13C  02A03021   ADDU A2, S5, ZERO
9D00E140  0F400708   JAL f_read
9D00E144  27A70010   ADDIU A3, SP, 16
128:                     }
129:                 
130:                 }//read_file()
9D00E120  0B40385C   J 0x9D00E170
9D00E124  8FBF0034   LW RA, 52(SP)
9D00E148  0B40385C   J 0x9D00E170
9D00E14C  8FBF0034   LW RA, 52(SP)
9D00E170  8FB50030   LW S5, 48(SP)
9D00E174  8FB4002C   LW S4, 44(SP)
9D00E178  8FB30028   LW S3, 40(SP)
9D00E17C  8FB20024   LW S2, 36(SP)
9D00E180  8FB10020   LW S1, 32(SP)
9D00E184  8FB0001C   LW S0, 28(SP)
9D00E188  03E00008   JR RA
9D00E18C  27BD0038   ADDIU SP, SP, 56
131:                 
132:                 void update_window(){
133:                     text_coord_t curpos;
134:                     
135:                 }//update_window()
9D00E190  03E00008   JR RA
9D00E194  00000000   NOP
136:                 
137:                 void close_file(){
138:                 }//close_file()
9D00E198  03E00008   JR RA
9D00E19C  00000000   NOP
139:                 
140:                 void edit_file(){
9D00E1A0  27BDFFE8   ADDIU SP, SP, -24
9D00E1A4  AFBF0014   SW RA, 20(SP)
141:                     FRESULT error;
142:                     unsigned int i;
143:                     unsigned short c;
144:                     if (error==FR_OK){
145:                         bline=0;
9D00E1A8  AF808080   SW ZERO, -32640(GP)
146:                         bcol=0;
9D00E1AC  AF808084   SW ZERO, -32636(GP)
147:                         sline=0;
9D00E1B0  A7808088   SH ZERO, -32632(GP)
148:                         scol=0;
9D00E1B4  A780808A   SH ZERO, -32630(GP)
149:                         edFlags |= F_INSERT;
9D00E1B8  93828078   LBU V0, -32648(GP)
9D00E1BC  34420004   ORI V0, V0, 4
9D00E1C0  A3828078   SB V0, -32648(GP)
150:                         set_cursor(CR_UNDER);
9D00E1C4  0F40239E   JAL set_cursor
9D00E1C8  00002021   ADDU A0, ZERO, ZERO
151:                         clear_screen();
9D00E1CC  0F402290   JAL clear_screen
9D00E1D0  00000000   NOP
152:                         update_window();
153:                         while (1){
154:                             c=wait_key(comm_channel);
9D00E1D4  0F4023C6   JAL wait_key
9D00E1D8  8384804C   LB A0, -32692(GP)
9D00E1DC  0B403875   J 0x9D00E1D4
9D00E1E0  00000000   NOP
155:                             switch(c){
156:                             }//switch
157:                         }//while
158:                     }else{
159:                         error=f_close(fn);
160:                         error=f_close(ft);
161:                         error=f_unlink(ftemp);
162:                     }
163:                 }//edit_file()
164:                 
165:                 FRESULT open_for_edit(char *file_name){
9D00E1E4  27BDFFE0   ADDIU SP, SP, -32
9D00E1E8  AFBF001C   SW RA, 28(SP)
9D00E1EC  AFB10018   SW S1, 24(SP)
9D00E1F0  AFB00014   SW S0, 20(SP)
9D00E1F4  00808821   ADDU S1, A0, ZERO
166:                     FRESULT error=FR_OK;
167:                     // fichier de travail temporaire
168:                     ftemp=(char *)ED_TEMP;
9D00E1F8  3C049D01   LUI A0, -25343
9D00E1FC  24847444   ADDIU A0, A0, 29764
169:                     error=f_unlink(ftemp); // supprime s'il existe déjà.
9D00E200  0F400BF0   JAL f_unlink
9D00E204  AF848074   SW A0, -32652(GP)
170:                     error=f_open(ft,ftemp,FA_CREATE_NEW|FA_WRITE);
9D00E208  8F84806C   LW A0, -32660(GP)
9D00E20C  8F858074   LW A1, -32652(GP)
9D00E210  0F400669   JAL f_open
9D00E214  24060006   ADDIU A2, ZERO, 6
9D00E218  00408021   ADDU S0, V0, ZERO
171:                     edFlags=0;
172:                     if (!error && file_name){
9D00E21C  14400019   BNE V0, ZERO, 0x9D00E284
9D00E220  A3808078   SB ZERO, -32648(GP)
9D00E224  12200017   BEQ S1, ZERO, 0x9D00E284
9D00E228  02202021   ADDU A0, S1, ZERO
173:                         fname=file_name;
9D00E22C  AF91807C   SW S1, -32644(GP)
174:                         error=f_stat(fname,fi);
9D00E230  0F400B11   JAL f_stat
9D00E234  8F858064   LW A1, -32668(GP)
175:                         if (error==FR_OK){
9D00E238  1440000B   BNE V0, ZERO, 0x9D00E268
9D00E23C  00408021   ADDU S0, V0, ZERO
176:                             error=f_open(fn,fname,FA_READ);
9D00E240  8F848068   LW A0, -32664(GP)
9D00E244  8F85807C   LW A1, -32644(GP)
9D00E248  0F400669   JAL f_open
9D00E24C  24060001   ADDIU A2, ZERO, 1
9D00E250  00408021   ADDU S0, V0, ZERO
177:                             read_file(fn->fsize);
9D00E254  8F828068   LW V0, -32664(GP)
9D00E258  0F4037DE   JAL read_file
9D00E25C  8C44000C   LW A0, 12(V0)
178:                         }else if (error==FR_NO_FILE){
9D00E268  24020004   ADDIU V0, ZERO, 4
9D00E26C  16020006   BNE S0, V0, 0x9D00E288
9D00E270  02001021   ADDU V0, S0, ZERO
179:                             fn=NULL;
9D00E274  AF808068   SW ZERO, -32664(GP)
180:                             edFlags |= NEW;
9D00E278  93828078   LBU V0, -32648(GP)
9D00E27C  34420002   ORI V0, V0, 2
9D00E280  A3828078   SB V0, -32648(GP)
181:                         }
182:                     }
183:                     return error;
184:                 }//open_for_edit()
9D00E260  0B4038A2   J 0x9D00E288
9D00E264  02001021   ADDU V0, S0, ZERO
9D00E284  02001021   ADDU V0, S0, ZERO
9D00E288  8FBF001C   LW RA, 28(SP)
9D00E28C  8FB10018   LW S1, 24(SP)
9D00E290  8FB00014   LW S0, 20(SP)
9D00E294  03E00008   JR RA
9D00E298  27BD0020   ADDIU SP, SP, 32
185:                 
186:                 void ed(char *file_name){
9D00E29C  27BDFFD8   ADDIU SP, SP, -40
9D00E2A0  AFBF0024   SW RA, 36(SP)
9D00E2A4  AFB30020   SW S3, 32(SP)
9D00E2A8  AFB2001C   SW S2, 28(SP)
9D00E2AC  AFB10018   SW S1, 24(SP)
9D00E2B0  AFB00014   SW S0, 20(SP)
9D00E2B4  00808021   ADDU S0, A0, ZERO
187:                     FRESULT error;
188:                     if (comm_channel!=LOCAL_CON){
9D00E2B8  9384804C   LBU A0, -32692(GP)
9D00E2BC  10800006   BEQ A0, ZERO, 0x9D00E2D8
9D00E2C0  7C042420   SEB A0, A0
189:                         print(comm_channel, "This editor only works on local console.\r");
9D00E2C4  3C059D01   LUI A1, -25343
9D00E2C8  0F40229C   JAL print
9D00E2CC  24A5744C   ADDIU A1, A1, 29772
9D00E2D0  0B4038E0   J 0x9D00E380
9D00E2D4  00000000   NOP
190:                     }else{
191:                         fi=malloc(sizeof(FILINFO));
9D00E2D8  0F4047DE   JAL malloc
9D00E2DC  24040018   ADDIU A0, ZERO, 24
9D00E2E0  00408821   ADDU S1, V0, ZERO
9D00E2E4  AF828064   SW V0, -32668(GP)
192:                         fn=malloc(sizeof(FIL));
9D00E2E8  0F4047DE   JAL malloc
9D00E2EC  24040028   ADDIU A0, ZERO, 40
9D00E2F0  00409021   ADDU S2, V0, ZERO
9D00E2F4  AF828068   SW V0, -32664(GP)
193:                         ft=malloc(sizeof(FIL));
9D00E2F8  0F4047DE   JAL malloc
9D00E2FC  24040028   ADDIU A0, ZERO, 40
9D00E300  00409821   ADDU S3, V0, ZERO
9D00E304  AF82806C   SW V0, -32660(GP)
194:                         ed_buff=calloc(BUFF_SIZE,sizeof(char));
9D00E308  24042000   ADDIU A0, ZERO, 8192
9D00E30C  0F405CA9   JAL calloc
9D00E310  24050001   ADDIU A1, ZERO, 1
195:                         if (fi && fn && ft && ed_buff){
9D00E314  12200015   BEQ S1, ZERO, 0x9D00E36C
9D00E318  AF828070   SW V0, -32656(GP)
9D00E31C  12400014   BEQ S2, ZERO, 0x9D00E370
9D00E320  24040002   ADDIU A0, ZERO, 2
9D00E324  12600013   BEQ S3, ZERO, 0x9D00E374
9D00E328  3C059D01   LUI A1, -25343
9D00E32C  10400012   BEQ V0, ZERO, 0x9D00E378
9D00E330  24A5747C   ADDIU A1, A1, 29820
196:                             if ((error=open_for_edit(file_name))==FR_OK){
9D00E334  0F403879   JAL open_for_edit
9D00E338  02002021   ADDU A0, S0, ZERO
9D00E33C  14400005   BNE V0, ZERO, 0x9D00E354
9D00E340  24040009   ADDIU A0, ZERO, 9
197:                                 edit_file();
9D00E344  0F403868   JAL edit_file
9D00E348  00000000   NOP
9D00E34C  0B4038E0   J 0x9D00E380
9D00E350  00000000   NOP
198:                             }else{
199:                                 print_error_msg(ERR_FIO,"",error);
9D00E354  3C059D01   LUI A1, -25343
9D00E358  24A57478   ADDIU A1, A1, 29816
9D00E35C  0F40196D   JAL print_error_msg
9D00E360  00403021   ADDU A2, V0, ZERO
9D00E364  0B4038E0   J 0x9D00E380
9D00E368  00000000   NOP
200:                             }
201:                         }else{
202:                             print_error_msg(ERR_ALLOC,"Not enough memory.\r",0);
9D00E36C  24040002   ADDIU A0, ZERO, 2
9D00E370  3C059D01   LUI A1, -25343
9D00E374  24A5747C   ADDIU A1, A1, 29820
9D00E378  0F40196D   JAL print_error_msg
9D00E37C  00003021   ADDU A2, ZERO, ZERO
203:                         }
204:                     }//else
205:                     free(fi);
9D00E380  0F405E55   JAL free
9D00E384  8F848064   LW A0, -32668(GP)
206:                     free(fn);
9D00E388  0F405E55   JAL free
9D00E38C  8F848068   LW A0, -32664(GP)
207:                     free(ft);
9D00E390  0F405E55   JAL free
9D00E394  8F84806C   LW A0, -32660(GP)
208:                     free(ed_buff);
9D00E398  0F405E55   JAL free
9D00E39C  8F848070   LW A0, -32656(GP)
209:                 } // ed()
9D00E3A0  8FBF0024   LW RA, 36(SP)
9D00E3A4  8FB30020   LW S3, 32(SP)
9D00E3A8  8FB2001C   LW S2, 28(SP)
9D00E3AC  8FB10018   LW S1, 24(SP)
9D00E3B0  8FB00014   LW S0, 20(SP)
9D00E3B4  03E00008   JR RA
9D00E3B8  27BD0028   ADDIU SP, SP, 40
210:                 
211:                 
---  /home/jacques/MPLABXProjects/vpc-32/console.c  -----------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   *  Name: console.c
21:                   *  Description: text console for NTSC video output
22:                   *  Author: Jacques Deschênes
23:                   *  Date Created: 2013-09-06
24:                   */
25:                  
26:                  #include "console.h"
27:                  #include "hardware/HardwareProfile.h"
28:                  #include "hardware/serial_comm/serial_comm.h"
29:                  #include "hardware/ps2_kbd/keyboard.h"
30:                  
31:                  
32:                  // indicateurs booléens
33:                  #define CUR_SHOW 1  // curseur actif
34:                  #define CUR_VIS  2  // curseur visible
35:                  #define INV_VID  4  // inverse vidéo
36:                  
37:                  
38:                  static unsigned short cx=0, cy=0;  // coordonnée courante du curseur texte en pixels.
39:                  static unsigned char tab_width=TAB_WIDTH;
40:                  static cursor_t cur_shape=CR_UNDER;
41:                  static unsigned short flags=0;
42:                  
43:                  unsigned char comm_channel=LOCAL_CON;
44:                  
45:                  
46:                  void scroll_up(void){
9D008630  27BDFFE8   ADDIU SP, SP, -24
9D008634  AFBF0014   SW RA, 20(SP)
9D008638  AFB00010   SW S0, 16(SP)
47:                      char *src, *dst;
48:                      dst = (char*)video_bmp;
49:                      src = (char*)video_bmp +(CHAR_HEIGHT)*HRES/8;
9D00863C  3C10A000   LUI S0, -24576
9D008640  26100138   ADDIU S0, S0, 312
50:                      memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*HRES/8);
9D008644  02002021   ADDU A0, S0, ZERO
9D008648  26050140   ADDIU A1, S0, 320
9D00864C  0F405C31   JAL memmove
9D008650  24061F40   ADDIU A2, ZERO, 8000
51:                      dst= (char*)video_bmp+(CHAR_HEIGHT*(LINE_PER_SCREEN-1))*HRES/8;
52:                      memset(dst,0,HRES/8*CHAR_HEIGHT);
9D008654  26041F40   ADDIU A0, S0, 8000
9D008658  00002821   ADDU A1, ZERO, ZERO
9D00865C  0F4059A4   JAL 0x9D016690
9D008660  24060140   ADDIU A2, ZERO, 320
53:                  }//scroll_up();
9D008664  8FBF0014   LW RA, 20(SP)
9D008668  8FB00010   LW S0, 16(SP)
9D00866C  03E00008   JR RA
9D008670  27BD0018   ADDIU SP, SP, 24
54:                  
55:                  void scroll_down(void){
9D008674  27BDFFE8   ADDIU SP, SP, -24
9D008678  AFBF0014   SW RA, 20(SP)
9D00867C  AFB00010   SW S0, 16(SP)
56:                      char *src, *dst;
57:                      src = (char*)video_bmp;
58:                      dst = (char*)video_bmp+(CHAR_HEIGHT)*HRES/8;
9D008680  3C10A000   LUI S0, -24576
9D008684  26100138   ADDIU S0, S0, 312
59:                      memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*HRES/8);
9D008688  26040140   ADDIU A0, S0, 320
9D00868C  02002821   ADDU A1, S0, ZERO
9D008690  0F405C31   JAL memmove
9D008694  24061F40   ADDIU A2, ZERO, 8000
60:                      dst=(char*)video_bmp;
61:                      memset(dst,0,HRES/8*CHAR_HEIGHT);
9D008698  02002021   ADDU A0, S0, ZERO
9D00869C  00002821   ADDU A1, ZERO, ZERO
9D0086A0  0F4059A4   JAL 0x9D016690
9D0086A4  24060140   ADDIU A2, ZERO, 320
62:                  }//scroll_down()
9D0086A8  8FBF0014   LW RA, 20(SP)
9D0086AC  8FB00010   LW S0, 16(SP)
9D0086B0  03E00008   JR RA
9D0086B4  27BD0018   ADDIU SP, SP, 24
63:                  
64:                  
65:                  void cursor_right(void){
9D0086B8  27BDFFE8   ADDIU SP, SP, -24
9D0086BC  AFBF0014   SW RA, 20(SP)
66:                      cx += CHAR_WIDTH;
9D0086C0  97828054   LHU V0, -32684(GP)
9D0086C4  24420006   ADDIU V0, V0, 6
9D0086C8  3042FFFF   ANDI V0, V0, -1
9D0086CC  A7828054   SH V0, -32684(GP)
67:                      if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
9D0086D0  2C42013E   SLTIU V0, V0, 318
9D0086D4  1440000F   BNE V0, ZERO, 0x9D008714
9D0086D8  8FBF0014   LW RA, 20(SP)
68:                          cx = 0;
9D0086DC  A7808054   SH ZERO, -32684(GP)
69:                          cy += CHAR_HEIGHT;
9D0086E0  97828056   LHU V0, -32682(GP)
9D0086E4  24420008   ADDIU V0, V0, 8
9D0086E8  3042FFFF   ANDI V0, V0, -1
9D0086EC  A7828056   SH V0, -32682(GP)
70:                          if (cy>=((LINE_PER_SCREEN-1)*CHAR_HEIGHT)){
9D0086F0  2C4200C8   SLTIU V0, V0, 200
9D0086F4  14400007   BNE V0, ZERO, 0x9D008714
9D0086F8  8FBF0014   LW RA, 20(SP)
71:                              scroll_up();
9D0086FC  0F40218C   JAL scroll_up
9D008700  00000000   NOP
72:                              cy -= CHAR_HEIGHT;
9D008704  97828056   LHU V0, -32682(GP)
9D008708  2442FFF8   ADDIU V0, V0, -8
9D00870C  A7828056   SH V0, -32682(GP)
73:                          }
74:                      }
75:                  } // cursor_right()
9D008710  8FBF0014   LW RA, 20(SP)
9D008714  03E00008   JR RA
9D008718  27BD0018   ADDIU SP, SP, 24
76:                  
77:                  void cursor_left(void){
9D00871C  27BDFFE8   ADDIU SP, SP, -24
9D008720  AFBF0014   SW RA, 20(SP)
78:                      if (cx>=(CHAR_WIDTH)){
9D008724  97828054   LHU V0, -32684(GP)
9D008728  2C430006   SLTIU V1, V0, 6
9D00872C  54600004   BNEL V1, ZERO, 0x9D008740
9D008730  24020034   ADDIU V0, ZERO, 52
79:                          cx -= CHAR_WIDTH;
9D008734  2442FFFA   ADDIU V0, V0, -6
9D008738  0B4021D9   J 0x9D008764
9D00873C  A7828054   SH V0, -32684(GP)
80:                      }else{
81:                          cx = (CHAR_PER_LINE-1);
9D008740  A7828054   SH V0, -32684(GP)
82:                          if (cy>=CHAR_HEIGHT){
9D008744  97828056   LHU V0, -32682(GP)
9D008748  2C430008   SLTIU V1, V0, 8
9D00874C  14600003   BNE V1, ZERO, 0x9D00875C
9D008750  2442FFF8   ADDIU V0, V0, -8
83:                              cy -= CHAR_HEIGHT;
9D008754  0B4021D9   J 0x9D008764
9D008758  A7828056   SH V0, -32682(GP)
84:                          }else{
85:                              scroll_down();
9D00875C  0F40219D   JAL scroll_down
9D008760  00000000   NOP
86:                          }
87:                      }
88:                  }// cursor_left()
9D008764  8FBF0014   LW RA, 20(SP)
9D008768  03E00008   JR RA
9D00876C  27BD0018   ADDIU SP, SP, 24
89:                  
90:                  void cursor_up(void){
9D008770  27BDFFE8   ADDIU SP, SP, -24
9D008774  AFBF0014   SW RA, 20(SP)
91:                      if (cy>=CHAR_HEIGHT){
9D008778  97828056   LHU V0, -32682(GP)
9D00877C  2C430008   SLTIU V1, V0, 8
9D008780  14600003   BNE V1, ZERO, 0x9D008790
9D008784  2442FFF8   ADDIU V0, V0, -8
92:                          cy -= CHAR_HEIGHT;
9D008788  0B4021E6   J 0x9D008798
9D00878C  A7828056   SH V0, -32682(GP)
93:                      }else{
94:                          scroll_down();
9D008790  0F40219D   JAL scroll_down
9D008794  00000000   NOP
95:                      }
96:                  }// cursor_up()
9D008798  8FBF0014   LW RA, 20(SP)
9D00879C  03E00008   JR RA
9D0087A0  27BD0018   ADDIU SP, SP, 24
97:                  
98:                  void cursor_down(void){
9D0087A4  27BDFFE8   ADDIU SP, SP, -24
9D0087A8  AFBF0014   SW RA, 20(SP)
99:                      if (cy<=((CHAR_HEIGHT*(LINE_PER_SCREEN-2)))){
9D0087AC  97828056   LHU V0, -32682(GP)
9D0087B0  2C4300C1   SLTIU V1, V0, 193
9D0087B4  10600003   BEQ V1, ZERO, 0x9D0087C4
9D0087B8  24420008   ADDIU V0, V0, 8
100:                         cy += CHAR_HEIGHT;
9D0087BC  0B4021F3   J 0x9D0087CC
9D0087C0  A7828056   SH V0, -32682(GP)
101:                     }else{
102:                         scroll_up();
9D0087C4  0F40218C   JAL scroll_up
9D0087C8  00000000   NOP
103:                     }
104:                 }//cursor_down()
9D0087CC  8FBF0014   LW RA, 20(SP)
9D0087D0  03E00008   JR RA
9D0087D4  27BD0018   ADDIU SP, SP, 24
105:                 
106:                 void crlf(void){
9D0087D8  27BDFFE8   ADDIU SP, SP, -24
9D0087DC  AFBF0014   SW RA, 20(SP)
107:                     cx=0;
9D0087E0  A7808054   SH ZERO, -32684(GP)
108:                     if (cy==((LINE_PER_SCREEN-1)*CHAR_HEIGHT)){
9D0087E4  97828056   LHU V0, -32682(GP)
9D0087E8  240300C8   ADDIU V1, ZERO, 200
9D0087EC  14430005   BNE V0, V1, 0x9D008804
9D0087F0  24420008   ADDIU V0, V0, 8
109:                         scroll_up();
9D0087F4  0F40218C   JAL scroll_up
9D0087F8  00000000   NOP
110:                     }else{
111:                         cy += CHAR_HEIGHT;
9D008804  A7828056   SH V0, -32682(GP)
112:                     }
113:                 }//crlf()
9D0087FC  0B402203   J 0x9D00880C
9D008800  8FBF0014   LW RA, 20(SP)
9D008808  8FBF0014   LW RA, 20(SP)
9D00880C  03E00008   JR RA
9D008810  27BD0018   ADDIU SP, SP, 24
114:                 
115:                 void put_char(dev_t channel, char c){
9D008814  27BDFFE8   ADDIU SP, SP, -24
9D008818  AFBF0014   SW RA, 20(SP)
9D00881C  7C042420   SEB A0, A0
9D008820  7C052C20   SEB A1, A1
9D00892C  00034840   SLL T1, V1, 1
9D008930  000318C0   SLL V1, V1, 3
9D008934  01234821   ADDU T1, T1, V1
9D008938  01244821   ADDU T1, T1, A0
9D00893C  00094880   SLL T1, T1, 2
9D008940  3C03A000   LUI V1, -24576
9D008944  24630138   ADDIU V1, V1, 312
9D008948  00692021   ADDU A0, V1, T1
9D00894C  000D68C0   SLL T5, T5, 3
9D008950  3C059D01   LUI A1, -25343
9D008954  24A50C38   ADDIU A1, A1, 3128
9D008958  00AD2821   ADDU A1, A1, T5
9D00895C  24630140   ADDIU V1, V1, 320
9D008960  00691821   ADDU V1, V1, T1
116:                     register int i,l,r,b,x,y;
117:                     x=cx;
9D008824  97828054   LHU V0, -32684(GP)
118:                     y=cy;
119:                     if (channel==LOCAL_CON){
9D008828  14800080   BNE A0, ZERO, 0x9D008A2C
9D00882C  97838056   LHU V1, -32682(GP)
120:                         switch (c){
9D008830  24060009   ADDIU A2, ZERO, 9
9D008834  10A60010   BEQ A1, A2, 0x9D008878
9D008838  28A4000A   SLTI A0, A1, 10
9D00883C  10800006   BEQ A0, ZERO, 0x9D008858
9D008840  2404000A   ADDIU A0, ZERO, 10
9D008844  24040008   ADDIU A0, ZERO, 8
9D008848  14A40022   BNE A1, A0, 0x9D0088D4
9D00884C  28A40020   SLTI A0, A1, 32
9D008850  0B402231   J 0x9D0088C4
9D008854  00000000   NOP
9D008858  10A40003   BEQ A1, A0, 0x9D008868
9D00885C  2404000D   ADDIU A0, ZERO, 13
9D008860  14A4001C   BNE A1, A0, 0x9D0088D4
9D008864  28A40020   SLTI A0, A1, 32
121:                             case CR:
122:                             case NL:
123:                                 crlf();
9D008868  0F4021F6   JAL crlf
9D00886C  00000000   NOP
124:                                 break;
9D008870  0B40228E   J 0x9D008A38
9D008874  8FBF0014   LW RA, 20(SP)
125:                             case TAB:
126:                                 cx += (cx%tab_width);
9D008878  9385801C   LBU A1, -32740(GP)
9D00887C  0045001A   DIV V0, A1
9D008880  00A001F4   TEQ A1, ZERO
9D008884  00002010   MFHI A0, 0
9D008888  00441021   ADDU V0, V0, A0
9D00888C  3042FFFF   ANDI V0, V0, -1
9D008890  A7828054   SH V0, -32684(GP)
127:                                 if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
9D008894  2C42013E   SLTIU V0, V0, 318
9D008898  14400066   BNE V0, ZERO, 0x9D008A34
9D00889C  240200C8   ADDIU V0, ZERO, 200
128:                                     cx = 0;
129:                                     if (cy==((LINE_PER_SCREEN-1)*CHAR_HEIGHT)){
9D0088A0  14620005   BNE V1, V0, 0x9D0088B8
9D0088A4  A7808054   SH ZERO, -32684(GP)
130:                                         scroll_up();
9D0088A8  0F40218C   JAL scroll_up
9D0088AC  00000000   NOP
131:                                     }else{
132:                                         cy += CHAR_HEIGHT;
9D0088B8  24630008   ADDIU V1, V1, 8
9D0088BC  0B40228D   J 0x9D008A34
9D0088C0  A7838056   SH V1, -32682(GP)
133:                                     }
134:                                 }
135:                                 break;
136:                             case '\b':
137:                                 cursor_left();
9D0088C4  0F4021C7   JAL cursor_left
9D0088C8  00000000   NOP
138:                                 break;
9D0088CC  0B40228E   J 0x9D008A38
9D0088D0  8FBF0014   LW RA, 20(SP)
139:                             default:
140:                                 if ((c<32) || (c>(FONT_SIZE+32))) break;
9D0088D4  14800057   BNE A0, ZERO, 0x9D008A34
9D0088D8  24ADFFE0   ADDIU T5, A1, -32
141:                                 c -=32;
9D0088DC  7C0D6C20   SEB T5, T5
142:                                 b=x>>5; // position index ligne video_bmp
9D0088E0  00022143   SRA A0, V0, 5
143:                                 r=0;
144:                                 l=(32-CHAR_WIDTH)-(x&0x1f); // décalage  à l'intérieur de l'entier
9D0088E4  3042001F   ANDI V0, V0, 31
9D0088E8  2405001A   ADDIU A1, ZERO, 26
9D0088EC  00A21023   SUBU V0, A1, V0
145:                                 if (l<0){
146:                                     r=-l;
9D0088F0  00022823   SUBU A1, ZERO, V0
9D0088F4  28460000   SLTI A2, V0, 0
9D0088F8  0006280A   MOVZ A1, ZERO, A2
9D0088FC  00A03021   ADDU A2, A1, ZERO
147:                                 }
148:                                 for (i=0;i<8;i++){
9D008A14  1483FFD3   BNE A0, V1, 0x9D008964
9D008A18  24A50001   ADDIU A1, A1, 1
149:                                     if (r){
9D008964  10C0001B   BEQ A2, ZERO, 0x9D0089D4
9D008968  00000000   NOP
150:                                         if (flags & INV_VID){
9D008900  9787804E   LHU A3, -32690(GP)
9D008904  30E70004   ANDI A3, A3, 4
9D00896C  10E0000E   BEQ A3, ZERO, 0x9D0089A8
9D008970  90A90000   LBU T1, 0(A1)
151:                                             video_bmp[y][b] |= (0x3f>>r);
9D008908  240A003F   ADDIU T2, ZERO, 63
9D00890C  00AA6007   SRAV T4, T2, A1
9D00897C  8C8D0000   LW T5, 0(A0)
9D008980  018D6825   OR T5, T4, T5
152:                                             video_bmp[y][b] &=~(font6x8[c][i]>>r);
9D008974  00C9C807   SRAV T9, T1, A2
9D008978  0019C827   NOR T9, ZERO, T9
9D008984  032D6824   AND T5, T9, T5
9D008988  AC8D0000   SW T5, 0(A0)
153:                                             video_bmp[y][b+1] |= (0x3f<<32-r);
9D008910  24080020   ADDIU T0, ZERO, 32
9D008914  01054023   SUBU T0, T0, A1
9D008918  010A5804   SLLV T3, T2, T0
9D008994  8C8D0004   LW T5, 4(A0)
9D008998  016D6825   OR T5, T3, T5
154:                                             video_bmp[y][b+1] &= ~(font6x8[c][i]<<(32-r));
9D00898C  01094804   SLLV T1, T1, T0
9D008990  00094827   NOR T1, ZERO, T1
9D00899C  012D4824   AND T1, T1, T5
9D0089A0  0B402284   J 0x9D008A10
9D0089A4  AC890004   SW T1, 4(A0)
155:                                         }else{
156:                                             video_bmp[y][b] &= ~(0x3f>>r);
9D00891C  000C7827   NOR T7, ZERO, T4
9D0089A8  8C8D0000   LW T5, 0(A0)
9D0089AC  01ED6824   AND T5, T7, T5
157:                                             video_bmp[y][b] |= font6x8[c][i]>>r;
9D0089B0  00C9C807   SRAV T9, T1, A2
9D0089B4  01B96825   OR T5, T5, T9
9D0089B8  AC8D0000   SW T5, 0(A0)
158:                                             video_bmp[y][b+1] &= ~(0x3f<<32-r);
9D008920  000B7027   NOR T6, ZERO, T3
9D0089BC  8C8D0004   LW T5, 4(A0)
9D0089C0  01CD6824   AND T5, T6, T5
159:                                             video_bmp[y][b+1] |= font6x8[c][i]<<(32-r);
9D0089C4  01094804   SLLV T1, T1, T0
9D0089C8  01A94825   OR T1, T5, T1
9D0089CC  0B402284   J 0x9D008A10
9D0089D0  AC890004   SW T1, 4(A0)
160:                                         }
161:                                         y++;
162:                                     } else{
163:                                         if (flags & INV_VID){
9D0089D4  50E00009   BEQL A3, ZERO, 0x9D0089FC
9D0089D8  8C8D0000   LW T5, 0(A0)
164:                                             video_bmp[y][b] |= (0x3f<<l);
9D008924  004A5004   SLLV T2, T2, V0
9D0089E8  8C890000   LW T1, 0(A0)
9D0089EC  01494825   OR T1, T2, T1
165:                                             video_bmp[y++][b] &=~(font6x8[c][i]<<l);
9D0089DC  90AD0000   LBU T5, 0(A1)
9D0089E0  004D6804   SLLV T5, T5, V0
9D0089E4  000D6827   NOR T5, ZERO, T5
9D0089F0  01A94824   AND T1, T5, T1
9D0089F4  0B402284   J 0x9D008A10
9D0089F8  AC890000   SW T1, 0(A0)
166:                                         }else{
167:                                             video_bmp[y][b] &= ~(0x3f<<l);
9D008928  000AC027   NOR T8, ZERO, T2
9D0089FC  030D6824   AND T5, T8, T5
168:                                             video_bmp[y++][b] |= font6x8[c][i]<<l;
9D008A00  90A90000   LBU T1, 0(A1)
9D008A04  00494804   SLLV T1, T1, V0
9D008A08  01A94825   OR T1, T5, T1
9D008A0C  AC890000   SW T1, 0(A0)
9D008A10  24840028   ADDIU A0, A0, 40
169:                                         }
170:                                     }
171:                                 }
172:                                 cursor_right();
9D008A1C  0F4021AE   JAL cursor_right
9D008A20  00000000   NOP
173:                         }//switch(c)
174:                     }else{
175:                         UartPutch(channel,c);
9D008A2C  0F404002   JAL UartPutch
9D008A30  00000000   NOP
176:                     }
177:                 }//put_char()
9D0088B0  0B40228E   J 0x9D008A38
9D0088B4  8FBF0014   LW RA, 20(SP)
9D008A24  0B40228E   J 0x9D008A38
9D008A28  8FBF0014   LW RA, 20(SP)
9D008A34  8FBF0014   LW RA, 20(SP)
9D008A38  03E00008   JR RA
9D008A3C  27BD0018   ADDIU SP, SP, 24
178:                 
179:                 void clear_screen(){
9D008A40  27BDFFE8   ADDIU SP, SP, -24
9D008A44  AFBF0014   SW RA, 20(SP)
180:                     memset(video_bmp,0,HRES/8*VRES);
9D008A48  3C04A000   LUI A0, -24576
9D008A4C  24840138   ADDIU A0, A0, 312
9D008A50  00002821   ADDU A1, ZERO, ZERO
9D008A54  0F4059A4   JAL 0x9D016690
9D008A58  24062080   ADDIU A2, ZERO, 8320
181:                     cx=0;
9D008A5C  A7808054   SH ZERO, -32684(GP)
182:                     cy=0;
9D008A60  A7808056   SH ZERO, -32682(GP)
183:                 } // clear_screen()
9D008A64  8FBF0014   LW RA, 20(SP)
9D008A68  03E00008   JR RA
9D008A6C  27BD0018   ADDIU SP, SP, 24
184:                 
185:                 void print(dev_t channel, const char *text){
9D008A70  27BDFFE8   ADDIU SP, SP, -24
9D008A74  AFBF0014   SW RA, 20(SP)
9D008A78  AFB00010   SW S0, 16(SP)
9D008A7C  7C042420   SEB A0, A0
186:                     if (channel==LOCAL_CON){
9D008A80  1480000C   BNE A0, ZERO, 0x9D008AB4
9D008A84  00A08021   ADDU S0, A1, ZERO
187:                         while (*text){
9D008A88  80A50000   LB A1, 0(A1)
9D008A8C  10A0000C   BEQ A1, ZERO, 0x9D008AC0
9D008A90  8FBF0014   LW RA, 20(SP)
9D008AA0  82050000   LB A1, 0(S0)
9D008AA4  14A0FFFC   BNE A1, ZERO, 0x9D008A98
9D008AA8  26100001   ADDIU S0, S0, 1
188:                             put_char(channel, *text++);
9D008A94  26100001   ADDIU S0, S0, 1
9D008A98  0F402205   JAL put_char
9D008A9C  00002021   ADDU A0, ZERO, ZERO
189:                         }
190:                     }else{
191:                         UartPrint(channel,text);
9D008AB4  0F40403A   JAL UartPrint
9D008AB8  00000000   NOP
192:                     }
193:                 }// print()
9D008AAC  0B4022B0   J 0x9D008AC0
9D008AB0  8FBF0014   LW RA, 20(SP)
9D008ABC  8FBF0014   LW RA, 20(SP)
9D008AC0  8FB00010   LW S0, 16(SP)
9D008AC4  03E00008   JR RA
9D008AC8  27BD0018   ADDIU SP, SP, 24
194:                 
195:                 void println(dev_t channel, const char *str){
9D008ACC  27BDFFE8   ADDIU SP, SP, -24
9D008AD0  AFBF0014   SW RA, 20(SP)
9D008AD4  AFB00010   SW S0, 16(SP)
9D008AD8  7C048420   SEB S0, A0
196:                     print(channel, str);
9D008ADC  0F40229C   JAL print
9D008AE0  02002021   ADDU A0, S0, ZERO
197:                     if (channel==LOCAL_CON){
9D008AE4  16000005   BNE S0, ZERO, 0x9D008AFC
9D008AE8  02002021   ADDU A0, S0, ZERO
198:                         crlf();
9D008AEC  0F4021F6   JAL crlf
9D008AF0  00000000   NOP
199:                     }else{
200:                         UartPutch(channel,'\r');
9D008AFC  0F404002   JAL UartPutch
9D008B00  2405000D   ADDIU A1, ZERO, 13
201:                     }
202:                 }
9D008AF4  0B4022C2   J 0x9D008B08
9D008AF8  8FBF0014   LW RA, 20(SP)
9D008B04  8FBF0014   LW RA, 20(SP)
9D008B08  8FB00010   LW S0, 16(SP)
9D008B0C  03E00008   JR RA
9D008B10  27BD0018   ADDIU SP, SP, 24
203:                 
204:                 void print_hex(dev_t channel, unsigned int hex, unsigned char width){
9D008B14  27BDFFD8   ADDIU SP, SP, -40
9D008B18  AFBF0024   SW RA, 36(SP)
9D008B1C  7C042420   SEB A0, A0
205:                     char c[12], *d;
206:                     int i;
207:                     c[11]=0;
9D008B20  A3A0001B   SB ZERO, 27(SP)
208:                     d= &c[10];
209:                     for(i=width;i>=0||hex;i--){
9D008B24  30C600FF   ANDI A2, A2, 255
9D008B28  0B4022D7   J 0x9D008B5C
9D008B2C  27A2001A   ADDIU V0, SP, 26
9D008B58  24C6FFFF   ADDIU A2, A2, -1
9D008B5C  04C1FFF4   BGEZ A2, 0x9D008B30
9D008B60  30A3000F   ANDI V1, A1, 15
9D008B64  14A0FFF3   BNE A1, ZERO, 0x9D008B34
9D008B68  2867000A   SLTI A3, V1, 10
210:                         *d=(hex%16);
211:                         if (*d<10)
9D008B30  2867000A   SLTI A3, V1, 10
9D008B34  10E00004   BEQ A3, ZERO, 0x9D008B48
9D008B38  A0430000   SB V1, 0(V0)
212:                             *d += '0';
9D008B3C  24630030   ADDIU V1, V1, 48
9D008B40  0B4022D4   J 0x9D008B50
9D008B44  A0430000   SB V1, 0(V0)
213:                         else
214:                             *d += 'A'-10;
9D008B48  24630037   ADDIU V1, V1, 55
9D008B4C  A0430000   SB V1, 0(V0)
215:                         hex /=16;
9D008B50  00052902   SRL A1, A1, 4
216:                         d--;
9D008B54  2442FFFF   ADDIU V0, V0, -1
217:                     }
218:                     print(channel, ++d);
9D008B6C  0F40229C   JAL print
9D008B70  24450001   ADDIU A1, V0, 1
219:                 } // print_hex()
9D008B74  8FBF0024   LW RA, 36(SP)
9D008B78  03E00008   JR RA
9D008B7C  27BD0028   ADDIU SP, SP, 40
220:                 
221:                 void print_int(dev_t channel, int number, unsigned short width){ // imprime entier,width inclus le signe
9D008B80  27BDFFD8   ADDIU SP, SP, -40
9D008B84  AFBF0024   SW RA, 36(SP)
9D008B88  7C042420   SEB A0, A0
9D008C14  00463023   SUBU A2, V0, A2
9D008C18  00401821   ADDU V1, V0, ZERO
222:                     int sign=0, i;
223:                     char str[14], *d;
224:                     str[13]=0;
9D008B8C  30C2FFFF   ANDI V0, A2, -1
9D008B90  2C42000E   SLTIU V0, V0, 14
9D008B94  14400002   BNE V0, ZERO, 0x9D008BA0
9D008B98  A3A0001D   SB ZERO, 29(SP)
9D008B9C  2406000D   ADDIU A2, ZERO, 13
9D008BA0  30C6FFFF   ANDI A2, A2, -1
225:                     d=&str[12];
9D008BBC  27A2001C   ADDIU V0, SP, 28
9D008BF8  27A2001C   ADDIU V0, SP, 28
226:                     if (width>13){width=13;}
227:                     if (number<0){
9D008BA4  04A10003   BGEZ A1, 0x9D008BB4
9D008BA8  00004021   ADDU T0, ZERO, ZERO
228:                         sign=1;
9D008BB0  24080001   ADDIU T0, ZERO, 1
229:                         number = -number;
9D008BAC  00052823   SUBU A1, ZERO, A1
230:                     }
231:                     //for (i=--width;i>=0||number;i--){
232:                     i=width;
233:                     while (number>0){
9D008BB4  18A00010   BLEZ A1, 0x9D008BF8
9D008BB8  00C04821   ADDU T1, A2, ZERO
9D008BE0  1CA0FFF8   BGTZ A1, 0x9D008BC4
9D008BE4  24C6FFFF   ADDIU A2, A2, -1
234:                        *d--=(number%10)+'0';
9D008BC0  2403000A   ADDIU V1, ZERO, 10
9D008BC4  00A3001A   DIV A1, V1
9D008BC8  006001F4   TEQ V1, ZERO
9D008BCC  00003810   MFHI A3, 0
9D008BD0  00002812   MFLO A1, 0
9D008BD4  24E70030   ADDIU A3, A3, 48
9D008BD8  A0470000   SB A3, 0(V0)
9D008BDC  2442FFFF   ADDIU V0, V0, -1
235:                         number /= 10;
236:                         i--;
237:                     }
238:                     if (i==width){
9D008BE8  15260008   BNE T1, A2, 0x9D008C0C
9D008BEC  24030030   ADDIU V1, ZERO, 48
239:                         *d--='0';
9D008BF0  0B402301   J 0x9D008C04
9D008BF4  A0430000   SB V1, 0(V0)
9D008BFC  24030030   ADDIU V1, ZERO, 48
9D008C00  A0430000   SB V1, 0(V0)
9D008C04  2442FFFF   ADDIU V0, V0, -1
240:                         i--;
9D008C08  24C6FFFF   ADDIU A2, A2, -1
241:                     }
242:                     while (i>0){
9D008C0C  18C00009   BLEZ A2, 0x9D008C34
9D008C10  00C03821   ADDU A3, A2, ZERO
9D008C28  5466FFFE   BNEL V1, A2, 0x9D008C24
9D008C2C  A0650000   SB A1, 0(V1)
9D008C30  00471023   SUBU V0, V0, A3
243:                         *d--=' ';
9D008C1C  24050020   ADDIU A1, ZERO, 32
9D008C20  A0650000   SB A1, 0(V1)
9D008C24  2463FFFF   ADDIU V1, V1, -1
244:                         i--;
245:                     }
246:                     if (sign){*d='-';}else{*d=' ';}
9D008C34  11000004   BEQ T0, ZERO, 0x9D008C48
9D008C38  24030020   ADDIU V1, ZERO, 32
9D008C3C  2403002D   ADDIU V1, ZERO, 45
9D008C40  0B402313   J 0x9D008C4C
9D008C44  A0430000   SB V1, 0(V0)
9D008C48  A0430000   SB V1, 0(V0)
247:                     
248:                     print(channel, d);
9D008C4C  0F40229C   JAL print
9D008C50  00402821   ADDU A1, V0, ZERO
249:                 }// print_int()
9D008C54  8FBF0024   LW RA, 36(SP)
9D008C58  03E00008   JR RA
9D008C5C  27BD0028   ADDIU SP, SP, 40
250:                 
251:                 void set_tab_width(unsigned char width){
252:                     tab_width=width;
253:                 }// set_tab_width()
9D008C60  03E00008   JR RA
9D008C64  A384801C   SB A0, -32740(GP)
254:                 
255:                 void clear_eol(void){
9D008C68  27BDFFE0   ADDIU SP, SP, -32
9D008C6C  AFBF001C   SW RA, 28(SP)
9D008C70  AFB10018   SW S1, 24(SP)
9D008C74  AFB00014   SW S0, 20(SP)
256:                     int x,y;
257:                     x=cx;
9D008C78  97908054   LHU S0, -32684(GP)
258:                     y=cy;
259:                     while (cx<(CHAR_WIDTH*(CHAR_PER_LINE-2))){
9D008C7C  2E020132   SLTIU V0, S0, 306
9D008C80  10400008   BEQ V0, ZERO, 0x9D008CA4
9D008C84  97918056   LHU S1, -32682(GP)
9D008C94  97828054   LHU V0, -32684(GP)
9D008C98  2C420132   SLTIU V0, V0, 306
9D008C9C  1440FFFB   BNE V0, ZERO, 0x9D008C8C
9D008CA0  00002021   ADDU A0, ZERO, ZERO
260:                         put_char(LOCAL_CON, 32);
9D008C88  00002021   ADDU A0, ZERO, ZERO
9D008C8C  0F402205   JAL put_char
9D008C90  24050020   ADDIU A1, ZERO, 32
261:                     }
262:                     put_char(LOCAL_CON, 32);
9D008CA4  00002021   ADDU A0, ZERO, ZERO
9D008CA8  0F402205   JAL put_char
9D008CAC  24050020   ADDIU A1, ZERO, 32
263:                     cx=x;
9D008CB0  A7908054   SH S0, -32684(GP)
264:                     cy=y;
9D008CB4  A7918056   SH S1, -32682(GP)
265:                 }// clear_eol()
9D008CB8  8FBF001C   LW RA, 28(SP)
9D008CBC  8FB10018   LW S1, 24(SP)
9D008CC0  8FB00014   LW S0, 20(SP)
9D008CC4  03E00008   JR RA
9D008CC8  27BD0020   ADDIU SP, SP, 32
266:                 
267:                 text_coord_t get_curpos(){
9D008CCC  00801021   ADDU V0, A0, ZERO
268:                     text_coord_t cpos;
269:                     cpos.x = cx/CHAR_WIDTH;
9D008CD8  97858054   LHU A1, -32684(GP)
9D008CDC  24040006   ADDIU A0, ZERO, 6
9D008CE0  00A4001B   DIVU A1, A0
9D008CE4  008001F4   TEQ A0, ZERO
9D008CE8  00002812   MFLO A1, 0
270:                     cpos.y = cy/CHAR_HEIGHT;
9D008CD0  97838056   LHU V1, -32682(GP)
9D008CD4  000318C2   SRL V1, V1, 3
9D008CEC  A4450000   SH A1, 0(V0)
271:                     return cpos;
272:                 } // get_cursor_pos()
9D008CF0  03E00008   JR RA
9D008CF4  A4430002   SH V1, 2(V0)
273:                 
274:                 void set_curpos(unsigned short x, unsigned short y){// {x,y} coordonnée caractère
9D008CF8  3084FFFF   ANDI A0, A0, -1
275:                     if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
9D008CFC  2C820035   SLTIU V0, A0, 53
9D008D00  10400009   BEQ V0, ZERO, 0x9D008D28
9D008D04  30A5FFFF   ANDI A1, A1, -1
9D008D08  2CA2001A   SLTIU V0, A1, 26
9D008D0C  10400006   BEQ V0, ZERO, 0x9D008D28
9D008D10  00042040   SLL A0, A0, 1
276:                         return;
277:                     cx=x*CHAR_WIDTH;
9D008D14  00041080   SLL V0, A0, 2
9D008D18  00442023   SUBU A0, V0, A0
9D008D1C  A7848054   SH A0, -32684(GP)
278:                     cy=y*CHAR_HEIGHT;
9D008D20  000528C0   SLL A1, A1, 3
9D008D24  A7858056   SH A1, -32682(GP)
9D008D28  03E00008   JR RA
9D008D2C  00000000   NOP
279:                 }//set_curpos()
280:                 
281:                 void invert_char(void){// inverse vidéo du caractère à la position courante
9D008D6C  24A30001   ADDIU V1, A1, 1
9D008D70  00053040   SLL A2, A1, 1
9D008D74  000510C0   SLL V0, A1, 3
9D008D78  00C23021   ADDU A2, A2, V0
9D008D7C  00CA3021   ADDU A2, A2, T2
9D008D80  00063080   SLL A2, A2, 2
9D008D84  3C02A000   LUI V0, -24576
9D008D88  24420138   ADDIU V0, V0, 312
9D008D8C  00461021   ADDU V0, V0, A2
9D008D90  24A5000A   ADDIU A1, A1, 10
282:                     register int i,l,r,b,x,y;
283:                     x=cx;
9D008D30  97878054   LHU A3, -32684(GP)
284:                     y=cy;
9D008D34  97858056   LHU A1, -32682(GP)
285:                     b=x>>5;
9D008D38  00075143   SRA T2, A3, 5
286:                     r=0;
287:                     l=(32-CHAR_WIDTH)-(x&0x1f);
9D008D3C  30E7001F   ANDI A3, A3, 31
9D008D40  2402001A   ADDIU V0, ZERO, 26
9D008D44  00473823   SUBU A3, V0, A3
288:                     if (l<0){
289:                         r=-l;
9D008D48  00071023   SUBU V0, ZERO, A3
9D008D4C  28E40000   SLTI A0, A3, 0
9D008D50  0004100A   MOVZ V0, ZERO, A0
9D008D54  00402021   ADDU A0, V0, ZERO
290:                     }
291:                     for (i=9;i;i--){
9D008DC0  1465FFF4   BNE V1, A1, 0x9D008D94
9D008DC4  24420028   ADDIU V0, V0, 40
292:                         if (r){
9D008D94  10800007   BEQ A0, ZERO, 0x9D008DB4
9D008D98  8C460000   LW A2, 0(V0)
293:                             video_bmp[y][b] ^= (0x3f>>r);
9D008D58  2403003F   ADDIU V1, ZERO, 63
9D008D5C  00434807   SRAV T1, V1, V0
9D008D9C  00C93026   XOR A2, A2, T1
9D008DA0  AC460000   SW A2, 0(V0)
294:                             video_bmp[y][b+1] ^= (0x3f<<32-r);
9D008D60  00024023   SUBU T0, ZERO, V0
9D008D64  01034004   SLLV T0, V1, T0
9D008DA4  8C460004   LW A2, 4(V0)
9D008DA8  00C83026   XOR A2, A2, T0
9D008DAC  0B40236F   J 0x9D008DBC
9D008DB0  AC460004   SW A2, 4(V0)
295:                             y++;
296:                         } else{
297:                             video_bmp[y++][b] ^= (0x3f<<l);
9D008D68  00E33804   SLLV A3, V1, A3
9D008DB4  00C73026   XOR A2, A2, A3
9D008DB8  AC460000   SW A2, 0(V0)
9D008DBC  24630001   ADDIU V1, V1, 1
298:                         }
299:                     }
300:                 }//invert_char()
9D008DC8  03E00008   JR RA
9D008DCC  00000000   NOP
301:                 
302:                 static void toggle_underscore(void){
303:                     register int l,r,b,x;
304:                     x=cx;
9D008568  97828054   LHU V0, -32684(GP)
305:                     b=x>>5;
9D00856C  00021943   SRA V1, V0, 5
306:                     r=0;
307:                     l=(32-CHAR_WIDTH)-(x&0x1f);
9D008570  3042001F   ANDI V0, V0, 31
9D008574  2404001A   ADDIU A0, ZERO, 26
9D008578  00821023   SUBU V0, A0, V0
308:                     if (l<0){
9D00857C  0441001D   BGEZ V0, 0x9D0085F4
9D008580  97848056   LHU A0, -32682(GP)
309:                         r=-l;
9D008584  00022023   SUBU A0, ZERO, V0
310:                     }
311:                     if (r){
9D008588  10800019   BEQ A0, ZERO, 0x9D0085F0
9D00858C  3C05A000   LUI A1, -24576
312:                         video_bmp[cy+CHAR_HEIGHT-1][b] ^= (0x3f>>r);
9D008590  97828056   LHU V0, -32682(GP)
9D008594  24420007   ADDIU V0, V0, 7
9D008598  00023040   SLL A2, V0, 1
9D00859C  000210C0   SLL V0, V0, 3
9D0085A0  00C23021   ADDU A2, A2, V0
9D0085A4  00C33821   ADDU A3, A2, V1
9D0085A8  00073880   SLL A3, A3, 2
9D0085AC  24A50138   ADDIU A1, A1, 312
9D0085B0  00E53821   ADDU A3, A3, A1
9D0085B4  2402003F   ADDIU V0, ZERO, 63
9D0085B8  00824807   SRAV T1, V0, A0
9D0085BC  8CE80000   LW T0, 0(A3)
9D0085C0  01284026   XOR T0, T1, T0
9D0085C4  ACE80000   SW T0, 0(A3)
313:                         video_bmp[cy+CHAR_HEIGHT-1][b+1] ^= (0x3f<<32-r);
9D0085C8  24630001   ADDIU V1, V1, 1
9D0085CC  00C31821   ADDU V1, A2, V1
9D0085D0  00031880   SLL V1, V1, 2
9D0085D4  00651821   ADDU V1, V1, A1
9D0085D8  00042023   SUBU A0, ZERO, A0
9D0085DC  00821004   SLLV V0, V0, A0
9D0085E0  8C650000   LW A1, 0(V1)
9D0085E4  00451026   XOR V0, V0, A1
9D0085E8  03E00008   JR RA
9D0085EC  AC620000   SW V0, 0(V1)
314:                     } else{
315:                         video_bmp[cy+CHAR_HEIGHT-1][b] ^= (0x3f<<l);
9D0085F0  97848056   LHU A0, -32682(GP)
9D0085F4  24840007   ADDIU A0, A0, 7
9D0085F8  00042840   SLL A1, A0, 1
9D0085FC  000420C0   SLL A0, A0, 3
9D008600  00A42021   ADDU A0, A1, A0
9D008604  00831821   ADDU V1, A0, V1
9D008608  00031880   SLL V1, V1, 2
9D00860C  3C05A000   LUI A1, -24576
9D008610  24A50138   ADDIU A1, A1, 312
9D008614  00651821   ADDU V1, V1, A1
9D008618  2404003F   ADDIU A0, ZERO, 63
9D00861C  00441004   SLLV V0, A0, V0
9D008620  8C640000   LW A0, 0(V1)
9D008624  00441026   XOR V0, V0, A0
9D008628  03E00008   JR RA
9D00862C  AC620000   SW V0, 0(V1)
316:                     }
317:                 }//toggle_underscore()
318:                 
319:                 void show_cursor(BOOL show){
9D008DD0  27BDFFE8   ADDIU SP, SP, -24
9D008DD4  AFBF0014   SW RA, 20(SP)
320:                     if (show){
9D008DD8  10800011   BEQ A0, ZERO, 0x9D008E20
9D008DDC  AFB00010   SW S0, 16(SP)
321:                         flags |= CUR_SHOW;
9D008DE0  9782804E   LHU V0, -32690(GP)
9D008DE4  34420001   ORI V0, V0, 1
322:                         flags ^= CUR_VIS;
9D008DE8  38420002   XORI V0, V0, 2
9D008DEC  A782804E   SH V0, -32690(GP)
323:                         if (cur_shape==CR_BLOCK){
9D008DF0  24020001   ADDIU V0, ZERO, 1
9D008DF4  8F838050   LW V1, -32688(GP)
9D008DF8  14620005   BNE V1, V0, 0x9D008E10
9D008DFC  00000000   NOP
324:                             invert_char();
9D008E00  0F40234C   JAL invert_char
9D008E04  00000000   NOP
325:                         }else{
326:                             toggle_underscore();
9D008E10  0F40215A   JAL 0x9D008568
9D008E14  00000000   NOP
327:                         }
328:                     }else{
329:                         if (flags & CUR_VIS){
9D008E20  9790804E   LHU S0, -32690(GP)
9D008E24  32020002   ANDI V0, S0, 2
9D008E28  1040000D   BEQ V0, ZERO, 0x9D008E60
9D008E2C  9782804E   LHU V0, -32690(GP)
330:                             if (cur_shape==CR_BLOCK){
9D008E30  24020001   ADDIU V0, ZERO, 1
9D008E34  8F838050   LW V1, -32688(GP)
9D008E38  14620005   BNE V1, V0, 0x9D008E50
9D008E3C  00000000   NOP
331:                                 invert_char();
9D008E40  0F40234C   JAL invert_char
9D008E44  3210FFFD   ANDI S0, S0, -3
332:                             }else{
333:                                 toggle_underscore();
9D008E50  0F40215A   JAL 0x9D008568
9D008E54  3210FFFD   ANDI S0, S0, -3
334:                             }
335:                             flags &= ~CUR_VIS;
9D008E48  0B402397   J 0x9D008E5C
9D008E4C  A790804E   SH S0, -32690(GP)
9D008E58  A790804E   SH S0, -32690(GP)
336:                         }
337:                         flags &= ~CUR_SHOW;
9D008E5C  9782804E   LHU V0, -32690(GP)
9D008E60  3042FFFE   ANDI V0, V0, -2
9D008E64  A782804E   SH V0, -32690(GP)
338:                     }
339:                 
340:                 }// show_cursor()
9D008E08  0B40239B   J 0x9D008E6C
9D008E0C  8FBF0014   LW RA, 20(SP)
9D008E18  0B40239B   J 0x9D008E6C
9D008E1C  8FBF0014   LW RA, 20(SP)
9D008E68  8FBF0014   LW RA, 20(SP)
9D008E6C  8FB00010   LW S0, 16(SP)
9D008E70  03E00008   JR RA
9D008E74  27BD0018   ADDIU SP, SP, 24
341:                 
342:                 void set_cursor(cursor_t shape){
9D008E78  27BDFFE8   ADDIU SP, SP, -24
9D008E7C  AFBF0014   SW RA, 20(SP)
9D008E80  AFB00010   SW S0, 16(SP)
343:                     if (flags & CUR_VIS){
9D008E84  9782804E   LHU V0, -32690(GP)
9D008E88  30420002   ANDI V0, V0, 2
9D008E8C  10400008   BEQ V0, ZERO, 0x9D008EB0
9D008E90  00808021   ADDU S0, A0, ZERO
344:                         show_cursor(FALSE);
9D008E94  0F402374   JAL show_cursor
9D008E98  00002021   ADDU A0, ZERO, ZERO
345:                         cur_shape=shape;
9D008E9C  AF908050   SW S0, -32688(GP)
346:                         show_cursor(TRUE);
9D008EA0  0F402374   JAL show_cursor
9D008EA4  24040001   ADDIU A0, ZERO, 1
347:                     }else{
348:                         cur_shape=shape;
9D008EB0  AF848050   SW A0, -32688(GP)
349:                     }
350:                 }// set_cursor()
9D008EA8  0B4023AE   J 0x9D008EB8
9D008EAC  8FBF0014   LW RA, 20(SP)
9D008EB4  8FBF0014   LW RA, 20(SP)
9D008EB8  8FB00010   LW S0, 16(SP)
9D008EBC  03E00008   JR RA
9D008EC0  27BD0018   ADDIU SP, SP, 24
351:                 
352:                 unsigned short get_key(dev_t channel){ // lecture touche clavier, retourne 0 s'il n'y a pas de touche ou touche relâchée.
9D008EC4  27BDFFE8   ADDIU SP, SP, -24
9D008EC8  7C042420   SEB A0, A0
353:                     unsigned short code;
354:                     if (channel==LOCAL_CON){
9D008ECC  1480000C   BNE A0, ZERO, 0x9D008F00
9D008ED0  AFBF0014   SW RA, 20(SP)
355:                         code=  KbdScancode();
9D008ED4  0F401F18   JAL KbdScancode
9D008ED8  00000000   NOP
9D008EDC  00402021   ADDU A0, V0, ZERO
9D008EE0  3042FFFF   ANDI V0, V0, -1
356:                         if (!(code & FN_BIT)){
9D008EE4  30430200   ANDI V1, V0, 512
9D008EE8  14600009   BNE V1, ZERO, 0x9D008F10
9D008EEC  8FBF0014   LW RA, 20(SP)
357:                             code = KbdKey(code);
9D008EF0  0F401DDA   JAL KbdKey
9D008EF4  00000000   NOP
9D008EF8  0B4023C3   J 0x9D008F0C
9D008EFC  3042FFFF   ANDI V0, V0, -1
358:                         }
359:                     }else{
360:                         code=UartGetch(STDIN);
9D008F00  0F403FF5   JAL UartGetch
9D008F04  24040001   ADDIU A0, ZERO, 1
9D008F08  3042FFFF   ANDI V0, V0, -1
361:                         if (code==-1){
362:                             code=0;
363:                         }
364:                     }
365:                     return code;
366:                 }//get_key()
9D008F0C  8FBF0014   LW RA, 20(SP)
9D008F10  03E00008   JR RA
9D008F14  27BD0018   ADDIU SP, SP, 24
367:                 
368:                 unsigned short wait_key(dev_t channel){ // attend qu'une touche soit enfoncée et retourne sa valeur.
9D008F18  27BDFFE0   ADDIU SP, SP, -32
9D008F1C  AFBF001C   SW RA, 28(SP)
9D008F20  AFB10018   SW S1, 24(SP)
9D008F24  AFB00014   SW S0, 20(SP)
369:                     unsigned short key;
370:                     unsigned int t0;
371:                     t0=ticks()+500;
9D008F28  0F403E85   JAL ticks
9D008F2C  7C048420   SEB S0, A0
372:                     if (channel==LOCAL_CON){
9D008F30  12000013   BEQ S0, ZERO, 0x9D008F80
9D008F34  245101F4   ADDIU S1, V0, 500
373:                         while (!(key=get_key(channel))){
9D008F80  0F4023B1   JAL get_key
9D008F84  00002021   ADDU A0, ZERO, ZERO
9D008F88  1040FFED   BEQ V0, ZERO, 0x9D008F40
9D008F8C  00408021   ADDU S0, V0, ZERO
374:                             if (ticks()==t0){
9D008F40  0F403E85   JAL ticks
9D008F44  00000000   NOP
9D008F48  1451000D   BNE V0, S1, 0x9D008F80
9D008F4C  9782804E   LHU V0, -32690(GP)
375:                                 if (flags & CUR_SHOW){
9D008F50  30420001   ANDI V0, V0, 1
9D008F54  10400005   BEQ V0, ZERO, 0x9D008F6C
9D008F58  00000000   NOP
376:                                     show_cursor(FALSE);
9D008F5C  0F402374   JAL show_cursor
9D008F60  00002021   ADDU A0, ZERO, ZERO
9D008F64  0B4023DD   J 0x9D008F74
9D008F68  00000000   NOP
377:                                 }else{
378:                                     show_cursor(TRUE);
9D008F6C  0F402374   JAL show_cursor
9D008F70  24040001   ADDIU A0, ZERO, 1
379:                                 }
380:                                 t0=ticks()+500;
9D008F74  0F403E85   JAL ticks
9D008F78  00000000   NOP
9D008F7C  245101F4   ADDIU S1, V0, 500
381:                             }
382:                         };
383:                         show_cursor(FALSE);
9D008F90  0F402374   JAL show_cursor
9D008F94  00002021   ADDU A0, ZERO, ZERO
384:                     }else{
385:                         key=UartWaitch(STDIN,0);
9D008F38  0B4023E8   J 0x9D008FA0
9D008F3C  24040001   ADDIU A0, ZERO, 1
9D008FA0  0F404010   JAL UartWaitch
9D008FA4  00002821   ADDU A1, ZERO, ZERO
9D008FA8  3050FFFF   ANDI S0, V0, -1
386:                     }
387:                     return key;
388:                 }//wait_key()
9D008F98  0B4023EC   J 0x9D008FB0
9D008F9C  02001021   ADDU V0, S0, ZERO
9D008FAC  02001021   ADDU V0, S0, ZERO
9D008FB0  8FBF001C   LW RA, 28(SP)
9D008FB4  8FB10018   LW S1, 24(SP)
9D008FB8  8FB00014   LW S0, 20(SP)
9D008FBC  03E00008   JR RA
9D008FC0  27BD0020   ADDIU SP, SP, 32
389:                 
390:                 unsigned char readline(dev_t channel, unsigned char *ibuff,unsigned char max_char){ // lit une ligne au clavier, retourne la longueur de texte.
9D008FC4  27BDFFD0   ADDIU SP, SP, -48
9D008FC8  AFBF002C   SW RA, 44(SP)
9D008FCC  AFB50028   SW S5, 40(SP)
9D008FD0  AFB40024   SW S4, 36(SP)
9D008FD4  AFB30020   SW S3, 32(SP)
9D008FD8  AFB2001C   SW S2, 28(SP)
9D008FDC  AFB10018   SW S1, 24(SP)
9D008FE0  AFB00014   SW S0, 20(SP)
9D008FE4  00A09821   ADDU S3, A1, ZERO
9D008FE8  7C042420   SEB A0, A0
391:                     unsigned char c=0, count=0;
392:                     if (channel==LOCAL_CON){
9D008FEC  14800025   BNE A0, ZERO, 0x9D009084
9D008FF0  30D400FF   ANDI S4, A2, 255
9D008FF4  00008021   ADDU S0, ZERO, ZERO
393:                         while ((c!='\r') && (count<=max_char)){
9D009050  0B40241D   J 0x9D009074
9D009054  0290102B   SLTU V0, S4, S0
9D009070  0290102B   SLTU V0, S4, S0
9D009074  1040FFE4   BEQ V0, ZERO, 0x9D009008
9D009078  00000000   NOP
394:                             c=wait_key(channel);
9D009008  0F4023C6   JAL wait_key
9D00900C  00002021   ADDU A0, ZERO, ZERO
9D009010  304200FF   ANDI V0, V0, 255
395:                             if (c==CR){
9D008FF8  2411000D   ADDIU S1, ZERO, 13
9D009014  14510005   BNE V0, S1, 0x9D00902C
9D009018  00002021   ADDU A0, ZERO, ZERO
396:                                 put_char(channel,'\r');
9D00901C  0F402205   JAL put_char
9D009020  2405000D   ADDIU A1, ZERO, 13
397:                                 break;
9D009024  0B402425   J 0x9D009094
9D009028  A2600000   SB ZERO, 0(S3)
398:                             }else if (c==BS){
9D008FFC  24120008   ADDIU S2, ZERO, 8
9D00902C  5452000A   BNEL V0, S2, 0x9D009058
9D009030  A2620000   SB V0, 0(S3)
399:                                 if (count){
9D009034  1200FFF4   BEQ S0, ZERO, 0x9D009008
9D009038  00002021   ADDU A0, ZERO, ZERO
400:                                     ibuff--;
9D00903C  2673FFFF   ADDIU S3, S3, -1
401:                                     count--;
9D009040  2610FFFF   ADDIU S0, S0, -1
9D009044  321000FF   ANDI S0, S0, 255
402:                                     print(channel,"\b \b");
9D009000  3C159D01   LUI S5, -25343
9D009004  26B57E4C   ADDIU S5, S5, 32332
9D009048  0F40229C   JAL print
9D00904C  02A02821   ADDU A1, S5, ZERO
403:                                 }
404:                             }else if ((c & FN_BIT)==0){
405:                                 *ibuff++=c;
9D009058  26730001   ADDIU S3, S3, 1
406:                                 count++;
9D00905C  26100001   ADDIU S0, S0, 1
9D009060  321000FF   ANDI S0, S0, 255
407:                                 put_char(channel, c);
9D009064  00002021   ADDU A0, ZERO, ZERO
9D009068  0F402205   JAL put_char
9D00906C  7C022C20   SEB A1, V0
408:                             }
409:                         }// while
410:                         *ibuff=(char)0;
9D00907C  0B402425   J 0x9D009094
9D009080  A2600000   SB ZERO, 0(S3)
411:                     }else{
412:                         count=UartReadln(STDIN,ibuff,max_char);
9D009084  24040001   ADDIU A0, ZERO, 1
9D009088  0F404056   JAL UartReadln
9D00908C  02803021   ADDU A2, S4, ZERO
9D009090  305000FF   ANDI S0, V0, 255
413:                     }
414:                     return count;
415:                 } // readline()
9D009094  02001021   ADDU V0, S0, ZERO
9D009098  8FBF002C   LW RA, 44(SP)
9D00909C  8FB50028   LW S5, 40(SP)
9D0090A0  8FB40024   LW S4, 36(SP)
9D0090A4  8FB30020   LW S3, 32(SP)
9D0090A8  8FB2001C   LW S2, 28(SP)
9D0090AC  8FB10018   LW S1, 24(SP)
9D0090B0  8FB00014   LW S0, 20(SP)
9D0090B4  03E00008   JR RA
9D0090B8  27BD0030   ADDIU SP, SP, 48
416:                 
417:                 void invert_video(unsigned char invert){
9D0090BC  308400FF   ANDI A0, A0, 255
418:                     if (invert){
9D0090C0  10800004   BEQ A0, ZERO, 0x9D0090D4
9D0090C4  9782804E   LHU V0, -32690(GP)
419:                         flags |= INV_VID;
9D0090C8  34420004   ORI V0, V0, 4
9D0090CC  03E00008   JR RA
9D0090D0  A782804E   SH V0, -32690(GP)
420:                     }else{
421:                         flags &= ~INV_VID;
9D0090D4  3042FFFB   ANDI V0, V0, -5
9D0090D8  03E00008   JR RA
9D0090DC  A782804E   SH V0, -32690(GP)
422:                     }
423:                 }//invert_video()
---  /Volumes/home/c11067/xc32/build/xc32-XC32_v1_33_branch/src45x/gcc/gcc/libgcc2.c  -------------------
9D00D6D0  00C04821   ADDU T1, A2, ZERO
9D00DB2C  00C01021   ADDU V0, A2, ZERO
9D00D6D4  00804021   ADDU T0, A0, ZERO
9D00DB30  00804021   ADDU T0, A0, ZERO
9D00D6D8  14E0003B   BNE A3, ZERO, 0x9D00D7C8
9D00D6DC  00A01821   ADDU V1, A1, ZERO
9D00DB34  14E0003E   BNE A3, ZERO, 0x9D00DC30
9D00DB38  00A01821   ADDU V1, A1, ZERO
9D00D6E0  00A6102B   SLTU V0, A1, A2
9D00D6E4  10400048   BEQ V0, ZERO, 0x9D00D808
9D00D6E8  70C21020   CLZ V0, A2
9D00DB3C  00A6302B   SLTU A2, A1, A2
9D00DB40  10C00046   BEQ A2, ZERO, 0x9D00DC5C
9D00DB44  00000000   NOP
9D00DB48  70442020   CLZ A0, V0
9D00D6EC  10400008   BEQ V0, ZERO, 0x9D00D710
9D00D6F0  00093C02   SRL A3, T1, 16
9D00DB4C  10800008   BEQ A0, ZERO, 0x9D00DB70
9D00DB50  00022C02   SRL A1, V0, 16
9D00D700  00464804   SLLV T1, A2, V0
9D00DB60  00821004   SLLV V0, V0, A0
9D00D6F4  00022023   SUBU A0, ZERO, V0
9D00D6F8  00882006   SRLV A0, T0, A0
9D00D6FC  00451804   SLLV V1, A1, V0
9D00D704  00831825   OR V1, A0, V1
9D00DB54  00042823   SUBU A1, ZERO, A0
9D00DB58  00A82806   SRLV A1, T0, A1
9D00DB5C  00831804   SLLV V1, V1, A0
9D00DB64  00A31825   OR V1, A1, V1
9D00D708  00484004   SLLV T0, T0, V0
9D00DB68  00884004   SLLV T0, T0, A0
9D00D70C  00093C02   SRL A3, T1, 16
9D00D710  0067001B   DIVU V1, A3
9D00D714  00E001F4   TEQ A3, ZERO
9D00D718  312BFFFF   ANDI T3, T1, -1
9D00D71C  00082C02   SRL A1, T0, 16
9D00D720  00005012   MFLO T2, 0
9D00D724  00002010   MFHI A0, 0
9D00D728  714B5002   MUL T2, T2, T3
9D00D72C  00043400   SLL A2, A0, 16
9D00D730  00C53025   OR A2, A2, A1
9D00D734  00CA602B   SLTU T4, A2, T2
9D00D738  0067001B   DIVU V1, A3
9D00D73C  00E001F4   TEQ A3, ZERO
9D00D740  51800009   BEQL T4, ZERO, 0x9D00D768
9D00D744  00CA3023   SUBU A2, A2, T2
9D00D748  00C93021   ADDU A2, A2, T1
9D00D74C  00C9182B   SLTU V1, A2, T1
9D00D750  54600005   BNEL V1, ZERO, 0x9D00D768
9D00D754  00CA3023   SUBU A2, A2, T2
9D00D758  00CA202B   SLTU A0, A2, T2
9D00D75C  00C91821   ADDU V1, A2, T1
9D00D760  0064300B   MOVN A2, V1, A0
9D00D764  00CA3023   SUBU A2, A2, T2
9D00D768  00C7001B   DIVU A2, A3
9D00D76C  00E001F4   TEQ A3, ZERO
9D00D770  3108FFFF   ANDI T0, T0, -1
9D00D774  00002012   MFLO A0, 0
9D00D778  00001810   MFHI V1, 0
9D00D77C  708B2002   MUL A0, A0, T3
9D00D780  00031C00   SLL V1, V1, 16
9D00D784  00684025   OR T0, V1, T0
9D00D788  0104182B   SLTU V1, T0, A0
9D00D78C  00C7001B   DIVU A2, A3
9D00D790  00E001F4   TEQ A3, ZERO
9D00D794  50600009   BEQL V1, ZERO, 0x9D00D7BC
9D00D798  01044023   SUBU T0, T0, A0
9D00D79C  01094021   ADDU T0, T0, T1
9D00D7A0  0109182B   SLTU V1, T0, T1
9D00D7A4  54600005   BNEL V1, ZERO, 0x9D00D7BC
9D00D7A8  01044023   SUBU T0, T0, A0
9D00D7AC  0104182B   SLTU V1, T0, A0
9D00D7B0  01094821   ADDU T1, T0, T1
9D00D7B4  0123400B   MOVN T0, T1, V1
9D00D7B8  01044023   SUBU T0, T0, A0
9D00DB6C  00022C02   SRL A1, V0, 16
9D00DB70  0065001B   DIVU V1, A1
9D00DB74  00A001F4   TEQ A1, ZERO
9D00DB78  3049FFFF   ANDI T1, V0, -1
9D00DB7C  00086402   SRL T4, T0, 16
9D00DB80  00005012   MFLO T2, 0
9D00DB84  00005810   MFHI T3, 0
9D00DB88  71492002   MUL A0, T2, T1
9D00DB8C  000B3C00   SLL A3, T3, 16
9D00DB90  00EC3825   OR A3, A3, T4
9D00DB94  00E4302B   SLTU A2, A3, A0
9D00DB98  0065001B   DIVU V1, A1
9D00DB9C  00A001F4   TEQ A1, ZERO
9D00DBA0  10C0000B   BEQ A2, ZERO, 0x9D00DBD0
9D00DBA4  00E41823   SUBU V1, A3, A0
9D00DBA8  00E23821   ADDU A3, A3, V0
9D00DBAC  00E2182B   SLTU V1, A3, V0
9D00DBB0  14600006   BNE V1, ZERO, 0x9D00DBCC
9D00DBB4  254AFFFF   ADDIU T2, T2, -1
9D00DBB8  00E4182B   SLTU V1, A3, A0
9D00DBBC  10600004   BEQ V1, ZERO, 0x9D00DBD0
9D00DBC0  00E41823   SUBU V1, A3, A0
9D00DBC4  254AFFFF   ADDIU T2, T2, -1
9D00DBC8  00E23821   ADDU A3, A3, V0
9D00DBCC  00E41823   SUBU V1, A3, A0
9D00DBD0  0065001B   DIVU V1, A1
9D00DBD4  00A001F4   TEQ A1, ZERO
9D00DBD8  3108FFFF   ANDI T0, T0, -1
9D00DBDC  00002012   MFLO A0, 0
9D00DBE0  00003810   MFHI A3, 0
9D00DBE4  70894802   MUL T1, A0, T1
9D00DBE8  00073C00   SLL A3, A3, 16
9D00DBEC  00E84025   OR T0, A3, T0
9D00DBF0  0109302B   SLTU A2, T0, T1
9D00DBF4  0065001B   DIVU V1, A1
9D00DBF8  00A001F4   TEQ A1, ZERO
9D00DBFC  10C00006   BEQ A2, ZERO, 0x9D00DC18
9D00DC00  01024021   ADDU T0, T0, V0
9D00DC04  0102102B   SLTU V0, T0, V0
9D00DC08  14400003   BNE V0, ZERO, 0x9D00DC18
9D00DC0C  2484FFFF   ADDIU A0, A0, -1
9D00DC10  0109482B   SLTU T1, T0, T1
9D00DC14  00892023   SUBU A0, A0, T1
9D00DC18  000A4C00   SLL T1, T2, 16
9D00DC1C  00894825   OR T1, A0, T1
9D00DC20  00002821   ADDU A1, ZERO, ZERO
9D00D808  14C00006   BNE A2, ZERO, 0x9D00D824
9D00D80C  71221020   CLZ V0, T1
9D00DC5C  14400006   BNE V0, ZERO, 0x9D00DC78
9D00D810  24020001   ADDIU V0, ZERO, 1
9D00D814  0046001B   DIVU V0, A2
9D00D818  00C001F4   TEQ A2, ZERO
9D00D81C  00004812   MFLO T1, 0
9D00DC64  24030001   ADDIU V1, ZERO, 1
9D00D820  71221020   CLZ V0, T1
9D00DC74  70431820   CLZ V1, V0
9D00D824  54400082   BNEL V0, ZERO, 0x9D00DA30
9D00D828  24080020   ADDIU T0, ZERO, 32
9D00DC78  5460007A   BNEL V1, ZERO, 0x9D00DE64
9D00D82C  00A92823   SUBU A1, A1, T1
9D00D830  00091C02   SRL V1, T1, 16
9D00D834  3127FFFF   ANDI A3, T1, -1
9D00DC80  00A24823   SUBU T1, A1, V0
9D00DC8C  24050001   ADDIU A1, ZERO, 1
9D00DA30  01024023   SUBU T0, T0, V0
9D00DE64  01034023   SUBU T0, T0, V1
9D00DA34  00494804   SLLV T1, T1, V0
9D00DE68  00621004   SLLV V0, V0, V1
9D00DA38  01053006   SRLV A2, A1, T0
9D00DE6C  01053006   SRLV A2, A1, T0
9D00DA4C  01045806   SRLV T3, A0, T0
9D00DE80  00652804   SLLV A1, A1, V1
9D00DE8C  01254825   OR T1, T1, A1
9D00DA5C  00444004   SLLV T0, A0, V0
9D00DE88  00644004   SLLV T0, A0, V1
9D00DA3C  00091C02   SRL V1, T1, 16
9D00DA58  000B2C02   SRL A1, T3, 16
9D00DA60  00005012   MFLO T2, 0
9D00DB08  00892821   ADDU A1, A0, T1
9D00DE70  00023C02   SRL A3, V0, 16
9D00DE90  00096C02   SRL T5, T1, 16
9D00D838  00A3001B   DIVU A1, V1
9D00D83C  006001F4   TEQ V1, ZERO
9D00D840  00085C02   SRL T3, T0, 16
9D00D844  00002012   MFLO A0, 0
9D00D848  00005010   MFHI T2, 0
9D00D84C  70872002   MUL A0, A0, A3
9D00D850  000A3400   SLL A2, T2, 16
9D00D854  00CB3025   OR A2, A2, T3
9D00D858  00C4502B   SLTU T2, A2, A0
9D00D85C  00A3001B   DIVU A1, V1
9D00D860  006001F4   TEQ V1, ZERO
9D00D864  51400009   BEQL T2, ZERO, 0x9D00D88C
9D00D868  00C43023   SUBU A2, A2, A0
9D00D86C  00C93021   ADDU A2, A2, T1
9D00D870  00C9282B   SLTU A1, A2, T1
9D00D874  54A00005   BNEL A1, ZERO, 0x9D00D88C
9D00D878  00C43023   SUBU A2, A2, A0
9D00D87C  00C4502B   SLTU T2, A2, A0
9D00D880  00C92821   ADDU A1, A2, T1
9D00D884  00AA300B   MOVN A2, A1, T2
9D00D888  00C43023   SUBU A2, A2, A0
9D00D88C  00C3001B   DIVU A2, V1
9D00D890  006001F4   TEQ V1, ZERO
9D00D894  3108FFFF   ANDI T0, T0, -1
9D00D898  00002012   MFLO A0, 0
9D00D89C  00002810   MFHI A1, 0
9D00D8A0  70873802   MUL A3, A0, A3
9D00D8A4  00052C00   SLL A1, A1, 16
9D00D8A8  00A84025   OR T0, A1, T0
9D00D8AC  0107202B   SLTU A0, T0, A3
9D00D8B0  00C3001B   DIVU A2, V1
9D00D8B4  006001F4   TEQ V1, ZERO
9D00D8B8  50800009   BEQL A0, ZERO, 0x9D00D8E0
9D00D8BC  01074023   SUBU T0, T0, A3
9D00D8C0  01094021   ADDU T0, T0, T1
9D00D8C4  0109182B   SLTU V1, T0, T1
9D00D8C8  54600005   BNEL V1, ZERO, 0x9D00D8E0
9D00D8CC  01074023   SUBU T0, T0, A3
9D00D8D0  0107182B   SLTU V1, T0, A3
9D00D8D4  01094821   ADDU T1, T0, T1
9D00D8D8  0123400B   MOVN T0, T1, V1
9D00D8DC  01074023   SUBU T0, T0, A3
9D00DC90  0127001B   DIVU T1, A3
9D00DF70  0B403738   J 0x9D00DCE0
9D00D7BC  00481006   SRLV V0, T0, V0
9D00D8E0  00481006   SRLV V0, T0, V0
9D00D7C0  03E00008   JR RA
9D00D7C4  00001821   ADDU V1, ZERO, ZERO
9D00D8E4  03E00008   JR RA
9D00D8E8  00001821   ADDU V1, ZERO, ZERO
9D00D7C8  00A7102B   SLTU V0, A1, A3
9D00D7CC  14400047   BNE V0, ZERO, 0x9D00D8EC
9D00D7D0  70EA5020   CLZ T2, A3
9D00DC30  00A7102B   SLTU V0, A1, A3
9D00DD40  00004821   ADDU T1, ZERO, ZERO
9D00D8EC  00801021   ADDU V0, A0, ZERO
9D00D8F0  03E00008   JR RA
9D00D8F4  00A01821   ADDU V1, A1, ZERO
9D00DC3C  70E31820   CLZ V1, A3
9D00D7D4  15400048   BNE T2, ZERO, 0x9D00D8F8
9D00D7D8  240C0020   ADDIU T4, ZERO, 32
9D00DC40  14600043   BNE V1, ZERO, 0x9D00DD50
9D00D7DC  00E5102B   SLTU V0, A3, A1
9D00D7E0  14400005   BNE V0, ZERO, 0x9D00D7F8
9D00D7E4  00861023   SUBU V0, A0, A2
9D00D7E8  0086102B   SLTU V0, A0, A2
9D00D7EC  544000CD   BNEL V0, ZERO, 0x9D00DB24
9D00D7F0  00801021   ADDU V0, A0, ZERO
9D00DC48  00E5282B   SLTU A1, A3, A1
9D00DF64  00002821   ADDU A1, ZERO, ZERO
9D00D7F4  00861023   SUBU V0, A0, A2
9D00D7F8  00A72823   SUBU A1, A1, A3
9D00D7FC  0082202B   SLTU A0, A0, V0
9D00D800  03E00008   JR RA
9D00D804  00A41823   SUBU V1, A1, A0
9D00D8F8  018A6023   SUBU T4, T4, T2
9D00DD50  01435023   SUBU T2, T2, V1
9D00D8FC  01473804   SLLV A3, A3, T2
9D00D900  01865806   SRLV T3, A2, T4
9D00D904  01675825   OR T3, T3, A3
9D00DD54  01461006   SRLV V0, A2, T2
9D00D92C  01463004   SLLV A2, A2, T2
9D00D908  01856806   SRLV T5, A1, T4
9D00DD60  01454806   SRLV T1, A1, T2
9D00D91C  01841006   SRLV V0, A0, T4
9D00D920  01452804   SLLV A1, A1, T2
9D00D924  00452825   OR A1, V0, A1
9D00DD74  01445006   SRLV T2, A0, T2
9D00D90C  000B3C02   SRL A3, T3, 16
9D00D910  01A7001B   DIVU T5, A3
9D00D914  00E001F4   TEQ A3, ZERO
9D00D918  316FFFFF   ANDI T7, T3, -1
9D00D928  00051402   SRL V0, A1, 16
9D00D930  00007012   MFLO T6, 0
9D00D934  00001810   MFHI V1, 0
9D00D938  71CFC002   MUL T8, T6, T7
9D00D93C  00034C00   SLL T1, V1, 16
9D00D940  01224825   OR T1, T1, V0
9D00D944  0138102B   SLTU V0, T1, T8
9D00D948  01A7001B   DIVU T5, A3
9D00D94C  00E001F4   TEQ A3, ZERO
9D00D950  1040000A   BEQ V0, ZERO, 0x9D00D97C
9D00D954  01442004   SLLV A0, A0, T2
9D00D958  012B4821   ADDU T1, T1, T3
9D00D95C  012B102B   SLTU V0, T1, T3
9D00D960  14400006   BNE V0, ZERO, 0x9D00D97C
9D00D964  25CEFFFF   ADDIU T6, T6, -1
9D00D968  0138102B   SLTU V0, T1, T8
9D00D96C  50400004   BEQL V0, ZERO, 0x9D00D980
9D00D970  01384823   SUBU T1, T1, T8
9D00D974  25CEFFFF   ADDIU T6, T6, -1
9D00D978  012B4821   ADDU T1, T1, T3
9D00D97C  01384823   SUBU T1, T1, T8
9D00D980  0127001B   DIVU T1, A3
9D00D984  00E001F4   TEQ A3, ZERO
9D00D988  30A5FFFF   ANDI A1, A1, -1
9D00D98C  00006812   MFLO T5, 0
9D00D990  00001810   MFHI V1, 0
9D00D994  71AF7802   MUL T7, T5, T7
9D00D998  00031400   SLL V0, V1, 16
9D00D99C  00451025   OR V0, V0, A1
9D00D9A0  004F182B   SLTU V1, V0, T7
9D00D9A4  0127001B   DIVU T1, A3
9D00D9A8  00E001F4   TEQ A3, ZERO
9D00D9AC  1060000B   BEQ V1, ZERO, 0x9D00D9DC
9D00D9B0  000E4400   SLL T0, T6, 16
9D00D9B4  004B1021   ADDU V0, V0, T3
9D00D9B8  004B182B   SLTU V1, V0, T3
9D00D9BC  14600007   BNE V1, ZERO, 0x9D00D9DC
9D00D9C0  25ADFFFF   ADDIU T5, T5, -1
9D00D9C4  004F182B   SLTU V1, V0, T7
9D00D9C8  10600005   BEQ V1, ZERO, 0x9D00D9E0
9D00D9CC  01A84025   OR T0, T5, T0
9D00D9D0  25ADFFFF   ADDIU T5, T5, -1
9D00D9D4  004B1021   ADDU V0, V0, T3
9D00D9D8  000E4400   SLL T0, T6, 16
9D00D9DC  01A84025   OR T0, T5, T0
9D00D9E4  004F7823   SUBU T7, V0, T7
9D00DD64  00071402   SRL V0, A3, 16
9D00DD80  00055402   SRL T2, A1, 16
9D00DE38  00AC2823   SUBU A1, A1, T4
9D00D9E0  01060019   MULTU 0, T0, A2
9D00D9E8  00004810   MFHI T1, 0
9D00D9EC  00004012   MFLO T0, 0
9D00D9F4  01201821   ADDU V1, T1, ZERO
9D00D9F8  01203821   ADDU A3, T1, ZERO
9D00DE34  01260019   MULTU 0, T1, A2
9D00DE3C  00003810   MFHI A3, 0
9D00D9F0  01E9282B   SLTU A1, T7, T1
9D00D9FC  14A0003D   BNE A1, ZERO, 0x9D00DAF4
9D00DA00  00001012   MFLO V0, 0
9D00DA04  51E90043   BEQL T7, T1, 0x9D00DB14
9D00DA08  0082182B   SLTU V1, A0, V0
9D00DB14  5460FFF8   BNEL V1, ZERO, 0x9D00DAF8
9D00DE40  00A7402B   SLTU T0, A1, A3
9D00DF4C  0086302B   SLTU A2, A0, A2
9D00DE54  00002821   ADDU A1, ZERO, ZERO
9D00DF58  2529FFFF   ADDIU T1, T1, -1
9D00DA0C  01E31823   SUBU V1, T7, V1
9D00DAF4  00464023   SUBU T0, V0, A2
9D00DA10  00883023   SUBU A2, A0, T0
9D00DA14  0086202B   SLTU A0, A0, A2
9D00DA18  00641823   SUBU V1, V1, A0
9D00DA1C  01836004   SLLV T4, V1, T4
9D00DA20  01461006   SRLV V0, A2, T2
9D00DA24  004C1025   OR V0, V0, T4
9D00DC24  01201021   ADDU V0, T1, ZERO
9D00DD34  01201021   ADDU V0, T1, ZERO
9D00DD44  01201021   ADDU V0, T1, ZERO
9D00DE58  01201021   ADDU V0, T1, ZERO
9D00DA28  03E00008   JR RA
9D00DC28  03E00008   JR RA
9D00DD38  03E00008   JR RA
9D00DD48  03E00008   JR RA
9D00DE5C  03E00008   JR RA
9D015CD0  27BDFFE0   ADDIU SP, SP, -32
9D015CD4  AFBF001C   SW RA, 28(SP)
9D015CD8  AFB20018   SW S2, 24(SP)
9D015CDC  AFB10014   SW S1, 20(SP)
9D015CE0  AFB00010   SW S0, 16(SP)
9D015CE4  10A00027   BEQ A1, ZERO, 0x9D015D84
9D015CE8  00801021   ADDU V0, A0, ZERO
9D015D84  0F405D24   JAL __floatunsisf
9D015D88  00000000   NOP
9D015CEC  70A42020   CLZ A0, A1
9D015CF0  24110020   ADDIU S1, ZERO, 32
9D015CF4  02248023   SUBU S0, S1, A0
9D015CF8  00053040   SLL A2, A1, 1
9D015CFC  00101827   NOR V1, ZERO, S0
9D015D00  00663004   SLLV A2, A2, V1
9D015D04  02021806   SRLV V1, V0, S0
9D015D08  00C31825   OR V1, A2, V1
9D015D0C  02052806   SRLV A1, A1, S0
9D015D10  32060020   ANDI A2, S0, 32
9D015D14  0066280A   MOVZ A1, V1, A2
9D015D18  00822004   SLLV A0, V0, A0
9D015D1C  34A30001   ORI V1, A1, 1
9D015D20  0064280B   MOVN A1, V1, A0
9D015D24  0F405D24   JAL __floatunsisf
9D015D28  00A02021   ADDU A0, A1, ZERO
9D015D2C  1211000F   BEQ S0, S1, 0x9D015D6C
9D015D30  00409021   ADDU S2, V0, ZERO
9D015D6C  3C029D01   LUI V0, -25343
9D015D70  0B405753   J 0x9D015D4C
9D015D74  8C457E58   LW A1, 32344(V0)
9D015D34  2402001F   ADDIU V0, ZERO, 31
9D015D38  1202000F   BEQ S0, V0, 0x9D015D78
9D015D3C  24040001   ADDIU A0, ZERO, 1
9D015D78  3C029D01   LUI V0, -25343
9D015D7C  0B405753   J 0x9D015D4C
9D015D80  8C457E5C   LW A1, 32348(V0)
9D015D40  0F405C4A   JAL sitofp
9D015D44  02042004   SLLV A0, A0, S0
9D015D48  00402821   ADDU A1, V0, ZERO
9D015D4C  0F404C28   JAL __mulsf3
9D015D50  02402021   ADDU A0, S2, ZERO
9D015D54  8FBF001C   LW RA, 28(SP)
9D015D58  8FB20018   LW S2, 24(SP)
9D015D5C  8FB10014   LW S1, 20(SP)
9D015D60  8FB00010   LW S0, 16(SP)
9D015D64  03E00008   JR RA
9D015D68  27BD0020   ADDIU SP, SP, 32
9D015D8C  8FBF001C   LW RA, 28(SP)
9D015D90  8FB20018   LW S2, 24(SP)
9D015D94  8FB10014   LW S1, 20(SP)
9D015D98  8FB00010   LW S0, 16(SP)
9D015D9C  03E00008   JR RA
9D015DA0  27BD0020   ADDIU SP, SP, 32
---  /Volumes/home/c11067/xc32/build/xc32-XC32_v1_33_branch/src45x/gcc/gcc/config/floatunsisf.c  --------
9D017490  27BDFFE8   ADDIU SP, SP, -24
9D017494  AFBF0014   SW RA, 20(SP)
9D017498  04800006   BLTZ A0, 0x9D0174B4
9D01749C  00801021   ADDU V0, A0, ZERO
9D0174B4  30420001   ANDI V0, V0, 1
9D0174B8  00042042   SRL A0, A0, 1
9D0174BC  0F405C4A   JAL sitofp
9D0174C0  00822025   OR A0, A0, V0
9D0174C4  00402021   ADDU A0, V0, ZERO
9D0174C8  0F404742   JAL fpadd
9D0174CC  00402821   ADDU A1, V0, ZERO
9D0174A0  0F405C4A   JAL sitofp
9D0174A4  00000000   NOP
9D0174A8  8FBF0014   LW RA, 20(SP)
9D0174AC  03E00008   JR RA
9D0174B0  27BD0018   ADDIU SP, SP, 24
9D0174D0  8FBF0014   LW RA, 20(SP)
9D0174D4  03E00008   JR RA
9D0174D8  27BD0018   ADDIU SP, SP, 24
